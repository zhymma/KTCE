{"Basic Operations": ["def basic_arithmetic(a, b, operator):\n    \"\"\"\n    Perform basic arithmetic operations between two numbers.\n    Parameters:\n    - a : float\n        First operand in the operation.\n    - b : float\n        Second operand in the operation.\n    - operator : str\n        The operation to perform. Expected values: '+', '-', '*', '/', '%', '**'\n    Returns:\n    - float or int\n        The result of the arithmetic operation.\n    Examples:\n    >>> basic_arithmetic(5, 3, '+')\n    8\n    >>> basic_arithmetic(10, 2, '/')\n    5.0\n    >>> basic_arithmetic(4, 3, '**')\n    64\n    \"\"\"\n    if operator == '+':\n        return a + b\n    elif operator == '-':\n        return a - b\n    elif operator == '*':\n        return a * b\n    elif operator == '/':\n        if b != 0:\n            return a / b\n        else:\n            raise ValueError(\"Division by zero is undefined.\")\n    elif operator == '%':\n        return a % b\n    elif operator == '**':\n        return a ** b", "def multiply_fractions(frac1, frac2):\n    \"\"\"\n    Multiply two fractions.\n    \n    Parameters:\n    - fratc1 (Fraction): First fraction to multiply.\n    - fratc2 (Fraction): Second fraction to multiply.\n    \n    Returns:\n    - Fraction: The product of the two fractions.\n    \n    Examples:\n    >>> multiply_fractions(Fraction(1, 2), Fraction(2, 3))\n    Fraction(1, 3)\n    \"\"\"\n    return frac1 * frac2", "def divide(a, b):\n    \"\"\"\n    Divides the first number by the second.\n    Parameters:\n        a (float): The dividend.\n        b (float): The divisor (should not be zero).\n    Returns:\n        float: The quotient of a divided by b.\n    Raises:\n        ValueError: If b is zero.\n    \"\"\"\n    if b == 0:\n        raise ValueError(\"The divisor cannot be zero.\")\n    return a / b", "def subtract_numbers(a, b):\n    \"\"\"\n    Subtract the second number from the first.\n    Parameters:\n    a (float|int): The number from which b is to be subtracted.\n    b (float|int): The number to subtract from a.\n    Returns:\n    float|int: The result of the subtraction, a - b.\n    Examples:\n    >>> subtract_numbers(10, 5)\n    5\n    >>> subtract_numbers(5, 10)\n    -5\n    \"\"\"\n    return a - b", "def add(*args):\n    \"\"\"\n    Sum a list of numbers.\n    Parameters:\n        *args (float or int): A set of numbers to be added.\n    Returns:\n        float: The sum of all the numbers.\n    Examples:\n        >>> add(1, 2, 3)\n        6\n        >>> add(10.5, 2.3)\n        12.8\n    \"\"\"\n    return sum(args)", "def convert_fraction_to_decimal(fraction_string):\n    \"\"\"\n    Convert a fraction represented as a string to a decimal value.\n    Parameters:\n        fraction_string (str): A string representation of the fraction ('numerator/denominator').\n    Returns:\n        float: Decimal representation of the fraction.\n    Examples:\n        >>> convert_fraction_to_decimal('1/3')\n        0.3333333333333333\n        >>> convert_fraction_to_decimal('2/5')\n        0.4\n    \"\"\"\n    from fractions import Fraction\n    return float(Fraction(fraction_string))", "def multiply(*args):\n    \"\"\"\n    Returns the product of the provided arguments.\n    Parameters:\n    args (float or int): A sequence of numbers that will be multiplied together.\n    Returns:\n    float or int: Product of all the numbers provided as arguments.\n    Examples:\n    >>> multiply(2, 3)\n    6\n    >>> multiply(2, 3, 4)\n    24\n    \"\"\"\n    from functools import reduce\n    from operator import mul\n    return reduce(mul, args, 1)", "def add(a, b):\n    \"\"\"\n    Adds two numbers and returns the result.\n    Parameters:\n    a (float|int): First operand\n    b (float|int): Second operand\n    Returns:\n    float|int: The sum of the two numbers.\n    \"\"\"\n    return a + b", "def multiply_numbers(a, b):\n    \"\"\"\n    Multiply two numbers.\n    \n    Parameters:\n    - a (int or float): First operand.\n    - b (int or float): Second operand.\n    \n    Returns:\n    - float: The product of the inputs.\n    \n    Examples:\n    >>> multiply_numbers(3, 4)\n    12\n    >>> multiply_numbers(1.5, 2)\n    3.0\n    \"\"\"\n    return a * b", "def operate_on_fractions(a, b, operation='add'):\n    \"\"\"\n    Perform arithmetic operations on two fractions.\n    \n    Parameters:\n        a (str or Fraction): First fraction (as a Fraction object or a string like '3/4').\n        b (str or Fraction): Second fraction (same format as the first).\n        operation (str): The operation to perform ('add', 'subtract', 'multiply', 'divide').\n    \n    Returns:\n        Fraction: Result of the operation as a simplified fraction.\n    \n    Raises:\n        ValueError: If the operation type is invalid.\n        \n    Examples:\n        >>> operate_on_fractions('1/2', '1/3', 'add')\n        Fraction(5, 6)\n        >>> operate_on_fractions('1/2', '1/3', 'multiply')\n        Fraction(1, 6)\n    \"\"\"\n    a = Fraction(a)\n    b = Fraction(b)\n    if operation == 'add':\n        return a + b\n    elif operation == 'subtract':\n        return a - b\n    elif operation == 'multiply':\n        return a * b\n    elif operation == 'divide':\n        return a / b\n    else:\n        raise ValueError(\"Invalid operation type\")", "def area(shape, *dimensions):\n    \"\"\"\n    Calculate the area of various shapes.\n    \n    Parameters\n    ----------\n    shape : str\n        The shape to calculate the area for. Options are 'circle', 'rectangle', 'triangle', 'square'.\n    *dimensions : float\n        The dimensions required for the shape.\n        - Circle: radius\n        - Rectangle: length, width\n        - Triangle: base, height\n        - Square: side length\n        \n    Returns\n    -------\n    float\n        The area of the specified shape.\n    \n    Examples\n    --------\n    >>> area('circle', 5)\n    78.53981633974483\n    \n    >>> area('rectangle', 4, 5)\n    20\n    \n    >>> area('triangle', 3, 4)\n    6\n    \n    >>> area('square', 4)\n    16\n    \"\"\"\n    if shape == 'circle':\n        if len(dimensions) == 1:\n            radius = dimensions[0]\n            return math.pi * (radius ** 2)\n        else:\n            raise ValueError(\"Circle requires 1 dimension (radius).\")\n    elif shape == 'rectangle':\n        if len(dimensions) == 2:\n            length, width = dimensions\n            return length * width\n        else:\n            raise ValueError(\"Rectangle requires 2 dimensions (length, width).\")\n    elif shape == 'triangle':\n        if len(dimensions) == 2:\n            base, height = dimensions\n            return 0.5 * base * height\n        else:\n            raise ValueError(\"Triangle requires 2 dimensions (base, height).\")\n    elif shape == 'square':\n        if len(dimensions) == 1:\n            side = dimensions[0]\n            return side ** 2\n        else:\n            raise ValueError(\"Square requires 1 dimension (side length).\")\n    else:\n        raise ValueError(\"Invalid shape specified.\")", "def exponentiate(base, exponent):\n    \"\"\"\n    Raise a given number to the power of the exponent.\n    Parameters:\n    base (float|int): The base number.\n    exponent (float|int): The exponent to which the base is raised.\n    Returns:\n    float|int: The result of the power operation.\n    Examples:\n    >>> exponentiate(2, 3)\n    8\n    >>> exponentiate(5, 2)\n    25\n    \"\"\"\n    return pow(base, exponent)", "def sum_of_numbers(numbers):\n    \"\"\"\n    Sum a list of numbers.\n    Parameters:\n    - numbers (list of numbers): The list of numbers to sum up.\n    Returns:\n    - number: The sum of the numbers in the list.\n    Example:\n    >>> sum_of_numbers([1, 2, 3, 4])\n    10\n    \"\"\"\n    return sum(numbers)", "def sum_of_digits(number):\n    \"\"\"\n    Calculates the sum of all digits in an integer.\n    Parameters:\n    - number (int): The number whose digits are to be summed.\n    Returns:\n    - int: The sum of the digits of the number.\n    Example:\n    >>> sum_of_digits(1234)\n    10\n    \"\"\"\n    return sum(int(digit) for digit in str(abs(number)))", "def convert_time_hours_to_minutes(hours):\n    \"\"\"\n    Converts time from hours to minutes.\n    Parameters:\n        hours (float or int): Time in hours.\n    Returns:\n        float: Time in minutes.\n    Examples:\n        >>> convert_time_hours_to_minutes(2)\n        120\n        >>> convert_time_hours_to_minutes(1.5)\n        90\n    \"\"\"\n    return hours * 60", "def evaluate_expression(expression):\n    \"\"\"\n    Evaluate a mathematical expression string adhering to the order of operations (PEMDAS/BODMAS).\n    Parameters:\n        expression (str): A string representing the mathematical expression to be evaluated.\n    Returns:\n        sympy.core.expr.Expr: The result of the evaluated expression, which can be numeric or symbolic.\n    Examples:\n        >>> evaluate_expression(\"3 + 2 * (1 + 5)\")\n        15\n        >>> evaluate_expression(\"(2 + 3) * 5 - 3**2\")\n        16\n        >>> evaluate_expression(\"2*3 + (4*5) / 2 - 3\")\n        13.0\n    \"\"\"\n    # Convert the input string expression to a sympy expression\n    sympy_expression = sp.sympify(expression)\n    \n    # Evaluate the expression\n    result = sympy_expression\n    return result\n    print(evaluate_expression(\"3 + 2 * (1 + 5)\"))  # Should print 15\n    print(evaluate_expression(\"(2 + 3) * 5 - 3**2\"))  # Should print 16\n    print(evaluate_expression(\"2*3 + (4*5) / 2 - 3\"))  # Should print 13.0", "def compute_mean(numbers):\n    \"\"\"\n    Computes the arithmetic mean of a list of numbers.\n    Parameters:\n    numbers (list of float|int): A list containing numbers whose mean is to be calculated.\n    Returns:\n    float: The arithmetic mean of the numbers.\n    Raises:\n    ValueError: If the list is empty.\n    \"\"\"\n    if not numbers:\n        raise ValueError(\"The list of numbers cannot be empty.\")\n    return sum(numbers) / len(numbers)", "def is_divisible(number, divisor):\n    \"\"\"Check if the number is divisible by the divisor.\n    \n    Parameters:\n        number (int): The number to check.\n        divisor (int): The divisor to check against.\n        \n    Returns:\n        bool: True if number is divisible by divisor, otherwise False.\n    \n    Examples:\n        >>> is_divisible(10, 2)\n        True\n        >>> is_divisible(10, 3)\n        False\n    \"\"\"\n    return number % divisor == 0", "def sum_values(*args, operation='sum'):\n    \"\"\"\n    Performs basic arithmetic operations: sum, subtraction, multiplication, or division on a given set of values.\n    \n    Parameters:\n    - args (float or int): A set of numeric values to perform operations on.\n    - operation (str): Type of operation; can be 'sum', 'subtract', 'multiply', or 'divide'. Default is 'sum'.\n    \n    Returns:\n    - float or int: Result of the arithmetic operation.\n    \n    Examples:\n    - sum_values(1, 2, 3, 4) should return 10.\n    - sum_values(1, 2, 3, 4, operation='multiply') should return 24.\n    - sum_values(10, 2, operation='subtract') should return 8.\n    - sum_values(100, 10, operation='divide') should return 10.\n    \"\"\"\n    import operator\n    from functools import reduce\n    \n    operations = {\n        'sum': operator.add,\n        'subtract': operator.sub,\n        'multiply': operator.mul,\n        'divide': operator.truediv\n    }\n    \n    if operation in operations and len(args) > 1:\n        return reduce(operations[operation], args)\n    elif len(args) == 1:\n        return args[0]\n    else:\n        raise ValueError(\"Unsupported operation or insufficient arguments\")", "def lcm(a, b):\n    \"\"\"\n    Compute the least common multiple of two numbers based on their GCD.\n    Parameters:\n    a (int): The first number.\n    b (int): The second number.\n    Returns:\n    int: The least common multiple of a and b.\n    Examples:\n    >>> lcm(4, 5)\n    20\n    >>> lcm(12, 6)\n    12\n    \"\"\"\n    return abs(a*b) // gcd(a, b)", "def alternating_sum(numbers):\n    \"\"\"\n    Computes alternating sum of elements in a list.\n    Parameters:\n    - numbers (list of numbers): A list containing the numerical sequence.\n    Returns:\n    - number: Alternating sum of the sequence.\n    Example:\n    >>> alternating_sum([1, 2, 3, 4])\n    -2  # 1 - 2 + 3 - 4\n    \"\"\"\n    return sum((-1)**i * x for i, x in enumerate(numbers))", "def round_to_nearest(number, precision):\n    \"\"\"Round a number to a specified precision.\n    Parameters:\n        number (float): The number to round.\n        precision (int): The number of decimal places to round to.\n    Returns:\n        float: The rounded number.\n    Examples:\n        >>> round_to_nearest(3.14159, 2)\n        3.14\n        >>> round_to_nearest(300.987654, -2)\n        300.0\n    \"\"\"\n    return round(number, precision)", "def simplify_fraction(numer, denom):\n    \"\"\"Simplify a fraction by dividing both numerator and denominator by their GCD.\n    Parameters:\n    - numer (int) : The numerator of the fraction.\n    - denom (int) : The denominator of the fraction.\n    Returns:\n    Fraction : A simplified Fraction object.\n    \"\"\"\n    common_divisor = gcd(numer, denom)\n    return Fraction(numer//common_divisor, denom//common_divisor)", "def prime_factorization(n):\n    \"\"\"\n    Calculate the prime factors of a given integer.\n    Parameters:\n    - n : int\n        The number to factorize.\n    Returns:\n    - list\n        A list of the prime factors of the number.\n    Examples:\n    >>> prime_factorization(60)\n    [2, 2, 3, 5]\n    >>> prime_factorization(100)\n    [2, 2, 5, 5]\n    \"\"\"\n    import math\n    factors = []\n    while n % 2 == 0:\n        factors.append(2)\n        n = n // 2\n        \n    for i in range(3, int(math.sqrt(n)) + 1, 2):\n        while (n % i == 0):\n            factors.append(i)\n            n = n // i\n            \n    if n > 2:\n        factors.append(n)\n        \n    return factors", "def calculate_exponentiation_and_roots(base, exponent):\n    \"\"\"\n    Perform exponentiation and calculate roots as special cases (e.g., square root or cube root). \n    Parameters:\n    - base : float\n        Base of the exponentiation.\n    - exponent : float\n        Exponent for the operation. If the exponent is fractional, it calculates the root.\n    Returns:\n    - float\n        Result of the exponentiation or root calculation.\n    Examples:\n    >>> calculate_exponentiation_and_roots(2, 3)\n    8\n    >>> calculate_exponentiation_and_roots(9, 0.5)\n    3.0\n    \"\"\"\n    \n    return base ** exponent", "def calculate_simple_interest(principal, rate, time):\n    \"\"\"\n    Calculate simple interest.\n    Parameters:\n    - principal (float|int): The initial amount of money.\n    - rate (float): The interest rate (expressed as a fraction of 1 for easiness, i.e., 10% as 0.1).\n    - time (float|int): The time period for which the interest is calculated.\n    Returns:\n    - amount (float): The total amount accumulated after the interest.\n    Examples:\n    >>> calculate_simple_interest(1000, 0.05, 3)\n    1150.0\n    \"\"\"\n    return principal * (1 + rate * time)", "def sequence_expression_evaluation(sequence, expression):\n    \"\"\"\n    Evaluate a numerical expression on each term of the sequence.\n    Parameters:\n    - sequence (list of int or float): A list containing the numerical sequence.\n    - expression (callable): A function that takes a single argument and returns a number.\n    Returns:\n    - list of int or float: The sequence after applying the expression to each term.\n    Examples:\n    >>> sequence_expression_evaluation([1, 2, 3, 4], lambda x: x**2 - x + 1)\n    [1, 3, 7, 13]\n    \"\"\"\n    return [expression(x) for x in sequence]", "def proportional_scaling(value, scale_factor):\n    \"\"\"\n    Scale a value by a given factor.\n    \n    Parameters\n    ----------\n    value : float or int\n        The original value to be scaled.\n    scale_factor : float or int\n        The factor by which the value will be scaled.\n    \n    Returns\n    -------\n    float or int\n        The scaled value.\n    \n    Examples\n    --------\n    >>> proportional_scaling(10, 2)\n    20\n    \n    >>> proportional_scaling(10, 0.5)\n    5.0\n    \"\"\"\n    return value * scale_factor", "def simplify_expression(expression):\n    \"\"\"\n    Simplifies the given mathematical expression and rearranges terms where possible.\n    \n    Parameters:\n    - expression (str): The arithmetic expression as a string.\n    \n    Returns:\n    - simplified_expr (sympy object): The simplified expression.\n    \n    Example:\n    >>> simplify_expression(\"2*x + 3*x\")\n    5*x\n    >>> simplify_expression(\"x*x + 2*x*x + 3*x + x\")\n    3*x**2 + 4*x\n    \"\"\"\n    # Simplify an arbitrary mathematical expression\n    simplified_expr = sp.simplify(expression)\n    return simplified_expr", "def weighted_mean(values, weights):\n    \"\"\"\n    Computes the weighted mean for a list of values using corresponding weights.\n    Parameters:\n    values (list of float|int): Values to average.\n    weights (list of float|int): Weights corresponding to the values.\n    Returns:\n    float: The weighted mean of the values.\n    Raises:\n    ValueError: If 'values' and 'weights' lists are not of the same length or are empty.\n    \"\"\"\n    if not values or not weights:\n        raise ValueError(\"Values and weights cannot be empty.\")\n    if len(values) != len(weights):\n        raise ValueError(\"The length of values must be equal to the length of weights.\")\n    weighted_sum = sum(v * w for v, w in zip(values, weights))\n    sum_weights = sum(weights)\n    return weighted_sum / sum_weights if sum_weights else float('nan')  # Handling zero division internally.", "def square_root(number):\n    \"\"\"\n    Compute the square root of a number using math library.\n    Parameters:\n    number (float|int): The number for which to find the square root.\n    Returns:\n    float: The square root of the number.\n    Examples:\n    >>> square_root(16)\n    4.0\n    >>> square_root(25)\n    5.0\n    \"\"\"\n    if number < 0:\n        raise ValueError(\"Cannot compute the square root of a negative number.\")\n    return math.sqrt(number)", "def find_multiples_in_range(base, start, end):\n    \"\"\"Find all multiples of a base number within a specified range [start, end].\n    \n    Parameters:\n        base (int): The base number to find multiples of.\n        start (int): The starting range (inclusive).\n        end (int): The ending range (inclusive).\n        \n    Returns:\n        list: List of multiples of base within the range.\n    \n    Examples:\n        >>> find_multiples_in_range(3, 1, 10)\n        [3, 6, 9]\n    \"\"\"\n    return [i for i in range(start, end + 1) if i % base == 0]", "def square(number):\n    \"\"\"\n    Compute the square of a number.\n    Parameters:\n    number (float|int): The number to square.\n    Returns:\n    float|int: The square of the number.\n    Examples:\n    >>> square(5)\n    25\n    >>> square(-4)\n    16\n    \"\"\"\n    return number**2", "def sum_with_modulo(numbers, modulo):\n    \"\"\"\n    Sum a list of numbers applying modulo operation to the result.\n    Parameters:\n    - numbers (list of numbers): The list of numbers to sum.\n    - modulo (int): The modulo value.\n    Returns:\n    - int: The result of (sum(numbers) % modulo).\n    Example:\n    >>> sum_with_modulo([1, 2, 3, 4], 3)\n    1\n    \"\"\"\n    return sum(numbers) % modulo", "def percentage_of(total, percentage):\n    \"\"\"\n    Calculate a given percentage of a total.\n    \n    Parameters\n    ----------\n    total : float or int\n        The total value.\n    percentage : float\n        The percentage to calculate (as a percentage, e.g., 50 for 50%).\n    \n    Returns\n    -------\n    float\n        The calculated percentage of the total.\n    \n    Examples\n    --------\n    >>> percentage_of(200, 25)\n    50.0\n    \n    >>> percentage_of(150, 10)\n    15.0\n    \"\"\"\n    return (percentage / 100.0) * total", "def round_number(number, digits):\n    \"\"\"\n    Round a number to a specified number of decimal places.\n    Parameters:\n        number (float): The number to be rounded.\n        digits (int): The number of decimal places to round to.\n    Returns:\n        float: The rounded number.\n    Examples:\n        >>> round_number(3.141592653589793, 2)\n        3.14\n        >>> round_number(123.456789, 3)\n        123.457\n    \"\"\"\n    return round(number, digits)", "def operation_with_pi(numer, denom, operation):\n    \"\"\"Perform arithmetic operations with π involved.\n    Parameters:\n    - numer (float) : The numerator which may include π.\n    - denom (float) : The denominator which may include π.\n    - operation (str) : The operation to perform.\n    Returns:\n    float : The result of arithmetic operation involving π.\n    \"\"\"\n    if operation == 'multiply':\n        return np.pi * (numer/denom)\n    elif operation == 'divide':\n        return (numer/np.pi) / (denom/np.pi) if denom != 0 else 'Error: Division by zero'\n    else:\n        return 'Error: Invalid operation'", "def divide(dividend, divisor):\n    \"\"\"\n    Returns the quotient of the division of the dividend by the divisor.\n    Parameters:\n    dividend (float or int): The number which is to be divided.\n    divisor (float or int): The number by which the dividend is to be divided.\n    Returns:\n    float: The quotient of dividend and divisor.\n    Raises:\n    ZeroDivisionError: If the divisor is zero.\n    Examples:\n    >>> divide(10, 2)\n    5.0\n    >>> divide(5, 2)\n    2.5\n    \"\"\"\n    if divisor == 0:\n        raise ZeroDivisionError(\"Divisor cannot be zero.\")\n    return dividend / divisor", "def factorial(number):\n    \"\"\"\n    Computes the factorial of a number using iterative method.\n    Parameters:\n    - number (int): The number to compute the factorial of.\n    Returns:\n    - int: Factorial of the number.\n    Example:\n    >>> factorial(5)\n    120\n    \"\"\"\n    if number == 0 or number == 1:\n        return 1\n    result = 1\n    for n in range(2, number + 1):\n        result *= n\n    return result", "def calculate_speed(distance, time):\n    \"\"\"\n    Calculates the speed given distance and time.\n    Parameters:\n        distance (float): The distance traveled.\n        time (float): The time taken to travel the distance.\n    Returns:\n        float: The speed (distance per unit of time). Returns None if time is zero.\n    Examples:\n        >>> calculate_speed(100, 2)\n        50.0\n        >>> calculate_speed(150, 0)  # Edge case for division by zero\n        None\n    \"\"\"\n    if time == 0:\n        return None\n    return distance / time", "def simplify_expression(expression):\n    \"\"\"\n    Simplifies a mathematical expression string step-by-step and evaluates the result respecting PEMDAS/BODMAS rules.\n    \n    Parameters\n    ----------\n    expression : str\n        A string containing the mathematical expression to be simplified.\n    Returns\n    -------\n    sp.Expr\n        The simplified symbolic expression using SymPy.\n    str\n        String representation of the simplified expression.\n    float\n        Numerically evaluated result of the simplified expression.\n        \n    Examples\n    --------\n    >>> simplify_expression(\"2 + 3 * 4 - 1\")\n    (2 + (3*4) - 1) simplified is: 11.0\n    >>> simplify_expression(\"1 + 2 * (3 + 4)\")\n    (1 + 2*(3 + 4)) simplified is: 15.0\n    \"\"\"\n    import sympy as sp\n    symbolic_expr = sp.sympify(expression)\n    simplified_expr = sp.simplify(symbolic_expr)\n    return simplified_expr, str(simplified_expr), float(simplified_expr)", "def calculate_expression(expression):\n    \"\"\"\n    Computes the arithmetic value of a string expression respecting the order of operations.\n    \n    Parameters:\n    - expression (str): The arithmetic expression in standard string format.\n    \n    Returns:\n    - result (sympy object): The computed value from the expression.\n    \n    Example:\n    >>> calculate_expression(\"2 + 3 * (4 - 1)\")\n    11\n    >>> calculate_expression(\"3 + 4 * 2 / (1 - 5) ** 2\")\n    3.5\n    \"\"\"\n    # Parse and compute the expression using sympy\n    result = sp.sympify(expression).evalf()\n    return result", "def arithmetic_mean(data):\n    \"\"\"\n    Computes the arithmetic mean of a list or array of numbers.\n    \n    Parameters:\n        data (list or ndarray): A list or numpy array of numbers.\n    Returns:\n        float: The arithmetic mean of the data provided.\n    \n    Example:\n        >>> arithmetic_mean([1, 2, 3, 4, 5])\n        3.0\n    \"\"\"\n    return np.mean(data)", "def gcd(a, b):\n    \"\"\"\n    Compute the greatest common divisor of two numbers using Euclid's algorithm.\n    Parameters:\n    a (int): The first number.\n    b (int): The second number.\n    Returns:\n    int: The greatest common divisor of a and b.\n    Examples:\n    >>> gcd(54, 24)\n    6\n    >>> gcd(11, 5)\n    1\n    \"\"\"\n    while b != 0:\n        a, b = b, a % b\n    return a", "def evaluate_expression(expression):\n    \"\"\"\n    Evaluates a mathematical expression, potentially involving algebraic operations.\n    \n    Parameters:\n    expression (str): A string representing the mathematical expression to evaluate.\n    \n    Returns:\n    float|int|sympy.Expr: Result of evaluating the expression.\n    \n    Example:\n    >>> evaluate_expression(\"3*x + 2\")\n    3*x + 2\n    >>> evaluate_expression(\"3*5 + 2\")\n    17\n    \"\"\"\n    expr = sp.sympify(expression)\n    return expr", "def sum_elements(data):\n    \"\"\"\n    Computes the sum of elements in a list or array.\n    \n    Parameters:\n        data (list or ndarray): A list or numpy array of numbers.\n    \n    Returns:\n        float: The sum of the data provided.\n    \n    Example:\n        >>> sum_elements([1, 2, 3, 4, 5])\n        15\n    \"\"\"\n    return np.sum(data)", "def subtract(initial, *args):\n    \"\"\"\n    Subtract a list of numbers from an initial value.\n    Parameters:\n        initial (float or int): The initial value from which others will be subtracted.\n        *args (float or int): A set of numbers to be subtracted from the initial value.\n    Returns:\n        float: The result after subtraction.\n    Examples:\n        >>> subtract(10, 1, 2)\n        7\n        >>> subtract(20.5, 0.5)\n        20.0\n    \"\"\"\n    return initial - sum(args)", "def product_of_numbers(numbers):\n    \"\"\"\n    Computes the product of a list of numbers.\n    Parameters:\n    - numbers (list of number): The list of numbers to multiply.\n    Returns:\n    - number: The result of multiplying all the numbers together.\n    Example:\n    >>> product_of_numbers([1, 2, 3, 4])\n    24\n    \"\"\"\n    from functools import reduce\n    return reduce(lambda x, y: x * y, numbers, 1)", "def apply_distributive_property(a, b, c):\n    \"\"\"\n    Apply the distributive property of multiplication over addition: a(b + c) = ab + ac.\n    \n    Parameters:\n        a (int or float): The multiplier.\n        b (int or float): The first term to be multiplied and added.\n        c (int or float): The second term to be multiplied and added.\n    \n    Returns:\n        tuple: A tuple of the individual products and their sum: (ab, ac, ab + ac).\n    \n    Examples:\n        >>> apply_distributive_property(2, 3, 4)\n        (6, 8, 14)\n    \"\"\"\n    product1 = a * b\n    product2 = a * c\n    return (product1, product2, product1 + product2)", "def negate_number(x):\n    \"\"\"\n    Negate the provided number.\n    Parameters:\n    x (float|int): The number to negate.\n    Returns:\n    float|int: The negation of the number.\n    Examples:\n    >>> negate_number(5)\n    -5\n    >>> negate_number(-10)\n    10\n    \"\"\"\n    return -x", "def basic_arithmetic(op, x, y):\n    import operator\n    operations = {\n        'add': operator.add,\n        'subtract': operator.sub,\n        'multiply': operator.mul,\n        'divide': operator.truediv,\n        'power': operator.pow\n    }\n    \n    if op not in operations:\n        raise ValueError(f\"Unsupported operation '{op}'. Choose from {list(operations.keys())}\")\n    \n    if op == 'divide' and y == 0:\n        raise ValueError(\"Cannot divide by zero\")\n    \n    return operations[op](x, y)", "def sequence_differences(sequence):\n    \"\"\"\n    Calculate the differences between consecutive terms in a sequence.\n    Parameters:\n    - sequence (list of int or float): A list containing the numerical sequence.\n    Returns:\n    - list of int or float: List containing the differences between consecutive terms.\n    Examples:\n    >>> sequence_differences([1, 2, 4, 7])\n    [1, 2, 3]\n    \"\"\"\n    return [sequence[i+1] - sequence[i] for i in range(len(sequence) - 1)]", "def get_factors(n):\n    \"\"\"\n    Get all factors of a given number.\n    \n    Parameters\n    ----------\n    n : int\n        The number to find factors for.\n    \n    Returns\n    -------\n    list\n        A list of factors of n.\n    \n    Examples\n    --------\n    >>> get_factors(12)\n    [1, 2, 3, 4, 6, 12]\n    \n    >>> get_factors(7)\n    [1, 7]\n    \"\"\"\n    if n <= 0:\n        raise ValueError(\"Number must be positive.\")\n    factors = []\n    for i in range(1, int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            factors.append(i)\n            if i != n // i:\n                factors.append(n // i)\n    factors.sort()\n    return factors", "def advanced_arithmetic_sequences(start, end, operation=\"subtract\", step=1, function=None):\n    \"\"\"\n    Apply arithmetic operations over a range of numbers with an optional mathematical function (like power or factorial).\n    Parameters:\n    - start (int): Starting number.\n    - end (int): Ending number.\n    - operation (str): Type of operation to apply on sequence ('add', 'subtract'). Default is 'subtract'.\n    - step (int): Step count between sequence numbers. Default is 1 (sequential).\n    - function (callable): A function to apply to each number before performing the arithmetic operation.\n    Returns:\n    - total (float|int): The accumulated result after applying the arithmetic operation across the sequence.\n    Examples:\n    >>> advanced_arithmetic_sequences(1, 5, \"add\")\n    15\n    >>> advanced_arithmetic_sequences(1, 3, \"subtract\")\n    -5\n    >>> import math\n    >>> advanced_arithmetic_sequences(1, 3, \"add\", function=math.sqrt)\n    1 + sqrt(2) + sqrt(3)\n    \"\"\"\n    if not isinstance(start, int) or not isinstance(end, int):\n        raise ValueError(\"Start and end values must be integers.\")\n    if operation not in [\"add\", \"subtract\"]:\n        raise ValueError(\"Invalid operation. Use 'add' or 'subtract'.\")\n    if function:\n        numbers = [function(x) for x in range(start, end + 1, step)]\n    else:\n        numbers = list(range(start, end + 1, step))\n    if operation == \"add\":\n        return sum(numbers)\n    elif operation == \"subtract\":\n        return sum(-num if i != 0 else num for i, num in enumerate(numbers))", "def subtract(minuend, subtrahend):\n    \"\"\"\n    Returns the difference between the minuend and the subtrahend.\n    Parameters:\n    minuend (float or int): The number from which another number (subtrahend) is to be subtracted.\n    subtrahend (float or int): The number that is to be subtracted from the minuend.\n    Returns:\n    float or int: The result of subtracting subtrahend from minuend.\n    Examples:\n    >>> subtract(10, 5)\n    5\n    >>> subtract(7.5, 2.2)\n    5.3\n    \"\"\"\n    return minuend - subtrahend", "def conditional_sum(data, mod=None):\n    \"\"\"\n    Sums elements in a list with an optional modular arithmetic adjustment.\n    \n    Parameters:\n    - data (list of int or float): List of numbers to be summed.\n    - mod (int, optional): If provided, the summation is taken modulo this value.\n    \n    Returns:\n    - int or float: Sum of the list, or sum modulo if mod is provided.\n    \n    Examples:\n    - conditional_sum([1, 2, 3, 4]) should return 10.\n    - conditional_sum([1, 2, 3, 4], mod=3) should return 1 (i.e., 10 % 3).\n    \"\"\"\n    total = sum(data)\n    if mod is not None:\n        total %= mod\n    return total"], "Rounding Numbers": ["def custom_round(number, decimal_places=0):\n    \"\"\"\n    Rounds a number to a specified number of decimal places.\n    \n    Parameters:\n    - number (float): The number to be rounded.\n    - decimal_places (int): The number of decimal places to round to.\n    \n    Returns:\n    float: The rounded number.\n    Examples:\n    >>> custom_round(3.14159, 2)\n    3.14\n    >>> custom_round(1.275, 2)\n    1.28\n    >>> custom_round(1.2345, 3)\n    1.235\n    >>> custom_round(1.2344, 3)\n    1.234\n    \"\"\"\n    import decimal\n    # Setting rounding method of decimal context to ROUND_HALF_UP\n    decimal.getcontext().rounding = decimal.ROUND_HALF_UP\n    d = decimal.Decimal(number)\n    rounded = round(d, decimal_places)  # Using round after setting context for proper half up rounding\n    return float(rounded)", "def round_to_nearest(value, unit=1):\n    \"\"\"\n    Rounds the given value to the nearest specified unit. For example, nearest dollar, nearest hundred, etc.\n    Parameters:\n    - value (float or int): The number to be rounded.\n    - unit (int): The unit to round to. Default is 1, which corresponds to nearest whole number.\n    Returns:\n    - int: Rounded value to nearest unit.\n    Examples:\n    >>> round_to_nearest(123.25)\n    123\n    \n    >>> round_to_nearest(123.99)\n    124\n    >>> round_to_nearest(1583, 100)\n    1600\n    \"\"\"\n    return int(decimal.Decimal(value / unit).to_integral_value(decimal.ROUND_HALF_UP) * unit)", "def rounding_analyzer(original, rounded):\n    \"\"\"\n    Analyzes the properties between original and rounded number.\n    \n    Parameters:\n    - original (float): The original number before rounding.\n    - rounded (float): The rounded number.\n    \n    Returns:\n    dict: A dictionary providing information about change, direction of rounding and error (if any).\n    \n    Examples:\n    >>> rounding_analyzer(3.1459, 3.15)\n    {'original': 3.1459, 'rounded': 3.15, 'change': 0.0041, 'direction': 'up', 'error': 0.0}\n    >>> rounding_analyzer(2.2499, 2.25)\n    {'original': 2.2499, 'rounded': 2.25, 'change': 0.0001, 'direction': 'up', 'error': 0.0}\n    >>> rounding_analyzer(4.9999, 5.0)\n    {'original': 4.9999, 'rounded': 5.0, 'change': 0.0001, 'direction': 'up', 'error': 0.0}\n    \"\"\"\n    original = float(original)\n    rounded = float(rounded)\n    change = abs(rounded - original)\n    direction = 'up' if rounded > original else 'down' if rounded < original else 'no change'\n    error = abs(rounded - round(float(original)))\n    return {'original': original, 'rounded': rounded, 'change': change, 'direction': direction, 'error': error}"], "Order of Operations": ["def evaluate_expression(expression):\n    \"\"\"\n    Evaluate a mathematical expression by strictly following the order of operations (PEMDAS/BODMAS).\n    \n    Parameters\n    ----------\n    expression : str\n        A string that represents the mathematical expression to be evaluated.\n        \n    Returns\n    -------\n    result : float or int\n        The numerical result of the evaluated expression.\n        \n    Examples\n    --------\n    >>> evaluate_expression(\"3 + 2 * (1 + 3)**2 - 8 / 2\")\n    26.0\n    \n    >>> evaluate_expression(\"(2 + 3) * 5\")\n    25\n    \n    >>> evaluate_expression(\"4**2 + 6 * 10\")\n    100\n    \"\"\"\n    from sympy import sympify\n    # Compute the expression using sympy which respects order of operations\n    try:\n        result = sympify(expression).evalf()\n    except Exception as e:\n        raise ValueError(f\"Error evaluating expression: {str(e)}\")\n    return result", "def nth_term_arithmetic_sequence(a, d, n):\n    \"\"\"\n    Calculate the n-th term of an arithmetic sequence using the formula a_n = a + (n-1) * d.\n    Parameters:\n    - a (float): The first term of the sequence.\n    - d (float): The common difference of the sequence.\n    - n (int): The term of the sequence to find.\n    Returns:\n    - float: The n-th term of the sequence.\n    Examples:\n    >>> nth_term_arithmetic_sequence(3, 2, 5)\n    11\n    >>> nth_term_arithmetic_sequence(1, -0.5, 10)\n    -3.5\n    \"\"\"\n    return a + (n - 1) * d"], "Unit Conversion": ["def convert_units(value, from_unit, to_unit):\n    \"\"\"\n    Converts a measurement from one unit to another.\n    Parameters:\n    - value (float): The quantity of the measurement in the 'from_unit'.\n    - from_unit (str): The unit of the input value. Supported units are 'inches', 'feet', 'yards', and 'miles'.\n    - to_unit (str): The unit to which the conversion should be made. Supported units are the same as 'from_unit'.\n    Returns:\n    - float: The converted value in the 'to_unit'.\n    Examples:\n    >>> convert_units(12, 'inches', 'feet')\n    1.0\n    >>> convert_units(3, 'yards', 'feet')\n    9.0\n    \"\"\"\n    # Unit conversion factors\n    factors = {\n        'inches': {'feet': 1/12, 'yards': 1/36, 'miles': 1/63360},\n        'feet': {'inches': 12, 'yards': 1/3, 'miles': 1/5280},\n        'yards': {'inches': 36, 'feet': 3, 'miles': 1/1760},\n        'miles': {'inches': 63360, 'feet': 5280, 'yards': 1760}\n    }\n    if from_unit == to_unit:\n        return value\n    else:\n        return value * factors[from_unit][to_unit]", "def calculate_arithmetic(value1, value2, operation, rounding_digits=None):\n    \"\"\"\n    Perform arithmetic operations between two values and optionally round the result.\n    Parameters:\n    value1 : float\n        The first numerical value.\n    value2 : float\n        The second numerical value.\n    operation : str\n        The operation to perform ('add', 'subtract', 'multiply', 'divide').\n    rounding_digits : int, optional\n        The number of digits to round the result to. If None, rounding is not performed.\n    Returns:\n    float\n        The result of the arithmetic operation, potentially rounded.\n    Examples:\n    >>> calculate_arithmetic(10, 2.5, 'multiply')\n    25.0\n    >>> calculate_arithmetic(100.1234, 0, 'subtract', rounding_digits=2)\n    100.12\n    \"\"\"\n    operations = {\n        'add': lambda x, y: x + y,\n        'subtract': lambda x, y: x - y,\n        'multiply': lambda x, y: x * y,\n        'divide': lambda x, y: x / y if y != 0 else float('inf')\n    }\n    result = operations[operation](value1, value2)\n    if rounding_digits is not None:\n        return round(result, rounding_digits)\n    \n    return result", "def convert_units(value, factor):\n    \"\"\"\n    Convert units by a specific factor. This is a general utility function for unit scaling.\n    \n    Parameters:\n        value (float): the value to convert.\n        factor (float): the factor by which to scale the value.\n    \n    Returns:\n        float: the scaled value\n    \n    Examples:\n        convert_units(3, 60) -> 180\n    \"\"\"\n    return value * factor", "def convert_units(value, src_unit, dest_unit, conversion_factors):\n    \"\"\"\n    Convert a value from a source unit to a destination unit using specified conversion factors.\n    Parameters:\n    - value (float): The numeric value to be converted.\n    - src_unit (str): The source unit from which conversion is to be made.\n    - dest_unit (str): The destination unit to which conversion is to be made.\n    - conversion_factors (dict): A dictionary with key as a tuple (src_unit, dest_unit) and value as the conversion factor.\n    Returns:\n    - float: The converted value in the destination unit.\n    Examples:\n    >>> convert_units(1000, 'mL', 'L', {('mL', 'L'): 0.001})\n    1.0\n    >>> convert_units(2, 'USD', 'EUR', {('USD', 'EUR'): 0.95})\n    1.9\n    \"\"\"\n    if (src_unit, dest_unit) in conversion_factors:\n        return value * conversion_factors[(src_unit, dest_unit)]\n    elif (dest_unit, src_unit) in conversion_factors:\n        return value / conversion_factors[(dest_unit, src_unit)]\n    else:\n        raise ValueError(\"Conversion factor not available for the given units\")", "def currency_to_cents(dollars, cents_per_dollar=100):\n    \"\"\"\n    Convert a monetary value in dollars to cents.\n    \n    Parameters:\n    - dollars (float): the amount in dollars.\n    - cents_per_dollar (int): number of cents per dollar (default: 100).\n    \n    Returns:\n    - int: equivalent amount in cents.\n    Examples:\n    >>> currency_to_cents(1.25)\n    125\n    \"\"\"\n    return int(dollars * cents_per_dollar)", "def money_conversion(amount, from_currency, to_currency, exchange_rate):\n    \"\"\"\n    Convert monetary values from one currency to another using a specified exchange rate.\n    Parameters:\n    - amount (float): the monetary value in the original currency to be converted.\n    - from_currency (str): the ISO currency code of the original currency.\n    - to_currency (str): the ISO currency code of the target currency.\n    - exchange_rate (float): the rate at which the currencies are to be exchanged.\n    \n    Returns:\n    - float: the converted monetary value in the target currency.\n    Examples:\n    >>> money_conversion(100, 'USD', 'EUR', 0.95)\n    95.0\n    \"\"\"\n    return amount * exchange_rate", "def calculate_proportions(value, src_ratio, dest_ratio):\n    \"\"\"\n    Calculate the proportional value based on source and destination ratios.\n    Parameters:\n    - value (float): The original value which is to be proportionally adjusted.\n    - src_ratio (float): The source ratio.\n    - dest_ratio (float): The destination ratio represented.\n    Returns:\n    - float: The value adjusted to the destination ratio.\n    Examples:\n    >>> calculate_proportions(100, 1, 2)\n    200\n    >>> calculate_proportions(150, 3, 2)\n    100\n    \"\"\"\n    return value * (dest_ratio / src_ratio)", "def fraction_to_decimal(numerator, denominator):\n    \"\"\"\n    Convert a fraction to a decimal.\n    \n    Parameters:\n    - numerator (int): the numerator of the fraction.\n    - denominator (int): the denominator of the fraction.\n    \n    Returns:\n    - float: decimal representation of the fraction.\n    Examples:\n    >>> fraction_to_decimal(1, 2)\n    0.5\n    \"\"\"\n    return numerator / denominator"], "Rate Problems": ["def calculate_time(distance, rate):\n    \"\"\"\n    Computes the time required to cover a given distance with a specific rate (speed).\n    Parameters:\n    distance (float): the distance to be traveled.\n    rate (float): the speed at which the travel occurs.\n    Returns:\n    float: The time required to cover the given distance at the given rate.\n    Example:\n    >>> calculate_time(100, 50)\n    2.0\n    \"\"\"\n    if rate == 0:\n        raise ValueError(\"Rate cannot be zero.\")\n    return distance / rate", "def calculate_hourly_rate(total_earnings, total_hours):\n    \"\"\"\n    Calculate the hourly rate from total earnings and hours worked.\n    Parameters:\n    total_earnings (float): Total earnings in a period.\n    total_hours (float): Hours worked in the same period.\n    Returns:\n    float: Hourly wage.\n    Example:\n    >>> calculate_hourly_rate(500, 20)\n    25.0\n    \"\"\"\n    return total_earnings / total_hours", "def convert_hours_to_minutes(hours):\n    \"\"\"\n    Converts time from hours to minutes.\n    Parameters:\n    hours (float): The time in hours.\n    Returns:\n    float: The time in minutes.\n    Example:\n    >>> convert_hours_to_minutes(2.5)\n    150.0\n    \"\"\"\n    return hours * 60", "def time_conversion(time_value, from_unit=\"hours\", to_unit=\"minutes\"):\n    \"\"\"\n    Convert time between hours and minutes.\n    Parameters:\n    time_value (float): The time value to convert.\n    from_unit (str): Unit of the input time ('hours' or 'minutes').\n    to toda_unit (str): Unit of the output time ('hours' or 'minutes').\n    Returns:\n    float: Converted time value.\n    Example:\n    >>> time_conversion(2, from_unit=\"hours\", to_unit=\"minutes\")\n    120.0\n    >>> time_conversion(90, from_unit=\"minutes\", to_unit=\"hours\")\n    1.5\n    \"\"\"\n    if from_unit == \"hours\" and to_unit == \"minutes\":\n        return time_value * 60\n    elif from_unit == \"minutes\" and to_unit == \"hours\":\n        return time_value / 60\n    else:\n        return time_value", "def calculate_rate_problem(distance=None, time=None, speed=None):\n    \"\"\"\n    General-purpose function for solving problems related to the formula speed = distance / time.\n    \n    Parameters\n    ----------\n    distance : float or None\n        The distance covered. If this is not provided, the function calculates it.\n    time : float or None\n        The time taken. If this is not provided, the function calculates it.\n    speed : float or None\n        The traveling speed. If this is not provided, the function calculates it.\n    \n    Returns\n    -------\n    float\n        The value of the calculated distance, time, or speed, depending on which parameter was initially None.\n    \n    Examples\n    --------\n    >>> calculate_rate_problem(speed=60, time=2)\n    120.0  # Distance = 60 mph * 2h = 120 miles\n    >>> calculate_rate_problem(distance=150, time=3)\n    50.0  # Speed = 150 miles / 3h = 50 mph\n    >>> calculate_rate_problem(distance=100, speed=50)\n    2.0  # Time = 100 miles / 50 mph = 2 hours\n    \"\"\"\n    if distance is None:\n        return speed * time\n    elif time is None:\n        return distance / speed\n    elif speed is None:\n        return distance / time\n    else:\n        raise ValueError(\"Two inputs are needed among distance, time and speed.\")", "def average_speed(distances, times):\n    \"\"\"\n    Calculates average speed based on total distance traveled and total time spent traveling.\n    Parameters:\n    distances (list of float): list of distances traveled.\n    times (list of float): list of times spent for each corresponding distance.\n    Returns:\n    float: The average speed for the entire trip.\n    Example:\n    >>> average_speed([100, 200], [2, 4])\n    50.0\n    \"\"\"\n    total_distance = np.sum(distances)\n    total_time = np.sum(times)\n    if total_time == 0:\n        raise ValueError(\"Total time cannot be zero.\")\n    return total_distance / total_time", "def compute_duration_or_total(rate, other, is_duration=True):\n    \"\"\"\n    Given a rate and either the total quantity or total duration, this function computes either the duration required\n    to achieve a total at the given rate, or the total achievable in the given duration at the rate.\n    Parameters:\n    rate (float): The rate of operation (units per time for computing duration, or time per unit for total calculation).\n    other (float): The quantity if calculating duration or the duration if calculating total.\n    is_duration (bool): Flag to determine whether to compute duration (True) or total (False).\n    Returns:\n    float: The computed duration or total based on the input rate and other value.\n    Examples:\n    >>> compute_duration_or_total(20, 500, is_duration=True)\n    25.0  # Interpretation: At a rate of 20 units/hr to achieve 500 units, it takes 25 hours.\n    \n    >>> compute_duration_or_total(5, 100, is_duration=False)\n    500.0  # Interpretation: With a rate of 5 miles/hour and 100 hours available, the total distance is 500 miles.\n    \"\"\"\n    if rate == 0:\n        return None\n    return other / rate if is_duration else rate * other", "def combine_rates(*rates):\n    \"\"\"\n    Calculate the combined rate of work when multiple rates are working together.\n    Parameters:\n    rates (list of float): Rates of all entities working together.\n    Returns:\n    float: Combined rate.\n    Examples:\n    >>> combine_rates(1/2, 1/3)\n    0.8333333333333333\n    \"\"\"\n    if any(rate == 0 for rate in rates):\n        raise ValueError(\"Rates must be all non-zero\")\n    reciprocal_sum = np.sum(1 / np.array(rates))\n    return 1 / reciprocal_sum", "def calculate_task_duration(rate, total_quantity):\n    \"\"\"\n    Calculate the time required to complete a task given the rate and the total quantity.\n    Parameters:\n    rate (float): Rate of completing the task (unit per time).\n    total_quantity (float): Total quantity to be managed or processed.\n    Returns:\n    float: Time needed to complete the task.\n    Examples:\n    >>> calculate_task_duration(10, 100)\n    10.0\n    \"\"\"\n    if rate == 0:\n        raise ValueError(\"Rate must be non-zero\")\n    return total_quantity / rate", "def calculate_speed_from_other(speed_of_one, time_of_one, time_of_other):\n    \"\"\"\n    Calculate the speed of another entity given the speed of one and their respective times to complete the same task.\n    Parameters:\n    speed_of_one (float): Speed of the first entity (e.g., speed in km/h).\n    time_of_one (float): Time taken by the first entity.\n    time_of_other (float): Time taken by the other entity to complete the same task.\n    Returns:\n    float: Calculated speed of the other entity.\n    Examples:\n    >>> calculate_speed_from_other(60, 2, 3)\n    40.0\n    \"\"\"\n    return speed_of_one * (time_of_one / time_of_other)", "def rate_from_another_speed(known_speed, known_multiplier, target_multiplier):\n    \"\"\"\n    Calculate rate or speed of one individual/entity based on another's speed given a proportionality constant.\n    Parameters:\n    known_speed (float): The given speed of one reference person/object.\n    known_multiplier (float): The multiplier associated with the known speed.\n    target_multiplier (float): The desired multiplier for calculating the target speed.\n    Returns:\n    float: Target speed based on proportional relationship.\n    Example:\n    >>> rate_from_another_speed(30, 2, 1)\n    15.0\n    \"\"\"\n    return known_speed * (target_multiplier / known_multiplier)", "def calculate_rate(numerator, denominator):\n    \"\"\"\n    Calculates a rate given a numerator and denominator, which is a common operation in solving various rate-based problems.\n    Parameters:\n    numerator (float): The total quantity (e.g., total earnings, total distance, total work done).\n    denominator (float): The total units (e.g., hours worked, time taken).\n    Returns:\n    float: The rate calculated as a ratio of numerator to denominator.\n    Examples:\n    >>> calculate_rate(500, 25)\n    20.0  # Interpretation: If numerator is earnings in dollars and denominator is hours, the wage rate is $20/hour.\n    \n    >>> calculate_rate(100, 20)\n    5.0  # Interpretation: If numerator is distance in miles and denominator is time in hours, the speed is 5 mph.\n    \"\"\"\n    return numerator / denominator if denominator != 0 else None"], "Averages": ["def calculate_mean(data):\n    \"\"\"\n    Calculate the simple arithmetic mean (average) of a list of numbers.\n    Parameters:\n    data (list or np.array): A list or array of numerical values.\n    Returns:\n    float: The mean of the input data.\n    Examples:\n    >>> calculate_mean([1, 2, 3, 4, 5])\n    3.0\n    >>> calculate_mean(np.array([2, 3, 4, 5, 6]))\n    4.0\n    \"\"\"\n    return np.mean(data)", "def calculate_mean(numbers):\n    \"\"\"\n    Calculate the arithmetic mean of a list of numbers.\n    Parameters:\n    - numbers (list of float or int): A list containing numbers for which the mean is needed.\n    Returns:\n    - float: The calculated mean of the provided numbers.\n    Examples:\n    >>> calculate_mean([1, 2, 3, 4, 5])\n    3.0\n    >>> calculate_mean([10, 20])\n    15.0\n    \"\"\"\n    return sum(numbers) / len(numbers) if numbers else 0", "def calculate_weighted_average(values, weights):\n    \"\"\"\n    Calculate the weighted average of a list of numbers given corresponding weights.\n    Parameters:\n    values (list or np.array): Values for which the average is to be calculated.\n    weights (list or np.array): Weights corresponding to each value in the values list.\n    Returns:\n    float: The weighted average of the values.\n    Examples:\n    >>> calculate_weighted_average([1, 2, 3], [3, 2, 1])\n    1.8333333333333333\n    \"\"\"\n    return np.average(values, weights=weights)", "def calculate_average_speed(total_distance, total_time):\n    \"\"\"\n    Calculate the average speed given total distance and total time.\n    Parameters:\n        total_distance (float): The total distance travelled.\n        total_time (float): The total time spent.\n    Returns:\n        float: Average speed.\n    Examples:\n        >>> calculate_average_speed(150, 3)\n        50.0\n    \"\"\"\n    if total_time == 0:\n        raise ValueError(\"Total time cannot be zero for speed calculation.\")\n    return total_distance / total_time", "def recalculate_average(current_avg, n, new_elements):\n    \"\"\"\n    Adjust an existing average by adding new elements.\n    \n    Parameters:\n    current_avg (float): Current average of the dataset.\n    n (int): Number of elements in the current dataset.\n    new_elements (list of float or int): New elements added to the dataset.\n    Returns:\n    float: New average including new elements.\n    Examples:\n    >>> recalculate_average(20.0, 3, [40, 50])\n    30.0\n    \"\"\"\n    total_sum = current_avg * n\n    new_sum = sum(new_elements)\n    total_n = n + len(new_elements)\n    new_avg = (total_sum + new_sum) / total_n\n    return new_avg", "def adjust_mean(current_mean, current_count, new_value, addition=True):\n    \"\"\"\n    Adjust the mean when items are added to or removed from the data set.\n    Parameters:\n    current_mean (float): Current average of the dataset.\n    current_count (int): Number of items in the dataset.\n    new_value (float): The value being added or removed.\n    addition (bool): True if the value is being added, False if being removed.\n    Returns:\n    float: New mean of the dataset.\n    Examples:\n    >>> adjust_mean(3.0, 4, 5, addition=True)\n    3.2\n    >>> adjust_mean(3.2, 5, 5, addition=False)\n    3.0\n    \"\"\"\n    total_sum = current_mean * current_count\n    if addition:\n        total_sum += new_value\n        current_count += 1\n    else:\n        total_sum -= new_value\n        current_count -= 1\n    return total_sum / current_count if current_count > 0 else 0", "def calculate_total_sum(average, count):\n    \"\"\"\n    Calculate the total sum from the average and the number of items.\n    Parameters:\n        average (float): The average of the items.\n        count (int): The number of items.\n    Returns:\n        float: Total sum of all the items.\n    Examples:\n        >>> calculate_total_sum(25.5, 4)\n        102.0\n        >>> calculate_total_sum(100, 5)\n        500\n    \"\"\"\n    return average * count", "def retrieve_total_sum_and_modify_average(original_mean, original_count, subset_sum, new_average):\n    \"\"\"\n    Recalculate total sum and modified averages from subsets, including addition or removal of items.\n    Parameters:\n    original_mean (float): The existing average from the main group.\n    original_count (int): The count of items in the main group.\n    subset_sum (float): The total sum of the subset being analyzed.\n    new_average (float): The target new average after modifying the group.\n    Returns:\n    tuple: A tuple containing the new total sum and the modified mean.\n    Examples:\n    >>> retrieve_total_sum_and_modify_average(3.0, 3, 9, 4.0)\n    (12.0, 4.0)\n    \"\"\"\n    original_total = original_mean * original_count\n    new_total = original_total + subset_sum\n    new_mean = new_average if new_total != 0 else 0\n    return new_total, new_mean", "def average(data):\n    \"\"\"\n    Calculate the arithmetic mean of a list of numbers.\n    Parameters:\n    data (list of float or int): A list of numbers.\n    Returns:\n    float: The arithmetic mean of the numbers.\n    Examples:\n    >>> average([10, 20, 30])\n    20.0\n    \"\"\"\n    if not data:\n        return 0  # Avoid division by zero\n    return sum(data) / len(data)"], "Fractions": ["def subtract_fractions(frac1, frac2):\n    \"\"\"\n    Subtracts the second fraction from the first and returns the result in its simplest form.\n    Parameters:\n        frac1 (Fraction or str or tuple): The first fraction (minuend), similar format as in add_fractions.\n        frac2 (Fraction or str or tuple): The second fraction (subtrahend), similar format.\n    \n    Returns:\n        Fraction: The result of subtraction, simplified.\n    Example:\n        >>> subtract_fractions('3/4', '1/2')\n        Fraction(1, 4)\n    \"\"\"\n    return Fraction(frac1) - Fraction(frac2)", "def operate_fractions(frac1, frac2, operation):\n    \"\"\"Perform arithmetic operations on two fractions.\n    Parameters:\n    frac1 (Fraction): The first fraction.\n    frac2 (Fraction): The second fraction.\n    operation (str): The operation to perform ('add', 'subtract', 'multiply', 'divide').\n    Returns:\n    Fraction: The result of the arithmetic operation.\n    Examples:\n    >>> operate_fractions(Fraction(1, 2), Fraction(1, 3), 'add')\n    Fraction(5, 6)\n    \"\"\"\n    if operation == 'add':\n        return frac1 + frac2\n    elif operation == 'subtract':\n        return frac1 - frac2\n    elif operation == 'multiply':\n        return frac1 * frac2\n    elif operation == 'divide':\n        return frac1 / frac2\n    else:\n        raise ValueError(\"Unsupported operation specified\")", "def simplify_fraction(numerator, denominator):\n    \"\"\"\n    Simplify a fraction to its lowest terms.\n    Parameters:\n    numerator (int, float): The numerator of the fraction.\n    denominator (int, float): The denominator of the fraction.\n    Returns:\n    Fraction: The fraction in its simplest form.\n    Examples:\n    >>> simplify_fraction(8, 24)\n    Fraction(1, 3)\n    >>> simplify_fraction(-10, -20)\n    Fraction(1, 2)\n    \"\"\"\n    return Fraction(numerator, denominator)", "def improper_to_mixed(fraction):\n    \"\"\"Convert an improper fraction to a mixed number.\n    Parameters:\n    fraction (Fraction): The improper fraction to convert.\n    Returns:\n    tuple: A tuple (whole, numerator, denominator), representing the mixed number.\n    \n    Examples:\n    >>> improper_to_mixed(Fraction(7, 2))\n    (3, 1, 2)\n    \"\"\"\n    whole = fraction.numerator // fraction.denominator\n    new_numerator = fraction.numerator % fraction.denominator\n    return (whole, new_numerator, fraction.denominator)", "def fraction_to_decimal(numerator, denominator):\n    \"\"\"\n    Convert a fraction represented by numerator and denominator to a decimal.\n    Parameters:\n    numerator (int): the numerator of the fraction.\n    denominator (int): the denominator of the fraction.\n    Returns:\n    float: Decimal representation of the fraction.\n    Example:\n    >>> fraction_to_decimal(1, 2)\n    0.5\n    \"\"\"\n    return numerator / denominator", "def fraction_to_percentage(frac):\n    \"\"\"\n    Converts a fraction to a percentage format.\n    Parameters:\n        frac (Fraction or str or tuple): The fraction to convert, similar format as in simplify_fraction.\n    \n    Returns:\n        float: The numeric value of the fraction expressed as a percentage.\n    Example:\n        >>> fraction_to_percentage('1/2')\n        50.0\n    \"\"\"\n    return float(Fraction(frac) * 100)", "def fraction_to_decimal(fraction, rounding_digits=None):\n    \"\"\"\n    Convert a fraction to decimal and optionally round it.\n    Parameters:\n    - fraction (str or Fraction): The fraction to convert.\n    - rounding_digits (int, optional): Number of decimal places to round to. If none, no rounding is applied.\n    Returns:\n    - float or int: The decimal representation of the fraction, rounded if specified.\n    Examples:\n    >>> fraction_to_decimal('1/3', 2)\n    0.33\n    \n    >>> fraction_to_encode('4/2')\n    2.0\n    \"\"\"\n    f = Fraction(fraction)\n    decimal_value = float(f)\n    if rounding_digits is not None:\n        return round(decimal_value, rounding_digits)\n    return decimal_value", "def decimal_to_fraction(decimal):\n    \"\"\"\n    Convert a decimal to a Fraction.\n    Parameters:\n    decimal (float): Decimal value to convert.\n    Returns:\n    Fraction: A simplified fraction representation of the decimal.\n    Example:\n    >>> str(decimal_to_fraction(0.5))\n    '1/2'\n    \"\"\"\n    return Fraction(decimal).limit_denominator()", "def simplify_fraction(frac):\n    \"\"\"\n    Simplifies a fraction to its lowest terms.\n    Parameters:\n        frac (Fraction or str or tuple): The fraction to simplify, can be a Fraction instance, string like '10/20', or tuple (10, 20).\n    \n    Returns:\n        Fraction: The fraction in its simplest form.\n    Example:\n        >>> simplify_fraction('10/20')\n        Fraction(1, 2)\n    \"\"\"\n    return Fraction(frac).limit_denominator()", "def add_fractions(numer1, denom1, numer2, denom2):\n    \"\"\"\n    Add two fractions and return the result in simplified form.\n    Parameters:\n    numer1 (int), denom1 (int): Numerator and denominator of the first fraction.\n    numer2 (int), denom2 (int): Numerator and denominator of the second fraction.\n    Returns:\n    Fraction: The sum of the two fractions, simplified.\n    Example:\n    >>> str(add_fractions(1, 2, 1, 3))\n    '5/6'\n    \"\"\"\n    return Fraction(numer1, denom1) + Fraction(numer2, denom2)", "def simplify_complex_fraction(expression):\n    \"\"\"\n    Simplifies complex fractions which can include variables, powers, or roots.\n    Parameters:\n    expression (str): A string representing the complex fraction or mathematical expression.\n    Returns:\n    sp.Expr: The simplified expression.\n    Examples:\n    >>> simplify_complex_fraction('1/2 + 1/3')\n    '5/6'\n    >>> simplify_complex_fraction('(1/2)*(1/3) / (1/4)')\n    '2/3'\n    \"\"\"\n    expr = sp.sympify(expression)\n    return sp.simplify(expr)", "def find_common_denominator(fraction1, fraction2):\n    \"\"\"\n    Finds a common denominator for two fractions and returns them as fractions\n    with the common denominator.\n    Parameters:\n        fraction1 (Fraction): First fraction.\n        fraction2 (Fraction): Second fraction.\n    \n    Returns:\n        tuple: Tuple of two Fractions with a common denominator.\n    Examples:\n        >>> find_common_denominator(Fraction(1, 2), Fraction(1, 3))\n        (Fraction(3, 6), Fraction(2, 6))\n    \"\"\"\n    lcm_denominator = (fraction1.denominator * fraction2.denominator) // gcd(fraction1.denominator, fraction2.denominator)\n    new_fraction1 = Fraction(fraction1.numerator * (lcm_denominator // fraction1.denominator), lcm_denominator)\n    new_fraction2 = Fraction(fraction2.numerator * (lcm_denominator // fraction2.denominator), lcm_denominator)\n    return (new_fraction1, new_fraction2)", "def round_decimal(value, places):\n    \"\"\"\n    Rounds a decimal value to a specified number of decimal places with rounding half-up.\n    \n    Parameters:\n        value (float): the decimal value to round.\n        places (int): the number of decimal places to round to.\n    \n    Returns:\n        float: the rounded decimal value.\n    \n    Examples:\n        >>> round_decimal(0.456, 2)\n        0.46\n        >>> round_decimal(0.1234, 1)\n        0.1\n    \"\"\"\n    decimal_value = Decimal(value).quantize(Decimal('1.' + '0' * places), rounding=ROUND_HALF_UP)\n    return float(decimal_value)", "def common_denominator(*fractions):\n    \"\"\"\n    Finds the least common denominator (LCD) for a list of fraction strings.\n    \n    Parameters:\n    - fractions (tuple of str): Fractions for which to find the LCD.\n    \n    Returns:\n    - int: The least common denominator for all provided fractions.\n    \n    Examples:\n    - common_denominator('1/2', '2/3') => 6\n    - common_denominator('5/12', '3/4') => 12\n    \"\"\"\n    f_objs = [Fraction(frac) for frac in fractions]\n    lcd = f_objs[0].denominator\n    for frac in f_objs[1:]:\n        lcd = (lcd * frac.denominator) // math.gcd(lcd, frac.denominator)\n    return lcd", "def square_fraction(fraction):\n    \"\"\"\n    Square a given fraction.\n    \n    Parameters:\n        fraction (str): The fraction to square in string format, e.g., '1/2'.\n        \n    Returns:\n        str: The squared fraction in string format.\n        \n    Examples:\n    >>> square_fraction('1/2')\n    '1/4'\n    \"\"\"\n    f = Fraction(fraction)\n    result = f * f\n    return str(result)", "def simplify_fraction(frac):\n    \"\"\"Simplify a fraction to its simplest form using GCD.\n    \n    Parameters:\n    - frac (Fraction): Fraction to be simplified.\n    \n    Returns:\n    - Fraction: The fraction in its simplest form.\n    \n    Examples:\n    >>> simplify_fraction(Fraction(36, 48))\n    Fraction(3, 4)\n    \"\"\"\n    common_divisor = gcd(frac.numerator, frac.denominator)\n    return Fraction(frac.numerator // common_divisor, frac.denominator // common_divisor)", "def complex_fraction(frac):\n    \"\"\"\n    Simplifies fractions where numerator or denominator can be an expression involving factorials or square roots.\n    Parameters:\n    - frac (tuple): The fraction where elements can be integers or sympy expressions.\n    Returns:\n    - Rational: The simplified fraction.\n    Examples:\n    >>> operate_fractions((factorial(5), factorial(3)), (sqrt(9), factorial(2)), 'multiply')\n    Rational(20, 1)  # 5! / 3! * sqrt(9) / 2! = 20\n    \"\"\"\n    simplified_numerator = factorial(frac[0]) if isinstance(frac[0], int) else sqrt(frac[0])\n    simplified_denominator = factorial(frac[1]) if isinstance(frac[1], int) else sqrt(frac[1])\n    return simplified_numerator / simplified_denominator", "def reciprocal_fraction(frac):\n    \"\"\"\n    Calculates the reciprocal of a given fraction (inverse).\n    Parameters:\n        frac (Fraction or str or tuple): The fraction to invert, similar format as in simplify_fraction.\n    \n    Returns:\n        Fraction: The reciprocal of the given fraction.\n    Example:\n        >>> reciprocal_fraction('1/4')\n        Fraction(4, 1)\n    \"\"\"\n    frac = Fraction(frac)\n    if frac.numerator == 0:\n        raise ValueError(\"Reciprocal does not exist for zero numerator.\")\n    return Fraction(frac.denominator, frac.numerator)", "def factorial_fraction_reduction(numerator, denominator):\n    \"\"\"\n    Reduces a fraction which involves factorials in the numerator and/or the denominator.\n    Parameters:\n    numerator (str): The factorial expression for the numerator.\n    denominator (str): The factorial expression for the denominator.\n    Returns:\n    sp.Expr: The reduced form of the expression.\n    Examples:\n    >>> factorial_fraction_reduction('5!', '3!')\n    '20'\n    >>> factorial_fraction_reduction('10!', '8!')\n    '90'\n    \"\"\"\n    num_fact = sp.factorial(sp.sympify(numerator[:-1])) if '!' in numerator else sp.sympify(numerator)\n    denom_fact = sp.factorial(sp.sympify(denominator[:-1])) if '!' in denominator else sp.sympify(denominator)\n    return sp.simplify(num_fact / denom_fact)", "def simplify_with_roots(expression):\n    \"\"\"\n    Simplifies expressions that include roots.\n    Parameters:\n    expression (str): A string expression that might include roots, e.g., sqrt(x), x**(1/3), etc.\n    Returns:\n    sp.Expr: The simplified expression with roots.\n    Examples:\n    >>> simplify_with_roots('sqrt(8)')\n    '2*sqrt(2)'\n    >>> simplify_with_roots('x**(1/3) * x**(2/3)')\n    'x'\n    \"\"\"\n    expr = sp.sympify(expression)\n    return sp.simplify(expr)", "def find_lcm(a, b):\n    \"\"\"Compute least common multiple of two numbers.\n    \n    Parameters:\n    - a, b (int): Integers to find the LCM of.\n    \n    Returns:\n    - int: Least common multiple of a and b.\n    \n    Examples:\n    >>> find_lcm(6, 8)\n    24\n    \"\"\"\n    return a * b // gcd(a, b)", "def calculate_probability(frac):\n    \"\"\"\n    Calculates the probability expressed by a fraction.\n    Parameters:\n        frac (Fraction or str or tuple): The fraction representing the probability, similar format as in simplify_fraction.\n    \n    Returns:\n        float: The numeric value of the probability.\n    Example:\n        >>> calculate_probability('1/4')\n        0.25\n    \"\"\"\n    return float(Fraction(frac))"], "Addition": ["def sum_of_integers(n):\n    \"\"\"\n    Calculate the sum of the first n integers using the formula n(n+1)/2.\n    \n    Parameters:\n    n : int\n        The nth term till which the sum is to be calculated.\n    \n    Returns:\n    int\n        The sum of the first n natural numbers.\n    \n    Examples:\n    >>> sum_of_integers(10)\n    55\n    \n    >>> sum_of_integers(100)\n    5050\n    \"\"\"\n    return n * (n + 1) // 2", "def sum_numbers(*args):\n    \"\"\"\n    Computes the sum of all provided arguments. This function can handle a flexible\n    amount of numbers as well as lists of numbers.\n    Parameters:\n    - args (int, float, list): Individual numbers or lists of numbers.\n    Returns:\n    - float: The total sum of all input numbers.\n    Examples:\n    >>> sum_numbers(5, 10)\n    15\n    >>> sum_numbers([1, 2, 3], 4)\n    10\n    >>> sum_numbers(7.2, 0.3)\n    7.5\n    \"\"\"\n    total_sum = 0\n    for arg in args:\n        if isinstance(arg, list):\n            total_sum += sum(arg)\n        else:\n            total_sum += arg\n    return total_sum", "def sum_values(*args):\n    \"\"\"\n    Calculate the sum of an arbitrary number of values or a single list of values.\n    \n    Parameters:\n        *args: A variable length argument list containing numbers or a single iterable(list, tuple) of numbers.\n    \n    Returns:\n        float: The sum of the provided values.\n        \n    Examples:\n        >>> sum_values(1, 2, 3, 4)\n        10\n        >>> sum_values([1, 2, 3, 4])\n        10\n    \"\"\"\n    import numpy as np\n    if len(args) == 1 and hasattr(args[0], '__iter__'):\n        return float(np.sum(args[0]))\n    else:\n        return float(np.sum(args))", "def sum_of_digits(number):\n    \"\"\"\n    Calculates the sum of the digits of a given number.\n    Parameters:\n    - number (int, float): The number from which to sum the digits.\n    Returns:\n    - int: The sum of the digits.\n    Examples:\n    >>> sum_of_digits(123)\n    6\n    >>> sum_of_digits(1042)\n    7\n    \"\"\"\n    return sum(int(digit) for digit in str(int(number)))", "def sum_numbers(numbers):\n    \"\"\"\n    Calculate the sum of a list of numbers.\n    Parameters:\n    numbers (list of float or int): A list containing numbers to be summed.\n    Returns:\n    float or int: The sum of the given numbers.\n    Examples:\n    >>> sum_numbers([1, 2, 3, 4, 5])\n    15\n    >>> sum_numbers([10.5, 20.6])\n    31.1\n    \"\"\"\n    if not all(isinstance(x, (int, float)) for x in numbers):\n        raise ValueError(\"All elements in list must be integers or floats\")\n    return sum(numbers)", "def add_numbers(*args):\n    \"\"\"\n    Add a series of numbers together.\n    \n    Parameters:\n    *args : float or int\n        A variable number of arguments that are the numbers to be added together.\n    \n    Returns:\n    float\n        The sum of the provided numbers.\n    \n    Examples:\n    >>> add_numbers(1, 2, 3)\n    6\n    \n    >>> add_numbers(10.5, 3.2)\n    13.7\n    \"\"\"\n    sum_total = sum(args)\n    return sum_total", "def average_elements(numbers):\n    \"\"\"\n    Computes the average of a list of numbers.\n    \n    Parameters:\n    numbers (list): A list of numbers (int or float) to compute the average of.\n    \n    Returns:\n    float: The average of the provided numbers.\n    \n    Examples:\n    >>> average_elements([10, 20, 30, 40])\n    25.0\n    >>> average_elements([1.5, 2.5, 3.5])\n    2.5\n    \"\"\"\n    if not numbers:\n        raise ValueError(\"The input list 'numbers' cannot be empty.\")\n    total_sum = sum(numbers)\n    count = len(numbers)\n    return total_sum / count", "def sum_numerical_values(numbers):\n    \"\"\"\n    Sum multiple numerical values accurately using numpy for floating-point precision.\n    Parameters\n    ----------\n    numbers : list of float\n        A list of numerical values to be summed.\n    Returns\n    -------\n    float\n        The summation result of the numerical values.\n    Examples\n    --------\n    >>> sum_numerical_values([0.1, 0.2, 0.3])\n    0.6\n    \n    >>> sum_numerical_values([1.5, 2.5, 3])\n    7.0\n    \"\"\"\n    return np.sum(numbers)", "def numpy_based_sum(numbers):\n    \"\"\"\n    Sum an array of numbers using the numpy library for enhanced performance\n    and potentially better handling of very large arrays of numbers.\n    Parameters:\n    numbers : array_like\n        An array, list, or tuple of numbers (int, float, or complex) to be summed.\n    Returns:\n    float or complex\n        The sum of the array elements, returned as float or complex based on the input type.\n    Examples:\n    >>> numpy_based_sum([0.1, 0.2, 0.3])\n    0.6000000000000001\n    >>> numpy_based_sum([1, 2, 3, 4, 5])\n    15.0\n    >>> numpy_based_sum(np.array([1e-16, 1e-16], dtype=np.float64))\n    2e-16\n    \"\"\"\n    # Utilizing numpy's sum to potentially leverage faster computations on arrays:\n    return np.sum(np.array(numbers))", "def detailed_addition(n1, n2):\n    \"\"\"\n    Breaks down two numbers into tens and units, then performs an addition, returning the detailed result.\n    Parameters:\n    - n1, n2 (int): Two-digit numbers to decompose and add.\n    Returns:\n    - dict: Result of detailed addition with breakdowns.\n    Examples:\n    >>> detailed_addition(14, 25)\n    {'Tens': 3, 'Units': 9}\n    \"\"\"\n    tens1, units1 = divmod(n1, 10)\n    tens2, units2 = divmod(n2, 10)\n    total_tens = tens1 + tens2\n    total_units = units1 + units2\n    if total_units >= 10:\n        total_tens += 1\n        total_units -= 10\n    return {'Tens': total_tens, 'Units': total_units}", "def sum_financials(**kwargs):\n    \"\"\"\n    A function to compute sum of various financial components, each represented as keyword arguments.\n    Parameters:\n    -----------\n    **kwargs : dict\n        Key-value pairs where keys are the name of the financial component and values are their numerical amount.\n    Returns:\n    --------\n    dict\n        A dictionary containing the total sum with a breakdown over different components.\n    Examples:\n    ---------\n    >>> sum_financials(daily_rental=50.5, mileage_cost=30.2, extra_fees=45)\n    {'total': 125.7, 'breakdown': {'daily_rental': 50.5, 'mileage_cost': 30.2, 'extra_fees': 45}}\n    \"\"\"\n    total_sum = sum(kwargs.values())\n    return {'total': total_sum, 'breakdown': kwargs}", "def accurate_sum(*numbers):\n    \"\"\"\n    Sum a sequence of numbers accurately.\n    This function uses Python's built-in types to manage higher precision addition of floating-point numbers\n    and can be adapted to use different precision strategies (like using decimal.Decimal for arbitrary\n    precision).\n    Parameters:\n    *numbers : float or int\n        A variable number of numbers (either floats or ints), which will be summed together.\n    Returns:\n    float\n        The accurate sum of the provided numbers.\n    Examples:\n    >>> accurate_sum(0.1, 0.2, 0.3)\n    0.6\n    >>> accurate_sum(1, 2, 3, 4, 5)\n    15\n    >>> accurate_sum(1e-16, 1e-16)\n    2e-16\n    \"\"\"\n    # A straightforward and precise addition:\n    # In Python 3.x, the built-in sum is implemented very effectively for a sequence of floats.\n    return sum(numbers)", "def sum_with_rounding(*args, decimal_places=2):\n    \"\"\"\n    Adds numbers with rounding the result to a specific number of decimal places.\n    \n    Parameters:\n    *args : float\n        Variable number of float numbers to be added.\n    decimal_places : int\n        Number of decimal places to round the final sum to.\n    \n    Returns:\n    float\n        The sum of the numbers rounded to the specified number of decimal places.\n    \n    Examples:\n    >>> sum_with_rounding(0.123, 0.456, decimal_places=2)\n    0.58\n    \n    >>> sum_with_rounding(0.123, 0.456, 0.789, decimal_places=1)\n    1.4\n    \"\"\"\n    return round(sum(args), decimal_places)", "def calculate_total_cost(base_costs, additional_costs_per_unit, units):\n    \"\"\"\n    Calculate total costs by adding base costs and additional costs, which are dependent on units.\n    \n    Parameters:\n        base_costs (float): The fixed base cost.\n        additional_costs_per_unit (float): Cost per unit.\n        units (int or float): Number of units.\n    Returns:\n        float: The total cost calculated.\n    Examples:\n        >>> calculate_total_cost(150, 0.1, 50)\n        155.0\n    \"\"\"\n    return base_costs + additional_costs_per_unit * units", "def add_place_values(*args):\n    \"\"\"\n    Adds numbers by handling place values separately.\n    \n    Parameters:\n    *args : tuples of (int, int)\n        Variable number of arguments where each argument is a tuple representing (value, place_value_multiplier).\n    \n    Returns:\n    int\n        The sum where each number has been multiplied by its place value before summing.\n    \n    Examples:\n    >>> add_place_values((20, 10), (5, 1))  # 20 tens and 5 ones\n    205\n    \n    >>> add_place_values((3, 100), (47, 1))  # 3 hundreds and 47 ones\n    347\n    \"\"\"\n    return sum(num * multiplier for num, multiplier in args)", "def sum_coefficients(coefficients, variable_symbol):\n    \"\"\"\n    Sum the coefficients of an algebraic expression using sympy for symbolic computation.\n    Parameters\n    ----------\n    coefficients : list of float\n        A list of coefficients to be summed.\n    variable_symbol : str\n        The variable symbol (as a string) for which the coefficients are multiplied.\n    Returns\n    -------\n    sympy.Expr\n        The summation result as a symbolic expression.\n    Examples\n    --------\n    >>> sum_coefficients([1, 2, 3], 'x')\n    6*x\n    \n    >>> sum_coefficients([0.5, 1.5, 2.5], 'y')\n    4.5*y\n    \"\"\"\n    var = symbols(variable_symbol)\n    expr = Add(*[coeff * var for coeff in coefficients])\n    return expr", "def sum_by_category(values, categories):\n    \"\"\"\n    Sum numbers grouped by categories provided in a separate list of the same length.\n    Parameters:\n        values (list of numbers): The numbers to be summed.\n        categories (list of str or int): A list categorizing each entry in values.\n    Returns:\n        dict: A dictionary with categories as keys and their summed values as values.\n    Examples:\n        >>> sum_by_category([100, 200, 150, 150], ['travel', 'travel', 'food', 'food'])\n        {'travel': 300, 'food': 300}\n    \"\"\"\n    import numpy as np\n    unique_categories = np.unique(categories)\n    summed_by_category = {}\n    for category in unique_categories:\n        summed_by_category[category] = float(np.sum(np.array(values)[np.array(categories) == category]))\n    return summed_by_category", "def sum_numbers(*args):\n    \"\"\"\n    Calculate the sum of an arbitrary number of numbers.\n    Parameters:\n    *args : float\n        A variable number of numeric arguments to be summed up.\n    Returns:\n    float\n        The sum of all given numbers.\n    Example:\n    >>> sum_numbers(10, 20, 30)\n    60\n    >>> sum_numbers(12.5, 3.4, 0.1)\n    16.0\n    \"\"\"\n    return sum(args)", "def generalized_sum(*numbers):\n    \"\"\"\n    Calculate the sum of an arbitrary number of numbers or lists of numbers.\n    Can handle single values, lists, and numpy arrays.\n    Parameters\n    ----------\n    *numbers : int, float, list, or numpy.ndarray\n        Variable length argument list. Each element being a number or a collection of numbers.\n    Returns\n    -------\n    float or int\n        Sum of all the numbers provided.\n    Examples\n    --------\n    >>> generalized_sum(10, 20, 30)\n    60\n    >>> generalized_sum([1, 2, 3], 5, [6, 4])\n    21\n    >>> import numpy as np\n    >>> generalized_sum(np.array([1, 2, 3]), 3)\n    9\n    \"\"\"\n    from numpy import ndarray, sum as np_sum\n    total = 0\n    for number in numbers:\n        if isinstance(number, (list, ndarray)):\n            total += np_sum(number)\n        else:\n            total += number\n    return total"], "Ratios and Proportions": ["def create_ratio(a, b):\n    \"\"\"\n    Create a ratio from two given numbers and simplify it.\n    Parameters:\n        a (int or float): The first quantity.\n        b (int or float): The second quantity.\n    Returns:\n        tuple: A tuple representing the simplified ratio (a, b).\n    Examples:\n        >>> create_ratio(12, 16)\n        (3, 4)\n    \"\"\"\n    gcd = math.gcd(int(a), int(b))  # Ensure numbers are treated as integers for gcd\n    return (a // gcd, b // gcd)", "def solve_proportional_ratio(a, b, c, d):\n    \"\"\"\n    Solves proportional ratios where one of the variables a, b, c, or d is None.\n    The ratio is defined as a:b = c:d.\n    Parameters:\n    - a (float or None): The first term of the first ratio (or None if unknown).\n    - b (float or None): The second term of the first ratio (or None if unknown).\n    - c (float or None): The first term of the second ratio (or None if unknown).\n    - d (float or None): The second term of the second ratio (or None if unknown).\n    Returns:\n    - float: The computed value of the unknown.\n    Example:\n    >>> solve_proportional_ratio(None, 2, 3, 6)\n    1\n    \"\"\"\n    if a is None:\n        return (b * c) / d\n    elif b is None:\n        return (a * d) / c\n    elif c is None:\n        return (a * d) / b\n    elif d is None:\n        return (b * c) / a", "def compute_part_of_whole(whole, numerator, denominator):\n    \"\"\"\n    Calculate the value representing a part of a whole given a ratio.\n    \n    Parameters:\n    - whole (float): The total or whole value.\n    - numerator (int): The numerator of the ratio.\n    - denominator (int): The denominator of the ratio.\n    \n    Returns:\n    - float: The part of the whole as defined by the ratio.\n    \n    Example:\n    >>> compute_part_of_whole(100, 1, 4)\n    25.0\n    \"\"\"\n    from fractions import Fraction\n    return whole * Fraction(numerator, denominator)", "def scale_proportionally(original_value, original_ratio, target_ratio):\n    \"\"\"\n    Calculate a new value that is proportionally scaled from an original ratio to a target ratio.\n    \n    Parameters:\n    original_value (float or int): The original value corresponding to the original ratio.\n    original_ratio (float or int): The original base ratio.\n    target_ratio (float or int): The ratio to which the value needs to be adjusted.\n    \n    Returns:\n    float: The adjusted value calculated as per the new target ratio.\n    \n    Example:\n    >>> scale_proportionally(100, 1, 2)\n    200.0  # If the original value is scaled from a ratio of 1 to 2, the target value will be twice the original.\n    \n    >>> scale_proportionally(150, 3, 2)\n    100.0  # Adjusts the value from a ratio of 3 to 2, effectively reducing the original value.\n    \"\"\"\n    if original_ratio == 0:\n        raise ValueError(\"original_ratio cannot be zero.\")\n    return (original_value / original_ratio) * target_ratio", "def find_proportionate_value(base_value, base_ratio, target_ratio):\n    \"\"\"\n    Calculate the target value given the base value and the target ratio based on a base ratio.\n    \n    Parameters:\n    base_value (float): Known base value.\n    base_ratio (tuple): Known base ratio (numerator, denominator).\n    target_ratio (tuple): Target ratio to find the corresponding value for (numerator, denominator).\n    \n    Returns:\n    float: The target value based on the proportionality.\n    \n    Example:\n    >>> find_proportionate_value(200, (3, 2), (4, 1))\n    400.0\n    \"\"\"\n    base_numerator, base_denominator = base_ratio\n    target_numerator, target_denominator = target_ratio\n    \n    return base_value * (target_numerator/target_denominator) / (base_numerator/base_denominator)", "def split_quantity_by_ratio(total_quantity, ratio):\n    \"\"\"\n    Split a total quantity into parts according to a given ratio.\n    Parameters:\n    total_quantity (float): The total amount to be divided.\n    ratio (tuple of int): The ratio by which to divide the total quantity.\n    Returns:\n    list: A list of quantities divided according to the ratio.\n    Example:\n    >>> split_quantity_by_ratio(120, (1, 2, 3))\n    [20.0, 40.0, 60.0]\n    \"\"\"\n    ratio_sum = sum(ratio)\n    return [total_quantity * (part / ratio_sum) for part in ratio]", "def scale_ratio(ratio, factor):\n    \"\"\"\n    Scale a given ratio by a multiplication factor.\n    Parameters:\n    ratio (tuple): A tuple containing the numerator and denominator of the ratio.\n    factor (int/float): The factor by which to scale the ratio.\n    \n    Returns:\n    tuple: A scaled ratio in its simplest form.\n    \n    Examples:\n    >>> scale_ratio((3, 4), 2)\n    (6, 8)\n    >>> scale_ratio((2, 3), 5)\n    (10, 15)\n    \"\"\"\n    scaled_numerator = ratio[0] * factor\n    scaled_denominator = ratio[1] * factor\n    return (scaled_numerator, scaled_denominator)", "def is_proportional(a, b, c, d):\n    \"\"\"\n    Check if two given ratios (a:b and c:d) are proportional.\n    Parameters:\n    a (float): the first term of the first ratio.\n    b (float): the second term of the first ratio.\n    c (float): the first term of the second ratio.\n    d (float): the second term of the second ratio.\n    Returns:\n    bool: True if the ratios are equivalent, False otherwise.\n    Examples:\n    >>> is_proportional(1, 2, 2, 4)\n    True  # Explanation (1/2 == 2/4)\n    >>> is_proportional(1, 3, 2, 6)\n    True  # Explanation (1/3 == 2/6)\n    \"\"\"\n    return (a * d) == (b * c)", "def solve_proportion(a, b, c):\n    \"\"\"\n    Based on the proportional relationship a:b = c:x, solve for x.\n    Parameters:\n    - a (float or int): The first term of the first ratio.\n    - b (float or int): The second term of the first ratio.\n    - c (float or int): The first term of the second ratio.\n    Returns:\n    - float: The calculated value of x in the second ratio.\n    Example:\n    >>> solve_proportion(1, 2, 3)\n    6.0\n    \"\"\"\n    return (b * c) / a", "def compare_ratios(ratio1, ratio2):\n    \"\"\"\n    Compare two ratios to determine if they are equivalent.\n    \n    Parameters:\n        ratio1 (tuple): First ratio in the form (numerator, denominator).\n        ratio2 (tuple): Second ratio in the form (numerator, denominator).\n        \n    Returns:\n        bool: True if ratios are equivalent, False otherwise.\n    \n    Examples:\n        >>> compare_ratios((1, 2), (2, 4))\n        True\n        >>> compare_ratios((1, 3), (2, 4))\n        False\n    \"\"\"\n    # Cross-multiplication to check if ratios are equivalent\n    return ratio1[0] * ratio2[1] == ratio1[1] * ratio2[0]", "def calculate_missing_value_in_proportion(a, b, c, missing_position):\n    \"\"\"\n    Calculate the missing value in a proportion given three known values.\n    \n    Parameters:\n    - a (float or int): The first known value of the proportion\n    - b (float or int): The second known value of the proportion related to `a`\n    - c (float or int): The third known value of the proportion\n    - missing_position (str): A string indicating which position is missing among 'a', 'b', or 'c',\n                              describing the relationship as a:b::c:x (x is the missing value)\n    \n    Returns:\n    - float: The calculated missing value maintaining the proportion.\n    Examples:\n    >>> calculate_missing_value_in_proportion(1, 2, 3, 'b')\n    6.0\n    >>> calculate_missing_value_in_proportion(2, 4, 10, 'c')\n    20.0\n    \"\"\"\n    import sys\n    if missing_position not in ['a', 'b', 'c']:\n        raise ValueError(\"missing_position must be 'a', 'b', or 'c'\")\n    \n    try:\n        if missing_position == 'b':\n            return (b * c) / a\n        elif missing_position == 'a':\n            return (b * a) / c\n        elif missing_position == 'c':\n            return (c * a) / b\n    except ZeroDivisionError:\n        sys.exit(\"Error: Division by zero occurred in proportions calculations.\")", "def scale_ratio(a, b, factor):\n    \"\"\"\n    Scales both terms of a given ratio by the specified factor.\n    Parameters:\n        a (int or float): The first quantity in the ratio.\n        b (int or float): The second quantity in the ratio.\n        factor (int or float): The factor by which to scale the ratio.\n    Returns:\n        tuple: A tuple representing the scaled ratio.\n    Examples:\n        >>> scale_ratio(3, 4, 3)\n        (9, 12)\n    \"\"\"\n    return (a * factor, b * factor)", "def calculate_simplified_ratio(value1, value2):\n    \"\"\"\n    Calculate the simplified ratio between two values.\n    \n    Parameters:\n    value1 (int/float): The first value.\n    value2 (int/float): The second value.\n  \n    Returns:\n    Rational: The simplified ratio of the two values.\n    \n    Example:\n    >>> calculate_simplified_ratio(150, 100)\n    Rational(3, 2)\n    \"\"\"\n    return nsimplify(Rational(value1, value2))", "def calculate_unit_rate(value_a, value_b):\n    \"\"\"\n    Calculate the unit rate or ratio of two values.\n    Parameters:\n    - value_a (float or int): Represents the first quantity in the ratio.\n    - value_b (float or int): Represents the second quantity with which the first quantity is being compared.\n    Returns:\n    - float: The unit rate or ratio value_a/value_b.\n    Examples:\n    >>> calculate_unit_rate(10, 2)\n    5.0\n    >>> calculate_unit_rate(50, 4)\n    12.5\n    \"\"\"\n    return value_a / value_b if value_b != 0 else None", "def calculate_missing_ratio_value(known_values, known_total, find_index):\n    \"\"\"\n    Given partial values in a ratio and a known total sum or product of all elements, find the missing value.\n    Parameters:\n    known_values (list of tuples): A list where each tuple contains the index (0-based) and the value of the known elements.\n    known_total (float): The known total sum or desired proportional product of the elements.\n    find_index (int): The index of the value to find.\n    Returns:\n    float: The calculated value at the find_index position within the distributed ratio.\n    Example:\n    >>> calculate_missing_ratio_value([(0, 2), (2, 5)], 21, 1)\n    14\n    \"\"\"\n    import math\n    \n    indices, values = zip(*known_values)\n    \n    if find_index in indices:\n        return values[indices.index(find_index)]\n    \n    # Calculate the proportionality constant\n    k = math.prod(values) / (known_total - sum(values))\n    \n    # Recreate complete ratio list based on the known total and partial values\n    total_parts = sum(values) + k * (len(values) + 1 - len(known_values))\n    ratio_values = list(values)\n    \n    # Find the missing values\n    missing_sum = known_total - sum(values)\n    factor = missing_sum / k\n    \n    # Gather all calculated ratio values\n    full_values = [factor if i not in indices else ratio_values[indices.index(i)] for i in range(len(values)+1)]\n    \n    # Return the value at the required index\n    return full_values[find_index]", "def simplify_fraction(a, b):\n    \"\"\"\n    Simplifies a fraction and returns the result in lowest terms.\n    \n    Parameters:\n    a (int): Numerator.\n    b (int): Denominator.\n    \n    Returns:\n    Fraction: A Fraction object of the simplified fraction.\n    \n    Examples:\n    >>> str(simplify_fraction(8, 24))\n    '1/3'\n    >>> str(simplify_fraction(18, 15))\n    '6/5'\n    \"\"\"\n    return Fraction(a, b).limit_denominator()", "def scale_quantity(ratio_a, ratio_b, target_total):\n    \"\"\"\n    Scale quantities based on a given ratio summing to a target total.\n    \n    Parameters:\n    ratio_a (int): Part of the first element in the ratio.\n    ratio_b (int): Part of the second element in the ratio.\n    target_total (int): Desired total sum of the scaled quantities.\n    \n    Returns:\n    tuple: Returns the scaled values of the two parts that maintain the original ratio.\n    \n    Examples:\n    >>> scale_quantity(1, 2, 30)\n    (10, 20)\n    >>> scale_quantity(3, 1, 40)\n    (30, 10)\n    \"\"\"\n    total_parts = ratio_a + ratio_b\n    part_value = target_total / total_parts\n    return (int(part_value * ratio_a), int(part_value * ratio_b))", "def distribute_proportionally(values, total):\n    \"\"\"\n    Distributes a total amount proportionally according to a list of values.\n    Parameters:\n    - values (list of floats): A list representing parts of a whole.\n    - total (float): The total amount to be distributed following the proportions given by `values`.\n    Returns:\n    - list of floats: A list of amounts distributed proportionally.\n    Example:\n    >>> distribute_proportionally([1, 2, 3], 600)\n    [100.0, 200.0, 300.0]\n    \"\"\"\n    sum_values = sum(values)\n    return [(val / sum_values) * total for val in values]", "def apply_unit_rate(unit_rate, new_quantity):\n    \"\"\"\n    Apply a given unit rate to a new quantity to find the scaled value.\n    \n    Parameters:\n    unit_rate (float): The pre-calculated ratio or unit rate.\n    new_quantity (float or int): The amount of the unit to scale the ratio to.\n    \n    Returns:\n    float: The scaled value based on the given unit rate and new quantity.\n    \n    Example:\n    >>> apply_unit_readable_rate(25, 2)\n    50.0\n    >>> apply_unit_readable_rate(50, 4)\n    200.0\n    \"\"\"\n    return unit_rate * new_quantity", "def scale_unit_rate(unit_rate, scaling_factor):\n    \"\"\"\n    Scale a given unit rate by a particular factor.\n    Parameters:\n    - unit_rate (float): The base unit rate to be scaled.\n    - scaling_factor (float or int): The factor by which the unit rate is to be multiplied.\n    Returns:\n    - float: The scaled unit rate.\n    Examples:\n    >>> scale_unit_rate(5.0, 3)\n    15.0\n    >>> scale_unit_rate(7.5, 2)\n    15.0\n    \"\"\"\n    return unit_rate * scaling_factor", "def convert_units(value, from_unit, to_unit):\n    \"\"\"\n    Converts a given value from one unit to another based on provided conversion factors.\n    \n    Parameters:\n    value (float): The value to be converted.\n    from_unit (str): The unit the value is currently expressed in.\n    to_unit (str): The unit the value needs to be converted to.\n    \n    Returns:\n    float: The value in the new unit.\n    \n    Example:\n    # Converting 1000 meters to kilometers\n    >>> convert_units(1000, 'm', 'km')\n    1.0\n    \"\"\"\n    unit_conversions = {\n        'm': 1,\n        'km': kilo,\n        'mm': milli,\n        'um': micro,\n        'mg': milli,\n        'kg': kilo,\n        'MB': mega,\n    }\n    \n    if from_unit not in unit_conversions or to_unit not in unit_conversions:\n        raise ValueError(\"Unsupported unit conversion\")\n    \n    value_in_meters = value * unit_conversions[from_unit]\n    value_in_target_unit = value_in_meters / unit_conversions[to_unit]\n    \n    return value_in_target_unit", "def compute_ratio(value1, value2):\n    \"\"\"\n    Computes the ratio of two values which is a simple division of one by another.\n    Parameters:\n    - value1 (float or int): Numerator in the calculation of the ratio.\n    - value2 (float or int): Denominator in the calculation of the ratio.\n    Returns:\n    - float: The computed ratio.\n    Examples:\n    >>> compute_ratio(10, 2)\n    5.0\n    >>> compute_ratio(7, 14)\n    0.5\n    \"\"\"\n    try:\n        return value1 / value2\n    except ZeroDivisionError:\n        return float('inf')  # To handle division by zero gracefully, often returned as infinity in mathematical contexts.", "def simplify_ratio(*args: int) -> Tuple[int, ...]:\n    \"\"\"\n    Simplifies a ratio of two or more integers to its simplest form.\n    Parameters:\n    - args (int): Variable number of integers comprising the ratio.\n    Returns:\n    - Tuple[int, ...]: The simplified ratio as a tuple of integers.\n    Examples:\n    >>> simplify_ratio(2, 4)\n    (1, 2)\n    >>> simplify_ratio(3, 6, 9)\n    (1, 2, 3)\n    \"\"\"\n    if not all(isinstance(x, int) for x in args):\n        raise ValueError(\"All inputs must be integers.\")\n    gcd = math.gcd(*args)\n    return tuple(x // gcd for x in args)", "def compute_ratio(part, whole):\n    \"\"\"\n    Computes the ratio of a part to a whole, expressed in the simplest fractional form.\n    Parameters:\n    - part (float|int): The part or subset quantity\n    - whole (float|int): The total or whole quantity\n    Returns:\n    - tuple (int, int): The ratio in the form of a numerator and denominator (simplest form).\n    Examples:\n    >>> compute_ratio(2, 8)\n    (1, 4)\n    >>> compute_ratio(3, 12)\n    (1, 4)\n    \"\"\"\n    from math import gcd\n    divisor = gcd(int(part), int(whole))\n    return (part // divisor, whole // divisor)", "def triangle_angle_from_ratio(angle_a, ratio_ab, target='B'):\n    \"\"\"\n    Given an angle of a triangle and the ratio of two sides, compute the other angle.\n    Parameters:\n    - angle_a (float): Known angle in degrees.\n    - ratio_ab (tuple): A tuple of two integers (part_a, part_b) representing the ratio of sides opposite to\n                        angle A and B respectively.\n    - target (str): The target angle to compute. Either 'B' or 'C'.\n    Returns:\n    - float: The computed angle in degrees. If the triangle is assumed similar and sum of angles in a\n             triangle is 180 degrees.\n    Examples:\n    >>> triangle_angle_from_ratio(45, (1, 1), 'B')\n    45.0\n    >>> triangle_angle_from_ratio(60, (2, 1), 'C')\n    30.0\n    \"\"\"\n    if target == 'C':\n        # if sum of angles in triangle is 180\n        angle_b = angle_a * (ratio_ab[0] / ratio_ab[1])\n        return 180 - angle_a - angle_b\n    elif target == 'B':\n        angle_b = angle_a * (ratio_ab[1] / ratio_ab[0])\n        return angle_b\n    else:\n        raise ValueError(\"Invalid target angle specified. Choose either 'B' or 'C'\")", "def triangle_angle_by_ratio(angle_ratio, total_angle=180):\n    \"\"\"\n    Compute angles of a triangle given a ratio between them.\n    Parameters\n    ----------\n    angle_ratio : tuple of ints\n        The ratio between the angles of the triangle. E.g., (2, 3, 4) specifies the ratio of angles.\n    total_angle : int, optional\n        The total sum of angles in a triangle, by default this is 180 degrees (valid for Euclidean geometry).\n    Returns\n    -------\n    list\n        List containing the actual angles of the triangle.\n    Example\n    -------\n    >>> triangle_angle_by_ratio((2, 3, 4))\n    [30.0, 45.0, 60.0]\n    \"\"\"\n    factor = total_angle / sum(angle_ratio)\n    return [x * factor for x in angle_ratio]", "def scale_dimensions(original_width, original_height, scale_factor):\n    \"\"\"\n    Scales dimensions by a given factor while maintaining aspect ratio.\n    \n    Parameters:\n        original_width (float or int): The original width dimension.\n        original_height (float or int): The original height dimension.\n        scale_factor (float): The factor by which to scale the dimensions.\n    Returns:\n        tuple of float: The new width and height after scaling.\n    \n    Example:\n        >>> scale_dimensions(1920, 1080, 0.5)\n        (960.0, 540.0)\n    \"\"\"\n    new_width = original_width * scale_factor\n    new_height = original_height * scale_factor\n    return (new_width, new_height)", "def calculate_unit_rate(quantity1, quantity2):\n    \"\"\"\n    Calculate the unit rate between two quantities.\n    \n    Parameters:\n    quantity1 (float or int): The first quantity (numerator).\n    quantity2 (float or int): The second quantity (denominator).\n    Returns:\n    float: The value of the first quantity per one unit of the second quantity.\n          \n    Example:\n    >>> calculate_unit_rate(100, 4)\n    25.0\n    >>> calculate_unit_rate(150, 3)\n    50.0\n    \"\"\"\n    if quantity2 == 0:\n        raise ValueError(\"The second quantity (denominator) cannot be zero.\")\n    return quantity1 / quantity2"], "Division": ["def divide_numbers(numerator, denominator):\n    \"\"\"\n    Perform division of two numbers, handling integers and floats.\n    \n    Parameters:\n        numerator (float or int): The dividend.\n        denominator (float or int): The divisor, must not be zero.\n    Returns:\n        float: The result of the division.\n    Example:\n        >>> divide_numbers(10, 2)\n        5.0\n        >>> divide_numbers(12.5, 5)\n        2.5\n    \"\"\"\n    if denominator == 0:\n        raise ValueError(\"Denominator cannot be zero.\")\n    return numerator / denominator", "def integer_division(dividend, divisor):\n    \"\"\"\n    Perform integer division on the provided dividend and divisor, returning both the quotient and the remainder.\n    Parameters:\n    - dividend (int): The number to be divided.\n    - divisor (int): The number by which the dividend is divided.\n    Returns:\n    - tuple: A tuple containing the quotient and remainder (quotient, remainder).\n    \n    Examples:\n    - integer_division(10, 3) returns (3, 1)\n    - integer_division(20, 5) returns (4, 0)\n    \"\"\"\n    quotient = np.floor_divide(dividend, divisor)\n    remainder = np.remainder(dividend, divisor)\n    return (quotient, remainder)", "def mixed_to_improper(whole, numerator, denominator):\n    \"\"\"\n    Convert a mixed number to an improper fraction.\n    \n    Parameters:\n    whole (int): The whole number part of the mixed number.\n    numerator (int): The fractional part's numerator of the mixed number.\n    denominator (int): The fractional part's denominator of the mixed number.\n    \n    Returns:\n    Fraction: an improper fraction representing the mixed number.\n    \n    Example:\n    >>> mixed_to_improper(3, 1, 4)\n    Fraction(13, 4)\n    \"\"\"\n    return Fraction(whole * denominator + numerator, denominator)", "def evaluate_expression(expression):\n    \"\"\"\n    Evaluate a mathematical expression, particularly handling the order of operations\n    including division.\n    Parameters:\n    expression (str): The mathematical expression to evaluate.\n    Returns:\n    float: The result of the evaluated expression.\n    Examples:\n    >>> evaluate_expression(\"12 / 3 / 2\")\n    2.0\n    >>> evaluate_expression(\"(10 + 5) / 3\")\n    5.0\n    \"\"\"\n    return float(sp.sympify(expression))", "def convert_units(value, from_unit, to_unit, conversion_factor):\n    \"\"\"\n    Converts a value from one unit to another using a conversion factor.\n    \n    Parameters:\n    value (float): The value to convert.\n    from_unit (str): The current unit of the value.\n    to_unit (str): The target unit to convert to.\n    conversion_factor (float): The factor used to perform the conversion.\n    \n    Returns:\n    float: The value converted into the new unit.\n    \n    Example:\n    >>> convert_units(1000, 'grams', 'kilograms', 0.001)\n    1.0\n    \"\"\"\n    return value * conversion_factor", "def simplify_fraction(numerator, denominator):\n    \"\"\"\n    Simplify a fraction to its lowest terms.\n    \n    Parameters:\n        numerator (int): The numerator of the fraction.\n        denominator (int): The denominator of the fraction.\n    Returns:\n        Fraction: The simplified fraction.\n    Examples:\n        >>> simplify_fraction(8, 20)\n        Fraction(2, 5)\n    \"\"\"\n    return Fraction(numerator, denominator)", "def count_integers_in_interval(start, end, divisor):\n    \"\"\"\n    Count the number of integers within a specified range [start, end] that are divisible by a given divisor.\n    Parameters:\n        start (int): The starting integer of the interval.\n        end (int): The ending integer of the interval.\n        divisor (int): The divisor to check divisibility.\n    Returns:\n        int: Count of divisible integers in the interval.\n    Examples:\n        >>> count_integers_in_interval(1, 10, 3)\n        3\n    \"\"\"\n    count = 0\n    for i in range(start, end + 1):\n        if i % divisor == 0:\n            count += 1\n    return count", "def long_division(numerator, denominator, precision=10):\n    \"\"\"\n    Perform long division on two numbers and return the decimal expansion to a specified precision.\n    \n    Parameters:\n    - numerator (int): The numerator of the fraction.\n    - denominator (int): The denominator of the fraction.\n    - precision (int, optional): Number of decimal places. Default is 10.\n    \n    Returns:\n    - str: A string representation of the decimal expansion.\n    \n    Examples:\n    - long_division(1, 3) returns '0.3333333333'\n    - long_division(2, 5) returns '0.4'\n    \"\"\"\n    result = numerator / denominator\n    return f\"{result:.{precision}f}\"", "def division_with_rounding(total_quantity, divider):\n    \"\"\"\n    Divide `total_quantity` by `divider` and round the result to the nearest whole number.\n    Parameters:\n    total_quantity (float): The total quantity to divide.\n    divider (float): The number by which to divide the total quantity.\n    Returns:\n    int: Result of the division rounded to the nearest whole number.\n    Examples:\n    >>> division_with_rounding(100.5, 3)\n    34\n    >>> division_with_rounding(7, 3)\n    2\n    \"\"\"\n    return round(total_quantity / divider)", "def divide_fractions(fraction1, fraction2):\n    \"\"\"\n    Divides two fractions.\n    \n    Parameters:\n    fraction1 (Fraction): The dividend fraction.\n    fraction2 (Fraction): The divisor fraction.\n    \n    Returns:\n    Fraction: The result of the division.\n    \n    Example:\n    >>> divide_fractions(Fraction(1, 2), Fraction(3, 4))\n    Fraction(2, 3)\n    \"\"\"\n    return fraction1 / fraction2", "def modular_expression(value, modulo):\n    \"\"\"\n    Compute the result of an integer modulo operation.\n    Parameters:\n    - value (int): The integer to be taken modulo.\n    - modulo (int): The modulus.\n    Returns:\n    int: The result of the modulo operation.\n    \n    Examples:\n    >>> modular_expression(10, 3)\n    1\n    >>> modular_expression(25, 4)\n    1\n    \"\"\"\n    return value % modulo", "def calculate_fit_and_remainder(total, unit_size, return_remainder=False):\n    \"\"\"\n    Calculate how many full units fit into the total amount and optionally get the remainder.\n    \n    Parameters\n    ----------\n    total : int\n        The total amount to be divided.\n    unit_size : int\n        The size of each unit.\n    return_remainder : bool, optional\n        If True, return both the number of full units that fit and the remainder. Default is False.\n    \n    Returns\n    -------\n    tuple or int\n        Number of full units that fit, and optionally the remainder.\n    \n    Examples\n    --------\n    >>> calculate_fit_and_remainder(100, 3)\n    33\n    >>> calculate_fit_and_remainder(100, 3, return_remainder=True)\n    (33, 1)  # 33 full units, and 1 left over\n    \"\"\"\n    if unit_size == 0:\n        raise ValueError(\"unit_size cannot be zero.\")\n    count = total // unit_size\n    remainder = total % unit_size\n    if return_remainder:\n        return count, remainder\n    return count", "def repetitive_division(total_quantity, unit_size):\n    \"\"\"\n    Calculate how many times `unit_size` fits into `total_quantity` repeatedly.\n    Parameters:\n    total_quantity (int): The total quantity that needs to be divided.\n    unit_size (int): The size of one unit.\n    Returns:\n    int: The number of times the unit size fits into the total quantity.\n    Examples:\n    >>> repetitive_division(100, 10)\n    10\n    >>> repetitive_division(45, 2)\n    22\n    \"\"\"\n    count = 0\n    while total_quantity >= unit_size:\n        total_quantity -= unit_size\n        count += 1\n    return count", "def is_divisible_by(number, divisor):\n    \"\"\"\n    Check if a number is divisible by another number.\n    Parameters:\n    number (int): The number to check.\n    divisor (int): The divisor.\n    Returns:\n    bool: True if number is divisible by divisor, else False.\n    Example:\n    >>> is_divisible_by(15, 3)\n    True\n    \"\"\"\n    return number % divisor == 0"], "Percentages": ["def percentage_change(old, new):\n    \"\"\"\n    Calculate the percentage increase or decrease from an old value to a new value.\n    Parameters:\n    old (float): The initial value.\n    new (float): The updated value.\n    Returns:\n    float: The percentage change from the old to the new value.\n    Examples:\n    >>> percentage_change(100, 150)\n    50.0\n    \"\"\"\n    return ((new - old) / old) * 100", "def percent_to_fraction(percent):\n    \"\"\"\n    Convert a percentage to a fraction.\n    Parameters:\n    percent (float): The percentage to convert.\n    Returns:\n    float: The fraction equivalent of the given percentage.\n    \n    Examples:\n    >>> percent_to_fraction(75)\n    0.75\n    \"\"\"\n    return percent / 100.0", "def percentage_of(part, whole):\n    \"\"\"\n    Calculate what percentage the part is of the whole.\n    Parameters:\n    part (float): The part or subset of the total.\n    whole (float): The total or whole from which the part is taken.\n    Returns:\n    float: The percentage value of the part in relation to the whole.\n    Examples:\n    >>> percentage_of(50, 200)\n    25.0\n    \"\"\"\n    return (part / whole) * 100", "def calculate_percentage(amount, percentage):\n    \"\"\"\n    Calculate the percentage of a given amount.\n    Parameters:\n    amount (float): The total amount from which the percentage will be calculated.\n    percentage (float): The percentage to calculate from the amount.\n    Returns:\n    float: The amount that represents the given percentage of the input amount.\n    Example:\n    >>> calculate_percentage(200, 15)\n    30.0\n    \"\"\"\n    return (amount * percentage) / 100", "def calculate_percentage(part, whole, to_decimal=False, round_result=None):\n    \"\"\"\n    Calculate percentage from a part value and a whole value. Optionally convert to decimal form and round result.\n    Parameters:\n        part (float): The part value of the whole.\n        whole (float): The entire or total value.\n        to_decimal (bool, optional): If True, return result in decimal form. Defaults to False.\n        round_result (int, optional): If specified, rounds the result to the given number of decimal places.\n    Returns:\n        float: The percentage (or decimal if requested) value.\n    Examples:\n        >>> calculate_percentage(50, 200)\n        25.0\n        >>> calculate_percentage(50, 200, to_decimal=True)\n        0.25\n        >>> calculate_percentage(50, 200, round_result=1)\n        25.0\n    \"\"\"\n    import math\n    percentage = (part / whole) * 100\n    if to_decimal:\n        percentage /= 100\n    if round_result is not None:\n        percentage = round(percentage, round_result)\n    return percentage", "def convert_between_percents_decimals_fractions(value, input_type, output_type):\n    \"\"\"\n    Converts values between percentages, decimals, and fractions.\n    Parameters:\n    - value (float or Fraction): the value to be converted.\n    - input_type (str): the type of the input value ('percent', 'decimal', 'fraction').\n    - output_type (str): the desired output type ('percent', 'decimal', 'fraction').\n    Returns:\n    - float or Fraction: Converted value in the desired format.\n    Examples:\n    >>> convert_between_percents_decimals_fractions(50, 'percent', 'decimal')\n    0.5\n    >>> convert_between_percents_decimals_fractions(0.75, 'decimal', 'percent')\n    75.0\n    >>> from fractions import Fraction\n    >>> print(convert_between_percents_decimals_fractions(Fraction(1, 4), 'fraction', 'percent'))\n    25.0\n    \"\"\"\n    from fractions import Fraction\n    \n    if input_type == 'percent':\n        value = value / 100\n    elif input_type == 'fraction':\n        value = float(value)\n    \n    if output_type == 'percent':\n        return value * 100\n    elif output_type == 'decimal':\n        return float(value)\n    elif output_id_type == 'fraction':\n        return Fraction(value).limit_denominator()", "def round_percentage(value, decimals=0):\n    \"\"\"\n    Rounds a percentage to a specified number of decimal places.\n    Parameters:\n    - value (float): The percentage value to round.\n    - decimals (int, optional): Number of decimal places to round to. Default is 0.\n    Returns:\n    float: The rounded percentage.\n    Example:\n    >>> round_percentage(33.3333, 1)\n    33.3\n    \"\"\"\n    return round(value, decimals)", "def dollars_to_cents(dollars):\n    \"\"\"\n    Convert dollar amount to cents.\n    Parameters:\n    dollars (float): Amount in dollars.\n    Returns:\n    int: Amount in cents.\n    \n    Examples:\n    >>> dollars_to_cents(12.75)\n    1275\n    \"\"\"\n    return int(dollars * 100)", "def fraction_to_percentage(numerator, denominator):\n    \"\"\"\n    Convert a fraction to a percentage.\n    Parameters:\n    numerator (float): The numerator of the fraction.\n    denominator (float): The denominator of the fraction.\n    Returns:\n    float: The percentage representation of the fraction.\n    Examples:\n    >>> fraction_to_percentage(1, 4)\n    25.0\n    \"\"\"\n    return (numerator / denominator) * 100"], "Multiplication": ["def unit_conversion(value: float, conversion_factor: float) -> float:\n    \"\"\"\n    Convert a unit from one scale to another using multiplication.\n    Parameters:\n    - value : float\n        The initial value in the base unit.\n    - conversion_factor : float\n        The factor by which to multiply the base value to achieve conversion.\n    Returns:\n    - converted_value : float\n        The value in the new unit.\n    Examples:\n    - unit_conversion(100, 0.3048) -> 30.48  # Convert 100 feet to meters\n    \"\"\"\n    return value * conversion_factor", "def multiply_numbers(*args):\n    \"\"\"\n    Multiplies a series of numbers together.\n    Parameters:\n    *args : float or int\n        An unpacked tuple of numbers.\n    Returns:\n    float\n        The product of all the input numbers.\n    Example:\n    >>> multiply_numbers(4, 5)\n    20\n    >>> multiply_numbers(1.5, 2, 3)\n    9.0\n    \"\"\"\n    from functools import reduce\n    import operator\n    return reduce(operator.mul, args, 1)", "def scale_recipe_ingredients(ingredients: List[float], scaling_factor: float) -> List[float]:\n    \"\"\"\n    Scale the quantities of ingredients in a recipe by a given factor.\n    Parameters:\n    - ingredients : List[float]\n        List of ingredient quantities.\n    - scaling_factor : float\n        Factor by which to scale the ingredients.\n    Returns:\n    - List[float]\n        New quantities of ingredients.\n    Examples:\n    - scale_recipe_ingredients([100, 200, 300], 0.5) -> [50.0, 100.0, 150.0]\n    \"\"\"\n    return [qty * scaling_factor for qty in ingredients]", "def binary_multiplication(a: str, b: str) -> str:\n    \"\"\"\n    Perform multiplication of two binary numbers.\n    Parameters:\n    - a : str\n        First binary number as a string.\n    - b : str\n        Second binary number as a string.\n    Returns:\n    - str\n        Binary representation of the product.\n    Examples:\n    - binary_multiplication('101', '110') -> '11110'\n    \"\"\"\n    return bin(int(a, 2) * int(b, 2))[2:]", "def multiply_fractions(*args: Fraction) -> Fraction:\n    \"\"\"\n    Multiply arbitrary numbers of fractions together.\n    Parameters:\n    - args : Fraction\n        Fractions to be multiplied.\n    Returns:\n    - result : Fraction\n        Product of the fractions, simplified automatically.\n    Examples:\n    - multiply_fractions(Fraction(1, 2), Fraction(3, 4)) -> Fraction(3, 8)\n    \"\"\"\n    result = Fraction(1, 1)\n    for frac in args:\n        result *= frac\n    return result", "def calculate_with_units(value, multiplier, unit=''):\n    \"\"\"\n    Multiply a numerical value by a multiplier, optionally attaching a unit of measure to the result.\n    Parameters:\n    value : float or int\n        The initial value.\n    multiplier : float or int\n        The multiplier factor.\n    unit : str, optional\n        Unit of measure to attach to the result.\n    Returns:\n    str or float\n        The result of the multiplication, with unit if provided.\n    \n    Examples:\n    >>> calculate_with_units(100, 2, 'meters')\n    '200 meters'\n    >>> calculate_with_units(50, 3)\n    150\n    \"\"\"\n    result = value * multiplier\n    return f\"{result} {unit}\".strip() if unit else result", "def multiply_numbers(a, b):\n    \"\"\"\n    Multiplies two numbers, which can be integers, floats, or fractions.\n    \n    Parameters:\n        a (int, float, Fraction): First number to multiply.\n        b (int, float, Fraction): Second number to multiply.\n    \n    Returns:\n        int, float, Fraction: The product of a and b.\n        \n    Example:\n        >>> multiply_numbers(5, 3)\n        15\n        >>> multiply_numbers(2.5, 4)\n        10.0\n        >>> multiply_numbers(Fraction(1, 2), Fraction(3, 4))\n        Fraction(3, 8)\n    \"\"\"\n    return a * b", "def scale_and_convert(value, scale_factor, conversion_factor=1):\n    \"\"\"\n    Scales a value by a scale factor and then converts it using a conversion factor.\n    Parameters:\n    value : float or int\n        The initial numerical value.\n    scale_factor : float or int\n        The factor by which to scale the value.\n    conversion_factor : float or int, optional\n        The factor by which the scaled value is to be converted.\n    Returns:\n    float\n        The scaled and converted value.\n    \n    Examples:\n    >>> scale_and_convert(10, 2, 0.5)\n    10.0\n    >>> scale_and_convert(15, 3)\n    45\n    \"\"\"\n    scaled_value = value * scale_factor\n    return scaled_value * conversion_factor", "def multiply_list_elements(numbers):\n    \"\"\"\n    Multiplies all elements in a given list or array of numbers.\n    \n    Parameters:\n        numbers (list, numpy.array): List or array of numbers.\n    \n    Returns:\n        int, float: Product of all numbers in the list or array.\n        \n    Example:\n        >>> multiply_list_elements([1, 2, 3, 4])\n        24\n        >>> multiply_list_elements(np.array([1.5, 2, 3]))\n        9.0\n    \"\"\"\n    product = 1\n    for number in numbers:\n        product *= number\n    return product"], "Summation": ["def sum_of_polynomial_sequence(coefficients, start, end):\n    \"\"\"\n    Calculate the sum of a polynomial sequence from start to end value.\n    Parameters:\n    coefficients (list): Coefficients of the polynomial from highest to lowest degree.\n    start (int): The starting value of the sequence.\n    end (int): The ending value of the sequence.\n    \n    Returns:\n    float: The sum of the polynomial sequence.\n    Example:\n    >>> sum_of_polynomial_sequence([1, 0, -1], 1, 5) # 1*x^2 + 0*x - 1 from x=1 to x=5\n    35\n    \"\"\"\n    from sympy import symbols, Sum\n    # Define the polynomial\n    x = symbols('x')\n    polynomial = sum(coeff * x**i for i, coeff in enumerate(reversed(coefficients)))\n    # Calculate the sum from start to end\n    return float(Sum(polynomial, (x, start, end)).doit())", "def sum_of_list(numbers):\n    \"\"\"\n    Calculate the sum of a list of numbers.\n    Parameters:\n    numbers (list): A list of numbers (integers or floats).\n    Returns:\n    float: The sum of the numbers in the list.\n    Example:\n    >>> sum_of_list([1, 2, 3, 4, 5])\n    15\n    >>> sum_of_list([1.5, 2.3, 3.1])\n    6.9\n    \"\"\"\n    return sum(numbers)", "def sum_list(values):\n    \"\"\"\n    Sums a list of numeric values.\n    \n    Parameters:\n    values (list): A list of numbers (integers or floats).\n    \n    Returns:\n    number: The sum of all elements in the list.\n    \n    Examples:\n    >>> sum_list([1, 2, 3, 4])\n    10\n    >>> sum_list([1.5, 2.5, 3])\n    7.0\n    \"\"\"\n    return sum(values)", "def sum_of_arithmetic_series(a, d, n, modifier=lambda x: x):\n    \"\"\"\n    Calculate the sum of the first `n` terms of an arithmetic sequence with a modifier function.\n    Parameters:\n    a (int): The first term of the sequence.\n    d (int): The common difference of the sequence.\n    n (int): The number of terms to be added.\n    modifier (function, optional): A function that modifies each term, e.g., applying floor or certain conditions.\n                                   By default, it's identity function (no modification).\n    \n    Returns:\n    int or float: The sum of the first `n` terms of the modified arithmetic sequence.\n    Example:\n    >>> sum_of_arithmetic_series(1, 1, 5)  # 1, 2, 3, 4, 5\n    15\n    >>> import math\n    >>> sum_of_arithmetic_series(1, 1, 5, math.floor)  # 1, 2, 3, 4, 5 with floor (though no change here)\n    15\n    \"\"\"\n    return sum(modifier(a + i * d) for i in range(n))", "def sum_polynomial_sequence(expression, start, end):\n    \"\"\"\n    Calculates the sum of the sequence generated by the polynomial expression from `start` to `end`.\n    \n    Parameters:\n    expression (str): A string representing the polynomial function of 'n'.\n    start (int): The starting value of the sequence.\n    end (int): The ending value of the sequence.\n    \n    Returns:\n    number: The sum of the sequence from start to end.\n    \n    Examples:\n    >>> sum_polynomial_sequence('n**2 + n + 1', 1, 5)\n    55\n    >>> sum_polynomial_sequence('n**3', 1, 4)\n    100\n    \"\"\"\n    n = symbols('n')\n    expr = eval(expression)\n    return summation(expr, (n, start, end))", "def advanced_series_sum(start, end, function, step=1):\n    \"\"\"\n    Compute the sum of function values applied to an integer series with a specific step adjustment,\n    potentially using rounding or floor functions.\n    Parameters:\n        start (int): The starting integer of the series.\n        end (int): The ending integer of the series (inclusive).\n        function (callable): A function that takes a single integer input and returns a number.\n        step (int): The step between successive integers in the series (default is 1).\n    Returns:\n        float or int: The total sum of the function applied to each integer in the series.\n    Examples\n        >>> advanced_series_sum(1, 10, lambda x: x*x)\n        385\n        >>> advanced_series_sum(1, 100, lambda x: floor(x/10), step=10)\n        450\n    \"\"\"\n    return sum(function(i) for i in range(start, end + 1, step))", "def conditional_sum(values, condition_func=lambda x: True):\n    \"\"\"\n    Calculates the sum of values that meet a specific condition.\n    \n    Parameters:\n    values (list): A list of numbers.\n    condition_func (callable): A function that takes an item from `values` and returns True if it should be summed.\n    \n    Returns:\n    number: The conditional sum.\n    \n    Examples:\n    >>> conditional_sum([1, 2, 3, 4, 5], lambda x: x % 2 == 0)\n    6\n    >>> conditional_sum([10, 15, 20, 25], lambda x: x > 15)\n    45\n    \"\"\"\n    return sum(xs for xs in values if condition_func(xs))"], "Time Calculations": ["def clock_angle_calculator(hour, minute):\n    \"\"\"\n    Calculates the angles of the hour and minute hands relative to 12:00 (top of the clock)\n    and the angle between these two hands at a specific time specified by the `hour` and `minute`.\n    \n    Parameters:\n    hour (int): The hour part of the time (0-23).\n    minute (int): The minute part of the time (0-59).\n    Returns:\n    tuple: \n        - angle_minute_hand (float): Angle of the minute hand from the top of the clock.\n        - angle_hour_hand (float): Angle of the hour hand from the top of the clock.\n        - difference_angle (float): Absolute difference in angles between the hour and minute hands.\n    Examples:\n    >>> clock_angle_calculator(3, 0)\n    (0.0, 90.0, 90.0)\n    \n    >>> clock_angle_calculator(9, 30)\n    (180.0, 285.0, 105.0)\n    \"\"\"\n    from math import fabs\n    # Minute hand moves 360 degrees in 60 minutes => 6 degrees per minute.\n    angle_minute_hand = 6 * minute\n    \n    # Hour hand moves 360 degrees in 12 hours => 30 degrees per hour.\n    # Plus it also moves as a function of the minutes past the hour (0.5 degrees per minute).\n    hour = hour % 12  # convert to 12-hour format in case of 24-hour format input\n    angle_hour_hand = 30 * hour + 0.5 * minute\n    \n    # Calculate the minimal difference between the two angles\n    difference_angle = fabs(angle_minute_hand - angle_hour_hand)\n    if difference_angle > 180:\n        difference_angle = 360 - difference_angle\n    return angle_minute_hand, angle_hour_hand, difference_angle", "def mixed_to_improper(mixed_number):\n    \"\"\"\n    Convert a mixed number to an improper fraction.\n    \n    Parameters:\n    - mixed_number (tuple): A tuple (whole_number, numerator, denominator) representing the mixed number.\n    \n    Returns:\n    - Fraction: An improper fraction representing the mixed number.\n    \n    Examples:\n    - mixed_to_improper((3, 1, 2)) -> Fraction(7, 2)\n    \"\"\"\n    whole, numerator, denominator = mixed_number\n    return Fraction(whole*denominator + numerator, denominator)", "def add_time(hours=0, minutes=0, seconds=0, starting_time=None, format_12_hour=True):\n    \"\"\"\n    Adds time to a given starting time or the current system time, managing overflow in hours, minutes, and seconds appropriately.\n    \n    Parameters:\n        hours (int): number of hours to add. Default is 0.\n        minutes (int): number of minutes to add. Default is 0.\n        seconds (int): number of seconds to add. Default is 0.\n        starting_time (datetime.time or None): starting time. If None, current system time is used. Default is None.\n        format_12_hour (bool): whether to return the time in 12-hour format. Default is True.\n    Returns:\n        str: The calculated time in the specified hour format (12-hour or 24-hour).\n    Examples:\n        >>> print(add_time(2, 30, format_12_hour=True))\n        '2:30 PM'  # Output may vary depending on the current time.\n        >>> print(add_time(14, 45, starting_time=datetime.time(11, 30), format_12_hour=False))\n        '02:15:00'\n    \"\"\"\n    if starting_time is None:\n        now = datetime.datetime.now()\n    else:\n        now = datetime.datetime.combine(datetime.date.today(), starting_time)\n        \n    added_time = datetime.timedelta(hours=hours, minutes=minutes, seconds=seconds)\n    new_time = now + added_time\n    if format_12_hour:\n        return new_time.strftime(\"%I:%M %p\")\n    else:\n        return new_time.strftime(\"%H:%M:%S\")", "def fraction_to_decimal(frac):\n    \"\"\"\n    Convert a fraction to a decimal.\n    \n    Parameters:\n    frac (Fraction): The fraction to convert.\n    \n    Returns:\n    float: The decimal representation of the fraction.\n    \n    Example:\n    >>> fraction_to_decimal(Fraction(1, 4))\n    0.25\n    \"\"\"\n    return float(frac)", "def calculate_future_day(start_day, days_ahead):\n    \"\"\"\n    Calculates the day of the week that is a certain number of days from a given starting day.\n    Parameters:\n    - start_day (str): The starting day of the week ('Monday', 'Tuesday', etc.).\n    - days_ahead (int): The number of days ahead to calculate.\n    Returns:\n    - str: The name of the day of the week\n    Examples:\n    >>> calculate_future_day('Wednesday', 2)\n    'Friday'\n    >>> calculate_future_day('Friday', 10)\n    'Monday'\n    \"\"\"\n    days_of_week = [\"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\", \"Sunday\"]\n    start_index = days_of_week.index(start_day)\n    future_index = (start_index + days_ahead) % 7\n    return days_of_week[future_index]", "def minutes_to_hours_minutes(minutes):\n    \"\"\" Convert minutes to a combination of hours and remaining minutes.\n    Parameters:\n    - minutes (int): Total number of minutes to convert.\n    Returns:\n    - tuple: a tuple containing hours and minutes.\n    Examples:\n    >>> minutes_to_hours_minutes(150)\n    (2, 30)\n    \"\"\"\n    hours = minutes // 60\n    minutes_remainder = minutes % 60\n    return hours, minutes_remainder", "def combine_time_segments(hours=0, minutes=0, seconds=0):\n    \"\"\" Combine separate time segments into a total timedelta object.\n    \n    Parameters:\n    - hours (int): Number of hours.\n    - minutes (int): Number of minutes.\n    - seconds (int): Number of seconds.\n    Returns:\n    - timedelta: Total time represented as a timedelta object.\n    Examples:\n    >>> combine_time_segments(2, 30, 40)\n    datetime.timedelta(seconds=9040)\n    \"\"\"\n    return timedelta(hours=hours, minutes=minutes, seconds=seconds)", "def convert_days_to_hours(days):\n    \"\"\"\n    Converts a number of days to hours.\n    Parameters:\n        days (float): Number of days.\n    Returns:\n        float: Total number of hours in given days.\n    \n    Example:\n        >>> convert_days_to_hours(1.5)\n        36.0\n    \"\"\"\n    return days * 24.0", "def convert_seconds_to_time(seconds):\n    \"\"\"\n    Converts a number of seconds into a combination of hours, minutes, and seconds.\n    Parameters:\n        seconds (int): Total number of seconds.\n    Returns:\n        tuple: A tuple containing hours, minutes, and seconds (hours, minutes, seconds).\n    \n    Example:\n        >>> convert_seconds_to_time(3661)\n        (1, 1, 1)\n    \"\"\"\n    return (seconds // 3600, (seconds % 3600) // 60, seconds % 60)", "def calculate_kinematic_value(known1: float, known2: float, to_find: str = 'time') -> float:\n    \"\"\"\n    Calculate the missing kinematic value (distance, speed, or time) using the formula distance = speed × time.\n    Parameters:\n    known1 (float): The first known value (either distance, speed, or time).\n    known2 (float): The second known value (either distance, speed, or time).\n    to_find (str): The type of value to find ('distance', 'speed', 'time').\n    Returns:\n    float: The calculated missing value.\n    Examples:\n    >>> calculate_kinematic_value(50, 10, 'time')\n    5.0\n    >>> calculate_kinematic_value(50, 5, 'speed')\n    10.0\n    >>> calculate_kinematic_value(10, 5, 'distance')\n    50.0\n    \"\"\"\n    if to_find == 'time':\n        return known1 / known2  # Assuming known1 is distance and known2 is speed\n    elif to_find == 'speed':\n        return known1 / known2  # Assuming known1 is distance and known2 is time\n    elif to_find == 'distance':\n        return known1 * known2  # Assuming known1 is speed and known2 is time\n    else:\n        raise ValueError(\"Invalid parameter for 'to_find'. Choose 'distance', 'speed', or 'time'.\")", "def calculate_cycle_position(start_pos, steps, cycle_length):\n    \"\"\"\n    Calculate new position within a cycle after moving a certain number of steps.\n    \n    Parameters:\n        start_pos (int): Starting position in the cycle.\n        steps (int): Number of steps to move forward in the cycle.\n        cycle_length (int): Total length of the cycle.\n        \n    Returns:\n        int: New position within the cycle after moving the steps.\n        \n    Example:\n        >>> calculate_cycle_position(1, 3, 12)\n        4\n        >>> calculate_cycle_position(10, 15, 12)\n        1\n    \"\"\"\n    # Calculate new position with modulus to handle cycle wrap-around\n    return (start_pos + steps - 1) % cycle_length + 1", "def calculate_time(distance, speed):\n    \"\"\"\n    Compute time taken to travel a given distance at a specified speed.\n    \n    Parameters:\n    distance (float): The distance traveled.\n    speed (float): The speed of travel.\n    \n    Returns:\n    float: The time taken to travel the given distance at the specified speed.\n    \n    Example:\n    >>> calculate_time(100, 50)\n    2.0\n    \"\"\"\n    if speed == 0:\n        raise ValueError(\"Speed cannot be zero.\")\n    return distance / speed", "def add_minutes_to_time(start_time, minutes):\n    \"\"\" Add minutes to a specified datetime.\n    Parameters:\n    - start_time (datetime): The initial time.\n    - minutes (int): Number of minutes to add.\n    Returns:\n    - datetime: Updated datetime after adding minutes.\n    Examples:\n    >>> from datetime import datetime\n    >>> add_minutes_to_time(datetime(2023, 1, 1, 1, 0), 61)\n    datetime.datetime(2023, 1, 1, 2, 1)\n    \"\"\"\n    return start_time + timedelta(minutes=minutes)", "def convert_time_units(seconds=None, minutes=None, hours=None, days=None):\n    \"\"\"\n    Convert various time units between seconds, minutes, hours, and days.\n    Parameters:\n    - seconds (int, optional): The number of seconds to convert. Default is None.\n    - minutes (int, optional): The number of minutes to convert. Default is None.\n    - hours (int, optional): The number of hours to convert. Default is None.\n    - days (int, optional): The number of days to convert. Default is None.\n    Returns:\n    - dict: A dictionary containing all converted values in terms of seconds, minutes, hours, and days.\n    Examples:\n    >>> convert_time_units(days=1)\n    {'seconds': 86400, 'minutes': 1440, 'hours': 24, 'days': 1}\n    >>> convert_time_units(hours=1)\n    {'seconds': 3600, 'minutes': 60, 'hours': 1, 'days': 0.041666666666666664}\n    \"\"\"\n    tot_seconds = (seconds if seconds is not None else 0) \\\n                  + (minutes * 60 if minutes is not None else 0) \\\n                  + (hours * 3600 if hours is not None else 0) \\\n                  + (days * 86400 if days is not None else 0)\n    return {\n        'seconds': tot_seconds,\n        'minutes': tot_seconds / 60,\n        'hours': tot_seconds / 3600,\n        'days': tot_seconds / 86400\n    }", "def fraction_operations(fraction1, fraction2, operation='multiply'):\n    \"\"\"\n    Perform operations (multiply or divide) between two fractions.\n    \n    Parameters:\n    - fraction1 (Fraction): The first fraction operand.\n    - fraction2 (Fraction): The second fraction operand.\n    - operation (str): The operation to perform: 'multiply' or 'divide'.\n    \n    Returns:\n    - Fraction: Result of the specified operation between the two fractions.\n    \n    Examples:\n    - fraction_operations(Fraction(1, 2), Fraction(3, 4), 'multiply') -> Fraction(3, 8)\n    - fraction_operations(Fraction(1, 2), Fraction(3, 4), 'divide') -> Fraction(2, 3)\n    \"\"\"\n    if operation == 'multiply':\n        return fraction1 * fraction2\n    elif operation == 'divide':\n        return fraction1 / fraction2\n    else:\n        raise ValueError(\"Invalid operation specified. Use 'multiply' or 'divide'.\")", "def seconds_to_time(seconds, start_time=None):\n    \"\"\" Convert total seconds to hours, minutes, and seconds and optionally add to a starting time.\n    Parameters:\n    - seconds (int): Total number of seconds to convert.\n    - start_time (datetime, optional): Starting time to add seconds to.\n    \n    Returns:\n    - datetime: Datetime object representing the combined time.\n    \n    Examples:\n    >>> from datetime import datetime\n    >>> seconds_to_time(3661, datetime(2023, 1, 1, 12, 0))\n    datetime.datetime(2023, 1, 1, 13, 1, 1)\n    >>> seconds_to_time(3661)\n    datetime.datetime(1900, 1, 1, 1, 1, 1)\n    \"\"\"\n    time_delta = timedelta(seconds=seconds)\n    if start_time is None:\n        start_time = datetime(1900, 1, 1)\n    return start_time + time_delta", "def calculate_missing_value(**kwargs):\n    \"\"\"\n    Calculate the missing value (distance, speed, or time) based on the other two provided values.\n    \n    Parameters:\n    - kwargs (dict): Keyword arguments specifying two out of three values among 'distance', 'speed', and 'time'.\n    \n    Returns:\n    - float: The calculated missing value based on the speed-distance-time relationship.\n    \n    Examples:\n    - calculate_missing_value(speed=60, time=2) -> 120 (calculates distance)\n    - calculate_missing_value(distance=150, time=3) -> 50 (calculates speed)\n    - calculate_missing_value(speed=50, distance=200) -> 4 (calculates time)\n    \n    Raises:\n    - ValueError: If insufficient or incorrect parameters are passed.\n    \"\"\"\n    keys = kwargs.keys()\n    if 'speed' in keys and 'time' in keys:\n        return kwargs['speed'] * kwargs['time']\n    elif 'distance' in keys and 'time' in keys:\n        return kwargs['distance'] / kwargs['time']\n    elif 'speed' in keys and 'distance' in keys:\n        return kwargs['distance'] / kwargs['speed']\n    else:\n        raise ValueError(\"Insufficient parameters provided. You must specify any two out of 'speed', 'distance', 'time'.\")"]}