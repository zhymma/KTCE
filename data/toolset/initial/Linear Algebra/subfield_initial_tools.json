{"Matrices": ["def matrix_inverse(matrix):\n    \"\"\"\n    Calculate the inverse of a given matrix.\n    Parameter:\n    - matrix: ndarray\n        The matrix to be inverted.\n    Returns:\n    - inverse: ndarray\n        The inverse of the given matrix.\n    \"\"\"\n    try:\n        inverse = np.linalg.inv(matrix)\n    except np.linalg.LinAlgError as err:\n        if 'Singular matrix' in str(err):\n            print(\"The input matrix is not invertible.\")\n            inverse = None\n        else:\n            raise\n    return inverse", "def calculate_determinant(matrix):\n    \"\"\"\n    Calculate the determinant of a matrix.\n    Parameters:\n    matrix (np.ndarray): A two-dimensional numpy array representing the matrix.\n    Returns:\n    float: The determinant of the matrix.\n    Examples:\n    >>> calculate_determinant(np.array([[2, 3], [1, 4]]))\n    5\n    \"\"\"\n    return np.linalg.det(matrix)", "def vector_add(v1, v2):\n    \"\"\"\n    Add two vectors.\n    Parameters:\n        v1 (np.ndarray): The first vector.\n        v2 (np.ndarray): The second vector.\n    Returns:\n        np.ndarray: The sum of v1 and v2.\n    Example:\n        >>> v1 = np.array([1, 2, 3])\n        >>> v2 = np.array([4, 5, 6])\n        >>> vector_add(v1, v2)\n        array([5, 7, 9])\n    \"\"\"\n    return np.add(v1, v2)", "def matrix_operations(A, B, operation='multiply'):\n    \"\"\"\n    Perform basic operations on two matrices: multiplication, addition, subtraction.\n    Parameters:\n    A (ndarray): A 2D NumPy array, the first matrix.\n    B (ndarray): A 2D NumPy array, the second matrix, should be the same size as A for addition and subtraction.\n    operation (str): Type of operation: 'multiply', 'add', or 'subtract'.\n    Returns:\n    ndarray: Result of the specified operation executed on the matrices.\n    Examples:\n    >>> import numpy as np\n    >>> A = np.array([[1, 2], [3, 4]])\n    >>> B = np.array([[2, 0], [1, 2]])\n    >>> matrix_operations(A, B, 'multiply')\n    array([[ 4,  4],\n           [10,  8]])\n    >>> matrix_operations(A, B, 'add')\n    array([[3, 2],\n           [4, 6]])\n    >>> matrix_operations(A, B, 'subtract')\n    array([[-1,  2],\n           [ 2,  2]])\n    \"\"\"\n    if operation == 'multiply':\n        return np.dot(A, B)\n    elif operation == 'add':\n        return np.add(A, B)\n    elif operation == 'subtract':\n        return np.subtract(A, B)\n    else:\n        raise ValueError(\"Unsupported operation. Use 'multiply', 'add', or 'subtract'.\")", "def matrix_multiply(A, B):\n    \"\"\"\n    Multiply two matrices.\n    Parameters:\n        A (np.ndarray): The first matrix.\n        B (np.ndarray): The second matrix.\n    Returns:\n        np.ndarray: The product of matrices A and B.\n    Example:\n        >>> A = np.array([[1, 2], [3, 4]])\n        >>> B = np.array([[2, 0], [1, 2]])\n        >>> matrix_multiply(A, B)\n        array([[ 4,  4],\n               [10,  8]])\n    \"\"\"\n    return np.dot(A, B)", "def matrix_multiply(matrix1, matrix2):\n    \"\"\"\n    Multiply two matrices.\n    Parameters:\n    matrix1 (np.ndarray): A two-dimensional numpy array.\n    matrix2 (np.ndarray): Another two-dimensional numpy array.\n    Returns:\n    np.ndarray: The product of matrix1 and matrix2.\n    Examples:\n    >>> matrix_multiply(np.array([[1, 2], [3, 4]]), np.array([[2, 0], [1, 2]]))\n    array([[ 4,  4],\n           [10,  8]])\n    \"\"\"\n    return np.dot(matrix1, matrix2)", "def project_vector(vector, onto):\n    \"\"\"\n    Project a vector onto another vector.\n    Parameters:\n    - vector: ndarray\n        The vector to be projected.\n    - onto: ndarray\n        The vector onto which `vector` will be projected.\n    Returns:\n    - projection: ndarray\n        The projection of `vector` onto `onto`.\n    \"\"\"\n    # Account for zero vectors\n    if np.count_nonzero(onto) == 0:\n        return np.zeros_like(vector)\n    # Compute the projection\n    scale_factor = np.dot(vector, onto) / np.dot(onto, onto)\n    projection = scale_factor * onto\n    return projection", "def get_eigenvectors(matrix):\n    \"\"\"\n    Calculate the eigenvalues and eigenvectors of a given matrix.\n    Parameters:\n    - matrix: ndarray\n        The matrix for which the eigenvectors are to be calculated.\n    Returns:\n    - eigenvalues: ndarray\n        Eigenvalues of the given matrix.\n    - eigenvectors: ndarray\n        Eigenvectors of the given matrix.\n    \"\"\"\n    eigenvalues, eigenvectors = np.linalg.eig(matrix)\n    return eigenvalues, eigenvectors", "class MatrixEigen:\n    \"\"\"\n    A class to compute eigenvalues and eigenvectors of a matrix.\n    Methods\n    -------\n    compute_eigenvalues(A):\n        Computes eigenvalues of matrix A.\n    compute_eigenvectors(A):\n        Computes eigenvectors of matrix A.\n    \"\"\"\n    @staticmethod\n    def compute_eigenvalues(A):\n        \"\"\"\n        Compute the eigenvalues of the matrix A.\n        Parameters:\n            A (numpy.ndarray): A square matrix.\n        Returns:\n            numpy.ndarray: Array of eigenvalues.\n        \"\"\"\n        return np.linalg.eigvals(A)\n    @staticmethod\n    def compute_eigenvectors(A):\n        \"\"\"\n        Compute the eigenvectors of the matrix A.\n        Parameters:\n            A (numpy.ndarray): A square matrix.\n        Returns:\n            tuple: Returns a tuple containing an array of eigenvalues and a matrix whose columns are the corresponding right eigenvectors.\n        \"\"\"\n        return np.linalg.eig(A)", "class MatrixManipulator:\n    \"\"\"\n    A utility class to perform various matrix operations such as multiplication, \n    matrix powers, inversion and checking properties like identity matrix condition.\n    Methods\n    -------\n    multiply_matrices(A, B):\n        Multiplies two matrices A and B.\n    matrix_power(A, n):\n        Computes the nth power of matrix A.\n    invert_matrix(A):\n        Computes the inverse of matrix A.\n    is_identity_matrix(A):\n        Checks if matrix A is an identity matrix.\n    \"\"\"\n    @staticmethod\n    def multiply_matrices(A, B):\n        \"\"\"\n        Multiplies two matrices A and B using the dot product.\n        Parameters:\n            A (numpy.ndarray): A matrix.\n            B (numpy.ndarray): A matrix.\n        Returns:\n            numpy.ndarray: Resultant matrix after multiplication.\n        \"\"\"\n        return np.dot(A, B)\n    @staticmethod\n    def matrix_power(A, n):\n        \"\"\"\n        Computes the nth power of matrix A using matrix multiplication.\n        Parameters:\n            A (numpy.ndarray): A square matrix.\n            n (int): The exponent to which the matrix is to be raised.\n        Returns:\n            numpy.ndarray: A to the power n.\n        \"\"\"\n        return np.linalg.matrix_power(A, n)\n    @staticmethod\n    def invert_matrix(A):\n        \"\"\"\n        Computes the inverse of matrix A if it exists.\n        Parameters:\n            A (numpy.ndarray): A square matrix.\n        Returns:\n            numpy.ndarray: Inverse of matrix A.\n        \"\"\"\n        return np.linalg.inv(A)\n    @staticmethod\n    def is_identity_matrix(A):\n        \"\"\"\n        Checks if the provided matrix A is an identity matrix.\n        Parameters:\n            A (numpy.ndarray): A square matrix.\n        Returns:\n            bool: True if A is an identity matrix, False otherwise.\n        \"\"\"\n        return np.allclose(A, np.eye(A.shape[0]))", "def geometric_transform(matrix, vector, transform_type):\n    \"\"\"\n    Performs the specified geometric transformation on a vector.\n    Parameters:\n    - matrix: ndarray\n        The transformation matrix to be applied.\n    - vector: ndarray\n        The vector to be transformed.\n    - transform_type: str\n        The type of transformation to be performed - 'rotation', 'reflection', 'dilation', 'projection'.\n    Returns:\n    - transformed_vector: ndarray\n        The vector after applying the transformation.\n    \"\"\"\n    if transform_type in ['rotation', 'reflection', 'dilation', 'projection']:\n        transformed_vector = np.dot(matrix, vector)\n    else:\n        print(f\"'{transform_type}' is not a supported transformation type.\")\n        transformed_vector = vector\n    return transformed_vector", "def matrix_inverse(A):\n    \"\"\"\n    Compute the inverse of matrix A.\n    Parameters:\n        A (np.ndarray): A square matrix.\n    Returns:\n        np.ndarray: The inverse of matrix A.\n    Example:\n        >>> A = np.array([[1, 2], [3, 4]])\n        >>> matrix_inverse(A)\n        array([[-2. ,  1. ],\n               [ 1.5, -0.5]])\n    \"\"\"\n    return np.linalg.inv(A)", "class MatrixProjection:\n    \"\"\"\n    A class to create and manipulate projection matrices.\n    Methods\n    -------\n    create_projection_matrix(u):\n        Creates the projection matrix onto vector u.\n    project_vector(v, P):\n        Projects vector v using projection matrix P.\n    \"\"\"\n    @staticmethod\n    def create_projection_matrix(u):\n        \"\"\"\n        Create the projection matrix for projecting other vectors onto vector u.\n        Parameters:\n            u (numpy.ndarray): A vector onto which other vectors will be projected.\n        Returns:\n            numpy.ndarray: Projection matrix.\n        \"\"\"\n        u_normalized = u / np.linalg.norm(u)\n        return np.outer(u_normalized, u_normalized)\n    @staticmethod\n    def project_vector(v, P):\n        \"\"\"\n        Projects vector v onto the subspace represented by projection matrix P.\n        Parameters:\n            v (numpy.ndarray): A vector to be projected.\n            P (numpy.ndarray): Projection matrix.\n        Returns:\n            numpy.ndarray: Projected vector.\n        \"\"\"\n        return np.dot(P, v)", "def matrix_identity(n):\n    \"\"\"\n    Generate an identity matrix of size n.\n    Parameters:\n        n (int): The size of the identity matrix.\n    Returns:\n        np.ndarray: An n x n identity matrix.\n    Example:\n        >>> matrix_identity(3)\n        array([[1, 0, 0],\n               [0, 1, 0],\n               [0, 0, 1]])\n    \"\"\"\n    return np.eye(n)", "class MatrixSystemSolver:\n    \"\"\"\n    A class to solve systems of linear equations represented in matrix form.\n    Methods\n    -------\n    solve_linear_system(A, b):\n        Solves the linear system Ax = b for x.\n    \"\"\"\n    @staticmethod\n    def solve_linear_system(A, b):\n        \"\"\"\n        Solve the linear system Ax = b using numpy's linear algebra solver.\n        Parameters:\n            A (numpy.ndarray): Coefficient matrix.\n            b (numpy.ndarray): Result vector.\n        Returns:\n            numpy.ndarray: Solution vector x.\n        \"\"\"\n        return np.linalg.solve(A, b)", "def scalar_multiply(scalar, matrix):\n    \"\"\"\n    Multiply a matrix by a scalar.\n    Parameters:\n    scalar (float): The scalar value.\n    matrix (np.ndarray): A two-dimensional numpy array.\n    Returns:\n    np.ndarray: The scalar-multiplied matrix.\n    Examples:\n    >>> scalar_multiply(3, np.array([[1, 2], [3, 4]]))\n    array([[ 3,  6],\n           [ 9, 12]])\n    \"\"\"\n    return scalar * matrix", "def is_matrix_invertible(matrix):\n    \"\"\"\n    Check if a matrix is invertible by examining its determinant.\n    Parameters:\n    matrix (np.ndarray): A two-dimensional numpy array representing the matrix.\n    Returns:\n    bool: True if the matrix is invertible, False otherwise.\n    Examples:\n    >>> is_matrix_invertible(np.array([[2, 3], [2, 3]]))\n    False\n    \"\"\"\n    return np.linalg.det(matrix) != 0", "def vector_projection(v1, v2):\n    \"\"\"\n    Project vector v1 onto vector v2.\n    Parameters:\n        v1 (np.ndarray): The vector being projected.\n        v2 (np.ndarray): The vector onto which v1 is projected.\n    Returns:\n        np.ndarray: The projection of v1 onto v2.\n    Example:\n        >>> v1 = np.array([3, -1])\n        >>> v2 = np.array([2, 2])\n        >>> vector_projection(v1, v2)\n        array([1., 1.])\n    \"\"\"\n    v2_norm = np.dot(v2, v2)\n    if v2_norm == 0:\n        return np.zeros_like(v2)\n    return np.dot(v1, v2) / v2_norm * v2"], "Vectors": ["def vector_dot(v1, v2):\n    \"\"\"\n    Calculate the dot product of two vectors.\n    \n    Parameters:\n        v1 (array): First input vector.\n        v2 (array): Second input vector.\n    Returns:\n        float: The dot product of the two vectors.\n    \"\"\"\n    return np.dot(v1, v2)", "def vector_magnitude(v):\n    \"\"\"\n    Compute the magnitude (norm) of a vector.\n    \n    Parameters:\n        v (array): Input vector.\n    Returns:\n        float: The magnitude of the vector.\n    \"\"\"\n    return np.linalg.norm(v)", "def scalar_multiply(scalar, v):\n    \"\"\"\n    Multiply a vector by a scalar.\n    Parameters:\n    scalar (numeric): Scalar value.\n    v (array_like): Input vector.\n    Returns:\n    ndarray: Resultant vector after multiplication.\n    \n    Example:\n    >>> scalar_multiply(3, [1, 2, 3])\n    array([3, 6, 9])\n    \"\"\"\n    return np.multiply(scalar, v)", "def vector_add(v1, v2):\n    \"\"\"\n    Add two vectors.\n    Parameters:\n    v1, v2 (array_like): Input vectors.\n    Returns:\n    ndarray: Sum of the two vectors.\n    \n    Example:\n    >>> vector_add([1, 2, 3], [4, 5, 6])\n    array([5, 7, 9])\n    \"\"\"\n    return np.add(v1, v2)", "def vector_subtract(v1, v2):\n    \"\"\"\n    Subtract the second vector from the first.\n    \n    Parameters:\n        v1 (array): A vector from which to subtract.\n        v2 (array): A vector to subtract.\n    Returns:\n        array: The difference of the two vectors.\n    \"\"\"\n    return np.subtract(v1, v2)", "def area_of_parallelogram(v1, v2):\n    \"\"\"\n    This function computes the area of a parallelogram formed by two vectors.\n    Parameters:\n    v1 (np.array): First vector\n    v2 (np.array): Second vector\n    Returns:\n    float: Area of the parallelogram\n    \"\"\"\n    return np.linalg.norm(np.cross(v1, v2))", "def vector_cross(v1, v2):\n    \"\"\"\n    Calculate the cross product of two vectors in 3D space.\n    \n    Parameters:\n        v1 (array): First input vector (3 elements).\n        v2 (array): Second input vector (3 elements).\n    Returns:\n        array: The cross product of the two vectors.\n    \"\"\"\n    return np.cross(v1, v2)", "def check_collinearity(vector_a, vector_b):\n    \"\"\"\n    Check if two vectors are collinear.\n    Parameters:\n    vector_a (array-like): First vector.\n    vector_b (array-like): Second vector.\n    \n    Returns:\n    bool: True if vectors are collinear, False otherwise.\n    Examples:\n    >>> check_collinearity(np.array([1, 2, 3]), np.array([2, 4, 6]))\n    True\n    \"\"\"\n    cross_product = np.cross(vector_a, vector_b)\n    return np.all(cross_product == 0)", "def vector_subtract(vector_a, vector_b):\n    \"\"\"\n    Subtract one vector from another.\n    Parameters:\n    vector_a (array-like): Vector from which to subtract.\n    vector_b (array-like): Vector to be subtracted.\n    Returns:\n    ndarray: The resulting vector after subtraction.\n    Examples:\n    >>> vector_subtract(np.array([5, 7, 9]), np.array([4, 5, 6]))\n    array([1, 2, 3])\n    \"\"\"\n    return np.subtract(vector_a, vector_b)", "def basic_vector_operations(v1, v2, operation):\n    \"\"\"\n    This function performs basic vector operations such as addition, subtraction and scalar multiplication\n    between two vectors.\n    Parameters:\n    v1 (np.array): First vector\n    v2 (float or np.array): Second vector or scalar\n    operation (str): Required operation. Values can be 'add', 'subtract', 'multiply'\n    Returns:\n    np.array: Result vector after performing the operation\n    \"\"\"\n    if operation == 'add':\n        return np.add(v1, v2)\n    elif operation == 'subtract':\n        return np.subtract(v1, v2)\n    elif operation == 'multiply':\n        return np.multiply(v1, v2)\n    else:\n        print('Invalid Operation!')", "def determinant_from_vectors(v1, v2):\n    \"\"\"\n    This function computes the determinant of a 2x2 matrix formed by two vectors.\n    Parameters:\n    v1 (np.array): First vector\n    v2 (np.array): Second vector\n    Returns:\n    float: Determinant of the matrix\n    \"\"\"\n    matrix = np.vstack((v1, v2))\n    return np.linalg.det(matrix)"], "Determinants": ["def compute_determinant(matrix):\n    \"\"\"\n    Computes the determinant of a given square matrix.\n    Parameters:\n    - matrix (list of list of floats or numpy array): The matrix for which to compute the determinant.\n    Returns:\n    - float: The determinant of the matrix.\n    Example:\n    >>> compute_determinant([[1, 2], [3, 4]])\n    -2.0\n    >>> compute_determinant([[1, 0, 0], [0, 5, 0], [0, 0, 9]])\n    45.0\n    \"\"\"\n    np_matrix = np.array(matrix)\n    return np.linalg.det(np_matrix)", "def matrix_power_determinant(A, power):\n    \"\"\"\n    Calculate the determinant of a matrix raised to a given power.\n    Parameters:\n    A (list of lists or numpy.ndarray): A square matrix (n x n).\n    power (int): The exponent to which the matrix A is to be raised.\n    \n    Returns:\n    float: The determinant of the matrix A raised to the given power.\n    \n    Examples:\n    >>> matrix_power_determinant([[1, 2], [3, 4]], 2)\n    4.000000000000007\n    >>> matrix_power_determinant([[1, 1], [1, 1]], 3)\n    0.0\n    \"\"\"\n    if not isinstance(A, np.ndarray):\n        A = np.array(A)\n    \n    # Calculate matrix A raised to the specified power\n    A_power = np.linalg.matrix_power(A, power)\n    \n    # Compute and return the determinant of the resulting matrix\n    return np.linalg.det(A_power)", "def determinant_2x2(matrix):\n    \"\"\"\n    Calculate the determinant of a 2x2 matrix.\n    Parameters:\n    matrix (list of lists): A 2x2 matrix represented as a list of two lists, each containing two elements.\n    Returns:\n    float: The determinant of the given 2x2 matrix.\n    Examples:\n    >>> determinant_2x2([[a, b], [c, d]])\n    a*d - b*c\n    >>> determinant_2x2([[1, 2], [3, 4]])\n    -2\n    \"\"\"\n    if len(matrix) != 2 or len(matrix[0]) != 2 or len(matrix[1]) != 2:\n        raise ValueError(\"Input must be a 2x2 matrix.\")\n    \n    return matrix[0][0] * matrix[1][1] - matrix[0][1] * matrix[1][0]", "def is_orthogonal(matrix):\n    \"\"\"\n    Checks if a given square matrix is orthogonal.\n    \n    Parameters:\n        matrix (np.ndarray): A square numpy array representing the matrix to be checked.\n    Returns:\n        bool: True if the matrix is orthogonal, False otherwise.\n    Examples:\n        >>> is_orthogonal(np.array([[1, 0], [0, 1]]))\n        True\n        >>> is_orthogonal(np.array([[0, 1], [1, 0]]))\n        True\n        >>> is_orthogonal(np.array([[2, 0], [0, 2]]))\n        False\n    \"\"\"\n    if not isinstance(matrix, np.ndarray):\n        raise ValueError(\"The input should be a numpy array\")\n    \n    if matrix.shape[0] != matrix.shape[1]:\n        raise ValueError(\"The matrix must be square\")\n    \n    identity = np.eye(matrix.shape[0])\n    transpose = matrix.T\n    product = np.dot(matrix, transpose)\n    \n    return np.allclose(product, identity)", "def scalar_multiply_matrix(matrix, scalar):\n    \"\"\"\n    Multiplies each element of a 2x2 matrix by a given scalar.\n    \n    Parameters:\n    matrix (list of list of floats): The original 2x2 matrix.\n    scalar (float): The scalar value to multiply with each element of the matrix.\n    \n    Returns:\n    list of list of floats: A new 2x2 matrix each element of which has been multiplied by the scalar.\n    \n    Examples:\n    >>> scalar_multiply_matrix([[1, 2], [3, 4]], 3)\n    [[3, 6], [9, 12]]\n    >>> scalar_multiply_matrix([[1, -1], [-1, 1]], 0.5)\n    [[0.5, -0.5], [-0.5, 0.5]]\n    \"\"\"\n    return [[element * scalar for element in row] for row in matrix]", "def solve_linear_system(matrix, constants):\n    \"\"\"\n    Solve a linear system using the matrix of coefficients and a constants vector, relying on determinants.\n    Parameters:\n    matrix (list[list[float]] or sp.Matrix): The coefficient matrix of the system.\n    constants (list[float] or sp.Matrix): The constants vector on the right-hand side of the equations.\n    Returns:\n    Union[sp.Matrix, None]: The solution of the system as a symbolic vector or None if no unique solution exists.\n    \n    Example:\n    >>> solve_linear_system([[2, -1], [5, 3]], [1, 28])\n    Matrix([[6], [7]])\n    \"\"\"\n    matrix = sp.Matrix(matrix)\n    constants = sp.Matrix(constants)\n    \n    if matrix.det() == 0:\n        print(\"The system has no unique solutions or infinitely many solutions.\")\n        return None\n    \n    # Using Cramer's Rule since it's based on determinants to solve\n    return matrix.solve(constants)", "class MatrixDeterminantTools:\n    \"\"\"\n    A collection of tools for working with determinants of matrices, addressing a variety of subtasks related to linear algebra and determinant properties.\n    \"\"\"\n    @staticmethod\n    def calculate_determinant(matrix):\n        \"\"\"\n        Calculate the determinant of a given square matrix.\n        Parameters:\n        matrix (np.ndarray): A square matrix whose determinant is to be calculated.\n        Returns:\n        float: The determinant of the matrix.\n        Example:\n        >>> MatrixDeterminantTools.calculate_determinant(np.array([[1, 2], [3, 4]]))\n        -2.0\n        \"\"\"\n        return np.linalg.det(matrix)\n    @staticmethod\n    def system_to_matrix(coefficients):\n        \"\"\"\n        Converts a list of coefficient lists from a system of linear equations into a matrix.\n        Parameters:\n        coefficients (list of lists): Coefficients from a system of equations, where each sublist represents the coefficients of one equation.\n        Returns:\n        np.ndarray: The coefficient matrix.\n        Example:\n        >>> MatrixDeterminantTools.system_to_matrix([[1, -2], [3, 4]])\n        array([[ 1, -2],\n               [ 3,  4]])\n        \"\"\"\n        return np.array(coefficients)\n    @staticmethod\n    def determinant_special_cases(matrix):\n        \"\"\"\n        Computes and checks determinant special cases for certain pre-defined matrices like identity, zero or diagonal matrices.\n        Parameters:\n        matrix (np.ndarray): The matrix to check special cases for.\n        Returns:\n        str: Description of the determinant case.\n        Example:\n        >>> MatrixDeterminantTools.determinant_special_cases(np.eye(2))\n        'Determinant of the identity matrix is 1.'\n        \"\"\"\n        if np.array_equal(matrix, np.eye(len(matrix))):\n            return f\"Determinant of the identity matrix is 1.\"\n        elif np.all((matrix == 0)):\n            return f\"Determinant of the zero matrix is 0.\"\n        elif np.allclose(matrix, np.diag(np.diagonal(matrix))):\n            return f\"Determinant of the diagonal matrix is product of its diagonal elements: {np.prod(np.diagonal(matrix))}.\"\n        return \"No special determinant case recognized. Consider computing normally.\"\n    @staticmethod\n    def determinant_and_matrix_powers(matrix, power):\n        \"\"\"\n        Computes determinant of a matrix raised to a specific power.\n        Parameters:\n        matrix (np.ndarray): The base matrix.\n        power (int): The power to which the matrix is to be raised.\n        Returns:\n        float: The determinant of the matrix raised to the given power.\n        Example:\n        >>> MatrixDeterminantTools.determinant_and_matrix_powers(np.array([[1, 2], [3, 4]]), 2)\n        4.0\n        \"\"\"\n        exp_matrix = np.linalg.matrix_power(matrix, power)\n        return np.linalg.det(exp_matrix)\n    @staticmethod\n    def solve_linear_system(matrix, identity):\n        \"\"\"\n        Solves a linear system where the matrix product is equated to an identity matrix.\n        Parameters:\n        matrix (np.ndarray): The coefficient matrix.\n        identity (np.ndarray): The identity matrix, typically `np.eye(n)`.\n        Returns:\n        np.ndarray: Solution to the system.\n        Example:\n        >>> MatrixDeterminantTools.solve_linear_system(np.array([[1, 2], [3, 4]]), np.eye(2))\n        array([[-2. ,  1. ],\n               [ 1.5, -0.5]])\n        \"\"\"\n        if MatrixDeterminantTools.calculate_determinant(matrix) == 0:\n            raise ValueError(\"The matrix is singular and cannot be inverted.\")\n        return np.linalg.inv(matrix)", "def calculate_determinant(matrix, symbolic=False):\n    \"\"\"\n    Compute the determinant of a square matrix using numeric or symbolic computation.\n    \n    Parameters:\n    - matrix (list of lists or sympy.Matrix): Matrix for which the determinant is to be calculated.\n    - symbolic (bool): If True, will treat the matrix elements as symbols for symbolic computation. Otherwise, will perform numerical computation.\n    \n    Returns:\n    - float or sympy.Expr: The determinant of the matrix.\n    \n    Examples:\n    >>> calculate_determinant([[1, 2], [3, 4]])\n    -2\n    >>> calculate_determinant([[1, 2], [3, 4]], symbolic=True)\n    -2\n    >>> m = sp.Matrix([[sp.cos(x), -sp.sin(x)], [sp.sin(x), sp.cos(x)]])\n    >>> calculate_determinant(m, symbolic=True)\n    1\n    \"\"\"\n    if symbolic:\n        # Assure the input is a sympy Matrix for symbolic computation\n        if not isinstance(matrix, sp.Matrix):\n            matrix = sp.Matrix(matrix)\n        return matrix.det()\n    else:\n        # Use numpy for numeric computation\n        matrix = np.array(matrix)\n        return round(float(np.linalg.det(matrix)), 10)  # rounded for floating-point precision issues", "def check_linear_independence(*vectors):\n    \"\"\"\n    Checks if the given vectors are linearly independent.\n    Parameters:\n    - vectors (tuple of lists): Vectors to check linear independence.\n    Returns:\n    - bool: True if vectors are linearly independent, False otherwise.\n    Example:\n    >>> check_linear_independence([1, 2], [2, 4])\n    False\n    >>> check_linear_independence([1, 0, 0], [0, 1, 0], [0, 0, 1])\n    True\n    \"\"\"\n    matrix = np.array(vectors).T  # form a matrix with vectors as columns\n    determinant = np.linalg.det(matrix)\n    return np.isclose(determinant, 0, atol=1e-9)  # Check if the determinant is effectively zero", "def compute_vector_norm(vector, ord=None):\n    \"\"\"\n    Computes the norm of a given vector.\n    Parameters:\n    vector (np.array): The vector to compute the norm of.\n    ord (int, float, optional): Order of the norm. If None, it defaults to 2 (Euclidean norm).\n    Returns:\n    float: The norm of the vector.\n    Examples:\n    >>> compute_vector_norm(np.array([3, 4]))\n    5.0\n    >>> compute_vector_norm(np.array([1, 2, 3]), ord=1)\n    6\n    \"\"\"\n    return np.linalg.norm(vector, ord=ord)"], "Vectors and Parametric Equations": ["def cross_product(v1, v2):\n    \"\"\"Compute the cross product of two vectors (3-dimensional).\n    \n    Parameters:\n        v1 (np.array): First vector.\n        v2 (np.array): Second vector.\n        \n    Returns:\n        np.array: Cross product of the two vectors.\n    \"\"\"\n    return np.cross(v1, v2)", "def vector_magnitude(v):\n    \"\"\"Compute the magnitude (norm) of a vector.\n    \n    Parameters:\n        v (np.array): Vector.\n        \n    Returns:\n        float: Magnitude of the vector.\n    \"\"\"\n    return np.linalg.norm(v)", "def vector_projection(v, w):\n    \"\"\"\n    Calculates the vector projection of vector v onto vector w.\n    Parameters:\n    v (array-like): The vector to be projected.\n    w (array-like): The vector onto which v is projected.\n    Returns:\n    numpy.ndarray: The projection of vector v onto vector w.\n    \n    Examples:\n    >>> v = np.array([3, 4])\n    >>> w = np.array([1, 0])\n    >>> vector_projection(v, w)\n    array([3., 0.])\n    \"\"\"\n    v = np.asarray(v)\n    w = np.asarray(w)\n    return (np.dot(v, w) / np.dot(w, w)) * w", "def add_vectors(v1, v2):\n    \"\"\"Add two vectors.\n    \n    Parameters:\n        v1 (np.array): First vector.\n        v2 (np.array): Second vector.\n        \n    Returns:\n        np.array: Resultant vector after addition.\n    \"\"\"\n    return np.add(v1, v2)", "def subtract_vectors(v1, v2):\n    \"\"\"Subtract one vector from another.\n    \n    Parameters:\n        v1 (np.array): Vector from which to subtract.\n        v2 (np.array): Vector to subtract.\n        \n    Returns:\n        np.array: Resultant vector after subtraction.\n    \"\"\"\n    return np.subtract(v1, v2)", "def parametric_line(p, d):\n    \"\"\"Create a parametric line equation from a point and a direction vector.\n    \n    Parameters:\n        p (np.array): A point on the line (position vector).\n        d (np.array): Direction vector of the line.\n        \n    Returns:\n        function: A function that computes a point on the line given a parameter t.\n    \"\"\"\n    def line(t):\n        return p + t * d\n    return line", "def evaluate_line(v, d, t):\n    \"\"\"\n    Evaluates the parametric equation of a line at a given parameter value.\n    Parameters:\n        v (np.array): The point vector (origin) of the line.\n        d (np.array): The direction vector of the line.\n        t (float or np.array): The parameter at which to evaluate the line.\n    Returns:\n        np.array: The coordinates of the line at parameter t.\n    \n    Examples:\n        >>> evaluate_line(np.array([1, 1]), np.array([2, 2]), 0.5)\n        array([2., 2.])\n    \"\"\"\n    return v + t * d"]}