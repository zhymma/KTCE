{"Factorials": [["def compute_factorial(n):\n    \"\"\"\n    Compute the factorial of an integer n.\n    \n    Parameters\n    ----------\n    n : int\n        The input integer for which the factorial is to be calculated. Must be non-negative.\n    \n    Returns\n    -------\n    int\n        The factorial of the input integer n.\n    \n    Examples\n    --------\n    >>> compute_factorial(5)\n    120\n    \n    >>> compute_factorial(0)\n    1\n    \"\"\"\n    if n < 0:\n        raise ValueError(\"Input must be a non-negative integer.\")\n    return math.factorial(n)", "def factorial(n):\n    \"\"\"\n    Calculate the factorial of a given non-negative integer n.\n    Parameters:\n    n (int): A non-negative integer whose factorial is to be computed\n    Returns:\n    int: Factorial of the integer n\n    \n    Examples:\n    >>> factorial(5)\n    120\n    >>> factorial(0)\n    1\n    \"\"\"\n    if n < 0:\n        raise ValueError(\"Factorial is not defined for negative values\")\n    return math_factorial(n)", "def calculate_factorial(n):\n    \"\"\"\n    Calculate the factorial of a non-negative integer n.\n    Parameters:\n    n (int): A non-negative integer whose factorial is to be computed.\n    Returns:\n    int: The factorial of the input number n.\n    Examples:\n    >>> calculate_factorial(5)\n    120\n    >>> calculate_factorial(0)\n    1\n    \"\"\"\n    if n < 0:\n        raise ValueError(\"Factorial is not defined for negative numbers\")\n    return math.factorial(n)", "def factorial(n):\n    \"\"\"\n    Compute the factorial of a given non-negative integer n.\n    \n    Parameters:\n    n : int\n        A non-negative integer for which the factorial is to be computed.\n    \n    Returns:\n    int\n        Factorial of the given integer n.\n    \n    Raises:\n    ValueError\n        If n is negative.\n        \n    Examples:\n    >>> factorial(5)\n    120\n    >>> factorial(0)\n    1\n    \"\"\"\n    if n < 0:\n        raise ValueError(\"Factorial is not defined for negative integers\")\n    return math.factorial(n)", "def factorial_prime_factors(n):\n    \"\"\"\n    Calculate the prime factors of the factorial of n (n!).\n    \n    Parameters:\n    n : int\n        A non-negative integer whose factorial's prime factors are to be found.\n    \n    Returns:\n    list\n        A list of the unique prime factors of n!.\n    \n    Raises:\n    ValueError\n        If n is negative.\n        \n    Examples:\n    >>> factorial_prime_factors(5)\n    [2, 3, 5]\n    >>> factorial_prime_factors(0)\n    []\n    \"\"\"\n    if n < 0:\n        raise ValueError(\"Factorial is not defined for negative integers\")\n    # Factorial of 0 and 1 are 1, which has no prime factors\n    if n == 0:\n        return []\n    return list(set(primefactors(math.factorial(n))))", "def factorial(n):\n    \"\"\"\n    Calculate the factorial of a non-negative integer n.\n    \n    Parameters:\n    n (int): A non-negative integer whose factorial is desired.\n    \n    Returns:\n    int: The factorial of n.\n    \n    Raises:\n    ValueError: If n is negative.\n    \n    Examples:\n    >>> factorial(5)\n    120\n    >>> factorial(0)\n    1\n    \"\"\"\n    if n < 0:\n        raise ValueError(\"Factorial is not defined for negative numbers\")\n    return math.factorial(n)", "def factorial_value(n):\n    \"\"\"\n    Computes the factorial of a given non-negative integer.\n    Parameters\n    ----------\n    n : int\n        A non-negative integer for which the factorial is to be calculated.\n    Returns\n    -------\n    int\n        The factorial of the given integer.\n    Raises\n    ------\n    ValueError\n        If the input `n` is negative.\n    \n    Examples\n    --------\n    >>> factorial_value(5)\n    120\n    \n    >>> factorial_value(0)\n    1\n    \"\"\"\n    if n < 0:\n        raise ValueError(\"Factorial is not defined for negative integers\")\n    return math.factorial(n)", "def factorial(n):\n    \"\"\"\n    Calculate the factorial of a non-negative integer n using an iterative approach.\n    Parameters:\n    n (int): A non-negative integer whose factorial is to be calculated.\n    Returns:\n    int: The factorial of the given number n.\n    \n    Examples:\n    >>> factorial(5)\n    120\n    >>> factorial(0)\n    1\n    \"\"\"\n    if n < 0:\n        raise ValueError(\"Factorial is not defined for negative numbers\")\n    result = 1\n    for i in range(2, n+1):\n        result *= i\n    return result", "def factorial(n):\n    \"\"\"\n    Calculate the factorial of a non-negative integer n.\n    Parameters:\n    n (int): A non-negative integer whose factorial is to be computed.\n    Returns:\n    int: The factorial of the input number.\n    Examples:\n    >>> factorial(5)\n    120\n    >>> factorial(0)\n    1\n    \"\"\"\n    if n < 0:\n        raise ValueError(\"Factorial is not defined for negative numbers.\")\n    if n == 0:\n        return 1\n    result = 1\n    for i in range(2, n + 1):\n        result *= i\n    return result", "def factorial(n):\n    \"\"\"\n    Calculate the factorial of a non-negative integer n.\n    Parameters:\n        n (int): A non-negative integer whose factorial is desired.\n    Returns:\n        int: The factorial of the specified integer n.\n    Examples:\n        >>> factorial(5)\n        120\n        >>> factorial(0)\n        1\n        \n    Raises:\n        ValueError: If n is negative.\n    \"\"\"\n    if n < 0:\n        raise ValueError(\"Factorial is not defined for negative numbers.\")\n    return math_factorial(n)", "def factorial(n: int) -> int:\n    \"\"\"\n    Computes the factorial of a non-negative integer n.\n    Parameters\n    ----------\n    n : int\n        A non-negative integer whose factorial is to be computed.\n    Returns\n    -------\n    int\n        The factorial of the given integer n.\n    Raises\n    ------\n    ValueError\n        If n is negative.\n    Examples\n    --------\n    >>> factorial(5)\n    120\n    >>> factorial(0)\n    1\n    \"\"\"\n    if n < 0:\n        raise ValueError(\"Factorial is not defined for negative integers.\")\n    return math.factorial(n)", "def compute_factorial(n):\n    \"\"\"\n    Compute the factorial of a given non-negative integer.\n    Parameters:\n    n : int\n        A non-negative integer whose factorial is to be computed\n    Returns:\n    int\n        The factorial of the provided number n.\n    Raises:\n    ValueError:\n        If `n` is a negative integer, as factorials for negative integers are not defined.\n    Examples:\n    >>> compute_factorial(5)\n    120\n    >>> compute_factorial(0)\n    1\n    >>> compute_factorial(-1)\n    Traceback (most recent call last):\n        ...\n    ValueError: Factorial is not defined for negative numbers\n    Notes:\n    - Factorial of 0 is defined as 1.\n    - This function uses the `math.factorial` method which is efficient and handles large numbers well.\n    - The function raises an error for negative integers since factorials are not traditionally defined for negative numbers.\n    \"\"\"\n    from math import factorial\n    if n < 0:\n        raise ValueError(\"Factorial is not defined for negative numbers\")\n    return factorial(n)", "def factorial(n):\n    \"\"\"\n    Calculates the factorial of a non-negative integer n.\n    \n    Parameters:\n    n (int): A non-negative integer whose factorial is to be computed.\n    \n    Returns:\n    int: The factorial of n.\n    \n    Raises:\n    ValueError: If n is negative.\n    Examples:\n    >>> factorial(5)\n    120\n    \n    >>> factorial(0)\n    1\n    \"\"\"\n    if n < 0:\n        raise ValueError(\"Factorial is not defined for negative numbers\")\n    \n    from math import factorial as math_factorial\n    return math_factorial(n)", "def factorial(n):\n    \"\"\"\n    Calculate the factorial of a non-negative integer n.\n    Parameters:\n    n (int): A non-negative integer whose factorial is desired.\n    Returns:\n    int: The factorial of the given integer n.\n    Examples:\n    >>> factorial(5)\n    120\n    >>> factorial(0)\n    1\n    \"\"\"\n    if not isinstance(n, int) or n < 0:\n        raise ValueError(\"Input must be a non-negative integer\")\n        \n    from math import factorial as math_factorial\n    return math_factorial(n)", "def calculate_factorial(n):\n    \"\"\"\n    Compute the factorial of a non-negative integer n.\n    Parameters:\n        n (int): A non-negative integer for which the factorial will be computed.\n    Returns:\n        int: The factorial of the integer n.\n    Examples:\n        >>> calculate_factorial(5)\n        120\n        >>> calculate_factorial(0)\n        1\n    \"\"\"\n    if n < 0:\n        raise ValueError(\"Factorial is not defined for negative integers\")\n    return math.factorial(n)", "def factorial_prime_factors(n):\n    \"\"\"\n    Find the prime factors of n!.\n    Parameters:\n        n (int): A non-negative integer to find the prime factors of its factorial.\n    Returns:\n        list: A list of unique prime factors of n!.\n    Examples:\n        >>> factorial_prime_factors(5)\n        [2, 3, 5]\n        >>> factorial_prime_factors(8)\n        [2, 3, 5, 7]\n    \"\"\"\n    if n < 0:\n        raise ValueError(\"n must be a non-negative integer for factorial prime factors analysis\")\n    \n    # Compute n! and find its prime factors\n    fact = factorial(n)\n    return primefactors(fact)", "def calculate_factorial(n):\n    \"\"\"\n    Calculate and return the factorial of a given non-negative integer.\n    \n    Parameters:\n    n (int): A non-negative integer whose factorial is to be computed.\n    \n    Returns:\n    int: The factorial of the given integer.\n    \n    Raises:\n    ValueError: If the input is negative, as factorial for negative numbers is not defined.\n    \n    Examples:\n    >>> calculate_factorial(5)\n    120\n    >>> calculate_factorial(0)\n    1\n    \"\"\"\n    if n < 0:\n        raise ValueError(\"Factorial is not defined for negative numbers\")\n    return math.factorial(n)"], ["def permutations(n, k):\n    \"\"\"\n    Calculate the number of ways to choose k items from n items without replacement and with order.\n    \n    Parameters:\n    n (int): Total number of items.\n    k (int): Number of items to choose.\n    \n    Returns:\n    int: The number of k-permutations of n items.\n    \n    Raises:\n    ValueError: If n or k is negative, or if k > n.\n    \n    Examples:\n    >>> permutations(5, 3)\n    60\n    >>> permutations(5, 5)\n    120\n    \"\"\"\n    if n < 0 or k < 0:\n        raise ValueError(\"n and k must be non-negative integers\")\n    if k > n:\n        raise ValueError(\"Cannot choose more items than are available\")\n    return math.perm(n, k)", "def combinations(n, k):\n    \"\"\"\n    Calculate the number of ways to choose k items from n items without replacement and without order.\n    \n    Parameters:\n    n (int): Total number of items.\n    k (int): Number of items to choose.\n    \n    Returns:\n    int: The number of combinations of n items taken k at a time.\n    \n    Raises:\n    ValueError: If n or k is negative, or if k > n.\n    \n    Examples:\n    >>> combinations(5, 3)\n    10\n    >>> combinations(5, 2)\n    10\n    \"\"\"\n    if n < 0 or k < 0:\n        raise ValueError(\"n and k must be non-negative integers\")\n    if k > n:\n        raise ValueError(\"Cannot choose more items than are available\")\n    return math.comb(n, k)", "def combination(n, k):\n    \"\"\"\n    Calculate the number of ways to choose k items from n items without regard to the order (n choose k).\n    \n    Parameters:\n    n (int): The total number of items.\n    k (int): The number of items to choose.\n    \n    Returns:\n    int: The number of combinations.\n    \n    Raises:\n    ValueError: If n or k is negative, or if k is greater than n.\n    \n    Examples:\n    >>> combination(5, 3)\n    10\n    >>> combination(10, 0)\n    1\n    \"\"\"\n    if n < 0 or k < 0:\n        raise ValueError(\"n and k should be non-negative integers\")\n    if k > n:\n        raise ValueError(\"k cannot be greater than n\")\n    return math.comb(n, k)", "def permutation(n, k):\n    \"\"\"\n    Calculate the number of ways to arrange k items from n items (nPk).\n    \n    Parameters:\n    n (int): The total number of items.\n    k (int): The number of items to arrange.\n    \n    Returns:\n    int: The number of permutations.\n    \n    Raises:\n    ValueError: If n or k is negative, or if k is greater than n.\n    \n    Examples:\n    >>> permutation(5, 3)\n    60\n    >>> permutation(10, 0)\n    1\n    \"\"\"\n    if n < 0 or k < 0:\n        raise ValueError(\"n and k should be non-negative integers\")\n    if k > n:\n        raise ValueError(\"k cannot be greater than n\")\n    return math.perm(n, k)"], ["def calculate_permutations(n, r=None, fixed_positions=0, repeats=None):\n    \"\"\"\n    Calculate permutations of n items taken r at a time, optionally considering:\n    - fixed positions,\n    - repeated items.\n    Parameters:\n    n (int): Total number of distinct items.\n    r (int, optional): Number of items to be taken for permutation. If None, assumes r = n.\n    fixed_positions (int): Number of positions that are fixed. Default is 0.\n    repeats (dict, optional): A dictionary where keys are items and values are the repetition counts of the items.\n    Returns:\n    int: The number of possible permutations.\n    Examples:\n    >>> calculate_permutations(5, 3) # P(5,3)\n    60\n    >>> calculate_permutations(4, fixed_positions=1) # P(4,3)\n    24\n    >>> calculate_permutations(6, repeats={1: 2, 2: 1, 3: 3}) # Items 1 repeated 2 times, 2 repeated once, 3 repeated 3 times.\n    60\n    \"\"\"\n    if r is None:\n        r = n\n    if r > n:\n        return 0\n    if fixed_positions > r:\n        raise ValueError(\"Fixed positions cannot exceed number of positions taken for permutation.\")\n    \n    # Calculate the base permutation ignoring repetitions\n    permutation = math.factorial(n - fixed_positions) // math.factorial(n - r)\n    \n    # Adjust for any repetitions\n    if repeats:\n        for item_count in repeats.values():\n            permutation //= math.factorial(item_count)\n    \n    return permutation", "def permutations(n, r=None):\n    \"\"\"\n    Calculate the number of ways to arrange n items in r positions (nPr = n! / (n-r)!),\n    where order matters. If r is not specified, permutations of n items in n positions.\n    Parameters:\n    n (int): Total number of distinct items.\n    r (int, optional): Number of positions to fill. If None, r is assumed to be equal to n.\n    Returns:\n    int: The number of distinct permutations possible.\n    Examples:\n    >>> permutations(5, 3)\n    60\n    >>> permutations(5)\n    120\n    \"\"\"\n    if r is None:\n        r = n\n    if not 0 <= r <= n:\n        raise ValueError(\"r must be between 0 and n.\")\n    return factorial(n) // factorial(n - r)", "def permutations(n: int, r: int) -> int:\n    \"\"\"\n    Computes the number of permutations (nPr), ways to arrange r elements from a set of n elements.\n    Parameters\n    ----------\n    n : int\n        Total number of items.\n    r : int\n        Number of items to arrange.\n    Returns\n    -------\n    int\n        The number of ways to arrange r items from n items without replacement.\n    Raises\n    ------\n    ValueError\n        If n or r is negative or if r > n.\n    Examples\n    --------\n    >>> permutations(5, 3)\n    60\n    >>> permutations(6, 6)\n    720\n    \"\"\"\n    if n < 0 or r < 0 or r > n:\n        raise ValueError(\"Invalid value for n or r. Ensure 0 <= r <= n and n, r >= 0\")\n    return math.perm(n, r)", "def permutations(n, r):\n    \"\"\"\n    Calculates the number of permutations of n items taken r at a time.\n    \n    Parameters:\n    n (int): Total number of items.\n    r (int): Number of items to take.\n    \n    Returns:\n    int: The number of permutations of n items taken r at a time.\n    \n    Raises:\n    ValueError: If r > n or if n or r is negative.\n    \n    Examples:\n    >>> permutations(5, 3)\n    60\n    \n    >>> permutations(10, 0)\n    1\n    \"\"\"\n    if n < 0 or r < 0:\n        raise ValueError(\"n and r should be non-negative integers\")\n    if r > n:\n        raise ValueError(\"Cannot take more elements than available\")\n    \n    # Use the previously defined simplify_factorial_ratio function:\n    return simplify_factorial_ratio(n, n-r)", "def permutations(n, r=None, repetitions=None):\n    \"\"\"\n    Calculate the number of permutations of `n` items taken `r` at a time,\n    optionally considering repetitions.\n    Parameters:\n    n (int): Total number of distinct items.\n    r (int, optional): Number of items to permute. If None, r is set to n.\n    repetitions (dict, optional): A dictionary with items as keys and counts as values\n                                  indicating the number of times each item repeats.\n    Returns:\n    int: The number of permutations.\n    Examples:\n    >>> permutations(5)  # P(5, 5)\n    120\n    >>> permutations(5, 3)  # P(5, 3)\n    60\n    >>> permutations(5, repetitions={1: 3, 2: 2})  # Items `1` repeated 3 times and `2` repeated 2 times\n    10\n    Notes:\n    When `repetitions` is used, `n` is the count of all items considering repetitions.\n    \"\"\"\n    if r is None:\n        r = n\n    \n    if not isinstance(n, int) or not isinstance(r, int) or n < 0 or r < 0:\n        raise ValueError(\"n and r must be non-negative integers\")\n    \n    from math import factorial as math_factorial\n    \n    if repetitions:\n        if not all(isinstance(v, int) and v > 0 for v in repetitions.values()):\n            raise ValueError(\"All repetition counts must be positive integers\")\n        # Compute factorial(n) divided by the product of factorials of repeated items\n        numerator = math_factorial(n)\n        denominator = 1\n        for count in repetitions.values():\n            denominator *= math_factorial(count)\n        return numerator // denominator\n    \n    # If no repetitions, standard permutation formula P(n, r) = n! / (n-r)!\n    if r > n:\n        return 0\n    return math_factorial(n) // math_factorial(n - r)"], ["def binomial_coefficient(n, k):\n    \"\"\"\n    Calculate the binomial coefficient 'n choose k' which represents the number\n    of ways to choose k elements from a set of n elements without regard to the \n    order of selection.\n    \n    Parameters:\n    n : int\n        The total number of elements.\n    k : int\n        The number of elements to choose.\n    \n    Returns:\n    int\n        The binomial coefficient for the given values of n and k.\n    \n    Raises:\n    ValueError\n        If n or k is negative, or if k greater than n.\n        \n    Examples:\n    >>> binomial_coefficient(5, 2)\n    10\n    >>> binomial_coefficient(10, 0)\n    1\n    \"\"\"\n    if n < 0 or k < 0 or k > n:\n        raise ValueError(\"Invalid values for n and k. Ensure 0 <= k <= n and n, k >= 0.\")\n    return math.comb(n, k)", "def binomial_coefficient(n, k):\n    \"\"\"\n    Calculate the binomial coefficient C(n, k) which is the number of ways to choose k items from n items without regard to order.\n    Parameters:\n        n (int): The total number of items.\n        k (int): The number of items to choose.\n    Returns:\n        int: The binomial coefficient C(n, k).\n    Examples:\n        >>> binomial_coefficient(5, 2)\n        10\n        >>> binomial_coefficient(10, 5)\n        252\n    Raises:\n        ValueError: If n is negative or k is negative or if k > n.\n    \"\"\"\n    if n < 0 or k < 0 or k > n:\n        raise ValueError(\"Invalid values for n and/or k. Ensure that 0 <= k <= n and n >= 0.\")\n    return int(comb(n, k, exact=True))", "def calculate_binomial_coefficient(n, k):\n    \"\"\"\n    Calculate the binomial coefficient, \"n choose k\", which is defined as n! / (k! * (n-k)!).\n    Parameters:\n        n (int): The total number of items.\n        k (int): The number of items to choose.\n    Returns:\n        int: The binomial coefficient.\n    Examples:\n        >>> calculate_binomial_coefficient(5, 2)\n        10\n        >>> calculate_binomial_coefficient(10, 0)\n        1\n    \"\"\"\n    if n < 0 or k < 0:\n        raise ValueError(\"n and k must be non-negative integers\")\n    if k > n:\n        return 0\n    return math.factorial(n) // (math.factorial(k) * math.factorial(n - k))"], ["def factorial_product_simplify(n, k):\n    \"\"\"\n    Simplify a product of factorials often found in combinatorial problems.\n    Specifically, this will compute the combination C(n, k) = n! / (k! * (n-k)!)\n    \n    Parameters\n    ----------\n    n : int\n        The total number of items.\n    k : int\n        The number of items to choose.\n    \n    Returns\n    -------\n    int\n        The simplified product of factorials as an integer.\n    \n    Examples\n    --------\n    >>> factorial_product_simplify(5, 2)\n    10\n    \n    >>> factorial_product_simplify(6, 3)\n    20\n    \"\"\"\n    if n < 0 or k < 0 or k > n:\n        raise ValueError(\"Invalid input: Ensure 0 <= k <= n and n >= 0\")\n    \n    return math.comb(n, k)", "def simplify_factorial_ratio(n, k):\n    \"\"\"\n    Simplify a ratio of two factorials, specifically n! / k! where n >= k.\n    This is often used in permutation and combination calculations.\n    Parameters:\n    n (int): The upper value in the factorial ratio, where n >= k\n    k (int): The lower value in the factorial ratio, where k <= n\n    Returns:\n    int: The simplified value of n! / k!\n    Examples:\n    >>> simplify_factorial_ratio(5, 3)\n    20\n    >>> simplify_factorial_ratio(10, 10)\n    1\n    \"\"\"\n    if n < 0 or k < 0:\n        raise ValueError(\"Factorial is not defined for negative values\")\n    if k > n:\n        raise ValueError(\"k should be less than or equal to n for valid simplification\")\n        \n    # Optimization: directly compute the product by reducing the factorial computation\n    result = 1\n    for i in range(k + 1, n + 1):\n        result *= i\n    return result"], ["def permutations(n, k):\n    \"\"\"\n    Calculate the number of k-permutations of n items using factorial definitions.\n    Parameters:\n    n (int): Total number of items.\n    k (int): Number of positions to fill.\n    Returns:\n    int: The number of ways to arrange n items in k positions.\n    \n    Examples:\n    >>> permutations(5, 3)\n    60\n    >>> permutations(10, 1)\n    10\n    \"\"\"\n    if k > n:\n        return 0\n    return simplify_factorial_ratio(n, n-k)"], ["def combined_permutations(total_items, groups, unwanted=None):\n    \"\"\"\n    Calculate the total permutations considering different groups and subtracting\n    any unwanted arrangements using factorial operations.\n    Parameters:\n    total_items (int): Total number of items to arrange.\n    groups (list of int): Each element represents a number of items within a group treated as indistinguishable.\n    unwanted (int, optional): Number of unwanted scenarios to subtract, calculated as a factorial.\n    Returns:\n    int: Net permissible permutations.\n    Examples:\n    >>> combined_permutations(10, [7, 3])\n    120\n    >>> combined_permutations(10, [7, 3], unwanted=factorial(2))\n    60\n    \"\"\"\n    total_permutations = factorial(total_items)\n    for group_size in groups:\n        total_permutations //= factorial(group_size)\n    if unwanted is not None:\n        total_permutations -= unwanted\n    return total_permutations"], ["def combinations(n: int, r: int) -> int:\n    \"\"\"\n    Computes the number of combinations (nCr), ways to choose r elements from a set of n elements without regard to order.\n    Parameters\n    ----------\n    n : int\n        Total number of items.\n    r : int\n        Number of items to choose.\n    Returns\n    -------\n    int\n        The number of ways to choose r items from n items without replacement and without order.\n    Raises\n    ------\n    ValueError\n        If n or r is negative or if r > n.\n    Examples\n    --------\n    >>> combinations(5, 3)\n    10\n    >>> combinations(6, 2)\n    15\n    \"\"\"\n    if n < 0 or r < 0 or r > n:\n        raise ValueError(\"Invalid value for n or r. Ensure 0 <= r <= n and n, r >= 0\")\n    return math.comb(n, r)"], ["def factorial_gcd(a, b):\n    \"\"\"\n    Computes the greatest common divisor (GCD) of the factorials of two given non-negative integers.\n    Parameters\n    ----------\n    a : int\n        A non-negative integer.\n    b : int\n        Another non-negative integer.\n    Returns\n    -------\n    int\n        The GCD of the factorial of `a` and `b`.\n    Raises\n    ------\n    ValueError\n        If either input `a` or `b` is negative.\n    \n    Examples\n    --------\n    >>> factorial_gcd(5, 3)\n    6\n    \n    >>> factorial_gcd(7, 7)\n    5040\n    \"\"\"\n    if a < 0 or b < 0:\n        raise ValueError(\"Inputs should be non-negative integers\")\n    return math.gcd(factorial_value(a), factorial_value(b))"], ["def gcd_of_factorials(n, m):\n    \"\"\"\n    Compute the GCD of the factorials of two integers n and m.\n    \n    Parameters\n    ----------\n    n : int\n        The first input integer.\n    m : int\n        The second input integer.\n        \n    Returns\n    -------\n    int\n        The GCD of n! and m!.\n    \n    Examples\n    --------\n    >>> gcd_of_factorials(5, 3)\n    6\n    \n    >>> gcd_of_factorials(4, 4)\n    24\n    \"\"\"\n    return math.gcd(math.factorial(n), math.factorial(m))"], ["def simplify_factorial_ratio(numerator, denominator):\n    \"\"\"\n    Simplify the ratio of two factorials, given the numerator and denominator factorial values.\n    \n    This function is commonly used in scenarios like combinations and permutations where factorial\n    division occurs. It reduces the computation by cancelling out common factorial terms.\n    Parameters:\n    numerator (int): The upper factorial term.\n    denominator (int): The lower factorial term, should be less than or equal to the numerator.\n    Returns:\n    int: The result of numerator! / denominator! after simplification.\n    \n    Examples:\n    >>> simplify_factorial_ratio(5, 3)\n    20\n    >>> simplify_factor0lial_ratio(6, 6)\n    1\n    \"\"\"\n    if numerator < 0 or denominator < 0:\n        raise ValueError(\"Factorial is not defined for negative numbers\")\n    if denominator > numerator:\n        raise ValueError(\"Denominator cannot be greater than numerator for factorial ratio simplification\")\n    \n    result = 1\n    for i in range(denominator + 1, numerator + 1):\n        result *= i\n    return result", "def simplify_factorial_ratio(num, den):\n    \"\"\"\n    Simplifies a ratio of two factorials.\n    \n    Parameters:\n    num (int): The numerator factorial argument.\n    den (int): The denominator factorial argument.\n    \n    Returns:\n    int: The simplified result of the ratio num!/den!.\n    \n    Raises:\n    ValueError: If either num or den is negative, or if den > num.\n    \n    Examples:\n    >>> simplify_factorial_ratio(5, 3)\n    20\n    \n    >>> simplify_factorial_ratio(6, 6)\n    1\n    \"\"\"\n    if num < 0 or den < 0:\n        raise ValueError(\"Factorial is not defined for negative numbers\")\n    if den > num:\n        raise ValueError(\"Denominator cannot be greater than numerator in the ratio\")\n    \n    result = 1\n    for i in range(den+1, num+1):  # Simplification occurs by division of common terms\n        result *= i\n    return result"], ["def factorial_product_simplification(*args):\n    \"\"\"\n    Simplifies the product of factorials for an arbitrary number of given non-negative integers.\n    Parameters\n    ----------\n    *args : int\n        An arbitrary number of non-negative integers.\n    Returns\n    -------\n    int\n        The product of the factorials of the given numbers.\n    Raises\n    ------\n    ValueError\n        If any input value in `args` is negative.\n    Examples\n    --------\n    >>> factorial_product_simplification(3, 4, 5)\n    86400\n    \n    >>> factorial_product_simplification(1, 2, 3)\n    12\n    \"\"\"\n    if any(x < 0 for x in args):\n        raise ValueError(\"All inputs should be non-negative integers\")\n    return reduce(lambda x, y: x * math.factorial(y), args, 1)"]], "Counting Problems": [["def factorial(n):\n    if n == 0 or n == 1:\n        return 1\n    return n * factorial(n - 1)", "def factorial(n):\n    \"\"\" Recursive function to find factorial of n \"\"\"\n    if n == 0 or n == 1:\n        return 1\n    else:\n        return n * factorial(n - 1)"], ["def combination_count(n: int, k: int) -> int:\n    \"\"\"\n    Calculates combinations, the number of ways to choose k items from n items \n    without considering order.\n    \n    Parameters:\n        n (int): Total number of items in the set.\n        k (int): Number of items to select.\n    Returns:\n        int: The total number of combinations.\n    \n    Examples:\n        >>> combination_count(10, 2)\n        45\n        >>> combination_count(5, 5)\n        1\n    \"\"\"\n    if k > n:\n        return 0\n    return math.factorial(n) // (math.factorial(k) * math.factorial(n - k))", "def combination(n, k):\n    \"\"\"\n    Compute the binomial coefficient, which is the number of ways to choose `k`\n    items from `n` items without regard to the order of selection.\n    Parameters:\n        n (int): The total number of items.\n        k (int): The number of items to choose.\n    Returns:\n        int: The number of ways to choose `k` items from `n` items.\n    Examples:\n        >>> combination(5, 2)\n        10\n        >>> combination(10, 4)\n        210\n    Raises:\n        ValueError: If `k` > `n` or `n` or `k` < 0 since it violates the definition of combinations.\n    \"\"\"\n    from math import factorial\n    if k > n or n < 0 or k < 0:\n        raise ValueError(\"Invalid values for n and k where n must be >= k and n, k >= 0.\")\n    return factorial(n) // (factorial(k) * factorial(n - k))", "def combinations(n, r):\n    \"\"\"\n    Calculate the number of combinations (order does not matter) of choosing r items from n items.\n    \n    Parameters:\n    n (int): Total number of items.\n    r (int): Number of items to choose.\n    Returns:\n    int: The number of combinations.\n    Example:\n    >>> combinations(5, 3)  # Choosing 3 out of 5 distinct items\n    10\n    \"\"\"\n    return factorial(n) // (factorial(r) * factorial(n - r))", "def combinations(n, r):\n    \"\"\"\n    Calculate the number of ways to select r items from n items without regard to the order of selection.\n    \n    Parameters:\n        n (int): Total number of items.\n        r (int): Number of items to select.\n    \n    Returns:\n        int: The number of combinations.\n    \n    Examples:\n        >>> combinations(5, 3)\n        10\n        >>> combinations(10, 2)\n        45\n    \"\"\"\n    if r > n:\n        return 0\n    return factorial(n) // (factorial(r) * factorial(n - r))", "def combinations(n, k):\n    \"\"\"Calculate the number of combinations (n choose k), which is \"n choose k\" - \n    the number of ways to choose k items from n items without regard to order.\n    \n    Combining properties:\n    \\( C(n, k) = \\frac{n!}{k!(n-k)!} \\)\n    Parameters:\n        n (int): Total number of items.\n        k (int): Number of items to choose.\n    Returns:\n        int: The number of combinations (n choose k).\n    \n    Examples:\n        >>> combinations(10, 3)\n        120\n        >>> combinations(5, 2)\n        10\n        >>> combinations(10, 0)\n        1\n    \"\"\"\n    if k > n:\n        return 0\n    if k > n - k:  # Take advantage of symmetry: C(n, k) == C(n, n-k)\n        k = n - k\n    num = factorial(n)\n    den = factorial(k) * factorial(n - k)\n    return num // den", "def combination(n, k):\n    \"\"\"\n    Calculate the number of ways to choose k elements from a set of n elements where order does not matter.\n    Parameters:\n    n (int): Total number of elements.\n    k (int): Number of elements to choose.\n    Returns:\n    int: The number of combinations.\n    Examples:\n    >>> combination(5, 3)\n    10\n    >>> combination(10, 1)\n    10\n    \"\"\"\n    return factorial(n) // (factorial(k) * factorial(n - k))", "def combinations(n, k):\n    \"\"\"\n    Calculate the number of combinations (n choose k) using the combination formula.\n    \n    Parameters:\n        n (int): The total number of distinct items.\n        k (int): The number of items to choose.\n    \n    Returns:\n        int: The number of ways to choose k items from n distinct items, order does not matter.\n    \n    Examples:\n        >>> combinations(5, 2)\n        10\n        >>> combinations(10, 4)\n        210\n        >>> combinations(23, 0)\n        1\n    \"\"\"\n    if k > n:\n        return 0\n    if k == 0 or k == n:\n        return 1\n    k = min(k, n - k)  # Take advantage of symmetry in combinations: C(n, k) == C(n, n-k)\n    numerator = factorial_cached(n)\n    denominator = factorial_cached(k) * factorial_cached(n - k)\n    return numerator // denominator"], ["def factorial(n):\n    \"\"\"\n    Computes the factorial of a number.\n    \n    The factorial of n is the product of all positive integers less than or equal to n. \n    It is denoted by n!, and can be defined by the product: n! = n*(n-1)*(n-2)*...*3*2*1. \n    \n    Parameters:\n    n: int, input number.\n    \n    Returns:\n    int, the factorial of the input number n.\n    \n    Example:\n    >>> factorial(5)\n    120\n    \"\"\"\n    from math import factorial\n    return factorial(n)", "def factorial(n):\n    \"\"\"Compute factorial of a non-negative integer n using memoization to improve performance.\n    Parameters:\n        n (int): A non-negative integer whose factorial is desired.\n    Returns:\n        int: Factorial of n.\n    \n    Examples:\n        >>> factorial(5)\n        120\n        >>> factorial(0)\n        1\n    \"\"\"\n    if n == 0:\n        return 1\n    else:\n        return n * factorial(n - 1)", "def factorial(n):\n    \"\"\"\n    Calculate the factorial of a non-negative integer n.\n    Parameters:\n    n (int): A non-negative integer to calculate the factorial of.\n    Returns:\n    int: The factorial of n.\n    \n    Examples:\n    >>> factorial(5)\n    120\n    >>> factorial(0)\n    1\n    \"\"\"\n    import math\n    if n < 0:\n        raise ValueError(\"Factorial is not defined for negative numbers\")\n    return math.factorial(n)"], ["def permutations(n, r):\n    \"\"\"\n    Calculate the number of permutations (order matters) of choosing r items from n items.\n    Parameters:\n    n (int): Total number of items.\n    r (int): Number of items to choose.\n    Returns:\n    int: The number of permutations.\n    Example:\n    >>> permutations(5, 3)  # Choosing 3 out of 5 distinct items\n    60\n    \"\"\"\n    return factorial(n) // factorial(n - r)", "def permutations(n, r):\n    \"\"\"\n    Calculate the number of ways to arrange n items into r positions.\n    \n    Parameters:\n        n (int): Total number of items.\n        r (int): Number of positions to fill.\n    \n    Returns:\n        int: The number of permutations.\n    \n    Examples:\n        >>> permutations(4, 2)\n        12\n        >>> permutations(5, 5)\n        120\n    \"\"\"\n    return factorial(n) // factorial(n - r)", "def permutation(n, r):\n    \"\"\"\n    Computes the number of ways to select and arrange 'r' items from a set of 'n' distinct items. \n    This is calculated as nPr = n! / (n - r)!.\n    Parameters:\n    n (int): The total number of items in the set.\n    r (int): The number of items to select from the set.\n    Returns:\n    int: The number of ways to select and arrange 'r' items from a set of 'n' distinct items.\n    Example:\n    >>> permutation(5, 2)\n    20\n    \"\"\"\n    from math import factorial\n    return factorial(n) // factorial(n - r)", "def permutation(n, r):\n    \"\"\" Compute the number of permutations of n items taken r at a time.\n    Parameters:\n        n (int): Total number of items.\n        r (int): Number of items to select.\n    Returns:\n        int: Number of permutations.\n    \"\"\"\n    return math.perm(n, r)", "def calculate_permutations(n, r):\n    \"\"\"\n    Calculate the number of permutations.\n    Parameters:\n    n (int): total number of items.\n    r (int): number of items to arrange\n    Returns:\n    int: number of ways to arrange r items from a set of n\n    \"\"\"\n    \n    return perm(n, r)"], ["def permutation_count(n: int, r: int = None, repetitions: List[int] = None) -> int:\n    \"\"\"\n    Calculates the total number of permutations possible from a set of n items, \n    taking r items at a time, considering item repetitions.\n    \n    Parameters:\n        n (int): Total number of items in the set.\n        r (int, optional): Number of items to choose at a time. If not provided, assumes r = n.\n        repetitions (List[int], optional): List containing counts of indistinguishable items. \n                                           Useful when the items are not unique.\n    Returns:\n        int: The total number of permutations.\n    Examples:\n        >>> permutation_count(5, 3)\n        60\n        >>> permutation_count(6)  # P(6,6)\n        720\n        >>> permutation_count(5, repetitions=[3, 2])  # Permutations of multiset {3 x a, 2 x b}\n        10\n    \"\"\"\n    if r is None:\n        r = n\n    \n    if repetitions:\n        numerator = math.factorial(n)\n        denominator = math.prod(math.factorial(rep) for rep in repetitions)\n        return numerator // denominator\n    else:\n        return math.factorial(n) // math.factorial(n - r)", "def multiset_permutation(total_items, repetitions):\n    \"\"\"\n    Calculate the number of permutations of a multiset where some items may be indistinguishable.\n    Parameters:\n    total_items (int): The total number of items in the multiset.\n    repetitions (list): A list of integers where each integer represents the count of each indistinguishable item.\n    Returns:\n    int: The number of distinct permutations of the multiset.\n    Examples:\n    >>> multiset_permutation(5, [3, 2])  # e.g., three Xs and two Ys\n    10\n    >>> multiset_permutation(6, [2, 2, 2])  # e.g., two Xs, two Ys, two Zs\n    90\n    \"\"\"\n    from functools import reduce\n    from operator import mul\n    denominator = reduce(mul, (factorial(count) for count in repetitions), 1)\n    return factorial(total_items) // denominator"], ["def permutations(n, m):\n    \"\"\"\n    Calculate the number of permutations of n items taken m at a time, denoted as P(n, m).\n    \n    Parameters:\n        n (int): Total number of items.\n        m (int): Number of items to choose.\n    Returns:\n        int: Number of permutations.\n    \n    Examples:\n        >>> permutations(5, 3)\n        60\n    \"\"\"\n    if m > n:\n        return 0\n    return factorial(n) // factorial(n - m)", "def combinations(n, m):\n    \"\"\"\n    Calculate the number of combinations of n items taken m at a time, denoted as C(n, m).\n    \n    Parameters:\n        n (int): Total number of items.\n        m (int): Number of items to choose.\n    Returns:\n        int: Number of combinations.\n    \n    Examples:\n        >>> combinations(5, 3)\n        10\n    \"\"\"\n    if m > n:\n        return 0\n    return factorial(n) // (factorial(m) * factorial(n - m))"], ["def inclusion_exclusion(sets, universe_size):\n    \"\"\"\n    Apply the inclusion-exclusion principle to calculate the size of the union of several sets.\n    \n    Parameters:\n    sets (list of sets or dicts): A list where each element represents a set.\n    universe_size (int): The size of the universal set containing all items.\n    \n    Returns:\n    int: The size of the union of the given sets.\n    Example:\n    >>> A = {1, 2, 3}\n    >>> B = {3, 4, 5}\n    >>> C = {5, 6, 7}\n    >>> inclusion_exclusion([A, B, C], 7)  # Assuming the universe size is 7\n    6\n    \"\"\"\n    from itertools import combinations\n    union_size = 0\n    for i in range(1, len(sets) + 1):\n        for subset in combinations(sets, i):\n            intersect_size = len(set.intersection(*subset))\n            union_size += intersect_size * (-1) ** (i + 1)\n    return universe_size + union_size", "def inclusion_exclusion(principle_sets, universe_size):\n    \"\"\" Calculate the overall count using inclusion-exclusion principle.\n    Parameters:\n        principle_sets (list): List of tuples where each tuple have a set and its count.\n        universe_size (int): Total size of the universal set.\n    Returns:\n        int: Calculated result using the principle of inclusion-exclusion.\n    \"\"\"\n    # Implementation logic will involve generating all possible intersections and alternately adding/subtracting their sizes\n    from itertools import combinations\n    \n    def set_size(intersecting_sets):\n        intersect_size = len(intersecting_sets[0])\n        for other_set in intersecting_sets[1:]:\n            intersect_size *= len(other_set)\n        return intersect_size\n    \n    total = 0\n    for i in range(1, len(principle_sets) + 1):\n        for subset in combinations(principle_sets, i):\n            intersect_size = set_size([s"], ["def constraint_function(total):\n    max_choices = 5 * 3  # Maximum choices for the first and third positions\n    return total - max_choices"], ["def multistage_choices(choices):\n    \"\"\" Calculate total outcomes for sequential selection stages.\n    Parameters:\n        choices (list of list of int): Each sublist represents choices available in each stage.\n    Returns:\n        int: Total number of outcomes.\n    \"\"\"\n    from functools import reduce\n    import operator\n    \n    return reduce(operator.mul, (len(stage) for stage in choices))"], ["def count_by_multiplication(elements, constraints=None):\n    \"\"\"\n    Calculate total outcomes using the multiplication principle with an option to apply constraints\n    via a custom function (inclusion-exclusion principle).\n    Parameters:\n        elements (list): List of integers representing the number of choices at each step.\n        constraints (func, optional): A function that accepts the number of total unrestricted outcomes\n                                      and returns the number of valid outcomes considering constraints.\n    Returns:\n        int: The total number of possible outcomes or valid outcomes based on constraints.\n    Examples:\n        >>> count_by_multiplication([3, 4, 5])  # Simple case without constraints\n        60\n        >>> count_by_multiplication([3, 4, 5], lambda x: x - 10)  # Applying a simple constraint\n        50\n    \"\"\"\n    from functools import reduce\n    from operator import mul\n    total_outcomes = reduce(mul, elements, 1)\n    if constraints:\n        return constraints(total_outcomes)\n    return total_outliers"], ["def factorial_cached(n):\n    \"\"\" Cached factorial function to improve performance in repeated calls with same n. \"\"\"\n    return factorial(n)"], ["def simplify_factorials(num, den):\n    \"\"\"\n    Simplify a fraction involved in factorial calculations by reducing numerator and denominator factorials.\n    \n    Parameters:\n        num (int): The numerator which could be n!\n        den (int): The denominator typically a product of factorials, e.g. k1!*k2!*...*km!\n    \n    Returns:\n        int: Simplified result of the fraction.\n    \n    Examples:\n        >>> simplify_factorials(5, 2*3)\n        10\n    \"\"\"\n    result = 1\n    for i in range(num, den, -1):\n        result *= i\n    return result"], ["def combination(n, r):\n    \"\"\" Compute the number of combinations of n items taken r at a time.\n    Parameters:\n        n (int): Total number of items.\n        r (int): Number of items to select.\n    Returns:\n        int: Number of combinations.\n    \"\"\"\n    return math.comb(n, r)", "def calculate_combinations(n, r):\n    \"\"\"\n    Calculate the number of combinations.\n    Parameters:\n    n (int): total number of items.\n    r (int): number of items to choose\n    Returns:\n    int: number of ways to choose r items from a set of n\n    \"\"\"\n    return comb(n, r)"], ["def binomial_coefficient(n, k):\n    \"\"\"\n    Calculate the binomial coefficient \"n choose k\", which is the number of ways to choose k items from n items without considering the order.\n    \n    Parameters:\n        n (int): Total number of items.\n        k (int): Number of items to choose.\n    \n    Returns:\n        int: The binomial coefficient.\n    \n    Examples:\n        >>> binomial_coefficient(5, 3)\n        10\n        >>> binomial_coefficient(10, 2)\n        45\n    \"\"\"\n    if k > n:\n        return 0\n    if k > n - k:  # Take advantage of symmetry\n        k = n - k\n    c = 1\n    for i in range(k):\n        c = c * (n - i) // (i + 1)\n    return c"], ["def permutation(n, k):\n    \"\"\"\n    Calculate the number of ways to choose k elements from a set of n elements where order matters.\n    Parameters:\n    n (int): Total number of elements.\n    k (int): Number of elements to arrange.\n    Returns:\n    int: The number of permutations.\n    Examples:\n    >>> permutation(5, 3)\n    60\n    >>> permutation(10, 1)\n    10\n    \"\"\"\n    return factorial(n) // factorial(n - k)"], ["def calculate_distribution(n, k):\n    \"\"\"\n    Calculate the number of ways to distribute n indistinguishable balls into k distinguishable boxes.\n    Parameters:\n    n (int): Number of indistinguishable balls.\n    k (int): Number of distinguishable boxes.\n    Returns:\n    int: the number of ways to distribute.\n    \"\"\"\n    return comb(n + k - 1, k - 1)"], ["def permutation_with_repetition(n, counts):\n    \"\"\"\n    Computes the number of permutations for a multiset.\n    The number of distinct permutations of a multiset is found by dividing the factorial \n    of the total number of items by the product of the factorials of the number of each \n    kind of item.\n    n: int, Total number of items.\n    counts: list of int, List containing the frequency of each kind of item.\n    Returns:\n    int, The number of distinct permutations of the multiset.\n    Example:\n    >>> permutation_with_repetition(8, [2, 2, 2, 2])\n    2520\n    \"\"\"\n    from math import factorial\n    result = factorial(n)\n    for c in counts:\n        result //= factorial(c)\n    return result"], ["def list_permutations(items, k):\n    \"\"\"List all possible permutations of k elements from the given items.\"\"\"\n    return list(permutations(items, k))"], ["def stars_and_bars(objects, bins):\n    \"\"\"\n    Calculate the number of ways to distribute indistinguishable objects into distinguishable bins.\n    \n    Parameters:\n        objects (int): Number of indistinguishable objects to distribute.\n        bins (int): Number of distinguishable bins.\n    \n    Returns:\n        int: Number of ways to distribute the objects among the bins.\n    \n    Examples:\n        >>> stars_and_bars(4, 2)\n        5\n        >>> stars_and_bars(3, 3)\n        10\n    \"\"\"\n    return combinations(objects + bins - 1, bins - 1)"], ["def recursive_count(base_cases, relation, steps):\n    \"\"\"\n    Compute counts using a recursive relation and base case values for a specified number of steps.\n    Parameters:\n    base_cases (dict): Dictionary of initial value pairs {step: value}.\n    relation (func): A function that provides the next value based on previous ones.\n    steps (int): The total number of steps to compute.\n    Returns:\n    any: The computed value at the specified step.\n    Example:\n    >>> recursive_count({0: 1, 1: 1}, lambda x, y: x + y, 5)  # Fibonacci sequence up to 5th step\n    8\n    \"\"\"\n    values = [base_cases[i] for i in sorted(base_list.keys())]  # Initialize values\n    for i in range(len(values), steps + 1):\n        next_value = relation(*values[-len(base_list):])\n        values.append(next_value)\n    return values[steps]"], ["def count_valid_permutations(n, constraints):\n    \"\"\" Count permutations of `n` items fulfilling given constraints.\n    Parameters:\n        n (int): Total number of items.\n        constraints (list of tuple): Each tuple contains a fixed element and its position.\n    Returns:\n        int: Number of valid permutations.\n    \"\"\"\n    from itertools import permutations\n    \n    items = list(range(1, n+1))\n    total = 0\n    for perm in permutations(items):\n        if all(perm[pos-1] == value for pos, value in constraints):\n            total += 1\n    return total"], ["def stars_and_bars(n, k):\n    \"\"\"Calculate the number of ways to distribute n indistinguishable items into k distinguishable bins.\"\"\"\n    # Translate into combinations problem: we have n items and k-1 bars to place\n    return calculate_combinations(n + k - 1, k - 1)"], ["def multiplicative_counting(*choices):\n    \"\"\"\n    Calculate the total number of outcomes for a series of independent choices using the multiplication principle.\n    Parameters:\n    *choices (int): A variable number of arguments, each representing the number of options for an independent event.\n    Returns:\n    int: The total number of possible outcomes.\n    Example:\n    >>> multiplicative_counting(3, 4, 2)  # e.g., 3 ways to choose a shirt, 4 ways to choose pants, 2 ways to wear shoes or not\n    24\n    \"\"\"\n    from functools import reduce\n    from operator import mul\n    return reduce(mul, choices, 1)"], ["def count_paths_grid(m, n):\n    \"\"\"Count paths in a m x n grid from (0, 0) to (m, n) only moving right or down.\"\"\"\n    # There are m moves down and n moves right, combination of these moves\n    return calculate_combinations(m + n, n)"], ["def factorial(n):\n    \"\"\"Calculate factorial of a number.\"\"\"\n    if n < 0:\n        raise ValueError(\"Factorial is not defined for negative numbers.\")\n    return math.factorial(n)"], ["def multiplicative_combinations(*args):\n    \"\"\"\n    Calculate the total number of ways to make selections from multiple independent categories.\n    Each category's choice is represented as a tuple (n, k), where `n` is the total number of items\n    and `k` is the number of items to be selected in that category.\n    Parameters:\n        args (list of tuples): A list where each tuple represents the choices from a category (n, k).\n    Returns:\n        int: The product of combinations from all categories, representing total selections.\n    Examples:\n        >>> multiplicative_combinations((5, 2), (3, 1))\n        30\n        >>> multiplicative_combinations((10, 2), (6, 3), (4, 1))\n        840\n    Note:\n        Uses the `combination` function defined above for calculating individual binomial coefficients.\n    \"\"\"\n    total_ways = 1\n    for n, k in args:\n        total_ways *= combination(n, k)\n    return total_ways"], ["def calculate_combinations(n, k):\n    \"\"\"Calculate C(n, k), the number of combinations of n items taken k at a time.\"\"\"\n    if n < k:\n        return 0\n    return factorial(n) // (factorial(k) * factorial(n - k))"], ["def calculate_permutations(n, k):\n    \"\"\"Calculate P(n, k), the number of ways to arrange k items out of n items.\"\"\"\n    if n < k:\n        return 0\n    return factorial(n) // factorial(n - k)"], ["def inclusion_exclusion_principle(sets, union=True):\n    \"\"\"Calculate the size of the union or intersection of multiple sets using the inclusion-exclusion principle.\"\"\"\n    from functools import reduce\n    \n    def union_count(sets):\n        n = len(sets)\n        count = 0\n        for i in range(1, n + 1):\n            signs = (-1) ** (i + 1)\n            for combo in combinations(sets, i):\n                intersected_set = reduce(lambda x, y: x & y, combo)\n                count += signs * len(intersected_set)\n        return count\n    def intersection_count(sets):\n        return len(reduce(lambda x, y: x & y, sets))\n    if union:\n        return union_list_sets(sets)\n    else:\n        return intersection_count(sets)"], ["def calculate_binomial_coefficient(n, k):\n    \"\"\"\n    Calculate the binomial coefficient, which is the coefficient of the term \n    in the expansion of (x + y) to the nth power.\n    Parameters:\n    n (int): the power to which the binomial is raised.\n    k (int): the term whose coefficient is calculated.\n    Returns:\n    int: the binomial coefficient.\n    \"\"\"\n    \n    return comb(n, k)"], ["def list_combinations(items, k):\n    \"\"\"List all possible combinations of k elements from the given items.\"\"\"\n    return list(combinations(items, k))"], ["def permutations_with_constraints(data, constraints):\n    \"\"\"Generate permutations of data considering positional constraints.\n    Parameters:\n        data (iterable): The items to permute.\n        constraints (dict): Positional constraints where keys are indices and values are fixed elements.\n    Returns:\n        generator: Yields valid permutations considering constraints.\n    \"\"\"\n    from itertools import permutations\n    \n    def is_valid(perm):\n        return all(perm[pos] == item for pos, item in constraints.items())\n    \n    return (perm for perm in permutations(data) if is_valid(perm))"], ["def factorial(n):\n    \"\"\" Compute the factorial of a number.\n    Parameters:\n        n (int): The number to compute factorial of.\n    Returns:\n        int: Factorial of `n`.\n    \"\"\"\n    return math.factorial(n)"], ["def combinations_with_replacement(n, k):\n    \"\"\"Generate all combinations of n items taken k at a time with replacement.\"\"\"\n    return list(combinations(range(n + k - 1), k))"]], "Binomial Coefficients": [["def check_pascal_identity(n, k):\n    \"\"\"\n    Validates Pascal's identity for given n and k: C(n, k) == C(n-1, k-1) + C(n-1, k)\n    \n    Parameters:\n    n (int): the total number of items.\n    k (int): the number of items being chosen.\n    \n    Returns:\n    bool: True if Pascal's identity holds, False otherwise.\n    \n    Examples:\n    >>> check_pascal_identity(5, 3)\n    True\n    >>> check_pascal_identity(10, 6)\n    True\n    \"\"\"\n    if k > n or k < 0:\n        return False\n    left_side = binomial_coefficient(n, k)\n    right_side = binomial_coefficient(n-1, k-1) + binomial_coefficient(n-1, k)\n    return left_side == right_side", "def apply_pascals_identity(n, k):\n    \"\"\"\n    Computes the binomial coefficient using Pascal's identity:\n        binom(n, k) = binom(n-1, k-1) + binom(n-1, k)\n    This function is particularly useful when previous values from the Pascal's triangle are known,\n    reducing the computational effort significantly compared to direct computation.\n    Parameters\n    ----------\n    n : int\n        The total number of items.\n    k : int\n        The number of items to choose.\n    Returns\n    -------\n    int\n        The binomial coefficient using Pascal's Identity.\n    Examples\n    --------\n    >>> apply_pascals_identity(5, 2)\n    10  # Since binom(4,1) + binom(4,2) = 4 + 6 = 10\n    Notes\n    -----\n    It is assumed that the previous binomial coefficients needed (binom(n-1, k-1) and binom(n-1, k)) are known or computed by the same method.\n    \"\"\"\n    if k == 0 or n == k:\n        return 1\n    else:\n        return calculate_binomial_coefficient(n - 1, k - 1) + calculate_binomial_coefficient(n - 1, k)", "def pascals_identity(n: int, k: int) -> bool:\n    \"\"\"\n    Validate Pascal's Identity: C(n, k) = C(n-1, k-1) + C(n-1, k)\n    \n    Parameters:\n        n (int): The total number of items.\n        k (int): The number of items to choose.\n    \n    Returns:\n        bool: True if Pascal's identity holds, otherwise False.\n        \n    Examples:\n        >>> pascals_identity(5, 3)\n        True\n    \"\"\"\n    if n <= 0 or k < 0 or k > n:\n        return False\n    left_side = calculate_binomial_coefficient(n, k)\n    right_side = calculate_binomial_coefficient(n-1, k-1) + calculate_binomial_coefficient(n-1, k)\n    return left_side == right_side"], ["def binomial_coefficient(n, k):\n    \"\"\"\n    Calculates the binomial coefficient \"n choose k\" which is the coefficient of the k-th term\n    in polynomial expansion of (1 + x)^n.\n    \n    Parameters:\n    n (int): the total number of items or the upper value in the binomial.\n    k (int): the number of items being chosen or the lower value in the binomial.\n    \n    Returns:\n    int: the binomial coefficient.\n    \n    Examples:\n    >>> binomial_coefficient(5, 2)\n    10\n    >>> binomial_coefficient(10, 5)\n    252\n    \"\"\"\n    if k > n:\n        return 0\n    if k == 0 or k == n:\n        return 1\n    k = min(k, n - k)  # Take advantage of symmetry\n    c = 1\n    for i in range(k):\n        c = c * (n - i) // (i + 1)\n    return c", "def binomial_coefficient(n, k):\n    \"\"\"\n    Calculate the binomial coefficient for given n and k.\n    Parameters:\n    n : int\n        The total number of items.\n    k : int\n        The number of items to choose.\n    Returns:\n    int\n        The binomial coefficient, which is the number of ways to choose k items from n items without regard to order.\n    Examples:\n    >>> binomial_coefficient(5, 2)\n    10\n    >>> binomial_coefficient(10, 5)\n    252\n    \"\"\"\n    if k < 0 or k > n:\n        return 0\n    if k == 0 or k == n:\n        return 1\n    k = min(k, n - k)  # Take advantage of symmetry\n    c = 1\n    for i in range(k):\n        c = c * (n - i) // (i + 1)\n    return c", "def calculate_binomial_coefficient(n, k):\n    \"\"\"\n    Calculates the binomial coefficient, also known as \"n choose k\", which is the number\n    of ways to choose k elements from n elements without considering the order.\n    Parameters\n    ----------\n    n : int\n        The total number of items.\n    k : int\n        The number of items to choose.\n    Returns\n    -------\n    int\n        The binomial coefficient for the given values of n and k.\n    Examples\n    --------\n    >>> calculate_binomial_coefficient(5, 2)\n    10\n    >>> calculate_binomial_coefficient(10, 4)\n    210\n    Notes\n    -----\n    The function uses the definition:\n        binom(n, k) = n! / (k! * (n-k)!)\n    \"\"\"\n    from math import factorial\n    if k > n:\n        return 0\n    if k == 0 or n == k:\n        return 1\n    if k > n - k:  # Take advantage of symmetry\n        k = n - k\n    return factorial(n) // (factorial(k) * factorial(n - k))", "def binomial_coefficient(n, k):\n    \"\"\"\n    Calculate the binomial coefficient (\"n choose k\") which represents the number of\n    ways to choose k elements from a set of n elements without considering the order.\n    Parameters:\n        n (int): the total number of elements.\n        k (int): the number of elements to choose.\n    Returns:\n        int: The binomial coefficient, computed as n! / (k! * (n-k)!)\n    Examples:\n        >>> binomial_coefficient(5, 2)\n        10\n        >>> binomial_coefficient(10, 5)\n        252\n    \"\"\"\n    from math import factorial\n    if k > n:\n        return 0\n    if k == 0 or k == n:\n        return 1\n    \n    # Apply symmetry for efficiency: C(n, k) == C(n, n-k)\n    k = min(k, n - k)\n    return factorial(n) // (factorial(k) * factorial(n - k))", "def calculate_binomial_coefficient(n: int, k: int) -> int:\n    \"\"\"\n    Calculate binomial coefficient for given `n` and `k` which is n choose k (denoted as C(n, k)).\n    Parameters:\n        n (int): The total number of items.\n        k (int): The number of items to choose.\n    Returns:\n        int: The binomial coefficient calculated as n! / (k! * (n-k)!)\n    Examples:\n        >>> calculate_binomial_coefficient(5, 2)\n        10\n        >>> calculate_binomial_coefficient(10, 4)\n        210\n    \"\"\"\n    if k > n:\n        return 0\n    if k == 0 or k == n:\n        return 1\n    k = min(k, n - k)  # Symmetry property\n    numerator = factorial(n)\n    denominator = factorial(k) * factorial(n - k)\n    return numerator // denominator", "def binomial_coefficient(n, k):\n    \"\"\"\n    Calculate the binomial coefficient \"n choose k\", which is the number of ways to choose k items from n items \n    without regard to the order of selection.\n    Parameters:\n    n (int): The total number of items.\n    k (int): The number of items to choose.\n    Returns:\n    int: The binomial coefficient.\n    Examples:\n    >>> binomial_coefficient(5, 2)\n    10\n    >>> binomial_coefficient(10, 5)\n    252\n    \"\"\"\n    if k > n:\n        return 0\n    if k == 0 or k == n:\n        return 1\n    k = min(k, n - k) # Take advantage of symmetry, nCk == nC(n-k)\n    numer = math.prod(range(n, n-k, -1))\n    denom = math.prod(range(1, k+1))\n    return numer // denom"], ["def sum_of_binomial_row(n: int) -> int:\n    \"\"\"\n    Calculate the sum of the nth row in Pascal's Triangle (which is actually 2^n).\n    \n    Parameters:\n        n (int): The row number to sum up the binomial coefficients.\n        \n    Returns:\n        int: The sum of binomial coefficients in the nth row of Pascal's Triangle.\n    Examples:\n        >>> sum_of_binomial_row(3)\n        8\n    \"\"\"\n    return 2 ** n"], ["def binomial_coefficient_relations(n: int, k: int) -> bool:\n    \"\"\"\n    Verify properties of binomial coefficients related to symmetry and other relations.\n    \n    Parameters:\n        n (int): Total number of items.\n        k (int): Number of items to choose.\n    \n    Returns:\n        bool: True if all properties hold, otherwise False.\n        \n    Examples:\n        >>> binomial_coefficient_relations(6, 2)\n        True\n    \"\"\"\n    if k > n or k < 0:\n        return False"], ["def binomial_theorem_expansion(base, exponent, terms):\n    \"\"\"\n    Calculate the terms of the expansion (a + b)^n using the Binomial Theorem. This function returns \n    the coefficients along with the terms involving `a` and `b` raised to appropriate powers.\n    Parameters:\n    base (tuple): The tuple (a, b) representing the base components to be used in the expansion.\n    exponent (int): The power to which the base is raised.\n    terms (int): The number of terms to return from the expansion.\n    Returns:\n    list of tuples: Each tuple contains (coefficient, power of a, power of b).\n    Examples:\n    >>> binomial_theorem_expansion((1, 1), 3, 4)\n    [(1, 3, 0), (3, 2, 1), (3, 1, 2), (1, 0, 3)]\n    \"\"\"\n    a, b = base\n    result = []\n    for k in range(terms):\n        coeff = binomial_coefficient(exponent, k)\n        term_a = exponent - k\n        term_b = k\n        result.append((coeff, term_a, term_b))\n    return result"], ["def pascals_triangle(rows: int) -> List[List[int]]:\n    \"\"\"\n    Generate Pascal's Triangle up to the specified number of rows.\n    \n    Parameters:\n        rows (int): Number of rows in Pascal's triangle to generate.\n    \n    Returns:\n        List[List[int]]: Pascal's Triangle as a list of lists, where each inner list represents a row of the triangle.\n    Examples:\n        >>> pascals_triangle(3)\n        [[1], [1, 1], [1, 2, 1]]\n    \"\"\"\n    triangle = [[1]]\n    for n in range(1, rows):\n        row = [1]\n        for k in range(1, n):\n            row.append(triangle[n-1][k-1] + triangle[n-1][k])\n        row.append(1)\n        triangle.append(row)\n    return triangle"], ["def sum_binomial_coefficients(n, k_start, k_end):\n    \"\"\"\n    Compute the sum of binomials coefficients from k_start to k_end for a given n.\n    Parameters:\n    n : int\n        The total number of items.\n    k_start : int\n        The starting value of k in the summation.\n    k_end : int\n        The ending value of k in the summation.\n    Returns:\n    int\n        The sum of binomial coefficients from k_start to k_end for a given n.\n    Examples:\n    >>> sum_binomial_coefficients(5, 0, 2)\n    16\n    >>> sum_binomial_coefficients(10, 3, 6)\n    386\n    \"\"\"\n    return sum(binomial_coefficient(n, k) for k in range(k_start, k_end + 1))"], ["def factorial(n):\n    \"\"\"\n    Compute the factorial of a non-negative integer n.\n    Parameters:\n    n : int\n        A non-negative integer\n    Returns:\n    int\n        The factorial of n, n!\n    Examples:\n    >>> factorial(5)\n    120\n    >>> factorial(0)\n    1\n    \"\"\"\n    if n < 0:\n        raise ValueError(\"Factorial is not defined for negative numbers\")\n    return math.factorial(n)"], ["def sum_of_binomial_coefficients(n):\n    \"\"\"\n    Calculates the sum of binomial coefficients for given n over k from 0 to n.\n    This is effectively evaluating (1 + 1)^n due to the Binomial Theorem.\n    \n    Parameters:\n    n (int): the upper value in the binomial coefficient.\n    \n    Returns:\n    int: the sum of binomial coefficients for given n.\n    \n    Examples:\n    >>> sum_of_binomial_coefficients(4)\n    16\n    >>> sum_of_binomial_coefficients(5)\n    32\n    \"\"\"\n    return 2 ** n"], ["def check_binomial_properties(n, k):\n    \"\"\"\n    Check and return various properties and identities of binomial coefficients, such as symmetry and special values.\n    \n    Parameters:\n        n (int): The total number of elements.\n        k (int): The number of elements to choose.\n        \n    Returns:\n        dict: A dictionary with properties and whether they hold for the given n and k.\n    \n    Examples:\n        >>> check_binomial_properties(5, 2)\n        {'symmetry': True, 'special_value_n': False, 'special_value_0': False}\n        >>> check_binomial_properties(6, 6)\n        {'symmetry': True, 'special_value_n': True, 'special_value_0': True}\n    \"\"\"\n    properties = {\n        'symmetry': binomial_coefficient(n, k) == binomial_coefficient(n, n - k),\n        'special_value_n': (k == n-1 and binomial_coefficient(n, k) == n),\n        'special_value_0': (k == 0 or k == n) and binomial_coefficient(n, k) == 1\n    }\n    return properties"]], "Pascal's Triangle": [["def pascals_triangle_row(n):\n    \"\"\"\n    Generate the nth row of Pascal's Triangle using the binomial coefficient formula.\n    Parameters:\n        n (int): The index of the row in Pascal's Triangle (0-indexed).\n    Returns:\n        list: A list containing the elements of the nth row of Pascal's Triangle.\n    Examples:\n        >>> pascals_triangle_row(4)\n        [1, 4, 6, 4, 1]\n        >>> pascals_triangle_row(5)\n        [1, 5, 10, 10, 5, 1]\n    \"\"\"\n    return [binomial_coefficient(n, k) for k in range(n + 1)]", "def generate_pascals_triangle(num_rows):\n    \"\"\"\n    Generates Pascal's triangle up to a specified number of rows.\n    \n    Parameters:\n        num_rows (int): The number of rows of Pascal's triangle to generate.\n    Returns:\n        list of lists: A list containing rows of Pascal's triangle; each row is also a list of integers.\n    \n    Examples:\n        >>> generate_pascals_triangle(5)\n        [[1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1]]\n    \"\"\"\n    triangle = []\n    for n in range(num_rows):\n        row = [1] * (n + 1)\n        for k in range(1, n):\n            row[k] = triangle[n - 1][k - 1] + triangle[n - 1][k]\n        triangle.append(row)\n    return triangle", "def generate_pascals_triangle(num_rows):\n    \"\"\"\n    Generate Pascal's triangle up to the specified number of rows.\n    \n    Parameters:\n    num_rows (int): The number of rows of Pascal's triangle to generate.\n    \n    Returns:\n    List[List[int]]: A list of lists, where each list represents a row of Pascal's triangle.\n    \n    Examples:\n    >>> generate_pascals_triangle(5)\n    [[1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1]]\n    \"\"\"\n    triangle = []\n    for n in range(num_rows):\n        row = [1] * (n + 1)\n        for k in range(1, n):\n            row[k] = triangle[n-1][k-1] + triangle[n-1][k]\n        triangle.append(row)\n    return triangle", "def generate_pascals_triangle(num_rows):\n    \"\"\"\n    Generates Pascal's Triangle up to the specified number of rows.\n    Parameters:\n    -----------\n    num_rows : int\n        The number of rows of Pascal's Triangle to generate.\n    Returns:\n    --------\n    list of lists of ints\n        Each sublist represents a row of Pascal's Triangle.\n    Example:\n    --------\n    >>> generate_pascals_triangle(3)\n    [[1], [1, 1], [1, 2, 1]]\n    \"\"\"\n    from math import factorial\n    def binom(n, k):\n        return factorial(n) // (factorial(k) * factorial(n - k))\n    \n    triangle = []\n    for n in range(num_rows):\n        row = []\n        for k in range(n + 1):\n            row.append(binom(n, k))\n        triangle.append(row)\n    \n    return triangle", "def generate_pascals_triangle(n_rows):\n    \"\"\"\n    Generates the first n_rows of Pascal's Triangle.\n    Parameters:\n    n_rows (int): Number of rows of Pascal's Triangle to generate.\n    Returns:\n    List[List[int]]: A list of rows, where each row is a list of integers representing a row in Pascal's Triangle.\n    Example:\n    >>> generate_pascals_triangle(5)\n    [[1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1]]\n    \"\"\"\n    triangle = []\n    for i in range(n_rows):\n        row = [1] * (i + 1)\n        if i > 1:\n            for j in range(1, i):\n                row[j] = triangle[i - 1][j - 1] + triangle[i - 1][j]\n        triangle.append(row)\n    return triangle", "def pascals_triangle(n):\n    \"\"\"\n    Generate Pascal's Triangle up to the nth row.\n    Parameters:\n        n (int): the number of rows in Pascal's Triangle to generate.\n    Returns:\n        List[List[int]]: A list containing rows of Pascal's Triangle.\n    Examples:\n    >>> pascals_triangle(3)\n    [[1], [1, 1], [1, 2, 1]]\n    >>> pascals_triangle(5)\n    [[1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1]]\n    \"\"\"\n    triangle = [[1]]\n    for i in range(1, n):\n        row = [1]\n        for j in range(1, i):\n            row.append(triangle[i-1][j-1] + triangle[i-1][j])\n        row.append(1)\n        triangle.append(row)\n    return triangle", "def generate_pascals_triangle(n: int) -> List[List[int]]:\n    \"\"\"\n    Generate rows of Pascal's Triangle up to the nth row.\n    \n    Parameters:\n    n : int\n        The number of rows of Pascal's Triangle to generate.\n    \n    Returns:\n    List[List[int]]\n        A list containing the rows of Pascal's Triangle.\n    \n    Examples:\n    >>> generate_pascals_triangle(5)\n    [[1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1]]\n    \"\"\"\n    triangle = []\n    for row in range(n):\n        row_data = [1] * (row + 1)\n        for col in range(1, row):\n            row_data[col] = triangle[row-1][col-1] + triangle[row-1][col]\n        triangle.append(row_data)\n    return triangle", "def generate_pascals_triangle(num_rows):\n    \"\"\"\n    Generate Pascal's Triangle up to a given number of rows.\n    \n    Parameters:\n        num_rows (int): The number of rows of Pascal's triangle to generate.\n        \n    Returns:\n        list: A list of lists, where each inner list represents a row of Pascal's triangle.\n    \n    Example:\n        >>> generate_pascals_triangle(3)\n        [[1], [1, 1], [1, 2, 1]]\n    \"\"\"\n    from math import comb\n    triangle = []\n    for n in range(num_rows):\n        row = [comb(n, k) for k in range(n + 1)]\n        triangle.append(row)\n    return triangle", "def generate_pascal_triangle_row(n):\n    \"\"\"\n    Generate the entire n-th row of Pascal's triangle using an iterative approach based on Pascal's identity.\n    Parameters:\n    - n (int): The index of the row (0-indexed)\n    Returns:\n    - list of int: The n-th row of Pascal's triangle\n    Examples:\n    >>> generate_pascal_triangle_row(5)\n    [1, 5, 10, 10, 5, 1]\n    >>> generate_pascal_triangle_fib(3)\n    [1, 3, 3, 1]\n    \"\"\"\n    if n == 0:\n        return [1]\n    row = [1]\n    for k in range(1, n + 1):\n        row.append(row[k - 1] * (n - k + 1) // k)\n    return row"], ["def check_parity_in_pascals_triangle(num_rows):\n    \"\"\"\n    Checks and counts the number of odd and even numbers in each row of Pascal's triangle.\n    \n    Parameters:\n        num_rows (int): The number of rows of Pascal's triangle to check.\n    Returns:\n        list of tuples: Each tuple contains (row_index, num_odd, num_even) for each row.\n    \n    Examples:\n        >>> check_parity_in_pascals_triangle(5)\n        [(0, 1, 0), (1, 2, 0), (2, 1, 2), (3, 2, 2), (4, 1, 4)]\n    \"\"\"\n    triangle = generate_pascals_triangle(num_rows)\n    parity_counts = []\n    for i, row in enumerate(triangle):\n        odd_count = sum(1 for num in row if num % 2 != 0)\n        even_count = len(row) - odd_count\n        parity_counts.append((i, odd_count, even_count))\n    return parity_counts", "def count_even_odd_numbers(n_rows):\n    \"\"\"\n    Counts the number of even and odd numbers in the first n rows of Pascal's Triangle.\n    Parameters:\n    n_rows (int): Number of rows of Pascal's Triangle to evaluate.\n    Returns:\n    tuple: A tuple (count_even, count_odd) representing the counts of even and odd numbers respectively.\n    Example:\n    >>> count_even_odd_numbers(5)\n    (7, 8)\n    \"\"\"\n    triangle = generate_pascals_triangle(n_rows)\n    count_even = 0\n    count_odd = 0\n    for row in triangle:\n        for num in row:\n            if num % 2 == 0:\n                count_even += 1\n            else:\n                count_odd += 1\n    return (count_even, count_odd)", "def pascal_triangle_details(num_rows):\n    \"\"\"\n    Perform detailed analysis of Pascal's triangle including searches,\n    even/odd checks and summation of rows.\n    \n    Parameters:\n        num_rows (int): The number of rows of Pascal's triangle to analyze.\n        \n    Returns:\n        dict: A dictionary containing sums of each row, positions of the first 3-digit number,\n        and counts of even and odd numbers.\n    \n    Example:\n        >>> pascal_triangle_details(5)\n        {'row_sums': [1, 2, 4, 8, 16], 'first_3_digit_occurrence': [(4, 4)], 'even_count': 2, 'odd_count': 18}\n    \"\"\"\n    triangle = generate_pascals_triangle(num_rows)\n    \n    details = {\n        'row_sums': [sum(row) for row in triangle],\n        'first_3_digit_occurrence': [],\n        'even_count': 0,\n        'odd_count': 0,\n    }\n    \n    for i, row in enumerate(triangle):\n        for j, element in enumerate(row):\n            if element == 100:\n                details['first_3_digit_occurrence'].append((i, j))\n            if element % 2 == 0:\n                details['even_count'] += 1\n            else:\n                details['odd_count'] += 1\n    \n    return details"], ["def pascals_triangle_row_sum(n):\n    \"\"\"\n    Calculate the sum of the elements in the nth row of Pascal's Triangle.\n    The sum of elements in the nth row is known to be 2^n.\n    Parameters:\n        n (int): The index of the row (0-indexed).\n    Returns:\n        int: Sum of the elements in the nth row.\n    Examples:\n        >>> pascals_triangle_row_sum(3)\n        8\n        >>> pascals_triangle_row_sum(4)\n        16\n    \"\"\"\n    return 2 ** n"], ["def binomial_coefficient(n, k):\n    \"\"\"\n    Compute the binomial coefficient, also known as \"n choose k\", which\n    is defined as the number of ways to choose k elements from a set of n elements\n    without considering the order, calculated as n! / (k! * (n - k)!).\n    Parameters:\n        n (int): Total number of items.\n        k (int): Number of items to choose.\n    Returns:\n        int: The binomial coefficient.\n    Examples:\n        >>> binomial_coefficient(5, 2)\n        10\n        >>> binomial_coefficient(10, 3)\n        120\n    \"\"\"\n    if k > n:\n        return 0\n    if k == 0 or k == n:\n        return 1\n    return factorial(n) // (factorial(k) * factorial(n - k))", "def calculate_binomial_coefficient(n, k):\n    \"\"\"\n    Calculate the binomial coefficient \"n choose k\", which is the coefficient of the k-th term \n    in the polynomial expansion of the binomial power (x + y)^n.\n    \n    Parameters:\n    n (int): The number of trials or the upper index in the binomial coefficient.\n    k (int): The number of successful outcomes or the lower index in the binomial coefficient.\n    \n    Returns:\n    int: The binomial coefficient calculated as n! / (k! * (n-k)!)\n    \n    Examples:\n    >>> calculate_binomial_coefficient(5, 2)\n    10\n    >>> calculate_binomial_coefficient(21, 11)\n    352716\n    \"\"\"\n    # Utilize symmetry property: binom(n, k) == binom(n, n-k)\n    if k > n - k:\n        k = n - k\n    \n    # Calculate the binomial coefficient either using factorial or scipy's optimized function\n    return int(binom(n, k))", "def binomial_coefficient(n, k):\n    \"\"\"\n    Calculate the binomial coefficient, also known as \"n choose k\", which\n    is the coefficient of the term x^k in the polynomial expansion of \n    the binomial power (1 + x)^n.\n    Parameters:\n    -----------\n    n : int\n        The number of trials or the upper index in the binomial coefficient.\n    k : int\n        The number of successful outcomes or the lower index in the binomial coefficient.\n    Returns:\n    --------\n    int\n        The binomial coefficient calculated as n! / (k! * (n-k)!)\n    Example:\n    --------\n    >>> binomial_coefficient(5, 3)\n    10\n    >>> binomial_coefficient(10, 2)\n    45\n    \"\"\"\n    from math import factorial\n    if k > n:\n        return 0\n    if k == 0 or k == n:\n        return 1\n    return factorial(n) // (factorial(k) * factorial(n - k))", "def binomial_coefficient(n, k):\n    \"\"\"\n    Calculate the binomial coefficient C(n, k) as n! / (k!*(n-k)!).\n    Parameters:\n        n (int): the total number of items.\n        k (int): the number of items to choose.\n    Returns:\n        int: the binomial coefficient.\n    Examples:\n    >>> binomial_coefficient(5, 2)\n    10\n    >>> binomial_coefficient(21, 10)\n    352716\n    \"\"\"\n    if k > n:\n        return 0\n    if k > n // 2:  # Utilize the symmetric property of binomial coefficients\n        k = n - k\n    return factorial(n) // (factorial(k) * factorial(n - k))", "def binomial_coefficient(n: int, k: int) -> int:\n    \"\"\"\n    Compute the binomial coefficient \"n choose k\".\n    Parameters:\n    n : int\n        The total number of items.\n    k : int\n        The number of items to choose.\n    Returns:\n    int\n        The calculated binomial coefficient.\n    \n    Examples:\n    >>> binomial_coefficient(5, 2)\n    10\n    \"\"\"\n    if k > n:\n        return 0\n    if k == 0 or n == k:\n        return 1\n    k = min(k, n - k)  # take advantage of symmetry\n    numerator = math.prod(range(n, n - k, -1))\n    denominator = math.factorial(k)\n    return numerator // denominator", "def binomial_coefficient(n, k):\n    \"\"\"\n    Calculate the binomial coefficient \"n choose k\", which is the coefficient for the \n    k-th element in the n-th row of Pascal's Triangle. It represents the number of \n    ways to choose k items from n items without regard to order.\n    Parameters:\n    - n (int): total number of items\n    - k (int): number of items to choose\n    Returns:\n    - int: binomial coefficient (n choose k)\n    Examples:\n    >>> binomial_coefficient(5, 2)\n    10\n    >>> binomial_coefficient(21, 10)\n    352716\n    \"\"\"\n    if k > n:\n        return 0\n    if k == 0 or k == n:\n        return 1\n    k = min(k, n - k)  # Take advantage of symmetry, C(n, k) == C(n, n-k)\n    c = 1\n    for i in range(k):\n        c = c * (n - i) // (i + 1)\n    return c"], ["def find_position_in_pascals_triangle(target, num_rows):\n    \"\"\"\n    Finds positions of a specific number in Pascal's triangle within the first `num_rows` rows.\n    \n    Parameters:\n        target (int): The number to find in Pascal's triangle.\n        num_rows (int): The number of rows to search through in Pascal's triangle.\n    Returns:\n        list of tuples: Each tuple contains (row_index, column_index) indicating the position of the target number.\n    \n    Examples:\n        >>> find_position_in_pascals_triangle(100, 15)\n        [(13, 6), (13, 7)] # assuming the number 100 appears in the 13th row, at positions 6 and 7\n    \"\"\"\n    triangle = generate_pascals_triangle(num_rows)\n    positions = []\n    for i, row in enumerate(triangle):\n        for j, number in enumerate(row):\n            if number == target:\n                positions.append((i, j))\n    return positions", "def find_number_in_pascal(number, n_rows):\n    \"\"\"\n    Finds and returns the positions of a given number in Pascal's Triangle up to n_rows.\n    Parameters:\n    number (int): The number to find in Pascal's Triangle.\n    n_rows (int): Number of rows to search through.\n    Returns:\n    List[tuple]: A list of tuples, each representing the (row, position) of the number in Pascal's Triangle.\n    Example:\n    >>> find_number_in_pascal(3, 5)\n    [(3, 1), (3, 2)]\n    \"\"\"\n    triangle = generate_pascals_triangle(n_rows)\n    positions = []\n    for r, row in enumerate(triangle):\n        if number in row:\n            positions.extend([(r, idx) for idx, val in enumerate(row) if val == number])\n    return positions"]]}