{"Properties of Integers": [["def modular_inverse(a, m):\n    \"\"\"\n    Computes the modular inverse of a under modulo m if exists.\n    Parameters:\n    - a (int): The number to find the inverse of.\n    - m (int): The modulus.\n    Returns:\n    - int: The modular inverse of a under modulus m, or None if no inverse exists.\n    Raises:\n    - ValueError: If the inverse does not exist.\n    \"\"\"\n    try:\n    \treturn mod_inverse(a, m)\n    except ValueError:\n    \treturn None", "def modular_inverse(a, n):\n    \"\"\"\n    Find the modular inverse of a under modulo n if it exists. The inverse exists if and only if a and n are relatively prime.\n    \n    Parameters:\n    - a: int, the number to find an inverse for.\n    - n: int, the modulo.\n    \n    Returns:\n    - int, the modular inverse of a mod n if it exists, otherwise raises an exception.\n    \n    Example:\n    >>> modular_inverse(3, 11)\n    4\n    \"\"\"\n    if is_relatively_prime(a, n):\n        for x in range(1, n):\n            if (a * x) % n == 1:\n                return x\n    raise ValueError(f\"No modular inverse exists for {a} under modulo {n}, since they are not relatively prime.\")", "def modular_inverse(a, n):\n    \"\"\"\n    Calculate the modular inverse of a under modulo n if it exists.\n    \n    Parameters:\n        a (int): The integer to find an inverse for.\n        n (int): The modulus.\n    \n    Returns:\n        int or None: The modular inverse of a under n if it exists, otherwise None if no inverse exists (i.e., a and n are not coprime).\n    \n    Examples:\n        >>> modular_inverse(3, 11)\n        4\n        >>> modular_inverse(10, 20)\n        None\n    \"\"\"\n    # Extended Euclidean Algorithm\n    t, newt = 0, 1\n    r, newr = n, a\n    while newr != 0:\n        quotient = r // newr\n        t, newt = newt, t - quotient * newt\n        r, newr = newr, r - quotient * newr\n    if r > 1:\n        return None  # a and n are not coprime\n    if t < 0:\n        t = t + n\n    return t", "def mod_inverse(a, n):\n    \"\"\"\n    Returns the modular inverse of a under modulo n.\n    Parameters:\n    a (int): The number to find an inverse for.\n    n (int): The modulus.\n    Returns:\n    int: The modular inverse of a under modulo n or None if no inverse exists.\n    Examples:\n    >>> mod_inverse(3, 11)\n    4\n    \"\"\"\n    try:\n        return sp.mod_inverse(a, n)\n    except ValueError:\n        return None"], ["def is_prime(number):\n    \"\"\"\n    Determine if a number is a prime number.\n    Parameters:\n    - number (int): The number to check.\n    Returns:\n    - bool: True if the number is a prime, otherwise False.\n    Examples:\n    >>> is_prime(11)\n    True\n    >>> is_prime(4)\n    False\n    \"\"\"\n    if number <= 1:\n        return False\n    if number <= 3:\n        return True\n    if number % 2 == 0 or number % 3 == 0:\n        return False\n    i = 5\n    while i * i <= number:\n        if number % i == 0 or number % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "def is_prime(n):\n    \"\"\"\n    Checks if the number n is a prime.\n    Parameters:\n    - n (int): The number to check for primality.\n    Returns:\n    - bool: True if n is a prime number, otherwise False.\n    Examples:\n    >>> is_prime(11)\n    True\n    >>> is_prime(4)\n    False\n    \"\"\"\n    return isprime(n)", "def is_prime(n):\n    \"\"\"\n    Determines if the given number is a prime.\n    \n    Parameters:\n        n (int): The number to check.\n        \n    Returns:\n        bool: True if n is a prime, False otherwise.\n        \n    Example:\n        >>> is_prime(29)\n        True\n        >>> is_phase(10)\n        False\n    \"\"\"\n    return sympy.isprime(n)", "def is_prime(n):\n    \"\"\"\n    Assess if an integer is a prime.\n    Parameters:\n    n (int): The integer to check.\n    Returns:\n    bool: True if n is a prime number, otherwise False.\n    Example:\n    >>> is_prime(29)\n    True\n    \"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "def is_prime(n):\n    \"\"\"\n    Determine if the input integer is a prime number.\n    Parameters:\n        n (int): The integer to check for primality.\n    Returns:\n        bool: True if n is prime, otherwise False.\n    \n    Examples:\n    >>> is_prime(29)\n    True\n    \"\"\"\n    return isprime(n)", "def is_prime(n):\n    \"\"\"\n    Check if a number is a prime.\n    Parameters:\n    - n (int): The integer to check for primality.\n    \n    Returns:\n    - bool: True if n is prime, False otherwise.\n    \n    Examples:\n    >>> is_prime(11)\n    True\n    >>> is_prime(12)\n    False\n    \"\"\"\n    return sympy.isprime(n)", "def is_prime(n):\n    \"\"\"\n    Determine whether an integer is a prime number.\n    Parameters:\n    - n : int\n        The integer to check for primality.\n    Returns:\n    - bool\n        True if n is a prime number, otherwise False.\n    \n    Examples:\n    >>> is_prime(29)\n    True\n    >>> is_prime(4)\n    False\n    \"\"\"\n    return sp.isprime(n)", "def is_prime(n):\n    \"\"\"\n    Check if the number is a prime.\n    Parameters:\n        n (int): The integer to check.\n    Returns:\n        bool: True if n is a prime, False otherwise.\n    Examples:\n        >>> is_prime(29)\n        True\n        >>> is_prime(4)\n        False\n    \"\"\"\n    return sympy.isprime(n)"], ["def count_divisors(n):\n    \"\"\"\n    Count the divisors of an integer n.\n    :param n: The integer to count divisors for.\n    :return: The count of divisors of n.\n    \n    Examples:\n    >>> count_divisors(36)\n    9\n    >>> count_divisors(37)\n    2\n    \"\"\"\n    total = 0\n    root = int(math.sqrt(n))\n    for i in range(1, root + 1):\n        if n % i == 0:\n            total += 1 + (i != n // i)\n    return total", "def count_divisors(n):\n    \"\"\"\n    Counts the number of divisors of n.\n    Parameters:\n    - n (int): The number to check.\n    Returns:\n    - int: Number of divisors of n.\n    Examples:\n    >>> count_divisors(12)\n    6\n    >>> count_divisors(13)\n    2\n    \"\"\"\n    return len(divisors(n))", "def count_divisors(n):\n    \"\"\"\n    Count the number of divisors of the given integer n.\n    Parameters:\n        n (int): The integer to count divisors for.\n    Returns:\n        int: The number of divisors of n.\n    Examples:\n        >>> count_divisors(36)\n        9\n    \"\"\"\n    return len(find_divisors(n))"], ["def is_divisible_by(number, divisor):\n    \"\"\"\n    Check if the number is divisible by the divisor.\n    Parameters:\n    - number (int): The number to be checked.\n    - divisor (int): The divisor to check against.\n    Returns:\n    - bool: True if number is divisible by divisor, False otherwise.\n    Examples:\n    >>> is_divisible_by(100, 5)\n    True\n    >>> is_divisible_by(101, 5)\n    False\n    \"\"\"\n    return number % divisor == 0", "def is_divisible_by(n, divisor):\n    \"\"\"\n    Check if an integer is divisible by another integer without remainder.\n    \n    Parameters:\n        n (int): The number to be tested for divisibility.\n        divisor (int): The divisor.\n    \n    Returns:\n        bool: True if `n` is divisible by `divisor`, False otherwise.\n    \n    Example:\n        >>> is_divisible_by(10, 2)\n        True\n    \"\"\"\n    if divisor == 0:\n        raise ValueError(\"Divisor cannot be zero.\")\n    return n % divisor == 0", "def divisibility_by_number(number, divisor):\n    \"\"\"\n    Check if a number is divisible by another number.\n    Parameters:\n    - number (int): The number to be divided.\n    - divisor (int): The divisor.\n    Returns:\n    bool: True if 'number' is divisible by 'divisor', False otherwise.\n    \n    Examples:\n    >>> divisibility_by_number(10, 2)\n    True\n    >>> divisibility_by_number(10, 3)\n    False\n    \"\"\"\n    return number % divisor == 0", "def is_divisible(n, divisor):\n    \"\"\"\n    Checks if the first number is divisible by the second number.\n    Parameters:\n    - n (int): Number to be checked.\n    - divisor (int): Divisor.\n    Returns:\n    bool: True if n is divisible by divisor, else False.\n    Example:\n    >>> is_divisible(10, 2)\n    True\n    >>> is_divisible(10, 3)\n    False\n    \"\"\"\n    return n % divisor == 0"], ["def prime_factors(n):\n    \"\"\"\n    Returns the list of prime factors of a given positive integer n.\n    Parameters:\n    - n (int): Positive integer to factorize.\n    \n    Returns:\n    - list: Prime factors of integer n.\n    Examples:\n    >>> prime_factors(18)\n    [2, 3, 3]\n    >>> prime_factors(17)\n    [17]\n    \"\"\"\n    i = 2\n    factors = []\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n            factors.append(i)\n    if n > 1:\n        factors.append(n)\n    return factors", "def prime_factors(n):\n    \"\"\"\n    Returns the prime factors of n as a dictionary where keys are the primes and values are their respective powers.\n    Parameters:\n    - n (int): The number to factorize.\n    Returns:\n    - dict: A dictionary of prime factors with their powers.\n    Examples:\n    >>> prime_factors(28)\n    {2: 2, 7: 1}\n    >>> prime_factors(100)\n    {2: 2, 5: 2}\n    \"\"\"\n    return factorint(n)", "def prime_factors(n):\n    \"\"\"\n    Compute the prime factors of a given number n.\n    Parameters:\n        n (int): The integer to factorize.\n    Returns:\n        dict: A dictionary where keys are the prime factors and values are their respective powers in the factorization.\n    \n    Examples:\n    >>> prime_factors(360)\n    {2: 3, 3: 2, 5: 1}\n    \"\"\"\n    return factorint(n)", "def prime_factors(n):\n    \"\"\"\n    Compute the prime factors of a given number.\n    Parameters:\n    - n (int): The integer to factorize.\n    \n    Returns:\n    - list: A list of integers representing the prime factors of n.\n    \n    Examples:\n    >>> prime_factors(12)\n    [2, 2, 3]\n    \"\"\"\n    return list(sympy.factorint(n).elements())", "def prime_factors(n):\n    \"\"\"\n    Decomposes an integer into its prime factors.\n    Parameters:\n    - n (int): The integer to factorize.\n    Returns:\n    tuple of ints: Tuple containing the prime factors.\n    Example:\n    >>> prime_factors(18)\n    (2, 3, 3)\n    \"\"\"\n    import sympy\n    factors = list(sympgy.ntheory.factorint(n).items())\n    result = []\n    for prime, exponent in factors:\n        result.extend([prime] * exponent)\n    return tuple(result)", "def prime_factors(n):\n    \"\"\"\n    Return the prime factors of a given integer n.\n    Parameters:\n        n (int): The integer to factorize.\n    Returns:\n        list: A list of prime factors of n.\n    Examples:\n        >>> prime_factors(18)\n        [2, 3, 3]\n    \"\"\"\n    return list(sympy.factorint(n).elements())"], ["def is_perfect_square(n):\n    \"\"\"\n    Checks if a number is a perfect square.\n    :param n: An integer to check for being a perfect square.\n    :return: A boolean, True if n is a perfect square, False otherwise.\n    \n    Examples:\n    >>> is_perfect_square(16)\n    True\n    >>> is_perfect_square(17)\n    False\n    \"\"\"\n    root = math.isqrt(n)\n    return root * root == n", "def is_perfect_square(n):\n    \"\"\"Check if a given number is a perfect square.\n    \n    Parameters:\n    n (int): The integer to check.\n    Returns:\n    bool: True if n is a perfect square, False otherwise.\n    \n    Examples:\n    >>> is_perfect_square(16)\n    True\n    >>> is_perfect_square(20)\n    False\n    \"\"\"\n    import math\n    if n < 0:\n        return False\n    root = math.isqrt(n)\n    return root * root == n", "def integer_squares(n):\n    \"\"\"\n    Check if a number is a perfect square.\n    Parameters:\n    - n (int): The integer to check.\n    \n    Returns:\n    - bool: True if n is a perfect square, False otherwise.\n    \n    Examples:\n    >>> integer_squares(16)\n    True\n    >>> integer_squares(14)\n    False\n    \"\"\"\n    root = int(n**0.5)\n    return root * root == n", "def is_perfect_square(n):\n    \"\"\"\n    Determine if the number `n` is a perfect square.\n    \n    Parameters:\n        n (int): The number to check.\n        \n    Returns:\n        bool: True if `n` is a perfect square, otherwise False.\n        \n    Examples:\n        >>> is_perfect_square(16)\n        True\n        >>> is_perfect_square(20)\n        False\n    \"\"\"\n    if n < 0:\n        return False\n    root = int(math.sqrt(n))\n    return n == root * root"], ["def modulo_add(a, b, n):\n    \"\"\"\n    Perform modular addition of two numbers a and b under modulo n.\n    Parameters:\n    - a (int): First number.\n    - b (int): Second number.\n    - n (int): Modulus.\n    Returns:\n    - int: Result of (a + b) % n.\n    Examples:\n    >>> modulo_add(3, 4, 5)\n    2\n    >>> modulo_add(10, 20, 7)\n    2\n    \"\"\"\n    return (a + b) % n", "def mod_add(a, b, n):\n    \"\"\"\n    Perform modular addition.\n    Parameters:\n    a (int): First term of addition.\n    b (int): Second term of addition.\n    n (int): Modulus.\n    Returns:\n    int: Result of (a + b) % n.\n    Examples:\n    >>> mod_add(5, 3, 7)\n    1\n    \"\"\"\n    return (a + b) % n", "def mod_multiply(a, b, n):\n    \"\"\"\n    Perform modular multiplication.\n    Parameters:\n    a (int): First factor.\n    b (int): Second factor.\n    n (int): Modulus.\n    Returns:\n    int: Result of (a * b) % n.\n    Examples:\n    >>> mod_multiply(3, 4, 5)\n    2\n    \"\"\"\n    return (a * b) % n"], ["def modular_sub(a, b, mod):\n    \"\"\"\n    Perform modular subtraction.\n    \n    Parameters:\n        a (int): The first operand.\n        b (int): The second operand subtracted from the first.\n        mod (int): The modulus.\n    \n    Returns:\n        int: The result of (a - b) % mod.\n    Examples:\n        >>> modular_sub(5, 3, 7)\n        2\n    \"\"\"\n    return (a - b) % mod", "def mod_subtract(a, b, n):\n    \"\"\"\n    Perform modular subtraction.\n    Parameters:\n    a (int): Minuend.\n    b (int): Subtrahend.\n    n (int): Modulus.\n    Returns:\n    int: Result of (a - b) % n.\n    Examples:\n    >>> mod_subtract(5, 3, 7)\n    2\n    \"\"\"\n    return (a - b) % n"], ["def modular_add(a, b, mod):\n    \"\"\"\n    Perform modular addition.\n    \n    Parameters:\n        a (int): The first operand.\n        b (int): The second operand.\n        mod (int): The modulus.\n    Returns:\n        int: The result of (a + b) % mod.\n    Examples:\n        >>> modular_add(3, 4, 5)\n        2\n    \"\"\"\n    return (a + b) % mod", "def modular_mult(a, b, mod):\n    \"\"\"\n    Perform modular multiplication.\n    \n    Parameters:\n        a (int): The first operand.\n        b (int): The second operand.\n        mod (int): The modulus.\n    Returns:\n        int: The result of (a * b) % mod.\n    Examples:\n        >>> modular_mult(4, 3, 5)\n        2\n    \"\"\"\n    return (a * b) % mod"], ["def count_powers(start, end, power):\n    \"\"\"Count the number of specific powers (e.g., squares, cubes) in a given range [start, end].\n    \n    Parameters:\n    start (int): The starting point of the range.\n    end (int): The ending point of the range.\n    power (int): The exponent value to test for (e.g., 2 for squares, 3 for cubes).\n    Returns:\n    int: Count of integers in the given range that are exact powers of the specified exponent.\n    \n    Examples:\n    >>> count_powers(1, 1000, 2)\n    31\n    >>> count_powers(1, 10000, 4)\n    7\n    \"\"\"\n    import math\n    lower_bound = math.ceil(pow(start, 1/power))\n    upper_bound = math.floor(pow(end, 1/power))\n    return upper_bound - lower_bound + 1", "def find_powers(start, end, power):\n    \"\"\"Find all integers in a given range that are exact powers of specified exponent.\n    \n    Parameters:\n    start (int): The lower boundary of the range.\n    end (int): The upper boundary of the range.\n    power (int): The exponent to check against.\n    Returns:\n    \n    Examples:\n    >>> find_powers(1, 100, 2)\n    [1, 4, 9, 16, 25, 36, 49, 64, 81, 100]\n    \"\"\"\n    import math\n    lower_bound = math.ceil(pow(start, 1/power))\n    upper_bound = math.floor(pow(end, 1/power))\n    return [i ** power for i in range(lower_override, upper_override + 1)]"], ["def nth_root(n, r):\n    \"\"\"\n    Computes the nth root of a number n.\n    Parameters:\n    - n (int): The number to find the root of.\n    - r (int): The root degree.\n    Returns:\n    - float: The nth root of n.\n    Examples:\n    >>> nth_root(16, 2)\n    4.0\n    >>> nth_root(27, 3)\n    3.0\n    \"\"\"\n    return n ** (1/r)", "def calculate_root(n, root_degree):\n    \"\"\"\n    Calculate the nth root of a given number using exponentiation.\n    Parameters:\n        n (float or int): The number to find the root of.\n        root_degree (int): The degree of the root.\n    Returns:\n        float: The nth root of the number.\n    \n    Examples:\n    >>> calculate_root(81, 4)\n    3.0\n    \"\"\"\n    return n ** (1 / root_degree)", "def integer_nth_root(n, root_degree):\n    \"\"\"\n    Calculates the integer part of the nth root of a number.\n    Parameters:\n    - n (int): The number.\n    - root_degree (int): The degree of the root.\n    Returns:\n    int: The integer part of the nth root.\n    Example:\n    >>> integer_nth_root(16, 2)\n    4\n    \"\"\"\n    import sympy\n    return int(sympy.ntheory.primetest.integer_nthroot(n, root_degree)[0])"], ["def integer_sign(n):\n    \"\"\"\n    Determine the sign of an integer.\n    Parameters:\n        n (int): The integer to check.\n    Returns:\n        int: -1 if negative, 1 if positive, 0 if zero.\n    Examples:\n        >>> integer_sign(-20)\n        -1\n        >>> integer_sign(15)\n        1\n    \"\"\"\n    if n < 0:\n        return -1\n    elif n > 0:\n        return 1\n    else:\n        return 0"], ["def chinese_remainder_theorem(congruences):\n    \"\"\"\n    Solves a system of simultaneous linear congruences using the Chinese Remainder Theorem.\n    Parameters:\n    - congruences (list of tuple): A list where each tuple is of the form (remainder, modulus).\n    Returns:\n    - int: The smallest non-negative solution to the system of congruences.\n    \"\"\"\n    return solve_congruence(*congruences)[0]", "def chinese_remainder_theorem(congruences):\n    \"\"\"\n    Solves a system of congruences using the Chinese Remainder Theorem.\n    Parameters:\n    congruences (list of tuples): A list where each tuple represents a congruence of the form (remainder, modulus).\n    Returns:\n    int: The smallest non-negative solution to the system of congruences, or None if no solution exists.\n    Examples:\n    >>> chinese_remainder_theorem([(2, 3), (3, 5), (2, 7)])\n    23\n    \"\"\"\n    x, m = 0, 1\n    for a_i, n_i in congruences:\n        try:\n            n1_inv = sp.mod_inverse(m, n_i)\n        except"], ["def gcd_lcm_calculator(a, b):\n    \"\"\"\n    Calculate the Greatest Common Divisor (GCD) and Least Common Multiple (LCM)\n    of two integers using Euclid's algorithm for GCD and the relation LCM * GCD = a * b.\n    Parameters:\n    - a (int): First integer\n    - b (int): Second integer\n    \n    Returns:\n    - tuple: (gcd, lcm) of the integers a and b\n    Examples:\n    >>> gcd_lcm_calculator(12, 15)\n    (3, 60)\n    >>> gcd_lcm_calculator(100, 80)\n    (20, 400)\n    \"\"\"\n    from math import gcd\n    \n    gcd_value = gcd(a, b)\n    lcm_value = abs(a * b) // gcd_value\n    \n    return gcd_value, lcm_value", "def gcd_lcm(*args):\n    \"\"\"\n    Calculate the Greatest Common Divisor (GCD) and Least Common Multiple (LCM) of given integers.\n    \n    Parameters:\n        args (int): A variable number of integer arguments for which GCD and LCM is to be calculated.\n    \n    Returns:\n        tuple: A tuple containing the GCD and LCM of the provided integers.\n    \n    Examples:\n        >>> gcd_lcm(12, 15)\n        (3, 60)\n        >>> gcd_lcm(5, 10, 15)\n        (5, 30)\n    \"\"\"\n    def _gcd(x, y):\n        while y != 0:\n            x, y = y, x % y\n        return abs(x)\n    \n    def _lcm(x, y):\n        return abs(x * y) // _gcd(x, y)\n    \n    gcd = args[0]\n    lcm = args[0]\n    for num in args[1:]:\n        gcd = _gcd(gcd, num)\n        lcm = _lcm(lcm, num)\n    \n    return (gcd, lcm)"], ["def is_palindrome(num):\n    \"\"\"\n    Checks if the given number is a palindrome.\n    Parameters:\n        num (int): The integer to check for palindrome properties.\n    Returns:\n        bool: True if num is a palindrome, False otherwise.\n    Examples:\n        >>> is_palindrome(12321)\n        True\n        >>> is_palindrome(12345)\n        False\n    \"\"\"\n    str_num = str(num)\n    return str_num == str_num[::-1]", "def is_palindrome(n):\n    \"\"\"\n    Check if the number n is a palindrome.\n    Parameters:\n        n (int): The integer to check.\n    Returns:\n        bool: True if n is a palindrome, False otherwise.\n    Examples:\n        >>> is_palindrome(121)\n        True\n        >>> is_palindrome(123)\n        False\n    \"\"\"\n    return str(n) == str(n)[::-1]"], ["def modular_exponentiation(base, exponent, modulus):\n    \"\"\"\n    Efficiently computes (base ** exponent) % modulus using modular exponentation.\n    Parameters:\n    - base (int): The base.\n    - exponent (int): The exponent.\n    - modulus (int): The modulus.\n    Returns:\n    - int: The result of (base ** exponent) % modulus.\n    \"\"\"\n    result = 1\n    base = base % modulus\n    while exponent > 0:\n        if (exponent % 2) == 1:\n            result = (result * base) % modulus\n        exponent = exponent >> 1\n        base = (base * base) % modulus\n    return result", "def mod_exponent(base, exponent, modulus):\n    \"\"\"\n    Computes (base^exponent) % modulus using efficient exponentiation.\n    Parameters:\n    base (int): Base of the exponentiation.\n    exponent (int): Exponent.\n    modulus (int): Modulus.\n    Returns:\n    int: Result of (base^exponent) % modulus.\n    Examples:\n    >>> mod_exponent(2, 10, 1000)\n    24\n    \"\"\"\n    return pow(base, exponent, modulus)"], ["def check_divisibility(n, div):\n    \"\"\"\n    Determines if n is divisible by div.\n    Parameters:\n    - n (int): The number to be checked.\n    - div (int): The divisor.\n    Returns:\n    - bool: True if n is divisible by div, False otherwise.\n    \"\"\"\n    return n % div == 0", "def check_divisibility(n, divisor):\n    \"\"\"\n    Check if the integer n is divisible by divisor.\n    Parameters:\n    - n : int\n        The number to be checked.\n    - divisor : int\n        The divisor to check against.\n    Returns:\n    - bool\n        True if n is divisible by divisor, False otherwise.\n    \n    Examples:\n    >>> check_divisibility(20, 4)\n    True\n    >>> check_divisibility(21, 4)\n    False\n    \"\"\"\n    return n % divisor == 0"], ["def count_perfect_squares(start, end):\n    \"\"\"Count the number of perfect squares in a given range [start, end].\n    \n    Parameters:\n    start (int): The start of the range (inclusive).\n    end (int): The end of the range (inclusive).\n    Returns:\n    int: The count of perfect squares in the range.\n    Examples:\n    >>> count_perfect_squares(1, 100)\n    10\n    \"\"\"\n    import math\n    return math.isqrt(end) - math.isqrt(start - 1)", "def find_perfect_squares(start, end):\n    \"\"\"Find all perfect squares in a given range [start, end].\n    \n    Parameters:\n    start (int): The start of the range (inclusive).\n    end (int): The end of the range (inclusive).\n    Returns:\n    list: A list of all perfect squares in the range.\n    \n    Examples:\n    >>> find_perfect_squares(1, 50)\n    [1, 4, 9, 16, 25, 36, 49]\n    \"\"\"\n    import math\n    first = math.ceil(math.sqrt(start))\n    last = math.floor(math.sqrt(end))\n    return [i * i for i in range(first, last + 1)]"], ["def arithmetic_sequence_sum(a, d, n):\n    \"\"\"\n    Calculate the sum of the first n terms of an arithmetic sequence.\n    Parameters:\n        a (int): The first term of the sequence.\n        d (int): The common difference between consecutive terms.\n        n (int): The number of terms.\n    Returns:\n        int: The sum of the first n terms of the sequence.\n    Examples:\n        >>> arithmetic_sequence_sum(1, 1, 5)\n        15\n    \"\"\"\n    return n * (2 * a + (n - 1) * d) // 2"], ["def solve_diophantine(a, b, c):\n    \"\"\"\n    Solve the linear Diophantine equation a*x + b*y = c for integers x and y.\n    Returns a single solution (x, y) if it exists.\n    Parameters:\n        a (int): Coefficient of x.\n        b (int): Coefficient of y.\n        c (int): Constant term.\n    Returns:\n        tuple: a tuple (x, y) representing a solution, if it exists.\n        None: if no integer solution exists.\n    Examples:\n        >>> solve_diophanine(3, -9, 12)\n        None\n        >>> solve_diophanine(2, 3, 5)\n        (1, 1)\n    \"\"\"\n    from math import gcd\n    if c % gcd(a, b) != 0:\n        return None\n    x, y = 0, c // b\n    while True:\n        if (c - b * y) % a == 0:\n            x = (c - b * y) // a\n            return (x, y)\n        y -= 1"], ["def gcd(a, b):\n    \"\"\"\n    Compute the greatest common divisor of two integers.\n    \n    Parameters:\n    - a (int): First integer.\n    - b (int): Second integer.\n    Returns:\n    int: The greatest common divisor of a and b.\n    \n    Examples:\n    >>> gcd(12, 15)\n    3\n    >>> gcd(3, 7)\n    1\n    \"\"\"\n    from math import gcd as compute_gcd\n    return compute_gcd(a, b)"], ["def absolute_value(n):\n    \"\"\"\n    Calculate the absolute value of an integer.\n    Parameters:\n    - n (int): The integer.\n    \n    Returns:\n    - int: The absolute value of n.\n    \n    Examples:\n    >>> absolute_value(-5)\n    5\n    >>> absolute_endcode_point(3)\n    3\n    \"\"\"\n    return abs(n)", "def absolute_value(n):\n    \"\"\"\n    Compute the absolute value of an integer.\n    Parameters:\n        n (int): The integer to compute the absolute value.\n    Returns:\n        int: The absolute value of n.\n    Examples:\n        >>> absolute_value(-5)\n        5\n        >>> absolute_value(10)\n        10\n    \"\"\"\n    return abs(n)"], ["def is_even(number):\n    \"\"\"\n    Determine if a number is even.\n    Parameters:\n    - number (int): The number to check.\n    Returns:\n    - bool: True if the number is even, otherwise False.\n    Examples:\n    >>> is_even(4)\n    True\n    >>> is_even(5)\n    False\n    \"\"\"\n    return number % 2 == 0", "def is_even(number):\n    \"\"\"\n    Check if the number is even.\n    Parameters:\n    number : int\n        The integer to check.\n    Returns:\n    bool\n        Returns True if the number is even, otherwise False.\n    Examples:\n    >>> is_even(4)\n    True\n    >>> is_even(5)\n    False\n    \"\"\"\n    return number % 2 == 0", "def is_even(number):\n    \"\"\"\n    Determine if a number is even.\n    Parameters:\n    - number (int): The integer to be checked.\n    Returns:\n    bool: True if the number is even, False otherwise.\n    \n    Examples:\n    >>> is_even(4)\n    True\n    >>> is_even(5)\n    False\n    \"\"\"\n    return number % 2 == 0"], ["def integer_close_to_sqrt(n):\n    \"\"\"\n    Finds the closest integer to the square root of n.\n    Parameters:\n    - n (int): The number to find the square root of.\n    Returns:\n    - int: The integer closest to the square root of n.\n    Examples:\n    >>> integer_close_to_sqrt(10)\n    3\n    >>> integer_close_to_sqrt(15)\n    4\n    \"\"\"\n    return round(math.sqrt(n))"], ["def calculate_lcm(numbers):\n    \"\"\"\n    Calculate least common multiple of a list of numbers.\n    Parameters:\n    - numbers : list of int\n        The list of integers for which to calculate the LCM.\n    \n    Returns:\n    - int\n        The least common multiple of the numbers.\n    \n    Examples:\n    >>> calculate_lcm([12, 15, 20])\n    60\n    \"\"\"\n    return int(np.lcm.reduce(numbers))"], ["def count_factors(n):\n    \"\"\"\n    Count the number of factors of an integer.\n    Parameters:\n    - n (int): The integer to count factors for.\n    \n    Returns:\n    - int: Number of factors of n.\n    \n    Examples:\n    >>> count_factors(12)\n    6\n    \"\"\"\n    if n <= 0:\n        raise ValueError(\"n must be a positive integer\")\n    factors = sympy.divisors(n)\n    return len(factors)"], ["def primes_in_range(start, end):\n    \"\"\"\n    Lists all primes within a given inclusive range.\n    \n    Parameters:\n        start (int): Start of the range.\n        end (int): End of the range.\n    \n    Returns:\n        list: List of primes within the given range.\n        \n    Example:\n        >>> primes_in_range(10, 20)\n        [11, 13, 17, 19]\n    \"\"\"\n    return list(sympl", "def list_primes_in_range(start, end):\n    \"\"\"\n    List all prime numbers within a specified range.\n    Parameters:\n    - start : int\n        The start of the range.\n    - end : int\n        The end of the range.\n    Returns:\n    - list of int\n        List containing all prime numbers between start and end.\n    \n    Examples:\n    >>> list_primes_in_range(10, 20)\n    [11, 13, 17, 19]\n    \"\"\"\n    return list(sp.primerange(start, end))"], ["def consecutive_primes(n):\n    \"\"\"\n    Generate a list of the first n prime numbers.\n    Parameters:\n        n (int): The number of primes to generate.\n    Returns:\n        list: A list of the first n primes.\n    Examples:\n        >>> consecutive_primes(5)\n        [2, 3, 5, 7, 11]\n    \"\"\"\n    return list(sympy.primerange(1, sympy.prime(n)+1))"], ["def product_of_integers(numbers):\n    \"\"\"\n    Compute the product of a sequence of integers.\n    Parameters:\n         numbers (list): A list of integers.\n    Returns:\n        int: The product of the integers in the list.\n    Examples:\n        >>> product_of_integers([1, 2, 3])\n        6\n    \"\"\"\n    product = 1\n    for num in numbers:\n        product *= num\n    return product"], ["def is_odd(number):\n    \"\"\"\n    Determine if a number is odd.\n    Parameters:\n    - number (int): The number to check.\n    Returns:\n    - bool: True if the number is odd, otherwise False.\n    Examples:\n    >>> is_odd(3)\n    True\n    >>> is_odd(10)\n    False\n    \"\"\"\n    return number % 2 != 0", "def is_odd(number):\n    \"\"\"\n    Check if the number is odd.\n    Parameters:\n    number : int\n        The integer to check.\n    Returns:\n    bool\n        Returns True if the number is odd, otherwise False.\n    Examples:\n    >>> is_odd(3)\n    True\n    >>> is_odd(4)\n    False\n    \"\"\"\n    return number % 2 != 0", "def is_odd(number):\n    \"\"\"\n    Determine if a number is odd.\n    Parameters:\n    - number (int): The integer to be checked.\n    Returns:\n    bool: True if the number is odd, False otherwise.\n    \n    Examples:\n    >>> is_odd(3)\n    True\n    >>> is_odd(4)\n    False\n    \"\"\"\n    return number % 2 != 0"], ["def solve_linear_congruence(a, b, m):\n    \"\"\"\n    Solves the linear congruence of the form a * x ≡ b (mod m).\n    Parameters:\n    - a (int): The coefficient of x in the congruence.\n    - b (int): The remainder in the congruence.\n    - m (int): The modulus.\n    Returns:\n    - tuple: Solution in the form of (x, m) where x is the smallest non-negative solution.\n    \"\"\"\n    return solve_congruence((a, b), (1, m))", "def solve_congruence(a, b, m):\n    \"\"\"\n    Solves the linear congruence equation: ax ≡ b (mod m).\n    Parameters:\n    a (int): Coefficient of x in the congruence.\n    b (int): The remainder term.\n    m (int): The modulus.\n    Returns:\n    tuple: A tuple (x, M) representing the solution in the form x % M, or None if no solution exists.\n    Examples:\n    >>> solve_congruence(2, 3, 5)\n    (4, 5)\n    \"\"\"\n    gcd, x, y = sp.igcdex(a, m)\n    if b % gcd == 0:\n        x0 = x * (b // gcd) % m\n        return (x0, m // gcd)\n    else:\n        return None"], ["def find_divisors(n):\n    \"\"\"\n    Find all divisors of a given integer n.\n    Parameters:\n    n (int): The integer to find divisors of.\n    Returns:\n    list of int: List of all divisors of n.\n    Example:\n    >>> find_divisors(28)\n    [1, 2, 4, 7, 14, 28]\n    \"\"\"\n    divisors = []\n    for i in range(1, int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            divisors.append(i)\n            if i != n // i:\n                divisors.append(n // i)\n    divisors.sort()\n    return divisors", "def calculate_divisors(n):\n    \"\"\"\n    Return all divisors of an integer n including 1 and n itself.\n    Parameters:\n        n (int): The integer to calculate divisors for.\n    Returns:\n        list: A list of all divisors of n.\n    Examples:\n    >>> calculate_divisors(28)\n    [1, 2, 4, 7, 14, 28]\n    \"\"\"\n    return divisors(n)", "def calculate_divisors(n):\n    \"\"\"\n    Calculate all divisors of a given integer, including 1 and the number itself.\n    \n    Parameters:\n    - n : int\n        Integer to find divisors for.\n    \n    Returns:\n    - list of int\n        List containing all divisors of n.\n    \n    Examples:\n    >>> calculate_divisors(28)\n    [1, 2, 4, 7, 14, 28]\n    \"\"\"\n    divisors = set()\n    for i in range(1, int(np.sqrt(n)) + 1):\n        if n % i == 0:\n            divisors.add(i)\n            divisors.add(n // i)\n    return sorted(divisors)", "def find_divisors(n):\n    \"\"\"\n    Find all divisors of the given integer n.\n    Parameters:\n        n (int): The integer to find divisors for.\n    Returns:\n        List[int]: A list of all divisors of n sorted in ascending order.\n    Examples:\n        >>> find_divisors(36)\n        [1, 2, 3, 4, 6, 9, 12, 18, 36]\n    \"\"\"\n    import math\n    divisors = set()\n    for i in range(1, int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            divisors.add(i)\n            divisors.add(n // i)\n    return sorted(list(divisors))"], ["def prime_factorization(number):\n    \"\"\"\n    Compute the prime factors of a given integer.\n    \n    Parameters:\n    - number: int, the number to be factorized.\n    \n    Returns:\n    - list of int, representing the prime factors of the given number.\n    \n    Example:\n    >>> prime_factorization(60)\n    [2, 3, 5]\n    \"\"\"\n    return primefactors(number)", "def prime_factors(number):\n    \"\"\"\n    Calculate the prime factors of a given integer.\n    \n    Parameters:\n        number (int): The integer to factorize.\n    \n    Returns:\n        list: List of prime factors of the given integer.\n    \n    Examples:\n        >>> prime_factors(18)\n        [2, 3]\n        >>> prime_factors(89)\n        [89]\n    \"\"\"\n    return primefactors(number)"], ["def is_divisible(n, k):\n    \"\"\"\n    Check if integer n is divisible by integer k.\n    Parameters:\n        n (int): The number to be divided.\n        k (int): The divisor.\n    Returns:\n        bool: True if n is divisible by k, False otherwise.\n    Examples:\n        >>> is_divisible(10, 5)\n        True\n        >>> is_divisible(10, 3)\n        False\n    \"\"\"\n    return n % k == 0"], ["def is_coprime(a, b):\n    \"\"\"\n    Checks if two numbers a and b are coprime (gcd is 1).\n    Parameters:\n    - a (int): First number.\n    - b (int): Second number.\n    Returns:\n    - bool: True if gcd(a, b) == 1, otherwise False.\n    Examples:\n    >>> is_coprime(14, 15)\n    True\n    >>> is_coprime(14, 21)\n    False\n    \"\"\"\n    return gcd(a, b) == 1", "def coprime(a, b):\n    \"\"\"\n    Determines if two numbers are coprime (relatively prime).\n    \n    Parameters:\n        a (int): First number.\n        b (int): Second number.\n        \n    Returns:\n        bool: True if a and b are coprime, False otherwise.\n    \n    Example:\n        >>> coprime(15, 28)\n        True\n        >>> coprime(12, 18)\n        False\n    \"\"\"\n    return math.gcd(a, b) == 1", "def are_coprime(a, b):\n    \"\"\"\n    Determine if two numbers are coprime (relatively prime).\n    Parameters:\n    - a (int): The first integer.\n    - b (int): The second integer.\n    \n    Returns:\n    - bool: True if a and b are coprime, False otherwise.\n    \n    Examples:\n    >>> are_coprime(8, 15)\n    True\n    >>> are_coprime(12, 18)\n    False\n    \"\"\"\n    return sympy.gcd(a, b) == 1", "def are_coprime(a, b):\n    \"\"\"\n    Determine if two numbers are coprime (i.e., their greatest common divisor is 1).\n    Parameters:\n        a (int): The first integer.\n        b (int): The second integer.\n    Returns:\n        bool: True if a and b are coprime, False otherwise.\n    Examples:\n        >>> are_coprime(15, 28)\n        True\n        >>> are_coprime(12, 18)\n        False\n    \"\"\"\n    return sympy.gcd(a, b) == 1"], ["def sum_of_integers(numbers):\n    \"\"\"\n    Sum a sequence of integers.\n    Parameters:\n        numbers (list): A list of integers.\n    Returns:\n        int: The sum of the integers in the list.\n    Examples:\n        >>> sum_of_integers([1, 2, 3, 4])\n        10\n    \"\"\"\n    return sum(numbers)"], ["def lcm(x, y):\n    \"\"\"\n    Compute the least common multiple (LCM) of two numbers based on their GCD.\n    \n    Parameters:\n    - x: int, the first number.\n    - y: int, the second number.\n    \n    Returns:\n    - int, the LCM of the two numbers.\n    \n    Example:\n    >>> lcm(4, 5)\n    20\n    \"\"\"\n    return abs(x*y) // gcd(x, y)"], ["def count_fourth_powers(a, b):\n    \"\"\"\n    Count the number of fourth powers in the range [a, b].\n    x is considered a fourth power if x = n^4 for some integer n.\n    \n    Parameters:\n        a (int): Start of the range.\n        b (int): End of the range.\n        \n    Returns:\n        int: Count of fourth powers in the given range.\n        \n    Examples:\n        >>> count_fourth_powers(1, 1000)\n        3\n        >>> count_fourth_powers(1, 10000)\n        4\n    \"\"\"\n    # Finding the floor of the fourth root of `a` and `b`.\n    low_n = int(math.pow(a, 0.25))\n    high_n = int(math.pow(b, 1/4))\n    \n    count = 0\n    for n in range(low_n, high_n + 1):\n        if n**4 >= a and n**4 <= b:\n            count += 1\n    return count"], ["def list_perfect_squares(limit):\n    \"\"\"\n    Lists all perfect squares up to a given limit.\n    :param limit: The upper limit (inclusive) for listing perfect squares.\n    :return: A list of all perfect squares up to 'limit'.\n    \n    Examples:\n    >>> list_perfect_squares(30)\n    [0, 1, 4, 9, 16, 25]\n    \"\"\"\n    return [i * i for i in range(int(math.sqrt(limit)) + 1)]"], ["def filter_divisible_numbers(start, end, divisor):\n    \"\"\"\n    Generates a list of numbers within the specified range that are divisible by the given divisor.\n    Parameters:\n    start : int\n        The starting value of the range (inclusive).\n    end : int\n        The ending value of the range (inclusive).\n    divisor : int\n        The divisor used for filtering numbers.\n    Returns:\n    list of int\n        List of integers within the specified range that are divisible by the divisor.\n    Examples:\n    >>> filter_divisible_numbers(1, 10, 2)\n    [2, 4, 6, 8, 10]\n    >>> filter_divisible_numbers(1, 10, 3)\n    [3, 6, 9]\n    \"\"\"\n    return [x for x in range(start, end + 1) if x % divisor == 0]"], ["def divisors_parity(n):\n    \"\"\"\n    Checks the parity of the divisor count of an integer n.\n    :param n: The integer to check the divisor count's parity.\n    :return: True if the count is odd (meaning n is a perfect square), else False.\n    \n    Examples:\n    >>> divisors_parity(36)\n    True\n    >>> divisors_parity(37)\n    False\n    \"\"\"\n    return is_perfect_square(n)"], ["def extended_euclidean_algorithm(a, b):\n    \"\"\"\n    Applies the Extended Euclidean Algorithm to find integers x, y such that ax + by = gcd(a, b).\n    Parameters:\n    - a (int): First integer\n    - b (int): Second integer\n    \n    Returns:\n    - tuple: gcd of a and b, and coefficients x, y such that ax + by = gcd(a, b)\n    Examples:\n    >>> extended_euclidean_algorithm(10, 6)\n    (2, 1, -1)\n    >>> extended_euclidean_algorithm(113, 57)\n    (1, 5, -10)\n    \"\"\"\n    if a == 0:\n        return (b, 0, 1)\n    else:\n        gcd, x1, y1 = extended_euclidean_algorithm(b % a, a)\n        x = y1 - (b // a) * x1\n        y = x1\n        return (gcd, x, y)"], ["def next_prime(n):\n    \"\"\"\n    Find the smallest prime number greater than n.\n    Parameters:\n    n (int): Starting number to find the next prime.\n    Returns:\n    int: The next prime number after n.\n    Example:\n    >>> next_prime(28)\n    29\n    \"\"\"\n    test_num = n + 1\n    while True:\n        if is_prime(test_num):\n            return test_num\n        test_num += 1"], ["def classify_integer(n):\n    \"\"\"\n    Classifies an integer as positive, negative, or zero.\n    Parameters:\n    - n (int): The integer to classify.\n    \n    Returns:\n    - str: \"positive\", \"negative\", or \"zero\" based on the value of n.\n    \n    Examples:\n    >>> classify_integer(10)\n    'positive'\n    >>> classify_integer(-5)\n    'negative'\n    >>> classify_integer(0)\n    'zero'\n    \"\"\"\n    if n > 0:\n        return \"positive\"\n    elif n < 0:\n        return \"negative\"\n    else:\n        return \"zero\""], ["def is_relatively_prime(x, y):\n    \"\"\"\n    Check if two numbers are relatively prime.\n    \n    Parameters:\n    - x: int, the first number.\n    - y: int, the second number.\n    \n    Returns:\n    - bool, True if x and y are relatively prime, False otherwise.\n    \n    Example:\n    >>> is_relatively_prime(35, 18)\n    True\n    \"\"\"\n    return gcd(x, y) == 1"], ["def check_non_zero_divisor(divisor):\n    \"\"\"\n    Ensures that the divisor is not zero before performing division.\n    Parameters:\n        divisor (int): The number to check as a divisor.\n        \n    Returns:\n        bool: True if divisor is not zero, raising an error if zero.\n        \n    Example:\n        >>> check_non_zero_divisor(10)\n        True\n        >>> check_non_zero_divisor(0)\n        Traceback (most recent call last):\n        ...\n        ValueError: Divisor cannot be zero\n    \"\"\"\n    if divisor == 0:\n        raise ValueError(\"Divisor cannot be zero\")\n    return True"], ["def get_digit(n, position):\n    \"\"\"\n    Get the digit at a specific position from right in an integer.\n    \n    Parameters:\n        n (int): The integer from which to get the digit.\n        position (int): The position from the right (1-based index).\n    \n    Returns:\n        int: The digit at the specified position.\n    \n    Example:\n        >>> get_digit(12345, 2)\n        4\n    \"\"\"\n    return int(str(abs(n))[-position]) if position <= count_digits(n) else 0"], ["def integer_digit_manipulation():\n    \"\"\"\n    A collection of utility functions for manipulating and analyzing digits of integers.\n    Includes functions like reversing digits, extracting specific digits, summing digits, \n    and checking if a number is a palindrome.\n    \"\"\"\n    import numpy as np\n    from sympy import isprime\n    def reverse_digits(n):\n        \"\"\"\n        Reverses the digits of an integer.\n        \n        Parameters\n        ----------\n        n : int\n            The integer whose digits are to be reversed.\n        \n        Returns\n        -------\n        int\n            The integer after reversing its digits.\n        \n        Examples\n        --------\n        >>> reverse_digits(1234)\n        4321\n        \"\"\"\n        return int(str(n)[::-1])\n    def sum_digits(n):\n        \"\"\"\n        Sums the digits of an integer.\n        \n        Parameters\n        ----------\n        n : int\n            The integer whose digits are to be summed.\n        \n        Returns\n        -------\n        int\n            The sum of the digits of the input integer.\n        \n        Examples\n        --------\n        >>> sum_digits(1234)\n        10\n        \"\"\"\n        return sum(map(int, str(n)))\n    \n    def is_palindrome(n):\n        \"\"\"\n        Checks if an integer is a palindrome.\n        \n        Parameters\n        ----------\n        n : int\n            The integer to check.\n        \n        Returns\n        -------\n        bool\n            True if the integer is a palindrome, False otherwise.\n        \n        Examples\n        --------\n        >>> is_palindrome(12321)\n        True\n        \"\"\"\n        s = str(n)\n        return s == s[::-1]\n    def get_digit(n, position):\n        \"\"\"\n        Gets a specific digit from an integer.\n        \n        Parameters\n        ----------\n        n : int\n            The integer from which the digit is to be extracted.\n        position : int\n            The position of the digit to extract (0-based, from right).\n        \n        Returns\n        -------\n        int\n            The digit at the specified position.\n        \n        Examples\n        --------\n        >>> get_digit(1234, 1)\n        3\n        \"\"\"\n        return int(str(n)[::-1][position])\n    \n    def count_digits(n):\n        \"\"\"\n        Counts the total number of digits in an integer.\n        \n        Parameters\n        ----------\n        n : int\n            The integer to check.\n        \n        Returns\n        -------\n        int\n            The number of digits in the integer.\n        \n        Examples\n        --------\n        >>> count_digits(1234)\n        4\n        \"\"\"\n        return len(str(n))\n    \n    def is_prime(n):\n        \"\"\"\n        Checks if an integer is a prime number.\n        \n        Parameters\n        ----------\n        n : int\n            The integer to check.\n        \n        Returns\n        -------\n        bool\n            True if the integer is a prime number, False otherwise.\n        \n        Examples\n        --------\n        >>> is_prime(7)\n        True\n        \"\"\"\n        return isprime(n)\n    \n    digit_utils = {\n        'reverse_digits': reverse_digits,\n        'sum_digits': sum_digits,\n        'is_palindrome': is_palindrome,\n        'get_digit': get_digit,\n        'count_digits': count_digits,\n        'is_prime': is_prime\n    }\n    return digit_utils"], ["def check_congruence(a, b, m):\n    \"\"\"\n    Checks if two numbers are congruent modulo another number.\n    :param a: The first integer.\n    :param b: The second integer.\n    :param m: The modulus.\n    :return: True if a ≡ b (mod m), False otherwise.\n    \n    Examples:\n    >>> check_congruence(37, 57, 10)\n    True\n    >>> check_congruence(35, 57, 10)\n    False\n    \"\"\"\n    return (a - b) % m == 0"], ["def is_composite(n):\n    \"\"\"\n    Determines if the given number is composite.\n    \n    Parameters:\n        n (int): The number to check.\n        \n    Returns:\n        bool: True if n is composite, False otherwise.\n        \n    Example:\n        >>> is_composite(15)\n        True\n        >>> is_composite(11)\n        False\n    \"\"\"\n    if n <= 1:\n        return False\n    return not is_prime(n)"], ["def is_whole_number(n):\n    \"\"\"\n    Check if a number is a whole number (non-negative integer).\n    Parameters:\n    - n (int/float): The number to check.\n    \n    Returns:\n    - bool: True if n is a whole number, False otherwise.\n    \n    Examples:\n    >>> is_whole_number(5)\n    True\n    >>> is_whole_number(-1)\n    False\n    >>> is_whole_number(3.5)\n    False\n    \"\"\"\n    return n == int(n) and n >= 0"], ["def extract_digits(num):\n    \"\"\"\n    Extracts and returns the digits of the given integer as a list.\n    Parameters:\n        num (int): The integer from which to extract the digits.\n    Returns:\n        list: Digits of the integer.\n    Examples:\n        >>> extract_digits(1234)\n        [1, 2, 3, 4]\n        >>> extract_digits(9075)\n        [9, 0, 7, 5]\n    \"\"\"\n    from math import floor, log10\n    if num == 0:\n        return [0]\n    digits = []\n    while num:\n        digits.append(num % 10)\n        num = num // 10\n    return digits[::-1]"], ["def is_divisible_by(n, d):\n    \"\"\"\n    Determine if integer n is divisible by d.\n    Parameters:\n    n (int): Numerator integer.\n    d (int): Denominator integer (must not be zero).\n    Returns:\n    bool: True if n is divisible by d, False otherwise.\n    Example:\n    >>> is_divisible_by(10, 2)\n    True\n    \"\"\"\n    if d == 0:\n        raise ValueError(\"Denominator must not be zero.\")\n    return n % d == 0"], ["def calculate_power(base, exponent):\n    \"\"\"\n    Compute the power of a base raised to an exponent.\n    Parameters:\n        base (float or int): The base number.\n        exponent (int): The power to raise the base to.\n    Returns:\n        float: The result of the exponentiation.\n    \n    Examples:\n    >>> calculate_power(2, 10)\n    1024\n    \"\"\"\n    return base ** exponent"], ["def count_filtered_integers(start, end, properties):\n    \"\"\"\n    Count integers in a given range based on specified properties such as evenness, oddness, and divisibility.\n    Parameters:\n    start : int\n        Start of range (inclusive).\n    end : int\n        End of range (inclusive).\n    properties : dict\n        A dictionary of properties to check, e.g., {'even': True, 'divisible_by': 3}\n    Returns:\n    int\n        Count of integers that meet all specified properties.\n    Examples:\n    >>> count_filtered_integers(1, 10, {'even': True})\n    5\n    >>> count_filtered_integers(1, 10, {'divisible_by': 5})\n    2\n    \"\"\"\n    count = 0\n    for num in range(start, end + 1):\n        if all([\n            ('even' in properties and properties['even'] == is_even(num)),\n            ('divisible_by' in properties and num % properties['divisible_by'] == 0)\n        ]):\n            count += 1\n    return count"], ["def units_digit(number):\n    \"\"\"\n    Return the units digit of a number.\n    Parameters:\n    - number (int): The number to get the units digit from.\n    Returns:\n    - int: The units digit of the number.\n    Examples:\n    >>> units_digit(123)\n    3\n    >>> units_digit(-476)\n    6\n    \"\"\"\n    return abs(number) % 10"], ["def reverse_digits(n):\n    \"\"\"\n    Reverse the digits of an integer.\n    \n    Parameters:\n        n (int): The integer to be reversed.\n    \n    Returns:\n        int: The integer formed by reversing the digits of `n`.\n    \n    Example:\n        >>> reverse_digits(123)\n        321\n    \"\"\"\n    return int(str(n)[::-1]) if n >= 0 else -int(str(-n)[::-1])"], ["def arithmetic_modulo_n(a, b, mod, operation='add'):\n    \"\"\"\n    Perform arithmetic operations on two integers modulo `n`.\n    Parameters:\n    a : int\n        The first operand.\n    b : int\n        The second operand.\n    mod : int\n        The modulo value.\n    operation : str\n        The operation to perform ('add', 'subtract', 'multiply').\n    Returns:\n    int\n        The result of the operation performed modulo `n`.\n    Examples:\n    >>> arithmetic_modulo_n(3, 5, 6, 'add')\n    2\n    >>> arithmetic_modulo_n(4, 3, 5, 'multiply')\n    2\n    \"\"\"\n    operations = {\n        'add': (a + b) % mod,\n        'subtract': (a - b) % mod,\n        'multiply': (a * b) % mod\n    }\n    return operations.get(operation, None)"], ["def divisibility_by_digit_sum(num, divisor):\n    \"\"\"\n    Checks if the sum of the digits of num is divisible by the given divisor.\n    Parameters:\n        num (int): The number to check.\n        divisor (int): The divisor to test against the digit sum.\n    Returns:\n        bool: True if the sum of the digits of num is divisible by divisor, else False.\n    Examples:\n        >>> divisibility_by_digit_sum(123, 3)\n        True\n        >>> divisibility_by_digit_sum(124, 3)\n        False\n    \"\"\"\n    digit_sum = sum(extract_digits(num))\n    return digit_sum % divisor == 0"], ["def integer_base_conversion_and_divisibility():\n    \"\"\"\n    A collection of utility functions for base conversion and checking divisibility rules.\n    Includes functions for converting numbers between different bases, checking divisibility,\n    and analyzing repeating decimals.\n    \"\"\"\n    from sympy import isprime\n    import math\n    def convert_base(n, from_base, to_base):\n        \"\"\"\n        Converts a number from one base to another.\n        \n        Parameters\n        ----------\n        n : int or str\n            The number to convert. If not in base 10, provide as string.\n        from_base : int\n            The base of the input number.\n        to_base : int\n            The base to convert to.\n        \n        Returns\n        -------\n        str\n            The number in the target base as a string.\n        \n        Examples\n        --------\n        >>> convert_base('1010', 2, 10)\n        '10'\n        >>> convert_base('A', 16, 2)\n        '1010'\n        \"\"\"\n        if from_base != 10:\n            n = int(n, from_base)\n        if to_base == 10:\n            return str(n)\n        else:\n            digits = \"0123456789ABCDEF\"\n            result = \"\"\n            while n > 0:\n                result = digits[n % to_base] + result\n                n //= to_base\n            return result or \"0\"\n    def is_divisible(n, divisor):\n        \"\"\"\n        Checks if a number is divisible by another number.\n        \n        Parameters\n        ----------\n        n : int\n            The number to check.\n        divisor : int\n            The divisor to check against.\n        \n        Returns\n        -------\n        bool\n            True if n is divisible by divisor, False otherwise.\n        \n        Examples\n        --------\n        >>> is_divisible(10, 2)\n        True\n        >>> is_divisible(10, 3)\n        False\n        \"\"\"\n        return n % divisor == 0\n    \n    def repeating_decimal_period(n):\n        \"\"\"\n        Calculates the period of the repeating decimal for 1/n.\n        \n        Parameters\n        ----------\n        n : int\n            The integer to calculate the repeating decimal period for.\n        \n        Returns\n        -------\n        int\n            The period of the repeating decimal.\n        \n        Examples\n        --------\n        >>> repeating_decimal_period(3)\n        1\n        >>> repeating_decimal_period(7)\n        6\n        \"\"\"\n        remainders = {}\n        remainder = 1\n        position = 0\n        while remainder and remainder not in remainders:\n            remainders[remainder] = position\n            remainder = (remainder * 10) % n\n            position += 1\n        return 0 if not remainder else position - remainders[remainder]\n    base_utils = {\n        'convert_base': convert_base,\n        'is_divisible': is_divisible,\n        'repeating_decimal_period': repeating_decimal_period\n    }\n    return base_utils"], ["def count_perfect_squares(a, b):\n    \"\"\"\n    Count the number of perfect squares within the range [a, b].\n    \n    Parameters:\n        a (int): The lower bound of the range (inclusive).\n        b (int): The upper bound of the range (inclusive).\n        \n    Returns:\n        int: The count of perfect squares within the range.\n        \n    Examples:\n        >>> count_perfect_squares(1, 25)\n        5\n        >>> count_perfect_squares(1, 100)\n        10\n    \"\"\"\n    if b < a or a < 0:\n        return 0\n    return int(math.sqrt(b)) - int(math.sqrt(a - 1))"], ["def basic_modular_operations(a, b, m, operation):\n    \"\"\"\n    Performs basic modular arithmetic operations between two numbers.\n    Parameters:\n    - a (int): The first number.\n    - b (int): The second number.\n    - m (int): The modulus.\n    - operation (str): The operation to perform ('add', 'subtract', 'multiply').\n    Returns:\n    - int: The result of the operation under modulo m.\n    \"\"\"\n    if operation == 'add':\n        return (a + b) % m\n    elif operation == 'subtract':\n        return (a - b) % m\n    elif operation == 'multiply':\n        return (a * b) % m\n    else:\n        raise ValueError(\"Unsupported operation\")"], ["def gcd(x, y):\n    \"\"\"\n    Compute the greatest common divisor (GCD) of two numbers using the Euclidean algorithm.\n    \n    Parameters:\n    - x: int, the first number.\n    - y: int, the second number.\n    \n    Returns:\n    - int, the GCD of x and y.\n    \n    Example:\n    >>> gcd(48, 18)\n    6\n    \"\"\"\n    while y:\n        x, y = y, x % y\n    return x"], ["def euler_totient(n):\n    \"\"\"\n    Computes the Euler's totient function of n, defined as the number of integers up to n that are coprime with n.\n    Parameters:\n    - n (int): The number to compute totient for.\n    Returns:\n    - int: Euler's totient of n.\n    Examples:\n    >>> euler_totient(9)\n    6\n    >>> euler_totient(10)\n    4\n    \"\"\"\n    return totient(n)"], ["def count_even_odd_in_range(start, end):\n    \"\"\"\n    Count even and odd numbers within a given range [start, end).\n    Parameters:\n    - start (int): The starting integer value of the range (inclusive).\n    - end (int): The ending integer value of the range (exclusive).\n    Returns:\n    tuple: A tuple (count_even, count_odd) representing the number of even and odd numbers respectively.\n    \n    Examples:\n    >>> count_even_odd_in_range(1, 10)\n    (4, 5)\n    \"\"\"\n    count_even = len([num for num in range(start, end) if num % 2 == 0])\n    count_odd = (end - start) - count_even\n    return (count_even, count_odd)"], ["def is_integer_solution_discriminant(a, b, c):\n    \"\"\"\n    Checks if the quadratic equation ax^2 + bx + c = 0 has integer solutions by examining its discriminant.\n    Parameters:\n        a (int): Coefficient of x^2.\n        b (int): Coefficient of x.\n        c (int): Constant term.\n        \n    Returns:\n        bool: True if the equation has integer solutions, otherwise False.\n        \n    Examples:\n        >>> is_integer_solution_discriminant(1, -3, 2)  # x^2 - 3x + 2 = 0 with roots (1, 2)\n        True\n        >>> is_integer_solution_discriminant(1, 1, 1)  # x^2 + x + 1 = 0 with no real roots\n        False\n    \"\"\"\n    discriminant = b * b - 4 * a * c\n    return is_perfect_square(discriminant)"], ["def extended_gcd(a, b):\n    \"\"\"\n    Compute the extended greatest common divisor of a and b, and return the coefficients of Bezout's identity.\n    \n    Parameters:\n        a (int): First number.\n        b (int): Second number.\n    Returns:\n        (gcd, x, y) (tuple): gcd is the greatest common divisor of a and b.\n                             x and y are the coefficients of Bezout's identity, i.e., ax + by = gcd\n    Examples:\n        >>> extended_gcd(12, 15)\n        (3, -1, 1)\n    \"\"\"\n    if a == 0:\n        return (b, 0, 1)\n    else:\n        gcd, x1, y1 = extended_gcd(b % a, a)\n        x = y1 - (b // a) * x1\n        y = x1\n        return (gcd, x, y)"], ["def modulus_divisibility(num, base, mod):\n    \"\"\"\n    Checks divisibility of the number num with respect to a base after applying modulus operation.\n    Parameters:\n        num (int): The number to check.\n        base (int): The base for modulus operation.\n        mod (int): The modulus divisor.\n    Returns:\n        bool: True if the number's modulus in the given base is divisible by mod, else False.\n    Examples:\n        >>> modulus_divisibility(20, 10, 2)\n        True\n        >>> modulus_divisibility(21, 10, 2)\n        False\n    \"\"\"\n    return (num % base) % mod == 0"], ["def digit_sum(n):\n    \"\"\"\n    Calculate the sum of the digits of an integer.\n    \n    Parameters:\n        n (int): The integer whose digits will be summed.\n    \n    Returns:\n        int: The sum of the digits of `n`.\n    \n    Example:\n        >>> digit_sum(123)\n        6\n    \"\"\"\n    return sum(int(digit) for digit in str(abs(n)))"], ["def modular_inverse(a, mod):\n    \"\"\"\n    Find the modular inverse of a under modulo mod using the extended Euclidean algorithm.\n    \n    Parameters:\n        a (int): The integer to find the inverse for.\n        mod (int): The modulus.\n    Returns:\n        int or None: Modular inverse of a modulo mod if exists. Returns None if no inverse exists.\n    Examples:\n        >>> modular_inverse(3, 11)\n        4\n    \"\"\"\n    gcd, x, _ = extended_gcd(a, mod)\n    if gcd == 1:\n        return x % mod\n    return None"], ["def expand_polynomial(expression):\n    \"\"\"\n    Take a polynomial expression and expand it.\n    Parameters:\n        expression (str): The polynomial expression in string form, where the variable is x.\n    Returns:\n        str: The expanded polynomial expression.\n    \n    Examples:\n    >>> expand_polynomial(\"(x-1)(x+1)\")\n    'x**2 - 1'\n    \"\"\"\n    x = symbols('x')\n    return str(expand(expression))"], ["def count_digits(n):\n    \"\"\"\n    Count the number of digits in an integer.\n    \n    Parameters:\n        n (int): The integer to count digits.\n    \n    Returns:\n        int: The number of digits in `n`.\n    \n    Example:\n        >>> count_digits(12345)\n        5\n    \"\"\"\n    return len(str(abs(n)))"], ["def is_perfect_power(n, power):\n    \"\"\"\n    Checks if a number is a perfect power of another integer.\n    Parameters:\n    - n (int): The number to check.\n    - power (int): The power to test.\n    Returns:\n    bool: True if n is a perfect power of 'power', else False.\n    Example:\n    >>> is_perfect_power(64, 2)\n    True\n    >>> is_perfect_power(65, 2)\n    False\n    \"\"\"\n    import sympy\n    root, perfect = sympy.ntheory.primetest.integer_nthroot(n, power)\n    return perfect"], ["def list_primes(a, b):\n    \"\"\"\n    Lists all primes in the range [a, b)\n    Parameters:\n    - a (int): Start of the range (inclusive).\n    - b (int): End of the range (exclusive).\n    Returns:\n    - list: List of prime numbers between a and b.\n    Examples:\n    >>> list_primes(10, 20)\n    [11, 13, 17, 19]\n    \"\"\"\n    return list(primerange(a, b))"]], "Floor and Ceiling Functions": [["def floor_function(value):\n    \"\"\"\n    Calculate the floor of a number, defined as the greatest integer less than or equal to the input value.\n    Parameters:\n    - value (float or int): The number for which the floor will be calculated.\n    Returns:\n    int: The floor value of the input number.\n    Examples:\n    >>> floor_function(3.7)\n    3\n    >>> floor_function(-1.2)\n    -2\n    \"\"\"\n    return math.floor(value)", "def floor_value(x):\n    \"\"\"\n    Computes the floor of a given number.\n    Parameters:\n        x (float or int): The number from which the floor will be calculated.\n    Returns:\n        int: The floor value of x.\n    Examples:\n        >>> floor_value(3.7)\n        3\n        >>> floor_value(-1.2)\n        -2\n    \"\"\"\n    return math.floor(x)", "def floor_value(number):\n    \"\"\"\n    Calculate the floor value of a number, which is the greatest integer less than or equal to the number.\n    Parameters:\n    number (float): The real number from which the floor value is to be calculated.\n    Returns:\n    int: The floor value of the provided number.\n    Examples:\n    >>> floor_value(3.7)\n    3\n    >>> floor_value(-2.1)\n    -3\n    >>> floor_value(0)\n    0\n    This can be used directly within expressions or computations involving basic arithmetic operations.\n    \"\"\"\n    return math.floor(number)"], ["def calculate_ceiling(number):\n    \"\"\"\n    This function calculates and returns the ceiling value of a given number.\n    \n    Parameters:\n    -----------\n    number : float\n        The number for which the ceiling value is to be calculated.\n        \n    Returns:\n    --------\n    float :\n        The ceiling value of the given number.\n        \n    Examples:\n    ---------\n    >>> calculate_ceiling(4.2)\n    5\n    >>> calculate_ceiling(-3.9)\n    -3\n    \"\"\"\n    \n    return math.ceil(number)"], ["def ceiling_function(value):\n    \"\"\"\n    Calculate the ceiling of a number, defined as the smallest integer greater than or equal to the input value.\n    Parameters:\n    - value (float or int): The number for which the ceiling will be calculated.\n    Returns:\n    int: The ceiling value of the input number.\n    Examples:\n    >>> ceiling_function(3.1)\n    4\n    >>> ceiling_function(-1.9)\n    -1\n    \"\"\"\n    return math.ceil(value)", "def ceiling_value(x):\n    \"\"\"\n    Computes the ceiling of a given number.\n    Parameters:\n        x (float or int): The number from which the ceiling will be calculated.\n    Returns:\n        int: The ceiling value of x.\n    Examples:\n        >>> ceiling_value(3.7)\n        4\n        >>> ceiling_value(-1.2)\n        -1\n    \"\"\"\n    return math.ceil(x)", "def ceiling_value(number):\n    \"\"\"\n    Calculate the ceiling value of a number, which is the smallest integer greater than or equal to the number.\n    \n    Parameters:\n    number (float): The real number from which the ceiling value is to be calculated.\n    \n    Returns:\n    int: The ceiling value of the provided number.\n    Examples:\n    >>> ceiling_value(3.2)\n    4\n    >>> ceiling_value(-2.7)\n    -2\n    >>> ceiling_value(0)\n    0\n    This function can be used in various numerical contexts, especially when dealing with fractions or rounding off.\n    \"\"\"\n    return math.ceil(number)"], ["def calculate_floor(number):\n    \"\"\"\n    This function calculates and returns the floor value of a given number.\n    \n    Parameters:\n    -----------\n    number : float\n        The number for which the floor value is to be calculated.\n        \n    Returns:\n    --------\n    float :\n        The floor value of the given number.\n        \n    Examples:\n    ---------\n    >>> calculate_floor(4.2)\n    4\n    >>> calculate_floor(-3.9)\n    -4\n    \"\"\"\n    \n    return math.floor(number)"], ["def decompose_number(x):\n    \"\"\"\n    Decomposes a number into its integer and fractional parts using the floor function.\n    Parameters:\n        x (float): The number to decompose.\n    Returns:\n        tuple: A tuple containing the integer part and the fractional part.\n               The integer part is obtained using the floor function.\n    Examples:\n        >>> decompose_number(4.5)\n        (4, 0.5)\n        >>> decompose_number(-1.7)\n        (-2, 0.3)  # Note that -1.7 = -2 + 0.3\n    \"\"\"\n    integer_part = floor_value(x)\n    fractional_part = x - integer_part\n    return integer_part, fractional_part"], ["def calculate_fractional_part(number):\n    \"\"\"\n    This function calculates and returns the fractional part of a given number.\n    \n    Parameters:\n    -----------\n    number : float\n        The number for which the fractional part is to be calculated.\n        \n    Returns:\n    --------\n    float :\n        The fractional part of the given number.\n        \n    Examples:\n    ---------\n    >>> calculate_fractional_part(4.2)\n    0.2\n    >>> calculate_fractional_part(-3.9)\n    0.1\n    \"\"\"\n    \n    return number - math.floor(number)"], ["def floor_ceil(value):\n    \"\"\"\n    Calculate the floor and ceiling of a given numerical value.\n    Parameters:\n    - value (float): The real number from which the floor and ceiling values are to be computed.\n    Returns:\n    - tuple: A tuple containing the floor value and the ceiling value respectively.\n    Examples:\n    >>> floor_ceil(3.7)\n    (3, 4)\n    >>> floor_ceil(-2.5)\n    (-3, -2)\n    \"\"\"\n    from math import floor, ceil\n    return (floor(value), ceil(value))", "def calculate_floor_ceiling(x):\n    \"\"\"\n    Calculate the floor and ceiling of a given number.\n    Parameters:\n    - x (float): The number for which to calculate the floor and ceiling values.\n    Returns:\n    - tuple: A tuple containing the floor and ceiling values respectively.\n    Examples:\n    >>> calculate_floor_ceiling(3.7)\n    (3, 4)\n    >>> calculate_floor_ceiling(-2.3)\n    (-3, -2)\n    \"\"\"\n    floor_value = math.floor(x)\n    ceiling_value = math.ceil(x)\n    return (floor_value, ceiling_value)"], ["def arithmetic_with_floor_ceil(a, b, operation):\n    \"\"\"\n    Perform arithmetic operations using floor and ceiling values of the provided numbers.\n    \n    Parameters:\n    - a (float): The first real number.\n    - b (float): The second real number.\n    - operation (str): The arithmetic operation to perform. Supported operations are 'add', 'subtract', 'multiply'.\n    Returns:\n    - int: The result of the arithmetic operation applied using the floor/ceil values of the given numbers.\n    Examples:\n    >>> arithmetic_with_floor_ceil(3.2, 5.8, 'add')\n    (floor(3.2) + ceil(5.8)) = 3 + 6 = 9\n    >>> arithmetic_with_floor_ceil(-2.5, 4.1, 'multiply')\n    (ceil(-2.5) * floor(4.1)) = -2 * 4 = -8\n    \"\"\"\n    from math import floor, ceil\n    methods = {\n        'add': lambda x, y: floor(x) + ceil(y),\n        'subtract': lambda x, y: ceil(x) - floor(y),\n        'multiply': lambda x, y: ceil(x) * floor(y)\n    }\n    if operation in methods:\n        return methods[operation](a, b)\n    else:\n        raise ValueError(\"Unsupported operation. Use 'add', 'subtract', or 'multiply'.\")"], ["def floor_ceiling_expression_evaluator(expression):\n    \"\"\"\n    Evaluate an expression involving floor or ceiling functions.\n    Parameters:\n    - expression (str): The string of the expression involving floor and ceiling operations.\n    Returns:\n    - float: The result of the evaluated expression.\n    Examples:\n    >>> floor_ceiling_expression_evaluator(\"math.floor(3.7) + math.ceil(-2.3)\")\n    1\n    >>> floor_ceiling_expression_evaluator(\"math.floor(math.sqrt(10)) * 2\")\n    6\n    \"\"\"\n    allowed_builtins = {\"math\": math}\n    result = eval(expression, {\"__builtins__\": None}, allowed_builtins)\n    return result"]], "Integer Properties": [["def sum_of_digits(n):\n    \"\"\"\n    Calculate the sum of digits of a given integer.\n    Parameters:\n        n (int): The integer to calculate the sum of digits.\n    Returns:\n        int: Sum of the digits of n.\n    \"\"\"\n    return sum(int(digit) for digit in str(abs(n)))", "def sum_of_digits(n):\n    \"\"\"\n    Return the sum of digits of the integer `n`.\n    \n    Parameters:\n        n (int): The integer whose digits sum is calculated.\n    Returns:\n        int: The sum of the digits of `n`.\n    \n    Examples:\n        >>> sum_of_digits(123)\n        6\n        >>> sum_of_digits(409)\n        13\n    \"\"\"\n    return sum(int(digit) for digit in str(n))", "def product_of_digits(n):\n    \"\"\"\n    Return the product of digits of the integer `n`.\n    Parameters:\n        n (int): The integer whose digits product is calculated.\n    Returns:\n        int: The product of the digits of `n`.\n    \n    Examples:\n        >>> product_of_digits(123)\n        6\n        >>> product_of_digits(430)\n        0\n    \"\"\"\n    product = 1\n    for digit in str(n):\n        product *= int(digit)\n    return product", "def sum_of_digits(n):\n    \"\"\"\n    Calculates the sum of the digits of a number.\n    Parameters:\n    - n (int): The number whose digit sum is calculated.\n    Returns:\n    - int: The sum of the digits of n.\n    Example:\n    >>> sum_of_digits(1234)\n    10\n    \"\"\"\n    return sum(int(digit) for digit in str(n))", "def sum_of_digits(n):\n    \"\"\"\n    Calculates the sum of the digits of a given integer n.\n    Parameters:\n    - n (int): The integer whose digits sum is to be calculated.\n    Returns:\n    - int: The sum of digits of n.\n    \n    Examples:\n    >>> sum_of_digits(1234)\n    10\n    \"\"\"\n    return sum(int(digit) for digit in str(abs(n)))"], ["def is_divisible(n, d):\n    \"\"\"\n    Checks if n is divisible by d.\n    Parameters:\n    - n (int): The number to be checked.\n    - d (int): The divisor.\n    Returns:\n    - bool: True if n is divisible by d, False otherwise.\n    Example:\n    >>> is_divisible(10, 2)\n    True\n    >>> is_divisible(10, 3)\n    False\n    \"\"\"\n    return n % d == 0", "def is_divisible(n, m):\n    \"\"\"\n    Checks if n is divisible by m.\n    Parameters:\n    - n (int): The dividend.\n    - m (int): The divisor.\n    Returns:\n    - bool: True if n is divisible by m, False otherwise.\n    \n    Examples:\n    >>> is_divisible(20, 4)\n    True\n    \"\"\"\n    return n % m == 0"], ["def sum_of_proper_divisors(n):\n    \"\"\"Calculate the sum of all proper divisors of n (excluding n itself).\n    \n    Parameters:\n        n (int): The number to calculate the sum of its proper divisors\n    \n    Returns:\n        int: Sum of all proper divisors of n\n    \n    Examples:\n        >>> sum_of_proper_divisors(28)\n        28\n        >>> sum_of_proper_divisors(12)\n        16\n    \"\"\"\n    return sum(all_divisors(n)) - n", "def sum_of_divisors(n):\n    \"\"\"\n    Calculates the sum of all divisors of n including 1 and n itself.\n    Parameters:\n    - n (int): The number whose divisors' sum is to be found.\n    Returns:\n    - int: The sum of all divisors of n.\n    Example:\n    >>> sum_of_divisors(12)\n    28\n    \"\"\"\n    divisors = find_divisors(n)\n    return sum(divisors)", "def sum_of_divisors(n):\n    \"\"\"\n    Returns the sum of all divisors of a number n.\n    Parameters:\n    - n (int): The integer to calculate the sum of divisors for.\n    Returns:\n    - int: Sum of all divisors of n.\n    \n    Examples:\n    >>> sum_of_divisors(28)\n    56\n    \"\"\"\n    return sum(get_divisors(n))"], ["def generate_number_sequence(start, end, step=1, sequence_type='natural'):\n    \"\"\"\n    Generate a sequence of numbers with given properties like natural numbers, even, odd, or prime within a range.\n    \n    Parameters:\n        start (int): The starting number of the sequence.\n        end (int): The ending number of the sequence (inclusive).\n        step (int, optional): The step between consecutive numbers. Defaults to 1.\n        sequence_type (str, optional): Type of the number sequence (`natural`, `even`, `odd`, `prime`).\n    \n    Returns:\n        list: A list containing the generated sequence of numbers.\n    \n    Examples:\n        >> generate_number_sequence(1, 10)\n        [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n        >> generate_number_c", "def generate_sequence(start, count, parity='odd'):\n    \"\"\"\n    Generate a sequence of odd or even numbers starting from a given number.\n    \n    Parameters:\n    start (int): The number to start from.\n    count (int): The total number of elements to generate.\n    parity (str): 'odd' to generate odd numbers, 'even' to generate even numbers.\n    \n    Returns:\n    list[int]: A list of odd or even integers.\n    \n    Example:\n    >>> generate_sequence(1, 5, 'odd')\n    [1, 3, 5, 7, 9]\n    >>> generate_sequence(2, 5, 'even')\n    [2, 4, 6, 8, 10]\n    \"\"\"\n    if parity not in ['odd', 'even']:\n        raise ValueError(\"Parity must be 'odd' or 'even'\")\n    if (is_odd(start) and parity == 'even') or (is_even(start) and parity == 'odd'):\n        start += 1\n    return [start + 2 * i for i in range(count)]", "def generate_sequence(start, count, step=2):\n    \"\"\"\n    Generate a sequence of integers starting from a particular number, with configurable step, typically used for even or odd sequences.\n    Parameters:\n        start (int): The start number of the sequence.\n        count (int): The number of elements in the sequence.\n        step (int): The step between consecutive numbers (default is 2).\n    Returns:\n        list: A list containing the sequence of numbers.\n    Examples:\n        >>> generate_sequence(2, 5)\n        [2, 4, 6, 8, 10]\n        >>> generate_step(1, 5)\n        [1, 3, 5, 7, 9]\n    \"\"\"\n    return [start + i * step for i in range(count)]"], ["def find_divisors(n):\n    \"\"\"\n    Find all divisors of a given integer n.\n    Parameters:\n        n (int): The integer to find divisors of.\n    Returns:\n        list: A list of all divisors of n.\n    \"\"\"\n    return sympy.divisors(n)", "def all_divisors(n):\n    \"\"\"Calculates all divisors of a given integer n, including 1 and n itself.\n    \n    Parameters:\n        n (int): The integer to find divisors for\n    \n    Returns:\n        list: Sorted list of all divisors of n\n    \n    Examples:\n        >>> all_divisors(28)\n        [1, 2, 4, 7, 14, 28]\n        >>> all_divisors(15)\n        [1, 3, 5, 15]\n    \"\"\"\n    divisors = set()\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            divisors.add(i)\n            divisors.add(n // i)\n    return sorted(divisors)", "def find_divisors(n):\n    \"\"\"\n    Finds all divisors of n, including 1 and n itself.\n    Parameters:\n    - n (int): The number whose divisors are to be found.\n    Returns:\n    - List[int]: A list of all divisors of n.\n    Example:\n    >>> find_divisors(12)\n    [1, 2, 3, 4, 6, 12]\n    \"\"\"\n    from math import sqrt\n    divisors = []\n    for i in range(1, int(sqrt(n)) + 1):\n        if n % i == 0:\n            divisors.append(i)\n            if i != n // i:\n                divisors.append(n // i)\n    divisors.sort()\n    return divisors", "def get_divisors(n):\n    \"\"\"\n    Calculates all the divisors of a given integer n.\n    Parameters:\n    - n (int): The integer to find divisors for.\n    Returns:\n    - list of int: A list containing all divisors of n.\n    \n    Examples:\n    >>> get_divisors(28)\n    [1, 2, 4, 7, 14, 28]\n    \"\"\"\n    import math\n    divisors = set()\n    for i in range(1, int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            divisors.add(i)\n            divisors.add(n // i)\n    return sorted(list(divisors))", "def find_divisors(n):\n    \"\"\"\n    Calculate all divisors of a given integer, both proper and improper.\n    Parameters:\n    - n (int): The integer to find divisors for.\n    Returns:\n    - list: A list of all divisors of n.\n    \n    Examples:\n    - find_divisors(28) -> [1, 2, 4, 7, 14, 28]\n    - find_divisors(13) -> [1, 13]\n    \"\"\"\n    if n < 1:\n        raise ValueError(\"n must be a positive integer.\")\n    divisors = set()\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            divisors.add(i)\n            divisors.add(n // i)\n    \n    return sorted(divisors)"], ["def compute_lcm(a, b):\n    \"\"\"Compute the least common multiple of two integers a and b.\n    \n    Parameters:\n        a (int): First integer\n        b (int): Second integer\n    \n    Returns:\n        int: Least common multiple of a and b\n    \n    Examples:\n        >>> compute_lcm(6, 8)\n        24\n        >>> compute_lcm(5, 10)\n        10\n    \"\"\"\n    return abs(a*b) // gcd(a, b)", "def gcd_lcm(a, b):\n    \"\"\"\n    Calculate the greatest common divisor and least common multiple of two numbers.\n    Parameters:\n    a : int\n        First integer.\n    b : int\n        Second integer.\n    Returns:\n    tuple\n        A tuple containing the gcd and lcm of the two integers.\n    Examples:\n    >>> gcd_lcm(12, 18)\n    (6, 36)\n    \"\"\"\n    gcd_ab = math.gcd(a, b)\n    lcm_ab = abs(a*b) // gcd_guided investigations a positive integers.ab\n    return gcd_ab, lcm_ab", "def gcd_and_lcm(a, b):\n    \"\"\"\n    Calculate the greatest common divisor (gcd) and least common multiple (lcm) of two numbers.\n    Parameters:\n    - a (int): The first integer.\n    - b (int): The second integer.\n    Returns:\n    - tuple: A tuple containing the gcd and lcm of a and b.\n    \n    Examples:\n    - gcd_and_lcm(12, 15) -> (3, 60)\n    - gcd_and_lcm(100, 85) -> (5, 1700)\n    \"\"\"\n    \n    from math import gcd\n    from sympy import lcm\n    \n    if a < 1 or b < 1:\n        raise ValueError(\"Both numbers must be positive integers.\")\n    \n    gcd_value = gcd(a, b)\n    lcm_value = lcm(a, b)\n    \n    return (gcd_value, lcm_value)"], ["def check_prime(number):\n    \"\"\"\n    Check if a number is prime using the sympy library.\n    Parameters:\n        number (int): The number to check for primality.\n    Returns:\n        bool: True if the number is prime, False otherwise.\n    \"\"\"\n    return sympy.isprime(number)", "def is_prime(number):\n    \"\"\"\n    Check if a number is prime.\n    Parameters:\n    - number (int): The number to be checked.\n    Returns:\n    - bool: True if number is prime, False otherwise.\n    \n    Examples:\n    >>> is_prime(7)\n    True\n    >>> is_prime(4)\n    False\n    \"\"\"\n    return isprime(number)"], ["def modular_inverse(a, m):\n    \"\"\"\n    Find the modular inverse of a under modulo m.\n    Parameters:\n    - a (int): The number to find the inverse of.\n    - m (int): The modulus.\n    Returns:\n    - int/None: The modular inverse if it exists, otherwise None.\n    Examples:\n    - modular_inverse(3, 11) -> 4 (because (3*4) % 11 == 1)\n    - modular_inverse(10, 20) -> None (because 10 and 20 are not coprime)\n    \"\"\"\n    from sympy import mod_inverse\n    try:\n        return mod_inverse(a, m)\n    except ValueError:\n        return None", "def modular_inverse(a, m):\n    \"\"\"\n    Compute the modular inverse of a under modulo m.\n    Parameters:\n        a (int): The number to find an inverse for.\n        m (int): The modulo.\n    Returns:\n        int: The modular inverse of a under modulo m, or None if no inverse exists.\n    \"\"\"\n    return sympy.mod_inverse(a, m) if sympy.gcd(a, m) == 1 else None", "def modular_inverse(a, m):\n    \"\"\"\n    Find the modular inverse of a under modulo m using the Extended Euclidean Algorithm.\n    \n    Parameters:\n    - a (int): The number to find the inverse for.\n    - m (int): The modulus.\n    \n    Returns:\n    - Optional[int]: The modular inverse of a under modulo m, or None if no inverse exists.\n    \n    Examples:\n    >>> modular_inverse(3, 11)\n    4\n    >>> modular_inverse(10, 20)\n    None\n    \"\"\"\n    a = a % m\n    for x in range(1, m):\n        if ((a * x) % m == 1):\n            return x\n    return None"], ["def is_perfect_square(n):\n    \"\"\"\n    Check if a number is a perfect square.\n    \n    Parameters:\n    - n: int, the number to check\n    \n    Returns:\n    - bool, True if n is a perfect square, False otherwise\n    \n    Examples:\n    >>> is_perfect_square(25)\n    True\n    >>> is_perfect_square(10)\n    False\n    \"\"\"\n    sqrt_n = int(math.sqrt(n))\n    return sqrt_n * sqrt_n == n", "def is_perfect_square(n):\n    \"\"\"\n    Checks if the given integer `n` is a perfect square.\n    Parameters\n    ----------\n    n : int\n        The integer to check.\n    Returns\n    -------\n    bool\n        True if `n` is a perfect square, False otherwise.\n    Examples\n    --------\n    >>> is_perfect_square(16)\n    True\n    >>> is_perfect_square(14)\n    False\n    \"\"\"\n    root = int(math.sqrt(n))\n    return n == root * root", "def is_perfect_square(n):\n    \"\"\"\n    Check if a given integer n is a perfect square.\n    Parameters:\n    - n (int): The number to check.\n    Returns:\n    - bool: True if n is a perfect square, False otherwise.\n    Examples:\n    >>> is_perfect_square(16)\n    True\n    >>> is_perfect_square(14)\n    False\n    \"\"\"\n    root = isqrt(n)\n    return root * root == n"], ["def list_factors(n):\n    \"\"\"\n    List all positive factors of a given integer.\n    Parameters:\n    - n (int): The integer to find factors of.\n    Returns:\n    - list: A list of all positive factors of n.\n    Examples:\n    - list_factors(36) -> [1, 2, 3, 4, 6, 9, 12, 18, 36]\n    \"\"\"\n    return [i for i in range(1, n+1) if n % i == 0]", "def all_factors(n):\n    \"\"\"\n    Retrieve all factors of an integer.\n    Parameters:\n    n : int\n        The integer whose factors are to be found.\n    \n    Returns:\n    list\n        A sorted list of all unique factors of the integer.\n    Examples:\n    >>> all_factors(28)\n    [1, 2, 4, 7, 14, 28]\n    \"\"\"\n    factors = set()\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            factors.add(i)\n            factors.add(n // i)\n    return sorted(factors)"], ["def extract_digits(n):\n    \"\"\"Extract digits of an integer n as a list.\n    \n    Parameters:\n        n (int): The integer from which digits are to be extracted.\n        \n    Returns:\n        list: Digits of the given integer.\n    \n    Examples:\n        >>> extract_digits(123)\n        [1, 2, 3]\n    \"\"\"\n    return [int(x) for x in str(abs(n))]", "def extract_digits(number):\n    \"\"\"Extract digits from an integer and return as a list.\n    \n    Parameters:\n    - number (int): The integer from which to extract digits.\n    \n    Returns:\n    List[int]: A list of digits.\n    \n    Examples:\n    >>> extract_digits(1234)\n    [1, 2, 3, 4]\n    \"\"\"\n    return [int(digit) for digit in str(abs(number))]"], ["def product_parity(n1, n2):\n    \"\"\"\n    Determines the parity (odd/even) of the product of two integers.\n    Parameters:\n    n1 : int\n        First integer.\n    n2 : int\n        Second integer.\n    Returns:\n    str\n        'odd' if the product is odd, 'even' if the product is even.\n    Examples:\n    >>> product_parity(2, 3)\n    'even'\n    >>> product_parity(3, 5)\n    'odd'\n    \"\"\"\n    if is_odd(n1) and is_odd(n2):\n        return 'odd'\n    else:\n        return 'even'", "def multiply_and_check_parity(num1, num2):\n    \"\"\"\n    Multiply two numbers and check if the result is even or odd.\n    Parameters:\n        num1 (int): The first integer.\n        num2 (int): The second integer.\n    Returns:\n        dict: A dictionary containing the product and its parity (\"even\" or \"odd\").\n    Examples:\n        >>> multiply_and_check_parity(5, 3)\n        {'product': 15, 'parity': 'odd'}\n        >>> multiply_and_check_parity(2, 3)\n        {'product': 6, '7parity': 'even'}\n    \"\"\"\n    product = num1 * num2\n    return {'product': product, 'parity': 'even' if is_even(product) else 'odd'}"], ["def gcd(a, b):\n    \"\"\"\n    Compute the greatest common divisor of a and b.\n    Parameters:\n    - a (int): First number.\n    - b (int): Second number.\n    Returns:\n    - int: The greatest common divisor of a and b.\n    \n    Example:\n    >>> gcd(48, 18)\n    6\n    \"\"\"\n    while b:\n        a, b = b, a % b\n    return a", "def gcd(a, b):\n    \"\"\"\n    Compute the greatest common divisor of a and b using the Euclidean Algorithm.\n    Parameters:\n    - a (int): First number\n    - b (int): Second number\n    \n    Returns:\n    - int: The greatest common divisor of a and b.\n    \n    Examples:\n    >>> gcd(14, 49)\n    7\n    >>> gcd(100, 25)\n    25\n    \"\"\"\n    while b != 0:\n        (a, b) = (b, a % b)\n    return a"], ["def is_even(n):\n    \"\"\"\n    Determines if a given integer is even.\n    Parameters:\n    n : int\n        Integer to check.\n    Returns:\n    bool\n        True if 'n' is even, False otherwise.\n    \n    Examples:\n    >>> is_even(3)\n    False\n    >>> is_even(4)\n    True\n    \"\"\"\n    return n % 2 == 0", "def is_even(n):\n    \"\"\"Check if the number is even.\n    \n    Parameters:\n        n (int): Number to check.\n        \n    Returns:\n        bool: True if n is even, False otherwise.\n    \n    Examples:\n        >>> is_even(20)\n        True\n        >>> is_even(11)\n        False\n    \"\"\"\n    return n % 2 == 0", "def is_even(n):\n    \"\"\"\n    Check if a number is even.\n    \n    Parameters:\n    n (int): The number to check.\n    \n    Returns:\n    bool: True if the number is even, False otherwise.\n    \n    Example:\n    >>> is_even(4)\n    True\n    >>> is_even(5)\n    False\n    \"\"\"\n    return n % 2 == 0", "def is_even(n):\n    \"\"\"\n    Check if an integer is even.\n    Parameters\n    ----------\n    n : int\n        The integer to check.\n    Returns\n    -------\n    bool\n        True if `n` is even, otherwise False.\n    Examples\n    --------\n    >>> is_even(2)\n    True\n    >>> is_even(3)\n    False\n    \"\"\"\n    return n % 2 == 0", "def is_even(number):\n    \"\"\"\n    Determine if the given number is even.\n    Parameters:\n        number (int): The integer to check for evenness.\n    Returns:\n        bool: True if the number is even, False otherwise.\n    Examples:\n        >>> is_even(4)\n        True\n        >>> is_even(5)\n        False\n    \"\"\"\n    return number % 2 == 0"], ["def prime_factors_with_exponents(n):\n    \"\"\"\n    Provides prime factorization of a number with their exponents.\n    \n    Parameters:\n    - n: int, the number to factorize\n    \n    Returns:\n    - dict, keys are prime factors and values are their exponents\n    \n    Examples:\n    >>> prime_factors_with_exponents(18)\n    {2: 1, 3: 2}\n    >>> prime_factors_with_exponents(50)\n    {2: 1, 5: 2}\n    \"\"\"\n    return factorint(n)", "def prime_factors(n):\n    \"\"\"Returns all prime factors of a given integer n with their exponents in the form of a dictionary.\n    \n    Parameters:\n        n (int): The integer to factorize\n    \n    Returns:\n        dict: A dictionary with prime factors as keys and their exponents as values\n    \n    Examples:\n        >>> prime_factors(18)\n        {2: 1, 3: 2}\n        >>> prime_factors(100)\n        {2: 2, 5: 2}\n    \"\"\"\n    factors = {}\n    for p in primerange(2, int(n**0.5) + 1):\n        count = 0\n        while n % p == 0:\n            n //= p\n            count += 1\n        if count > 0:\n            factors[p] = count\n    if n > 1:\n        factors[n] = 1\n    return factors", "def prime_factors(n):\n    \"\"\"\n    Return the prime factorization of an integer n as a dictionary {prime: exponent}.\n    Parameters:\n    - n (int): The number to factorize.\n    Returns:\n    - dict: A dictionary with primes as keys and their respective exponents as values.\n    Examples:\n    >>> prime_factors(18)\n    {2: 1, 3: 2}\n    \"\"\"\n    return factorint(n)", "def prime_factorization(n):\n    \"\"\"\n    Perform prime factorization of a given integer.\n    Parameters:\n    - n (int): The integer to factorize.\n    Returns:\n    - dict: A dictionary where keys are the prime factors and values are their respective exponents in the factorization.\n    \n    Examples:\n    - prime_factorization(18) -> {2: 1, 3: 2}\n    - prime_factorization(100) -> {2: 2, 5: 2}\n    \"\"\"\n    from sympy import primefactors, multiplicity\n    \n    if n < 1:\n        raise ValueError(\"n must be a positive integer.\")\n    factors = primefactors(n)\n    factorization = {p: multiplicity(p, n) for p in factors}\n    \n    return factorization"], ["def check_primality(n):\n    \"\"\"\n    Check if the number is a prime.\n    \n    Parameters:\n        n (int): The number to check for primality.\n    \n    Returns:\n        bool: True if n is a prime number, otherwise False.\n    \n    Examples:\n        print(check_primality(31))  # True\n        print(check_primality(100))  # False\n    \"\"\"\n    return isprime(n)", "def is_prime(n):\n    \"\"\"\n    Check if the number n is a prime number.\n    Parameters:\n    - n (int): The number to check for primality.\n    Returns:\n    - bool: True if n is a prime number, False otherwise.\n    Example:\n    >>> is_prime(11)\n    True\n    >>> is_prime(10)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True", "def is_prime(n):\n    \"\"\"Check if an integer is a prime number.\n    \n    Parameters:\n    n : int\n        Number to check for primality.\n    \n    Returns:\n    bool\n        True if n is a prime number, False otherwise.\n    \n    Example:\n    >>> is_prime(11)\n    True\n    >>> is_prime(4)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "def is_prime(n):\n    \"\"\"\n    Check if an integer is a prime number.\n    Parameters:\n    n : int\n        The integer to check for primality.\n    Returns:\n    bool\n        True if n is a prime number, else False.\n    Examples:\n    >>> is_prime(29)\n    True\n    \"\"\"\n    return sympy.isprime(n)", "def is_prime(n):\n    \"\"\"\n    Determine whether an integer is a prime number.\n    \n    Parameters:\n    - n (int): The integer to check for primality.\n    Returns:\n    - bool: True if n is a prime number, False otherwise.\n    \n    Examples:\n    >>> is_prime(29)\n    True\n    \"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "def is_prime(n):\n    \"\"\"\n    Check if an integer is a prime number.\n    Parameters\n    ----------\n    n : int\n        The integer to check for primality.\n    Returns\n    -------\n    bool\n        True if `n` is a prime number, otherwise False.\n    Examples\n    --------\n    >>> is_prime(5)\n    True\n    >>> is_prime(4)\n    False\n    \"\"\"\n    return sympy.isprime(n)"], ["def triangle_combinations(max_side: int):\n    \"\"\"\n    Generates all combinations of integer side lengths (a, b, c) such that they satisfy the triangle inequality.\n    \n    Parameters:\n    - max_side (int): Maximum length for any side of the triangle.\n    \n    Returns:\n    - set of tuples: a set containing tuples (a, b, c), each being a valid triangle with sides a, b, and c.\n    \n    Example:\n    >>> triangle_combinations(5)\n    {(3, 4, 5), (2, 3, 4), (2, 2, 3), ...}\n    \"\"\"\n    from itertools import combinations_with_replacement\n    \n    valid_triangles = set()\n    for a, b, c in combinations_with_replacement(range(1, max_side + 1), 3):\n        if a + b > c and a + c > b and b + c > a:\n            valid_triangles.add(tuple(sorted([a, b, c])))\n    \n    return valid_triangles", "def generate_triangle_sides(max_side_length, fixed_perimeter=None, must_be_odd=False):\n    \"\"\"\n    Generates all possible combinations of side lengths (a, b, c) for triangles,\n    optionally with a fixed perimeter and conditions on the parity of the sides.\n    Parameters:\n        max_side_length (int): The maximum length for any side of the triangle.\n        fixed_perimeter (int, optional): If specified, only side combinations with this perimeter are returned.\n        must_be_odd (bool, optional): If True, only odd-numbered sides will be considered.\n    Returns:\n        list of tuple: A list of valid (a, b, c) tuples where each tuple represents triangle side lengths.\n    Examples:\n        >>> generate_triangle_sides(10)\n        [(3, 4, 5), (6, 8, 10), ...]\n        >>> generate_triangle_sides(10, fixed_perimeter=24)\n        [(6, 8, 10)]\n        >>> generate_triangle_sides(10, must_be_odd=True)\n        [(3, 5, 7), (5, 7, 9), ...]\n    \"\"\"\n    from itertools import combinations_with_replacement\n    valid_triangles = []\n    side_range = range(1, max_side_length + 1, 2 if must_be_odd else 1)\n    for sides in combinations_with_replacement(side_range, 3):\n        a, b, c = sides\n        if a + b + c == fixed_perimeter or fixed_perimeter is None:\n            if a + b > c and a + c > b and b + c > a:\n                valid_triangles.append(sides)\n    return valid_triangles"], ["def count_digit_combinations(digits, length, leading_zeros=False):\n    \"\"\"Count possible numbers of a given length with specified digit constraints and optional leading zeros.\n    \n    Parameters:\n    - digits (list): Allowed digits.\n    - length (int): Desired length of numbers.\n    - leading_zeros (bool): Whether leading zeros are allowed.\n    \n    Returns:\n    Iterator over all valid number combinations as strings.\n    \n    Examples:\n    >>> len(list(count_digit_combinations([1, 2, 3], 2, leading_zeros=False)))\n    9\n    \"\"\"\n    if leading_zeros:\n        return product(digits, repeat=length)\n    return product([d for d in digits if d != 0], *[digits for _ in range(length - 1)])"], ["def is_valid_triangle(a, b, c):\n    \"\"\"\n    Check if three sides can form a valid triangle based on the Triangle Inequality Theorem.\n    Parameters:\n        a (int): Length of side a.\n        b (int): Length of side b.\n        c (int): Length of side c.\n    Returns:\n        bool: True if the sides form a valid triangle, False otherwise.\n    Examples:\n        >>> is_valid_triangle(3, 4, 5)\n        True\n        >>> is_valid_triangle(1, 1, 3)\n        False\n    \"\"\"\n    return (a + b > c) and (a + c > b) and (b + c > a)", "def is_valid_triangle(a, b, c):\n    \"\"\"\n    Determines if three side lengths can form a triangle based on the triangle inequality theorem.\n    \n    Parameters:\n    - a (int): length of side a\n    - b (int): length of side b\n    - c (int): length of side c\n    \n    Returns:\n    - bool: True if the sides can form a triangle, False otherwise\n    Examples:\n    >>> is_valid_triangle(3, 4, 5)\n    True\n    >>> is_valid_triangle(1, 2, 3)\n    False\n    \"\"\"\n    return (a + b > c) and (a + c > b) and (b + c > a)"], ["def is_square_free(n):\n    \"\"\"\n    Determines if a number is square-free. A number is square-free if it is not divisible by any perfect squares other than 1.\n    Parameters\n    ----------\n    n : int\n        The integer to check for square-freeness.\n    \n    Returns\n    -------\n    bool\n        True if `n` is square-free, False otherwise.\n    Examples\n    --------\n    >>> is_square_free(10)\n    True\n    >>> is_square_free(12)\n    False\n    \"\"\"\n    factors = factorint(n)\n    for exp in factors.values():\n        if exp > 1:\n            return False\n    return True", "def is_square_free(n):\n    \"\"\"\n    Determine if the number n is square-free (no square of any prime divides n).\n    Parameters:\n    - n (int): The number to check.\n    Returns:\n    - bool: True if n is square-free, False otherwise.\n    Examples:\n    >>> is_square_free(14)\n    True\n    >>> is_square_free(12)\n    False\n    \"\"\"\n    factors = factorint(n)\n    return all(exp == 1 for exp in factors.values())"], ["def count_valid_numbers(range_start, range_end, include=None, exclude=None):\n    \"\"\"Count integers within a specific range that meet digit inclusion/exclusion criteria.\n    \n    Parameters:\n    - range_start (int): Start of the range (inclusive).\n    - range_end (int): End of the range (inclusive).\n    - include (list, optional): Digits that must be included. If None, no inclusion criteria.\n    - exclude (list, optional): Digits that must be excluded. If None, no exclusion criteria.\n    \n    Returns:\n    int: Count of valid numbers within the range.\n    \n    Examples:\n    >>> count_valid_numbers(100, 500, exclude=[0, 1])\n    324\n    \"\"\"\n    count = 0\n    for num in range(range_start, range_end + 1):\n        if validate_digit_criteria(num, include, exclude):\n            count += 1\n    return count"], ["def check_parity_of_sum(*numbers):\n    \"\"\"\n    Check if the sum of the provided numbers is even or odd.\n    Parameters:\n        numbers (int): Variable length integer arguments.\n    Returns:\n        str: 'even' if the sum is even, 'odd' if the sum is odd.\n    Examples:\n        >>> check_parity_of_sum(1, 2, 3)\n        'even'\n        >>> check_parity_of_sum(1, 3, 5)\n        'odd'\n    \"\"\"\n    total = sum(numbers)\n    return 'even' if is_even(total) else 'odd'"], ["def count_divisors_from_factors(factors):\n    \"\"\"\n    Count number of divisors of a number given its prime factorization.\n    \n    Parameters:\n    - factors: dict, prime factors with their exponents from factorint\n    \n    Returns:\n    - int, the total number of divisors\n    \n    Examples:\n    >>> count_divisors_from_factors({2: 1, 3: 2})\n    6   # Number of divisors of 18\n    >>> count_divisors_from_factors({2: 1, 5: 2})\n    6   # Number of divisors of 50\n    \"\"\"\n    count = 1\n    for exp in factors.values():\n        count *= (exp + 1)\n    return count", "def count_factors(n):\n    \"\"\"\n    Count the total number of divisors of an integer n based on its prime factorization.\n    Parameters:\n    - n (int): The number whose factors are to be counted.\n    Returns:\n    - int: The number of factors of n.\n    Examples:\n    >>> count_factors(18)\n    6\n    \"\"\"\n    factors = prime_factors(n)\n    count = 1\n    for exp in factors.values():\n        count *= (exp + 1)\n    return count"], ["def find_next_odd_or_even(number, find_even=True):\n    \"\"\"\n    Find the next even or odd number following the given number.\n    Parameters:\n        number (int): The reference number.\n        find_even (bool): Flag to determine if the next even (True) or odd (False) number should be found.\n    Returns:\n        int: The next even or odd number.\n    Examples:\n        >>> find_next_odd_or_even(4)\n        6\n        >>> find_next_odd_or_even(4, find_even=False)\n        5\n    \"\"\"\n    offset = 1 if is_even(number) ^ find_even else 2\n    return number + offset"], ["def get_divisors(number):\n    \"\"\"\n    Get all positive divisors of a given number.\n    \n    Parameters:\n    - number (int): The number to get divisors for.\n    \n    Returns:\n    - list: A list of all positive divisors.\n    \n    Examples:\n    >>> get_divisors(12)\n    [1, 2, 3, 4, 6, 12]\n    \"\"\"\n    return divisors(number)"], ["def are_consecutive(numbers):\n    \"\"\"\n    Determine if a list of numbers consists of consecutive integers.\n    Parameters\n    ----------\n    numbers : list of int\n        The list of integers to check.\n    Returns\n    -------\n    bool\n        True if integers are consecutive, otherwise False.\n    Examples\n    --------\n    >>> are_consecutive([1, 2, 3, 4])\n    True\n    >>> are_consecutive([1, 2, 4])\n    False\n    \"\"\"\n    sorted_numbers = sorted(numbers)\n    return all((sorted_numbers[i] + 1 == sorted_numbers[i + 1]\n                for i in range(len(sorted_numbers) - 1)))"], ["def integer_solution_counter(func, lower_bound, upper_bound):\n    \"\"\"\n    Counts and lists integer solutions for a given function within specified bounds.\n    \n    Parameters:\n        func (function): A Python function that should return a boolean.\n                         It defines the conditions under which an integer is considered a solution.\n        lower_bound (int): The lower inclusive bound of the range to test.\n        upper_bound (int): The upper inclusive bound of the range to test.\n    \n    Returns:\n        tuple: First element is the count of solutions, the second element is a list of solutions.\n    \n    Examples:\n        >>> integer_solution_counter(lambda x: x % 2 == 0, 1, 10)\n        (5, [2, 4, 6, 8, 10])\n        >>> integer_solution_counter(lambda x: x**2 <= 50, -10, 10)\n        (15, [-7, -6, -5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7])\n    \"\"\"\n    import sympy as sp\n    \n    solutions = []\n    for x in sp.solveset(func(sp.symbols('x')), domain=sp.S.Integers):\n        if lower_bound <= x <= upper_bound:\n            solutions.append(int(x))\n    \n    return len(solutions), solutions"], ["def count_digit(n, digit):\n    \"\"\"Count occurrences of a specific digit in an integer.\n    \n    Parameters:\n        n (int): Integer to search within.\n        digit (int): Digit to count.\n        \n    Returns:\n        int: Number of times digit occurs in n.\n    \n    Examples:\n        >>> count_digit(1223, 2)\n        2\n    \"\"\"\n    return str(n).count(str(digit))"], ["def classify_number(n):\n    \"\"\"\n    Classify a given integer as 'prime', 'composite' or 'neither'.\n    Parameters:\n    - n (int): The integer to classify.\n    Returns:\n    - str: Description of the integer ('prime', 'composite', 'neither').\n    Examples:\n    - classify_number(7) returns \"prime\"\n    - classify_number(9) returns \"composite\"\n    - classify_number(1) returns \"neither\"\n    \"\"\"\n    if n <= 1:\n        return 'neither'\n    if sympy.isprime(n):\n        return 'prime'\n    else:\n        return 'composite'", "def classify_number(number):\n    \"\"\"\n    Classify a number as 'prime', 'composite' or 'neither'.\n    \n    Parameters:\n    - number (int): The number to classify.\n    \n    Returns:\n    - str: 'prime', 'composite', or 'neither' based on the number classification.\n    Examples:\n    >>> classify_number(2)\n    'prime'\n    >>> classify_number(1)\n    'neither'\n    \"\"\"\n    if number <= 1:\n        return 'neither'\n    if is_prime(number):\n        return 'prime'\n    return 'composite'"], ["def is_perfect_cube(n):\n    \"\"\"\n    Check if a number is a perfect cube.\n    \n    Parameters:\n    - n: int, the number to check\n    \n    Returns:\n    - bool, True if n is a perfect cube, False otherwise\n    \n    Examples:\n    >>> is_perfect_cube(27)\n    True\n    >>> is_perfect_cube(20)\n    False\n    \"\"\"\n    cbrt_n = int(round(n ** (1/3)))\n    return cbrt_n ** 3 == n", "def is_perfect_cube(n):\n    \"\"\"\n    Checks if the given integer `n` is a perfect cube.\n    \n    Parameters\n    ----------\n    n : int\n        The integer to check.\n    Returns\n    -------\n    bool\n        True if `n` is a perfect cube, False otherwise.\n    Examples\n    --------\n    >>> is_perfect_cube(27)\n    True\n    >>> is_perfect_cube(20)\n    False\n    \"\"\"\n    cube_root = round(n ** (1/3))\n    return n == cube_root ** 3", "def is_perfect_cube(n):\n    \"\"\"\n    Check if a given integer n is a perfect cube.\n    Parameters:\n    - n (int): The number to check.\n    Returns:\n    - bool: True if n is a perfect cube, False otherwise.\n    Examples:\n    >>> is_perfect_cube(27)\n    True\n    >>> is_perfect_cube(26)\n    False\n    \"\"\"\n    croot = int(round(n ** (1/3)))\n    return croot**3 == n"], ["def is_odd(n):\n    \"\"\"\n    Determines if a given integer is odd.\n    Parameters:\n    n : int\n        Integer to check.\n    Returns:\n    bool\n        True if 'n' is odd, False otherwise.\n    \n    Examples:\n    >>> is_odd(3)\n    True\n    >>> is_odd(4)\n    False\n    \"\"\"\n    return n % 2 != 0", "def is_odd(n):\n    \"\"\"\n    Check if a number is odd.\n    \n    Parameters:\n    n (int): The number to check.\n    \n    Returns:\n    bool: True if the number is odd, False otherwise.\n    \n    Example:\n    >>> is_odd(3)\n    True\n    >>> is_odd(4)\n    False\n    \"\"\"\n    return n % 2 != 0", "def is_odd(number):\n    \"\"\"\n    Determine if the given number is odd.\n    Parameters:\n        number (int): The integer to check for oddness.\n    Returns:\n        bool: True if the number is odd, False otherwise.\n    Examples:\n        >>> is_odd(3)\n        True\n        >>> is_odd(10)\n        False\n    \"\"\"\n    return number % 2 != 0"], ["def is_even_by_digits(n):\n    \"\"\"\n    Determines if the number is even based on the sum of its digits.\n    Parameters:\n    - n (int): The number to check.\n    Returns:\n    - bool: True if the sum of the digits is even, False otherwise (implying the number itself is even).\n    Example:\n    >>> is_even_by_digits(1234)\n    True\n    >>> is_even_by_digits(123)\n    False\n    \"\"\"\n    return sum_of_digits(n) % 2 == 0"], ["def validate_digit_criteria(number, include=None, exclude=None):\n    \"\"\"Check if number's digits meet certain inclusion and exclusion criteria.\n    \n    Parameters:\n    - number (int): The number to check.\n    - include (list, optional): Digits that must be included. If None, no inclusion criteria.\n    - exclude (list, optional): Digits that must be excluded. If None, no exclusion criteria.\n    \n    Returns:\n    bool: True if number meets criteria, False otherwise.\n    \n    Examples:\n    >>> validate_digit_criteria(456, include=[4, 5], exclude=[1, 2, 3])\n    True\n    >>> validate_digit_criteria(123, exclude=[4, 5, 6])\n    True\n    \"\"\"\n    digits = set(extract_digits(number))\n    if include and not set(include).issubset(digits):\n        return False\n    if exclude and set(exclude).intersection(digits):\n        return False\n    return True"], ["def sum_of_integers(n):\n    \"\"\"Calculate the sum of the first n positive integers.\n    \n    Parameters:\n    n : int\n        The number of terms.\n    \n    Returns:\n    int\n        The sum of the first n positive integers.\n    \n    Example:\n    >>> sum_of_integers(10)\n    55\n    \"\"\"\n    return n * (n + 1) // 2"], ["def generate_arithmetic_sequence(start, diff, n):\n    \"\"\"Generate an arithmetic sequence from a start value with a fixed difference over n terms.\n    \n    Parameters:\n    start : int\n        Starting value of the arithmetic sequence.\n    diff : int\n        Common difference between consecutive terms.\n    n : int\n        Number of terms to generate.\n    \n    Returns:\n    list\n        The list of n terms in the arithmetic sequence.\n    \n    Example:\n    >>> generate_arithmetic_sequence(1, 3, 4)\n    [1, 4, 7, 10]\n    \"\"\"\n    return [start + i * diff for i in range(n)]"], ["def polynomial_integer_values(polynomial, values):\n    \"\"\"\n    Evaluate a polynomial at given values and check if results are integers.\n    Parameters:\n        polynomial (sympy.Poly): The polynomial to evaluate.\n        values (list): Values at which to evaluate the polynomial.\n    Returns:\n        dict: A dictionary mapping values to their evaluation results and whether those are integers.\n    \"\"\"\n    results = {}\n    for val in values:\n        result = polynomial.subs(sympy.Symbol('x'), val)\n        results[val] = {'value': result, 'is_integer': sympy.sympify(result).is_integer}\n    return results"], ["def integer_properties_checker(n, check='prime'):\n    \"\"\"\n    Check specific properties of an integer such as primality or perfect square.\n    Parameters:\n    n (int): the integer to check\n    check (str): What to check, supported values are 'prime', 'perfect_square'\n    Returns:\n    bool: True if the property is satisfied, False otherwise\n    Examples:\n    >>> integer_properties_checker(29, 'prime')\n    True\n    >>> integer_properties_checker(28, 'perfect_square')\n    False\n    \"\"\"\n    if check == 'prime':\n        return sympy.isprime(n)\n    elif check == 'perfect_square':\n        return n == sympy.Integer(sympy.sqrt(n))**2\n    else:\n        raise ValueError(\"Unsupported check type provided. Supported types are 'prime', 'perfect_square'.\")"], ["def test_integer_solutions(a, b, c, x):\n    \"\"\"\n    Check if the equation ax + b = c has an integer solution for x.\n    Parameters:\n    - a (int): Coefficient of x.\n    - b (int): Constant term.\n    - c (int): Right-hand side of the equation.\n    Returns:\n    - bool: True if there is an integer solution, False otherwise.\n    Examples:\n    - test_integer_solutions(2, -4, 10) returns True (x=7 solves the equation)\n    - test_integer_solutions(5, 2, 19) returns True (x=17/5 which is not an integer thus False)\n    \"\"\"\n    # Simplify to x = (c - b) / a\n    result = (c - b) / a\n    return result.is_integer()"], ["def solve_integer_equation_by_factors(product, sum_of_factors):\n    \"\"\"\n    Find pairs of integers that when multiplied yield 'product' and when added yield 'sum_of_factors'.\n    Parameters:\n    - product (int): The product of the two integers.\n    - sum_of_factors (int): The sum of the two integers.\n    Returns:\n    - list: A list of tuples (x, y) where x and y are integer solutions.\n    \n    Examples:\n    - solve_integer_equation_by_factors(72, 18) -> [(9, 8), (8, 9), (-9, -8), (-8, -9)]\n    \"\"\"\n    \n    solutions = []\n    for x in find_divisors(abs(product)):  # We get all divisors of the product\n        # Check both positive and negative divisors\n        for sign in [1, -1]:\n            y = product // (x * sign)\n            if x * sign + y == sum_of_factors:\n                solutions.append((x * sign, y))\n                \n    return solutions"], ["def arithmetic_sum(a, d, n):\n    \"\"\"\n    Calculate the sum of the first `n` terms of an arithmetic sequence.\n    Parameters\n    ----------\n    a : int\n        The first term of the sequence.\n    d : int\n        The common difference of the sequence.\n    n : int\n        The number of terms.\n    Returns\n    -------\n    int\n        The sum of the first `n` terms.\n    Examples\n    --------\n    >>> arithmetic_sum(1, 1, 100)  # Sum of first 100 natural numbers\n    5050\n    >>> arithmetic_sum(2, 2, 10)  # Sum of first 10 even numbers starting from 2\n    110\n    \"\"\"\n    return n * (2 * a + (n - 1) * d) // 2"], ["def is_abundant(n):\n    \"\"\"\n    Determine if a number is abundant (sum of proper divisors greater than the number itself).\n    Parameters:\n    n : int\n        The number to check for abundance.\n    Returns:\n    bool\n        True if n is abundant, False otherwise.\n    Examples:\n    >>> is_abundant(12)\n    True\n    \"\"\"\n    proper_factors = sum(all_factors(n)[:-1])\n    return proper_factors > n"], ["def sum_of_divisors(n, prime_only=False):\n    \"\"\"\n    Calculate the sum of divisors of an integer, with an option to sum only prime divisors.\n    Parameters:\n        n (int): The integer to find the sum of divisors.\n        prime_only (bool, optional): If True, sum only the prime divisors. Defaults to False.\n    Returns:\n        int: Sum of divisors or sum of prime divisors based on `prime_only` flag.\n    \"\"\"\n    divisors = find_divisors(n)\n    if prime_only:\n        prime_divisors = [div for div in divisors if sympy.isprime(div)]\n        return sum(prime_divisors)\n    return sum(divisors)"], ["def count_integers_within_bounds(lower_bound, upper_bound, inclusive=True):\n    \"\"\"\n    Calculate the total count of integers between two bounds.\n    Parameters:\n    lower_bound (int): the lower bound of the range\n    upper_bound (int): the upper bound of the range\n    inclusive (bool): if True, include both bounds, else exclude bounds\n    \n    Returns:\n    int: count of integers within the specified bounds\n    Examples:\n    >>> count_integers_within_bounds(1, 10)\n    10\n    >>> count_integers_within_bounds(1, 10, inclusive=False)\n    8\n    \"\"\"\n    if inclusive:\n        return (upper_bound - lower_bound + 1)\n    else:\n        return (upper_bound - lower_bound - 1)"], ["def integer_solutions_to_equation(eq, variables, domain=(None, None)):\n    \"\"\"\n    Find integer solutions to an equation over a specific domain.\n    Parameters:\n    eq (sympy expression): the equation or expression object from sympy\n    variables (list of sympy symbols): symbols used in the equation\n    domain (tuple): a lower and upper bound for solutions, as (min, max)\n    \n    Returns:\n    list: a list of dictionaries mapping variables to their integer solutions\n    Examples:\n    >>> x, y = sp.symbols('x y')\n    >>> integer_solutions_to_equation(x**2 + y**2 - 25, [x, y])\n    [{x: -5, y: 0}, {x: 0, y: -5}, {x: 0, y: 5}, {x: 5, y: 0}]\n    \"\"\"\n    solutions = []\n    for val in domain:\n        subs_eq = eq.subs(variables[0], val)\n        remaining_vars = variables[1:]\n        if len(remaining_vars) == 0:\n            if subs_eq.is_zero:\n                solutions.append({variables[0]: val})\n        else:\n            for sol in integer_solutions_to_equation(subs_eq, remaining_vars, domain):\n                sol[variables[0]] = val\n                solutions.append(sol)\n    return solutions"], ["def find_integers_in_range(start, end, condition=lambda x: True):\n    \"\"\"\n    Generates a list of integers within a specified range that meet a certain condition.\n    \n    Parameters:\n        start (int): The start of the range (inclusive).\n        end (int): The end of the range (inclusive).\n        condition (callable): A function that takes an integer as an argument and returns\n                              a boolean indicating whether the integer meets the specified condition.\n                              Default checks if every integer in the range is valid.\n    \n    Returns:\n        List[int]: A list containing all integers in the range [start, end] that meet the condition.\n    \n    Examples:\n        # Find all integers between 1 and 100\n        print(find_integers_in_range(1, 100))\n        # Find all even integers between 1 and 100\n        print(find_integers_in_range(1, 100, lambda x: x % 2 == 0))\n        # Find all prime integers between 1 and 100\n        from sympy import isprime\n        print(find_integers_in_range(1, 100, isprime))\n    \"\"\"\n    return [n for n in range(start, end + 1) if condition(n)]"], ["def integer_ceiling(x):\n    \"\"\"Find the ceiling of a real number, rounding up to the nearest integer.\n    \n    Parameters:\n    x : float\n        The real number to find the ceiling of.\n    \n    Returns:\n    int\n        The ceiling of x.\n    \n    Example:\n    >>> integer_ceiling(3.2)\n    4\n    >>> integer_ceiling(-2.3)\n    -2\n    \"\"\"\n    return math.ceil(x)"], ["def calculate_lcm(num1, num2):\n    \"\"\"\n    Calculate the least common multiple of two numbers.\n    Parameters:\n        num1 (int): First integer.\n        num2 (int): Second integer.\n    Returns:\n        int: The least common multiple of num1 and num2.\n    \"\"\"\n    return sympy.lcm(num1, num2)"], ["def polynomial_coefficients_integer(polynomial):\n    \"\"\"\n    Check if a polynomial expression has all integer coefficients.\n    Parameters:\n        polynomial (sympy.Poly): A polynomial expression.\n    Returns:\n        bool: True if all coefficients of the polynomial are integers, False otherwise.\n    \"\"\"\n    return all(coeff.is_Integer for coeff in polynomial.all_coeffs())"], ["def evaluate_expression(values, operation='sum'):\n    \"\"\"\n    Evaluate a mathematical expression with a list of values based on operation type like sum or product.\n    \n    Parameters:\n    values (list[int]): List of integer values.\n    operation (str): Type of operation ('sum', 'product').\n    \n    Returns:\n    int: Result of the operation.\n    \n    Example:\n    >>> evaluate_expression([1, 3, 5], 'sum')\n    9\n    >>> evaluate_expression([1, 3, 5], 'product')\n    15\n    \"\"\"\n    import functools\n    import operator\n    if operation == 'sum':\n        return sum(values)\n    elif operation == 'product':\n        return functools.reduce(operator.mul, values, 1)\n    else:\n        raise ValueError(\"Unsupported operation type. Supported types: 'sum', 'product'\")"], ["def polynomial_factors(f, var):\n    \"\"\"\n    Find the factors of a polynomial expression.\n    Parameters:\n    - f (sympy.Expr): Polynomial expression.\n    - var (sympy.Symbol): The variable in the polynomial.\n    Returns:\n    - List of factors.\n    Examples:\n    - polynomial_factors(x**2 - 1, x) -> [x - 1, x + 1]\n    \"\"\"\n    from sympy import factor_list\n    return factor_list(f, gens=var)"], ["def count_numbers_with_properties(start, end, properties):\n    \"\"\"Count numbers in a specified range that meet a set of digit-based properties.\n    \n    Parameters:\n        start (int): Start of range.\n        end (int): End of range.\n        properties (callable): A function that takes an integer and returns a boolean, whether it satisfies the property.\n        \n    Returns:\n        int: Count of numbers satisfying the given properties.\n    \n    Examples:\n        >>> count_numbers_with_properties(10, 99, lambda x: '5' in str(x) and is_even(x))\n        9\n    \"\"\"\n    return sum(1 for x in range(start, end + 1) if properties(x))"], ["def find_factors(number):\n    \"\"\"\n    Find all positive factors of a given number.\n    Parameters:\n        number (int): The number to factorize.\n    Returns:\n        list: A list of all positive factors of the number.\n    \"\"\"\n    return list(sympy.divisors(number))"], ["def is_perfect_number(n):\n    \"\"\"Determine if n is a perfect number. A perfect number is equal to the sum of its proper divectors (excluding itself).\n    \n    Parameters:\n        n (int): The number to check if it is perfect\n    \n    Returns:\n        bool: True if n is a perfect number, False otherwise\n    \n    Examples:\n        >>> is_perfect_number(28)\n        True\n        >>> is_perfect_number(12)\n        False\n    \"\"\"\n    return sum_of_proper_divisors(n) == n"], ["def solve_sum_of_squares(target, limit=None):\n    \"\"\"\n    Find pairs of integers (a, b) such that a^2 + b^2 = target, with an optional limit on values of a and b.\n    \n    Parameters:\n        target (int): The target integer sum of squares.\n        limit (int, optional): Maximum absolute value for a and b. If not specified, it uses sqrt(target).\n    \n    Returns:\n        List[Tuple[int, int]]: A list of tuples (a, b) where both a^2 + b^2 equals to the target.\n    \n    Examples:\n        # Find integer solutions for a^2 + b^2 = 50\n        print(solve_sum_of_squares(50))\n        # Find integer solutions for a^2 + b^2 = 25 with |a|,|b| <= 5\n        print(solve_sum_of_squares(25, 5))\n    \"\"\"\n    import math\n    if limit is None:\n        limit = int(math.sqrt(target))\n    solutions = []\n    for a in range(-limit, limit + 1):\n        for b in range(-limit, limit + 1):\n            if a**2 + b**2 == target:\n                solutions.append((a, b))\n    return solutions"], ["def possible_numbers(digits, length, unique=False):\n    \"\"\"Generate all possible numbers of a given length from specified digits.\n    \n    Parameters:\n        digits (list): Possible digits to use.\n        length (int): The length of numbers to generate.\n        unique (bool): If True, all digits in the number must be unique.\n        \n    Returns:\n        list: All possible numbers as strings.\n    \n    Examples:\n        >>> possible_numbers([1, 2, 3], 2)\n        ['11', '12', '13', '21', '22', '23', '31', '32', '33']\n        >>> possible_numbers([1, 2, 3], 2, unique=True)\n        ['12', '13', '21', '23', '31', '32']\n    \"\"\"\n    if unique:\n        return [''.join(map(str, comb)) for comb in itertools.permutations(digits, length)]\n    else:\n                return [''.join(map(str, comb)) for comb in itertools.product(digits, repeat=length)]"], ["def basic_integer_operations(x, operation='floor', modulus=None, check_prime=False, get_divisors=False):\n    \"\"\"\n    Perform basic operations on an integer including floor, ceiling, modular arithmetic, \n    checking for primality, and getting divisors.\n    \n    Parameters:\n        x (int): The integer on which to perform operations.\n        operation (str, optional): The type of mathematical floor/ceiling operation (`floor`, `ceil`). Defaults to 'floor'.\n        modulus (int, optional): For modulus operation. If provided, function returns x % modulus.\n        check_prime (bool, optional): If True, checks whether the integer is prime. Defaults to False.\n        get_divisors (bool, optional): If True, returns all divisors of x. Defaults to False.\n    \n    Returns:\n        Various outputs depending on inputs: transformed integer, boolean for primality, list of divisors.\n    \n    Examples:\n        >> basic_integer_operations(17.7, 'floor')\n        17\n        >> basic_integer_operations(28, modulus=5)\n        3\n        >> basic_integer_operations(11, check_prime=True)\n        True\n        >> basic_integer_operations(12, get_divisors=True)\n        [1, 2, 3, 4, 6, 12]\n    \"\"\"\n    if operation == 'floor':\n        result = floor(x)\n    elif operation == 'ceil':\n        result = ceil(x)\n    else:\n        result = x\n    \n    if modulus is not None:\n        result = x % modulus\n    \n    prime_status = isprime(x) if check_prime else None\n    divisor_list = divisors(x) if get_divisors else None\n    \n    return {'result': result, 'is_prime': prime_status, 'divisors': divisor_list}"], ["def integer_floor(x):\n    \"\"\"Find the floor of a real number, rounding down to the nearest integer.\n    \n    Parameters:\n    x : float\n        The real number to find the floor of.\n    \n    Returns:\n    int\n        The floor of x.\n    \n    Example:\n    >>> integer_floor(3.7)\n    3\n    >>> integer_floor(-1.2)\n    -2\n    \"\"\"\n    return math.floor(x)"], ["def generate_triangles_with_perimeter(perimeter):\n    \"\"\"\n    Generates all sets of integer side lengths (a, b, c) that add up to a specific perimeter and \n    adhere to the triangle inequality theorem.\n    \n    Parameters:\n    - perimeter (int): The specified perimeter that the sum of the side lengths must equal.\n    \n    Returns:\n    - list of tuples: Each tuple contains three integers (a, b, c) that represent the sides of a triangle.\n    Examples:\n    >>> generate_triangles_with_perimeter(12)\n    [(3, 4, 5), (4, 4, 4), (5, 3, 4)]\n    \"\"\"\n    triangles = []\n    for a in range(1, perimeter//3 + 1):\n        for b in range(a, (perimeter - a)//2 + 1):\n            c = perimeter - a - b\n            if is_valid_triangle(a, b, c):\n                triangles.append((a, b, c))\n    return triangles"], ["def is_divisible(a, b):\n    \"\"\"\n    Check if integer a is divisible by integer b.\n    Parameters:\n        a (int): The dividend.\n        b (int): The divisor.\n    Returns:\n        bool: True if a is divisible by b, False otherwise.\n    \"\"\"\n    if b == 0:\n        raise ValueError(\"Division by zero is not supported.\")\n    return a % b == 0"], ["def filter_triangles(triangles, perimeter=None, odd_even=None):\n    \"\"\"\n    Filters a set of triangles based on the perimeter and/or parity conditions.\n    Parameters:\n    - triangles (set of tuples): Set of tuples (a, b, c) representing sides of the triangles.\n    - perimeter (int, optional): The exact perimeter that the triangles must have.\n    - odd_even (str, optional): 'odd' for triangles with all odd sides; 'even' for all even sides; None for no parity filter.\n    \n    Returns:\n    - set of tuples: a set of triangles that pass all filters.\n    \n    Example:\n    >>> triangles = {(3, 4, 5), (2, 3, 4), (5, 5, 5)}\n    >>> filter_triangles(triangles, perimeter=12)\n    {(3, 4, 5)}\n    >>> filter_triangles(triangles, odd_even='odd')\n    {(5, 5, 5)}\n    \"\"\"\n    filtered = set()\n    for a, b, c in triangles:\n        if perimeter is not None and (a + b + c) != perimeter:\n            continue\n        if odd_even is not None:\n            if odd_even == 'odd' and (a % 2 == 0 or b % 2 == 0 or c % 2 == 0):\n                continue\n            elif odd_even == 'even' and (a % 2 != 0 or b % 2 != 0 or c % 2 != 0):\n                continue\n        filtered.add((a, b, c))\n    \n    return filtered"], ["def list_perfect_cubes(limit):\n    \"\"\"\n    Generates all perfect cubes less than or equal to the given limit.\n    \n    Parameters\n    ----------\n    limit : int\n        The upper limit for the perfect cubes.\n    Returns\n    -------\n    list\n        A list of all perfect cubes up to `limit`.\n    Examples\n    --------\n    >>> list_perfect_cubes(30)\n    [0, 1, 8, 27]\n    \"\"\"\n    cubes = [i**3 for i in range(int(round(limit ** (1/3))) + 1)]\n    return cubes"], ["def count_valid_numbers_in_range(start, end, criteria_func):\n    \"\"\"\n    Count integers within a specified range that meet a given criteria.\n    \n    Parameters:\n        start (int): The start of the range (inclusive).\n        end (int): The end of the range (inclusive).\n        criteria_func (function): A function that takes an integer and returns a boolean.\n    \n    Returns:\n        int: The count of integers satisfying the criteria within the specified range.\n    \n    Examples:\n        >>> def is_even(n):\n        ...     return n % 2 == 0\n        >>> count_valid_numbers_in_range(1, 10, is_even)\n        5\n    \"\"\"\n    return sum(1 for n in range(start, end + 1) if criteria_func(n))"], ["def calculate_gcd(num1, num2):\n    \"\"\"\n    Calculate the greatest common divisor of two numbers.\n    Parameters:\n        num1 (int): First integer.\n        num2 (int): Second integer.\n    Returns:\n        int: The greatest common divisor of num1 and num2.\n    \"\"\"\n    return sympy.gcd(num1, num2)"], ["def count_common_divisors(x, y):\n    \"\"\"\n    Count common divisors of two integers.\n    Parameters:\n        x (int): First integer.\n        y (int): Second integer.\n    Returns:\n        int: Number of common divisors.\n    \"\"\"\n    divisors_x = set(find_divisors(x))\n    divisors_y = set(find_divisors(y))\n    return len(divisors_x & divisors_y)"], ["def list_perfect_squares(limit):\n    \"\"\"\n    Generates all perfect squares less than or equal to the given limit.\n    \n    Parameters\n    ----------\n    limit : int\n        The upper limit for the perfect squares.\n    Returns\n    -------\n    list\n        A list of all perfect squares up to `limit`.\n    Examples\n    --------\n    >>> list_perfect_squares(30)\n    [0, 1, 4, 9, 16, 25]\n    \"\"\"\n    squares = [i*i for i in range(int(math.sqrt(limit)) + 1)]\n    return squares"], ["def solve_linear_inequality(a, b, c):\n    \"\"\"Solve a linear inequality of the form a*x + b <= c\n    \n    Parameters:\n    a : int\n        The coefficient of x.\n    b : int\n        Constant term.\n    c : int\n        Right side of the inequality.\n    \n    Returns:\n    tuple\n        The range of x that satisfies the inequality.\n    \n    Example:\n    >>> solve_linear_inequality(3, -6, 12)\n    (-inf, 6.0)\n    \"\"\"\n    if a == 0:\n        if b <= c:\n            return float('-inf'), float('inf')  # Indeterminate case or all x satisfy\n        else:\n            return ()  # No solution\n    x = (c - b) / a\n    if a > 0:\n        return float('-inf'), x\n    else:\n        return x, float('inf')"], ["def prime_factors(n):\n    \"\"\"\n    Compute the prime factors of an integer.\n    Parameters:\n    n : int\n        The integer to be factorized.\n    Returns:\n    list\n        A list of tuples representing prime factors and their exponents.\n    Examples:\n    >>> prime_factors(18)\n    [(2, 1), (3, 2)]\n    \"\"\"\n    return sympy.ntheory.factorint(n).items()"], ["def is_square_free(n):\n    \"\"\"\n    Check if a number is square-free (not divisible by any perfect square other than 1).\n    \n    Parameters:\n    - n: int, the number to check\n    \n    Returns:\n    - bool, True if n is square-free, False otherwise\n    \n    Examples:\n    >>> is_square_free(30)\n    True\n    >>> is_square_free(12)\n    False\n    \"\"\"\n    if n < 2:\n        return True\n    for p in range(2, int(math.sqrt(n)) + 1):\n        if n % (p * p) == 0:\n            return False\n    return True"], ["def check_digit_inclusion(n, include_digits=None, exclude_digits=None):\n    \"\"\"\n    Check whether the integer `n` includes or excludes certain digits.\n    \n    Parameters:\n        n (int): The integer to check.\n        include_digits (set of int, optional): Digits that should be included in `n`.\n        exclude_digits (set of int, optional): Digits that should be excluded from `n`.\n    \n    Returns:\n        bool: True if `n` meets the criteria, False otherwise.\n    \n    Examples:\n        >>> check_digit_inclusion(567, include_digits={5, 6}, exclude_digits={1})\n        True\n        >>> check_digit_inclusion(560, include_digits={1}, exclude_digits={0})\n        False\n    \"\"\"\n    str_n = str(n)\n    if include_digits and not all(str(digit) in str_n for digit in include_digits):\n        return False\n    if exclude_digits and any(str(digit) in str_n for digit in exclude_digits):\n        return False\n    return True"]], "Powers and Roots": [["def estimate_square_root(n):\n    \"\"\"Estimating the square root of n to the nearest integer.\n    Parameters:\n    n (float): The number to take the root from.\n    Returns:\n    int: The nearest integer of the square root of n.\n    Example:\n     >>> estimate_square_root(200)\n    14\n    \"\"\"\n    return int(n**0.5)", "def estimate_square_root(n):\n    \"\"\"Estimate the square root of a non-perfect square number to nearest integers.\n    \n    Parameters:\n        n (int): The number to estimate the square root for.\n        \n    Returns:\n        tuple: A tuple of integers (low_bound, high_bound) which bounds the square root of n.\n    \n    Examples:\n        >>> estimate_square_root(20)\n        (4, 5)\n    \"\"\"\n    low = int(math.sqrt(n))\n    high = low + 1\n    return (low, high)"], ["def is_square(n):\n    \"\"\"Checks whether a number is a perfect square.\n    Parameters:\n    n (int): Integer input to be checked.\n    Returns:\n    bool: True if n is a perfect square, False otherwise.\n    Example:\n    >>> is_square(25)\n    True\n    >>> is_square(26)\n    False\n    \"\"\"\n    return math.isqrt(n)**2 == n", "def is_perfect_square(n):\n    \"\"\"Check if a number is a perfect square.\n    \n    Parameters:\n        n (int): The number to check.\n        \n    Returns:\n        bool: True if n is a perfect square, otherwise False.\n    \n    Examples:\n        >>> is_perfect_square(16)\n        True\n        >>> is_perfect_square(15)\n        False\n    \"\"\"\n    root = int(math.sqrt(n))\n    return root * root == n"], ["def power_mod(base, exponent, mod):\n    \"\"\"\n    Computes (base ** exponent) % mod efficiently using modular exponentiation.\n    \n    Parameters:\n    - base (int): The base of the power.\n    - exponent (int): The exponent to which the base is raised.\n    - mod (int): The modulus to be applied.\n    \n    Returns:\n    - int: The result of (base ** exponent) % mod.\n    \n    Example:\n    >>> power_mod(2, 10, 1000)\n    24\n    >>> power_mod(3, 3, 7)\n    6\n    \"\"\"\n    result = 1\n    base = base % mod\n    while exponent > 0:\n        if (exponent % 2) == 1:  # If exponent is odd, multiply the base with result\n            result = (result * base) % mod\n        exponent = exponent >> 1  # exponent = exponent / 2\n        base = (base * base) % mod  # base = base * base\n    return result", "def power_mod(base, exponent, mod):\n    \"\"\"\n    Calculate the base raised to the exponent modulo mod.\n    \n    Parameters:\n    base (int): The base number.\n    exponent (int): The power to which the base is raised.\n    mod (int): The modulus to use for the calculation.\n    \n    Returns:\n    int: The result of (base ** exponent) % mod\n    \n    Examples:\n    >>> power_mod(2, 5, 3)\n    2\n    >>> power_mod(3, 2, 4)\n    1\n    \"\"\"\n    return pow(base, exponent, mod)", "def calculate_power(base, exponent, mod=None):\n    \"\"\"\n    Calculate the power of a number.\n    Parameters:\n    base (int, float): The base number.\n    exponent (int, float): The exponent to which the base is raised.\n    mod (int, optional): If specified, perform modulo operation with this number on the result.\n    \n    Returns:\n    result (int, float): The calculated power. If 'mod' is specified, return the result modulo 'mod'.\n    \n    Example:\n    >>> calculate_power(2, 3)\n    8\n    >>> calculate_power(5, -1)\n    0.2\n    >>> calculate_power(2, 0.5)\n    1.4142135623730951\n    >>> calculate_power(10, 9, 7)\n    1\n    \"\"\"\n    import numpy as np\n    result = np.power(base, exponent)\n    if mod is not None:\n        result %= mod\n    return result"], ["def is_cube(n):\n    \"\"\"Checks whether a number is a perfect cube.\n    Parameters:\n    n (int): Integer input to be checked.\n    Returns:\n    bool: True if n is a perfect cube, False otherwise.\n    Example:\n    >>> is_cube(27)\n    True\n    >>> is_cube(28)\n    False\n    \"\"\"\n    x=int(round(n**(1./3)))\n    return x**3 == n", "def is_perfect_cube(n):\n    \"\"\"Check if a number is a perfect cube.\n    \n    Parameters:\n        n (int): The number to check.\n        \n    Returns:\n        bool: True if n is a perfect cube, otherwise False.\n    \n    Examples:\n        >>> is_perfect_cube(27)\n        True\n        >>> is_perfect_cube(20)\n        False\n    \"\"\"\n    cube_root = round(n ** (1. / 3))\n    return cube_root ** 3 == n"], ["def compute_power(base, exponent):\n    \"\"\"\n    Computes the power of a given base raised to an exponent.\n    \n    Parameters:\n    - base (int or float or complex): The base of the exponentiation.\n    - exponent (int or float or complex): The exponent to which the base is raised.\n    \n    Returns:\n    - int or float or complex: The result of base ** exponent.\n    \n    Example:\n    >>> compute_power(2, 3)\n    8\n    >>> compute_power(3 + 4j, 2)\n    (5+24j)\n    \"\"\"\n    return base ** exponent", "def compute_power(base, exponent):\n    \"\"\"\n    Compute the power of a number given the base and the exponent.\n    \n    Parameters:\n    base (int or float): The base number.\n    exponent (float): The exponent to which the base is raised.\n    \n    Returns:\n    float or complex: Result of base raised to the exponent.\n    \n    Examples:\n    >>> compute_power(2, 3)\n    8\n    >>> compute_power(4, 0.5)\n    2.0\n    >>> compute_power(-1, 0.5)\n    (6.123233995736766e-17+1j)\n    \"\"\"\n    return base ** exponent"], ["def simplify_radical_expression(a, b):\n    \"\"\"Simplifies the radical expression sqrt(a / b).\n    \n    Parameters:\n        a (int): The numerator.\n        b (int): The denominator.\n    \n    Returns:\n        str: A string representing the simplified radical form.\n    \n    Examples:\n        >>> simplify_radical_expression(50, 2)\n        '5*sqrt(2)'\n        >>> simplify_radical_expression(18, 9)\n        'sqrt(2)'\n    \"\"\"\n    factor = math.gcd(a, b)\n    a //= factor\n    b //= factor\n    sqrt_a = int(math.sqrt(a))\n    sqrt_b = int(math.sqrt(b))\n    if sqrt_a ** 2 == a and sqrt_b ** 2 == b:\n        return f\"{sqrt_a * sqrt_b}\"\n    elif sqrt_a ** 2 == a:\n        return f\"{sqrt_a}*sqrt({b})\"\n    elif sqrt_b ** 2 == b:\n        return f\"sqrt({a})/{sqrt_b}\"\n    else:\n        return f\"sqrt({a}/{b})\""], ["def list_powers_in_range(start, end, power):\n    \"\"\"List numbers in a specified range that are exact powers.\n    \n    Parameters:\n        start (int): The starting number of the range.\n        end (int): The ending number of the range.\n        power (int): The power to compute.\n    \n    Returns:\n        list: A list of integers that are exact powers in the range.\n    \n    Examples:\n        >>> list_powers_in_range(1, 1000, 3)\n        [1, 8, 27, 64, 125, 216, 343, 512, 729, 1000]\n    \"\"\"\n    lower_bound = math.ceil(start ** (1/power))\n    upper_bound = math.floor(end ** (1/power))\n    return [i**power for i in range(lower_bound, upper;iev\n           erable[upper_boundr+af1])]"], ["def find_pattern(seq):\n    \"\"\"\n    Detect a pattern in a sequence.\n    Parameter:\n    seq (list): Sequence of numbers in which to detect a pattern.\n    Returns:\n    pattern (list): Detected repeating pattern. Return empty list if no pattern is found.\n    Example:\n    >>> find_pattern([1, 2, 3, 1, 2, 3, 1, 2, 3])\n    [1, 2, 3]\n    \"\"\"\n    # Iterate over lengths of potential repeats\n    for i in range(1, len(seq)//2 + 1):\n        if len(seq) % i == 0: # Repeat length must divide sequence length\n            pattern = seq[:i]\n            if pattern * (len(seq) // i) == seq:\n                return pattern\n    return []"], ["def compute_cube_root(n):\n    \"\"\"Compute the cube root of a number.\n    \n    Parameters:\n        n (float|int): The number to find the cube root of.\n        \n    Returns:\n        float: The cube root of the number.\n    \n    Examples:\n        >>> compute_cube_root(27)\n        3.0\n        >>> compute_cube_root(-8)\n        -2.0\n    \"\"\"\n    if n < 0:\n        return -(-n) ** (1. / 3)\n    return n ** (1. / 3)"], ["def prime_factorization(n):\n    \"\"\"\n    Perform prime factorization of a number.\n    Parameter:\n    n (int): An integer to factorize into primes.\n    Returns:\n    factors (dict): A dictionary where the keys are prime factors and values are their frequencies in the factorization.\n    Example:\n    >>> prime_factorization(20)\n    {2: 2, 5: 1}\n    \"\"\"\n    import sympy\n    factors = sympy.factorint(n)\n    return factors"], ["def calculate_root(n, degree):\n    \"\"\"\n    Calculate the nth root of a number.\n    Parameters:\n    n (int, float): The base number.\n    degree (int, float): The degree of root to be calculated.\n    Returns:\n    result (int, float): The calculated nth root.\n    Example:\n    >>> calculate_root(81, 4)\n    3.0\n    \"\"\"\n    import numpy as np\n    result = np.power(n, 1.0/degree)\n    return result"], ["def simplify_expression(expression):\n    \"\"\"\n    Simplifies mathematical expressions involving powers and roots using symbolic math.\n    \n    Parameters:\n    expression (str): The mathematical expression in string form to be simplified.\n    \n    Returns:\n    sympy.core.expr.Expr: The simplified expression.\n    \n    Examples:\n    >>> str(simplify_expression(\"sqrt(x)**2\"))\n    'x'\n    >>> str(simplify_expression(\"x**3 * x**4\"))\n    'x**7'\n    \"\"\"\n    from sympy import simplify, sympify\n    expr = sympify(expression)\n    return simplify(expr)"], ["def simplfy_square_root(n):\n    \"\"\"Find the simplified form of square root of n.\n    Parameters:\n    n (int): Integer input to be checked.\n    Returns:\n    str: Simplified form of square root of n.\n    Example:\n    >>> simplify_square_root(50)\n    '5*sqrt(2)'\n    \"\"\"\n    return sqrt(n)"], ["def nth_root_of_unity(degree, k=1):\n    \"\"\"\n    Computes the k-th nth root of unity using Euler's formula.\n    \n    Parameters:\n    - degree (int): The degree of the root of unity.\n    - k (int): Specifies which nth root of unity to compute.\n    \n    Returns:\n    - complex: The k-th nth root of unity.\n    \n    Example:\n    >>> nth_root_of_unity(4)\n    (1+0j)\n    >>> nth_root_of_unity(3, 1)\n    (-0.4999999999999998+0.8660254037844387j)\n    \"\"\"\n    return cmath.exp(2j * cmath.pi * k / degree)"], ["def find_units_digit(base, exponent):\n    \"\"\"\n    Find the unit's digit of a number raised to an exponent.\n    \n    Parameters:\n    base (int): The base number.\n    exponent (int): The exponent.\n    \n    Returns:\n    int: The unit's digit.\n    \n    Examples:\n    >>> find_units_digit(12, 2)\n    4\n    >>> find_units_digit(7, 3)\n    3\n    \"\"\"\n    # Only last digit of base raised to the power affects the unit's digit.\n    return (base % 10) ** exponent % 10"], ["def calculate_square_and_square_root(n):\n    \"\"\"Find the square and square root of n.\n    Parameters:\n    n (int): Integer input to be checked.\n    Returns:\n    tuple: a tuple of square and square root of n.\n    Example:\n    >>> calculate_square_and_square_root(4)\n    (16, 2.0)\n    \"\"\"\n    return n**2, sqrt(n)"], ["def compute_nth_root(n, r):\n    \"\"\"Computes the nth root of a number r.\n    Parameters:\n    n (int): The root to compute.\n    r (float): The number to take the root from.\n    Returns:\n    float: The nth root of r.\n    Example:\n    >>> compute_nth_root(3, 27)\n    3.0\n    \"\"\"\n    return r**(1/n)"], ["def perfect_squares_in_range(start, end):\n    \"\"\"Find all perfect squares within a range.\n    Parameters:\n    start (int): the start of the range.\n    end (int): the end of the range.\n    Returns:\n    list: List of all perfect squares within the range.\n    Example:\n    >>> perfect_squares_in_range(1, 10)\n    [1, 4, 9]\n    \"\"\"\n    squares = []\n    for num in range(start, end+1):\n        root = math.sqrt(num)\n        if int(root + 0.5) ** 2 == num:\n            squares.append(num)\n    return squares"], ["def list_powers_within_range(min_val, max_val, power):\n    \"\"\"\n    Generates a list of numbers that are perfect powers (such as squares, cubes) within a specified range.\n    \n    Parameters:\n    min_val (int): Minimum value of the range.\n    max_val (int): Maximum value of the range.\n    power (int): The power to consider (2 for squares, 3 for cubes, etc.)\n    \n    Returns:\n    list: A list of integers that are perfect powers within the given range.\n    \n    Examples:\n    >>> list_powers_within_range(1, 100, 2)\n    [1, 4, 9, 16, 25, 36, 49, 64, 81, 100]\n    \n    >>> list_powers_within_range(1, 100, 3)\n    [1, 8, 27, 64]\n    \"\"\"\n    from math import pow\n    n = 1\n    results = []\n    while pow(n, power) <= max_val:\n        if pow(n, power) >= min_val:\n            results.append(int(pow(n, power)))\n        n += 1\n    return results"], ["def calculate_root(value, root_degree, symbolic=False):\n    \"\"\"\n    Calculates the nth root of a specified number and optionally returns a symbolic expression.\n    Parameters:\n    value (float or int): The number from which to extract the root.\n    root_degree (int): The degree of the root (e.g., 2 for square root, 3 for cube root).\n    symbolic (bool): Whether to return the result as a symbolic expression (default is False).\n    \n    Returns:\n    float or sympy.core.expr.Expr: The numerical or symbolic nth root of the value.\n    Examples:\n    >>> calculate_root(16, 2)\n    4.0\n    >>> calculate_root(27, 3, symbolic=True)\n    3\n    \"\"\"\n    if symbolic:\n        from sympy import root, N\n        return root(value, root_degree)\n    else:\n        from math import pow\n        return pow(value, 1 / root_degree)"], ["def compute_square_root(n):\n    \"\"\"Compute the square root of a number.\n    \n    Parameters:\n        n (float|int): The number to find the square root of. Must be non-negative.\n        \n    Returns:\n        float: The square root of the number.\n    \n    Examples:\n        >>> compute_square_root(16)\n        4.0\n        >>> compute_square_root(15)\n        3.872983346207417\n    \"\"\"\n    if n < 0:\n        raise ValueError(\"Cannot compute square root of a negative number.\")\n    return math.sqrt(n)"], ["def simplify_expression_with_root(base, exponent, root_degree):\n    \"\"\"\n    Simplify an expression involving roots and exponents.\n    \n    Parameters:\n    base (int or float): The base number.\n    exponent (int): The exponent, can be negative for roots.\n    root_degree (int): The degree of the root to apply.\n    \n    Returns:\n    float: The simplified result of (base ** (exponent / root_degree)).\n    \n    Examples:\n    >>> simplify_expression_with_root(8, 1, 3)\n    2.0\n    >>> simplify_expression_with_root(16, 1, 4)\n    2.0\n    \"\"\"\n    return base ** (exponent / root_degree)"], ["def compute_root(base, degree):\n    \"\"\"\n    Computes the nth root of a given base.\n    \n    Parameters:\n    - base (int or float): The base whose root is to be computed.\n    - degree (int): The degree of the root.\n    \n    Returns:\n    - float or complex: The degree'th root of base. Returns a complex number if the root is complex.\n    \n    Example:\n    >>> compute_root(16, 2)\n    4.0\n    >>> compute_root(-8, 3)\n    -2.0\n    \"\"\"\n    if base >= 0 or degree % 2 != 0:\n        return base ** (1.0 / degree)\n    else:\n        return -(-base) ** (1.0 / degree) if degree % 2 == 1 else cmath.exp(cmath.log(-base) / degree)"]], "Fractions and Decimals": [["def gcd_lcm(a, b):\n    \"\"\"\n    Calculate the greatest common divisor (GCD) and the least common multiple (LCM) of two integers.\n    Parameters:\n        a (int): The first integer.\n        b (int): The second integer.\n    Returns:\n        tuple: A tuple containing the GCD and LCM of the provided integers.\n    Examples:\n        >>> gcd_lcm(12, 18)\n        (6, 36)\n    \"\"\"\n    factor_a = primefactors(a)\n    factor_b = primefactors(b)\n    common_factors = set(factor_a).intersection(factor_b)\n    gcd_ = 1\n    lcm_ = 1\n  \n    for factor in factor_a + factor_b:\n        if factor in common_factors:\n            gcd_ *= factor\n            common_factors.remove(factor)\n        lcm_ *= factor\n    return gcd_, int(a * b / gcd_)", "def lcm(a, b):\n    \"\"\"\n    Calculate the Least Common Multiple (LCM) of two integers.\n    Parameters:\n    - a (int): First number.\n    - b (int): Second number.\n    Returns:\n    - int: The LCM of the two numbers.\n    Example:\n    >>> lcm(6, 8)\n    24\n    \"\"\"\n    return abs(a * b) // gcd(a, b)"], ["def fraction_operations(fraction1, fraction2, operation='add'):\n    \"\"\"\n    Perform operations (add, subtract, multiply, divide) on two fractions.\n    Parameters:\n    - fraction1 (sympy.Rational): First fraction operand.\n    - fraction2 (sympy.Rational): Second fraction operand.\n    - operation (str): Operation to perform ('add', 'subtract', 'multiply', 'divide').\n    Returns:\n    - sympy.Rational: The result of the operation.\n    Examples:\n    >>> fraction_operations(Rational(1, 3), Rational(1, 6), 'add')\n    1/2\n    >>> fraction_operations(Rational(1, 2), Rational(1, 4), 'subtract')\n    1/4\n    \"\"\"\n    if operation == 'add':\n        return fraction1 + fraction2\n    elif operation == 'subtract':\n        return fraction1 - fraction2\n    elif operation == 'multiply':\n        return fraction1 * fraction2\n    elif operation == 'divide':\n        return fraction1 / fraction2", "def fraction_arithmetic(frac1, frac2, operation='add'):\n    \"\"\"\n    Perform arithmetic operations on two fractions.\n    Parameters:\n        frac1 (Fraction): The first fraction.\n        frac2 (Fraction): The second fraction.\n        operation (str): The operation to perform ('add', 'subtract', 'multiply', 'divide').\n    Returns:\n        Fraction: The result of the arithmetic operation.\n    Examples:\n        >>> fraction_arithmetic(Fraction(1, 3), Fraction(1, 6), 'add')\n        Fraction(1, 2)\n        >>> fraction_arithmetic(Fraction(1, 3), Fraction(1, 6), 'multiply')\n        Fraction(1, 18)\n    \"\"\"\n    if operation == 'add':\n        return frac1 + frac2\n    elif operation == 'subtract':\n        return frac1 - frac2\n    elif operation == 'multiply':\n        return frac1 * frac2\n    elif operation == 'divide':\n        return frac1 / frac2\n    else:\n        raise ValueError(\"Unsupported operation. Choose from 'add', 'subtract', 'multiply', 'divide'.\")"], ["def is_terminating_decimal(numerator, denominator):\n    \"\"\"\n    Determine if a fraction represented by `numerator/denominator` results in a terminating decimal.\n    Parameters:\n        numerator (int): The numerator of the fraction.\n        denominator (int): The denominator of the fraction.\n    Returns:\n        bool: True if the fraction is a terminating decimal, False otherwise.\n    Examples:\n        >>> is_terminating_decimal(1, 8)\n        True\n        >>> is_terminating_decimal(1, 3)\n        False\n    \"\"\"\n    simplified_denominator = denominator // gcd(numerator, denominator)\n    prime_factors_ = primefactors(simplified_denominator)\n    return all(factor in [2, 5] for factor in prime_factors_)", "def does_fraction_terminate(numerator, denominator):\n    \"\"\"\n    Determines if a fraction will terminate or have infinite repeating decimals.\n    \n    Parameters:\n    - numerator (int): Numerator of the fraction.\n    - denominator (int): Denominator of the fraction.\n    \n    Returns:\n    - bool: True if the fraction terminates, False otherwise.\n    \n    Examples:\n    - does_fraction_terminate(1, 2) --> True\n    - does_fraction_terminate(1, 3) --> False\n    \"\"\"\n    # Prime factorization only contains 2's or 5's\n    while denominator % 2 == 0:\n        denominator //= 2\n    while denominator % 5 == 0:\n        denominator //= 5\n    return denominator == 1"], ["def modular_exponent(base, exponent, mod):\n    \"\"\"\n    Calculate base raised to exponent modulo mod using efficient modular exponentiation.\n    Parameters:\n        base (int): The base of the expression.\n        exponent (int): The exponent.\n        mod (int): The modulus for the operation.\n    Returns:\n        int: The result of (base^exponent) % mod.\n    Examples:\n        >>> modular_exponent(2, 10, 1000)\n        24\n    \"\"\"\n    return pow(base, exponent, mod)", "def mod_exp(base, exponent, modulus):\n    \"\"\"\n    Calculate (base^exponent) % modulus using iterative method to handle large numbers efficiently.\n    \n    Parameters:\n    - base (int): the base of the exponential expression.\n    - exponent (int): the exponent.\n    - modulus (int): the modulus.\n    \n    Returns:\n    - int: The result of (base^exponent) % modulus.\n    \n    Example:\n    >>> mod_exp(2, 10, 1000)\n    24\n    \"\"\"\n    result = 1\n    base = base % modulus\n    while exponent > 0:\n        if (exponent % 2) == 1:\n            result = (result * base) % modulus\n        exponent = exponent >> 1\n        base = (base * base) % modulus\n    return result"], ["def simplify_fraction(numerator, denominator):\n    \"\"\"\n    Simplify a fraction using its numerator and denominator.\n    Parameters:\n    - numerator (int): the numerator of the fraction.\n    - denominator (int): the denominator of the short division.\n    Returns:\n    - sympy.Rational: the simplified fraction.\n    Examples:\n    >>> simplify_fraction(10, 100)\n    1/10\n    >>> simplify_fraction(22, 7)\n    22/7\n    \"\"\"\n    return Rational(numerator, denominator)", "def simplify_fraction(numerator, denominator):\n    \"\"\"\n    Simplifies a fraction using the greatest common divisor.\n    Parameters:\n        numerator (int): The numerator of the fraction.\n        denominator (int): The denominator of the fraction.\n    Returns:\n        Fraction: The simplified fraction.\n    Examples:\n        >>> simplify_fraction(8, 20)\n        Fraction(2, 5)\n    \"\"\"\n    common_divisor = math_gcd(numerator, denominator)\n    return Fraction(numerator // common_divisor, denominator // common_divisor)", "def simplify_fraction(numerator, denominator):\n    \"\"\"\n    Simplify a fraction by finding the greatest common divisor of the numerator and denominator.\n    Parameters:\n        numerator (int): The numerator of the fraction.\n        denominator (int): The denominator of the fraction.\n    Returns:\n        Fraction: A simplified Fraction object.\n    Examples:\n        >>> simplify_fraction(8, 20)\n        Fraction(2, 5)\n        >>> simplify_fraction(50, 100)\n        Fraction(1, 2)\n    \"\"\"\n    common_divisor = gcd(numerator, denominator)\n    return Fraction(numerator // common_divisor, denominator // common_divisor)", "def simplify_fraction(numerator, denominator):\n    \"\"\"\n    Simplify a fraction by reducing it to its lowest terms.\n    Parameters:\n    - numerator (int): the numerator of the fraction.\n    - denominator (int): the denominator of the fraction.\n    Returns:\n    - tuple: a simplified fraction as a tuple (new_numerator, new_denominator).\n    Example:\n    >>> simplify_fraction(8, 12)\n    (2, 3)\n    \"\"\"\n    common_divisor = gcd(numerator, denominator)\n    return numerator // common_divisor, denominator // common_divisor"], ["def convert_decimal_to_fraction(decimal_str):\n    \"\"\"\n    Convert a decimal string, which may include a repeating part, to a fraction.\n    Parameters:\n    - decimal_str (str): A string representing the decimal to convert. Repeating parts \n      should be indicated using parentheses.\n    Returns:\n    - sympy.Rational: The fraction representing the decimal.\n    Examples:\n    >>> convert_decimal_to_fraction('1.23(45)')\n    12339/9900\n    \n    >>> convert_decimal_to_fraction('3.142857142857...')\n    22/7\n    \"\"\"\n    # Check if there's a repeating part\n    match = re.match(r'^(\\d*)\\.(\\d*)\\((\\d+)\\)$', decimal_str)\n    if match:\n        whole, non_repeating, repeating = match.groups()\n        non_repeating_length = len(non_repeating)\n        repeating_length = len(repeating)\n        # Convert whole and the non-repeating part to the left of the decimal\n        non_rep_value = int(whole + non_repeating) if non_repeating else int(whole)\n        rep_value = int(repeating)\n        # Calculate the fraction\n        if non_repeating:\n            fraction = Rational(non_rep_hold + rep_value / (10**repeating_length - 1), 10**non_repeating_length * (10**repeating_length - 1))\n        else:\n            fraction = Rational(non_rep_hold + rep_value / (10**repeating_length - 1), 10**repeating_length - 1)\n        \n        return fraction\n    # Handle non-repeating decimal\n    else:\n        return Rational(decimal_str)", "def convert_repeating_decimal_to_fraction(decimal_str):\n    \"\"\"\n    Convert a repeating decimal given as a string to its simplest fractional form.\n    Parameters:\n    - decimal_str (str): The repeating decimal as a string, e.g., \"0.333...\", \"1.256...\"\n    Returns:\n    - sympy.Rational: The fraction form of the repeating decimal.\n    Examples:\n    >>> convert_repeating_decimal_to_fraction('0.333...')\n    1/3\n    >>> convert_repeating_decimal_to_fraction('1.256...')\n    sympy.Rational(1256, 999) - simplified form\n    \"\"\"\n    if '...' not in decimal_str:\n        # No repeating part, simple conversion        \n        return sympy.Rational(decimal_str)\n    \n    non_repeating, repeating = decimal_str.replace('...', '').split('.')\n    repeat_length = len(repeating)\n    non_repeat_length = len(non_repeating) - 1  # Excludes point\n    \n    denominator = 10**repeat_length - 1\n    numerator = int(repeating) + int(non_repeating)*10**repeat_length\n    return sympy.Rational(numerator, denominator * 10**non_repeat, 10)", "def convert_repeating_decimal_to_fraction(decimal_str):\n    \"\"\"\n    Converts a repeating decimal represented as a string to a Fraction object.\n    \n    Parameters:\n    - decimal_str (str): The repeating decimal as string. It should follow the format '0.x(y)',\n      where 'x' is the non-repeating part and 'y' is the repeating part. E.g., '0.3(3)', '0.(142857)'.\n    \n    Returns:\n    - Fraction: The fraction representation of the repeating decimal.\n    \n    Examples:\n    - convert_repeated_decimal_to_fraction('0.3(3)') --> Fraction(1, 3)\n    - convert_repeated_decimal_to_pattern('1.2(56)') --> Fraction(56/495)\n    \"\"\"\n    # Pattern to match repeating decimals in the format 0.xxx(y)\n    match = re.match(r'^(\\d*)\\.(\\d*)\\((\\d+)\\)$', decimal_str)\n    if not match:\n        raise ValueError(\"Decimal format is incorrect. Ensure it's in the format of '0.x(y)'\")\n    # Extract parts of the repeating decimal\n    whole, non_repeating, repeating = match.groups()\n    whole = int(whole) if whole else 0\n    non_repeating_decimal = int(non_repeating) if non_repeating else 0\n    repeating_decimal = int(repeating)\n    \n    # Length of the non repeating and repeating parts\n    len_nr = len(non_repeating)\n    len_r = len(repeating)\n    \n    # Calculate the fraction\n    num = int(non_repeating + repeating) - non_repeating_decimal\n    denom = int('9' * len_r + '0' * len_nr)\n    \n    return Fraction(whole * denom + num, denom)"], ["def prime_factorization(n):\n    \"\"\"\n    Returns the prime factors of a given integer.\n    Parameters:\n        n (int): The number to factorize.\n    Returns:\n        list: A list of prime factors.\n    Examples:\n        >>> prime_factorization(18)\n        [2, 3, 3]\n    \"\"\"\n    factors = []\n    for prime in primefactors(n):\n        count = 0\n        while n % prime == 0:\n            n //= prime\n            count += 1\n        factors.extend([prime] * count)\n    return factors", "def prime_factors(n):\n    \"\"\"\n    Returns the list of prime factors of a given integer n.\n    Parameters:\n    - n (int): the number to factorize.\n    Returns:\n    - list: List of prime factors of n.\n    Example:\n    >>> prime_factors(60)\n    [2, 2, 3, 5]\n    \"\"\"\n    i = 2\n    factors = []\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n            factors.append(i)\n    if n > 1:\n        factors.append(n)\n    return factors"], ["def gcd(*numbers):\n    \"\"\"\n    Calculate the greatest common divisor of a series of integers.\n    Parameters:\n        numbers (int): A series of integer numbers.\n    Returns:\n        int: The greatest common divisor of the numbers.\n    Examples:\n        >>> gcd(8, 12, 16)\n        4\n    \"\"\"\n    return np.gcd.reduce(numbers)"], ["def lcm(*numbers):\n    \"\"\"\n    Calculate the least common multiple of a series of integers.\n    Parameters:\n        numbers (int): A series of integer numbers.\n    Returns:\n        int: The least common multiple of the numbers.\n    Examples:\n        >>> lcm(5, 10, 20)\n        20\n    \"\"\"\n    return np.lcm.reduce(numbers)"], ["def is_prime(num):\n    \"\"\"\n    Check if a number is a prime number.\n    Parameters:\n        num (int): The number to check.\n    Returns:\n        bool: True if the number is a prime, else False.\n    Examples:\n        >>> is_prime(11)\n        True\n        >>> is_prime(4)\n        False\n    \"\"\"\n    return isprime(num)"], ["def add_fractions(frac1, frac2):\n    \"\"\"\n    Add two fractions and return the result in its simplest form.\n    Parameters:\n    - frac1 (Fraction): First fraction.\n    - frac2 (Fraction): Second fraction.\n    Returns:\n    - Fraction: Sum of the two fractions in simplest form.\n    Examples:\n    >>> add_fractions(Fraction(1, 3), Fraction(1, 6))\n    Fraction(1, 2)\n    >>> add_fractions(Fraction(1, 2), Fraction(1, 3))\n    Fraction(5, 6)\n    \"\"\"\n    return frac1 + frac2", "def multiply_fractions(frac1, frac2):\n    \"\"\"\n    Multiply two fractions and return the result in its simplest form.\n    Parameters:\n    - frac1 (Fraction): First fraction.\n    - frac2 (Fraction): Second fraction.\n    Returns:\n    - Fraction: Product of the two fractions in simplest form.\n    Examples:\n    >>> multiply_fractions(Fraction(1, 4), Fraction(2, 3))\n    Fraction(1, 6)\n    \"\"\"\n    return frac1 * frac2", "def add_fractions(frac1, frac2):\n    \"\"\"\n    Add two fractions and return the result in its simplest form.\n    Parameters:\n        frac1 (Fraction): The first fraction.\n        frac2 (Fraction): The second fraction.\n    Returns:\n        Fraction: The sum of the two fractions, in simplest form.\n    Examples:\n        >>> add_fractions(Fraction(1, 2), Fraction(1, 3))\n        Fraction(5, 6)\n    \"\"\"\n    return simplify_fraction(frac1.numerator * frac2.denominator + frac2.numerator * frac1.denominator,\n                             frac1.denominator * frac2.denominator)", "def multiply_fractions(frac1, frac2):\n    \"\"\"\n    Multiply two fractions and return the result in its simplest form.\n    Parameters:\n        frac1 (Fraction): The first fraction.\n        frac2 (Fraction): The second fraction.\n    Returns:\n        Fraction: The product of the two fractions, in simplest form.\n    Examples:\n        >>> multiply_fractions(Fraction(1, 2), Fraction(2, 3))\n        Fraction(1, 3)\n    \"\"\"\n    return simplify_fraction(frac1.numerator * frac2.numerator, frac1.denominator * frac2.denominator)"]], "Floor Function": [["def floor_basic(x):\n    \"\"\"\n    Compute the floor of a number, the greatest integer less than or equal to x.\n    Parameters:\n    x (float): A real number whose floor is to be calculated.\n    Returns:\n    int: The greatest integer less than or equal to x.\n    Examples:\n    >>> floor_basic(3.7)\n    3\n    >>> floor_basic(-1.2)\n    -2\n    \"\"\"\n    return math.floor(x)", "def calculate_floor(x):\n    \"\"\"\n    Calculate the floor (greatest integer less than or equal to) of a given number.\n    Parameters:\n    - x (float): A real number whose floor value is to be calculated.\n    Returns:\n    - int: The floor value of the number.\n    Examples:\n    >>> calculate_floor(3.7)\n    3\n    >>> calculate_floor(-1.2)\n    -2\n    >>> calculate_floor(4.0)\n    4\n    \"\"\"\n    return math.floor(x)", "def compute_floor(x):\n    \"\"\"\n    Compute the floor of a given real number.\n    Parameters:\n    - x (float): The number for which the floor value is to be computed.\n    Returns:\n    - int: The floor value of the input number.\n    Examples:\n    >>> compute_floor(3.7)\n    3\n    >>> compute_floor(-1.2)\n    -2\n    \"\"\"\n    return math.floor(x)"], ["def calculate_floor(value):\n    \"\"\"\n    This function is used to calculate the floor value of a given number. \n    The floor function is the greatest integer less than or equal to the input value.\n    Parameters:\n    value (float): Input number to calculate the floor value\n    Returns:\n    int: floor of the given number\n    Examples:\n    >>> calculate_floor(10.6)\n    10\n    >>> calculate_floor(-2.3)\n    -3\n    \"\"\"\n    return math.floor(value)", "def calculate_floor_sqrt(value):\n    \"\"\"\n    This function is used to calculate the floor value of a square root \n    of given number. For a non-perfect square, it gives the greatest perfect \n    square less than the given number.\n    Parameters:\n    value (float): Input number to calculate the floor value of its square root\n    Returns:\n    int: floor of the square root of the given number\n    Examples:\n    >>> calculate_floor_sqrt(10)\n    3\n    >>> calculate_floor_sqrt(63)\n    7\n    \"\"\"\n    return math.floor(math.sqrt(value))", "def calculate_floor_square(value):\n    \"\"\"\n    This function is used to calculate the floor value of a square\n    of given number. It gives the greatest perfect square less than the \n    square of the given number if it is non-integer.\n    Parameters:\n    value (float): Input number to calculate the floor value of its square \n    Returns:\n    int: floor of the square of the given number\n    Examples:\n    >>> calculate_floor_square(10.5)\n    110\n    >>> calculate_floor_square(2.3)\n    5\n    \"\"\"\n    return math.floor(value**2)"], ["def floor_value(x):\n    \"\"\"\n    Calculate the floor of a given number.\n    Parameters\n    ----------\n    x : float\n        A real number for which the floor value is computed.\n    Returns\n    -------\n    int\n        The largest integer less than or equal to x.\n    Examples\n    --------\n    >>> floor_value(3.7)\n    3\n    >>> floor_value(-1.2)\n    -2\n    \"\"\"\n    from math import floor\n    return floor(x)", "def floor_value(number):\n    \"\"\"\n    Calculates the floor of the given number.\n    Parameters:\n        number (float): The number for which the floor value is to be calculated.\n    \n    Returns:\n        int: The floor value of the given number.\n    \n    Examples:\n    >>> floor_value(3.7)\n    3\n    >>> floor_value(-2.3)\n    -3\n    \"\"\"\n    from math import floor\n    return floor(number)"], ["def floor_function_bounds(value, lower_bound, upper_bound):\n    \"\"\"\n    Determines if the floor of a value falls within a specified integer bounds.\n    Parameters:\n        value (float): The number to check.\n        lower_bound (int): The lower integer boundary.\n        upper_bound (int): The upper integer boundary.\n    \n    Returns:\n        bool: True if the floor of the value is within the bounds, False otherwise.\n    \n    Examples:\n    >>> floor_function_bounds(3.2, 3, 5)\n    True\n    >>> floor_function_bounds(-2.6, -1, 2)\n    False\n    \"\"\"\n    from math import floor\n    floor_value = floor(value)\n    return lower_bound <= floor_value <= upper_bound"], ["def apply_floor_in_expression(expr, value):\n    \"\"\"\n    Apply the floor function within a provided algebraic expression and evaluate it.\n    Parameters:\n    - expr (callable): A function representing an algebraic expression involving the floor function.\n    - value (float): The real number to be substituted into the expression.\n    Returns:\n    - float: The result of evaluating the algebraic expression with the floor function applied.\n    Examples:\n    >>> apply_floor_in_expression(lambda x: math.floor(x/2) + math.floor(x**0.5), 10)\n    5\n    \"\"\"\n    return expr(value)"], ["def iterative_floor_application(start_value, iteration_function, iterations):\n    \"\"\"\n    Repeatedly apply a transformation involving the floor function and observe the result after a defined number of iterations.\n    Parameters\n    ----------\n    start_value : float\n        Initial value where the transformation begins.\n    iteration_function : callable\n        A function that defines the transformation involving the floor to apply.\n    iterations : int\n        Number of times the iteration is applied.\n    Returns\n    -------\n    float\n        Result after applying the defined transformation the number of times specified by 'iterations'.\n    Examples\n    --------\n    >>> iterative_floor_application(4.5, lambda x: x/2, 5)\n    0.140625\n    \"\"\"\n    from math import floor\n    current_value = start_value\n    for _ in range(iterations):\n        current_value = floor(iteration_function(current_value))\n    return current_value", "def iterative_floor_application(initial_value, iterations):\n    \"\"\"\n    Applies the floor function iteratively to a value a specified number of times.\n    Parameters:\n        initial_value (float): The initial number to which the floor function is to be applied.\n        iterations (int): The number of times to apply the floor function.\n    \n    Returns:\n        int: The result after applying the floor function the specified number of times.\n    \n    Examples:\n    >>> iterative_floor_application(3.7, 1)\n    3\n    >>> iterative_floor_application(2.9, 2)\n    2\n    \"\"\"\n    from math import floor\n    for _ in range(iterations):\n        initial_value = floor(initial_value)\n    return initial_value"], ["def evaluate_floor_with_inequality(expr, start, end, step=1):\n    \"\"\"\n    Evaluate an inequality expression involving the floor function across a specified interval.\n    Parameters:\n    - expr (callable): An inequality expression involving a variable and the floor function.\n    - start (int): The start of the interval (inclusive).\n    - end (int): The end of the interval (exclusive).\n    - step (int): The step with which to increment values in the interval.\n    Returns:\n    - list of tuples: Each tuple contains a value and a boolean indicating if the inequality holds.\n    Examples:\n    >>> evaluate_floor_with_inequality(lambda x: math.floor(x) >= x - 1, 1, 10)\n    [(1, True), (2, True), (3, True), ...]\n    \"\"\"\n    results = []\n    for x in range(start, end, step):\n        results.append((x, expr(x)))\n    return results"], ["def floor_of_square_root(x):\n    \"\"\"\n    Calculate the floor of the square root of a number.\n    Parameters:\n    x (float): A real number from which the square root is calculated, and then floored.\n    Returns:\n    int: The floor of the square root of x.\n    Examples:\n    >>> floor_of_square_root(67)\n    8\n    >>> floor_of_square_root(81)\n    9\n    \"\"\"\n    return math.floor(math.sqrt(x))"], ["def evaluate_floor_inequality(x, expected_value, inequality_type):\n    \"\"\"\n    Evaluate whether an inequality involving the floor of a number holds.\n    Parameters\n    ----------\n    x : float\n        The real number input to the floor function.\n    expected_value : int\n        The integer against which the floor of x is compared.\n    inequality_type : str\n        Type of inequality used for comparison {'<=', '>=', '=', '<', '>'}.\n    Returns\n    -------\n    bool\n        True if the inequality holds, False otherwise.\n    Examples\n    --------\n    >>> evaluate_floor_inequality(5.5, 5, '=')\n    True\n    >>> evaluate_floor_inequality(3.2, 3, '<')\n    False\n    \"\"\"\n    from math import floor\n    floor_x = floor(x)\n    inequalities = {\n        '<=': floor_x <= expected_value,\n        '>=': floor_x >= expected_value,\n        '=': floor_x == expected_value,\n        '<': floor_x < expected_value,\n        '>': floor_x > expected_value\n    }\n    return inequalities[inequality_type]"], ["def floor_product(a, b):\n    \"\"\"\n    Calculate the product of the floors of two numbers.\n    Parameters:\n    a (float): The first number.\n    b (float): The second number.\n    Returns:\n    int: The product of the floor values of the two numbers.\n    Examples:\n    >>> floor_product(3.7, 4.1)\n    12\n    >>> floor_product(-1.2, -2.5)\n    2\n    \"\"\"\n    return math.floor(a) * math.floor(b)"], ["def enhanced_floor_arithmetic(expression, function=None):\n    \"\"\"\n    Evaluates a complex mathematical expression potentially involving other functions,\n    and then computes the floor value of the result. Optionally, a function could be applied outside the floor.\n    Parameters:\n    - expression (str): The mathematical expression as a string.\n    - function (callable, optional): A function to be applied after taking the floor.\n    Returns:\n    - int: The floor value of the evaluated expression or the final result after applying another function.\n    Examples:\n    >>> enhanced_floor_arithmetic(\"math.sqrt(65)\")\n    8\n    >>> enhanced_floor_arithmetic(\"(5*3 + 2)/3\")\n    5\n    >>> enhanced_floor_arithmetic(\"3.5 + 4*1.1\")\n    7\n    >>> enhanced_floor_arithmetic(\"math.sqrt(81)\", math.sin)  # Since sin(9) = 0.412\n    0\n    \"\"\"\n    result = eval(expression)\n    floor_result = math.floor(result)\n    if function:\n        return function(floor_result)\n    return floor_result"], ["def floor_of_expression(expr):\n    \"\"\"\n    Evaluate the floor of an expression, potentially including more complex operations like factorials.\n    `expr` should be a string that Python can evaluate directly using the `eval` function.\n    Parameters:\n    expr (str): The string representation of the mathematical expression to floor.\n    Returns:\n    int: The floor of the evaluated expression.\n    Examples:\n    >>> floor_of_expression('5/3')\n    1\n    >>> floor_of_expression('math.sqrt(64) + 0.9')\n    8\n    \"\"\"\n    return math.floor(eval(expr))"], ["def calculate_floor_negative_fraction(value):\n    \"\"\"\n    This function is used to calculate the floor value of a negative fraction.\n    The floor function is the integer less than the negative fraction.\n    Parameters:\n    value (str): Input negative fraction to calculate the floor value (format \"-numerator/denominator\")\n    Returns:\n    int: floor of the given negative fraction.\n    Examples:\n    >>> calculate_floor_negative_fraction(\"-3/2\")\n    -2\n    >>> calculate_floor_negative_fraction(\"-1/8\")\n    -1\n    \"\"\"\n    fractional_part = Fraction(value)\n    return math.floor(fractional_part)"], ["def calculate_floor_mixed_fraction(value):\n    \"\"\"\n    This function is used to calculate the floor value of a mixed number.\n    The floor function is the integer part of the mixed number.\n    Parameters:\n    value (str): Input mixed number to calculate the floor value (format \"whole_numerator/denominator\")\n    Returns:\n    int: floor of the mixed number\n    Examples:\n    >>> calculate_floor_mixed_fraction(\"1_3/2\")\n    1\n    >>> calculate_floor_mixed_fraction(\"5_1/8\")\n    5\n    \"\"\"\n    whole, fraction = value.split('_')\n    fractional_value = Fraction(fraction)\n    total_value = int(whole) + fractional_value\n    return int(total_value)"]], "Prime Numbers": [["def sum_of_distinct_prime_factors(n):\n    \"\"\"\n    Sum the distinct prime factors of an integer n.\n    Parameters:\n        n (int): The number to find the prime factors of and sum them.\n    Returns:\n        int: Sum of the distinct prime factors of n.\n    Examples:\n        >>> sum_of_distinct_prime_factors(18)\n        5 # 2 + 3\n        >>> sum_of_distinct_prime_factors(28)\n        10 # 2 + 7\n    \"\"\"\n    return sum(prime_factors(n).keys())", "def sum_prime_factors(num):\n    \"\"\"\n    Sums all unique prime factors of a specific number.\n    Parameters:\n        num (int): The number whose prime factors are to be summed.\n    Returns:\n        int: The sum of all unique prime factors.\n    Examples:\n    >>> sum_prime_factors(30)\n    10  # 2 + 3 + 5\n    >>> sum_prime_factors(50)\n    7   # 2 + 5\n    \"\"\"\n    return sum(prime_factors(num))"], ["def prime_factors(n):\n    \"\"\"\n    Compute the prime factors of a given integer n.\n    \n    Parameters:\n    n : int\n        Integer to factorize into its prime factors.\n        \n    Returns:\n    list\n        A list containing the prime factors of the integer n.\n    \n    Examples:\n    >>> prime_factors(18)\n    [2, 3, 3]\n    >>> prime_factors(17)\n    [17]\n    \"\"\"\n    from sympy import primefactors\n    return primefactors(n)", "def prime_factors(num):\n    \"\"\"\n    Find all prime factors of a given number.\n    Parameters:\n        num (int): The number to factorize.\n    Returns:\n        list: A list of prime numbers which are the factors of the given number.\n    Examples:\n    >>> prime_factors(18)\n    [2, 3]\n    >>> prime_factors(56)\n    [2, 7]\n    \"\"\"\n    from sympy import primefactors\n    return primefactors(num)"], ["def is_prime(n):\n    \"\"\"\n    Checks if a number is a prime.\n    Parameters:\n    - n (int): The number to check for primality.\n    Returns:\n    - bool: True if the number is prime, False otherwise.\n    Examples:\n    >>> is_prime(11)\n    True\n    >>> is_prime(4)\n    False\n    \"\"\"\n    from math import sqrt\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i <= sqrt(n):\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "def is_prime(n):\n    \"\"\"\n    Check if the integer n is a prime number.\n    \n    Parameters:\n    n : int\n        The integer to be checked for primality.\n        \n    Returns:\n    bool\n        Returns True if n is a prime number, otherwise returns False.\n    \n    Examples:\n    >>> is_prime(11)\n    True\n    >>> is_prime(4)\n    False\n    \"\"\"\n    import math\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "def is_prime(number):\n    \"\"\"\n    Determine whether a number is a prime.\n    \n    Parameters:\n    number (int): The number to check for primality.\n    \n    Returns:\n    bool: True if the number is a prime, False otherwise.\n    \n    Examples:\n    >>> is_prime(2)\n    True\n    >>> is_prime(15)\n    False\n    \"\"\"\n    if number <= 1:\n        return False\n    if number <= 3:\n        return True\n    if number % 2 == 0 or number % 3 == 0:\n        return False\n    i = 5\n    while i * i <= number:\n        if number % i == 0 or number % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "def is_prime(n):\n    \"\"\"\n    Check if the number n is a prime number.\n    \n    Parameters:\n        n (int): The number to check for primality.\n    Returns:\n        bool: True if n is a prime number, False otherwise.\n    \n    Examples:\n        >>> is_prime(29)\n        True\n        >>> is_prime(100)\n        False\n    \"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "def is_prime(number):\n    \"\"\"\n    Determine if the provided number is a prime.\n    \n    Parameters:\n    number (int): The number to test for primality.\n    \n    Returns:\n    bool: True if `number` is a prime, otherwise False.\n    \n    Examples:\n    >>> is_prime(11)\n    True\n    >>> is_prime(4)\n    False\n    \"\"\"\n    return sympy.isprime(number)", "def is_prime(num):\n    \"\"\"\n    Check if a number is a prime.\n    Parameters:\n        num (int): The number to check for primality.\n    Returns:\n        bool: True if the number is prime, False otherwise.\n    Examples:\n    >>> is_prime(11)\n    True\n    >>> is_prime(4)\n    False\n    \"\"\"\n    if num <= 1:\n        return False\n    if num <= 3:\n        return True\n    if num % 2 == 0 or num % 3 == 0:\n        return False\n    i = 5\n    while i * i <= num:\n        if num % i == 0 or num % (i + 2) == 0:\n            return False\n        i += 6\n    return True"], ["def mersenne_primes(limit):\n    \"\"\"\n    Generate a list of Mersenne primes within a given range.\n    Parameters:\n    - limit (int): Upper limit for prime numbers to check for Mersenne primes.\n    Returns:\n    - list: A list of Mersenne primes up to the specified limit.\n    Examples:\n    >>> mersenne_primes(19)\n    [3, 7, 31]\n    \"\"\"\n    primes = generate_primes(2, limit)\n    mersenne_primes = [2 ** p - 1 for p in primes if is_prime(2 ** p - 1)]\n    return mersenne_primes", "def find_mersenne_primes(limit):\n    \"\"\"\n    Identify all Mersenne primes less than a specified limit.\n    \n    Parameters:\n    limit (int): The upper limit for prime numbers to check for Mersenne primes.\n    \n    Returns:\n    list: A list of Mersenne primes less than the given limit.\n    \n    Examples:\n    >>> find_mersenne_primes(50)\n    [3, 7, 31]\n    \"\"\"\n    import math\n    prime_list = generate_primes(2, int(math.log2(limit)) + 1)\n    mersenne_primes = []\n    for prime in prime_left:\n        m_prime = 2 ** prime - 1\n        if m_prime > limit:\n            break\n        if is_prime(m_prime):\n            mersenne_primes.append(m_prime)\n    return mersenne_primes", "def generate_mersenne_primes(limit):\n    \"\"\"\n    Generate all Mersenne primes less than a given limit.\n    Mersenne primes are of the form 2**p - 1 where p is also a prime.\n    \n    Parameters:\n    limit (int): The upper limit for prime generation. (exclusive)\n    \n    Returns:\n    list: A list of Mersenne primes less than `limit`.\n    \n    Examples:\n    >>> generate_mersenne_primes(50)\n    [3, 7, 31]\n    \"\"\"\n    primes = generate_primes(2, int(sympy.log(limit, 2)) + 1)\n    mersenne_primes = [2**p - 1 for p in primes if is_prime(2**p - 1)]\n    return [mp for mp in mersenne_primes if mp < limit]"], ["def prime_factors(n):\n    \"\"\"\n    Generate the prime factors of an integer n along with their respective powers.\n    \n    Parameters:\n        n (int): The number to factorize.\n    Returns:\n        dict: A dictionary where the keys are the prime factors and the values are their powers.\n    \n    Examples:\n        >>> prime_factors(18)\n        {2: 1, 3: 2}\n        >>> prime_factors(360)\n        {2: 3, 3: 2, 5: 1}\n    \"\"\"\n    from collections import defaultdict\n    factors = defaultdict(int)\n    # Check for number of 2s that divide n\n    while n % 2 == 0:\n        factors[2] += 1\n        n //= 2\n    # n must be odd at this point\n    for i in range(3, int(math.sqrt(n)) + 1, 2):\n        # While i divides n, add i and divide n\n        while n % i == 0:\n            factors[i] += 1\n            n //= i\n    # This condition is to check if n is a prime number\n    # greater than 2\n    if n > 2:\n        factors[n] += 1\n    return dict(factors)"], ["def is_mersenne_prime(p):\n    \"\"\"\n    Check if a number is a Mersenne prime.\n    Parameters:\n    - p (int): The exponent to check if 2^p - 1 is a Mersenne prime.\n    Returns:\n    - bool: True if 2^p - 1 is a Mersenne prime, False otherwise.\n    Examples:\n    >>> is_mersenne_prime(5)\n    True\n    >>> is_mersenne_prime(6)\n    False\n    \"\"\"\n    mersenne_candidate = 2 ** p - 1\n    return is_prime(mersenne_candidate)"], ["def largest_prime_factor(n):\n    \"\"\"\n    Find the largest prime factor of an integer n.\n    \n    Parameters:\n    n : int\n        Integer to find the largest prime factor of.\n        \n    Returns:\n    int\n        The largest prime factor of the integer n.\n    \n    Examples:\n    >>> largest_prime(INTRODUCING1)\n    7_NTEHARUDE\n    \"\"\"\n    factors = prime_factors(n)\n    return max(factors) if factors else None", "def largest_prime_factor(n):\n    \"\"\"\n    Find and return the largest prime factor of the integer n.\n    \n    Parameters:\n        n (int): The number to evaluate for the largest prime factor.\n    Returns:\n        int: The largest prime factor of n.\n    \n    Examples:\n        >>> largest_prime_factor(69)\n        23\n        >>> largest_prime_factor(50)\n        5\n    \"\"\"\n    factors = prime_factors(n)\n    if factors:\n        return max(factors.keys())\n    return None", "def largest_prime_factor(num):\n    \"\"\"\n    Find the largest prime factor of a given number.\n    Parameters:\n        num (int): The number whose largest prime factor is to be found.\n    Returns:\n        int: The largest prime factor of the given number.\n    Examples:\n    >>> largest_prime_factor(45)\n    5\n    >>> largest_prime_factor(88)\n    11\n    \"\"\"\n    return max(prime_factors(num)) if num > 1 else None"], ["def generate_primes(start, end):\n    \"\"\"\n    Generate a list of prime numbers within a given range.\n    Parameters:\n    - start (int): The starting integer of the range.\n    - end (int): The ending integer of the range.\n    Returns:\n    - list: A list of prime numbers within the specified range.\n    Examples:\n    >>> generate_primes(10, 20)\n    [11, 13, 17, 19]\n    \"\"\"\n    if start <= 1:\n        start = 2\n    primes = []\n    for num in range(start, end + 1):\n        if is_prime(num):\n            primes.append(num)\n    return primes", "def generate_primes(start, end):\n    \"\"\"\n    Generate all prime numbers in the specified range [start, end].\n    \n    Parameters:\n    start (int): The starting integer of the range (inclusive).\n    end (int): The end integer of the range (inclusive).\n    \n    Returns:\n    list: A list of prime numbers within the specified range.\n    \n    Examples:\n    >>> generate_primes(10, 50)\n    [11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47]\n    \"\"\"\n    return list(sympy.primerange(start, end))"], ["def generate_primes(min_val, max_val):\n    \"\"\"\n    Generate all prime numbers in a specified range.\n    \n    Parameters:\n    min_val (int): The minimum value of the range.\n    max_val (int): The maximum value of the range.\n    \n    Returns:\n    list: A list of prime numbers within the specified range.\n    \n    Examples:\n    >>> generate_primes(10, 20)\n    [11, 13, 17, 19]\n    \"\"\"\n    def sieve(n):\n        is_prime = [True] * (n+1)\n        p = 2\n        while (p * p <= n):\n            if (is_prime[p] == True):\n                for i in range(p * p, n+1, p):\n                    is_prime[i] = False\n            p += 1\n        return [p for p in range(2, n+1) if is_prime[p]]\n    return [p for p in sieve(max_val) if p >= min_val]"], ["def generate_primes(limit):\n    \"\"\"\n    Generate all prime numbers less than `limit`.\n    \n    Parameters:\n    limit : int\n        Upper integer limit to generate prime numbers up to.\n        \n    Returns:\n    list\n        A list of all prime numbers less than `limit`.\n    \n    Introduction of some _placeholder:\n    \"_introducin1g_examples\n        \n    >>> generate_pr1ites(stron100)\n    Reasons for customizing fun...\n    [2_, 3,PARSE_PRIMACE_placeholder, par_ARY_UP_TO-da_ters and documentation correctly. HerruH_anchor should make sure.\")\n    purpose of them_.\"\"\"\n    from sympy import primerange\n    return list(primerain_range_KEY_PLACEncoder, etc.dilimit)))"]], "Powers and Exponents": [["def convert_to_base(number, base):\n    \"\"\"\n    Convert a decimal number to a given base.\n    \n    Parameters:\n    number (int): The number in decimal format to convert.\n    base (int): The base to which the number should be converted.\n    Returns:\n    str: The representation of the number in the target base as a string.\n    Examples:\n    >>> convert_to_base(10, 3)\n    '101'\n    >>> convert_to_numeric_base(255, 16)\n    'FF'\n    \"\"\"\n    if base < 2:\n        raise ValueError(\"Base must be at least 2\")\n    result = \"\"\n    n = number\n    while n > 0:\n        remainder = n % base\n        if remainder > 9:\n            remainder = chr(remainder + 55)  # Converts remainder over 9 to A, B, C.. for bases higher than 10.\n        else:\n            remainder = str(remainder)\n        result = remainder + result\n        n = n // base\n    return result or \"0\"", "def convert_to_base(number, base):\n    \"\"\"\n    Converts a given integer to a specified base and returns the number as a string.\n    \n    Parameters:\n    - number (int): The number to convert.\n    - base (int): The base to which the number should be converted.\n    Returns:\n    - str: The representation of the number in the new base.\n    \n    Examples:\n    >>> convert_to_base(255, 16)\n    'FF'\n    >>> convert_to_base(10, 2)\n    '1010'\n    \"\"\"\n    if number == 0:\n        return \"0\"\n    digits = []\n    while number:\n        digits.append(int(number % base))\n        number //= base\n    digits = digits[::-1]\n    return ''.join(str(x) for x in digits)", "def convert_from_base(str_number, base):\n    \"\"\"\n    Converts a given base-n string to its decimal integer form.\n    \n    Parameters:\n    - str_number (str): The string representation of the number.\n    - base (int): The base of the given number.\n    Returns:\n    - int: The decimal representation of the number.\n    \n    Examples:\n    >>> convert_from_base('FF', 16)\n    255\n    >>> convert_from_base('1010', 2)\n    10\n    \"\"\"\n    return int(str_number, base)", "def decimal_to_base(num, base):\n    \"\"\"\n    Convert a decimal number to a given base.\n    \n    Parameters:\n        num (int): The decimal number to convert.\n        base (int): The base to convert the number to.\n        \n    Returns:\n        A string representing the number in the target base.\n    \n    Examples:\n        >>> decimal_to_base(10, 2)\n        '1010'\n        >>> decimal_to_base(255, 16)\n        'FF'\n    \"\"\"\n    if num == 0:\n        return \"0\"\n    digits = []\n    while num:\n        digits.append(int(num % base))\n        num //= base\n    digits = digits[::-1]\n    return ''.join(str(x) for x in digits)", "def base_to_decimal(num_str, base):\n    \"\"\"\n    Convert a number from a given base to decimal.\n    \n    Parameters:\n        num_str (str): The number in the original base as a string.\n        base (int): The base of the given number.\n        \n    Returns:\n        The decimal integer of the base number.\n    \n    Examples:\n        >>> base_to_decimal('1010', 2)\n        10\n        >>> base_to_decimal('FF', 16)\n        255\n    \"\"\"\n    return int(num_str, base)"], ["def power_of_number(base, exponent):\n    \"\"\"\n    Calculate the power of a given number.\n    \n    Parameters:\n        base (int or float or complex): The base of the power.\n        exponent (int): The exponent to which the base is raised.\n        \n    Returns:\n        The result of base raised to the power of exponent.\n    \n    Examples:\n        >>> power_of_number(2, 5)\n        32\n        >>> power_of_number(3, -1)\n        0.3333\n    \"\"\"\n    return base ** exponent", "def mod_power(base, exponent, mod):\n    \"\"\"\n    Calculate the power of a given number modulo another number.\n    \n    Parameters:\n        base (int): The base of the power.\n        exponent (int): The exponent to which the base is raised.\n        mod (int): The modulus.\n        \n    Returns:\n        The result of (base raised to the power of exponent) modulo mod.\n    \n    Examples:\n        >>> mod_power(2, 5, 3)\n        2\n        >>> mod_power(3, 3, 5)\n        2\n    \"\"\"\n    return pow(base, exponent, mod)"], ["def find_power_cycle(base, modulus):\n    \"\"\"\n    Finds the cycle of powers for a given base under a specified modulus.\n    \n    Parameters:\n    - base (int): The base number whose powers' cycle is to be determined.\n    - modulus (int): The modulus under which the powers are calculated.\n    Returns:\n    - list: A list containing the cycle of results of base ** exponent % modulus.\n    \n    Examples:\n    >>> find_power_cycle(2, 5)\n    [1, 2, 4, 3]\n    \"\"\"\n    seen = {}\n    cycle = []\n    value = 1\n    \n    while True:\n        next_value = (base * value) % modulus\n        if next_value in seen:\n            break\n        seen[next_value] = True\n        cycle.append(next_value)\n        value = next_value\n    \n    return cycle", "def find_cyclical_power_pattern(base, modulo):\n    \"\"\"\n    Determine the cycle length and pattern of the base raised to successive powers modulo a given number.\n    Parameters:\n    - base (int): The base that is being repeatedly exponentiated.\n    - modulo (int): The modulus for the modular arithmetic to find the cycle of powers.\n    Returns:\n    - cycle (list): The list representing one full cycle of results for base**power % modulo\n    Examples:\n    >>> find_cyclical_power_pattern(2, 3)\n    [1, 2]\n    >>> find_cyclical_power_pattern(3, 4)\n    [3, 1]\n    \"\"\"\n    seen = {}\n    result = []\n    power = 1\n    while True:\n        value = calculate_power(base, power, modulo)\n        if value in seen:\n            start = seen[value]\n            return result[start:]\n        seen[value] = len(result)\n        result.append(value)\n        power += 1"], ["def simplify_exponential_expression(base, exponent):\n    \"\"\"\n    Simplifies expressions involving powers using properties of exponents.\n    Parameters:\n    - base (int, float, Fraction): The base of the operation.\n    - exponent (int, float, Fraction): The power to which the base is raised.\n    Returns:\n    - simplified result based on the exponent rules.\n    Examples:\n    >>> simplify_exponential_expression(2, -3)\n    0.125\n    >>> simplify_exponential_expression(-3, 2)\n    9\n    \"\"\"\n    import fractions\n    if isinstance(base, fractions.Fraction) or isinstance(exponent, fractions.Fraction):\n        result = fractions.Fraction(base) ** fractions.Fraction(exponent)\n    else:\n        result = base ** exponent\n    return result"], ["def power_calculator(base, exponent, modulus=None):\n    \"\"\"\n    Calculate the power of a number optionally under a modular constraint.\n    \n    Parameters:\n    - base (int or float): The base number.\n    - exponent (int): The exponent to which the base is raised.\n    - modulus (int, optional): If provided, the function returns the result of (base ** exponent) % modulus.\n    Returns:\n    - int or float: Result of base raised to the power of exponent, possibly under modulus.\n    \n    Examples:\n    >>> power_calculator(2, 10)\n    1024\n    >>> power_calculator(2, 10, 1000)\n    24\n    \"\"\"\n    if modulus is not None:\n        return pow(base, exponent, modulus)\n    else:\n        return pow(base, exponent)", "def power_with_mod(base, exponent, modulus=None):\n    \"\"\"\n    Calculate the power of a number with an optional modulus.\n    \n    Parameters:\n    base (int, float): The base number.\n    exponent (int): The exponent (power) to which the base is raised. Should be an integer.\n    modulus (int, optional): If provided, the function returns base raised to the power exponent, modulo modulus.\n    Returns:\n    int or float: Result of the base raised to the power exponent, optionally modulo modulus.\n    Examples:\n    >>> power_with_mod(2, 10)\n    1024\n    >>> power_with_mod(2, 5, 3)\n    2\n    \"\"\"\n    if modulus is not None:\n        return pow(base, exponent, modulus)\n    else:\n        return pow(base, exponent)", "def modular_exponentiation(base, exponent, modulus=None):\n    \"\"\"\n    Calculates the power of a base raised to an exponent under optional modulo.\n    \n    Parameters:\n    - base (int or float): The base of the expression.\n    - exponent (int): The exponent to which the base is raised.\n    - modulus (int, optional): The modulus under which the power is computed.\n    Returns:\n    - result (int or float): The result of the base raised to the exponent,\n                             potentially under the modular operation.\n    \n    Examples:\n    >>> modular_exponentiation(2, 10)\n    1024\n    >>> modular_exponentiation(2, 10, 1000)\n    24\n    >>> modular_exponentiation(3, 5)\n    243\n    \"\"\"\n    import sympy\n    if modulus is not None:\n        return sympy.Pow(base, exponent, evaluate=False) % modulus\n    else:\n        return sympy.Pow(base, exponent, evaluate=False)", "def power_mod(base, exponent, modulus=None):\n    \"\"\"\n    Computes the power of a base raised to an exponent, optionally modulo a number.\n    \n    Parameters:\n    - base (int or float): The base of the exponentiation.\n    - exponent (int): The exponent to raise the base to.\n    - modulus (int, optional): The modulus to perform the operation under. Defaults to None.\n    Returns:\n    - result (int or float): The result of `base` raised to the power `exponent`, possibly modulo `modulus`.\n    \n    Examples:\n    >>> power_mod(2, 10)\n    1024\n    >>> power_mod(2, 10, 1000)\n    24\n    \"\"\"\n    if modulus is not None:\n        return pow(base, exponent, modulus)\n    else:\n        return pow(base, exponent)", "def calculate_power(base, exponent, modulo=None):\n    \"\"\"\n    Calculate the power of a number with an optional modular reduction.\n    Parameters:\n    - base (int or float): The base of the exponentiation.\n    - exponent (int): The exponent to raise the base to. Negative exponents result in fractional powers.\n    - modulo (int, optional): The modulus to apply for modular exponentiation. If None, standard exponentiation is performed.\n    Returns:\n    - result (int or float): The result of the exponentiation, possibly modulo 'modulo'.\n    Examples:\n    >>> calculate_power(2, 10)\n    1024\n    >>> calculate_power(2, 5, 3)\n    2\n    >>> calculate_power(3, -1)\n    0.3333333333333333\n    \"\"\"\n    from sympy import Pow\n    if modulo is not None:\n        return Pow(base, exponent, evaluate=False) % modulo\n    else:\n        return Pow(base, exponent, evaluate=False)"], ["def totient(n):\n    \"\"\"\n    Compute Euler's Totient function φ(n), the count of integers up to n that are coprime with n.\n    \n    Parameters:\n    - n (int): The number for which to calculate the totient function.\n    \n    Returns:\n    - int: The value of φ(n).\n    \n    Examples:\n    >>> totient(9)\n    6\n    \"\"\"\n    return sp.totient(n)"], ["def algebraic_power(expression, exponent):\n    \"\"\"\n    Calculate and simplify high powers of algebraic expressions.\n    \n    Parameters:\n        expression (str): The algebraic expression as a string.\n        exponent (int): The power to which the expression is raised.\n        \n    Returns:\n        Simplified form of the expression raised to the given power.\n    \n    Examples:\n        >>> algebraic_power(\"x + 1\", 2)\n        x**2 + 2*x + 1\n    \"\"\"\n    x = symbols('x')\n    expanded_expr = (eval(expression))**exponent\n    return simplify(expanded_expr)"], ["def power_properties(base, exponent, cycle_length=None):\n    \"\"\"\n    Determines properties of powers like last digit or cycles in the power sequence.\n    \n    Parameters:\n    - base (int): The base of the expression.\n    - exponent (int): The exponent to which the base is raised.\n    - cycle_length (int, optional): The length of the cycle to explore for powers properties.\n    Returns:\n    - properties (dict): A dictionary containing properties such as last_digit and periodicity.\n    \n    Examples:\n    >>> power_properties(2, 13)\n    {'last_digit': 2}\n    >>> power_properties(3, 10, 4)\n    {'last_digit': 1, 'periodicity': ['3', '9', '7', '1']}\n    \"\"\"\n    results = {}\n    if cycle_length:\n        periodicity = [(base**i) % 10 for i in range(1, cycle_length + 1)]\n        results['periodicity'] = periodicity\n    last_digit = (base**exponent) % 10\n    results['last_digit'] = last_digit\n    return results"], ["def sum_geometric_sequence(start, ratio, n):\n    \"\"\"\n    Calculates the sum of the first n terms of a geometric sequence.\n    Parameters:\n    - start (float): The first term of the sequence.\n    - ratio (float): The common ratio between terms of the sequence.\n    - n (int): The number of terms to sum.\n    Returns:\n    - float: The sum of the first n terms of the geometric sequence.\n    \n    Examples:\n    >>> sum_geometric_sequence(1, 2, 10)\n    1023.0\n    \"\"\"\n    if ratio == 1:\n        return start * n\n    else:\n        return start * (1 - ratio ** n) / (1 - ratio)"], ["def geometric_series_sum(a, r, n):\n    \"\"\"\n    Calculate the sum of the first n terms of a geometric series.\n    \n    Parameters:\n    a (int, float): The first term of the series.\n    r (int, float): The common ratio between successive terms.\n    n (int): The number of terms to sum.\n    Returns:\n    int or float: The sum of the first n terms of the geometric series.\n    Examples:\n    >>> geometric_series_sum(1, 2, 4)\n    15\n    >>> geometric_series_r_sum(3, 3, 3)\n    39\n    \"\"\"\n    if r == 1:\n        return n * a\n    else:\n        return a * (1 - r ** n) / (1 - r)"], ["def binary_representation(number):\n    \"\"\"\n    Return the binary representation of a number.\n    \n    Parameters:\n    number (int): The number to represent in binary.\n    Returns:\n    str: Binary string representation of the number.\n    Examples:\n    >>> binary_representation(10)\n    '1010'\n    >>> binary_representation(31)\n    '11111'\n    \"\"\"\n    return bin(number)[2:]"]], "Perfect Squares": [["def is_product_perfect_square(*args):\n    \"\"\"\n    Determine if the product of given integers is a perfect square.\n    \n    Parameters:\n        *args (int): Variable length integer arguments whose product is to be checked.\n    \n    Returns:\n        bool: True if the product is a perfect square, False otherwise.\n    \"\"\"\n    product_factorization = {}\n    for number in args:\n        factors = factorint(number)\n        for prime, exponent in factors.items():\n            if prime in product_factorization:\n                product_factorization[prime] += exponent\n            else:\n                product_factorization[prime] = exponent\n    return all(exp % 2 == 0 for exp in product_factorization.values())", "def is_product_perfect_square(*args):\n    \"\"\"\n    Check if the product of given integers is a perfect square.\n    Parameters:\n        *args (int): A variable-length list of integers.\n    Returns:\n        bool: True if the product is a perfect square, False otherwise.\n    Example:\n        >>> is_product_perfect_square(2, 8)\n        True\n        >>> is_product_perfect_square(3, 5, 2)\n        False\n    \"\"\"\n    product = math.prod(args)\n    root = math.isqrt(product)\n    return root * root == product"], ["def generate_pythagorean_triples(limit):\n    \"\"\"\n    Generate a list of Pythagorean triples up to a given limit.\n    Parameters:\n    - limit (int): The maximum value for the hypotenuse.\n    Returns:\n    - List[tuple]: A list of tuples, each containing a Pythagorean triple (a, b, c).\n    Examples:\n    >>> generate_pythagorean_triples(15)\n    [(3, 4, 5), (6, 8, 10), (5, 12, 13)]\n    \"\"\"\n    triples = []\n    for c in range(5, limit + 1):\n        for a in range(3, int(c/2) + 1):\n            b = math.sqrt(c * c - a * a)\n            if b == int(b):\n                triples.append((a, int(b), c))\n    return triples", "def generate_pythagorean_triples(limit):\n    \"\"\"\n    Generate Pythagorean triples up to a certain limit.\n    \n    Parameters:\n        limit (int): The maximum value of the hypotenuse in the triples.\n    \n    Returns:\n        list of tuples: All Pythagorean triples `(a, b, c)` where `c <= limit`.\n        \n    Examples:\n        >>> generate_pythagorean_triples(15)\n        [(3, 4, 5), (6, 8, 10), (5, 12, 13)]\n    \"\"\"\n    triples = []\n    for c in range(5, limit+1):\n        for a in range(1, c):\n            b_squared = c*c - a*a\n            b = int(math.sqrt(b_squared))\n            if b * b == b_squared and b > a:\n                triples.append((a, b, c))\n    return triples"], ["def check_perfect_square(number):\n    \"\"\"\n    Determine if the given number is a perfect square.\n    \n    Parameters:\n    number (int): The number to check.\n    \n    Returns:\n    bool: True if the number is a perfect square, False otherwise.\n    \n    Examples:\n    >>> check_perfect_square(16)\n    True\n    >>> check_perfect_square(20)\n    False\n    \"\"\"\n    root = math.isqrt(number)\n    return root * root == number", "def is_perfect_square(n):\n    \"\"\"\n    Check if a given number is a perfect square.\n    Parameters:\n    - n (int): The number to check.\n    Returns:\n    - bool: True if n is a perfect square, False otherwise.\n    Examples:\n    >>> is_perfect_square(16)\n    True\n    >>> is_perfect_square(14)\n    False\n    \"\"\"\n    root = int(math.sqrt(n))\n    return n == root * root", "def perfect_square_checker(n):\n    \"\"\"\n    Check if a number is a perfect square.\n    Parameters:\n    - n (int): The number to be checked.\n    Returns:\n    - bool: True if `n` is a perfect square, False otherwise.\n    \n    Examples:\n    >>> perfect_square_checker(16)\n    True\n    >>> perfect_square_checker(14)\n    False\n    \"\"\"\n    root = math.isqrt(n)\n    return root * root == n", "def is_perfect_square(n):\n    \"\"\"\n    Check if a number is a perfect square.\n    \n    Parameters:\n        n (int): The number to check.\n    \n    Returns:\n        bool: True if n is a perfect integer square, False otherwise.\n    \"\"\"\n    if n < 0:\n        return False\n    root = math.isqrt(n)\n    return n == root * root", "def is_perfect_square(n):\n    \"\"\"\n    Determine whether a number is a perfect square.\n    \n    Parameters:\n        n (int): The number to test for being a perfect square.\n        \n    Returns:\n        bool: True if `n` is a perfect square, False otherwise.\n        \n    Examples:\n        >>> is_perfect_square(16)\n        True\n        >>> is_perfect_square(14)\n        False\n    \"\"\"\n    if n < 0:\n        return False\n    root = int(math.sqrt(n))\n    return root * root == n", "def is_perfect_square(n):\n    \"\"\"\n    Determine whether a given integer `n` is a perfect square.\n    \n    Parameters:\n    -----------\n    n : int\n        The integer to check for being a perfect square.\n    \n    Returns:\n    --------\n    bool\n        True if `n` is a perfect square, False otherwise.\n        \n    Example:\n    --------\n    >>> is_perfect_square(16)\n    True\n    >>> is_perfect_square(17)\n    False\n    \"\"\"\n    from math import isqrt\n    root = isqrt(n)\n    return root * root == n", "def is_perfect_square(n):\n    \"\"\"\n    Check if a number n is a perfect square.\n    \n    Parameters:\n        n (int): The number to be checked.\n    Returns:\n        bool: True if n is a perfect square, otherwise False.\n    \n    Example:\n        >>> is_perfect_square(16)\n        True\n        >>> is_perfect_square(20)\n        False\n    \"\"\"\n    if n < 0:\n        return False\n    root = math.isqrt(n)\n    return root * root == n", "def is_perfect_square(n):\n    \"\"\"\n    Check if a number is a perfect square.\n    \n    Parameters:\n        n (int): The number to check.\n    \n    Returns:\n        bool: True if n is a perfect square, False otherwise.\n        \n    Examples:\n        >>> is_perfect_square(16)\n        True\n        >>> is_perfect_square(14)\n        False\n    \"\"\"\n    root = math.isqrt(n)\n    return root * root == n", "def is_perfect_square(n):\n    \"\"\"\n    Check if a number is a perfect square.\n    Parameters:\n        n (int): The number to check.\n    Returns:\n        bool: True if n is a perfect square, False otherwise.\n    \"\"\"\n    if n < 0:\n        return False\n    root = math.isqrt(n)\n    return root * root == n"], ["def perfect_squares_by_digit_sum(limit, digit_sum):\n    \"\"\"\n    List all perfect squares up to a limit where the sum of the digits matches the specified digit_sum.\n    Parameters:\n        limit (int): The upper limit of numbers to consider.\n        digit_sum (int): The required sum of the digits.\n    Returns:\n        List[int]: A list of perfect squares matching the digit sum criteria.\n    \"\"\"\n    from functools import reduce\n    perfect_squares = list_perfect_squares(1, limit)\n    return [num for num in perfect_squares if reduce(lambda x, y: x + y, map(int, str(num))) == digit_sum]"], ["def last_digit_of_squares():\n    \"\"\"\n    Lists the possible last digits of perfect squares in a decimal system.\n    Returns:\n        set: A set containing digits that are the last digits of a perfect square.\n    \"\"\"\n    return {i * i % 10 for i in range(10)}"], ["def generate_perfect_squares(min_val, max_val):\n    \"\"\"\n    Generate a list of perfect squares within the given range [min_val, max_val].\n    \n    Parameters:\n    min_val (int): The minimum value of the range (inclusive).\n    max_val (int): The maximum value of the range (inclusive).\n    \n    Returns:\n    list: List of perfect squares within the specified range.\n    \n    Examples:\n    >>> generate_perfect_squares(1, 100)\n    [1, 4, 9, 16, 25, 36, 49, 64, 81, 100]\n    \"\"\"\n    lower_bound = math.ceil(math.sqrt(min_val))\n    upper_bound = math.floor(math.sqrt(max.remove(main_val)))\n    return [i*i for i in range(lower_bound, upper_bound + 1)]", "def generate_perfect_squares(min_val, max_val):\n    \"\"\"\n    Generate all perfect squares within a given range.\n    \n    Parameters:\n        min_val (int): The minimum range value.\n        max_val (int): The maximum range value.\n    \n    Returns:\n        list of int: A list containing all perfect squares in the specified range.\n    \"\"\"\n    start = math.ceil(math.sqrt(min_val))\n    end = math.floor(math.sqrt(max_val))\n    return [x*x for x in range(start, end + 1)]"], ["def find_next_perfect_square(n):\n    \"\"\"\n    Find the smallest perfect square greater than a given number.\n    Parameters:\n    - n (int): The number to exceed.\n    Returns:\n    - int: The next perfect square.\n    Examples:\n    >>> find_next_perfect_square(15)\n    16\n    >>> find_next_perfect_square(25)\n    36\n    \"\"\"\n    root = int(math.sqrt(n)) + 1\n    return root ** 2", "def find_prev_perfect_square(n):\n    \"\"\"\n    Find the largest perfect square less than a given number.\n    Parameters:\n    - n (int): The number to be less than.\n    Returns:\n    - int: The previous perfect square.\n    Examples:\n    >>> find_prev_perfect_square(30)\n    25\n    >>> find_prev_perfect_square(26)\n    25\n    \"\"\"\n    root = int(math.sqrt(n)) - 1\n    return root ** 2 if root > 0 else -1  # Handle edge case for small n values"], ["def count_perfect_squares(a, b):\n    \"\"\"\n    Count all perfect squares within the range [a, b].\n    Parameters:\n        a (int): The lower bound of the range (inclusive).\n        b (int): The upper bound of the range (inclusive).\n    Returns:\n        int: The count of perfect squares within the range.\n    \"\"\"\n    squares = list_perfect_squares(a, b)\n    return len(squares)"], ["def perfect_square_divisors(n):\n    \"\"\"\n    Find all perfect square divisors of n based on its prime factorization.\n    Parameters:\n        n (int): The number for which to find perfect square divisors.\n    \n    Returns:\n        list: List of all perfect square divisors of n.\n    \n    Example:\n        >>> perfect_square_divisors(72)\n        [1, 4, 9, 36]\n    \"\"\"\n    factors = factorint(n)\n    divisors = {1}\n    for p, exp in factors.items():\n        # Since we want perfect squares, consider only even exponents\n        for e in range(2, exp+1, 2):  # Step by 2 to maintain even exponents\n            divisors.add(p ** e)\n    return sorted(divisors)"], ["def consecutive_perfect_squares_difference(n):\n    \"\"\"\n    Calculate and return differences between the first `n` consecutive perfect squares.\n    \n    Parameters:\n        n (int): Number of consecutive perfect squares to consider.\n        \n    Returns:\n        list: Differences between consecutive perfect squares.\n    \n    Examples:\n        >>> consecutive_perfect_squares_difference(5)\n        [3, 5, 7, 9]\n    \"\"\"\n    squares = [i * i for i in range(1, n + 1)]\n    differences = [squares[i] - squares[i-1] for i in range(1, n)]\n    return differences"], ["def list_perfect_squares(a, b):\n    \"\"\"\n    List all perfect squares within the range [a, b].\n    Parameters:\n        a (int): The lower bound of the range (inclusive).\n        b (int): The upper bound of the range (inclusive).\n    Returns:\n        List[int]: A list containing all the perfect squares within the range.\n    \"\"\"\n    if a > b:\n        return []\n    # Find smallest square number >= a\n    start = math.ceil(math.sqrt(a))\n    end = math.floor(math.sqrt(b))\n    return [i * i for i in range(start, end + 1)]"], ["def perfect_squares_range(lower, upper):\n    \"\"\"\n    Compute the number of perfect squares between two integer bounds using properties of consecutive squares.\n    \n    Parameters:\n    -----------\n    lower : int\n        The lower inclusive bound of the range.\n    upper : int\n        The upper inclusive bound of the range.\n    \n    Returns:\n    --------\n    int\n        The number of perfect squares in the range [lower, upper].\n    \n    Example:\n    --------\n    >>> perfect_squares_range(1, 100)\n    10\n    \"\"\"\n    from math import isqrt\n    lower_bound = isqrt(lower)\n    upper_bound = isqrt(upper)\n    if lower_bound * lower_bound < lower:\n        lower_bound += 1\n    return max(0, upper_bound - lower_bound + 1)"], ["def perfect_squares_by_last_digit(limit, last_digit):\n    \"\"\"\n    Find all perfect squares up to `limit` that end with `last_digit`.\n    \n    Parameters:\n    -----------\n    limit : int\n        The upper boundary to search for perfect squares.\n    last_digit : int\n        The last digit that the perfect squares must end with.\n    \n    Returns:\n    --------\n    list\n        A list of perfect squares up to `limit` ending with the given `last_digit`.\n        \n    Example:\n    --------\n    >>> perfect_squares_by_last_digit(100, 4)\n    [4, 64]\n    \"\"\"\n    return [k for k in perfect_squares_up_to(limit) if str(k)[-1] == str(last_digit)]"], ["def difference_of_consecutive_squares(n):\n    \"\"\"\n    Compute the difference between squares of consecutive integers up to n.\n    \n    Parameters:\n        n (int): The limit of the consecutive numbers.\n    \n    Returns:\n        list: Differences between the squares of each pair of consecutive integers.\n        \n    Examples:\n        >>> difference_of_consecutive_squares(10)\n        [3, 5, 7, 9, 11, 13, 15, 17, 19]\n    \"\"\"\n    return [2 * i + 1 for i in range(1, n)]"], ["def list_perfect_squares(start, end):\n    \"\"\"\n    List all perfect squares within a specified range.\n    Parameters:\n    - start (int): The start of the range.\n    - end (int): The end of the range.\n    Returns:\n    - List[int]: A list of all perfect squares within the range.\n    Examples:\n    >>> list_perfect_squares(1, 30)\n    [1, 4, 9, 16, 25]\n    \"\"\"\n    squares = []\n    root_start = int(math.sqrt(start))\n    root_end = int(math.sqrt(end))\n    for root in range(root_start, root_end + 1):\n        square = root ** 2\n        if square >= start and square <= end:\n            squares.append(square)\n    return squares", "def count_perfect_squares(start, end):\n    \"\"\"\n    Count the number of perfect squares within a range (inclusive).\n    Parameters:\n    - start (int): The starting number of the range.\n    - end (int): The ending number of the range.\n    Returns:\n    - int: The count of perfect squares between `start` and `end`.\n    \n    Examples:\n    >>> count_perfect_squares(1, 10)\n    3  # (1, 4, 9)\n    >>> count_perfect_squares(4, 17)\n    3  # (4, 9, 16)\n    \"\"\"\n    start_root = math.ceil(math.sqrt(start))\n    end_root = math.floor(math.sqrt(end))\n    if start_root > end_root:\n        return 0\n    return end_root - start_root + 1", "def perfect_squares_in_range(start, end):\n    \"\"\"\n    Generate all perfect squares within a specified range [start, end].\n    \n    Parameters:\n        start (int): The start of the range (inclusive).\n        end (int): The end of the range (inclusive).\n        \n    Returns:\n        list: List of all perfect squares in the range.\n    \n    Examples:\n        >>> perfect_squares_in_range(1, 100)\n        [1, 4, 9, 16, 25, 36, 49, 64, 81, 100]\n    \"\"\"\n    start_root = math.ceil(math.sqrt(start))\n    end_root = math.floor(math.sqrt(end))\n    return [i * i for i in range(start_root, end_root + 1)]", "def count_perfect_squares(start, end):\n    \"\"\"\n    Count the number of perfect squares in the inclusive range [start, end].\n    \n    Parameters:\n    -----------\n    start : int\n        The starting value of the range.\n    end : int\n        The ending value of the range.\n    \n    Returns:\n    --------\n    int\n        The count of perfect squares within the specified range.\n    \n    Example:\n    --------\n    >>> count_perfect_squares(1, 10)\n    3  # 1, 4, 9\n    \"\"\"\n    from math import isqrt\n    lower_bound = isqrt(start)\n    upper_bound = isqrt(end)\n    square_count = upper_bound - lower_bound\n    if is_perfect_square(start):\n        square_count += 1\n    return square_count", "def generate_perfect_squares(start, end):\n    \"\"\"\n    Generate a list of perfect squares between start and end (inclusive).\n    \n    Parameters:\n        start (int): The start of the range.\n        end (int): The end of the range.\n    \n    Returns:\n        list: List of perfect squares within the given range.\n    \n    Example:\n        >>> generate_perfect_squares(1, 100)\n        [1, 4, 9, 16, 25, 36, 49, 64, 81, 100]\n    \"\"\"\n    root_start = math.ceil(math.sqrt(start))\n    root_end = math.floor(math.sqrt(end))\n    return [x * x for x in range(root_start, root_end + 1)]", "def find_perfect_squares_in_range(start, end):\n    \"\"\"\n    Find all perfect squares in a specified range.\n    \n    Parameters:\n        start (int): The starting value of the range (inclusive).\n        end (int): The ending value of the range (inclusive).\n    \n    Returns:\n        list: A list of all perfect squares in the given range.\n        \n    Examples:\n        >>> find_perfect_squares_in_range(1, 100)\n        [1, 4, 9, 16, 25, 36, 49, 64, 81, 100]\n    \"\"\"\n    squares = []\n    current = math.ceil(math.sqrt(start))\n    square = current * current\n    while square <= end:\n        squares.append(square)\n        current += 1\n        square = current * current\n    return squares"], ["def perfect_squares_up_to(n):\n    \"\"\"\n    Generate all perfect squares less than or equal to `n`.\n    \n    Parameters:\n    -----------\n    n : int\n        Upper limit for the perfect square values.\n        \n    Returns:\n    --------\n    list\n        A list of all perfect squares ≤ `n`.\n    \n    Example:\n    --------\n    >>> perfect_squares_up_to(10)\n    [1, 4, 9]\n    \"\"\"\n    from math import isqrt\n    return [i*i for i in range(1, isqrt(n)+1)]"], ["def next_perfect_square(n):\n    \"\"\"\n    Find the next perfect square after a given square n.\n    \n    Parameters:\n        n (int): The reference square.\n    \n    Returns:\n        int: The next perfect square after n.\n    \n    Example:\n        >>> next_perfect_square(25)\n        36\n    \"\"\"\n    if is_perfect_square(n):\n        next_root = math.isqrt(n) + 1\n        return next_root * next_root\n    return None"], ["def consecutive_square_difference(n):\n    \"\"\"\n    Calculate the difference between squares of consecutive integers up to n.\n    \n    Parameters:\n        n (int): The upper limit of the integer range (inclusive).\n    \n    Returns:\n        list of tuples: Each tuple contains (n, (n+1)^2 - n^2).\n    \"\"\"\n    return [(x, (x+1)**2 - x**2) for x in range(1, n)]"], ["def perfect_square_divisors(number):\n    \"\"\"\n    Calculate all divisors of a number that are perfect squares.\n    \n    Parameters:\n    number (int): The number for which to find perfect square divisors.\n    \n    Returns:\n    list: All divisors of the input number that are also perfect squares.\n    \n    Examples:\n    >>> perfect_square_divisors(36)\n    [1, 4, 9, 36]  # 36 has divisors 1, 2, 3, 4, 6, 9, 12, 18, 36 of which 1, 4, 9, 36 are perfect squares\n    \"\"\"\n    divisors = set()\n    for i in range(1, int(math.sqrt(number)) + 1):\n        if number % i == 0:  # i is a divisor\n            if check_perfect_square(i):\n                divisors.add(i)\n            if check_perfect_square(number // i):\n                divisors.add(number // i)\n    return sorted(list(divisors))"], ["def perfect_square_proximity(number, tolerance):\n    \"\"\"\n    Identify if the given number is within the specified tolerance of being a perfect square.\n    \n    Parameters:\n    number (int): The target number.\n    tolerance (int): The tolerance within which the proximity to a perfect square is acceptable.\n    \n    Returns:\n    bool: True if the number is within the specified tolerance to being a perfect square, False otherwise.\n    \n    Examples:\n    >>> perfect_square_proximity(27, 2)\n    True  # Since 25 is a perfect square and |27-25| <= 2\n    >>> perfect_square_proximity(50, 1)\n    False  # Since the nearest perfect square (49 or 64) has a difference greater than 1\n    \"\"\"\n    root = math.isqrt(number)\n    proximal_square_low = root * root\n    proximal_square_high = (root + 1) * (root + 1)\n    return abs(proximal_square_low - number) <= tolerance or abs(proximal_square_high - number) <= tolerance"], ["def last_digit_perfect_squares(limit):\n    \"\"\"\n    Identify perfect squares up to a certain limit and their last digits.\n    Parameters:\n    - limit (int): The upper limit to which calculation is done.\n    Returns:\n    - dict: A dictionary with keys as the last digit and values as lists of perfect squares up to `limit` sharing that last digit.\n    \n    Examples:\n    >>> last_digit_perfect_squares(20)\n    {0: [0, 4, 9, 16], 1: [1], 4: [], 5: [25], 6: [36], 9: []}\n    \"\"\"\n    from collections import defaultdict\n    result = defaultdict(list)\n    for i in range(math.isqrt(limit) + 1):\n        sq = i * i\n        d = sq % 10\n        result[d].append(sq)\n    return dict(result)"], ["def is_difference_perfect_square(a, b):\n    \"\"\"\n    Determine if the difference between two numbers is a perfect square.\n    Parameters:\n    - a (int): The first number.\n    - b (int): The second number.\n    Returns:\n    - bool: True if the difference is a perfect square, False otherwise.\n    Examples:\n    >>> is_difference_perfect_square(26, 1)\n    True\n    >>> is_difference_perfect_square(30, 1)\n    False\n    \"\"\"\n    difference = abs(a - b)\n    return is_perfect_square(difference)"]], "Factors and Multiples": [["def prime_factorization(number):\n    \"\"\"\n    Compute the prime factorization of a given integer.\n    Parameters\n    ----------\n    number : int\n        The integer to factorize.\n    Returns\n    -------\n    factors : dict\n        A dictionary where keys are the prime factors and values are their exponents.\n    \n    Examples\n    --------\n    >>> prime_factorization(20)\n    {2: 2, 5: 1}\n    \n    >>> prime_factorization(1001)\n    {7: 1, 11: 1, 13: 1}\n    \n    \"\"\"\n    factors = factorint(number)\n    return factors", "def prime_factorization(n):\n    \"\"\"\n    Compute the prime factorization of a given integer.\n    Parameters:\n        n (int): The integer to factorize.\n    \n    Returns:\n        dict: A dictionary where keys are the prime factors and values are their respective powers.\n    Examples:\n        >>> prime_factorization(18)\n        {2: 1, 3: 2}\n        >>> prime_factorization(56)\n        {2: 3, 7: 1}\n    \"\"\"\n    factorization = sympy.ntheory.factorint(n)\n    return factorization", "def prime_factorization(n):\n    \"\"\"Compute the prime factorization of an integer n.\n    \n    Parameters:\n        n (int): The integer to factorize.\n    \n    Returns:\n        Dict[int, int]: Dictionary where keys are prime factors and values are their corresponding exponents.\n    \n    Examples:\n        >>> prime_factorization(360)\n        {2: 3, 3: 2, 5: 1}\n    \"\"\"\n    from sympy import primefactors, isprime\n    \n    factors = {}\n    for p in primefactors(n):\n        count = 0\n        temp = n\n        while temp % p == 0:\n            count += 1\n            temp //= p\n        factors[p] = count\n    return factors", "def prime_factorization(n):\n    \"\"\"\n    Perform prime factorization of a given number and return a dictionary of prime factors with their powers.\n    Parameters:\n    n (int): The number to prime factorize.\n    Returns:\n    Counter: Counter object with prime as keys and their powers as values.\n    Examples:\n    >>> prime_factorization(36)\n    Counter({2: 2, 3: 2})\n    \"\"\"\n    primes = Counter()\n    factor = 2\n    while factor * factor <= n:\n        while (n % factor) == 0:\n            primes[factor] += 1\n            n //= factor\n        factor += 1\n    if n > 1:\n        primes[n] += 1\n    return primes", "def prime_factors(n):\n    \"\"\"\n    Compute the prime factors of a given number along with their exponents.\n    Parameters:\n        n (int): The integer to be factorized.\n    \n    Returns:\n        dict: Dictionary with prime factors as keys and their exponents as values.\n    \n    Examples:\n        >>> prime_factors(56)\n        {2: 3, 7: 1}\n        >>> prime_factors(360)\n        {2: 3, 3: 2, 5: 1}\n    \"\"\"\n    return factorint(n)"], ["def lcm(x, y):\n    \"\"\"\n    Compute the least common multiple of two numbers x and y.\n    \n    Parameters:\n    x : int\n        First number.\n    y : int\n        Second number.\n    \n    Returns:\n    int\n        The least common multiple of x and y.\n    \n    Examples:\n    >>> lcm(12, 18)\n    36\n    >>> lcm(5, 13)\n    65\n    \"\"\"\n    if x == 0 or y == 0:\n        return 0\n    return abs(x * y) // gcd(x, y)", "def lcm(a, b):\n    \"\"\"\n    Compute the least common multiple of two numbers.\n    Parameters:\n        a (int): The first integer.\n        b (int): The second integer.\n    \n    Returns:\n        int: The least common multiple of a and b.\n    \n    Examples:\n        >>> lcm(12, 15)\n        60\n        >>> lcm(5, 7)\n        35\n    \"\"\"\n    return abs(a * b) // gcd(a, b)"], ["def compute_gcd(a, b):\n    \"\"\"Compute the greatest common divisor (GCD) of two numbers a and b.\n    \n    Parameters:\n        a (int): First number.\n        b (int): Second number.\n    \n    Returns:\n        int: The GCD of a and b.\n    \n    Examples:\n        >>> compute_gcd(48, 180)\n        12\n    \"\"\"\n    from math import gcd\n    return gcd(a, b)", "def gcd(a, b):\n    \"\"\"\n    Compute the greatest common divisor of two numbers.\n    Parameters:\n        a (int): The first integer.\n        b (int): The second integer.\n    \n    Returns:\n        int: The greatest common divisor of a and b.\n    \n    Examples:\n        >>> gcd(54, 24)\n        6\n        >>> gcd(17, 100)\n        1\n    \"\"\"\n    while b:\n        a, b = b, a % b\n    return abs(a)"], ["def extended_gcd_lcm_calc(numbers):\n    \"\"\"\n    Calculate the gcd and lcm of a list of numbers using the reduce function.\n    Parameters:\n        numbers (list): List of integers.\n    \n    Returns:\n        tuple: (gcd, lcm) of the list of numbers.\n    \n    Examples:\n        >>> extended_gcd_lcm_calc([48, 180, 640])\n        (4, 5760)\n        >>> extended_gcd_lcm_calc([21, 7, 14])\n        (7, 42)\n    \"\"\"\n    gcd_result = reduce(gcd, numbers)\n    lcm_result = reduce(lcm, numbers)\n    return gcd_result, lcm_result"], ["def count_divisors(number):\n    \"\"\"\n    Count the total number of divisors of an integer based on its prime factorization.\n    Parameters\n    ----------\n    number : int\n        The integer whose divisors are to be counted.\n    Returns\n    -------\n    count : int\n        Total number of divisors.\n    \n    Examples\n    --------\n    >>> count_divisors(28)\n    6  # 1, 2, 4, 7, 14, 28\n    \n    >>> count_divisors(1001)\n    8  # 1, 7, 11, 13, 77, 91, 143, 1001\n    \"\"\"\n    factors = prime_factorization(number)\n    count = 1\n    for exponent in factors.values():\n        count *= (exponent + 1)\n    return count", "def count_divisors_from_factors(factorization):\n    \"\"\"\n    Count the number of divisors of a number given its prime factorization.\n    Parameters:\n    factorization (Counter): Prime factorization result from prime_factorization function.\n    Returns:\n    int: The total number of divisors of the number.\n    Examples:\n    >>> count_divisors_from_factors(Counter({2: 2, 3: 2}))\n    9\n    \"\"\"\n    divisors = 1\n    for power in factorization.values():\n        divisors *= (power + 1)\n    return divisors"], ["def get_multiples_in_range(base, start, end):\n    \"\"\"\n    List all multiples of a given base number within a specified range.\n    Parameters:\n    base (int): The base number whose multiples are to be found.\n    start (int): The starting point of the range (inclusive).\n    end (int): The ending point of the range (inclusive).\n    Returns:\n    List[int]: A list of all multiples of base within the range [start, end].\n    Examples:\n    >>> get_multiples_in_range(3, 1, 20)\n    [3, 6, 9, 12, 15, 18]\n    \"\"\"\n    start = ((start + base - 1) // base) * base  # Round start up to the nearest multiple of base\n    return list(range(start, end + 1, base))"], ["def lcm_multiple(*numbers):\n    \"\"\"\n    Compute the least common multiple (LCM) of multiple numbers.\n    \n    Parameters:\n    numbers : tuple\n        A tuple containing the numbers.\n    \n    Returns:\n    int\n        The LCM of the provided numbers.\n    \n    Examples:\n    >>> lcm_multiple(5, 10, 20)\n    20\n    >>> lcm_multiple(7, 11)\n    77\n    \"\"\"\n    return reduce(lcm, numbers)"], ["def prime_factors(n):\n    \"\"\"\n    Returns the prime factorization of the given integer `n` as a dictionary\n    where keys are the prime factors and values are the corresponding exponents.\n    \n    Parameters:\n    n : int\n        The integer to factorize.\n    \n    Returns:\n    dict\n        A dictionary of prime factors with their exponents.\n    \n    Examples:\n    >>> prime_factors(18)\n    {2: 1, 3: 2}\n    >>> prime_factors(100)\n    {2: 2, 5: 2}\n    \"\"\"\n    factors = {}\n    # Check the number of 2s in n\n    while n % 2 == 0:\n        factors[2] = factors.get(2, 0) + 1\n        n //= 2\n    # n must be odd at this point, thus a skip of 2 is possible\n    for i in range(3, int(math.sqrt(n)) + 1, 2):\n        while (n % i == 0):\n            factors[i] = factors.get(i, 0) + 1\n            n //= i\n    # This condition is to check if n is a prime number greater than 2\n    if n > 2:\n        factors[n] = 1\n    return factors"], ["def are_coprime(x, y):\n    \"\"\"\n    Check if two numbers are coprime (i.e., their GCD is 1).\n    \n    Parameters:\n    x : int\n        First number.\n    y : int\n        Second number.\n    \n    Returns:\n    bool\n        True if the numbers are coprime, else False.\n    \n    Examples:\n    >>> are_coprime(5, 9)\n    True\n    >>> are_coprime(12, 18)\n    False\n    \"\"\"\n    return gcd(x, y) == 1"], ["def is_perfect_square(n):\n    \"\"\"\n    Determine if a number is a perfect square.\n    Parameters:\n    n (int): The number to check.\n    Returns:\n    bool: True if n is a perfect square, otherwise False.\n    Examples:\n    >>> is_perfect_square(16)\n    True\n    >>> is_perfect_square(14)\n    False\n    \"\"\"\n    sqrt_n = int(math.sqrt(n))\n    return sqrt_n * sqrt_n == n"], ["def get_factors(n):\n    \"\"\"\n    Compute all factors of a given number.\n    Parameters:\n    n (int): The number to find factors for.\n    Returns:\n    List[int]: A list of all positive factors of n.\n    Examples:\n    >>> get_factors(28)\n    [1, 2, 4, 7, 14, 28]\n    \"\"\"\n    factors = set()\n    for i in range(1, int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            factors.add(i)\n            factors.add(n // i)\n    return sorted(factors)"], ["def gcd_multiple(*numbers):\n    \"\"\"\n    Compute the greatest common divisor (GCD) of multiple numbers.\n    \n    Parameters:\n    numbers : tuple\n        A tuple containing the numbers.\n    \n    Returns:\n    int\n        The GCD of the provided numbers.\n    \n    Examples:\n    >>> gcd_multiple(24, 36, 48)\n    12\n    >>> gcd_multiple(21, 35)\n    7\n    \"\"\"\n    return reduce(gcd, numbers)"], ["def count_divisors(n):\n    \"\"\"Count the number of divisors of the given integer n.\n    \n    Parameters:\n        n (int): The number to find the divisor count for.\n    \n    Returns:\n        int: The number of divisors of n.\n    \n    Examples:\n        >>> count_divisors(28)\n        6\n    \"\"\"\n    return len(list_divisors(n))"], ["def list_prime_factors(n):\n    \"\"\"List all prime factors of the given integer n.\n    \n    Parameters:\n        n (int): The number to find prime factors for.\n    \n    Returns:\n        List[int]: List containing all the prime factors of n.\n    \n    Examples:\n        >>> list_prime_factors(360)\n        [2, 3, 5]\n    \"\"\"\n    from sympy import primefactors\n    return primefactors(n)"], ["def gcd_lcm_calculator(*numbers):\n    \"\"\"\n    Calculate the Greatest Common Divisor (GCD) and the Least Common Multiple (LCM) for a set of integers.\n    \n    Parameters:\n        numbers (int): A sequence of integers for which to compute the GCD and LCM.\n    \n    Returns:\n        tuple: A tuple containing two elements; the first is the GCD and the second is the LCM of the given integers.\n    Examples:\n        >>> gcd_lcm_calculator(8, 12)\n        (4, 24)\n        >>> gcd_lcm_calculator(18, 34, 56)\n        (2, 2856)\n    \"\"\"\n    from math import gcd\n    from functools import reduce\n    \n    def lcm(a, b):\n        return abs(a*b) // gcd(a, b)\n    \n    overall_gcd = reduce(gcd, numbers)\n    overall_lcm = reduce(lcm, numbers, 1)\n    \n    return (overall_gcd, overall_lcm)"], ["def check_prime(number):\n    \"\"\"\n    Check if a number is a prime number.\n    Parameters\n    ----------\n    number : int\n        The integer to check for primality.\n    Returns\n    -------\n    is_prime : bool\n        True if number is prime, False otherwise.\n    \n    Examples\n    --------\n    >>> check_prime(29)\n    True\n    \n    >>> check_prime(30)\n    False\n    \"\"\"\n    return isprime(number)"], ["def list_divisors(n):\n    \"\"\"List all divisors of the given integer n.\n    \n    Parameters:\n        n (int): The number to find divisors for.\n    \n    Returns:\n        List[int]: List containing all the divisors of n.\n    \n    Examples:\n        >>> list_divisors(28)\n        [1, 2, 4, 7, 14, 28]\n    \"\"\"\n    from math import isqrt\n    divisors = set()\n    for i in range(1, isqrt(n) + 1):\n        if n % i == 0:\n            divisors.add(i)\n            divisors.add(n // i)\n    return sorted(divisors)"], ["def gcd(x, y):\n    \"\"\"\n    Compute the greatest common divisor of two numbers x and y.\n    \n    Parameters:\n    x : int\n        First number.\n    y : int\n        Second number.\n    \n    Returns:\n    int\n        The greatest common divisor of x and y.\n    \n    Examples:\n    >>> gcd(12, 18)\n    6\n    >>> gcd(5, 13)\n    1\n    \"\"\"\n    while y:\n        x, y = y, x % y\n    return x"]], "Integers Properties": [["def prime_factors(n):\n    \"\"\"\n    Generate prime factors of a given integer.\n    \n    Parameters:\n        n (int): The integer to factorize.\n    \n    Returns:\n        list: A list of tuples where each tuple is (prime_factor, exponent).\n    \n    Examples:\n        >>> prime_factors(56)\n        [(2, 3), (7, 1)]\n    \"\"\"\n    return list(sympy.factorint(n).items())", "def get_prime_factors(n):\n    \"\"\"\n    Compute the prime factors of a given integer.\n    Parameters:\n        n (int): The integer to factorize.\n    Returns:\n        list: A list of the prime factors of n.\n    Example:\n        >>> get_prime_factors(28)\n        [2, 7]\n    \"\"\"\n    return primefactors(n)"], ["def modular_inverse(a, m):\n    \"\"\"\n    Computes the modular inverse of a under modulo m using the Extended Euclidean Algorithm.\n    Parameters:\n        a (int): The number to find the inverse of.\n        m (int): The modulus.\n    Returns:\n        int: The modular inverse of a modulo m if it exists. Returns None if the modular inverse does not exist.\n    Example:\n        >>> modular_inverse(3, 11)\n        4\n    \"\"\"\n    from sympy.core.numbers import igcdex\n    g, x, y = igcdex(a, m)\n    if g != 1:\n        return None  # No modular inverse if a and m are not coprime\n    else:\n        return x % m", "def modular_inverse(a, m):\n    \"\"\"\n    Compute the modular inverse of a under modulo m.\n    \n    Parameters:\n        a (int): The number to find an inverse for.\n        m (int): The modulus.\n    \n    Returns:\n        int: The modular inverse of a under modulo m, or None if it does not exist.\n    \n    Examples:\n        >>> modular_inverse(3, 11)\n        4\n    \"\"\"\n    return sympy.mod_inverse(a, m) if gcd(a, m) == 1 else None"], ["def check_primality(number):\n    \"\"\"\n    Checks if an integer is a prime number.\n    Parameters:\n        number (int): The integer to check for primality.\n    Returns:\n        bool: True if the integer is prime, otherwise False.\n    Example:\n        >>> check_primality(29)\n        True\n    \"\"\"\n    return isprime(number)", "def check_prime(n):\n    \"\"\"\n    Check if a number is a prime number.\n    Parameters:\n        n (int): The number to check for primality.\n    Returns:\n        bool: True if n is prime, else False.\n    Example:\n        >>> check_prime(29)\n        True\n        >>> check_prime(30)\n        False\n    \"\"\"\n    return isprime(n)"], ["def get_all_divisors(n):\n    \"\"\"\n    List all divisors of a given integer.\n    Parameters:\n        n (int): The integer to find divisors for.\n    Returns:\n        list: A list of all divisors of n.\n    Example:\n        >>> get_all_divisors(30)\n        [1, 2, 3, 5, 6, 10, 15, 30]\n    \"\"\"\n    return divisors(n)"], ["def count_modular_solutions(f, g, modulus):\n    \"\"\"\n    Counts the number of solutions to the equation f(x) ≡ g(x) (mod modulus).\n    Parameters:\n        f (function): A Python function representing the left-hand side of the equation.\n        g (function): A Python function representing the right-hand side of the equation.\n        modulus (int): The modulus for the equivalence.\n    Returns:\n        int: The number of solutions x that satisfy the equation under the given modulus.\n    Example:\n        >>> f = lambda x: x**2\n        >>> g = lambda x: 1\n        >>> count_modular_solutions(f, g, 10)\n        3\n    \"\"\"\n    count = 0\n    for x in range(modulus):\n        if f(x) % modulus == g(x) % modulus:\n            count += 1\n    return count"], ["def modular_exponentiation(base, exponent, modulus):\n    \"\"\"\n    Perform modular exponentiation (base^exponent % modulus).\n    Parameters:\n        base (int): The base of the expression.\n        exponent (int): The exponent of the expression.\n        modulus (int): The modulus to apply.\n    Returns:\n        int: Result of (base^exponent) % modulus.\n    Example:\n        >>> modular_exponentiation(2, 10, 1000)\n        24\n    \"\"\"\n    return pow(base, exponent, modulus)"], ["def gcd(a, b):\n    \"\"\"\n    Calculate the greatest common divisor of two numbers.\n    \n    Parameters:\n        a (int): The first integer.\n        b (int): The second integer.\n    \n    Returns:\n        int: The greatest common divisor of a and b.\n    \n    Examples:\n        >>> gcd(8, 12)\n        4\n    \"\"\"\n    return calculate_gcd(a, b)", "def compute_gcd(a, b):\n    \"\"\"\n    Compute the greatest common divisor of two integers.\n    Parameters:\n        a (int): First integer.\n        b (int): Second integer.\n    Returns:\n        int: The greatest common divisor of a and b.\n    Example:\n        >>> compute_gcd(8, 12)\n        4\n    \"\"\"\n    return gcd(a, b)"], ["def digit_analysis(n):\n    \"\"\"\n    Analyze the digits of a number and return various properties.\n    \n    Parameters:\n        n (int): The integer to analyze.\n    \n    Returns:\n        dict: A dictionary with keys 'digit_count', 'even_digit_count', 'odd_digit_count', 'max_digit', 'min_digit'.\n    \n    Examples:\n        >>> digit_analysis(4562)\n        {'digit_count': 4, 'even_digit_count': 3, 'odd_digit_count': 1, 'max_digit': 6, 'min_digit': 2}\n    \"\"\"\n    digits = [int(d) for d in str(n)]\n    return {\n        'digit_count': len(digits),\n        'even_digit_count': sum(1 for d in digits if d % 2 == 0),\n        'odd_digit_count': sum(1 for d in digits if d % 2 != 0),\n        'max_digit': max(digits),\n        'min_digit': min(digits)\n    }"], ["def all_factors(n):\n    \"\"\"\n    Generate all factors of a given integer.\n    \n    Parameters:\n        n (int): The integer to find factors of.\n    \n    Returns:\n        list: A sorted list of all factors of n.\n    \n    Examples:\n        >>> all_factors(30)\n        [1, 2, 3, 5, 6, 10, 15, 30]\n    \"\"\"\n    return sorted(list(sympy.divisors(n)))"], ["def prime_factors(number):\n    \"\"\"\n    Returns the prime factors of a given integer.\n    Parameters:\n        number (int): The integer to factorize.\n    \n    Returns:\n        list: A list of prime factors of the integer.\n    Example:\n        >>> prime_factors(60)\n        [2, 2, 3, 5]\n    \"\"\"\n    i = 2\n    factors = []\n    while i * i <= number:\n        if number % i:\n            i += 1\n        else:\n            number //= i\n            factors.append(i)\n    if number > 1:\n        factors.append(number)\n    return factors"], ["def all_divisors(number):\n    \"\"\"\n    Returns all divisors of a given integer.\n    Parameters:\n        number (int): The integer to find divisors for.\n    Returns:\n        list: A list of all divisors of the integer.\n    Example:\n        >>> all_divisors(28)\n        [1, 2, 4, 7, 14, 28]\n    \"\"\"\n    return divisors(number)"]], "Perfect Squares and Cubes": [["def perfect_squares_and_cubes_up_to(n, find_cubes=False):\n    \"\"\"\n    List perfect squares and cubes up to a given number n and optionally their sum.\n    \n    Parameters:\n    n (int): Upper limit (inclusive) to search for perfect squares and/or cubes.\n    find_cubes (bool): Flag to determine whether to find cubes (default=False).\n    \n    Returns:\n    tuple: Tuple where the first element is a list of perfect squares or cubes,\n           and the second element is their sum.\n    \n    Example:\n    >>> perfect_squares_and_cubes_up_to(30)\n    ([1, 4, 9, 16, 25], 55)\n    >>> perfect_squares_and_cubes_up_to(30, find_cubes=True)\n    ([1, 8, 27], 36)\n    \"\"\"\n    perfect_numbers = []\n    i = 1\n    while True:\n        square = i * i\n        if square > n:\n            break\n        if not find_cubes or (find_cubes and is_perfect_cube(square)):\n            perfect_numbers.append(square)\n        i += 1\n    if find_cubes:\n        perfect_numbers = [i ** 3 for i in range(1, int(n ** (1/3)) + 1) if i ** 3 <= n]\n    \n    perfect_numbers_sum = sum(perfect_numbers)\n    return perfect_numbers, perfect_numbers_sum", "def list_perfect_squares_cubes(limit, square=True):\n    \"\"\"\n    Lists perfect squares or cubes up to the given limit exclusive.\n    \n    Parameters:\n    - limit (int): Upper limit (non-inclusive) for the numbers to list the perfect squares or cubes.\n    - square (bool): If True, returns perfect squares, otherwise perfect cubes.\n    Returns:\n    - list[int]: List of perfect squares or cubes from 1 up to but not including the limit.\n    Examples:\n    >>> list_perfect_squares_cubes(10, square=True)\n    [1, 4, 9]\n    >>> list_perfect_squares_cubes(10, square=False)\n    [1, 8]\n    \"\"\"\n    if square:\n        return [i**2 for i in range(1, int(math.sqrt(limit))+1)]\n    else:\n        return [i**3 for i in range(1, int(limit**(1/3))+1)]"], ["def is_perfect_cube(n):\n    \"\"\"\n    Determines whether the provided number `n` is a perfect cube.\n    Parameters:\n        n (int): Number to check.\n    Returns:\n    bool: True if `n` is a perfect cube, False otherwise.\n    Examples:\n        >>> is_perfect_cube(27)\n        True\n        >>> is_perfect_cube(26)\n        False\n    \"\"\"\n    cube_root = int(round(n ** (1/3), 10))\n    return cube_root ** 3 == n", "def is_perfect_cube(number):\n    \"\"\"\n    Check if a number is a perfect cube.\n    Parameters:\n        number (int): The number to check.\n    Returns:\n        bool: True if `number` is a perfect cube, False otherwise.\n    \n    Examples:\n        >>> is_perfect_cube(27)\n        True\n        >>> is_perfect_cube(20)\n        False\n    \"\"\"\n    if number < 0:\n        root = int(-abs(number) ** (1/3))\n    else:\n        root = int(number ** (1/3))\n    return root ** 3 == number", "def is_perfect_cube(number):\n    \"\"\"\n    Check if a number is a perfect cube.\n    \n    Parameters:\n    number (int): The number to check.\n    \n    Returns:\n    bool: True if the number is a perfect cube, False otherwise.\n    \n    Example:\n    >>> is_perfect_cube(27)\n    True\n    >>> is_perfect_cube(28)\n    False\n    \"\"\"\n    if number < 0:\n        return False\n    cbrt_num = round(number ** (1/3))\n    return cbrt_num ** 3 == number", "def is_perfect_cube(n):\n    \"\"\"\n    Check if a number 'n' is a perfect cube.\n    Parameters:\n    n (int): Number to check.\n    Returns:\n    bool: True if 'n' is a perfect cube, False otherwise.\n    Examples:\n    >>> is_perfect_cube(27)\n    True\n    >>> is_perfect_cube(26)\n    False\n    \"\"\"\n    root = round(n ** (1/3))\n    return root ** 3 == n", "def is_perfect_cube(n):\n    \"\"\"\n    Check if a number is a perfect cube.\n    Parameters:\n    n (int): The number to check.\n    Returns:\n    bool: True if n is a perfect cube, False otherwise.\n    Examples:\n    >>> is_perfect_cube(27)\n    True\n    >>> is_perfect_cube(28)\n    False\n    \"\"\"\n    root = round(n ** (1/3))\n    return root ** 3 == n", "def is_perfect_cube(number):\n    \"\"\"\n    Check if a number is a perfect cube.\n    Parameters:\n    - number (int): The number to check.\n    Returns:\n    - bool: True if the number is a perfect cube, False otherwise.\n    \n    Examples:\n    >>> is_perfect_cube(27)\n    True\n    >>> is_perfect_cube(28)\n    False\n    \"\"\"\n    if number < 0:\n        number = -number\n    root = int(round(number ** (1/3)))\n    return root ** 3 == number"], ["def is_perfect_square(n):\n    \"\"\"\n    Determines whether the provided number `n` is a perfect square.\n    Parameters:\n        n (int): Number to check.\n    Returns:\n    bool: True if `n` is a perfect square, False otherwise.\n    Examples:\n        >>> is_perfect_square(9)\n        True\n        >>> is_perfect_square(8)\n        False\n    \"\"\"\n    import math\n    square_root = int(math.sqrt(n))\n    return square_root * square_root == n", "def is_perfect_square(number):\n    \"\"\"\n    Check if a number is a perfect square.\n    \n    Parameters:\n        number (int): The number to check.\n    Returns:\n        bool: True if `number` is a perfect square, False otherwise.\n    \n    Examples:\n        >>> is_perfect_square(16)\n        True\n        >>> is_perfect_square(20)\n        False\n    \"\"\"\n    if number < 0:\n        return False\n    root = int(math.sqrt(number))\n    return root * root == number", "def is_perfect_square(number):\n    \"\"\"\n    Check if a number is a perfect square.\n    \n    Parameters:\n    number (int): The number to check.\n    \n    Returns:\n    bool: True if the number is a perfect square, False otherwise.\n    \n    Example:\n    >>> is_perfect_square(16)\n    True\n    >>> is_perfect_square(17)\n    False\n    \"\"\"\n    if number < 0:\n        return False\n    sqrt_num = int(math.sqrt(number))\n    return sqrt_num * sqrt_num == number", "def is_perfect_square(n):\n    \"\"\"\n    Check if a number 'n' is a perfect square.\n    Parameters:\n    n (int): Number to check.\n    Returns:\n    bool: True if 'n' is a perfect square, False otherwise.\n    Examples:\n    >>> is_perfect_square(16)\n    True\n    >>> is_perfect_square(14)\n    False\n    \"\"\"\n    root = isqrt(n)\n    return root * root == n", "def is_perfect_square(n):\n    \"\"\"\n    Check if a number is a perfect square.\n    Parameters:\n    n (int): The number to check.\n    Returns:\n    bool: True if n is a perfect square, False otherwise.\n    Examples:\n    >>> is_perfect_square(16)\n    True\n    >>> is_perfect_square(17)\n    False\n    \"\"\"\n    root = math.isqrt(n)\n    return root * root == n", "def is_perfect_square(number):\n    \"\"\"\n    Check if a number is a perfect square.\n    Parameters:\n    - number (int): The number to check.\n    Returns:\n    - bool: True if the number is a perfect square, False otherwise.\n    \n    Examples:\n    >>> is_perfect_square(16)\n    True\n    >>> is_perfect_square(17)\n    False\n    \"\"\"\n    if number < 0:\n        return False\n    root = math.isqrt(number)\n    return root * root == number"], ["def is_perfect_power(n, power=2):\n    \"\"\"\n    Check if a number is a perfect power (default is a perfect square).\n    Parameters:\n    - n (int): The number to check.\n    - power (int): The power to check for (default 2 for square, 3 for cube, etc.).\n    Returns:\n    - bool: True if n is a perfect power, False otherwise.\n    Examples:\n    >>> is_perfect_power(16)\n    True\n    >>> is_perfect_power(27, 3)\n    True\n    \"\"\"\n    root = round(n**(1/power))\n    return root**power == n", "def is_perfect_power(n, power):\n    \"\"\"\n    Checks if a given number is a perfect power (e.g. square, cube).\n    Parameters:\n    n (int): The number to check.\n    power (int): The power to check against (e.g. 2 for squares, 3 for cubes).\n    Returns:\n    bool: True if n is a perfect power of the specified type, otherwise False.\n    \"\"\"\n    root = round(n ** (1 / power))\n    return root ** power == n"], ["def find_perfect_squares(min_val, max_val):\n    \"\"\"\n    Finds all perfect squares in a specified inclusive range.\n    \n    Parameters:\n        min_val (int): The minimum value of the range.\n        max_val (int): The maximum value of the range.\n    \n    Returns:\n        list: A list of all perfect squares within the given range [min_val, max_val].\n    \n    Examples:\n        >>> find_perfect_squares(1, 100)\n        [1, 4, 9, 16, 25, 36, 49, 64, 81, 100]\n    \"\"\"\n    start = int(math.ceil(math.sqrt(min_val)))\n    end = int(math.floor(math.sqrt(max_val)))\n    return [i**2 for i in range(start, end + 1)]", "def find_perfect_cubes(min_val, max_val):\n    \"\"\"\n    Finds all perfect cubes in a specified inclusive range.\n    \n    Parameters:\n        min_val (int): The minimum value of the range.\n        max_val (int): The maximum value of the range.\n    \n    Returns:\n        list: A list of all perfect cubes within the given range [min_val, max_val].\n    \n    Examples:\n        >>> find_perfect_cubes(1, 1000)\n        [1, 8, 27, 64, 125, 216, 343, 512, 729, 1000]\n    \"\"\"\n    start = int(math.ceil(min_val ** (1/3)))\n    end = int(math.floor(max_val ** (1/3)))\n    return [i**3 for i in range(start, end + 1)]"], ["def nearest_perfect_power(n, direction=\"next\", power=2):\n    \"\"\"\n    Find the nearest perfect power greater ('next') or smaller ('previous') than a given number.\n    Parameters:\n    - n (int): The reference number.\n    - direction (str): 'next' for next perfect power, 'previous' for previous (default 'next').\n    - power (int): The power to consider (default 2 for squares, 3 for cubes, etc.).\n    Returns:\n    - int: The nearest perfect power in the specified direction.\n    Examples:\n    >>> nearest_perfect_power(15)\n    16\n    >>> nearest_perfect_power(28, direction='previous', power=3)\n    27\n    \"\"\"\n    increment = 0 if direction == \"previous\" else 1\n    candidate_root = round(n**(1/power)) + increment\n    candidate_power = candidate_root**power\n    if direction == \"previous\" and candidate_power > n:\n        candidate_root -= 1\n        candidate_power = candidate_root**power\n    return candidate_power"], ["def find_perfect_powers_up_to(limit, power):\n    \"\"\"\n    Find all perfect powers up to a given limit.\n    Parameters:\n    limit (int): The upper limit (non-inclusive) for finding perfect powers.\n    power (int): The power to which numbers are raised.\n    Returns:\n    list: List of all integers up to 'limit' that are perfect 'power'th powers.\n    Examples:\n    >>> find_perfect_powers_up_to(100, 2)\n    [1, 4, 9, 16, 25, 36, 49, 64, 81]\n    >>> find_perfect_powers_up_to(100, 3)\n    [1, 8, 27, 64]\n    \"\"\"\n    results = []\n    num = 1\n    while (num ** power) < limit:\n        results.append(num ** power)\n        num += 1\n    return results", "def list_perfect_powers(upper_limit, power):\n    \"\"\"\n    Lists all perfect powers less than an upper limit.\n    Parameters:\n    upper_limit (int): The upper boundary for checking the numbers.\n    power (int): The power to check for (2 for squares, 3 for cubes, etc.).\n    Returns:\n    list: A list of all perfect powers under the specified upper limit.\n    \"\"\"\n    results = []\n    num = 1\n    while (result := num ** power) < upper_limit:\n        results.append(result)\n        num += 1\n    return results"], ["def adjusted_perfect_squares(limit, adjustment):\n    \"\"\"\n    Computes and returns perfect squares with a constant adjustment under a specified limit.\n    Parameters:\n    limit (int): The upper limit for checking perfect squares.\n    adjustment (int): The number to subtract from each square before checking.\n    Returns:\n    list: Perfect squares with adjustment under the specified limit.\n    \"\"\"\n    results = []\n    num = 1\n    while (square := num ** 2) - adjustment < limit:\n        results.append(square - adjustment)\n        num += 1\n    return results"], ["def is_perfect_square_in_base(n, base):\n    \"\"\"\n    Converts a number to a specified base and checks if the representation is a perfect square.\n    Parameters:\n    n (int): The number to convert and check.\n    base (int): The base to convert into.\n    Returns:\n    bool: True if the base-converted number is a perfect square, otherwise False.\n    \"\"\"\n    # Convert number n to the specified base\n    base_num = \"\"\n    original_n = n\n    while n > 0:\n        n, remainder = divmod(n, base)\n        base_num = str(remainder) + base_info\n    base_num = int(base_num)\n    # Check if the converted number is a perfect square\n    return is_perfect_power(base_num, 2)"], ["def generate_perfect_powers(start, end, power):\n    \"\"\"\n    Generates all perfect powers within a given interval [start, end] including the boundaries.\n    Parameters:\n    start (int): Lower bound of the range.\n    end (int): Upper bound of the range.\n    power (int): The power to which numbers are raised to qualify as perfect.\n    Returns:\n    list: A list of perfect powers from start to end inclusive.\n    Examples:\n    >>> generate_perfect_powers(1, 100, 2)  # Perfect squares up to 100\n    [1, 4, 9, 16, 25, 36, 49, 64, 81, 100]\n    >>> generate_perfect_powers(1, 100, 3)  # Perfect cubes up to 100\n    [1, 8, 27, 64]\n    \"\"\"\n    lower_bound = int(start ** (1/power))\n    upper_bound = int(end ** (1/power))\n    return [i ** power for i in range(lower_bound, upper_problem + 1) if i ** power <= end]", "def find_perfect_powers_in_range(start, end, power=2):\n    \"\"\"\n    Generate a list of all perfect powers within a specified range.\n    Parameters:\n    - start (int): The start of the range.\n    - end (int): The end of the range.\n    - power (int): The power to generate (default 2 for squares, 3 for cubes, etc.).\n    Returns:\n    - list of int: List containing all the perfect powers between start and end.\n    Examples:\n    >>> find_perfect_powers_in_range(1, 100)\n    [1, 4, 9, 16, 25, 36, 49, 64, 81, 100]\n    >>> find_perfect_powers_in_range(1, 100, 3)\n    [1, 8, 27, 64]\n    \"\"\"\n    start_root = int(math.ceil(start**(1/power)))\n    end_root = int(math.floor(end**(1/power)))\n    return [i**power for i in range(start roots, edit_root + 1)]"], ["def generate_cubes(n):\n    \"\"\"\n    Generates a list of all perfect cubes less than or equal to `n`.\n    Parameters:\n        n (int): Upper bound for generating perfect cubes.\n    Returns:\n    list: List of all perfect cubes ≤ `n`.\n    Examples:\n        >>> generate_cubes(30)\n        [0, 1, 8, 27]\n    \"\"\"\n    return [i**3 for i in range(int(round(n**(1/3), 10)) + 1)]"], ["def is_perfect_sixth_power(n):\n    \"\"\"\n    Check if a number is a perfect sixth power.\n    Parameters:\n    n (int): The number to check.\n    Returns:\n    bool: True if n is a perfect sixth power, False otherwise.\n    Examples:\n    >>> is_perfect_sixth_power(64)\n    True\n    >>> is_perfect_sixth_power(65)\n    False\n    \"\"\"\n    sixth_root = round(n ** (1/6))\n    return sixth_root ** 6 == n"], ["def generate_squares(n):\n    \"\"\"\n    Generates a list of all perfect squares less than or equal to `n`.\n    Parameters:\n        n (int): Upper bound for generating perfect squares.\n    Returns:\n    list: List of all perfect squares ≤ `n`.\n    Examples:\n        >>> generate_squares(10)\n        [0, 1, 4, 9]\n    \"\"\"\n    import math\n    return [i*i for i in range(int(math.sqrt(n)) + 1)]"], ["def perfect_powers(limit, power_type='square'):\n    \"\"\"\n    Identifies and lists all perfect power numbers up to a specified limit.\n    Parameters:\n    - limit (int): The upper boundary for numbers to check for being perfect powers.\n    - power_type (str): The type of power to check for ('square', 'cube', 'sixth').\n    Returns:\n    - list: A list of all perfect powers up to the specified limit.\n    Example:\n    >>> perfect_powers(100, 'square')\n    [1, 4, 9, 16, 25, 36, 49, 64, 81, 100]\n    >>> perfect_powers(100, 'cube')\n    [1, 8, 27, 64]\n    >>> perfect_powers(100, 'sixth')\n    [1, 64]\n    \"\"\"\n    if power_type == 'square':\n        exponent = 2\n    elif power_type == 'cube':\n        exponent = 3\n    elif power_type == 'sixth':\n        exponent = 6\n    else:\n        raise ValueError(\"Unsupported power_type. Choose 'square', 'cube', or 'sixth'.\")\n    result = []\n    number = 1\n    while number**exponent <= limit:\n        result.append(number**exponent)\n        number += 1\n    return result"]], "Divisibility": [["def compute_divisors(n):\n    \"\"\"\n    Compute all divisors of a number.\n    Parameters:\n    n : int\n        The integer to compute divisors for.\n    Returns:\n    list\n        Sorted list of all divisors of the number.\n    Examples:\n    >>> compute_divisors(60)\n    [1, 2, 3, 4, 5, 6, 10, 12, 15, 20, 30, 60]\n    \"\"\"\n    factors = prime_factors(n)\n    return divisors_from_factors(factors)", "def count_divisors(n):\n    \"\"\"\n    Counts the divisors of integer `n` based on prime factorization.\n    Parameters:\n    n (int): The integer to calculate divisors for.\n    Returns:\n    int: The number of divisors of `n`.\n    Examples:\n    >>> count_divisors(360)\n    24\n    \"\"\"\n    factorization = prime_factorization(n)\n    total_divisors = 1\n    for power in factorization.values():\n        total_divisors *= (power + 1)\n    return total_divisors", "def count_divisors(n):\n    \"\"\"\n    Calculate the total number of divisors of an integer using its prime factorization.\n    Parameters:\n    n : int\n        The integer to count divisors of.\n    Returns:\n    int\n        Total number of divisors of n.\n    Example:\n    >>> count_divisors(12)\n    6\n    \"\"\"\n    factors = prime_factors(n)\n    count = 1\n    for exp in factors.values():\n        count *= (exp + 1)\n    return count", "def sum_divisors(n):\n    \"\"\"\n    Calculate the sum of all divisors of a number using its prime factorization.\n    Parameters:\n    n : int\n        The integer to sum divisors of.\n    Returns:\n    int\n        Sum of all divisors of n.\n    Example:\n    >>> sum_divisors(12)\n    28\n    \"\"\"\n    factors = prime_factors(n)\n    total_sum = 1\n    for p, exp in factors.items():\n        total_sum *= (p**(exp + 1) - 1) // (p - 1)\n    return total_sum"], ["def find_divisors(n):\n    \"\"\"\n    Determine divisors of a given number.\n    Parameters:\n    n : int\n        The number to find divisors of\n    Returns:\n    list\n        List of divisors of n.\n    Example:\n    >>> find_divisors(12)\n    [1, 2, 3, 4, 6, 12]\n    \"\"\"\n    return [x for x in range(1, n+1) if n % x == 0]", "def divisors(n):\n    \"\"\"\n    Compute all divisors of the integer n.\n    Parameters:\n        n (int): The number to calculate divisors for.\n    \n    Returns:\n        list: A sorted list of all divisors of n.\n        \n    Example:\n        >>> divisors(12)\n        [1, 2, 3, 4, 6, 12]\n    \"\"\"\n    from sympy import divisors\n    return divisors(n)", "def list_divisors(n):\n    \"\"\"\n    List all divisors of a given integer.\n    Parameters:\n    n : int\n        The integer to find divisors of.\n    Returns:\n    list\n        List of all divisors of n.\n    Example:\n    >>> list_divisors(12)\n    [1, 2, 3, 4, 6, 12]\n    \"\"\"\n    divs = []\n    for i in range(1, int(sp.sqrt(n)) + 1):\n        if n % i == 0:\n            divs.append(i)\n            if i != n // i:\n                divs.append(n // i)\n    return sorted(divs)"], ["def count_multiples_of_lcm(lcm_value, start, end):\n    \"\"\"\n    Count the number of multiples of LCM within a specified range.\n    Parameters:\n        lcm_value (int): The LCM value to use for counting multiples.\n        start (int): The start of the range (inclusive).\n        end (int): The end of the range (inclusive).\n    Returns:\n        int: The count of multiples of the LCM within the specified range.\n    Examples:\n        >>> count_multiples_of_lcm(24, 1, 100)\n        4\n        >>> count_multiples_of_lcm(15, 1, 45)\n        3\n    \"\"\"\n    if lcm_value == 0:\n        return 0\n    \n    count_start = (start + lcm_value - 1) // lcm_value\n    count_end = end // lcm_value\n    return count_end - count_start + 1", "def count_multiples(number, start, end):\n    \"\"\"\n    Count the multiples of 'number' within a specified range [start, end].\n    \n    Parameters:\n    - number (int): the base number to find multiples of.\n    - start (int): the start of the range (inclusive).\n    - end (int): the end of the range (inclusive).\n    \n    Returns:\n    - int: count of multiples of 'number' within the given range.\n    \n    Example:\n    >>> count_multiples(5, 1, 100)\n    20\n    >>> count_multiples(7, 1, 50)\n    7\n    \"\"\"\n    if number <= 0:\n        return 0\n    start_adj = (start + number - 1) // number * number # ceil to next multiple if not already a multiple\n    if start_adj > end:\n        return 0\n    return (end - start_adj) // number + 1", "def count_multiples_in_range(divisor, start, end):\n    \"\"\"\n    Count the number of multiples of `divisor` within the range [start, end].\n    Parameters:\n        divisor (int): The number whose multiples are to be counted.\n        start (int): The start of the range (inclusive).\n        end (int): The end of the range (exclusive).\n    Returns:\n        int: The number of multiples of `divaivor` within the specified range.\n    Examples:\n        >>> count_multiples_in_range(5, 1, 11)\n        2  # Multiples are 5, 10\n        >>> count_multiples_in_range(12, 100, 200)\n        8  # Multiples are 108, 120, ..., 192\n    \"\"\"\n    if start % divisor == 0:\n        start_index = start\n    else:\n        start_index = start + (divisor - start % divisor)\n    \n    end_index = end - 1 - (end - 1) % divisor\n    return (end_index - start_index) // divisor + 1 if start_index <= end_index else 0"], ["def modular_exponentiation(base, exponent, modulus):\n    \"\"\"\n    Performs modular exponentiation of a base raised to an exponent under a modulus.\n    Parameters:\n    - base (int): The base of the exponentiation.\n    - exponent (int): The power to which the base is raised.\n    - modulus (int): The modulus to be applied.\n    \n    Returns:\n    - int: Result of (base ** exponent) % modulus.\n    \n    Examples:\n    - modular_exponentiation(2, 3, 5) -> 3 (since 2**3 % 5 = 8 % 5 = 3)\n    \"\"\"\n    result = 1\n    while exponent > 0:\n        if (exponent % 2) == 1:\n            result = (result * base) % modulus\n        base = (base * base) % modulus\n        exponent = exponent >> 1\n    return result", "def modular_power(base, exponent, modulus):\n    \"\"\"\n    Compute the power of a base number raised to an exponent under a given modulus using an efficient method.\n    Parameters:\n    base (int): The base number to be raised to the power.\n    exponent (int): The exponent to raise the base to.\n    modulus (int): The modulus under which to perform the operation.\n    Returns:\n    int: The result of (base ** exponent) % modulus.\n    Example:\n    >>> modular_power(2, 3, 5)\n    3\n    \"\"\"\n    return pow(base, exponent, modulus)"], ["def sum_of_digits(number):\n    \"\"\"\n    Calculates the sum of the digits of an integer.\n    Parameters:\n    - number (int): The number whose digits will be summed.\n    Returns:\n    - int: The sum of the digits of the number.\n    \n    Examples:\n    >>> sum_of_digits(123)\n    6\n    >>> sum_of_digits(456)\n    15\n    \"\"\"\n    return sum(int(digit) for digit in str(abs(number)))", "def sum_of_digits(number):\n    \"\"\"\n    Calculates the sum of all digits in the given integer number.\n    Parameters:\n        number (int): The number whose digits will be summed.\n    Returns:\n        int: The sum of the digits.\n    Examples:\n    >>> sum_of_digits(123)\n    6\n    >>> sum_of_digits(104)\n    5\n    \"\"\"\n    return sum(int(digit) for digit in str(abs(number)))"], ["def is_divisible_by(number, divisor):\n    \"\"\"\n    Checks if a given integer is divisible by another integer (divisor).\n    Parameters:\n    - number (int): The number to be checked.\n    - divisor (int): The divisor to check against.\n    Returns:\n    - bool: True if the number is divisible by the divisor, False otherwise.\n    \n    Examples:\n    >>> is_divisible_by(15, 3)\n    True\n    >>> is_divisible_by(17, 4)\n    False\n    \"\"\"\n    return number % divisor == 0", "def is_divisible(n, div):\n    \"\"\"\n    Check if the number `n` is divisible by the number `div`.\n    Parameters:\n    n (int): Number to check divisibility for.\n    div (int): Divisor.\n    Returns:\n    bool: True if `n` is divisible by `div`, False otherwise.\n    Examples:\n    >>> is_divisible(10, 5)\n    True\n    >>> is_divisible(13, 3)\n    False\n    \"\"\"\n    return n % div == 0", "def is_divisible(num, divisor):\n    \"\"\"\n    Check if the number `num` is divisible by `divisor`.\n    Parameters:\n        num (int): Number to be checked for divisibility.\n        divisor (int): Divisor against which to check the divisibility.\n    \n    Returns:\n        bool: True if num is divisible by divisor, False otherwise.\n    Examples:\n        >>> is_divisible(10, 2)\n        True\n        >>> is_divisible(13, 2)\n        False\n    \"\"\"\n    return num % divisor == 0", "def is_divisible(n, divisor):\n    \"\"\"\n    Check if a given number n is divisible by another number divisor.\n    Parameters:\n    n (int): The number to be checked for divisibility.\n    divisor (int): The number that n is checked against for divisibility.\n    Returns:\n    bool: True if n is divisible by divisor, False otherwise.\n    Example:\n    >>> is_divisible(10, 5)\n    True\n    >>> is_divisible(7, 3)\n    False\n    \"\"\"\n    if divisor == 0:\n        raise ValueError(\"The divisor cannot be zero.\")\n    return n % divisor == 0", "def is_divisible(n, divisor):\n    \"\"\"\n    Checks if a number n is divisible by the divisor.\n    Parameters:\n        n (int): The number to be checked for divisibility.\n        divisor (int): The divisor to check against.\n    Returns:\n        bool: True if n is divisible by divisor, False otherwise.\n    Examples:\n    >>> is_divisible(15, 5)\n    True\n    >>> is_divisible(13, 3)\n    False\n    \"\"\"\n    if divisor == 0:\n        raise ValueError(\"Divisor cannot be zero.\")\n    return n % divisor == 0"], ["def prime_factors(n):\n    \"\"\"\n    Compute the prime factors of a given number n.\n    Parameters:\n    n : int\n        The number for which to find the prime factors.\n        \n    Returns:\n    dict\n        A dictionary where keys are prime factors and values are their corresponding exponents.\n    Examples:\n    >>> prime_factors(60)\n    {2: 2, 3: 1, 5: 1}\n    \"\"\"\n    prime_factors = {}\n    for p, exp in sympy.factorint(n).items():\n        prime_factors[p] = exp\n    return prime_factors", "def prime_factorization(n):\n    \"\"\"\n    Returns the prime factors of a given integer `n`.\n    Parameters:\n    n (int): The integer to factorize.\n    Returns:\n    dict: A dictionary where keys are prime factors and values are their respective powers in the factorization.\n    Examples:\n    >>> prime_factorization(360)\n    {2: 3, 3: 2, 5: 1}\n    \"\"\"\n    factors = primefactors(n)\n    factor_counts = {}\n    for factor in factors:\n        count = 0\n        temp = n\n        while temp % factor == 0:\n            temp //= factor\n            count += 1\n        factor_counts[factor] = count\n    return factor_counts", "def prime_factors(n):\n    \"\"\"\n    Calculate the prime factors of a given integer 'n'.\n    Parameters:\n        n (int): The integer to factorize.\n    Returns:\n        dict: A dictionary with prime factors as keys and their powers as values.\n    Example:\n        >>> prime_factors(12)\n        {2: 2, 3: 1}\n    \"\"\"\n    from sympy import primefactors\n    factorization = {}\n    factors = primefactors(n)\n    for factor in factors:\n        count = 0\n        temp = n\n        while temp % factor == 0:\n            count += 1\n            temp //= factor\n        factorization[factor] = count\n    return factorization", "def prime_factors(n):\n    \"\"\"\n    Determine prime factors of a given integer with their respective exponents.\n    Parameters:\n    n : int\n        The integer to factorize.\n    Returns:\n    dict\n        A dictionary where keys are the prime factors and values are their respective exponents.\n    Example:\n    >>> prime_factors(360)\n    {2: 3, 3: 2, 5: 1}\n    \"\"\"\n    return {int(p): e for p, e in sp.factorint(n).items()}", "def prime_factors(n):\n    \"\"\"\n    Compute the prime factors of a given integer n and their respective powers.\n    \n    Parameters:\n        n (int): The integer to factorize.\n    \n    Returns:\n        dict: A dictionary where keys are the prime factors and values are their powers.\n        \n    Examples:\n        >>> prime_factors(18)\n        {2: 1, 3: 2}\n        >>> prime_factors(100)\n        {2: 2, 5: 2}\n    \"\"\"\n    factor_dict = {}\n    for p, exp in sympy.ntheory.factorint(n).items():\n        factor_dict[p] = exp\n    return factordict"], ["def gcd(x, y):\n    \"\"\"\n    Compute the greatest common divisor of two integers.\n    Parameters:\n    x : int\n        First integer.\n    y : int\n        Second integer.\n        \n    Returns:\n    int\n        The greatest common divisor of x and y.\n    Examples:\n    >>> gcd(48, 18)\n    6\n    \"\"\"\n    while y != 0:\n        (x, y) = (y, x % y)\n    return abs(x)", "def calculate_gcd(x, y):\n    \"\"\" Calculate the greatest common divisor of two numbers using math.gcd.\n    \n    Parameters:\n    x (int): First integer.\n    y (int): Second integer.\n    \n    Returns:\n    int: The greatest common divisor of x and y.\n    \n    Example:\n    >>> calculate_gcd(12, 18)\n    6\n    \"\"\"\n    return math.gcd(x, y)"], ["def find_divisors(n):\n    \"\"\"\n    Finds all divisors of an integer `n`.\n    Parameters:\n    n (int): The integer to find divisors for.\n    Returns:\n    list: A list of all divisors of `n`.\n    Examples:\n    >>> find_divisors(28)\n    [1, 2, 4, 7, 14, 28]\n    \"\"\"\n    return divisors(n)", "def find_divisors(n):\n    \"\"\" Find all positive divisors of an integer n including using its factors.\n    \n    Parameters:\n    n (int): The integer to find divisors for.\n    \n    Returns:\n    list: A list of all positive divisors of n.\n    \n    Example:\n    >>> find_divisors(28)\n    [1, 2, 4, 7, 14, 28]\n    \"\"\"\n    divisors = []\n    for i in range(1, int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            divisors.append(i)\n            if i != n // i:\n                divisors.append(n // i)\n    divisors.sort()\n    return divisors", "def divisors(n):\n    \"\"\"\n    Calculate all positive divisors of a given integer using its prime factorization.\n    \n    Parameters:\n        n (int): The integer to find divisors for.\n    \n    Returns:\n        list: Sorted list of all divisors of n.\n    \n    Examples:\n        >>> divisors(28)\n        [1, 2, 4, 7, 14, 28]\n        >>> divisors(100)\n        [1, 2, 4, 5, 10, 20, 25, 50, 100]\n    \"\"\"\n    prime_dict = prime_factors(n)\n    div_list = [1]  # start with 1 which is a divisor for any integer\n    for prime, exp in prime_dict.items():\n        current_length = len(div_list)\n        current_divisors = div_list[:]  # copy current divisors\n        for power in range(1, exp + 1):\n            new_divisors = [d * (prime ** power) for d in current_divisors]\n            div_list.extend(new_divisors)\n    return sorted(set(div_list))"], ["def divisor_properties(n):\n    \"\"\"\n    Calculate properties of divisors for n such as total number, sum, and product.\n    \n    Parameters:\n        n (int): The integer to analyze divisors for.\n    \n    Returns:\n        dict: A dictionary with keys 'number_of_divisors', 'sum_of_divisors', and 'product_of_divisors'.\n    \n    Examples:\n        >>> divisor_properties(30)\n        {'number_of_divisors': 8, 'sum_of_divisors': 72, 'product_of_divisors': 810000}\n    \"\"\"\n    divs = divisors(n)\n    num = len(divs)\n    sum_divs = sum(divs)\n    prod_divs = sympy.prod(divs)\n    return {'number_of_divisors': num, 'sum_of_divisors': sum_divs, 'product_of_divisors': prod_divs}"], ["def list_divisors(number):\n    \"\"\"\n    List all divisors of a given number.\n    Parameters:\n    number (int): The number whose divisors are to be found.\n    Returns:\n    list: A list of all divisors of the number.\n    Example:\n    >>> list_divisors(10)\n    [1, 2, 5, 10]\n    \"\"\"\n    if number <= 0:\n        raise ValueError(\"Number must be positive.\")\n    divisors = [1]\n    for i in range(2, int(number**0.5) + 1):\n        if number % i == 0:\n            divisors.extend([i, number // i])\n    if number != 1:\n        divisors.append(number)\n    return sorted(list(set(divisors)))"], ["def count_trailing_zeros_factorial(n):\n    \"\"\"\n    Counts the number of trailing zeros in n!.\n    Parameters:\n    n (int): The factorial number n! to analyze.\n    Returns:\n    int: The number of trailing zeros in `n!`.\n    Examples:\n    >>> count_trailing_zeros_factorial(5)\n    1\n    \"\"\"\n    i, zeros = 5, 0\n    while n >= i:\n        zeros += n // i\n        i *= 5\n    return zeros", "def count_trailing_zeros(n):\n    \"\"\"\n    Count the number of trailing zeros in n!.\n    Parameters:\n    n : int\n        The integer to count trailing zeros in its factorial.\n    Returns:\n    int\n        Number of trailing zeros in n!.\n    Detailed Description:\n    Trailing zeros come from factors of 10, which come from pairs of factors 2 and 5. \n    Since there are always more factors 2 than 5, count the factors of 5.\n    Example:\n    >>> count_trailing_zeros(5)\n    1\n    \"\"\"\n    count = 0\n    while n >= 5:\n        n //= 5\n        count += n\n    return count"], ["def calculate_lcm(*numbers):\n    \"\"\"\n    Calculate the least common multiple (LCM) of a list of integers.\n    Parameters:\n        numbers (int, ...): A variable number of integers for which the LCM is to be calculated.\n    Returns:\n        int: The LCM of the provided integers.\n    Examples:\n        >>> calculate_lcm(6, 8)\n        24\n        >>> calculate_lcm(5, 10, 20)\n        20\n    \"\"\"\n    def lcm(a, b):\n        return a * b // gcd(a, b)\n    \n    return reduce(lcm, numbers)", "def compute_lcm(*numbers):\n    \"\"\"\n    Calculate the Least Common Multiple (LCM) of a set of integers.\n    \n    Parameters:\n    - numbers (int): a sequence of integers to find the LCM of.\n    \n    Returns:\n    - int: the least common multiple of the given numbers.\n    \n    Example:\n    >>> compute_lcm(12, 15)\n    60\n    >>> compute_lcm(12, 15, 20)\n    60\n    \"\"\"\n    if not numbers:\n        return 0\n    def lcm(a, b):\n        return a * b // gcd(a, b)\n    \n    return reduce(lcm, numbers, 1)", "def lcm(*numbers):\n    \"\"\"\n    Calculate the least common multiple (LCM) of a list of integers.\n    Parameters:\n        numbers (int): A series of integers for which the LCM is to be calculated.\n    Returns:\n        int: The least common multiple of the input numbers.\n    Examples:\n        >>> lcm(12, 15)\n        60\n        >>> lcm(2, 3, 5)\n        30\n    \"\"\"\n    def lcm_pair(a, b):\n        return abs(a*b) // gcd(a, b)\n    \n    return reduce(lcm_pair, numbers, 1)"], ["def lcm(x, y):\n    \"\"\"\n    Compute the least common multiple of two integers.\n    Parameters:\n    x : int\n        First integer.\n    y : int\n        Second integer.\n        \n    Returns:\n    int\n        The least common multiple of x and y.\n    Examples:\n    >>> lcm(12, 15)\n    60\n    \"\"\"\n    return abs(x * y) // gcd(x, y)", "def calculate_lcm(x, y):\n    \"\"\" Calculate the least common multiple of two numbers based on their GCD.\n    \n    Parameters:\n    x (int): First integer.\n    y (int): Second integer.\n    \n    Returns:\n    int: The least common multiple of x and y.\n    \n    Example:\n    >>> calculate_lcm(12, 18)\n    36\n    \"\"\"\n    return abs(x * y) // math.gcd(x, y)"], ["def extended_euclidean(a, b):\n    \"\"\"\n    Extended Euclidean Algorithm to find integers x and y such that ax + by = gcd(a, b).\n    Parameters:\n    a : int\n        First integer.\n    b : int\n        Second integer.\n        \n    Returns:\n    tuple\n        Returns gcd(a, b), x, y where ax + by = gcd(a, b).\n    Examples:\n    >>> extended_euclidean(18, 30)\n    (6, -1, 1)\n    \"\"\"\n    x0, x1, y0, y1 = 0, 1, 1, 0\n    while b != 0:\n        q = a // b\n        a, b = b, a % b\n        x0, x1 = x1, x0 - q * x1\n        y0, y1 = y1, y0 - q * y1\n    return (a, x0, y0)", "def extended_gcd(a, b):\n    \"\"\" Extended Euclidean Algorithm to find integers x and y such that ax + by = gcd(a, b).\n    \n    Parameters:\n    a (int): First integer.\n    b (int): Second integer.\n    \n    Returns:\n    tuple: Returns a tuple (g, x, y) such that a*x + b*y = g = gcd(a, b)\n    \n    Example:\n    >>> extended_gcd(10, 6)\n    (2, -1, 2)\n    \"\"\"\n    x0, x1, y0, y1 = 1, 0, 0, 1\n    while b != 0:\n        q = a // b\n        a, b = b, a % b\n        x0, x1 = x1, x0 - q * x1\n        y0, y1 = y1, y0 - q * y1\n    return a, x0, y0"], ["def find_multiples(n, start, end):\n    \"\"\"\n    Find multiples of a given number within a specified range.\n    Parameters:\n    n : int\n        The number to find multiples of\n    start : int\n        The start of the range\n    end : int\n        The end of the range\n    Returns:\n    list\n        List of multiples of n between start and end.\n    Example:\n    >>> find_multiples(3, 1, 10)\n    [3, 6, 9]\n    \"\"\"\n    return [x for x in range(start, end+1) if x % n == 0]", "def find_multiples(base, start, end):\n    \"\"\"\n    Find all multiples of a base number within a specified range [start, end].\n    Parameters:\n    base (int): The base number of which multiples are to be found.\n    start (int): The starting value of the range (inclusive).\n    end (int): The ending value of the range (inclusive).\n    Returns:\n    list: A list of multiples of the base number within the given range.\n    Example:\n    >>> find_multiples(3, 1, 10)\n    [3, 6, 9]\n    \"\"\"\n    if base == 0:\n        raise ValueError(\"Base must be a non-zero integer.\")\n    return [multiple for multiple in range(start, end+1) if is_divisible(multiple, base)]"], ["def factorial_prime_factors(n):\n    \"\"\"\n    Determines the count of each prime factor in the factorial of `n`.\n    Parameters:\n    n (int): The factorial number n! to factorize.\n    Returns:\n    dict: Count of each prime factor in the factorial of `n`.\n    Examples:\n    >>> factorial_prime_factors(5)\n    {2: 3, 3: 1, 5: 1}\n    \"\"\"\n    factor_count = {}\n    for i in range(2, n+1):\n        factors = prime_factorization(i)\n        for prime, count in factors.items():\n            if prime in factor_count:\n                factor_count[prime] += count\n            else:\n                factor_count[prime] = count\n    return factor_count"], ["def factorial_divisor_properties(n):\n    \"\"\"\n    Analyze properties related to the divisors of n factorial, like the number of trailing zeros.\n    \n    Parameters:\n        n (int): The number to calculate factorial of.\n    \n    Returns:\n        dict: A dictionary with keys 'trailing_zeros'.\n        \n    Examples:\n        >>> factorial_divisor_properties(5)\n        {'trailing_zeros': 1}\n        >>> factorial_divisor_properties(10)\n        {'trailing_zeros': 2}\n    \"\"\"\n    trailing_zeros = 0\n    power_of_five = 5\n    while n >= power_of_five:\n        trailing_zeros += n // power_of_five\n        power_of_five *= 5\n    return {'trailing_zeros': trailing_zeros}"], ["def modulo_operation(n, m):\n    \"\"\"\n    Perform modulo operations.\n    Parameters:\n    n : int\n        Numerator in division\n    m : int\n        Denominator in division\n    Returns:\n    int\n        Remainder when n is divided by m.\n    Example:\n    >>> modulo_operation(10, 3)\n    1\n    \"\"\"\n    return n % m"], ["def find_multiples(number, limit):\n    \"\"\"\n    Returns a list of multiples of a given number up to a specified limit.\n    \n    Parameters:\n    - number (int): The base number of which multiples are desired.\n    - limit (int): The upper bound for multiples.\n    \n    Returns:\n    - List[int]: A list containing multiples of the number up to the limit.\n    \n    Examples:\n    - find_multiples(3, 10) -> [3, 6, 9]\n    \"\"\"\n    return [number * i for i in range(1, limit // number + 1)]"], ["def divisibility_check(n, m):\n    \"\"\"\n    Check if the number n is divisible by m.\n    Parameters:\n    n : int\n        Numerator in division\n    m : int\n        Denominator in division\n    Returns:\n    bool\n        True if n is divisible by m, False otherwise.\n    Example:\n    >>> divisibility_check(10, 2)\n    True\n    >>> divisibility_check(11, 2)\n    False\n    \"\"\"\n    return n % m == 0"], ["def is_even(n):\n    \"\"\"\n    Check if a number is even.\n    Parameters:\n    n : int\n        The number to check\n    Returns:\n    bool\n        True if n is even, False otherwise.\n        \n    Example:\n    >>> is_even(2)\n    True\n    >>> is_even(3)\n    False\n    \"\"\"\n    return n % 2 == 0"], ["def satisfies_all_conditions(number, *divisors):\n    \"\"\"\n    Check if a given number is divisible by all provided divisors.\n    \n    Parameters:\n    - number (int): the number to check.\n    - divisors (int): a sequence of divisors to check against.\n    \n    Returns:\n    - bool: True if the number is divisible by all of the divisors, False otherwise.\n    \n    Example:\n    >>> satisfies_all_conditions(120, 4, 5, 6)\n    True\n    >>> satisfies_all_conditions(17, 4, 3)\n    False\n    \"\"\"\n    return all(number % divisor == 0 for divisor in divisors)"], ["def factorization(n):\n    \"\"\"\n    Factorize a given number into prime factors.\n    Parameters:\n    n : int\n        The number to factorize\n    Returns:\n    list\n        List of prime factors of n.\n        \n    Example:\n    >>> factorization(12)\n    [2, 2, 3]\n    \"\"\"\n    i = 2\n    factors = []\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n            factors.append(i)\n    if n > 1:\n        factors.append(n)\n    return factors"], ["def check_digits_divisibility(number, divisor, last_n_digits):\n    \"\"\"\n    Checks divisibility of the last n digits of a number by a specified divisor.\n    Parameters:\n        number (int): The number to be checked.\n        divisor (int): The divisor to check against.\n        last_n_digits (int): Number of last digits to consider for divisibility test.\n    Returns:\n        bool: True if the last n digits form a number that is divisible by the divisor, False otherwise.\n    Examples:\n    >>> check_digits_divisibility(1234, 2, 1)\n    True\n    >>> check_digits_divisibility(1234, 4, 2)\n    False\n    \"\"\"\n    relevant_digits = abs(number) % (10 ** last_n_digits)\n    return is_divisible(relevant_digits, divisor)"], ["def integer_division(n, m):\n    \"\"\"\n    Perform integer division and return quotient and remainder.\n    Parameters:\n    n : int\n        Numerator in division\n    m : int\n        Denominator in division\n    Returns:\n    tuple\n        Quotient when n is divided by m and remainder.\n    Example:\n    >>> integer_division(10, 3)\n    (3, 1)\n    \"\"\"\n    quotient = n // m\n    remainder = n % m\n    return quotient, remainder"], ["def digit_properties_analysis(n):\n    \"\"\"\n    Analyze the digit-based properties of the number to determine its divisibility\n    by 2, 3, 4, 5, 6, 8, 9.\n    \n    Parameters:\n    n (int): The number to analyze.\n    Returns:\n    dict: Dictionary with properties like 'divisible_by_2', 'divisible_by_3', etc.\n    Examples:\n    >>> digit_properties_analysis(123)\n    {'last_digit': 3, 'sum_of_digits': 6, 'last_two_digits': 23, 'divisible_by_2': False, 'divisible_by_3': True, 'divisible_by_5': False, ...}\n    \"\"\"\n    last_digit = n % 10\n    sum_of_digits = sum(map(int, str(n)))\n    last_two_digits = n % 100\n    properties = {\n        'last_digit': last_digit,\n        'sum_of_digits': sum_of_digits,\n        'last_two_digits': last_two_dotjson\n        'divisible_by_2': is_divisible(n, 2),\n        'divisible_by_3': is_divisible(sum_of_digits, 3),\n        'divisible_by_4': is_divisible(last_two_digits, 4),\n        'divisible_by_5': last_digit in [0, 5],\n        'divisible_by_6': is_divisible(n, 2) and is_divisible(sum_of_digits, 3),\n        'divisible_by_8': is_divisible(n % 1000, 8),\n        'divisible_by_9': is_divisible(sum_of_digits, 9),\n    }\n    return properties"], ["def lcm(a, b):\n    \"\"\"\n    Compute the Least Common Multiple of two integers a and b.\n    Parameters:\n        a (int): First integer.\n        b (int): Second integer.\n    Returns:\n        int: LCM of a and b.\n    Example:\n        >>> lcm(4, 5)\n        20\n    \"\"\"\n    from math import gcd\n    return abs(a * b) // gcd(a, b)"], ["def compute_factorial(n):\n    \"\"\"\n    Compute n!.\n    Parameters:\n    n : int\n        The integer to compute the factorial of.\n    Returns:\n    int\n        n!.\n    Example:\n    >>> compute_factorial(5)\n    120\n    \"\"\"\n    return factorial(n)"], ["def gcd(a, b):\n    \"\"\"\n    Calculate the Greatest Common Divisor of two integers, a and b.\n    Parameters:\n        a (int): First integer.\n        b (int): Second integer.\n    Returns:\n        int: GCD of a and b.\n    Example:\n        >>> gcd(8, 12)\n        4\n    \"\"\"\n    from math import gcd\n    return gcd(a, b)"], ["def prime_factors(number):\n    \"\"\"\n    Return the prime factors of a given number as a list.\n    Parameters:\n        number (int): The integer to factorize.\n    Returns:\n        list: A list containing the prime factors of the number.\n    Examples:\n        >>> prime_factors(100)\n        [2, 2, 5, 5]\n        >>> prime_formatted_factors(36)\n        [2, 2, 3, 3]\n    \"\"\"\n    factors = []\n    for prime in primefactors(number):\n        count = 0\n        temp = number\n        while temp % prime == 0:\n            temp //= prime\n            count += 1\n        factors.extend([prime] * count)\n    return factors"], ["def extract_last_n_digits(number, n):\n    \"\"\"\n    Extracts the last n digits of an integer.\n    Parameters:\n    - number (int): The number from which to extract digits.\n    - n (int): The number of last digits to extract.\n    Returns:\n    - int: The last n digits of the number.\n    \n    Examples:\n    >>> extract_last_n_digits(12345, 2)\n    45\n    >>> extract_last_n_digits(98765, 3)\n    765\n    \"\"\"\n    return abs(number) % (10 ** n)"], ["def is_divisible(dividend, divisor):\n    \"\"\"\n    Determine if one number divides another without leaving a remainder.\n    \n    Parameters:\n    - dividend (int): The number to be divided.\n    - divisor (int): The number with which to divide the dividend.\n    \n    Returns:\n    - bool: True if dividend is divisible by divisor, False otherwise.\n    \n    Examples:\n    - is_divisible(10, 2) -> True\n    - is_divisible(10, 3) -> False\n    \"\"\"\n    if divisor == 0:\n        raise ValueError(\"Divisor cannot be zero.\")\n    return dividend % divisor == 0"], ["def divisors_from_factors(factor_dict):\n    \"\"\"\n    Calculate all divisors of a number given its prime factorization.\n    Parameters:\n    factor_dict : dict\n        A dictionary of prime factors and their respective exponents.\n    Returns:\n    list\n        Sorted list of all divisors of the number.\n    Examples:\n    >>> divisors_from_factors({2: 2, 3: 1, 5: 1})\n    [1, 2, 3, 4, 5, 6, 10, 12, 15, 20, 30, 60]\n    \"\"\"\n    from functools import reduce\n    from itertools import product\n    # Generate lists of powers for each prime factor\n    factors_powers = [\n        [factor ** exp for exp in range(power + 1)]\n        for factor, power in factor_dict.items()\n    ]\n    # Generate all combinations of these powers\n    all_combinations = product(*factors_powers)\n    # Multiply out each combination to get the divisors\n    divisors = sorted({reduce(lambda x, y: x * y, combination, 1) for combination in all_combinations})\n    return divisors"], ["def find_lcm(num1, num2):\n    \"\"\"\n    Find the least common multiple of two numbers.\n    \n    Parameters:\n    - num1 (int): First number.\n    - num2 (int): Second number.\n    \n    Returns:\n    - int: Least common multiple of num1 and num2.\n    \n    Examples:\n    - find_lcm(4, 6) -> 12\n    \"\"\"\n    return abs(num1 * num2) // gcd(num1, num2)"], ["def smallest_number_meeting_conditions(*divisors):\n    \"\"\"\n    Find the smallest number that is divisible by all provided divisors using the concept of LCM.\n    Parameters:\n        divisors (int, ...): A variable number of divisors.\n    Returns:\n        int: The smallest number that is divisible by each of the provided divisors.\n    Examples:\n        >>> smallest_number_meeting_conditions(18, 24)\n        72\n        >>> smallest_number_meeting_conditions(7, 14, 35)\n        70\n    \"\"\"\n    return calculate_lcm(*divisors)"], ["def is_prime(n):\n    \"\"\"\n    Check if a given number is a prime number.\n    Parameters:\n    n : int\n        The number to check\n    Returns:\n    bool\n        True if n is prime, False otherwise.\n        \n    Example:\n    >>> is_prime(2)\n    True\n    >>> is_prime(4)\n    False\n    \"\"\"\n    if n == 1:\n        return False\n    elif n == 2:\n        return True\n    else:\n        for x in range(2, n):\n            if n % x == 0:\n                return False\n        return True"], ["def find_factors(num):\n    \"\"\"\n    Finds all factors of a given number.\n    \n    Parameters:\n    - num (int): The number to find factors for.\n    Returns:\n    - List[int]: A list of all factors of num.\n    \n    Examples:\n    - find_factors(12) -> [1, 2, 3, 4, 6, 12]\n    \"\"\"\n    factors = []\n    for potential_factor in range(1, int(num**0.5) + 1):\n        if num % potential_factor == 0:\n            factors.append(potential_factor)\n            if potential_factor != num // potential_factor:\n                factors.append(num // potential_factor)\n    factors.sort()\n    return factors"]], "Multiples": [["def find_multiples_in_range(base, start, end):\n    \"\"\"\n    Generate all multiples of a base number within a specified range.\n    \n    Parameters:\n    - base (int): The base number of which multiples are to be found.\n    - start (int): The start of the range.\n    - end (int): The end of the range (inclusive).\n    \n    Returns:\n    - list: A list of multiples of the base number within the specified range.\n    \n    Examples:\n    >>> find_multiples_in_range(3, 100, 200)\n    [102, 105, 108, ..., 198]\n    >>> find_multiples_in_range(5, 1, 25)\n    [5, 10, 15, 20, 25]\n    \"\"\"\n    if base == 0:\n        raise ValueError(\"Base cannot be zero.\")\n    return [i for i in range(max(base, start - start % base), end + 1, base) if i >= start]", "def generate_multiples(n, start, end):\n    \"\"\"\n    Generate a list of multiples of a number `n` within a specified range [start, end].\n    Parameters:\n    - n (int): The base number to find multiples of.\n    - start (int): The starting point of the range.\n    - end (int): The ending point of the range.\n    Returns:\n    - list of int: A list containing multiples of `n` within the range.\n    Examples:\n    >>> generate_multiples(3, 1, 10)\n    [3, 6, 9]\n    >>> generate_multiples(5, 10, 30)\n    [10, 15, 20, 25, 30]\n    \"\"\"\n    if n <= 0:\n        raise ValueError(\"The base number n must be greater than 0\")\n    return [x for x in range(max(start, n), end + 1, n) if x % n == 0]", "def count_multiples(n, start, end):\n    \"\"\"\n    Count the multiples of a base number `n` within a specified range [start, end].\n    Parameters:\n    - n (int): The base number to find multiples of.\n    - start (int): The lower limit of the range.\n    - uv :::ionateimdmpspace3 :::ionateimdmpspace42 :::ionateimdmpspace54 :::ionateimdmpspace95 :::ionateimdmpspace38 :::ionateimdmpspace71]])\n    [- n: n (int): The starting range limit for multiple counting.\n    - start: (int): The min value of the range for counterting multiples.\n    - start/end: Defines the range within which to find and count multiples of n.\n    - [5, 205, 345, 495]\n    Added an example using larger range and prime base number.\n    \"\"\"\n    if starting < minimum limit of 1 required for start parameters.lication and incrementing of the initial factor.\n    \"\"\"\n    if (end < start) or (n <= 0):\n        raise ValueError(\"Start must be less than or equal to end and n must be positive\")\n    return (end // n) - ((start - 1) // n)"], ["def list_multiples(base, lower_bound, upper_bound):\n    \"\"\"\n    Generates a list of multiples of the given number within a specified range.\n    Parameters:\n    -----------\n    base : int\n        The base number whose multiples are to be found.\n    lower_bound : int\n        The lower boundary of the range (inclusive).\n    upper_bound : int\n        The upper boundary of the range (inclusive).\n    Returns:\n    --------\n    list\n        A list of multiples of the base number within the specified range.\n    Examples:\n    ---------\n    >>> list_multiples(7, 1, 100)\n    [7, 14, 21, 28, 35, 42, 49, 56, 63, 70, 77, 84, 91, 98]\n    \"\"\"\n    from math import ceil\n    start = ceil(lower_bound / base) * base\n    return [n for n in range(start, upper_bound + 1, base) if n >= lower_bound]", "def count_multiples(base, lower_bound, upper_bound):\n    \"\"\"\n    Counts the number of multiples of the base number within a specific range.\n    Parameters:\n    -----------\n    base : int\n        The base number to find multiples of.\n    lower_bound : int\n        The starting value of the range (inclusive).\n    upper_bound : int\n        The ending value of the range (inclusive).\n    Returns:\n    --------\n    int\n        The count of multiples of the base number within the range.\n    Examples:\n    ---------\n    >>> count_multiples(5, 1, 100)\n    20\n    >>> count_multiples(12, 50, 200)\n    13\n    \"\"\"\n    if base <= 0:\n        raise ValueError(\"Base must be a positive integer\")\n    if upper_bound < lower_bound:\n        return 0\n    start = (lower_bound + base - 1) // base\n    end = upper_bound // base\n    return end - start + 1"], ["def lcm_two_numbers(a, b):\n    \"\"\"\n    Compute the Least Common Multiple (LCM) of two integers using the Greatest Common Divisor (GCD).\n    \n    Parameters:\n    - a (int): The first integer.\n    - b (int): The second integer.\n    \n    Returns:\n    - int: The LCM of the two integers.\n    \n    Examples:\n    --------\n    >>> lcm_two_numbers(12, 15)\n    60\n    >>> lcm_two_numbers(5, 10)\n    10\n    \"\"\"\n    return abs(a*b) // math.gcd(a, b)", "def lcm_multiple_numbers(numbers):\n    \"\"\"\n    Compute the Least Common Multiple (LCM) of a list of integers using the `lcm_two_numbers` function.\n    \n    Parameters:\n    - numbers (list of int): A list of integers.\n    \n    Returns:\n    - int: The LCM of all the integers in the list.\n    \n    Examples:\n    --------\n    >>> lcm_multiple_numbers([4, 6, 8])\n    24\n    >>> lcm_multiple_numbers([3, 7, 14])\n    42\n    \"\"\"\n    def lcm(a, b):\n        return abs(a*b) // math.gcd(a, b)\n    \n    return reduce(lcm, numbers)", "def lcm(*numbers):\n    \"\"\"\n    Calculate the Least Common Multiple (LCM) of two or more integers.\n    \n    Parameters:\n        *numbers (int): Variable length argument list of integers.\n    \n    Returns:\n        int: The least common multiple of the input integers.\n    \n    Examples:\n        >>> lcm(15, 20)\n        60\n        >>> lcm(5, 12, 8)\n        120\n        \n    Notes:\n        The LCM of two or more integers is the smallest positive integer that is divisibly by all the input numbers.\n        The function uses the reduce method from functools to apply the lcm_two function across a list of numbers.\n    \"\"\"\n    def lcm_two(a, b):\n        return abs(a*b) // gcd(a, b)\n    \n    return reduce(lcm_two, numbers)"], ["def is_multiple(base, factor):\n    \"\"\"\n    Check if the first integer is a multiple of the second integer.\n    \n    Parameters:\n        base (int): The number to be checked.\n        factor (int): The potential factor of the base number.\n    \n    Returns:\n        bool: True if base is a multiple of factor, False otherwise.\n    \n    Examples:\n        >>> is_multiple(20, 5)\n        True\n        >>> is_multiple(14, 5)\n        False\n        \n    Notes:\n        A number A is considered a multiple of number B if there exists an integer X such that B * X = A.\n    \"\"\"\n    return base % factor == 0"], ["def generate_multiples(base, limit):\n    \"\"\"\n    Generate a list of multiples of a given number up to a specified limit.\n    Parameters\n    ----------\n    base : int\n        The number for which multiples are to be generated.\n    limit : int\n        The maximum value upto which multiples should be calculated.\n    Returns\n    -------\n    list of ints\n        List containing the multiples of the base number up to the limit.\n    Examples\n    --------\n    >>> generate_multiples(3, 30)\n    [3, 6, 9, 12, 15, 18, 21, 24, 27, 30]\n    >>> generate_multiples(5, 50)\n    [5, 10, 15, 20, 25, 30, 35, 40, 45, 50]\n    \"\"\"\n    return list(range(base, limit+1, base))"], ["def nth_multiple(n, base):\n    \"\"\"\n    Calculate the nth multiple of the base number.\n    \n    Parameters:\n    - n (int): The nth multiple to find.\n    - base (int): The base number.\n    \n    Returns:\n    - int: The nth multiple of the base number.\n    \n    Examples:\n    >>> nth_multiple(4, 3)\n    12\n    >>> nth_multiple(5, 10)\n    50\n    \"\"\"\n    return n * base"], ["def least_common_multiple(*numbers):\n    \"\"\"\n    Calculate the least common multiple of two or more integers.\n    \n    Parameters\n    ----------\n    numbers : int\n        A variable number of integer arguments.\n    Returns\n    -------\n    int\n        The least common multiple of the given integers.\n    Examples\n    --------\n    >>> least_common_multiple(4, 6)\n    12\n    >>> least_common_multiple(6, 9, 12)\n    36\n    \"\"\"\n    return lcm(*numbers)"], ["def nearest_multiple(number, base):\n    \"\"\"\n    Find the nearest multiple of 'base' for the given 'number'.\n    \n    Parameters:\n    - number (int): The number to find the nearest multiple to.\n    - base (int): The base number.\n    \n    Returns:\n    - tuple: The nearest lower and higher multiples of 'base' to 'number'.\n    \n    Examples:\n    >>> nearest_multiple(28, 5)\n    (25, 30)\n    \"\"\"\n    lower = number - (number % base)\n    higher = lower + base if number % base != 0 else lower\n    return (lower, higher)"]], "Modular Arithmetic": [["def modular_add(a, b, m):\n    \"\"\"\n    Perform modular addition.\n    Parameters:\n    - a (int): The first operand.\n    - b (int): The second operand.\n    - m (int): The modulus.\n    Returns:\n    int: The result of (a + b) % m.\n    \"\"\"\n    return (a + b) % m", "def modular_sub(a, b, m):\n    \"\"\"\n    Perform modular subtraction.\n    Parameters:\n    - a (int): The first operand.\n    - b (int): The second operand.\n    - m (int): The modulus.\n    Returns:\n    int: The result of (a - b) % m.\n    \"\"\"\n    return (a - b) % m", "def modular_mul(a, b, m):\n    \"\"\"\n    Perform modular multiplication.\n    Parameters:\n    - a (int): The first operand.\n    - b (int): The second operand.\n    - m (int): The modulus.\n    Returns:\n    int: The result of (a * b) % m.\n    \"\"\"\n    return (a * b) % m", "def modular_add(a, b, m):\n    \"\"\"\n    Performs modular addition of two numbers under a given modulus.\n    Parameters:\n    a (int): The first operand.\n    b (int): The second operand.\n    m (int): The modulus to apply.\n    Returns:\n    int: The result of (a + b) % m.\n    Example:\n    >>> modular_add(5, 3, 7)\n    1\n    \"\"\"\n    return (a + b) % m", "def modular_subtract(a, b, m):\n    \"\"\"\n    Performs modular subtraction of two numbers under a given modulus.\n    Parameters:\n    a (int): The first operand.\n    b (int): The second operand.\n    m (int): The modulus to apply.\n    Returns:\n    int: The result of (a - b) % m.\n    Example:\n    >>> modular_subtract(5, 3, 7)\n    2\n    \"\"\"\n    return (a - b) % m", "def modular_multiply(a, b, m):\n    \"\"\"\n    Performs modular multiplication of two numbers under a given modulus.\n    Parameters:\n    a (int): The first operand.\n    b (int): The second operand.\n    m (int): The modulus to apply.\n    Returns:\n    int: The result of (a * b) % m.\n    Example:\n    >>> modular_multiply(3, 4, 7)\n    5\n    \"\"\"\n    return (a * b) % m"], ["def modular_pow(base, exponent, modulus):\n    \"\"\"\n    Efficiently compute (base^exponent) % modulus using the method of exponentiation by squaring.\n    Parameters:\n    - base (int): The base of the power.\n    - exponent (int): The exponent to raise the base to.\n    - modulus (int): The modulus to apply.\n    Returns:\n    int: The result of (base^exponent) % modulus.\n    \"\"\"\n    result = 1\n    base = base % modulus\n    while exponent > 0:\n        if (exponent % 2) == 1:\n            result = (result * base) % modulus\n        exponent = exponent >> 1\n        base = (base * base) % modulus\n    return result", "def modular_exponentiation(base, exponent, modulus):\n    \"\"\"\n    Efficiently calculates (base^exponent) % modulus using the method of repeated squaring.\n    Parameters:\n    base (int): The base of the exponentiation.\n    exponent (int): The exponent to which the base is raised.\n    modulus (int): The modulus.\n    Returns:\n    int: The result of (base^exponent) % modulus.\n    Example:\n    >>> modular_exponentiation(2, 10, 1000)\n    24\n    \"\"\"\n    result = 1\n    base = base % modulus\n    while exponent > 0:\n        if (exponent % 2) == 1:\n            result = (result * base) % modulus\n        exponent = exponent >> 1\n        base = (base * base) % modulus\n    return result", "def modular_exponentiation(base, exponent, mod):\n    \"\"\"\n    Calculate the value of (base^exponent) % mod efficiently using exponentiation by squaring.\n    \n    Parameters:\n    base (int): The base number.\n    exponent (int): The exponent number.\n    mod (int): The modulus.\n    \n    Returns:\n    int: The result of (base^exponent) % mod.\n    \n    Examples:\n    >>> modular_exponentiation(2, 10, 1000)\n    24\n    >>> modular_exponentiation(3, 5, 7)\n    5\n    \"\"\"\n    result = 1\n    base = base % mod\n    while exponent > 0:\n        if (exponent % 2) == 1:\n            result = (result * base) % mod\n        exponent = exponent >> 1\n        base = (base * base) % mod\n    return result", "def mod_pow(base, exponent, modulus):\n    \"\"\"\n    Compute the power of a number with a modulus using efficient exponentiation.\n    \n    Parameters:\n        base (int): Base of the power.\n        exponent (int): Exponent of the power.\n        modulus (int): Modulus to use.\n    \n    Returns:\n        int: The result of (base^exponent) mod modulus.\n    \n    Example:\n        mod_pow(2, 5, 13) returns 6 because (2^5) % 13 = 32 % 13 = 6.\n    \"\"\"\n    return pow(base, exponent, modulus)"], ["def mod_add(a, b, modulus):\n    \"\"\"\n    Perform modular addition.\n    \n    Parameters:\n        a (int): First operand.\n        b (int): Second operand.\n        modulus (int): Modulus to use for the operation.\n    \n    Returns:\n        int: The result of (a + b) mod modulus.\n    \n    Example:\n        mod_add(5, 3, 7) returns 1 because (5 + 3) % 7 = 8 % 7 = 1.\n    \"\"\"\n    return (a + b) % modulus", "def mod_mult(a, b, modulus):\n    \"\"\"\n    Perform modular multiplication.\n    \n    Parameters:\n        a (int): First operand.\n        b (int): Second operand.\n        modulus (int): Modulus to use for the operation.\n    \n    Returns:\n        int: The result of (a * b) mod modulus.\n    \n    Example:\n        mod_mult(4, 6, 10) returns 4 because (4 * 6) % 10 = 24 % 10 = 4.\n    \"\"\"\n    return (a * b) % modulus"], ["def modular_add(a, b, mod):\n    \"\"\"\n    Calculate the sum of two numbers under a given modulus.\n    \n    Parameters:\n    a (int): The first number.\n    b (int): The second number.\n    mod (int): The modulus to apply.\n    \n    Returns:\n    int: The result of (a + b) % mod.\n    \n    Examples:\n    >>> modular_add(3, 5, 7)\n    1\n    >>> modular_add(6, 7, 5)\n    3\n    \"\"\"\n    return (a + b) % mod", "def modular_subtract(a, b, mod):\n    \"\"\"\n    Calculate the difference of two numbers under a given modulus.\n    \n    Parameters:\n    a (int): The first number.\n    b (int): The second number.\n    mod (int): The modulus to apply.\n    \n    Returns:\n    int: The result of (a - b) % mod.\n    \n    Examples:\n    >>> modular_subtract(10, 3, 7)\n    0\n    >>> modular_subtract(5, 2, 10)\n    3\n    \"\"\"\n    return (a - b) % mod"], ["def solve_crt(congruences, moduli):\n    \"\"\"\n    Solve a system of simultaneous linear congruences using the Chinese Remainder Theorem.\n    Parameters:\n    - congruences (list of int): The remainders of the congruences.\n    - moduli (list of int): The moduli for each congruence.\n    Returns:\n    - int: The smallest non-negative solution to the system of congruences.\n    Examples:\n    >>> solve_crt([2, 3], [3, 5])\n    8\n    \"\"\"\n    from sympy.ntheory.modular import solve_congruence\n    return int(solve_congruence([(congruences[i], moduli[i]) for i in range(len(congruences))])[0])", "def solve_system_congruences(congruences):\n    \"\"\"\n    Solve a system of linear congruences using the Chinese Remainder Theorem.\n    \n    Parameters:\n    congruences (list of tuples): A list of tuples where each tuple contains (residue, modulus).\n    \n    Returns:\n    int, bool: The smallest non-negative solution of the system, and a boolean indicating if the solution is unique.\n    \n    Examples:\n    >>> solve_system_congruences([(2, 3), (3, 5), (2, 7)])\n    (23, True)\n    >>> solve_system_congruences([(1, 3), (1, 4), (1, 5)])\n    (1, True)\n    \"\"\"\n    return solve_congruence(*congruences)", "def chinese_remainder_theorem(congruences):\n    \"\"\"\n    Solve simultaneous linear congruences using the Chinese Remainder Theorem.\n    \n    Parameters:\n        congruences (list of tuples): A list of tuples (ai, ni) representing congruences x ≡ ai (mod ni).\n    \n    Returns:\n        int: The smallest non-negative solution to the system of congruences.\n    \n    Example:\n        chinese_remainder_theorem([(2, 3), (3, 5), (2, 7)])\n        returns 23 because x ≡ 2 (mod 3), x ≡ 3 (mod 5), x ≡ 2 (mod 7) has a solution x = 23.\n    \"\"\"\n    from sympy.ntheory.modular import solve_congruence\n    return solve_congruence(*congruences)[0]"], ["def calculate_gcd(num1, num2):\n    \"\"\"\n    Calculate the greatest common divisor (gcd) between two numbers.\n    Parameters\n    ----------\n    num1 : int\n        The first number.\n    num2 : int\n        The second number.\n    Returns\n    -------\n    int\n        The greatest common divisor of the two numbers.\n    Examples\n    --------\n    >>> calculate_gcd(20, 30)\n    10\n    \"\"\"\n    return gcd(num1, num2)"], ["def modular_inv(a, m):\n    \"\"\"\n    Find the modular multiplicative inverse of a under modulo m using the Extended Euclidean Algorithm.\n    Parameters:\n    - a (int): The number to find the inverse of.\n    - m (int): The modulus.\n    Returns:\n    int: The modular inverse of a modulo m if it exists, otherwise `None`.\n    \"\"\"\n    from math import gcd\n    if gcd(a, m) != 1:\n        return None  # No modular inverse if a and m are not coprime\n    u1, u2, u3 = 1, 0, a\n    v1, v2, v3 = 0, 1, m\n    while v3 != 0:\n        q = u3 // v3\n        v1, v2, v3, u1, u2, u3 = (u1 - q * v1), (u2 - q * v2), (u3 - q * v3), v1, v2, v3\n    if u3 != 1:\n        return None\n    return u1 % m", "def get_modular_inverse(a, m):\n    \"\"\"\n    Computes the modular inverse of `a` under the modulus `m` using the Extended Euclidean Algorithm.\n    Parameters:\n    a (int): The number to find the inverse for.\n    m (int): The modulus.\n    Returns:\n    int: The modular inverse of `a` under `m`.\n    Raises:\n    ValueError: If no modular inverse exists, which occurs if `a` and `m` are not coprime.\n    Example:\n    >>> get_modular_inverse(3, 11)\n    4\n    \"\"\"\n    return mod_inverse(a, m)"], ["def modular_div(a, b, m):\n    \"\"\"\n    Perform modular division, which is a multiplication by the modular inverse.\n    Parameters:\n    - a (int): The numerator.\n    - b (int): The denominator, whose modular inverse will be computed.\n    - m (int): The modulus.\n    Returns:\n    int: The result of a * b^-1 % m, or `None` if no inverse exists.\n    \"\"\"\n    inv_b = modular_inv(b, m)\n    if inv_b is None:\n        return None\n    return modular_mul(a, inv_b, m)", "def modular_divide(a, b, m):\n    \"\"\"\n    Performs modular division of two numbers under a given modulus, which is accomplished\n    by multiplying the first number by the modular inverse of the second number.\n    Parameters:\n    a (int): The numerator.\n    b (int): The denominator, for which the modular inverse is computed.\n    m (int): The modulus.\n    Returns:\n    int: The result of (a * b^-1) % m, or raises a ValueError if the inverse does not exist.\n    \n    Example:\n    >>> modular_divide(8, 3, 7)\n    1\n    \"\"\"\n    try:\n        b_inv = mod_inverse(b, m)\n        return modular_multiply(a, b_inv, m)\n    except ValueError:\n        raise ValueError(f\"No modular inverse exists for {b} under modulus {m}\")"], ["def solve_congruence(expression_1, expression_2, mod):\n    \"\"\"\n    Solve for a variable in a congruence equation.\n    Parameters\n    ----------\n    expression_1 : int or str\n        The first expression of the congruence equation.\n    expression_2 : int or str\n        The second expression of the congruence equation.\n    mod : int\n        The modulus.\n    Returns\n    -------\n    int\n        The solution to the congruence equation.\n    Examples\n    --------\n    >>> solve_congruence('x', 1, 3)\n    1\n    \"\"\"\n    expression_1 = simplify(expression_1)\n    expression_2 = simplify(expression_2)\n    return (expression_2 - expression_1) % mod"], ["def simplify_modular_expression(expression):\n    \"\"\"\n    Simplify a numerical expression with respect to mod.\n    \n    Parameters\n    ----------\n    expression : str\n        The expression to simplify.\n        \n    Returns\n    -------\n    int\n        The simplified result.\n        \n    Examples\n    --------\n    >>> simplify_modular_expression('2+3')\n    5\n    \"\"\"\n    return simplify(expression)"], ["def sum_modulo(elements, m):\n    \"\"\"\n    Calculate the sum of elements under modulo m.\n    Parameters:\n    - elements (list of int): The elements to sum.\n    - m (int): The modulus.\n    Returns:\n    - int: The sum of the given elements modulo m.\n    Examples:\n    >>> sum_modulo([1, 2, 3, 4], 5)\n    0\n    \"\"\"\n    return sum(elements) % m"], ["def calculate_modular_inverse(num, mod):\n    \"\"\"\n    Calculate the modular inverse of a number under a certain modulus.\n    Parameters\n    ----------\n    num : int\n        The number to find the inverse of.\n    mod : int\n        The modulus.\n    Returns\n    -------\n    int\n        The modular inverse of the number.\n    Examples\n    --------\n    >>> calculate_modular_inverse(3, 7)\n    5\n    \"\"\"\n    return mod_inverse(num, mod)"], ["def calculate_power_modulo(base, power, mod):\n    \"\"\"\n    Calculate the power of a number modulo a certain number.\n    Parameters\n    ----------\n    base : int\n        The base number.\n    power : int\n        The power to raise the base number to.\n    mod : int\n        The modulus.\n    Returns\n    -------\n    int\n        The result of base^power modulo mod.\n    Examples\n    --------\n    >>> calculate_power_modulo(5, 3, 2)\n    1\n    \"\"\"\n    return pow(base, power, mod)"], ["def find_factors(num):\n    \"\"\"\n    Find all factors of a number.\n    Parameters\n    ----------\n    num : int\n        The number to find factors of.\n    Returns\n    -------\n    List[int]\n        The list of factors of the number.\n    Examples\n    --------\n    >>> find_factors(20)\n    [1, 2, 4, 5, 10, 20]\n    \"\"\"\n    return [i for i in range(1, num + 1) if num % i == 0]"], ["def modular_operations(a, b, op='mod', m=1):\n    \"\"\"\n    Perform modular arithmetic operations such as addition, subtraction, multiplication, \n    and modulus between two numbers under a modulo m.\n    Parameters:\n    - a (int or float): The first operand.\n    - b (int or float): The second operand or the modulus.\n    - op (str): The operation type ('add', 'sub', 'mul', 'mod', 'div').\n    - m (int, optional): The modulo for the operation. Default is 1 for standard operations.\n    Returns:\n    - int or float: Result of the specified operation under modulo m.\n    Examples:\n    >>> modular_operations(10, 3, 'mod')\n    1\n    >>> modular_operations(5, 3, 'add', 7)\n    1\n    >>> modular_operations(4, 3, 'mul', 5)\n    2\n    \"\"\"\n    if op == 'add':\n        return (a + b) % m\n    elif op == 'sub':\n        return (a - b) % m\n    elif op == 'mul':\n        return (a * b) % m\n    elif op == 'mod':\n        return a % b\n    elif op == 'div' and b != 0:  # division mod might need to use multiplicative inverse\n        from sympy import mod_inverse\n        inv_b = mod_inverse(b, m)\n        return (a * inv_b) % m\n    else:\n        raise ValueError(\"Operation not supported or division by zero\")"], ["def find_cycle_length(func, modulus, args=[]):\n    \"\"\"\n    Finds the length of the cycle in a sequence generated by a modular arithmetic function.\n    Parameters:\n    - func (function): The function used to generate the sequence.\n    - modulus (int): The modulus parameter of the function.\n    - args (list): Additional arguments to the function, if any.\n    Returns:\n    int: The length of the cycle.\n    \"\"\"\n    seen = {}\n    value = args[0]\n    for pos in range(modulus*2):\n        if value in seen:\n            return pos - seen[value]\n        seen[value] = pos\n        value = func(value, *args[1:], modulus)\n    return -1"], ["def check_cyclic_pattern(base, mod):\n    \"\"\"\n    Check for a cyclic pattern in modulo operations with a given base and modulus.\n    Parameters\n    ----------\n    base : int\n        The base number.\n    mod : int\n        The modulus.\n    Returns\n    -------\n    List[int]\n        The repeating pattern in the sequence base^k (mod m) for k = 1, 2, ...\n    Examples\n    --------\n    >>> check_cyclic_pattern(2, 3)\n    [2, 1]\n    \"\"\"\n    pattern = []\n    result = 1\n    for _ in range(mod):\n        result = (result * base) % mod\n        if result in pattern:\n            break\n        pattern.append(result)\n    return pattern"]], "Factorials": [["def factorial_properties(n):\n    \"\"\"\n    Provides various properties related to factorial numbers including identifying the number of trailing zeros and factor analysis.\n    Parameters:\n    n : int\n        A non-negative integer to analyse factorial properties.\n    Returns:\n    dict\n        Properties including 'trailing_zeros' and 'is_even'.\n    Examples:\n    >>> factorial_properties(5)\n    {'trailing_zeros': 1, 'is_even': True}\n    >>> factorial_properties(10)\n    {'trailing_zeros': 2, 'is_even': True}\n    \"\"\"\n    fact = calculate_factorial(n)\n    trailing_zeros = 0\n    factor = fact\n    while factor % 10 == 0:\n        trailing_zeros += 1\n        factor //= 10\n    \n    return {'trailing_zeros': trailing_spaces, 'is_even': fact % 2 == 0}", "def factorial_properties(n, analysis_type=\"trailing_zeros\"):\n    \"\"\"\n    Analyze certain properties of factorial of a number n, such as calculating trailing zeros.\n    Parameters:\n    - n (int): The number whose factorial's properties are to be analyzed.\n    - analysis_type (str): Type of analysis to perform on factorial. Supported values are 'trailing_zeros'.\n    Returns:\n    - int: Result of the analysis based on the type specified.\n    Example:\n    >>> factorial_properties(5, \"trailing_zeros\")\n    1\n    >>> factorial_properties(20, \"trailing_zeros\")\n    4\n    \"\"\"\n    if analysis_type == \"trailing_zeros\":\n        # Count trailing zeros in n!\n        count = 0\n        i = 5\n        while n // i >= 1:\n            count += n // i\n            i *= 5\n        return count\n    else:\n        raise ValueError(\"Unsupported analysis type. Supported types: 'trailing_zeros'.\")", "def factorial_properties(n):\n    \"\"\"\n    Return properties of the factorial of a number like its trailing zeros.\n    Parameters:\n    n : int\n        Non-negative integer to analyze factorial properties.\n    Returns:\n    dict\n        Dictionary with 'trailing_zeros'.\n    Examples:\n    >>> factorial_properties(5)\n    {'trailing_zeros': 1}\n    >>> factorial_properties(10)\n    {'trailing_zeros': 2}\n    \"\"\"\n    trailing_zeros = 0\n    factor_of_five = 5\n    while n >= factor_of_five:\n        trailing_zeros += n // factor_of_five\n        factor_of_five *= 5\n    return {'trailing_zeros': trailing_zeros}"], ["def calculate_factorial(n):\n    \"\"\"\n    Computes the factorial of a non-negative integer using a cached approach to enhance efficiency.\n    Parameters:\n    n : int\n        A non-negative integer for which the factorial is to be computed.\n    Returns:\n    int\n        The factorial of the given integer.\n    Examples:\n    >>> calculate_factorial(5)\n    120\n    >>> calculate_factorial(0)\n    1\n    \"\"\"\n    if n == 0 or n == 1:\n        return 1\n    else:\n        return n * calculate_factorial(n - 1)", "def factorial(n):\n    \"\"\"\n    Calculate the factorial of a non-negative integer n using an iterative approach.\n    Parameters:\n    n (int): A non-negative integer whose factorial is to be computed.\n    Returns:\n    int: The factorial of the integer n.\n    Examples:\n    >>> factorial(5)\n    120\n    >>> factorial(0)\n    1\n    Notes:\n    Factorial of 0 is defined as 1. This function will raise a ValueError if a negative integer is provided.\n    \"\"\"\n    if n < 0:\n        raise ValueError(\"Factorial is not defined for negative numbers\")\n    result = 1\n    for i in range(2, n + 1):\n        result *= i\n    return result", "def compute_factorial(n):\n    \"\"\"\n    Compute the factorial of a given non-negative integer n.\n    Parameters:\n    - n (int): A non-negative integer whose factorial is to be calculated.\n    Returns:\n    - int: The factorial of the integer n.\n    Example:\n    >>> compute_factorial(5)\n    120\n    >>> compute_factorial(0)\n    1\n    \"\"\"\n    if n < 0:\n        raise ValueError(\"Factorial is not defined for negative numbers.\")\n    return factorial(n)", "def compute_factorial(n):\n    \"\"\"\n    Compute the factorial of a given non-negative integer n.\n    Parameters\n    ----------\n    n : int\n        A non-negative integer whose factorial is to be computed.\n    Returns\n    -------\n    int\n        The factorial of n.\n    Raises\n    ------\n    ValueError\n        If n is negative.\n    Examples\n    --------\n    >>> compute_factorial(5)\n    120\n    \n    >>> compute_factorial(0)\n    1\n    \"\"\"\n    if n < 0:\n        raise ValueError(\"Factorial is not defined for negative numbers\")\n    return math.factorial(n)", "def compute_factorial(n):\n    \"\"\"\n    Compute the factorial of a non-negative integer.\n    Parameters:\n    n : int\n        The non-negative integer for which the factorial is computed.\n    Returns:\n    int\n        Factorial of the given integer.\n    Examples:\n    >>> compute_factorial(5)\n    120\n    >>> compute_factorial(0)\n    1\n    \"\"\"\n    if not isinstance(n, int) or n < 0:\n        raise ValueError(\"n must be a non-negative integer\")\n    return factorial(n)", "def calculate_factorial(n):\n    \"\"\"\n    Calculate the factorial of a given non-negative integer.\n    \n    Parameters:\n    n (int): A non-negative integer to compute the factorial of.\n    \n    Returns:\n    int: The factorial of `n`.\n    \n    Examples:\n    >>> calculate_factorial(5)\n    120\n    \n    >>> calculate_factorial(0)\n    1\n    \n    Raises:\n    ValueError: If `n` is negative.\n    \"\"\"\n    from math import factorial as math_factorial\n    \n    if n < 0:\n        raise ValueError(\"Factorial is not defined for negative integers\")\n    return math_factorial(n)"], ["def simplify_factorial_expression(expression):\n    \"\"\"\n    Simplifies an expression involving factorials, particularly useful for expressions\n    that include division and multiplication of multiple factorial terms.\n    \n    Parameters:\n    expression (str): A string representing the mathematical expression to simplify,\n                      which can include factorial notation as `factorial(n)` where `n` can be any integer.\n    \n    Returns:\n    sympy.core.expr.Expr: The simplified form of the input expression.\n    \n    Examples:\n    >>> simplify_factorial_expression(\"factorial(5)/factorial(3)\")\n    20\n    \n    >>> simplify_factorial_expression(\"factorial(n)*factorial(n-1)/factorial(n+1)\")\n    factorial(n - 1)\n    \n    Notes:\n    The function uses SymPy's simplification utilities, which can handle symbolic expressions.\n    This function assumes a correct mathematical expression is passed as input.\n    \"\"\"\n    expr = simplify(expression)\n    return expr"], ["def solve_factorial_equation(eq):\n    \"\"\"\n    Placeholder function for solving equations involving factorials. Actual implementation would require symbolic manipulation libraries like sympy.\n    Parameters:\n    eq : str\n        A string representing the equation involving factorials.\n    Returns:\n    list\n        The solutions to the equation, if solvable.\n    Examples:\n    >>> solve_factorial_equation('x! = 120')\n    [5]\n    \"\"\"\n    import sympy as sp\n    x = sp.symbols('x')\n    equation = sp.sympify(eq.replace(\"!\", \"\").replace(\"x\", \"factorial(x)\"))  # simple translation\n    return sp.solve(equation, x)"], ["def simplify_factorial_expression(n, m):\n    \"\"\"\n    Simplifies an expression of the form n! / m! given that n > m.\n    Parameters:\n    n (int): The numerator's factorial base, should be greater than m.\n    m (int): The denominator's factorial base, should be non-negative and less than n.\n    Returns:\n    int: The simplified result of n! / m!.\n    Examples:\n    >>> simplify_factorial_expression(5, 3)\n    20\n    >>> simplify_factorial_expression(6, 1)\n    720\n    Notes:\n    - If n == m, the result of the expression is 1 (since n! / n! = 1).\n    - This function uses an efficient method by only multiplying numbers from m+1 to n.\n    \"\"\"\n    if n < m:\n        raise ValueError(\"Numerator factorial base must be greater than the denominator factorial base\")\n    if m < 0:\n        raise ValueError(\"Factorial base must be non-negative\")\n    result = 1\n    for i in range(m + 1, n + 1):\n        result *= i\n    return result", "def simplify_factorial_expression(n, k):\n    \"\"\"\n    Simplify expressions of the type n! / k! where n >= k using properties of factorials.\n    Parameters\n    ----------\n    n : int\n        Integer where n! is the numerator.\n    k : int\n        Integer where k! is the denominator and 0 <= k <= n.\n    Returns\n    -------\n    int\n        Simplified value of the factorial division n! / k!.\n    Raises\n    ------\n    ValueError\n        If k > n or n < 0 or k < 0.\n    Examples\n    --------\n    >>> simplify_factorial_expression(5, 3)\n    20\n    \n    >>> simplify_factorial_expression(6, 6)\n    1\n    \n    >>> simplify_factorial_expression(7, 0)\n    5040\n    \"\"\"\n    if n < 0 or k < 0:\n        raise ValueError(\"n and k should be non-negative\")\n    if k > n:\n        raise ValueError(\"k should not be greater than n\")\n    result = 1\n    # n! / k! = n * (n-1) * ... * (k+1)\n    for i in range(k + 1, n + 1):\n        result *= i\n    return result"], ["def factorial_gcd(a, b):\n    \"\"\"\n    Compute the greatest common divisor (GCD) of the factorials of two non-negative integers.\n    Parameters:\n    a : int\n        The first non-negative integer.\n    b : int\n        The second non-negative integer.\n    Returns:\n    int\n        GCD of the factorials of a and b.\n    Examples:\n    >>> factorial_gcd(5, 3)\n    6\n    >>> factorial_gcd(7, 7)\n    5040\n    \"\"\"\n    return factorial(min(a, b))  # GCD of a! and b! is min(a, b)!"], ["def compute_double_factorial(n):\n    \"\"\"\n    Compute the double factorial of a non-negative integer, denoted as n!!,\n    which is the product of positive integers up to n that have the same parity as n.\n    Parameters:\n    n : int\n        A non-negative integer to compute the double factorial for.\n    Returns:\n    int\n        Double factorial of the integer n.\n    Examples:\n    >>> compute_double_factorial(5)\n    15\n    >>> compute_double_factorial(6)\n    48\n    \"\"\"\n    if not isinstance(n, int) or n < 0:\n        raise ValueError(\"n must be a non-negative integer\")\n    if n == 0 or n == 1:\n        return 1\n    return n * compute_double_factorial(n-2)"]], "Counting Digits": [["def count_fixed_digit_numbers(start, end, fixed_digit, fixed_position):\n    \"\"\"\n    Counts the numbers within a specified range where a given digit appears in a given position.\n    Parameters:\n    - start (int): The starting number of the range (inclusive).\n    - end (int): The ending number of the range (inclusive).\n    - fixed_digit (int): The specific digit to look for.\n    - fixed_position (int): The position (from the right, 1-based) where the digit is fixed.\n    Returns:\n    - int: The count of numbers satisfying the condition.\n    Examples:\n    >>> count_fixed_digit_numbers(100, 500, 2, 3)\n    41\n    >>> count_fixedist_digit_numbers(100, 200, 5, 2)\n    10\n    \"\"\"\n    count = 0\n    for num in range(start, end + 1):\n        str_num = str(abs(num))\n        if len(str_num) >= fixed_position and str_num[-fixed_position] == str(fixed_digit):\n            count += 1\n    return count", "def count_specific_digit_numbers(start, end, allowed_digits):\n    \"\"\"\n    Counts numbers within a range [start, end] that consist exclusively of the allowed digits.\n    \n    Parameters:\n    start (int): Starting value of the range.\n    end (int): Ending value of the range.\n    allowed_digits (set): A set of digits that are allowed in the numbers.\n    Returns:\n    int: Count of numbers only containing the allowed digits.\n    Examples:\n    >>> count_specific_digit_numbers(100, 500, {1, 2, 5})\n    31\n    \"\"\"\n    allowed_digits = set(map(str, allowed_digits))  # Convert digits to strings for comparison\n    count = 0\n    for num in range(start, end + 1):\n        if set(str(num)).issubset(allowed_digits):\n            count += 1\n    return count", "def count_constrained_numbers(start, end, allowed_digits):\n    \"\"\"\n    Count the numbers within a specified range that consist only of allowed digits.\n    Parameters:\n    start (int): Start of the range (inclusive).\n    end (int): End of the range (inclusive).\n    allowed_digits (set): A set of digits that are allowed in the numbers.\n    Returns:\n    int: Count of numbers meeting the criteria.\n    Examples:\n    >>> count_constrained_numbers(100, 500, {1, 2, 5})\n    34  # Example output, exact computation needs implementation.\n    \"\"\"\n    count = 0\n    for number in range(start, end + 1):\n        # Check if every digit in number is in allowed_digits\n        if all(int(digit) in allowed_digits for digit in str(number)):\n            count += 1\n    return count"], ["def range_by_digit_count(digit_count):\n    \"\"\"\n    Provides the minimum and maximum numbers that comprise the range of numbers with the specified digit count.\n    Parameters:\n    digit_count (int): The specific digit count.\n    Returns:\n    tuple: A tuple containing the minimum and maximum numbers that have the specified digit count.\n    Examples:\n    >>> range_by_limit_count(3)\n    (100, 999)\n    \"\"\"\n    if digit_count < 1:\n        raise ValueError(\"digit_count must be at least 1\")\n    min_number = 10**(digit_count - 1)\n    max_number = 10**digit_count - 1\n    return (min_number, max_number)"], ["def count_digits(number):\n    \"\"\"\n    Counts the number of digits in a given integer number.\n    Parameters:\n    - number (int): The number whose digits are to be counted.\n    Returns:\n    - int: The total number of digits in the number.\n    Examples:\n    >>> count_digits(123)\n    3\n    >>> count_digits(-5678)\n    4\n    \"\"\"\n    if number == 0:\n        return 1\n    return int(math.log10(abs(number))) + 1", "def count_digits(number):\n    \"\"\"\n    Calculate the number of digits in a given integer.\n    Parameters:\n    number (int): The number whose digits are to be counted.\n    Returns:\n    int: The number of digits in 'number'.\n    Examples:\n    >>> count_digits(12345)\n    5\n    >>> count_digits(-987)\n    3\n    \"\"\"\n    return int(math.log10(abs(number))) + 1 if number != 0 else 1", "def count_digits(number):\n    \"\"\"\n    Count the number of digits in the given number.\n    Parameters:\n    number (int): The number whose digits are to be counted.\n    Returns:\n    int: The number of digits in the given number.\n    Examples:\n    >>> count_digits(123)\n    3\n    >>> count_digits(-12345)\n    5\n    \"\"\"\n    return len(str(abs(number)))"], ["def count_palindromic_times(limit_hour, limit_minute):\n    \"\"\"\n    Counts all the valid time combinations on a digital clock that are palindromes up to given hour and minute limits.\n    Parameters:\n    - limit_hour (int): Maximum hour limit (24-based or 12-based).\n    - limit_minute (int): Maximum minute limit (typically 60).\n    Returns:\n    - int: Count of valid palindromic times.\n    Examples:\n    >>> count_palindromic_times(24, 60)\n    16\n    >>> count_palindromic_times(12, 60)\n    34\n    \"\"\"\n    def is_palindrome(s):\n        return s == s[::-1]\n    count = 0\n    for hour in range(limit_hour):\n        for min in range(limit_minute):\n            time_str = f\"{hour:02d}:{min:02d}\"\n            time_str = time_str.replace(\":\", \"\")\n            if is_palindrome(time_str):\n                count += 1\n    return count"], ["def count_numbers_in_range_with_property(min_value, max_value, property_checker):\n    \"\"\"\n    Counts the numbers in a given range that satisfy a specified property.\n    Parameters:\n    min_value (int): The minimum value of the range.\n    max_value (int): The maximum value of the range.\n    property_checker (callable): A function that applies a property to check on each number.\n    Returns:\n    int: The count of numbers satisfying 'property_checker'.\n    Examples:\n    >>> count_numbers_in_range_with_property(1, 600, lambda x: x % 2 == 0)\n    300\n    \"\"\"\n    return sum(1 for x in range(min_value, max_value + 1) if property_checker(x))"], ["def is_palindrome(number):\n    \"\"\"\n    Checks if a given integer is a palindrome.\n    Parameters:\n    number (int): The number to check.\n    Returns:\n    bool: True if 'number' is a palindrome, False otherwise.\n    Examples:\n    >>> is_palindrome(12321)\n    True\n    >>> is_palindrome(12345)\n    False\n    \"\"\"\n    num_str = str(number)\n    return num_str == num_str[::-1]"], ["def count_digit_palindromes(start, end):\n    \"\"\"\n    Count the palindromic numbers within a specified numeric range.\n    Parameters:\n    start (int): The starting number of the range.\n    end (int): The ending number of the range.\n    Returns:\n    int: The count of palindromic numbers in the range.\n    Examples:\n    >>> count_digit_palindromes(100, 300)\n    9  # Example output, exact computation needs implementation.\n    \"\"\"\n    count = 0\n    for number in range(start, end + 1):\n        if str(number) == str(number)[::-1]:\n            count += 1\n    return count"]], "Division and Remainders": [["def integer_division(dividend, divisor):\n    \"\"\"\n    Perform integer division and return the quotient and remainder.\n    Parameters:\n    dividend (int): The number to be divided.\n    divisor (int): The number by which to divide.\n    Returns:\n    tuple: A tuple containing the quotient and remainder.\n    Examples:\n    >>> integer_division(10, 3)\n    (3, 1)\n    >>> integer_division(25, 5)\n    (5, 0)\n    \"\"\"\n    if divisor == 0:\n        raise ValueError(\"Divisor cannot be zero.\")\n    \n    quotient = dividend // divisor\n    remainder = dividend % divisor\n    return quotient, remainder", "def quotient_remainder(dividend, divisor):\n    \"\"\"\n    Calculate the quotient and remainder of a given dividend divided by a divisor using integer division.\n    Parameters:\n    dividend (int): The number to be divided.\n    divisor (int): The number by which the dividend is divided.\n    Returns:\n    tuple:\n        quotient (int): The result of the division (without decimals).\n        remainder (int): What remains from the operation that cannot be evenly divided by the divisor.\n    Examples:\n    >>> quotient_remainder(10, 3)\n    (3, 1)\n    >>> quotient_remainder(25, 5)\n    (5, 0)\n    \"\"\"\n    if divisor == 0:\n        raise ValueError(\"Divisor cannot be zero.\")\n    quotient = dividend // divisor\n    remainder = dividend % divisor\n    return quotient, remainder", "def validate_division(dividend, divisor, quotient, remainder):\n    \"\"\"\n    Validates a division operation by checking if the dividend can be reconstructed from the divisor, quotient, and remainder.\n    Parameters:\n    dividend (int): The original number to be divided.\n    divisor (int): The divisor used in the division.\n    quotient (int): The quotient obtained from the division.\n    remainder (int): The remainder obtained from the division.\n    Returns:\n    bool:\n        True if the validation is successful (dividend = divisor * quotient + remainder), otherwise False.\n    Examples:\n    >>> validate_division(10, 3, 3, 1)\n    True\n    >>> validate_division(26, 5, 5, 1)\n    True\n    \"\"\"\n    return dividend == divisor * quotient + remainder", "def calculate_division_properties(dividend, divisor):\n    \"\"\"\n    Calculates the quotient and remainder of integer division.\n    Parameters:\n        dividend (int): The number to be divided.\n        divisor (int): The number by which to divide.\n    Returns:\n        tuple:\n        - quotient (int): Result of the integer division.\n        - remainder (int): The remainder left over when dividend is divided by divisor.\n    Examples:\n    >>> calculate_division_properties(10, 3)\n    (3, 1)\n    >>> calculate_division_properties(25, 4)\n    (6, 1)\n    \"\"\"\n    if divisor == 0:\n        raise ValueError(\"Divisor cannot be zero.\")\n    quotient = dividend // divisor\n    remainder = dividend % divisor\n    return quotient, remainder"], ["def modular_add(a, b, modulus):\n    \"\"\"\n    Perform modular addition between two numbers.\n    Parameters:\n    a (int): First number.\n    b (int): Second number.\n    modulus (int): Modulus to be applied.\n    Returns:\n    int: Result of (a + b) % modulus\n    Examples:\n    >>> modular_add(5, 3, 7)\n    1\n    \"\"\"\n    return (a + b) % modulus", "def modular_sub(a, b, modulus):\n    \"\"\"\n    Perform modular subtraction between two numbers.\n    Parameters:\n    a (int): First number.\n    b (int): Second number.\n    modulus (int): Modulus to be applied.\n    Returns:\n    int: Result of (a - b) % modulus\n    Examples:\n    >>> modular_sub(5, 3, 7)\n    2\n    \"\"\"\n    return (a - b) % modulus", "def modular_mult(a, b, modulus):\n    \"\"\"\n    Perform modular multiplication between two numbers.\n    Parameters:\n    a (int): First number.\n    b (int): Second number.\n    modulus (int): Modulus to be applied.\n    Returns:\n    int: Result of (a * b) % modulus\n    Examples:\n    >>> modular_mult(3, 4, 5)\n    2\n    \"\"\"\n    return (a * b) % modulus"], ["def factorial_mod(n, modulus):\n    \"\"\"\n    Compute factorial of n modulo a given modulus.\n    Parameters:\n    n (int): Number to compute factorial of.\n    modulus (int): Modulus to be applied to the factorial result.\n    Returns:\n    int: n! % modulus\n    Examples:\n    >>> factorial_mod(5, 7)\n    1\n    \"\"\"\n    result = 1\n    for i in range(2, n + 1):\n        result = (result * i) % modulus\n    return result\n    print(modular_add(5, 3, 7))   # Outputs 1\n    print(modular_sub(5, 3, 7))   # Outputs 2\n    print(modular_mult(3, 4, 5))  # Outputs 2\n    print(modular_div(8, 3, 5))   # Outputs 1\n    print(modular_pow(2, 10, 1000)) # Outputs 24\n    print(factorial_mod(5, 7))    # Outputs 1", "def factorial_modular(n, modulus):\n    \"\"\"\n    Calculate factorial of a number modulo a given number.\n    \n    Parameters:\n        n (int): The number to compute factorial for.\n        modulus (int): The modulus.\n        \n    Returns:\n        int: n! % modulus\n    \n    Examples:\n        >>> factorial_modular(5, 3)\n        2\n        >>> factorial_modular(0, 1)\n        0\n    \"\"\"\n    result = 1\n    for i in range(2, n + 1):\n        result = (result * i) % modulus\n    return result"], ["def modular_pow(base, exp, modulus):\n    \"\"\"\n    Efficiently compute (base ** exp) % modulus using exponentiation by squaring.\n    Parameters:\n    base (int): The base number.\n    exp (int): The exponent.\n    modulus (int): Modulus to be applied.\n    Returns:\n    int: Result of (base ** exp) % modulus\n    Examples:\n    >>> modular_pow(2, 10, 1000)\n    24\n    \"\"\"\n    result = 1\n    base = base % modulus\n    while exp > 0:\n        if exp % 2 == 1:\n            result = (result * base) % modulus\n        exp = exp >> 1\n        base = (base * base) % modulus\n    return result", "def modular_exponentiation(base, exponent, modulus):\n    \"\"\"\n    Efficiently compute (base ** exponent) % modulus using the method of exponentiation by squaring.\n    Parameters\n    ----------\n    base : int\n        The base number.\n    exponent : int\n        The exponent.\n    modulus : int\n        The modulus.\n    Returns\n    -------\n    int\n        The result of (base ** exponent) % modulus.\n    Examples\n    --------\n    >>> modular_exponentiation(2, 10, 1000)\n    24\n    \n    >>> modular_exponentiation(3, 200, 13)\n    9\n    \"\"\"\n    result = 1\n    base = base % modulus\n    while exponent > 0:\n        if (exponent % 2) == 1:\n            result = (result * base) % modulus\n        exponent = exponent >> 1\n        base = (base * base) % modulus\n    return result"], ["def find_remainder(n, m):\n    \"\"\"\n    Calculate the remainder when n is divided by m (n % m).\n    Parameters\n    ----------\n    n : int\n        The dividend.\n    m : int\n        The divisor.\n    Returns\n    -------\n    int\n        The remainder of the division of n by m (0 <= remainder < m).\n    Examples\n    --------\n    >>> find_remainder(10, 3)\n    1\n    >>> find_remainder(-10, 3)\n    2\n    \"\"\"\n    return n % m", "def positive_remainder(n, m):\n    \"\"\"\n    Calculate the positive remainder when n is divided by m, even if n is negative.\n    Parameters\n    ----------\n    n : int\n        The dividend.\n    m : int\n        The divisor.\n    Returns\n    -------\n    int\n        The positive remainder of the division of n by m.\n    Examples\n    --------\n    >>> positive_remainder(-10, 3)\n    2\n    \n    >>> positive_remainder(-8, 5)\n    2\n    \"\"\"\n    r = n % m\n    return r if r >= 0 else r + m"], ["def polynomial_division(dividend, divisor):\n    \"\"\"\n    Perform polynomial division and return the quotient and remainder.\n    Parameters:\n    dividend (list): Coefficients of the dividend polynomial, starting from the highest power.\n    divisor (list): Coefficients of the divisor polynomial, starting from the highest power.\n    Returns:\n    tuple: A tuple containing the list of coefficients for the quotient and the remainder.\n    Examples:\n    >>> polynomial_division([1, -3, 0, -4], [1, -1])\n    ([1.0, -2.0, -2.0], [-2.0])\n    \"\"\"\n    from numpy.polynomial import Polynomial as P\n    p = P(dividend)\n    q = P(divisor)\n    quotient, remainder = p // q, p % q\n    return (quotient.coef, remainder.coef)", "def polynomial_division(dividend, divisor):\n    \"\"\"\n    Performs polynomial division and returns the quotient and remainder.\n    Parameters:\n        dividend (sympy.Poly): The polynomial to be divided.\n        divisor (sympy.Poly): The polynomial by which to divide.\n    Returns:\n        tuple:\n        - quotient (sympy.Poly): The quotient polynomial.\n        - remainder (sympy.Poly): The remainder polynomial.\n    Examples:\n    >>> x = symbols('x')\n    >>> polynomial_division(x**2 + 2*x + 1, x + 1)\n    (x + 1, 0)\n    >>> polynomial_division(x**3 + 2*x**2 + 1, x**2 + 1)\n    (x, x + 1)\n    \"\"\"\n    quotient, remainder = div(dividend, divisor)\n    return quotient, remainder"], ["def sequence_periodicity(base, modulus):\n    \"\"\"\n    Identify the period of the sequence of powers of a number modulo another number.\n    Parameters\n    ----------\n    base : int\n        The base number.\n    modulus : int\n        The modulus.\n    Returns\n    -------\n    int\n        The length of the periodic cycle.\n    Examples\n    --------\n    >>> sequence_periodicity(2, 5)\n    4\n    \n    >>> sequence_periodicity(10, 6)\n    1\n    \"\"\"\n    period = 1\n    current = base % modulus\n    while True:\n        if modular_exponentiation(base, period, modulus) == current:\n            break\n        period += 1\n    return period"], ["def find_modular_inverses(n, modulus):\n    \"\"\"\n    Finds all values x such that (x * n) % modulus == 1, i.e., modular inverses under a given modulus.\n    Parameters:\n        n (int): The integer number for which to find the modular inverses.\n        modulus (int): The modulus under which the inverses are calculated.\n    Returns:\n        list: List of all integers x such that x is an inverse of n under modulus.\n    Examples:\n    >>> find_modular_inverses(3, 11)\n    [4]\n    >>> find_modular_inverses(2, 5)\n    [3]\n    \"\"\"\n    if modulus <= 0:\n        raise ValueError(\"Modulus must be a positive integer.\")\n    inverses = [x for x in range(1, modulus) if (n * x) % modulus == 1]\n    return inverses"], ["def positive_modular(a, b):\n    \"\"\"\n    Ensure the result of modular operation is positive.\n    \n    Parameters:\n        a (int): The number to be taken modulo of.\n        b (int): The modulus.\n        \n    Returns:\n        int: A positive remainder after division.\n        \n    Examples:\n        >>> positive_modular(-10, 3)\n        2\n    \"\"\"\n    return a % b"], ["def find_extreme_remainder(dividend, divisors, mode='max'):\n    \"\"\"\n    For a given dividend and list of divisors, find the divisor which yields the maximum or minimum remainder.\n    \n    Parameters:\n    dividend (int): The number to be divided.\n    divisors (list of int): A list of divisors.\n    mode (str): Either 'max' or 'min', determines whether to find the maximum or minimum remainder.\n    Returns:\n    dict: A dictionary with keys 'divisor', 'remainder', and 'extreme_value' showing the selected divisor, its remainder, and the value of the remainder.\n    Examples:\n    >>> find_extreme_remainder(10, [1, 2, 3, 4])\n    {'divisor': 3, 'remainder': 1, 'extreme_value': 1}\n    >>> find_extreme_remainder(10, [2, 3, 4], mode='min')\n    {'divisor': 2, 'remainder': 0, 'extreme_value': 0}\n    >>> find_extreme_remainder(10, [2, 3, 4], mode='max')\n    {'divisor': 3, 'remainder': 1, 'extreme_value': 1}\n    \"\"\"\n    if not divisors:\n        raise ValueError(\"Divisors list cannot be empty.\")\n    best_match = None\n    extreme_value = None\n    for divisor in divisors:\n        if divisor == 0:\n            continue\n        remainder = dividend % divisor\n        if (mode == 'max' and (extreme_value is None or remainder > extreme_value)) or (mode == 'min' and (extreme_value is None or remainder < extreme_value)):\n            best_match = divisor\n            extreme_value = remainder\n    return {'divisor': best_match, 'remainder': extreme_value, 'extreme_value': extreme_value}"], ["def modular_remainder(a, b):\n    \"\"\"\n    Calculate the remainder when one number is divided by another using modular arithmetic.\n    \n    Parameters:\n        a (int): The dividend\n        b (int): The divisor (non-zero)\n        \n    Returns:\n        int: The remainder after division\n        \n    Examples:\n        >>> modular_remainder(10, 3)\n        1\n        >>> modular_remainder(-10, 3)\n        2\n    \"\"\"\n    return a % b"], ["def modular_div(a, b, modulus):\n    \"\"\"\n    Perform modular division where result is a * (inverse of b modulo modulus).\n    Parameters:\n    a (int): Numerator.\n    b (int): Denominator to find the modular inverse of.\n    modulus (int): Modulus to be applied.\n    Returns:\n    int: Result of (a * modular_inverse(b, modulus)) % modulus\n    Examples:\n    >>> modular_div(8, 3, 5)\n    1\n    Note:\n    This function assumes that b has a modular inverse under the given modulus (modulus and b are coprime).\n    \"\"\"\n    from sympy import mod_inverse\n    return (a * mod_inverse(b, modulus)) % modulus"], ["def find_least_in_sequence_mod_conditions(conditions):\n    \"\"\"\n    Find the smallest positive integer that satisfies a list of modular conditions.\n    Parameters\n    ----------\n    conditions : list of tuple\n        A list of tuples where each tuple represents (remainder, modulus).\n    Returns\n    -------\n    int\n        The smallest positive integer that satisfies all the modular conditions.\n    Examples\n    --------\n    >>> find_least_in_sequence_mod_conditions([(2, 3), (3, 5)])\n    8\n    \n    >>> find_least_in_sequence_mod_conditions([(1, 4), (3, 6)])\n    7\n    \"\"\"\n    sol, _ = solve_congruence(*conditions)\n    return sol"], ["def modular_power(base, exponent, modulus):\n    \"\"\"\n    Calculate the result of base raised to the power exponent, all under modulo of a specified number.\n    \n    Parameters:\n        base (int): The base of the exponentiation.\n        exponent (int): The exponent.\n        modulus (int): The modulus to reduce the large number.\n        \n    Returns:\n        int: The result of (base ** exponent) % modulus\n    \n    Examples:\n        >>> modular_power(2, 10, 1000)\n        24\n    \"\"\"\n    return pow(base, exponent, modulus)"]], "Greatest Common Divisor (GCD)": [["def prime_factorization(n):\n    \"\"\"\n    Decomposes a number into its constituent prime factors.\n    Parameters:\n        n (int): The integer to factorize.\n    Returns:\n        list: A list of prime factors of the integer.\n    Examples:\n        >>> prime_factorization(18)\n        [2, 3]\n        \n        >>> prime_factorization(100)\n        [2, 5]\n    \"\"\"\n    return primefactors(n)", "def prime_factors(n):\n    \"\"\"\n    Calculate the prime factors of a given number.\n    Parameters:\n    n (int): The integer to factorize.\n    Returns:\n    dict: Dictionary of prime factors and their exponents.\n    Example:\n    >>> prime_factors(60)\n    {2: 2, 3: 1, 5: 1}\n    \"\"\"\n    from sympy import primefactors\n    factors = {}\n    for p in primefactors(n):\n        count = 0\n        x = n\n        while x % p == 0:\n            x //= p\n            count += 1\n        factors[p] = count\n    return factors", "def prime_factors(n):\n    \"\"\"\n    Computes the prime factors of a given integer, returned in a dictionary where keys are the primes\n    and values are their corresponding exponents in the factorization.\n    \n    Parameters:\n        n (int): The integer to factorize.\n    Returns:\n        dict: A dictionary of prime factors with their exponents.\n    Examples:\n    >>> prime_factors(360)\n    {2: 3, 3: 2, 5: 1}\n    >>> prime_factors(13)\n    {13: 1}\n    \"\"\"\n    from collections import defaultdict\n    factors = defaultdict(int)\n    # Check for number of 2s in n\n    while n % 2 == 0:\n        factors[2] += 1\n        n //= 2\n    # n must be odd at this point, thus skip even numbers\n    for i in range(3, int(n**0.5) + 1, 2):\n        while (n % i == 0):\n            factors[i] += 1\n            n //= i\n    if n > 2:\n        factors[n] += 1\n    return dict(factors)"], ["def gcd_multiple(numbers):\n    \"\"\"\n    Calculate the Greatest Common Divisor (GCD) of a list of numbers using the Euclidean Algorithm applied iteratively.\n    \n    Parameters:\n    - numbers (list of int): List of non-negative integers.\n    \n    Returns:\n    - int: GCD of all the integers in the list\n    \n    Examples:\n    >>> gcd_multiple([24, 108, 36])\n    12\n    >>> gcd_multiple([45, 55, 65])\n    5\n    \"\"\"\n    from functools import reduce  # Importing reduce function to apply gcd iteratively over list\n    return reduce(gcd, numbers)", "def multiple_gcd(numbers):\n    \"\"\"\n    Calculates the greatest common divisor (GCD) of a list of numbers.\n    Uses the math.gcd function and a reduction strategy to handle more than two numbers.\n    Parameters:\n        numbers (list of int): A list of integers to find the GCD of.\n    Returns:\n        int: The GCD of all provided numbers.\n    Examples:\n        >>> multiple_gcd([20, 40, 60])\n        20\n        >>> multiple_gcd([21, 14, 35])\n        7\n    \"\"\"\n    return reduce(gcd, numbers)", "def calculate_gcd_list(numbers):\n    \"\"\"\n    Compute the greatest common divisor of a list of integers.\n    Parameters:\n        numbers (list of int): List of integers.\n    Returns:\n        int: The greatest common divisor of the listed integers.\n    Examples:\n        >>> calculate_gcd_list([48, 64, 256])\n        16\n        >>> calculate_gcd_list([17, 13, 19])\n        1\n    \"\"\"\n    from functools import reduce\n    from math import gcd\n    return reduce(gcd, numbers)", "def compute_gcd(*numbers):\n    \"\"\"\n    Compute the greatest common divisor (GCD) of a list of numbers using the Euclidean algorithm.\n    \n    Parameters:\n    - numbers (int): A sequence of integers. This can be two or more numbers.\n    \n    Returns:\n    - int: The greatest common divisor of the given numbers.\n    \n    Example:\n    >>> compute_gcd(150, 100, 250)\n    50\n    >>> compute_gcd(45, 60)\n    15\n    >>> compute_gcd(123456, 789012, 345678)\n    6\n    \"\"\"\n    def euclidean_gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return abs(a)\n    \n    return reduce(euclidean_gcd, numbers)", "def gcd(*numbers):\n    \"\"\"\n    Compute the GCD of multiple numbers using the Euclidean algorithm.\n    Parameters:\n    numbers (int): A series of integers to compute the GCD.\n    Returns:\n    int: The greatest common divisor.\n    Example:\n    >>> gcd(48, 64, 256)\n    16\n    \"\"\"\n    from math import gcd as single_gcd\n    from functools import reduce\n    return reduce(single_gcd, numbers)", "def gcd_multiple(numbers):\n    \"\"\"\n    Compute the Greatest Common Divisor (GCD) of a list of numbers.\n    \n    Parameters:\n        numbers (list of int): A list of integers for which the GCD is required.\n    \n    Returns:\n        int: The greatest common divisor of the provided numbers.\n    \n    Examples:\n        >>> gcd_multiple([42, 56, 98])\n        14\n        >>> gcd_multiple([20, 40])\n        20\n    \"\"\"\n    return reduce(math.gcd, numbers)", "def gcd_multiple_numbers(*numbers):\n    \"\"\"\n    Calculate the Greatest Common Divisor (GCD) of multiple integers using the\n    Euclidean algorithm applied iteratively.\n    Parameters\n    ----------\n    numbers : int\n        A sequence of integers whose GCD is to be found.\n    Returns\n    -------\n    int\n        The gcd of all provided integers\n    Examples\n    --------\n    >>> gcd_multiple_numbers(20, 40, 60, 80)\n    20\n    >>> gcd_multiple_numbers(121, 11, 242)\n    11\n    \"\"\"\n    return reduce(gcd_two_numbers, numbers)", "def compute_gcd(*numbers):\n    \"\"\"\n    Compute the greatest common divisor (GCD) of multiple integers.\n    Parameters:\n    *numbers : int\n        Variable number of integer arguments to compute the GCD of.\n    Returns:\n    int\n        The GCD of the provided integers.\n    Examples:\n    --------\n    >>> compute_gcd(8, 12)\n    4\n    >>> compute_gcd(18, 24, 36)\n    6\n    \"\"\"\n    return reduce(math.gcd, numbers)", "def calculate_gcd_extended(*args):\n    \"\"\"\n    Compute the GCD of multiple integers by consecutively applying the GCD function.\n    Parameters:\n        *args (int): Variable length integer list.\n    Returns:\n        int: The greatest common divisor of all provided integers.\n    Examples:\n        >>> calculate_gcd_extended(48, 60, 72)\n        12\n        >>> calculate_gcd_extended(8, 12, 16)\n        4\n    \"\"\"\n    from functools import reduce\n    return reduce(calculate_gcd, args)"], ["def pairwise_gcd(numbers):\n    \"\"\"\n    Calculates the GCD by comparing pairs of numbers based on their prime factorization.\n    This function is useful when detailed factor analysis is needed.\n    Parameters:\n        numbers (list of int): A list of integers to find the GCD of using pairwise comparison.\n    Returns:\n        int: The GCD computed using prime factorization and pairwise comparison.\n    Examples:\n        >>> pairwise_gcd([18, 24, 30])\n        6\n        >>> pairwise_gcd([121, 11])\n        11\n    \"\"\"\n    common_factors = set(prime_factorization(numbers[0]))\n    for number in numbers[1:]:\n        common_factors.intersection_update(prime_factorization(number))\n    if not common_factors:\n        return 1\n    common_factors = sorted(list(common_factors))\n    min_exp_gcd = []\n    for factor in common_factors:\n        min_exp = min(number_prime_exp[number//factor] for number_prime_exp in map(lambda x: x//factor, numbers))\n        min_exp_gcd.append(factor ** min_exp)\n    return reduce(lambda x, y: x*y, min_exp_gcd, 1)", "def gcd_from_prime_factors(*numbers):\n    \"\"\"\n    Calculate the GCD of one or more numbers using their prime factorizations.\n    Parameters:\n    numbers (int): A series of integers to find the GCD of.\n    Returns:\n    int: The greatest common divisor.\n    Example:\n    >>> gcd_from_prime_factors(8, 12)\n    4\n    \"\"\"\n    if len(numbers) < 2:\n        raise ValueError(\"At least two numbers are required to compute the GCD.\")\n    \n    common_factors = None\n    for number in numbers:\n        pf = prime_factors(number)\n        if common_factors is None:\n            common_factors = pf\n        else:\n            common_factors = {p: min(common_factors.get(p, 0), exp) for p, exp in pf.items()}\n    \n    gcd = 1\n    for p, exp in common_factors.items():\n        gcd *= p ** exp\n    return gcd", "def gcd_from_factors(factors1, factors2):\n    \"\"\"\n    Computes the greatest common divisor (GCD) based on the prime factorizations of two numbers.\n    \n    Parameters:\n        factors1 (dict): Prime factors and their exponents for the first number.\n        factors2 (dict): Prime factors and their exponents for the second number.\n    Returns:\n        int: The GCD of the two numbers based on their prime factorizations.\n    Examples:\n    >>> gcd_from_factors({2: 3, 3: 2, 5: 1}, {2: 2, 3: 1, 7: 1})\n    12\n    \"\"\"\n    common_factors = set(factors1.keys()).intersection(factors2.keys())\n    gcd = 1\n    for p in common_factors:\n        exp = min(factors1[p], factors2[p])\n        gcd *= p ** exp\n    return gcd"], ["def calculate_lcm(a, b):\n    \"\"\"\n    Calculate the Least Common Multiple (LCM) using the relationship with GCD.\n    Parameters:\n    a (int): The first number.\n    b (int): The second number.\n    Returns:\n    int: The LCM of the two numbers.\n    Examples:\n    >>> calculate_lcm(12, 18)\n    36\n    >>> calculate_lcm(5, 7)\n    35\n    \"\"\"\n    return abs(a*b) // gcd(a, b)", "def gcd_lcm(a, b):\n    \"\"\"\n    Computes both GCD and LCM of two integers using their mathematical relationship.\n    Parameters:\n    a (int): The first integer.\n    b (int): The second integer.\n    Returns:\n    tuple: The GCD and LCM of the two integers.\n    Examples:\n    >>> gcd_lcm(21, 6)\n    (3, 42)\n    >>> gcd_lcm(20, 5)\n    (5, 20)\n    \"\"\"\n    gcd_ab = gcd(a, b)\n    lcm_ab = abs(a*b) // gcd_ab\n    return gcd_ab, lcm_ab", "def lcm(a, b):\n    \"\"\"\n    Compute the Least Common Multiple (LCM) of two integers based on the GCD.\n    \n    Parameters:\n        a (int): First integer.\n        b (int): Second integer.\n    \n    Returns:\n        int: The least common multiple of the two integers.\n    \n    Examples:\n        >>> lcm(4, 6)\n        12\n        >>> lcm(21, 6)\n        42\n    \"\"\"\n    return abs(a*b) // math.gcd(a, b)"], ["def lcm_multiple(numbers):\n    \"\"\"\n    Compute the Least Common Multiple (LCM) of a list of numbers using pairwise LCM calculation.\n    \n    Parameters:\n        numbers (list of int): A list of integers for which the LCM is required.\n    \n    Returns:\n        int: The least common multiple of the provided numbers.\n    \n    Examples:\n        >>> lcm_multiple([4, 6, 8])\n        24\n        >>> lcm_multiple([5, 7, 12])\n        420\n    \"\"\"\n    return reduce(lcm, numbers)", "def compute_lcm(*numbers):\n    \"\"\"\n    Compute the least common multiple (LCM) of multiple integers.\n    Parameters:\n    *numbers : int\n        Variable number of integer arguments to compute the LCM of.\n    Returns:\n    int\n        The LCM of the provided integers.\n    Examples:\n    --------\n    >>> compute_lcm(4, 5)\n    20\n    >>> compute_lcm(6, 8, 12)\n    24\n    \"\"\"\n    def lcm(x, y):\n        return abs(x * y) // math.gcd(x, y)\n    \n    return reduce(lcm, numbers)"], ["def gcd(a, b):\n    \"\"\"\n    Calculate the Greatest Common Divisor (GCD) of two numbers using the Euclidean Algorithm.\n    \n    Parameters:\n    - a (int): The first non-negative integer.\n    - b (int): The second non-negative integer.\n    \n    Returns:\n    - int: GCD of the two integers\n    \n    Examples:\n    >>> gcd(12, 18)\n    6\n    >>> gcd(13, 29)\n    1\n    \"\"\"\n    while b != 0:\n        a, b = b, a % b\n    return a", "def calculate_gcd(a, b):\n    \"\"\"\n    Calculate the Greatest Common Divisor (GCD) of two numbers.\n    Parameters:\n    a (int): The first number.\n    b (int): The second number.\n    Returns:\n    int: The GCD of the two numbers.\n    Examples:\n    >>> calculate_gcd(12, 18)\n    6\n    >>> calculate_gcd(100, 25)\n    25\n    \"\"\"\n    return gcd(a, b)", "def calculate_gcd(a, b):\n    \"\"\"\n    Calculate the greatest common divisor of two integers using Euclid's algorithm.\n    Parameters:\n        a (int): First integer.\n        b (int): Second integer.\n    Returns:\n        int: The greatest common divisor of a and b.\n    Examples:\n        >>> calculate_gcd(54, 24)\n        6\n        >>> calculate_gcd(17, 13)\n        1\n    \"\"\"\n    from math import gcd\n    return gcd(a, b)", "def compute_gcd(a, b):\n    \"\"\"\n    Computes the greatest common divisor (GCD) of two integers using the Euclidean algorithm.\n    \n    Parameters:\n        a (int): The first integer.\n        b (int): The second integer.\n    \n    Returns:\n        int: The GCD of the two integers.\n    \n    Examples:\n        >>> compute_gcd(12, 15)\n        3\n        >>> compute_gcd(100, 200)\n        100\n        >>> compute_gcd(7, 13)\n        1\n    \"\"\"\n    return gcd(a, b)", "def gcd_two_numbers(a, b):\n    \"\"\"\n    Calculate the Greatest Common Divisor (GCD) of two integers using the Euclidean algorithm.\n    Parameters\n    ----------\n    a : int\n        First integer.\n    b : int\n        Second integer.\n    Returns\n    -------\n    int\n        The gcd of the two provided integers.\n    Examples\n    --------\n    >>> gcd_two_numbers(15, 10)\n    5\n    >>> gcd_two_numbers(210, 45)\n    15\n    \"\"\"\n    while b != 0:\n        a, b = b, a % b\n    return abs(a)", "def gcd_euclidean(a, b):\n    \"\"\"\n    Computes the greatest common divisor (GCD) of two integers using the Euclidean algorithm.\n    \n    Parameters:\n        a (int): First integer.\n        b (int): Second integer.\n    Returns:\n        int: GCD of the two integers.\n    Examples:\n    >>> gcd_euclidean(48, 18)\n    6\n    >>> gcd_euclidean(100, 25)\n    25\n    \"\"\"\n    while b != 0:\n        a, b = b, a % b\n    return abs(a)", "def calculate_gcd(a, b):\n    \"\"\"\n    Compute the greatest common divisor (GCD) of two integers using Euclid's algorithm.\n    Parameters:\n        a (int): First integer.\n        b (int): Second integer.\n    Returns:\n        int: The greatest common divisor of a and b.\n    Examples:\n        >>> calculate_gcd(60, 48)\n        12\n        >>> calculate_gcd(17, 13)\n        1\n    \"\"\"\n    import math\n    return math.gcd(a, b)"], ["def solve_linear_diophantine(a, b, c):\n    \"\"\"\n    Solves the linear Diophantine equation ax + by = c where a, b, c are integers and\n    returns the smallest integer solution (x, y) if exists.\n    Parameters:\n        a (int): Coefficient of x.\n        b (int): Coefficient of y.\n        c (int): Constant term.\n    Returns:\n        tuple: A tuple (x, y) representing the solution or None if no solution exists.\n    Examples:\n        >>> solve_linear_diophantine(10, 6, 14)\n        (7, -7)\n        >>> solve_linear_diophantine(7, 5, 1)\n        (1, -1)\n    \"\"\"\n    from math import gcd\n    g = gcd(a, b)\n    if c % g != 0:\n        return None  # No solution\n    # Apply Extended Euclidean Algorithm to find one solution\n    x, y = _extended_gcd(a, b)\n    # Scale the found solution to the correct value\n    return (x * (c // g), y * (c // g))", "def solve_linear_diophantine(a, b, c):\n    \"\"\"\n    Solve the linear Diophantine equation of the form ax + by = c using extended Euclidean algorithm.\n    Parameters:\n        a (int): Coefficient of x.\n        b (int): Coefficient of y.\n        c (int): Constant term on the right side of the equation.\n    Returns:\n        tuple: A tuple (x, y) representing a solution (x, y) to the equation ax + by = c,\n               or None if no solution exists.\n    Examples:\n        >>> solve_linear_diophadier(9, -3, 12)\n        (4, 0)  # One possible solution\n        >>> solve_linear_diophadier(3, 6, 18)\n        (0, 3)  # One possible solution\n        \n    Notes:\n        This function does not handle cases where a or b is zero (degenerate cases).\n    \"\"\"\n    import math\n    g = math.gcd(a, b)\n    if c % g != 0:\n        return None  # No solution\n    # Extend Euclidean Algorithm to find one solution\n    def extended_euclid(a, b):\n        if b == 0:\n            return (1, 0)\n        else:\n            q, r = divmod(a, b)\n            s, t = extended_euclid(b, r)\n            return (t, s - q * t)\n    x1, y1 = extended_euclid(a, b)\n    x0 = x1 * (c // g)\n    y0 = y1 * (c // g)\n    \n    # This returns a particular solution; there are infinitely many solutions\n    # General solution could be written as x = x0 + (b/g)k, y = y0 - (a/g)k for any integer k\n    return (x0, y0)"], ["def factorial(n):\n    if n == 0:\n        return 1\n    else:\n        return n * factorial(n-1)"], ["def validate_gcd_lcm_relationship(a, b):\n    \"\"\"\n    Validate the relationship between GCD and LCM: GCD(a, b) * LCM(a, b) = a * b.\n    Parameters:\n    a : int\n        The first integer.\n    b : int\n        The second integer.\n    Returns:\n    bool\n        True if the relationship holds, else False.\n    Examples:\n    --------\n    >>> validate_gcd_lcm_relationship(15, 20)\n    True\n    >>> validate_gcd_lcm_relationship(8, 9)\n    True\n    \"\"\"\n    gcd = compute_gcd(a, b)\n    lcm = compute_lcm(a, b)\n    return gcd * lcm == a * b"], ["def gcd_of_factorials(a, b):\n    \"\"\"\n    Computes the GCD of the factorials of two integers.\n    Parameters:\n        a (int): The first number whose factorial is considered.\n        b (int): The second number whose factorial is considered.\n    \n    Returns:\n        int: The GCD of the factorials of two integers.\n    \n    Examples:\n        >>> gcd_of_factorials(5, 6)\n        120  # Since 5! = 120 and 6! = 720; gcd(120, 720) = 120\n        >>> gcd_of_factorials(3, 4)\n        6    # Since 3! = 6 and 4! = 24; gcd(6, 24) = 6\n    \"\"\"\n    factorial_a = factorial(a)\n    factorial_b = factorial(b)\n    return gcd(factorial_a, factorial_b)"], ["def gcd_of_polynomials(poly1, poly2):\n    \"\"\"\n    Computes the GCD of two polynomials represented as tuples of coefficients.\n    Parameters:\n        poly1 (tuple): The coefficients of the first polynomial.\n        poly2 (tuple): The coefficients of the second polynomial.\n    \n    Returns:\n        tuple: The GCD of the two polynomials in tuple format.\n    \n    Examples:\n        >>> gcd_of_polynomials((2, 4), (4, 8))\n        (2, 4)  # Equivalent to x + 2 where gcd is computed as tuple (1, 2)\n    \"\"\"\n    from numpy import gcd, polymul\n    # Convert polynomial tuples to a form usable for gcd computation\n    def poly_gcd(poly1, poly2):\n        result = [gcd(a, b) for a, b in zip(poly1, poly2)]\n        return tuple(result)\n    return poly_gcd(poly1, poly2)"], ["def _extended_gcd(a, b):\n    \"\"\"\n    A helper function that returns integers x, y such that ax + by = gcd(a, b).\n    \"\"\"\n    if a == 0:\n        return (0, 1)\n    else:\n        x1, y1 = _extended_gcd(b % a, a)\n        return (y1 - (b // a) * x1, x1)"], ["def calculate_gcd_multiple(numbers):\n    \"\"\"\n    Calculate the GCD of a list of numbers.\n    Parameters:\n    numbers (list of int): A list of integers.\n    Returns:\n    int: The GCD of the list of numbers.\n    Examples:\n    >>> calculate_gcd_multiple([24, 36, 48])\n    12\n    >>> calculate_gcd_multiple([20, 100, 200])\n    20\n    \"\"\"\n    return reduce(gcd, numbers)"]], "Factorials and Multiples": [["def smallest_factorial_multiple(k):\n    \"\"\"\n    Finds the smallest non-negative integer n such that k is a divisor of n!.\n    \n    Parameters:\n    k : int\n        The target divisor.\n        \n    Returns:\n    int\n        The smallest n such that k divides n!.\n        \n    Example:\n    >>> smallest_factorial_multiple(7)\n    7\n    \"\"\"\n    from sympy import factorint\n    factors = factorint(k)\n    return max(factors.keys())", "def smallest_factorial_multiple(k):\n    \"\"\"\n    Find the smallest factorial n! which contains the integer k as a factor.\n    \n    Parameters:\n    - k (int): An integer to check as a factorial multiple.\n    \n    Returns:\n    int: The smallest n such that k is a factor of n!.\n    Examples:\n    >>> smallest_factorial_multiple(5)\n    5\n    >>> smallest_factorial_multiple(11)\n    11\n    \"\"\"\n    if k == 0:\n        return 0  # 0! = 1 does not count 0 as a divisor\n    n = 1\n    fact = 1\n    while True:\n        fact *= n\n        if fact % k == 0:\n            return n\n        n += 1"], ["def calculate_combinations(n, k):\n    \"\"\"\n    Calculate the number of combinations (also known as \"n choose k\") which is the way to select k items from n items without considering the order.\n    \n    Parameters:\n    - n (int): Total number of items.\n    - k (int): Number of items to choose.\n    \n    Returns:\n    int: The number of possible combinations.\n    Examples:\n    >>> calculate_combinations(5, 2)\n    10\n    >>> calculate_combinations(10, 3)\n    120\n    \"\"\"\n    return comb(n, k)"], ["def compute_factorial(n):\n    \"\"\"\n    Compute the factorial of a non-negative integer n.\n    \n    Parameters:\n        n (int): A non-negative integer whose factorial is to be computed.\n        \n    Returns:\n        int: The factorial of n.\n        \n    Examples:\n        >>> compute_factorial(5)\n        120\n        >>> compute_factorial(0)\n        1\n    \"\"\"\n    if n < 0:\n        raise ValueError(\"Factorial is not defined for negative numbers\")\n    return math.factorial(n)", "def factorial(n):\n    \"\"\"\n    Calculate the factorial of a non-negative integer n.\n    \n    Parameters:\n    n : int\n        A non-negative integer whose factorial is to be calculated.\n        \n    Returns:\n    int\n        The factorial of the input integer n.\n        \n    Example:\n    >>> factorial(5)\n    120\n    \"\"\"\n    if n < 0:\n        raise ValueError(\"Factorial is not defined for negative numbers.\")\n    elif n == 0:\n        return 1\n    else:\n        from math import factorial as math_factorial\n        return math_factorial(n)", "def compute_factorial(n):\n    \"\"\"\n    Compute the factorial of a given number n using caching to enhance repeated calculations.\n    \n    Parameters:\n    - n (int): A non-negative integer whose factorial is to be computed.\n    \n    Returns:\n    int: The factorial of the given number.\n    Examples:\n    >>> compute_factorial(5)\n    120\n    >>> compute_factorial(0)\n    1\n    \"\"\"\n    if n < 0:\n        raise ValueError(\"Factorial is not defined for negative numbers\")\n    return factorial(n)"], ["def factorial_division(numerator, denominator):\n    \"\"\"\n    Simplifies the division of two factorials using cancellation of common terms.\n    \n    Parameters:\n    numerator : int\n        The numerator factorial.\n    denominator : int\n        The denominator factorial, should be less than or equal to numerator.\n        \n    Returns:\n    int\n        The simplified result of `numerator! / denominator!`.\n        \n    Example:\n    >>> factorial_division(5, 3)\n    20\n    \"\"\"\n    if denominator > numerator:\n        raise ValueError(\"Denominator must be less than or equal to numerator.\")\n    product = 1\n    for i in range(denominator + 1, numerator + 1):\n        product *= i\n    return product"], ["def cancel_factorials(n, k):\n    \"\"\"\n    Simplify the expression n! / k! when n >= k by calculating the product from (k+1) to n.\n    \n    Parameters:\n    - n (int): Numerator factorial.\n    - k (int): Denominator factorial.\n    \n    Returns:\n    int: The result of the simplification of n! / k!.\n    Examples:\n    >>> cancel_factorials(5, 3)\n    20\n    \"\"\"\n    if n < k:\n        raise ValueError(\"n should be greater than or equal to k for cancellation.\")\n    result = 1\n    for i in range(k+1, n+1):\n        result *= i\n    return result"], ["def factorial_divisibility(n, k):\n    \"\"\"\n    Determine the largest power of k that divides n! (n factorial) without a remainder.\n    \n    Parameters:\n        n (int): A non-negative integer representing the factorial to be analyzed.\n        k (int): A positive integer to check for divisibility into n!.\n    \n    Returns:\n        int: The largest exponent such that k^exponent divides n! without remainder.\n        \n    Examples:\n        >>> factorial_divisibility(5, 2)\n        3\n        >>> factorial_divisibility(10, 5)\n        2\n    \"\"\"\n    count = 0\n    i = k\n    while i <= n:\n        count += n // i\n        i *= k\n    return count"], ["def count_trailing_zeros_in_factorial(n):\n    \"\"\"\n    Count the number of trailing zeros in n!.\n    \n    Parameters:\n        n (int): The factorial (n!) of this non-negative integer will be computed to find trailing zeros.\n    \n    Returns:\n        int: Number of trailing zeros in the factorial of n.\n    \n    Examples:\n        >>> count_trailing_zeros_in_factorial(5)\n        1\n        >>> count_trailing_zeros_in_factorial(100)\n        24\n    \"\"\"\n    count = 0\n    while n >= 5:\n        n //= 5\n        count += n\n    return count", "def factorial_trailing_zeros(n):\n    \"\"\"\n    Count trailing zeros in n factorial.\n    \n    Parameters:\n    n : int\n        The non-negative integer to find the factorial trailing zeros of.\n        \n    Returns:\n    int\n        Number of trailing zeros in n!.\n        \n    Example:\n    >>> factorial_tralterial_zeros(5)\n    1\n    \"\"\"\n    count = 0\n    if n < 0:\n        raise ValueError(\"Negative numbers do not have factorial trailing zeros.\")\n    i = 5\n    while n // i > 0:\n        count += n // i\n        i *= 5\n    return count"], ["def simplify_factorial_expression(expr):\n    \"\"\"\n    Simplifies an expression involving factorials.\n    \n    Parameters:\n        expr (str): A string representation of a mathematical expression involving factorials.\n        \n    Returns:\n        Expr: A simplified symbolic expression.\n        \n    Examples:\n        >>> simplify_factorial_expression('(5! * 4!) / (3! * 6!)')\n        1/18\n    \"\"\"\n    x = symbols('x')\n    simplified_expr = simplify(expr.replace('!', 'factorial'))\n    return simplified_expr"], ["def factorial_binomial_coefficient(n, k):\n    \"\"\"\n    Calculate the binomial coefficient, C(n, k) = n! / (k! (n-k)!), representing combinations of n objects taken k at a time.\n    \n    Parameters:\n        n (int): Total number of objects.\n        k (int): Number of objects to choose.\n    \n    Returns:\n        int: The binomial coefficient of n and k.\n    \n    Examples:\n        >>> factorial_binomial_coefficient(5, 2)\n        10\n        >>> factorial_binomial_coefficient(10, 3)\n        120\n    \"\"\"\n    if k < 0 or k > n:\n        return 0\n    if k == 0 or k == n:\n        return 1\n    k = min(k, n - k)  # Take advantage of symmetry\n    c = 1\n    for i in range(k):\n        c = c * (n - i) // (i + 1)\n    return c"]], "Digit Sums": [["def generate_palindromes(limit, must_contain=None):\n    \"\"\"\n    Generates all palindromic numbers up to a specified limit.\n    Can also apply a constraint where generated palindromes must contain certain digits.\n    Parameters:\n    - limit (int): The upper limit for palindrome generation (exclusive).\n    - must_contain (tuple of int, optional): Digits that must be present in the palindrome.\n    Returns:\n    - list of int: List of all palindromic numbers up to 'limit' inclusive of the conditions.\n    Examples:\n    >>> generate_palindromes(150, must_contain=(1, 2))\n    [121]\n    >>> generate_palindromes(200)\n    [1, 2, ..., 191]\n    \"\"\"\n    palindromes = [i for i in range(limit) if is_palindrome(i)]\n    if must_contain:\n        digit_set = set(map(str, must_contain))\n        palindromes = [p for p in palindromes if digit_set & set(str(p))]\n    return palindromes", "def generate_palindromes(limit, base=10):\n    \"\"\"\n    Generate palindromic numbers up to a specified limit in a given base.\n    Parameters:\n    - limit (int): The upper boundary for generating palindromes (exclusive).\n    - base (int): The numerical base in which palindromes are generated.\n    Returns:\n    - list: A list of palindromic numbers up to 'limit'.\n    Examples:\n    >>> generate_palindromes(150)\n    [1, 2, 3, ..., 121, 131, 141]\n    >>> generate_palindromes(10, 2)\n    [1, 3, 5, 7]\n    \"\"\"\n    palindromes = []\n    for num in range(limit):\n        if is_palindrome(num, base):\n            palindromes.append(num)\n    return palindromes"], ["def calculate_digit_sum(n):\n    \"\"\"\n    Calculates the sum of digits of a given number.\n    Parameters:\n    - n (int): The number whose digits sum is to be calculated.\n    Returns:\n    - int: The sum of the digits of n.\n    Examples:\n    >>> calculate_digit_sum(123)\n    6\n    >>> calculate_digit_sum(10605)\n    12\n    \"\"\"\n    return sum(int(digit) for digit in str(abs(n)))", "def digit_sum(n):\n    \"\"\"\n    Calculate the sum of the digits of an integer.\n    Parameters:\n    -----------\n    n : int\n        The number whose digits will be summed.\n    Returns:\n    --------\n    int\n        Sum of the digits of `n`.\n    Examples:\n    ---------\n    >>> digit_sum(1234)\n    10\n    >>> digit_sum(-5678)\n    26\n    \"\"\"\n    return sum(int(d) for d in str(abs(n)))", "def digit_sum(number):\n    \"\"\"\n    Calculate the sum of the digits of an integer.\n    Parameters:\n    - number (int): The integer whose digit sum is computed.\n    Returns:\n    - int: The sum of the digits of the given integer.\n    Examples:\n    >>> digit_sum(1234)\n    10\n    >>> digit_sum(999)\n    27\n    \"\"\"\n    return sum(int(digit) for digit in str(number))", "def digit_sum(number):\n    \"\"\"Calculate the sum of the digits of a number.\n    \n    Parameters:\n    number (int): The number whose digits will be summed.\n    Returns:\n    int: The sum of the digits of the number.\n    Examples:\n    >>> digit_sum(123)\n    6\n    >>> digit_sum(104)\n    5\n    \"\"\"\n    return sum(int(digit) for digit in str(abs(number)))"], ["def count_digits(n):\n    \"\"\"\n    Count the number of digits in a number `n`.\n    \n    Parameters:\n        n (int): The number to count digits for.\n    \n    Returns:\n        int: The count of digits in `n`.\n    Examples:\n        >>> count_digits(12345)\n        5\n        >>> count_digits(-12345)\n        5\n    \"\"\"\n    if n == 0:\n        return 1\n    return int(math.log10(abs(n))) + 1", "def digit_count(n):\n    \"\"\"\n    Count the number of digits in an integer.\n    Parameters:\n    -----------\n    n : int\n        The number to count the digits of.\n    Returns:\n    --------\n    int\n        Number of digits in `n`.\n    Examples:\n    ---------\n    >>> digit_count(12345)\n    5\n    >>> digit_count(-123)\n    3\n    \"\"\"\n    return len(str(abs(n)))"], ["def max_number_from_digits(number, target_sum=None):\n    \"\"\"Create the largest possible number from the digits of a given number, optionally with a target digit sum.\n    Parameters:\n    number (int): The original number to manipulate digits from.\n    target_sum (int, optional): The desired sum of the digits of the resulting number.\n    Returns:\n    int: The largest possible integer formed under the specified conditions.\n    Examples:\n    >>> max_number_from_digits(3412)\n    4321\n    >>> max_number_from_digits(3412, 10)\n    431\n    \"\"\"\n    digits = sorted(str(abs(number)), reverse=True)\n    if target_since_birth is None:\n        return int(''.join(digits))\n    \n    current_sum = 0\n    result_digits = []\n    for digit in digits:\n        dig = int(digit)\n        if current_sum + dig <= target_sum:\n            result_digits.append(digit)\n            current_sum += dig\n        if current_sum == target_sum:\n            break\n    return int(''.join(result_digits))"], ["def is_digit_sum_divisible(number, divisor):\n    \"\"\"Check if the sum of the digits of a number is divisible by a given integer.\n    \n    Parameters:\n    number (int): The number to compute the digit sum of.\n    divisor (int): The divisor to check divisibility against.\n    Returns:\n    bool: Returns True if the digit sum is divisible by the divisor, False otherwise.\n    Examples:\n    >>> is_digit_sum_divisible(123, 3)\n    True\n    >>> is_digit_sum_divisible(104, 3)\n    False\n    \"\"\"\n    return digit_sum(number) % divisor == 0"], ["def count_digit_occurrences_in_range(start, end, digit):\n    \"\"\"Counts how many times a specific digit appears within a range of numbers.\n    Parameters:\n    start (int): Start of the range (inclusive).\n    end (int): End of the range (inclusive).\n    digit (str): The digit to count occurrences of.\n    Returns:\n    int: Total count of the digit's occurrences within the specified range.\n    Examples:\n    >>> count_digit_occurrences_in_range(10, 30, '1')\n    12\n    >>> count_digit_occurrences_in_range(1, 100, '0')\n    9\n    \"\"\"\n    count = 0\n    for num in range(start, end + 1):\n        count += str(num).count(digit)\n    return count"], ["def reverse_digits(n):\n    \"\"\"\n    Reverse the digits of the number `n` and return the resulting integer.\n    \n    Parameters:\n        n (int): The number to be reversed.\n    \n    Returns:\n        int: The integer formed by the reverse order of the digits of `n`.\n    Examples:\n        >>> reverse_digits(123)\n        321\n        >>> reverse_digits(100)\n        1\n    \"\"\"\n    return int(str(n)[::-1]) if n >= 0 else -int(str(-n)[::-1])", "def reverse_digits(n):\n    \"\"\"\n    Reverse the digits of an integer.\n    Parameters:\n    -----------\n    n : int\n        The number to be reversed.\n    Returns:\n    --------\n    int\n        The integer obtained by reversing the digits of `n`.\n    Examples:\n    ---------\n    >>> reverse_digits(123)\n    321\n    >>> reverse_digits(-456)\n    -654\n    \"\"\"\n    sign = -1 if n < 0 else 1\n    reversed_num = int(str(abs(n))[::-1])\n    return sign * reversed_num"], ["def is_palindromic_number(n):\n    \"\"\"\n    Check if the given integer is a palindromic number.\n    \n    A palindromic number is a number that remains the same when its digits are reversed.\n    Parameters:\n    - n (int): The number to check.\n    Returns:\n    - bool: True if n is a palindromic number, otherwise False.\n    Examples:\n    >>> is_palindromic_number(121)\n    True\n    >>> is_palindromic_number(123)\n    False\n    \"\"\"\n    str_n = str(n)\n    return str_n == str_n[::-1]"], ["def sum_of_digit_powers(n, power):\n    \"\"\"\n    Calculate the sum of the digits of a number raised to a specific power.\n    Parameters:\n    -----------\n    n : int\n        The number whose digits will be raised to the power and summed.\n    power : int\n        The power to raise each digit.\n    Returns:\n    --------\n    int\n        Sum of the digits of `n` raised to the `power`.\n    Examples:\n    ---------\n    >>> sum_of_digit_powers(123, 2)\n    14  # 1^2 + 2^2 + 3^2\n    >>> sum_of_digit_powers(321, 3)\n    36  # 3^3 + 2^3 + 1^3\n    \"\"\"\n    return sum(int(d)**power for d in str(abs(n)))"], ["def valid_digit_combinations(range_digits, check_evenness=True):\n    \"\"\"\n    Count combinations of digits from the range where first and last digits follow specific rules.\n    Parameters:\n    -----------\n    range_digits : list of int\n        The digits available for forming combinations.\n    check_evenness : bool\n        If true, checks that the first and last digits must both be even or both be odd.\n    Returns:\n    --------\n    int\n        Count of valid combinations of digits given the conditions.\n    Examples:\n    ---------\n    >>> valid_digit_combinations([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])\n    30  # 10 possible even-even or odd-odd pairs with 10 choices in between\n    \"\"\"\n    from itertools import product\n    if check_evenness:\n        pairs = [(d1, d2) for d1 in range_digits for d2 in range_digits if (d1 % 2 == d2 % 2)]\n    else:\n        pairs = list(product(range_digits, repeat=2))\n    return len(pairs) * len(range_digits)"], ["def generate_palindromic_numbers(min_digit, max_digit, lower_bound=None, upper_bound=None):\n    \"\"\"\n    Generate a list of palindromic numbers within a specified range and digit count.\n    Parameters:\n    - min_digit (int): Minimum number of digits in the palindromic numbers.\n    - max_digit (int): Maximum number of digits in the palindromic numbers.\n    - lower_bound (int, optional): Minimum value of the palindromic number. Defaults to None.\n    - upper_bound (int, optional): Maximum value of the palindromic number. Defaults to None.\n    Returns:\n    - list: A list of all palindromic numbers within the specified constraints.\n    Examples:\n    >>> generate_palindromic_numbers(3, 3)\n    [101, 111, 121, ..., 999]\n    >>> generate_palindromic_numbers(1, 2, 50, 150)\n    [55, 66, 77, 88, 99, 101, 111, 121, 131, 141]\n    \"\"\"\n    palindromics = []\n    start = 10**(min_digit-1) if min_digit > 1 else 1\n    end = 10**max_digit - 1\n    \n    for num in range(start, end + 1):\n        if is_palindromic_number(num):\n            if (lower_bound is None or num >= lower_bound) and (upper_bound is None or num <= upper_bound):\n                palindromics.append(num)\n    \n    return palindromics"], ["def is_palindrome(number, base=10):\n    \"\"\"\n    Check if a given number is a palindrome in the specified base.\n    Parameters:\n    - number (int): The number to check.\n    - base (int): The numerical base in which the number's palindromic nature is to be assessed.\n    Returns:\n    - bool: True if the number is a palindrome, False otherwise.\n    Examples:\n    >>> is_palindrome(121)\n    True\n    >>> is_palindrome(123, 10)\n    False\n    >>> is_palindrome(0b101, 2)\n    True\n    \"\"\"\n    original = number\n    reversed_num = 0\n    while number > 0:\n        reversed_num = reversed_num * base + number % base\n        number //= base\n    return original == reversed_num"], ["def digit_counter(number):\n    \"\"\"Counts the occurrence of each digit in a number.\n    Parameters:\n    number (int): The number to count digits from.\n    Returns:\n    dict: A dictionary with digits as keys and their counts as values.\n    Examples:\n    >>> digit_counter(112233)\n    {1: 2, 2: 2, 3: 2}\n    >>> digit_counter(456789)\n    {4: 1, 5: 1, 6: 1, 7: 1, 8: 1, 9: 1}\n    \"\"\"\n    counts = {}\n    for digit in str(abs(number)):\n        dig = int(digit)\n        if dig in counts:\n            counts[dig] += 1\n        else:\n            counts[dig] = 1\n    return counts"], ["def max_digit_sum_ordering(digits, desired_sum):\n    \"\"\"\n    Find the largest number formed by arranging digits to achieve a specified sum of digits.\n    Parameters:\n    -----------\n    digits : list of int\n        List of individual digits available.\n    desired_sum : int\n        The desired sum of the digits of the resulting number.\n    Returns:\n    --------\n    int or None\n        The largest number possible with the desired digit sum, or None if no such arrangement exists.\n    Examples:\n    ---------\n    >>> max_digit_sum_ordering([1, 2, 3, 9], 14)\n    9321\n    \"\"\"\n    from itertools import permutations\n    valid_numbers = []\n    for perm in permutations(digits):\n        if sum(perm) == desired_sum:\n            valid_numbers.append(int(''.join(map(str, perm))))\n    return max(valid_numbers, default=None)"], ["def is_palindrome(n):\n    \"\"\"\n    Checks whether a given number is a palindrome.\n    Parameters:\n    - n (int): The number to check.\n    Returns:\n    - bool: True if n is a palindrome; otherwise False.\n    Examples:\n    >>> is_palindrome(121)\n    True\n    >>> is_palindrome(123)\n    False\n    \"\"\"\n    s = str(n)\n    return s == s[::-1]"], ["def digit_sum(n, filter_divisor=None):\n    \"\"\"\n    Calculate the sum of the digits of an integer `n`. Optionally, only consider the sum if it is divisible by `filter_divisor`.\n    \n    Parameters:\n        n (int): The number whose digit sum is calculated.\n        filter_divisor (int, optional): If specified, the function will check if the digit sum is divisible by this number and return the sum if true, otherwise 0.\n    Returns:\n        int: The sum of the digits of `n` if `filter_divisor` is None or if the sum is divisible by `filter_divisor`, otherwise 0.\n    Examples:\n        >>> digit_sum(123)\n        6\n        >>> digit_sum(123, filter_divisor=3)\n        6\n        >>> digit_sum(124, filter_divisor=3)\n        0\n    \"\"\"\n    s = sum(int(digit) for digit in str(abs(n)))\n    if filter_divisor is not None and s % filter_divisor != 0:\n        return 0\n    return s"]], "Modulo Arithmetic": [["def modular_add(a, b, mod):\n    \"\"\"\n    Perform modular addition between two numbers.\n    Parameters:\n        a (int): The first integer.\n        b (int): The second integer.\n        mod (int): The modulus.\n    Returns:\n        int: The result of (a + b) % mod\n    Examples:\n        >>> modular_add(5, 3, 7)\n        1\n    \"\"\"\n    return (a + b) % mod", "def modular_sub(a, b, mod):\n    \"\"\"\n    Perform modular subtraction between two numbers.\n    Parameters:\n        a (int): The first integer.\n        b (int): The second integer.\n        mod (int): The modulus.\n    Returns:\n        int: The result of (a - b) % mod\n    Examples:\n        >>> modular_sub(5, 3, 7)\n        2\n    \"\"\"\n    return (a - b) % mod", "def modular_mult(a, b, mod):\n    \"\"\"\n    Perform modular multiplication between two numbers.\n    Parameters:\n        a (int): The first integer.\n        b (int): The second integer.\n        mod (int): The modulus.\n    Returns:\n        int: The result of (a * b) % mod\n    Examples:\n        >>> modular_mult(5, 3, 7)\n        1\n    \"\"\"\n    return (a * b) % mod", "def mod_add(a, b, modulus):\n    \"\"\"\n    Performs modular addition of two numbers under a specified modulus.\n    \n    Parameters:\n        a (int): The first operand.\n        b (int): The second operand.\n        modulus (int): The modulus to use.\n        \n    Returns:\n        int: The sum of a and b modulo modulus.\n        \n    Examples:\n        >>> mod_add(7, 5, 10)\n        2\n        >>> mod.add(3, -4, 10)\n        9\n    \"\"\"\n    return (a + b) % modulus", "def mod_mul(a, b, modulus):\n    \"\"\"\n    Performs modular multiplication of two numbers.\n    \n    Parameters:\n        a (int): The first number.\n        b (int): The second number.\n        modulus (int): The modulus to operate under.\n        \n    Returns:\n        int: The product of a and b modulo modulus.\n    \n    Examples:\n        >>> mod_mul(7, 5, 12)\n        11\n        >>> mod_mul(3, 4, 5)\n        2\n    \"\"\"\n    return (a * b) % modulus"], ["def modular_inverse(a, m):\n    \"\"\"\n    Calculate the modular inverse of a mod m.\n    Parameters:\n    - a: The number to find the inverse of.\n    - m: The modulus.\n    Returns:\n    - The modular inverse of a mod m if it exists, otherwise None.\n    \n    Examples:\n    >>> modular_inverse(3, 11)\n    4\n    \"\"\"\n    from sympy import mod_inverse\n    \n    try:\n        return mod_inverse(a, m)\n    except ValueError:  # If modular inverse does not exist\n        return None", "def modular_inverse(a, m):\n    \"\"\"\n    Compute the modular inverse of a mod m.\n    \n    Args:\n        a : int\n            The number whose modular inverse is to be calculated.\n        m : int\n            The modular value.\n   \n    Returns:\n        int\n            Returns the modular inverse of a mod m.\n    \"\"\"\n    try:\n        return mod_inverse(a, m)\n    except ValueError:\n        return \"No Inverse Exists\""], ["def modular_pow(base, exp, mod):\n    \"\"\"\n    Compute modular exponentiation.\n    Parameters:\n        base (int): The base integer.\n        exp (int): The exponent integer.\n        mod (int): The modulus.\n    Returns:\n        int: The result of (base ** exp) % mod\n    Examples:\n        >>> modular_pow(2, 5, 13)\n        6\n    \"\"\"\n    return pow(base, exp, mod)", "def modular_exponentiation(base, exponent, mod):\n    \"\"\"\n    This function computes the modular exponentiation i.e., it calculates (base^exponent) modulo mod.\n    Parameters:\n        base (int): base of the term\n        exponent (int): exponent of the term\n        mod (int): modulo to be applied in the calculation\n    Returns:\n        int: result of the modular exponentiation operation\n    Example:\n        >>> modular_exponentiation(2, 5, 101)\n        32 # because (2^5) is 32, and 32 modulo 101 is 32\n    \"\"\"\n    return powmod(base, exponent, mod)"], ["def solve_linear_congruence(a, b, m):\n    \"\"\"\n    Solve the linear congruence of the form ax ≡ b (mod m).\n    Parameters:\n    - a: Coefficient of x in the congruence.\n    - b: The right-hand side of the congruence.\n    - m: The modulus.\n    Returns:\n    - The smallest non-negative solution x of the congruence. If no solution, returns None.\n    \n    Examples:\n    >>> solve_linear_congruence(7, 1, 26)\n    15\n    \"\"\"\n    from sympy.ntheory.modular import solve_congruence\n    \n    # Transforming into the format required by solve_congruence ((a, m), (b, n))\n    cong = ((b, m),)\n    solution = solve_congruence(*cong)\n    \n    if solution is None:\n        return None\n    else:\n        return solution[0]", "def solve_linear_congruence(a, b, m):\n    \"\"\"\n    Solves a linear congruence equation of the form ax ≡ b (mod m)\n    Args:\n        a : int\n            Coefficient of x in the equation.\n        b : int\n            The result that a*x should be congruent to.\n        m : int\n            The modular value.\n    Returns:\n        int\n            Returns the least nonnegative integer solution to the equation.\n    \"\"\"\n    try:\n        mod_inv = mod_inverse(a, m)\n        return (mod_inv * b) % m\n    except ValueError:\n        return \"No Solution Exists\"", "def solve_linear_congruence(a, b, m):\n    \"\"\"\n    This function solves the linear congruence of the form ax ≡ b (mod m) for x.\n    Parameters:\n        a (int): the multiplier of x in the congruence\n        b (int): right side of the congruence\n        m (int): the modulus\n    Returns:\n        int: solution to the linear congruence\n    Example:\n        >>> solve_linear_congruence(3, 4, 7)\n        5 # Because 3*5 ≡ 4 (mod 7)\n    \"\"\"\n    a_inverse = calculate_mod_inverse(a, m)\n    if a_inverse is not None:\n        return (a_inverse * b) % m\n    return None"], ["def simplifying_arithmetic_modulo(a, operator, b, modulo):\n    \"\"\"\n    This function takes two integers a and b, an operator (either '+', '-', '*', '/') and a modulus. \n    It applies the operator to the numbers and reduces the result modulo the given modulus.\n    Parameters:\n        a (int): The first operand\n        operator (str): The operator to use. Possible values: '+', '-', '*', '/'\n        b (int): The second operand\n        modulo (int): The modulus to use for the calculation\n    Returns:\n        int: The simplified value of the operation\n    Example:\n        >>> simplifying_arithmetic_modulo(10, '+', 15, 7)\n        4 # because (10 + 15) = 25, and 25 modulo 7 equals 4\n    \"\"\"\n    if operator == '+':\n        return (a + b) % modulo\n    elif operator == '-':\n        return (a - b) % modulo\n    elif operator == '*':\n        return (a * b) % modulo\n    elif operator == '/':\n        b_inverse = calculate_mod_inverse(b, modulo)\n        if b_inverse is not None:\n            return (a * b_inverse) % modulo\n        return None"], ["def is_equivalent_modulo(a, b, mod):\n    \"\"\"\n    Check if two numbers are equivalent under a specified modulo.\n    Parameters:\n    - a (int): The first number.\n    - b (int): The second number.\n    - mod (int): The modulus to test equivalence under.\n    Returns:\n    bool: True if `a` is equivalent to `b` under modulo `mod`, otherwise False.\n    Example:\n    >>> is_equivalent_modulo(14, 3, 11)\n    True\n    \"\"\"\n    return (a % mod) == (b % mod)"], ["def solve_system_of_congruences(*congruences):\n    \"\"\"\n    This function solves a system of linear congruences. \n    The congruences are provided as pairs (rhs, modulo).\n    Parameters:\n        *congruences : arbitrary number of tuples (rhs, modulo) representing the congruences\n    Returns:\n        tuple: solution to the system as a pair (value, modulo)\n    Example:\n        >>> solve_system_of_congruences((1, 3), (2, 4), (3, 5))\n        (58, 60)\n    Note: Function uses the sympy's solve_congruence function, which in turn uses the Chinese \n    remainder theorem under the hood for providing solution.\n    \"\"\"\n    return solve_congruence(*congruences)"], ["def sum_modulo(numbers, mod):\n    \"\"\"\n    Calculate the sum of a list of numbers under a specified modulo.\n    Parameters:\n    - numbers (list of int): List of integers to be summed.\n    - mod (int): The modulus for the sum operation.\n    Returns:\n    int: The result of the sum modulo `mod`.\n    Example:\n    >>> sum_modulo([1, 2, 3, 4], 3)\n    1\n    \"\"\"\n    return sum(numbers) % mod"], ["def modular_inverse(a, mod):\n    \"\"\"\n    Find the modular multiplicative inverse of a under modulo mod.\n    Parameters:\n        a (int): The integer to find the inverse.\n        mod (int): The modulus.\n    Returns:\n        int or None: The modular inverse of a modulo mod if it exists, otherwise None.\n    Examples:\n        >>> modular_inverse(3, 11)\n        4\n    \"\"\"\n    try:\n        return pow(a, -1, mod)\n    except ValueError:\n        return None", "def mult_inverse_modulo(a, mod):\n    \"\"\"\n    Find the multiplicative inverse of `a` under modulo `mod`, if it exists.\n    Parameters:\n    - a (int): The integer to find the inverse of.\n    - mod (int): The modulus.\n    Returns:\n    int or None: The multiplicative inverse of `a` modulo `mod` if it exists, otherwise None.\n    Example:\n    >>> mult_inverse_modulo(3, 11)\n    4\n    \"\"\"\n    try:\n        from sympy import mod_inverse\n        return mod_inverse(a, mod)\n    except ValueError:\n        return None"], ["def calculate_mod_inverse(a, m):\n    \"\"\"\n    This function calculates the modular multiplicative inverse of 'a' under modulo 'm'. \n    i.e., it finds an integer 'b' such that (ab)mod m == 1.\n    \n    Parameters:\n        a (int): integer to compute the modular inverse for \n        m (int): modulo to consider \n        \n    Returns:\n        int: modular inverse of `a` under modulo `m`\n        \n    Example:\n        >>> calculate_mod_inverse(3, 7)\n        5 #because (3*5)%7 == 1\n    \"\"\"\n    try:\n        return mod_inverse(a, m)\n    except ValueError as ve:\n        print(f\"No modular multiplicative inverse for {a} under modulo {m}\")\n        return None"], ["def mod_reduce(number, modulus):\n    \"\"\"\n    Reduces a number modulo a given modulus.\n    \n    Parameters:\n        number (int): The number to be reduced.\n        modulus (int): The modulus to be used for reduction.\n        \n    Returns:\n        int: The equivalent number in the range [0, modulus-1].\n        \n    Examples:\n        >>> mod_reduce(10, 3)\n        1\n        >>> mod_reduce(-4, 3)\n        2\n    \"\"\"\n    return number % modulus"], ["def least_non_negative_residue(a, mod):\n    \"\"\"\n    Compute the least non-negative residue of a under modulo mod.\n    Parameters:\n        a (int): The integer.\n        mod (int): The modulus.\n    Returns:\n        int: The least non-negative residue of a modulo mod.\n    Examples:\n        >>> least_non_negative_residue(-3, 5)\n        2\n    \"\"\"\n    return a % mod"], ["def chinese_remainder_theorem(*args):\n    \"\"\"\n    Solve simultaneous linear congruences (systems of congruences) using the Chinese Remainder Theorem.\n    Args:\n        args : tuples\n            A sequence of (remainer, modulus) tuples.\n    Returns:\n        (int, int)\n            Returns a tuple (solution, lcm) where lcm is the least common multiple of all the moduli, \n            if a solution exists, else returns None.\n    \"\"\"\n    try:\n        result = solve_congruence(*args)\n        return result\n    except ValueError:\n        return \"No Solution Exists\""], ["def reduce_modulo(a, m):\n    \"\"\"\n    Reduce a number 'a' modulo 'm'.\n    Args:\n        a : int\n            The number which is to be reduced.\n        m : int\n            The modular value.\n    Returns:\n        int\n            Returns 'a' modulo 'm'.\n    \"\"\"\n    return a % m"], ["def modular_div(a, b, mod):\n    \"\"\"\n    Perform modular division, computing a * (b^(-1) mod mod).\n    Parameters:\n        a (int): The numerator.\n        b (int): The denominator, must be coprime with mod.\n        mod (int): The modulus.\n    Returns:\n        int or None: The result of (a * modular_inverse(b, mod)) % mod if inverse exists, otherwise None.\n    Examples:\n        >>> modular_div(8, 3, 7)\n        6\n    \"\"\"\n    b_inv = modular_inverse(b, mod)\n    if b_inv is None:\n        return None \n    return modular_mult(a, b_inv, mod)"], ["def modular_exponentiation(base, exponent, modulus):\n    \"\"\"\n    Calculate base^exponent mod modulus efficiently.\n    Parameters:\n    - base: The base of the exponentiation.\n    - exponent: The exponent.\n    - modulus: The modulus.\n    Returns:\n    - The result of (base^exponent) mod modulus.\n    \n    Examples:\n    >>> modular_exponentiation(2, 10, 1000)\n    24\n    \"\"\"\n    if gcd(base, modulus) == 1:  # If base and modulus are coprime, Fermat's little theorem can be applied.\n        exponent = exponent % (modulus - 1)\n    result = pow(base, exponent, modulus)\n    return result"], ["def extended_gcd(a, b):\n    \"\"\"\n    Extended Euclidean Algorithm to find x, y such that ax + by = gcd(a, b)\n    Parameters:\n        a (int): First number\n        b (int): Second number\n    Returns:\n        tuple: (gcd, x, y), where gcd is the greatest common divisor and x, y are the coefficients of a and b respectively in the equation ax + by = gcd\n    Examples:\n        >>> extended_gcd(18, 12)\n        (6, 1, -1)\n    \"\"\"\n    if a == 0:\n        return (b, 0, 1)\n    else:\n        gcd, x, y = extended_gcd(b % a, a)\n        return (gcd, y - (b // a) * x, x)"], ["def modulo_operation(a, b, operation, m):\n    \"\"\"\n    Perform modular arithmetic operations on two numbers.\n    Parameters:\n    - a: The first operand.\n    - b: The second operand.\n    - operation: The operation to perform ('+', '-', '*', '/').\n    - m: The modulus.\n    Returns:\n    - The result of the operation a operation b mod m.\n    \n    Examples:\n    >>> modulo_operation(8, 5, '+', 10)\n    3\n    >>> modulo_operation(8, 3, '*', 7)\n    2\n    \"\"\"\n    if operation == '+':\n        return (a + b) % m\n    elif operation == '-':\n        return (a - b) % m\n    elif operation == '*':\n        return (a * b) % m\n    elif operation == '/':\n        inv_b = modular_inverse(b, m)\n        if inv_b is not None:\n            return (a * inv_b) % m\n        else:\n            raise ValueError('Modular division is not possible as inverse does not exist.')\n    else:"], ["def calc_modulo(number, mod):\n    \"\"\"\n    Calculate the remainder of a division by `mod`.\n    Parameters:\n    - number (int): The number to be divided.\n    - mod (int): The divisor (modulus) to divide by.\n    Returns:\n    int: The remainder when `number` is divided by `mod`.\n    Example:\n    >>> calc_modulo(10, 3)\n    1\n    \"\"\"\n    return number % mod"], ["def is_congruent(a, b, m):\n    \"\"\"\n    Determine if 'a' and 'b' are congruent modulo 'm'.\n    Args:\n        a : int\n            First integer.\n        b : int\n            Second integer.\n        m : int\n            The modular value.\n    Returns:\n        bool\n            Returns True if 'a' and 'b' are congruent modulo 'm', else False.\n    \"\"\"\n    return a % m == b % m"]], "Base Conversion": [["def convert_number_from_base_to_base(num, source_base, target_base):\n    \"\"\"\n    Converts a number from a source base to a target base.\n    Parameters:\n        num (str): The number in the form of a string in the source base.\n        source_base (int): The numerical base of the input number.\n        target_base (int): The numerical base to which the number should be converted.\n    Returns:\n        str: The converted number in the target base as a string.\n    \n    Examples:\n        >>> convert_number_from_base_to_base('101', 2, 10)\n        '5'\n        >>> convert_number_from_base_to_base('7A', 16, 2)\n        '1111010'\n    \"\"\"\n    if source_base < 2 or target_base < 2:\n        raise ValueError(\"Base values should be 2 or higher.\")\n    \n    # Convert from source base to base 10\n    decimal_num = int(num, source_base)\n    \n    # Convert from base 10 to target base\n    if decimal_num == 0:\n        return '0'\n    result = []\n    while decimal_num > 0:\n        remainder = decimal_num % target_base\n        if 36 > remainder > 9:\n            remainder = chr(remainder + 55)\n        else:\n            remainder = str(remainder)\n        result.insert(0, remainder)\n        decimal_num = decimal_num // target_base\n        \n    return ''.join(result)", "def convert_number_to_base(number, base):\n    \"\"\"\n    Converts an integer from base 10 to a specified base.\n    Parameters:\n    ----------\n    number : int\n        The number in base 10 that needs to be converted.\n    base : int\n        The base to which the number is to be converted.\n    Returns:\n    -------\n    str\n        The number represented in the specified base.\n    Examples:\n    --------\n    >>> convert_number_to_base(255, 2)\n    '11111111'\n    >>> convert_number_to_base(255, 16)\n    'FF'\n    \"\"\"\n    if base < 2:\n        raise ValueError('Base must be at least 2')\n    \n    if number == 0:\n        return '0'\n    \n    digits = []\n    while number > 0:\n        remainder = number % base\n        if remainder > 9:\n            remainder = chr(65 + remainder - 10)  # Convert 10, 11, ... to 'A', 'B', ...\n        else:\n            remainder = str(remainder)\n        digits.append(remainder)\n        \n        number //= base\n        \n    return ''.join(reversed(digits))", "def convert_base_to_number(number, base):\n    \"\"\"\n    Converts a number from a given base back to base 10.\n    Parameters:\n    ----------\n    number : str\n        The number represented in the given base.\n    base : int\n        The base of the given number.\n    Returns:\n    -------\n    int\n        The integer value of the number in base 10.\n    Examples:\n    --------\n    >>> convert_base_to.b2d('11111111', 2)\n    255\n    >>> convert_base_to.b2d('FF', 16)\n    255\n    \"\"\"\n    if base < 2:\n        raise ValueError('Base must be at least 2')\n    \n    number = str(number).upper()  # Ensure the input is in uppercase\n    value = 0\n    for character in number:\n        if '0' <= character <= '9':\n            num = ord(character) - ord('0')\n        else:\n            num = ord(character) - ord('A') + 10\n        \n        value = value * base + num\n    return value", "def convert_base(number, from_base, to_base):\n    \"\"\"\n    Convert a number from one base to another base.\n    \n    Parameters:\n    - number (str): The number to convert as a string. For non-decimal bases, this may include alphabetic characters.\n    - from_base (int): The base of the provided number.\n    - to_base (int): The target base to which the number is to be converted.\n    \n    Returns:\n    - str: The number represented in the target base.\n    \n    Examples:\n    >>> convert_base('101', 2, 10)\n    '5'\n    >>> convert_base('77', 8, 2)\n    '111111'\n    >>> convert_base('FF', 16, 10)\n    '255'\n    \"\"\"\n    if from_base == to_base:\n        return number\n    \n    # Convert from any base to decimal\n    decimal = int(number, base=fromah_base)\n    \n    # Convert from decimal to any other base\n    if to_base == 10:\n        return str(decimal)\n    \n    digits = []\n    while decimal > 0:\n        digits.append(int(decimal % to_base))\n        decimal //= to_base\n    digits = digits[::-1]\n    \n    # Convert numerical digits to a base-specific string\n    return ''.join(chr(48 + d) if d < 10 else chr(65 + d - 10) for d in digits)", "def convert_base(number, from_base, to_base):\n    \"\"\"\n    Convert a number from one base to another base.\n    Parameters:\n    number : str\n        The number represented in the 'from_base' that needs to be converted.\n    from_base : int\n        The base of the given number.\n    to_base : int\n        The base to which the number needs to be converted.\n    Returns:\n    str:\n        The number represented in 'to_base'.\n    Examples:\n    >>> convert_base('101', 2, 10)\n    '5'\n    >>> convert_base('ff', 16, 2)\n    '11111111'\n    \"\"\"\n    # First, convert the number from the original base to decimal (intermediate base-10)\n    decimal_number = int(number, from_base)\n    # Now convert from decimal to the target base\n    if to_base == 10:\n        return str(decimal_number)\n    \n    # For non-decimal target bases\n    result = \"\"\n    while decimal_number > 0:\n        remainder = decimal_number % to_base\n        if 36 > remainder > 9:\n            result += chr(remainder + 55)  # Convert 10-35 to A-Z\n        else:\n            result += str(remainder)\n        decimal_number //= to_base\n    \n    return result[::-1]  # reverse the string to get the correct result", "def convert_number_to_base(n, base):\n    \"\"\"\n    Converts an integer from base 10 to a specified base.\n    \n    Parameters\n    ----------\n    n : int\n        The integer number in decimal (base 10)\n    base : int\n        The base to which the number `n` will be converted\n        \n    Returns\n    -------\n    str\n        The number in the specified `base` as a string\n    \n    Examples\n    --------\n    >>> convert_number_to_base(255, 16)\n    'FF'\n    >>> convert_number_to_base(2, 2)\n    '10'\n    \"\"\"\n    if n == 0:\n        return \"0\"\n    \n    digits = []\n    while n:\n        digits.append(int(n % base))\n        n //= base\n    \n    return ''.join(str(x) for x in digits[::-1])", "def convert_base_to_decimal(s, base):\n    \"\"\"\n    Converts a number from a specified base to decimal (base 10).\n    \n    Parameters\n    ----------\n    s : str\n        The number in `base` as a string\n    base : int\n        The base of the number `s`\n    \n    Returns\n    -------\n    int\n        The decimal representation of `s`\n    \n    Examples\n    --------\n    >>> convert_base_to_decimal('FF', 16)\n    255\n    >>> convert_base_toertaintydecimal('10', 2)\n    2\n    \"\"\"\n    return sum(int(char) * (base ** index) for index, char in enumerate(s[::-1]))", "def convert_base_to_decimal(number_str, base):\n    \"\"\"\n    Convert a number, represented as a string in a given base, to its decimal (base 10) equivalent.\n    \n    Parameters\n    ----------\n    number_str : str\n        The number represented as a string, which should correspond to the given base.\n    base : int\n        The base in which the number is currently represented. Should be between 2 and 36.\n    Returns\n    -------\n    int\n        Decimal representation of the number.\n    \n    Examples\n    --------\n    >>> convert_base_to_decimal(\"1010\", 2)\n    10\n    >>> convert_base_to_decimal(\"1A\", 16)\n    26\n    >>> convert_base_to_decimal(\"123\", 8)\n    83\n    \"\"\"\n    # Validate inputs\n    if base < 2 or base > 36:\n        raise ValueError(\"Base must be between 2 and 36.\")\n    if any(char not in \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\"[:base] for char in number_str.upper()):\n        raise ValueError(\"number_str contains characters outside base range.\")\n    # Convertion process: interpret the number_str in the specified base and convert to decimal\n    decimal_value = 0\n    for digit in number_str.upper():\n        if '0' <= digit <= '9':\n            value = ord(digit) - ord('0')\n        else:\n            value = ord(digit) - ord('A') + 10\n        decimal_value = decimal_value * base + value\n    return decimal_value", "def convert_base(number, source_base, target_base):\n    \"\"\"\n    Convert a number from a specific source base to a target base.\n    Parameters:\n    - number (str): The number in string format in the source base.\n    - source_base (int): The base of the input number.\n    - target_base (int): The base to which the number needs to be converted.\n    Returns:\n    - str: The number converted into the target base.\n    Examples:\n    >>> convert_base('101', 2, 10)\n    '5'\n    >>> convert_base('FF', 16, 2)\n    '11111111'\n    \"\"\"\n    import numpy as np\n    # Convert the number from any base to base 10\n    base10 = int(number, source_base)\n    # Convert from base 10 to the target base\n    if target_base == 10:\n        return str(base10)\n    else:\n        return np.base_repr(base10, base=target_base)", "def convert_base(number, from_base, to_base):\n    \"\"\"\n    Convert the representation of a given number from one base to another.\n    Parameters:\n    number (str): The number inputted in the form of a string in its initial base.\n    from_base (int): The base of the input number.\n    to_base (int): The base to which the number should be converted.\n    Returns:\n    str: The number represented in the new base as a string.\n    Examples:\n    >>> convert_base('101', 2, 10)\n    '5'\n    >>> convert_base('255', 10, 16)\n    'FF'\n    \"\"\"\n    import math\n    # Convert number from its base to decimal\n    decimal = 0\n    power = len(number) - 1\n    for digit in number:\n        decimal += int(digit, from_base) * (from_base ** power)\n        power -= 1\n    # Convert decimal to the target base\n    if decimal == 0:\n        return '0'\n    \n    result = []\n    while decimal > 0:\n        result.append(int(decimal % to_base))\n        decimal //= to_base\n    \n    # Convert each digit to appropriate base string representation and reverse\n    return ''.join(str(x) for x in reversed(result))"], ["def add_numbers_in_base(num1, num2, base):\n    \"\"\"\n    Adds two numbers in the same specified base without converting to base 10.\n    Parameters:\n    ----------\n    num1, num2 : str\n        The numbers in the specified base represented as strings.\n    base : int\n        The base in which the addition is to be performed.\n    Returns:\n    -------\n    str\n        The result of the addition in the same base.\n    Examples:\n    --------\n    >>> add_numbers_in_base('12', '1', 3)\n    '20'\n    >>> add_numbers_in_base('FF', '1', 16)\n    '100'\n    \"\"\"\n    max_len = max(len(num1), len(num2))\n    num1, num2 = num1.zfill(max_len), num2.zfill(max_len)\n    \n    carry = 0\n    result = []\n    \n    for i in range(max_len-1, -1, -1):\n        val1 = int(num1[i], base)\n        val2 = int(num2[i], base)\n        \n        total = val1 + val2 + carry\n        carry, remainder = divmod(total, base)\n        \n        result.append(convert_number_to_base(remainder, base))\n    \n    if carry:\n        result.append(convert_number_to_base(carry, base))\n    \n    return ''.join(reversed(result))", "def add_in_base(n1, n2, base):\n    \"\"\"\n    Adds two numbers expressed in the same arbitrary base without converting to base 10.\n    \n    Parameters\n    ----------\n    n1 : str\n        The first number in a specific `base`\n    n2 : str\n        The second number in the same `base` as `n1`\n    base : int\n        The base in which both numbers are expressed\n    \n    Returns\n    -------\n    str\n        The sum of `n1` and `n2` in the specified `base`, expressed as a string\n    \n    Examples\n    --------\n    >>> add_in_base('10', '11', 2)\n    '101'\n    >>> add_in_base('2', '7', 10)\n    '9'\n    \"\"\"\n    # Convert both numbers to decimal, add them, then convert back\n    dec_n1 = int(n1, base)\n    dec_n2 = int(n2, base)\n    sum_dec = dec_n1 + dec_n2\n    \n    # Now convert the decimal sum back to the original base\n    return convert_number_to_base(sum_dec, base)"], ["def binary_to_decimal(binary_str):\n    \"\"\"\n    Convert a binary number (as a string) to its decimal (base 10) representation.\n    \n    Parameters:\n    - binary_str (str): The binary number as a string.\n    \n    Returns:\n    - int: The decimal representation of the binary number.\n    \n    Examples:\n    >>> binary_to_decimal('101')\n    5\n    >>> binary_to.getValueOfKey('1101')\n    13\n    \"\"\"\n    return int(binary_str, 2)", "def decimal_to_binary(decimal_number):\n    \"\"\"\n    Convert a decimal number to its binary (base 2) representation.\n    \n    Parameters:\n    - decimal_number (int): The decimal number to convert.\n    \n    Returns:\n    - str: The binary representation of the decimal number.\n    \n    Examples:\n    >>> decimal_to_binary(5)\n    '101'\n    >>> decimal_to_binary(13)\n    '1101'\n    \"\"\"\n    return bin(decimal_number)[2:]", "def decimal_to_binary(decimal_number):\n    \"\"\"\n    Convert a decimal integer to its binary string representation.\n    Parameters\n    ----------\n    decimal_number : int\n        The decimal integer to convert.\n    Returns\n    -------\n    str\n        Binary string of the input decimal integer. The string includes the '0b' prefix,\n        or '-0b' for negative numbers.\n    Examples\n    --------\n    >>> decimal_to_binary(10)\n    '0b1010'\n    >>> decimal_to_binary(-5)\n    '-0b101'\n    \"\"\"\n    if decimal_number == 0:\n        return \"0b0\"\n    if decimal_number < 0:\n        return '-0b' + bin(-decimal_number)[2:]\n    return bin(decimal_number)", "def binary_to_decimal(binary_string):\n    \"\"\"\n    Convert a binary string (with '0b' prefix) to its decimal integer representation.\n    Parameters\n    ----------\n    binary_string : str\n        The binary string to convert. It must include the '0b' prefix, and may include a\n        '-' sign for negative values ('-0b').\n    Returns\n    -------\n    int\n        Decimal integer equivalent of the binary string.\n    Examples\n    --------\n    >>> binary_to_decimal('0b1010')\n    10\n    >>> binary_to_decimal('-0b101')\n    -5\n    \"\"\"\n    return int(binary_string, 2)"], ["def is_palindrome(num, base=10):\n    \"\"\"\n    Check if the number is a palindrome in the given base.\n    \n    Parameters:\n        num (int): The actual number to check for being a palindrome.\n        base (int): The numerical base in which the number's palindromic property is to be checked.\n    Returns:\n        bool: True if the number is a palindrome in the given base, False otherwise.\n    \n    Examples:\n        >>> is_palindrome(121, 10)\n        True\n        >>> is_palindrome(0b11011, 2)\n        True\n    \"\"\"\n    num_str = convert_number_from_base_to_base(str(num), 10, base)\n    return num_str == num_str[::-1]", "def is_palindrome_in_base(number, base):\n    \"\"\"\n    Check if the given number is a palindrome in the specified base.\n    Parameters:\n    number : int\n        The number to check.\n    base : int\n        The base in which to check for palindromic properties.\n    Returns:\n    bool:\n        True if the number is a palindrome in the specified base, False otherwise.\n    Examples:\n    >>> is_palindrome_in_base(121, 10)\n    True\n    >>> is_palindrome_in_base(19, 2)\n    False\n    \"\"\"\n    # Convert the number to the specified base\n    base_rep = convert_base(str(number), 10, base)\n    # Check if the base representation is a palindrome\n    return base_rep == base_rep[::-1]", "def is_palindrome(number, base):\n    \"\"\"\n    Check if the given number is a palindrome in the specified base.\n    Parameters:\n    - number (str): The number in the specified base.\n    - base (int): The base of the number.\n    Returns:\n    - bool: True if the number is a palindrome, else False.\n    Examples:\n    >>> is_palindrome('101', 2)\n    True\n    >>> is_palindrome('10', 10)\n    False\n    \"\"\"\n    return number == number[::-1]"], ["def smallest_palindrome_of_length(length, base):\n    \"\"\"\n    Finds the smallest palindromic number with the specified length in the given base.\n    \n    Parameters:\n        length (int): The length of the palindromic number.\n        base (int): The base in which the palindrome should exist.\n    Returns:\n        str: The smallest palindrome of the given length in the specified base.\n        \n    Examples:\n        >>> smallest_palindrome_of_length(5, 2)\n        '10001'\n        >>> smallest_palindrome_of_length(3, 10)\n        '101'\n    \"\"\"\n    if length == 1:\n        return '1'\n    elif length == 2:\n        return '11'\n    \n    # Start with the minimal number consisting of \"1\" followed by zeroes and closing with \"1\"\n    start = '1' + '0' * (length - 2) + '1'\n    return start", "def find_smallest_palindrome(length, base):\n    \"\"\"\n    Find the smallest palindromic number of specified length and base.\n    Parameters:\n    - length (int): The minimum length of the palindrome.\n    - base (int): The numeric base.\n    Returns:\n    - str: The smallest palindromic number in the specified base.\n    Examples:\n    >>> find_smallest_palindrome(5, 2)\n    '10001'\n    \"\"\"\n    if length == 1:\n        return '1'\n    elif length % 2 == 0:\n        return '1' + '0' * (length - 2) + '1'\n    else:\n        return '1' + '0' * (length - 1) + '1'"], ["def perform_arithmetic_base(num1, num2, base, operation):\n    \"\"\"\n    Perform arithmetic operations between two numbers in the same base and handle carrying or borrowing.\n    Parameters:\n    num1 (str): The first number in base 'base'.\n    num2 (str): The second number in base 'base'.\n    base (int): The base in which the arithmetic operation will be performed.\n    operation (str): The operation to perform ('+', '-').\n    Returns:\n    str: The result of the arithmetic operation in the same base.\n    Examples:\n    >>> perform_arithmetic_base('102', '203', 4, '+')\n    '311'\n    >>> perform_arithmetic_base('310', '123', 6, '-')\n    '201'\n    \"\"\"\n    # Convert numbers to decimal\n    decimal_1 = int(num1, base)\n    decimal_2 = int(num2, base)\n    \n    # Perform the operation in decimal\n    if operation == '+':\n        result_decimal = decimal_1 + decimal_2\n    elif operation == '-':\n        result_decimal = decimal_1 - decimal_2\n    else:\n        raise ValueError(\"Unsupported operation\")\n    # Convert the result back to the base\n    return convert_base(str(result_decimal), 10, base)"], ["def smallest_binary_palindrome(length):\n    \"\"\"\n    Find the smallest palindromic number in binary with a specified length.\n    Parameters:\n    length : int\n        The length of the binary palindrome.\n    Returns:\n    str:\n        The smallest binary palindromic number of the specified length.\n    Examples:\n    >>> smallest_binary_palindrome(5)\n    '10001'\n    \"\"\"\n    # Must at least be of length 1 and has to be odd for a singular smallest palindromic number\n    if length < 1:\n        raise ValueError(\"Length must be at least 1.\")\n    \n    if length == 1:\n        return \"1\"\n    \n    half = \"1\" + \"0\" * (length // 2 - 1)\n    return half + half[::-1]  # mirror the first half to form a palindrome"]], "Least Common Multiple": [["def lcm(*numbers):\n    \"\"\"\n    Compute the Least Common Multiple (LCM) of a set of integers using their greatest common divisor (GCD).\n    Parameters\n    ----------\n    numbers : int\n        An unpacked tuple of integers for which the LCM is to be calculated.\n    Returns\n    -------\n    int\n        The LCM of the provided integers.\n    \n    Examples\n    --------\n    >>> lcm(12, 15)\n    60\n    >>> lcm(5, 10, 20)\n    20\n    >>> lcm(21, 6)\n    42\n    \"\"\"\n    def lcm_two_numbers(a, b):\n        return abs(a*b) // gcd(a, b)\n    return reduce(lcm_two_numbers, numbers, 1)", "def lcm_pairwise(a, b):\n    \"\"\"\n    Calculate the Least Common Multiple (LCM) of two integers using the greatest common divisor (GCD).\n    Parameters:\n        a (int): First integer.\n        b (int): Second integer.\n    Returns:\n        int: Least common multiple of `a` and `b`.\n    Examples:\n        >>> lcm_pairwise(12, 15)\n        60\n        >>> lcm_pairwise(3, 7)\n        21\n    \"\"\"\n    if a == 0 or b == 0:\n        return 0\n    return abs(a * b) // gcd(a, b)", "def lcm(x, y):\n    \"\"\"\n    Calculate the Least Common Multiple (LCM) of two integers.\n    Parameters:\n    - x (int): First integer.\n    - y (int): Second integer.\n    Returns:\n    - int: LCM of the two integers.\n    Examples:\n    >>> lcm(12, 18)\n    36\n    >>> lcm(5, 11)\n    55\n    \"\"\"\n    return abs(x * y) // gcd(x, y)"], ["def calculate_lcm(numbers):\n    \"\"\"\n    Calculates the Least Common Multiple (LCM) of a list of integers.\n    Parameters:\n    - numbers (List[int]): A list of integers for which the LCM is to be calculated.\n    \n    Returns:\n    - int: The least common multiple of the provided integers.\n    \n    Examples:\n    >>> calculate_lcm([24, 36])\n    72\n    \n    >>> calculate_lcm([3, 4, 5])\n    60\n    \n    \"\"\"\n    if not all(isinstance(num, int) for num in numbers):\n        raise ValueError(\"All items in the list must be integers.\")\n    if any(num <= 0 for num in numbers):\n        raise ValueError(\"All numbers must be positive integers.\")\n    return lcm(numbers)", "def compute_lcm(numbers):\n    \"\"\"\n    Calculate the least common multiple (LCM) of a list of numbers based on prime factorization.\n    Parameters\n    ----------\n    numbers : list of int\n        The list of integers for which the LCM is to be calculated.\n    Returns\n    -------\n    int\n        The least common multiple of the provided numbers.\n    Examples\n    --------\n    >>> compute_lcm([21, 6])\n    42\n    >>> compute_lcm([5, 10, 15])\n    30\n    >>> compute_lcm([4, 5, 6])\n    60\n    \"\"\"\n    if not numbers:\n        return 1  # LCM of an empty list is conventionally 1\n    \n    # Initialize LCM to the first number\n    lcm_result = numbers[0]\n    for number in numbers[1:]:\n        lcm_result = sympy.lcm(lcm_result, number)\n    \n    return lcm_result", "def lcm_of_numbers(*numbers):\n    \"\"\"\n    Calculate the least common multiple (LCM) of a set of integers using\n    their prime factorizations. It takes any number of integer arguments \n    and returns the LCM.\n    Parameters\n    ----------\n    *numbers : int\n        A sequence of numbers for which LCM is sought.\n        \n    Returns\n    -------\n    int\n        The least common multiple of all provided integers.\n    \n    Examples\n    --------\n    >>> lcm_of_numbers(15, 25, 10)\n    150\n    >>> lcm_of_numbers(21, 14)\n    42\n    >>> lcm_of_numbers(3, 5, 7, 11)\n    1155\n    \"\"\"\n    \n    if not all(isinstance(number, int) for number in numbers):\n        raise ValueError(\"All inputs must be integers.\")\n    \n    from functools import reduce\n    from sympy.ntheory import factorint\n    \n    def lcm(a, b):\n        a_factors = factorint(a)\n        b_factors = factorint(b)\n        lcm_factors = {}\n        \n        # Get all primes from both factorizations\n        all_primes = set(a_factors.keys()).union(b_factors.keys())\n        \n        # For each prime, pick the highest power from either factorization\n        for prime in all_primes:\n            if prime in a_factors and prime in b_factors:\n                lcm_factors[prime] = max(a_factors[prime], b_factors[prime])\n            elif prime in a_factors:\n                lcm_factors[prime] = a_factors[prime]\n            else:\n                lcm_factors[prime] = b_factors[prime]\n        \n        # Compute the LCM from the factor dictionary\n        result = 1\n        for prime, power in lcm_factors.items():\n            result *= prime ** power\n        \n        return result\n    \n    return reduce(lcm, numbers)", "def lcm_multiple(nums):\n    \"\"\"\n    Calculate the Least Common Multiple (LCM) of a list of integers using the pairwise LCM approach.\n    Parameters:\n        nums (list): A list of integers.\n    Returns:\n        int: Least common multiple of all integers in the list.\n    Examples:\n        >>> lcm_multiple([4, 6, 8])\n        24\n        >>> lcm_multiple([5, 10, 20])\n        20\n    \"\"\"\n    return reduce(lcm_pairwise, nums, 1)", "def lcm_multiple(numbers):\n    \"\"\"\n    Calculate the LCM of a list of integers using the lcm function defined above through reduction.\n    Parameters:\n    - numbers (list of int): List of integers to find the LCM for.\n    Returns:\n    - int: LCM of the given list of integers.\n    Examples:\n    >>> lcm_multiple([12, 15, 18])\n    180\n    >>> lcm_multiple([4, 6, 8, 12])\n    24\n    \"\"\"\n    return reduce(lcm, numbers)"], ["def prime_factorization(number):\n    \"\"\"\n    Computes the prime factorization of a given integer.\n    Parameters:\n    - number (int): The integer to be factorized.\n    \n    Returns:\n    - List[int]: A list containing the prime factors of the input integer.\n    \n    Examples:\n    >>> prime_factorization(60)\n    [2, 2, 3, 5]\n    \n    >>> prime_factorization(13)\n    [13]\n    \n    \"\"\"\n    if number <= 0:\n        raise ValueError(\"Number must be a positive integer.\")\n    factors = []\n    for factor in primefactors(number):\n        count = 0\n        temp = number\n        while temp % factor == 0:\n            temp //= factor\n            count += 1\n        factors.extend([factor] * count)\n    return factors"], ["def prime_factorization(n):\n    \"\"\"\n    Compute the prime factors of a given positive integer n using the sympy library.\n    Parameters\n    ----------\n    n : int\n        The integer to factorize.\n    Returns\n    -------\n    list\n        A list of the prime factors of the integer.\n    Examples\n    --------\n    >>> prime_factorization(18)\n    [2, 3]\n    >>> prime_factorization(100)\n    [2, 5]\n    \"\"\"\n    return primefactors(n)"]], "Integers": [["def factors(n):\n    \"\"\"\n    Find all factors of the given integer.\n    Parameters:\n    n (int): Integer to find factors of.\n    Returns:\n    list: List of all factors of n.\n    Examples:\n    >>> factors(36)\n    [1, 2, 3, 4, 6, 9, 12, 18, 36]\n    \"\"\"\n    return [i for i in range(1, n + 1) if n % i == 0]", "def find_factors(n):\n    \"\"\"\n    Finds all factors of the given integer.\n    Parameters:\n    n (int): The integer to find factors of.\n    Returns:\n    list: A list containing all the factors of n.\n    Examples:\n    >>> find_factors(36)\n    [1, 2, 3, 4, 6, 9, 12, 18, 36]\n    >>> find_factors(101)\n    [1, 101]\n    \"\"\"\n    factors = []\n    for i in range(1, int(n ** 0.5) + 1):\n        if n % i == 0:\n            factors.append(i)\n            if i != n // i:\n                factors.append(n // i)\n    factors.sort()\n    return factors", "def find_factors(number: int) -> List[int]:\n    \"\"\"\n    Find all factors of a given number.\n    \n    Parameters:\n    - number (int): The integer to find factors for.\n    \n    Returns:\n    List[int]: A list of factors of the number.\n    \n    Example:\n    >>> find_factors(12)\n    [1, 2, 3, 4, 6, 12]\n    \"\"\"\n    factors = []\n    for i in range(1, int(math.sqrt(number)) + 1):\n        if number % i == 0:\n            factors.append(i)\n            if i != number // i:\n                factors.append(number // i)\n    factors.sort()\n    return factors"], ["def has_integer_solution(coefficients):\n    \"\"\"\n    Determines if a polynomial equation represented by given coefficients has at least one integer solution.\n    Parameters:\n    coefficients (list): A list of coefficients from the highest degree to the lowest of the polynomial equation.\n    Returns:\n    bool: True if there is at least one integer solution.\n    Notes:\n    Uses algebraic number theory to determine possible solutions; however, providing the exact method of solving such polynomials is complex due to the Abel-Ruffini theorem restrictions and generally solved using numerical approximations or specialized algebra systems.\n    Example:\n    # For a simple equation x^2 - 5 = 0\n    >>> has_integer_solution([1, 0, -5])\n    True\n    \"\"\"\n    # Placeholder for demonstration.\n    # Implementation will depend on the specific requirements and polynomial degree.\n    # For a quadratic equation ax^2 + bx + c:\n    import cmath\n    a, b, c = coefficients\n    discriminant = cmath.sqrt(b**2 - 4*a*c)\n    root1 = (-b + discriminant) / (2 * a)\n    root2 = (-b - discriminant) / (2 * a)\n    return root1.imag == 0 and root1.real.is_integer() or root2.imag == 0 and root2.real.is_integer()", "def has_integer_solutions(coefficients: List[int]) -> bool:\n    \"\"\"\n    Determine if a polynomial equation with given coefficients has integer solutions.\n    \n    Parameters:\n    - coefficients (List[int]): Coefficients of the polynomial equation from highest degree to constant term.\n    \n    Returns:\n    bool: True if the equation has potential integer solutions, else False.\n    \n    Example:\n    >>> has_integer_solutions([1, -6, 9])  # x^2 - 6x + 9 = 0, which simplifies to (x-3)^2 = 0\n    True\n    \"\"\"\n    from numpy import poly1d, polyroots\n    poly = poly1d(coefficients)\n    roots = polyroots(poly)\n    # Check if all roots are integers\n    return all(root.is_integer() for root in roots)"], ["def gcd(x, y):\n    \"\"\"\n    Calculate the Greatest Common Divisor (GCD) of two integers.\n    Parameters:\n    x (int): First integer.\n    y (int): Second integer.\n    Returns:\n    int: GCD of x and y.\n    Examples:\n    >>> gcd(20, 28)\n    4\n    >>> gcd(35, 10)\n    5\n    \"\"\"\n    return math.gcd(x, y)", "def compute_gcd(a, b):\n    \"\"\"\n    Calculate the greatest common divisor (GCD) of two integers.\n    Parameters:\n    a (int): The first integer.\n    b (int): The second integer.\n    Returns:\n    int: The greatest common divisor of a and b.\n    Examples:\n    >>> compute_gcd(12, 15)\n    3\n    >>> compute_gcd(100, 85)\n    5\n    \"\"\"\n    return gcd(a, b)"], ["def is_divisible(numerator: int, denominator: int) -> bool:\n    \"\"\"\n    Check if the numerator is divisible by the denominator.\n    \n    Parameters:\n    - numerator (int): The number to be divided.\n    - denominator (int): The number to divide by.\n    \n    Returns:\n    bool: True if numerator is divisible by denominator, else False.\n    \n    Example:\n    >>> is_divisible(15, 5)\n    True\n    >>> is_divisible(14, 5)\n    False\n    \"\"\"\n    if denominator == 0:\n        raise ValueError(\"Denominator cannot be zero.\")\n    return numerator % denominator == 0"], ["def unique_mode(integers):\n    \"\"\"\n    Finds the mode of a list of integers that appears most frequently.\n    Parameters:\n    integers (list): List of integers.\n    Returns:\n    tuple: mode of the list and its frequency, or None if no unique mode exists.\n    Examples:\n    >>> unique_mode([1, 2, 2, 3, 4])\n    (2, 2)\n    >>> unique_message([1, 1, 2, 2, 3, 3])\n    None\n    \"\"\"\n    counts = Counter(integers)\n    if len(set(counts.values())) == 1:  # check for tie in frequency\n        return None\n    mode = max(counts, key=counts.get)\n    return (mode, counts[mode])"], ["def integer_solutions(poly, domain_range):\n    \"\"\"\n    Identify integer solutions for a polynomial within a specified domain.\n    Parameters:\n    poly (function): Polynomial function.\n    domain_range (range): Range of domain to check for integer solutions.\n    Returns:\n    list: List of tuples where each tuple contains (x, y) such that poly(x) == y and y is an integer.\n    Examples:\n    >>> poly = lambda x: x**2 - 4*x + 6\n    >>> integer_solutions(poly, range(-10, 10))\n    [(-8, 70), (-7, 56), (-6, 44), ..., (6, 6), (7, 8), (8, 14), (9, 22)]\n    \"\"\"\n    return [(x, poly(x)) for x in domain_range if isinstance(poly(x), int)]"], ["def is_coprime(a, b):\n    \"\"\"\n    Determine if two integers are coprime (i.e., their GCD is 1).\n    Parameters:\n    a (int): The first integer.\n    b (int): The second integer.\n    Returns:\n    bool: True if a and b are coprime, else False.\n    Examples:\n    >>> is_coprime(15, 28)\n    True\n    >>> is_coprime(12, 18)\n    False\n    \"\"\"\n    return gcd(a, b) == 1"], ["def multiples(n, limit):\n    \"\"\"\n    Find all multiples of the given integer up to a specified limit.\n    Parameters:\n    n (int): Integer to find multiples of.\n    limit (int): Upper limit to search for multiples.\n    Returns:\n    list: List of multiples of n up to limit.\n    Examples:\n    >>> multiples(3, 10)\n    [3, 6, 9]\n    \"\"\"\n    return [i * n for i in range(1, limit // n + 1)]"], ["def gcd_multiple(numbers: List[int]) -> int:\n    \"\"\"\n    Compute the greatest common divisor of a list of integers.\n    \n    Parameters:\n    - numbers (List[int]): A list of integers to find the GCD.\n    \n    Returns:\n    int: The greatest common divisor of the provided numbers.\n    \n    Example:\n    >>> gcd_multiple([8, 12, 16])\n    4\n    \"\"\"\n    from functools import reduce\n    return reduce(math.gcd, numbers)"]], "Units Digit": [["def get_units_digit(number):\n    \"\"\"\n    Get the units digit of a given number.\n    \n    Parameters:\n        number (int): The number to find the units digit of.\n    \n    Returns:\n        int: The units digit of the number.\n        \n    Examples:\n        >>> get_units_digit(123)\n        3\n        >>> get_units_digit(-987)\n        3\n    \"\"\"\n    return abs(number) % 10", "def units_digit(n):\n    \"\"\"\n    Calculate the units digit of a given integer.\n    \n    Parameters\n    ----------\n    n : int\n        The integer for which the units digit is to be calculated.\n    Returns\n    -------\n    int\n        The units digit of the input number.\n    Examples\n    --------\n    >>> units_digit(245)\n    5\n    >>> units_digit(-123)\n    3\n    >>> units_digit(100020)\n    0\n    \"\"\"\n    return abs(n) % 10", "def units_digit(number):\n    \"\"\"\n    Calculate the units digit of a provided number.\n    \n    Parameters:\n    - number (int or str): Number or expression from which to find the units digit.\n    Returns:\n    - int: The units digit of the number.\n    Examples:\n    >>> units_digit(123)\n    3\n    >>> units_digit(2**10)  # Calculating the units digit of 2 raised to the power of 10\n    4\n    \"\"\"\n    return int(str(number)[-1])", "def get_units_digit(number):\n    \"\"\"\n    Calculate the units digit of a given integer.\n    Parameters:\n    - number (int): The integer whose units digit is required.\n    \n    Returns:\n    - int: The units digit of the input number.\n    Examples:\n    >>> get_units_digit(123)\n    3\n    >>> get_units_digit(-987)\n    7\n    \"\"\"\n    return abs(number) % 10", "def units_digit(n):\n    \"\"\"\n    Calculate the units digit of an integer n.\n    \n    Parameters:\n    n (int): The integer for which the units digit is to be found.\n    Returns:\n    int: Units digit of the provided integer.\n    \n    Examples:\n    >>> units_digit(123)\n    3\n    >>> units_digit(-789)\n    9\n    \"\"\"\n    return abs(n) % 10"], ["def arithmetic_units_digit(a, b, operation='add'):\n    \"\"\"\n    Compute the units digit resulting from the arithmetic operation (addition, subtraction, or multiplication) on two integers.\n    Parameters:\n    - a (int): The first integer.\n    - b (int): The second integer.\n    - operation (str): The arithmetic operation to perform: 'add', 'subtract', 'multiply'. Default is 'add'.\n    \n    Returns:\n    - int: The units digit after performing the specified arithmetic operation.\n    Examples:\n    >>> arithmetic_units_digit(123, 456)\n    9\n    >>> arithmetic_units_items(987, 654, 'multiply')\n    8\n    >>> arithmetic_units_digit(89, 32, 'subtract')\n    7\n    \"\"\"\n    operations = {\n        'add': (a + b) % 10,\n        'subtract': (a - b) % 10,\n        'multiply': (a * b) % 10\n    }\n    \n    return operations[operation]", "def units_digit_operations(*args, operation='multiply'):\n    \"\"\"\n    Compute the units digit of multiple numbers under specified operations.\n    Parameters\n    ----------\n    *args : int\n        Variable length argument list representing the numbers.\n    operation : str\n        The operation to perform on the units digits ('multiply', 'add', 'subtract').\n    Returns\n    -------\n    int\n        The resultant units digit.\n    Example\n    -------\n    >>> units_digit_operations(2, 3, 7, operation='multiply')\n    2\n    \"\"\"\n    result = 1 if operation == 'multiply' else 0\n    for number in args:\n        if operation == 'multiply':\n            result = (result * number) % 10\n        elif operation == 'add':\n            result = (result + number) % 10\n        elif operation == 'subtract':\n            result = (result - number) % 10\n    return result % 10"], ["def units_digit_of_multiplication(a, b):\n    \"\"\"\n    Calculate the units digit of the product of two integers.\n    \n    Parameters:\n        a (int): First multiplicand.\n        b (int): Second multiplicand.\n    Returns:\n        int: The units digit of the product of a and b.\n    Examples:\n        >>> units_digit_of_multiplication(12, 15)\n        0\n        >>> units_digit_of_multiplication(123, 456)\n        8\n    \"\"\"\n    return (a * b) % 10", "def get_units_digit_of_product(a, b):\n    \"\"\"\n    Calculate the units digit of the product of two integers using modular arithmetic.\n    \n    Parameters:\n    - a (int): The first integer.\n    - b (int): The second integer.\n    \n    Returns:\n    - int: The units digit of the product of `a` and `b`.\n    \n    Examples:\n    >>> get_units_digit_of_product(12, 9)\n    8\n    >>> get_units_lit+20).jpeg_digit_of_product(12345, 67890)\n    0\n    \"\"\"\n    return (a * b) % 10"], ["def count_units_digit_condition(base_start, base_end, exponent_limit, target_digit):\n    \"\"\"\n    Count occurrences of a specific unit digit in the given range and exponent conditions.\n    Parameters:\n    - base_start (int): The starting base number for computation.\n    - base_end (int): The ending base number for computation.\n    - exponent_limit (int): The maximum exponent to consider.\n    - target_digit (int): The units digit to count matches for.\n    \n    Returns:\n    - int: Number of matches found within specified range and conditions.\n    Examples:\n    >>> count_units_digit_condition(2, 10, 4, 6)\n    3\n    \"\"\"\n    count = 0\n    for base in range(base_start, base_end + 1):\n        for exponent in range(1, exponent_limit + 1):\n            if units_digit_of_power(base, exponent) == target_digit:\n                count += 1\n    return count"], ["def find_units_digit_of_power(base, exponent):\n    \"\"\"\n    Compute the units digit of a given number raised to a specified power by leveraging the cyclic nature of units digits.\n    \n    Parameters:\n        base (int): The base number.\n        exponent (int): The exponent to raise the base to.\n    \n    Returns:\n        int: The units digit of the result.\n        \n    Examples:\n        >>> find_units_digit_of_power(2, 10)\n        4\n        >>> find_units_digit_of_power(5, 100)\n        5\n    \"\"\"\n    if exponent == 0:\n        return 1  # Any number to the power of 0 equals 1\n    cycle = [base % 10]\n    while True:\n        next_digit = (cycle[-1] * base) % 10\n        if next_digit in cycle:  # Cycle is repeating\n            break\n        cycle.append(next_digit)\n    cycle_length = len(cycle)\n    effective_exponent = (exponent - 1) % cycle_length  # -1 because cycle starts from first calculation\n    return cycle[effective_exponent]", "def units_digit_from_powers(base, exponent):\n    \"\"\"\n    Compute the units digit of a number raised to a given power using the cyclic nature of powers.\n    \n    Parameters\n    ----------\n    base : int\n        Base of the power expression.\n    exponent : int\n        Exponent of the power expression.\n    \n    Returns\n    -------\n    int\n        The units digit of the base raised to the exponent.\n    \n    Examples\n    --------\n    >>> units_digit_from_powers(2, 10)\n    4\n    \n    >>> units_digit_from_powers(3, 3)\n    7\n    \"\"\"\n    # A number raised to any power has a units digit that repeats every 4 powers,\n    # due to Euler's theorem regarding the units digit cycle length for powers modulo 10.\n    base %= 10\n    exponent %= 4  # Take advantage of the cycle of 4 in units digits\n    \n    if exponent == 0:\n        return 1  # Any non-zero number to the power of zero is 1 (and thus unit digit 1)\n    \n    result = base\n    for _ in range(1, exponent):\n        result = (result * base) % 10\n    \n    return result", "def units_digit_of_power(base, exponent):\n    \"\"\"\n    Calculate the units digit of a number gotten by raising a base to a specified exponent.\n    \n    Parameters:\n    - base (int): The base number.\n    - exponent (int): The exponent value.\n    Returns:\n    - int: Units digit after performing base**exponent.\n    Examples:\n    >>> units_digit_of_power(4, 2)\n    6\n    \"\"\"\n    # Recognize units digit patterns for powers since they cycle every 4 in general scenario\n    base_units_digit = base % 10\n    pattern = [base_units_digit]\n    current_value = base_units_digit\n    \n    # Generate cycle pattern by mod 10 until it repeats\n    while True:\n        current_value = (current_value * base_units_digit) % 10\n        if current_value in pattern:\n            break\n        pattern.append(current_value)\n    \n    # Find position in cycle using exponent\n    position = (exponent % len(pattern)) - 1\n    return pattern[position] if position != -1 else pattern[-1]", "def powered_units_digit(base, exponent):\n    \"\"\"\n    Calculate the units digit of a number raised to a power.\n    Parameters:\n    - base (int): The base of the exponentiation.\n    - exponent (int): The exponent to raise the base.\n    Returns:\n    - int: Units digit of the result of the exponentiation.\n    Examples:\n    >>> powered_units_digit(2, 10)\n    4\n    >>> powered_units_item(7, 3)\n    3\n    \"\"\"\n    # As digits patterns repeat every 4 in most cases\n    return (base ** exponent) % 10", "def units_digit_of_power(base, exponent):\n    \"\"\"\n    Calculate the units digit of a number raised to a certain power using\n    the cyclic pattern of units digits.\n    Parameters:\n        base (int): The base number.\n        exponent (int): The exponent to which the base is raised.\n    Returns:\n        int: The units digit of base raised to the exponent.\n    Examples:\n        >>> units_digit_of_power(12, 2)\n        4\n        >>> units_digit_of_power(7, 5)\n        3\n    \"\"\"\n    # Units digit cycles for bases 0 through 9\n    cycles = {\n        0: [0], 1: [1], 2: [2, 4, 8, 6], 3: [3, 9, 7, 1], 4: [4, 6],\n        5: [5], 6: [6], 7: [7, 9, 3, 1], 8: [8, 4, 2, 6], 9: [9, 1]\n    }\n    last_digit = base % 10\n    cycle = cycles[last_digit]\n    cycle_length = len(cycle)\n    # Find the index in the cycle\n    index = (exponent % cycle_length) - 1\n    return cycle[index]", "def power_units_digit(base, exponent):\n    \"\"\"\n    Calculate the units digit of a number raised to a power. Recognizing the cyclic nature of units digits in powers,\n    this function leverages patterns in the last digits.\n    Parameters:\n    base (int): The base number.\n    exponent (int): The exponent to which the base number is raised.\n    Returns:\n    int: Units digit of the result of the base raised to the exponent.\n    Examples:\n    >>> power_units_digit(2, 3)\n    8\n    >>> power_units_digit(5, 100)\n    5\n    \"\"\"\n    # Last digit cycles for basis 0-9, pre-computed to optimize\n    cycles = {\n        0: [0],\n        1: [1],\n        2: [2, 4, 8, 6],\n        3: [3, 9, 7, 1],\n        4: [4, 6],\n        5: [5],\n        6: [6],\n        7: [7, 9, 3, 1],\n        8: [8, 4, 2, 6],\n        9: [9, 1]\n    }\n    \n    # Obtain the last digit of the base\n    last_digit = base % 10\n    # Cycle length of the last digit\n    cycle = cycles[last_digit]\n    cycle_length = len(cycle)\n    \n    # The position in the cycle based on the exponent\n    position = (exponent % cycle_length) - 1\n    \n    # Handle zero exponent special case\n    if exponent == 0:\n        return 1\n    else:\n        return cycle[position]", "def units_digit_exponent(base, exponent):\n    \"\"\"\n    Calculate the units digit of a number raised to a power.\n    \n    Parameters\n    ----------\n    base : int\n        The base number.\n    exponent : int\n        The exponent to which the base is raised.\n    Returns\n    -------\n    int\n        The units digit of the resulting number.\n    Example\n    -------\n    >>> units_digit_exponent(2, 10)\n    4\n    \"\"\"\n    # Since the units digits repeat every 4 cycles or are less,\n    # we can use mod 4 on the exponent to reduce unnecessary computation.\n    if exponent == 0:\n        return 1\n    base = base % 10\n    # List of units digits for power cycles % 4\n    cycle = [base]\n    for _ in range(1, 4):\n        base = (base * (cycle[0] % 10)) % 10\n        cycle.append(base)\n    # Exponent % 4 gives us the correct position in the cycle, shifted by 1 (0-indexed)\n    return cycle[(exponent % 4) - 1]", "def get_units_digit_of_power(base, exponent):\n    \"\"\"\n    Compute the units digit of a number raised to an exponent based on cyclic patterns observed in modular arithmetic particularly of powers modulo 10.\n    \n    The function reduces repetitive computation by leveraging the cyclic nature of the units digit when raising numbers to successively higher powers, utilizing modulo reduction.\n    \n    Parameters:\n    - base (int): The base integer whose power's units digit needs to be found.\n    - exponent (int): The exponent to which the base is raised.\n    \n    Returns:\n    - int: The units digit of `base` raised to `exponent`.\n    \n    Examples:\n    >>> get_units_digit_of_power(2, 10)\n    4\n    >>> get_units_digit_of_power(3, 3)\n    7\n    \"\"\"\n    # Cyclic patterns in units digits when bases are raised to higher powers (modulo 10)\n    cyclic_patterns = {\n        0: [0], 1: [1], 2: [2, 4, 8, 6], 3: [3, 9, 7, 1],\n        4: [4, 6], 5: [5], 6: [6], 7: [7, 9, 3, 1],\n        8: [8, 4, 2, 6], 9: [9, 1]\n    }\n    \n    last_digit = base % 10\n    pattern = cyclic_patterns[last_digit]\n    \n    # Handling cases where exponent is zero:\n    if exponent == 0:\n        return 1  # by definition any number to the power of 0 is 1\n    \n    # Get the correct index in the cycle corresponding to the given exponent:\n    cycle_length = len(pattern)\n    index = (exponent - 1) % cycle_length  # minus 1 because cycles in patterns are zero-indexed\n    \n    return pattern[index]"], ["def units_digit_sequence(start, end, function):\n    \"\"\"\n    Compute the units digits sequence for a range of integers using a given function, which could be a simple\n    units digit function or a power units digit function applied within a range.\n    Parameters:\n    start (int): The start integer of the sequence.\n    end (int): The end integer of the sequence (inclusive).\n    function (callable): A function that computes the units digit or related transformation.\n    Returns:\n    list: Sequence of results from applying the function to range of numbers.\n    Examples:\n    >>> units_digit_sequence(1, 10, lambda x: units_digit(x**2))\n    [1, 4, 9, 6, 5, 6, 9, 4, 1, 0]\n    >>> units_digit_sequence(3, 6, lambda x: power_units_digit(2, x))\n    [8, 4, 2, 6]\n    \"\"\"\n    return [function(n) for n in range(start, end + 1)]"], ["def units_digit_of_product(*args):\n    \"\"\"\n    Compute the units digit of a product of multiple integers.\n    \n    This function can also be used to compute the units digit of exponentiations \n    by repeating the base in the argument list the number of times equal to the exponent.\n    Parameters\n    ----------\n    *args : int\n        A variable number of integers whose product's units digit is to be calculated.\n    Returns\n    -------\n    int\n        The units digit of the product of the given integers.\n    Examples\n    --------\n    >>> units_digit_of_product(2, 5)\n    0\n    >>> units_digit_of_product(3, 4, 2)\n    4\n    >>> units_digit_of_product(9, 9)  # This can represent 9^2\n    1\n    \"\"\"\n    product = 1\n    for number in args:\n        # Only multiply units digits to keep computations smaller\n        product = (product * (number % 10)) % 10\n    return product"], ["def units_digit_from_multiplication(numbers):\n    \"\"\"\n    Compute the units digit of the product of a list of numbers.\n    \n    Parameters\n    ----------\n    numbers : list\n        A list of integers whose product's units digit is required.\n    \n    Returns\n    -------\n    int\n        The units digit of the product of the numbers.\n    \n    Examples\n    --------\n    >>> units_digit_from_multiplication([12, 35, 91])\n    0\n    \n    >>> units_digit_from_multiplication([7, 5, 2])\n    0\n    \"\"\"\n    from functools import reduce\n    from operator import mul\n    # Compute the product modulo 10 directly during multiplication to keep numbers manageable\n    result = reduce(lambda x, y: (x * y) % 10, numbers, 1)\n    return result"]], "Prime Factorization": [["def factor_properties(n):\n    \"\"\"\n    Utilizing the prime factorization of an integer, compute various properties such as the total number of factors, \n    all individual factors, and possible product dimensions from these factors.\n    Parameters:\n    - n (int): The integer for which properties based on its prime factorization are calculated.\n    Returns:\n    - dict: A dictionary containing:\n        'total_factors' : int, total number of factors including 1 and n.\n        'factors_list' : list, a list of all factors of the integer n.\n        'dimensions' : list of tuples, representing possible two-dimensional shapes (l, w) that multiply to n.\n    Example:\n    >>> factor_properties(360)\n    {'total_factors': 24, 'factors_list': [1, 2, 3, 4, 5, 6, 8, 9, 10, 12, 15, 18, 20, 24, 30, 36, 45, 60, 72, 90, 120, 180, 360], 'dimensions': [(1, 360), (2, 180), (3, 120), ... (30, 12), (36, 10), (45, 8), (60, 6)]}\n    \"\"\"\n    from sympy import divisors\n    factorization = prime_factorization(n)\n    all_factors = divisors(n)\n    total_factors = len(all_factors)\n    \n    dimensions = [(i, n // i) for i in all_factors if i <= n // i]\n    return {\n        'total_factors': total_factors,\n        'factors_list': all_factors,\n        'dimensions': dimensions\n    }", "def factors_from_prime_factors(n):\n    \"\"\"\n    Calculates all factors of a number based on its prime factorization.\n    Parameters:\n    n (int): The number to calculate factors for. Must be a positive integer.\n    Returns:\n    list: A sorted list of all factors of the number.\n    Example:\n    >>> factors_from_prime_factors(360)\n    [1, 2, 3, 4, 5, 6, 8, 9, 10, 12, 15, 18, 20, 24, 30, 36, 40, 45, 60, 72, 90, 120, 180, 360]\n    >>> factors_from_prime_factors(17)\n    [1, 17]\n    \"\"\"\n    from sympy import divisors\n    # Check if n is a valid input\n    if n < 1:\n        raise ValueError(\"n must be a positive integer\")\n    # Use sympy's divisors function which directly computes all divisors of a number\n    return sorted(divisors(n))"], ["def generate_divisors_from_factors(prime_factors):\n    \"\"\"\n    Generates all possible divisors of a number given its prime factorization.\n    Parameters:\n    ------------\n    prime_factors : dict\n        A dictionary of prime factors as returned by `prime_factorization`, where keys are primes and values are their exponents.\n    \n    Returns:\n    ------------\n    list\n        A sorted list of all divisors of the number.\n    \n    Examples:\n    ------------\n    >>> generate_divisors_from_factors({2: 1, 3: 2})\n    [1, 2, 3, 6, 9, 18]\n    \n    >>> generate_divisors_from_factors({2: 2, 5: 2})\n    [1, 2, 4, 5, 10, 20, 25, 50, 100]\n    \"\"\"\n    from functools import reduce\n    from itertools import product\n    base = sorted(prime_factors.items())\n    series = []\n    for p, exp in base:\n        series.append([p**e for e in range(exp + 1)])\n    divisors = list(map(lambda x: reduce(lambda a, b: a * b, x), product(*series)))\n    return sorted(divisors)"], ["def prime_factorization(n):\n    \"\"\"\n    Computes the prime factorization of the given integer `n`.\n    Parameters:\n    ------------\n    n : int\n        The number to be factorized into primes.\n    \n    Returns:\n    ------------\n    dict\n        A dictionary where keys are the prime factors and values are their respective exponents in the factorization.\n    Examples:\n    ------------\n    >>> prime_factorization(18)\n    {2: 1, 3: 2}\n    \n    >>> prime_factorization(100)\n    {2: 2, 5: 2}\n    \"\"\"\n    if n < 1:\n        raise ValueError(\"n must be a positive integer\")\n    return sympy.factorint(n)", "def prime_factorization(n):\n    \"\"\"\n    Calculate the prime factorization of a given integer.\n    \n    Parameters:\n    - n (int): The integer to factorize. It should be a positive number.\n    \n    Returns:\n    - dict: A dictionary where keys are prime factors and values are their respective powers.\n    \n    Example:\n    >>> prime_factorization(360)\n    {2: 3, 3: 2, 5: 1}\n    \"\"\"\n    assert n > 0, \"The input should be a positive integer.\"\n    return factorint(n)", "def prime_factorization(n):\n    \"\"\"\n    Decomposes a number into its prime factors and returns a dictionary where keys are the prime numbers \n    and values are their respective powers in the factorization.\n    Parameters:\n    n (int): The number to factorize. Must be a positive integer.\n    Returns:\n    dict: A dictionary of prime factors as keys and their powers as values.\n    Example:\n    >>> prime_factorization(360)\n    {2: 3, 3: 2, 5: 1}\n    >>> prime_factorization(17)\n    {17: 1}\n    \"\"\"\n    from sympy import primefactors, factorint\n    if n <= 1:\n        raise ValueError(\"n must be a positive integer greater than 1\")\n    # Using sympy's factorint which returns a dictionary of prime factors and their powers\n    return factorint(n)"]], "Least Common Multiple (LCM)": [["def calculate_lcm(*args):\n    \"\"\" Calculate the Least Common Multiple (LCM) of given integers using their prime factorizations.\n    Parameters:\n    *args : int\n        The integers for which to find the LCM.\n    Returns:\n    int\n        The LCM of the provided integers.\n    Examples:\n    >>> calculate_lcm(12, 15)\n    60\n    >>> calculate_lcm(12, 15, 20)\n    60\n    \"\"\"\n    if not all(isinstance(x, int) and x >= 1 for x in args):\n        raise ValueError(\"All arguments must be positive integers.\")\n    \n    lcm_factors = defaultdict(int)\n    \n    for number in args:\n        factors = prime_factorization(number)\n        for prime, exponent in factors.items():\n            if exponent > lcm_factors[prime]:\n                lcm_factors[prime] = exponent\n    \n    lcm = 1\n    for prime, exponent in lcm_factors.items():\n        lcm *= (prime ** exponent)\n    \n    return lcm", "def lcm_list(numbers):\n    \"\"\"\n    Calculate the least common multiple (LCM) for a list of integers.\n    \n    Parameters:\n        numbers (list of int): A list of non-zero integers.\n    \n    Returns:\n        int: The LCM of all integers in the list.\n    \n    Examples:\n        >>> lcm_list([4, 5, 6])\n        60\n        >>> lcm_list([12, 15, 20])\n        60\n    \"\"\"\n    def lcm_accumulator(x, y):\n        return lcm_two_numbers(x, y)\n    \n    return reduce(lcm_accumulator, numbers)", "def lcm_of_numbers(*numbers):\n    \"\"\"\n    Calculate Least Common Multiple (LCM) of two or more numbers based on prime factorization.\n    Parameters:\n    *numbers: Variable length argument list of integers for which to compute the LCM.\n    Returns:\n    int: The least common multiple of the given numbers.\n    Examples:\n    >>> lcm_of_numbers(6, 15)\n    30   # LCM(6, 15) = 30\n    >>> lcm_of_numbers(12, 15, 20)\n    60   # LCM(12, 15, 20) = 60\n    \"\"\"\n    from functools import reduce\n    # Define an internal function to compute LCM of two numbers\n    def lcm(a, b):\n        a_factors = prime_factors(a)\n        b_factors = prime_factors(b)\n        result_factor = {}\n        \n        # Combine the prime factors taking the highest powers\n        for prime in set(a_factors.keys()).union(b_factors.keys()):\n            if prime in a_factors and prime in b_factors:\n                result_factor[prime] = max(a_factors[prime], b_factors[prime])\n            elif prime in a_factors:\n                result_factor[prime] = a_factors[prime]\n            else:\n                result_factor[prime] = b_factors[prime]\n        \n        # Compute the LCM from the result factor dictionary\n        lcm_value = 1\n        for prime, exponent in result_factor.items():\n            lcm_value *= prime ** exponent\n        return lcm_value\n    return reduce(lcm, numbers)", "def lcm_multiple_numbers(numbers):\n    \"\"\"\n    Calculate the Least Common Multiple (LCM) for a list of integers.\n    Parameters:\n    numbers (list): A list of integers.\n    Returns:\n    int: The least common multiple of the supplied list of integers.\n    Examples:\n    >>> lcm_multiple_numbers([4, 6, 8])\n    24\n    >>> lcm_multiple_numbers([5, 10, 20])\n    20\n    \"\"\"\n    if not numbers:\n        return 0\n    return reduce(lcm_two_numbers, numbers)", "def compute_lcm(*numbers):\n    \"\"\"\n    Compute the least common multiple (LCM) of two or more numbers using their prime factorizations.\n    Parameters:\n    - numbers (int): Variable number of arguments which are the numbers whose LCM is to be found.\n    Returns:\n    - int: The least common multiple of the provided numbers.\n    Example:\n    >>> compute_lcm(15, 20, 30)\n    60\n    \"\"\"\n    from functools import reduce\n    import operator\n    if not all(isinstance(num, int) for num in numbers):\n        raise ValueError(\"All inputs must be integer numbers.\")\n    \n    def lcm(a, b):\n        a_factors = prime_factorization(a)\n        b_factors = prime_factorization(b)\n        combined_factors = {}\n        \n        all_primes = set(a_factors.keys()).union(b_factors.keys())\n        for prime in all_primes:\n            combined_factors[prime] = max(a_factors.get(prime, 0), b_factors.get(prime, 0))\n        \n        lcm_value = 1\n        for prime, exponent in combined_factors.items():\n            lcm_value *= prime ** exponent\n        \n        return lcm_value\n    \n    return reduce(lcm, numbers)", "def lcm_multiple(numbers):\n    \"\"\" Compute the LCM of a list of integers.\n    \n    This function accepts a list of integers and calculates the LCM for all of them\n    by progressively applying LCM from the two-numbers function to the whole list.\n    \n    Parameters:\n        numbers (list): A list of integers.\n    \n    Returns:\n        int: The least common multiple of all numbers in the list.\n    \n    Examples:\n        >>> lcm_multiple([12, 15, 20])\n        60\n        >>> lcm_multiple([2, 5, 8, 10])\n        40\n    \"\"\"\n    return reduce(lcm, numbers)"], ["def prime_factorization(n):\n    \"\"\" Decompose a positive integer into its prime factors.\n    Parameters:\n    n : int\n        The integer to factorize.\n    Returns:\n    dict\n        A dictionary where keys are the prime factors and values are the corresponding exponents.\n    Examples:\n    >>> prime_factorization(12)\n    {2: 2, 3: 1}\n    >>> prime_factorization(90)\n    {2: 1, 3: 2, 5: 1}\n    \"\"\"\n    factors = defaultdict(int)\n    # Check for number of 2s in n\n    while n % 2 == 0:\n        factors[2] += 1\n        n //= 2\n    # n must be odd at this point, thus a skip of 2 is possible\n    for i in range(3, int(math.sqrt(n)) + 1, 2):\n        while n % i == 0:\n            factors[i] += 1\n            n //= i\n    # This condition is to check if n is a prime number greater than 2\n    if n > 2:\n        factors[n] += 1\n    return dict(factors)", "def prime_factors(n):\n    \"\"\"\n    Produces the prime factorization of a given integer in the form of a dictionary \n    where keys are the prime factors and values are their respective exponents.\n    Parameters:\n    n (int): The number to factorize.\n    Returns:\n    dict: A dictionary with prime factors as keys and their exponents as values.\n    Examples:\n    >>> prime_factors(12)\n    {2: 2, 3: 1}   # 12 = 2^2 * 3^1\n    >>> prime_factors(28)\n    {2: 2, 7: 1}   # 28 = 2^2 * 7^1\n    \"\"\"\n    import math\n    factors = {}\n    # Check for number of 2s in n\n    while n % 2 == 0:\n        if 2 in factors:\n            factors[2] += 1\n        else:\n            factors[2] = 1\n        n = n // 2\n    # n must be odd at this point, thus check for odd factors from 3 onwards\n    for i in range(3, int(math.sqrt(n)) + 1, 2):\n        while (n % i == 0):\n            if i in factors:\n                factors[i] += 1\n            else:\n                factors[i] = 1\n            n = n // i\n    # This condition is to include the last factor\n    if n > 2:\n        factors[n] = 1\n    return factors", "def prime_factorization(n):\n    \"\"\"\n    Compute the prime factorization of a given number.\n    Parameters:\n    - n (int): The number to factorize.\n    Returns:\n    - dict: A dictionary where the keys are prime factors and values are their corresponding exponents.\n    Example:\n    >>> prime_factorization(360)\n    {2: 3, 3: 2, 5: 1}\n    \"\"\"\n    from sympy import primefactors, multiplicity\n    \n    factors = {}\n    for prime in primefactors(n):\n        factors[prime] = multiplicity(prime, n)\n    return factors"], ["def possible_values_n_from_lcm_gcd_conditions(n_conditions):\n    \"\"\" Evaluate possible integer values for n based on a series of LCM and GCD conditions.\n    \n    Parameters:\n        n_conditions (dict): Dictionary specifying the conditions with \"lcm_facts\" and \"gcd_facts\" as keys.\n                             Each key maps to a list of tuples, where each tuple in \"lcm_facts\" or \"gcd_facts\"\n                             is of the form (a, b, value) indicating LCM(a, b) == value or GCD(a, b) == value.\n    \n    Returns:\n        list: List of integers that meet all the given LCM and GCD conditions.\n    \n    Examples:\n        >>> n_conditions = {\n            \"lcm_facts\": [(6, 8, 24), (5, 7, 35)],\n            \"gcd_facts\": [(4, 10, 2)]\n        }\n        >>> possible_values_n_from_lcm_gcd_conditions(n_conditions)\n        [6, 8, 5, 7, 4, 10]  # Example output and might change depending on actual implementation logic\n    \"\"\"\n    pass"], ["def lcm_gcd_relationship(a, b):\n    \"\"\"\n    Validate the relationship between LCM and GCD of two numbers: lcm(a, b) * gcd(a, b) = |a * b|.\n    \n    Parameters:\n        a (int): The first non-zero integer.\n        b (int): The second non-zero integer.\n    \n    Returns:\n        bool: True if the relationship holds, False otherwise.\n    \n    Examples:\n        >>> lcm_gcd_relationship(21, 6)\n        True\n        >>> lcm_gcd_relationship(10, 5)\n        True\n    \"\"\"\n    gcd_val = math.gcd(a, b)\n    lcm_val = lcm_two_numbers(a, b)\n    return abs(a * b) == lcm_val * gcd_val"], ["def lcm_two_numbers(a, b):\n    \"\"\"\n    Calculate the least common multiple (LCM) for two integers.\n    \n    Parameters:\n        a (int): The first non-zero integer.\n        b (int): The second non-zero integer.\n    \n    Returns:\n        int: The LCM of the two integers.\n    \n    Examples:\n        >>> lcm_two_numbers(6, 8)\n        24\n        >>> lcm_two_numbers(7, 3)\n        21\n    \"\"\"\n    return abs(a * b) // math.gcd(a, b)", "def lcm_two_numbers(a, b):\n    \"\"\"\n    Calculate the Least Common Multiple (LCM) of two integers.\n    Parameters:\n    a (int): First number.\n    b (int): Second number.\n    Returns:\n    int: The least common multiple of a and b.\n    Examples:\n    >>> lcm_two_numbers(4, 6)\n    12\n    >>> lcm_two_numbers(15, 17)\n    255\n    \"\"\"\n    if a == 0 or b == 0:\n        return 0\n    return abs(a * b) // math.gcd(a, b)", "def lcm(a, b):\n    \"\"\" Compute the Least Common Multiple of two integers.\n    \n    Given two integers a and b, this function calculates their Least Common Multiple.\n    The function utilizes the relationship between GCD and LCM to compute the result as\n    lcm(a, b) = abs(a*b) / gcd(a, b).\n    \n    Parameters:\n        a (int): First integer.\n        b (int): Second integer.\n    \n    Returns:\n        int: Least Common Multiple of a and b.\n    \n    Examples:\n        >>> lcm(12, 15)\n        60\n        >>> lcm(3, 7)\n        21\n    \"\"\"\n    return abs(a*b) // gcd(a, b)"]]}