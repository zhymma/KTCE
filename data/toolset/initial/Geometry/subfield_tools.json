{"Circles": [["def circle_intersection_points(h1, k1, r1, h2, k2, r2):\n    \"\"\"\n    Calculates the intersection points, if any, between two circles defined by centers (h1, k1), (h2, k2) and radii r1, r2.\n    Parameters:\n        h1, k1 (float): Center of the first circle\n        r1 (float): Radius of the first circle\n        h2, k2 (float): Center of the second circle\n        r2 (float): Radius of the second circle\n    Returns:\n        list: A list containing tuples of the intersection points or a message if there are no intersections.\n    Examples:\n    >>> circle_intersection_points(0, 0, 5, 10, 0, 5)\n    'No intersection - circles are separate.'\n    >>> circle_intersection_points(0, 0, 5, 4, 0, 4)\n    [(1.0, 0.0), (7.0, 0.0)]\n    \"\"\"\n    x, y = symbols('x y')\n    eq1 = Eq((x-h1)**2 + (y-k1)**2, r1**2)\n    eq2 = Eq((x-h2)**2 + (y-k2)**2, r2**2)\n    result = solve((eq1, eq2), (x, y))\n    if not result:\n        return 'No intersection - circles may be separate or coincident without intersection points.'\n    else:", "def circle_intersection_points(center1, radius1, center2, radius2):\n    \"\"\"\n    Calculate the intersection points of two circles.\n    \n    Parameters:\n    - center1 (tuple): The (x, y) coordinates of the first circle's center.\n    - radius1 (float): The radius of the first circle.\n    - center2 (tuple): The (x, y) coordinates of the second circle's center.\n    - radius2 (float): The radius of the second circle.\n    \n    Returns:\n    - list: A list containing the (x, y) coordinates of the intersection points; might be empty.\n    \"\"\"\n    x, y = symbols('x y', real=True)\n    eq1 = Eq((x - center1[0])**2 + (y - center1[1])**2, radius1**2)\n    eq2 = Eq((x - center2[0])**2 + (y - center2[1])**2, radius2**2)\n    result = solve((eq1, eq2), (x, y))\n    return [tuple(map(float, res)) for res in result]", "def intersection_of_circles(center1, radius1, center2, radius2):\n    \"\"\"\n    Find the intersection points of two circles.\n    Parameters:\n        center1 (tuple): (x, y) coordinates of the first circle's center.\n        radius1 (float): Radius of the first circle.\n        center2 (tuple): (x, y) coordinates of the second circle's center.\n        radius2 (float): Radius of the second circle.\n    Returns:\n        list: A list containing the intersection points (tuples) or an empty list if no intersection.\n    \"\"\"\n    x1, y1 = center1\n    x2, y2 = center2\n    d = math.hypot(x2 - x1, y2 - y1)\n    \n    if d > radius1 + radius2 or d < abs(radius1 - radius2) or d == 0:\n        return []  # no intersection or one circle is within the other\n    a = (radius1**2 - radius2**2 + d**2) / (2 * d)\n    h = math.sqrt(radius1**2 - a**2)\n    x0 = x1 + a * (x2 - x1) / d\n    y0 = y1 + a * (y2 - y1) / d\n    intersection1 = (x0 + h * (y2 - y1) / d, y0 - h * (x2 - x1) / d)\n    intersection2 = (x0 - h * (y2 - y1) / d, y0 + h * (x2 - x1) / d)\n    \n    return [intersection1, intersection2]"], ["def circle_area(radius):\n    \"\"\"Calculate the area of a circle given the radius.\n    \n    Parameters:\n        radius (float): The radius of the circle.\n    \n    Returns:\n        float: The area of the circle.\n        \n    Example:\n        >>> circle_area(5)\n        78.53981633974483\n    \"\"\"\n    return math.pi * (radius ** 2)", "def circle_area(radius):\n    \"\"\" Calculates the area of a circle given its radius.\n    \n    Parameters:\n        radius (float): The radius of the circle.\n    Returns:\n        float: The area of the circle.\n    \"\"\"\n    return np.pi * np.square(radius)", "def circle_area(radius):\n    \"\"\"\n    Calculate the area of a circle given the radius.\n    \n    Parameters:\n    - radius (float): The radius of the circle.\n    \n    Returns:\n    - float: The area of the circle.\n    \"\"\"\n    return np.pi * radius ** 2"], ["def circle_circumference(radius):\n    \"\"\"Calculate the circumference of a circle given the radius.\n    \n    Parameters:\n        radius (float): The radius of the circle.\n        \n    Returns:\n        float: The circumference of the circle.\n    \n    Example:\n        >>> circle_circumference(5)\n        31.41592653589793\n    \"\"\"\n    return 2 * math.pi * radius", "def radius_from_circumference(circumference):\n    \"\"\"Calculate the radius of a circle from a given circumference.\n    \n    Parameters:\n        circumference (float): The circumference of the circle.\n        \n    Returns:\n        float: The radius of the circle.\n    \n    Example:\n        >>> radius_from_circumference(31.4)\n        5.0\n    \"\"\"\n    return circumference / (2 * math.pi)", "def circle_circumference(radius):\n    \"\"\" Calculates the circumference of a circle given its radius.\n    \n    Parameters:\n        radius (float): The radius of the circle.\n    Returns:\n        float: The circumference of the circle.\n    \"\"\"\n    return 2 * np.pi * radius", "def circle_circumference(radius):\n    \"\"\"\n    Calculate the circumference of a circle given the radius.\n    \n    Parameters:\n    - radius (float): The radius of the circle.\n    \n    Returns:\n    - float: The circumference of the circle.\n    \"\"\"\n    return 2 * np.pi * radius"], ["def compute_triangle_properties(vertices):\n    \"\"\"\n    Compute properties of a triangle given its vertices.\n    Parameters:\n        vertices (array): An array of three tuples, each representing x, y coordinates of a vertex.\n    Returns:\n        dict: Properties including area, perimeter, side lengths, and types of triangle (isosceles, equilateral).\n    \"\"\"\n    vertices = np.array(vertices)\n    side_lengths = np.linalg.norm(vertices - np.roll(vertices, -1, axis=0), axis=1)\n    s = np.sum(side_lengths) / 2  # semi-perimeter\n    area = np.sqrt(s * np.prod(s - side_lengths))  # Heron's formula\n    is_iso = np.any(side_lengths[0] == side_lengths[1]) or np.any(side_lengths[1] == side_lengths[2])\n    is_equi = np.all(side_lengths[0] == side_lengths[1])\n    properties = {\n        'Area': area,\n        'Perimeter': 2 * s,\n        'Side Lengths': side_lengths,\n        'Isosceles': is_iso,\n        'Equilateral': is_equi\n    }\n    return properties"], ["def are_circles_tangent(center1, radius1, center2, radius2):\n    \"\"\"\n    Determine if two circles are tangent to each other.\n    \n    Parameters:\n    - center1 (tuple): The (x, y) coordinates of the first circle's center.\n    - radius1 (float): The radius of the first circle.\n    - center2 (tuple): The (x, y)"], ["def circle_properties(radius, chord_length=None, angle_radians=None):\n    \"\"\"\n    Calculate properties of a circle given its radius with optional chord length and angle for intersected arc.\n    \n    Parameters:\n        radius (float): Radius of the circle.\n        chord_length (float, optional): Length of the chord within the circle.\n        angle_radians (float, optional): Angle subtended by the chord at the center of the circle in radians.\n    Returns:\n        dict: Properties including area, circumference, chord properties, and arc relationships.\n    \"\"\"\n    area = math.pi * radius**2\n    circumference = 2 * math.pi * radius\n    properties = {\n        'Area': area,\n        'Circumference': circumference\n    }\n    if chord_length is not None:\n        # Using the law of cosines to find the angle if not provided.\n        if angle_radians is None:\n            angle_radians = 2 * math.acos(chord_length / (2 * radius))\n        sagitta = radius * (1 - math.cos(angle_radians / 2))\n        arc_length = radius * angle_radians\n        segment_area = (radius**2 / 2) * (angle_radians - math.sin(angle_radians))\n        \n        properties.update({\n            'Chord Length': chord_length,\n            'Sagitta': sagitta,\n            'Arc Length': arc_length,\n            'Segment Area': segment_area\n        })\n    return properties"], ["def circle_standard_form(equation: str) -> Tuple[str, Tuple[float, float], float]:\n    \"\"\"\n    Convert a general form of a circle equation into standard form and extract\n    the center and radius of the circle.\n    Parameters:\n        equation (str): The equation of the circle in general form 'x^2 + y^2 + Dx + Ey + F = 0'.\n    Returns:\n        Tuple[str, Tuple[float, float], float]:\n            - Standard form of the equation.\n            - Center of the circle as a tuple (h, k).\n            - Radius of the circle.\n    \n    Example:\n        >>> circle_standard_form('x**2 + y**2 + 4*x - 6*y + 9 = 0')\n        ('(x - -2.0)^2 + (y - 3.0)^2 = 4.0', (-2.0, 3.0), 2.0)\n    \"\"\"\n    x, y = sp.symbols('x y')\n    # Parse the input equation\n    eq = sp.sympify(equation)\n    # Rearrange equation in x, y terms\n    eq = sp.Eq(eq, 0)\n    # Complete the square for both x and y\n    eq_circle = sp.simplify(eq.lhs).expand()\n    # Coefficients of x^2 and y^2 are assumed to be 1 for the equation of a circle\n    x_coeff = eq_circle.coeff(x, 2)\n    y_coeff = eq_circle.coeff(y, 2)\n    if x_coeff != 1 or y_coeff != 1:\n        raise ValueError(\"Invalid equation for a circle provided.\")\n    # Completing the square\n    xc = eq_circle.coeff(x, 1) / 2\n    yc = eq_circle.coeff(y, 1) / 2\n    center = (-xc, -yc)\n    constant_term = eq_circle.subs({x: 0, y: 0})\n    \n    # Calculate the squared radius\n    radius_squared = xc**2 + yc**2 - constant_term\n    if radius_squared < 0:\n        raise ValueError(\"The given equation does not represent a real circle.\")\n    radius = sp.sqrt(radius_squared)\n    \n    standard_form = f\"(x - {center[0]})^2 + (y - {center[1]})^2 = {radius_squared}\"\n    return (standard_form, center, radius.evalf())"], ["def point_inside_circle(center, radius, point):\n    \"\"\"\n    Determine if a point is inside a given circle.\n    \n    Parameters:\n    - center (tuple): The (x, y) coordinates of the circle's center.\n    - radius (float): The radius of the circle.\n    - point (tuple): The (x, y) coordinates of the point to check.\n    \n    Returns:\n    - bool: True if the point is inside the circle, False otherwise.\n    \"\"\"\n    return np.sqrt((point[0] - center[0])**2 + (point[1] - center[1])**2) <= radius"], ["def circle_properties(radius: float, angle: Union[float, None] = None, total_angle: float = 360.0) -> dict:\n    \"\"\"\n    Calculate various properties of a circle such as area, circumference, sector area, and arc length.\n    If an angle is specified, the function will additionally calculate the sector area and arc length for the given sector.\n    Parameters:\n        radius (float): The radius of the circle.\n        angle (float, optional): The central angle of the sector in degrees. Default is None, meaning no sector calculations.\n        total_angle (float): The total angle of the circle in degrees, usually 360 degrees.\n    Returns:\n        dict: A dictionary containing the area and circumference of the whole circle.\n              If an angle is provided, it will also contain the sector area and arc length.\n    Examples:\n        >>> circle_properties(5)\n        {'area': 78.53981633974483, 'circumference': 31.41592653589793}\n        >>> circle_properties(5, 90)\n        {'area': 78.53981633974483, 'circumference': 31.41592653589793, 'sector_area': 19.634954084936208, 'arc_length': 7.853981633974483}\n    \"\"\"\n    area = math.pi * radius ** 2\n    circumference = 2 * math.pi * radius\n    properties = {'area': area, 'circumference': circumference}\n    \n    if angle is not None:\n        sector_area = area * (angle / total_angle)\n        arc_length = circumference * (angle / total_angle)\n        properties.update({'sector_area': sector_area, 'arc_length': arc_length})\n    \n    return properties"], ["def tangency_point_line_to_circle(circle_center, circle_radius, point):\n    \"\"\" Computes the tangent from an external point to a circle.\n    \n    Parameters:\n        circle_center (tuple): The center of the circle (x0, y0)\n        circle_radius (float): The radius of the circle.\n        point (tuple): Coordinates of the external point (x1, y1)\n    \n    Returns:\n        tuple: Coordinates of the tangency point (xt, yt)\n    \"\"\"\n    x, y = symbols('x y', real=True)\n    x0, y0 = circle_center\n    x1, y1 = point\n    tangent_eq = Eq((x - x1)**2 + (y - y1)**2, ((x - x0)**2 + (y - y0)**2) - circle_radius**2)\n    solutions = solve(tangent_eq, (x, y))\n    # Returning only the first solution assuming the conditions are correct\n    return solutions[0]"], ["def circle_properties_from_equation(h, k, r_squared):\n    \"\"\"\n    Given the parameters h, k (center of the circle) and r_squared (radius squared),\n    returns the center, radius, area, and circumference of the circle.\n    \n    Parameters:\n        h (float): x-coordinate of the center of the circle\n        k (float): y-coordinate of the center of the circle\n        r_squared (float): square of the radius of the circle\n    Returns:\n        dict: Dictionary containing the center, radius, area, and circumference\n    \n    Examples:\n    >>> circle_properties_from_equation(0, 0, 25)\n    {'center': (0, 0), 'radius': 5.0, 'area': 78.5398, 'circumference': 31.4159}\n    \"\"\"\n    r = sqrt(r_squared)\n    area = pi * r**2\n    circumference = 2 * pi * r\n    return {\n        'center': (h, k),\n        'radius': r.evalf(),\n        'area': area.evalf(),\n        'circumference': circumference.evalf()\n    }"], ["def circle_intersection(eq1, eq2):\n    \"\"\"Find the points of intersection of two circles, if any.\n    \n    Parameters:\n        eq1, eq2 (sympy.Eq): Equations of the two circles.\n        \n    Returns:\n        list: Points of intersection, possibly empty.\n    \n    Example:\n        >>> eq1 = circle_standard_form(0, 0, 5)\n        >>> eq2 = circle_standard_form(2, 2, 5)\n        >>> circle_intersection(eq1, eq2)\n        [(3.0, -1.0), (1.0, 1.0)]\n    \"\"\"\n    x, y = sympy.symbols('x y')\n    return sympy.linsolve([eq1, eq2], x, y)"], ["def find_circle_properties_from_eq(eq):\n    \"\"\"Extract the center coordinates and the radius from the circle equation.\n    \n    Parameters:\n        eq (sympy.Eq): The equation of the circle.\n        \n    Returns:\n        tuple: Center coordinates (h, k) and radius r.\n    \n    Example:\n        >>> eq = circle_standard_form(0, 0, 5)\n        >>> find_circle_properties_from_eq(eq)\n        ((0, 0), 5)\n    \"\"\"\n    # Solution assumes eq is already in standard form (x-h)**2 + (y-k)**2 = r**2.\n    # Parsing it to extract the center and the radius.\n    x, y = sympy.symbols('x y')\n    lhs = eq.lhs - eq.rhs\n    center = sympy.solve([sympy.Eq(lhs.coeff(x, 2), 1), sympy.Eq(lhs.coeff(y, 2), 1)], x, y)\n    radius = sympy.sqrt(eq.rhs) if eq.rhs >= 0 else None \n    return (center[x], center[y]), sympy.re(radius)"], ["def find_circle_line_intersection(circle_center, circle_radius, line_coefficients):\n    \"\"\" Finds intersection points of a circle and a line.\n    \n    Parameters:\n        circle_center (tuple): A tuple (x0, y0) representing the center of the circle.\n        circle_radius (float): The radius of the circle.\n        line_coefficients (tuple): Coefficients (a, b, c) of the line ax + by + c = 0.\n    Returns:\n        list: A list of tuples representing the intersection points.\n    \"\"\"\n    x, y = symbols('x y')\n    x0, y0 = circle_center\n    a, b, c = line_coefficients\n    circle_eq = Eq((x - x0)**2 + (y - y0)**2, circle_radius**2)\n    line_eq = Eq(a*x + b*y + c, 0)\n    return solve((circle_eq, line_eq), (x, y))"], ["def circle_standard_form(h, k, r):\n    \"\"\"Create the standard form equation of a circle (x-h)^2 + (y-k)^2 = r^2.\n    \n    Parameters:\n        h (float): The x-coordinate of the circle's center.\n        k (float): The y-coordinate of the circle's center.\n        r (float): The radius of the circle.\n        \n    Returns:\n        sympy.Eq: The equation of the circle in sympy equation format.\n        \n    Example:\n        >>> print(circle_standard_form(0, 0, 5))\n        Eq(x**2 + y**2, 25)\n    \"\"\"\n    x, y = sympy.symbols('x y')\n    return sympy.Eq((x - h)**2 + (y - k)**2, r**2)"], ["def convert_general_to_standard_form(A, B, C, D, E, F):\n    \"\"\"\n    Converts a general circle equation of the form Ax^2 + By^2 + Cx + Dy + E = F\n    to its standard form (x-h)^2 + (y-k)^2 = r^2 and returns the coefficients h, k, and r_squared.\n    Parameters:\n        A, B, C, D, E, F (float): Coefficients of the general form of the circle equation\n    Returns:\n        tuple: A tuple containing h, k, and r_squared\n    Examples:\n    >>> convert_general_to_standard_form(1, 1, -4, -6, 8, 0)\n    (2.0, 3.0, 9.0)\n    \"\"\"\n    assert A == B == 1, \"The coefficients of x^2 and y^2 must both be 1 for a standard circle equation\"\n    h = -C / (2 * A)\n    k = -D / (2 * B)\n    r_squared = (C**2 + D**2) / (4 * A * B) - E + F\n    return (h, k, r_squared)"], ["def radius_from_area(area):\n    \"\"\"Calculate the radius of a circle from a given area.\n    \n    Parameters:\n        area (float): The area of the circle.\n        \n    Returns:\n        float: The radius of the circle.\n    \n    Example:\n        >>> radius_from_area(78.5)\n        5.0\n    \"\"\"\n    return math.sqrt(area / math.pi)"], ["def circle_equation(center, radius):\n    \"\"\" Generates the general form equation of a circle given its center and radius.\n    Parameters:\n        center (tuple): A tuple (x, y) representing the center of the circle.\n        radius (float): The radius of the circle.\n    Returns:\n        str: The equation of the circle in the form '(x - h)^2 + (y - k)^2 = r^2'.\n    \"\"\"\n    h, k = center\n    r_squared = np.square(radius)\n    return f\"(x - {h})^2 + (y - {k})^2 = {r_squared}\""]], "Coordinate Geometry": [["def line_parametric_form(p1, p2):\n    \"\"\"\n    Obtain the parametric form of a line given two points in 3D.\n    \n    Parameters:\n        p1, p2 (np.array): Two points in 3D space through which the line passes.\n    \n    Returns: \n        tuple of np.array: (point_on_line, direction_vector)\n    \n    Example:\n        >>> line_parametric_form(np.array([1, 2, 3]), np.array([4, 5, 6]))\n        (array([1, 2, 3]), array([3, 3, 3]))\n    \"\"\"\n    direction_vector = vector_subtract(p2, p1)\n    return (p1, direction_vector)", "def line_parametric_form(p1, direction):\n    \"\"\"\n    Represents a line in the parametric form p(t) = p1 + t * direction.\n    Parameters:\n    p1 (ndarray): A point on the line represented as a numpy array.\n    direction (ndarray): The direction vector of the line.\n    Returns:\n    func: A function that returns point on the line for a given parameter t.\n    \"\"\"\n    def line(t):\n        return vector_add(p1, scalar_multiply(direction, t))\n    return line"], ["def line_equation(point1, point2):\n    \"\"\"\n    Derives the equation of the line in slope-intercept form y = mx + b passing through two points.\n    \n    Parameters:\n        point1 (tuple): The (x, y) coordinates of the first point.\n        point2 (tuple): The (x, y) coordinates of the second point.\n    \n    Returns:\n        tuple: A tuple (m, b) representing the slope and the y-intercept of the line.\n    \n    Examples:\n        >>> line_equation((0, 0), (1, 2))\n        (2.0, 0.0)\n    \"\"\"\n    m = slope(point1, point2)\n    x1, y1 = point1\n    b = y1 - m * x1\n    return (m, b)", "def find_line_equation(point1, point2):\n    \"\"\"Finds the equation of the line passing through two points.\n    Parameters:\n        point1 (tuple): Tuple of (x, y) coordinates for the first point.\n        point2 (tuple): Tuple of (x, y) coordinates for the second point.\n    Returns:\n        sympy.Eq: Equation of the line in 'y = mx + c' format.\n    Examples:\n        >>> find_line_equation((1, 2), (3, 8))\n        Eq(y, 3*x - 1)\n    \"\"\"\n    x, y = symbols('x y')\n    x1, y1 = point1\n    x2, y2 = point2\n    m = (y2 - y1) / (x2 - x1)\n    c = y1 - m * x1\n    return Eq(y, m * x + c)", "def line_equation(point1, point2):\n    \"\"\"\n    Formulate the equation of a line given two points in 'y = mx + b' format, where m is the slope and b is the y-intercept.\n    \n    Parameters:\n        point1 (tuple): A tuple (x1, y1) representing the coordinates of the first point.\n        point2 (tuple): A tuple (x2, y2) representing the coordinates of the second point.\n    \n    Returns:\n        tuple: A tuple containing the slope (m) and the y-intercept (b) of the line.\n    \n    Examples:\n        >>> line_equation((1, 2), (3, 6))\n        (2.0, 0.0)\n        >>> line_equation((2, 3), (2, 5))\n        None  # Line is vertical\n    \"\"\"\n    slope = calculate_slope(point1, point2)\n    if slope is None:\n        return None\n    else:\n        x1, y1 = point1\n        intercept = y1 - slope * x1\n        return (slope, intercept)", "def line_from_two_points(point1, point2):\n    \"\"\"\n    Finds the equation of a line passing through two points in the form (m, c).\n    Parameters\n    ----------\n    point1 : tuple\n        Coordinates of the first point (x1, y1).\n    point2 : tuple\n        Coordinates of the second point (x2, y2).\n    \n    Returns\n    -------\n    tuple\n        Coefficients (m, c) of the line equation y = mx + c.\n    \n    Examples\n    --------\n    >>> line_from_two_points((0, 0), (1, 1))\n    (1.0, 0.0)\n    \"\"\"\n    m = find_slope(point1, point2)\n    c = point1[1] - m * point1[0]\n    return (m, c)", "def line_from_points(point1, point2):\n    \"\"\"\n    Generates the equation of a line in 2D space given two points.\n    Parameters\n    ----------\n    point1 : array_like\n        Coordinates (x1, y1) of the first point.\n    point2 : array_like\n        Coordinates (x2, y2) of the second point.\n    Returns\n    -------\n    tuple\n        Coefficients (A, B, C) of the line equation Ax + By + C = 0.\n    Examples\n    --------\n    >>> line_from_points([1, 1], [4, 5])\n    (-4, 3, -1)\n    \"\"\"\n    x1, y1 = point1\n    x2, y2 = point2\n    A = y2 - y1\n    B = x1 - x2\n    C = x2 * y1 - x1 * y2\n    return (A, B, C)", "def line_equation_from_points(p1, p2):\n    \"\"\"\n    Generate the equation of a line from two points in a Cartesian plane.\n    \n    Parameters:\n        p1 (tuple): The (x, y) coordinates of the first point on the line.\n        p2 (tuple): The (x, y) coordinates of the second point on the line.\n    \n    Returns:\n        sympy.Eq: The equation of the line in symbolic form (y = mx + c).\n    \n    Examples:\n    >>> line_equation_from_points((1, 2), (3, 8))\n    Eq(y, 3*x - 1)\n    \"\"\"\n    x, y = sp.symbols('x y')\n    x1, y1 = p1\n    x2, y2 = p2\n    slope = (y2 - y1) / (x2 - x1)\n    intercept = y1 - slope * x1\n    return sp.Eq(y, slope * x + intercept)", "def line_equation(point1, point2):\n    \"\"\"\n    Compute the equation of a line given two points.\n    Parameters:\n    - point1 (tuple): Coordinates of the first point (x1, y1).\n    - point2 (tuple): Coordinates of the second point (x2, y2).\n    Returns:\n    - sympy.Eq: The equation of the line.\n    Example:\n    >>> str(line_equation((1, 2), (3, 8)))\n    'y - 8 = 3*(x - 3)'\n    \"\"\"\n    x1, y1 = point1\n    x2, y2 = point2\n    x, y = sp.symbols('x y')\n    slope = slope_of_line(point1, point2)\n    return sp.Eq(y - y2, slope * (x - x2))"], ["def line_intersection_plane(point_line, direction_vector, plane_coefficients):\n    \"\"\"\n    Find the intersection of a line and a plane in 3D.\n    \n    Parameters:\n    - point_line (array-like): A point on the line.\n    - direction_vector (array-like): Direction vector of the line.\n    - plane_coefficients (tuple): Coefficients (A, B, C, D) of the plane Ax + By + Cz + D = 0.\n    \n    Returns:\n    - numpy.ndarray or None: The intersection point, or None if no intersection or the line lies in the plane.\n    \n    Example:\n    >>> line_intersection_plane([1, 1, 1], [1, 1, 1], (1, -1, 0, 0))\n    array([0.5, 0.5, 1. ])\n    \"\"\"\n    A, B, C, D = plane_coefficients\n    x0, y0, z0 = point_line\n    dx, dy, dz = direction_vector\n    denominator = A*dx + B*dy + C*dz\n    if denominator == 0:\n        return None  # Line and plane are parallel (either no intersection or the line is in the plane)\n    t = -(A*x0 + B*y0 + C*z0 + D) / denominator\n    return np.array([x0 + t*dx, y0 + t*dy, z0 + t*dz])", "def line_plane_intersection(line_point, line_dir, plane_normal, plane_point):\n    \"\"\"\n    Determines the intersection point of a line and a plane, if it exists.\n    Parameters:\n    line_point (ndarray): A point on the line.\n    line_dir (ndarray): The direction vector of the line.\n    plane_normal (ndarray): The normal vector of the plane.\n    plane_point (ndarray): A point on the plane.\n    Returns:\n    ndarray or None: The intersection point if it exists, otherwise None.\n    \"\"\"\n    num = dot_product(vector_subtract(plane_point, line_point), plane_normal)\n    den = dot_product(line_dir, plane_normal)\n    if den == 0:\n        return None  # Line and plane are parallel\n    t = num / den\n    return line_parametric_form(line_point, line_dir)(t)"], ["def slope(point1, point2):\n    \"\"\"\n    Calculates the slope of the line passing through two points.\n    \n    Parameters:\n        point1 (tuple): The (x, y) coordinates of the first point.\n        point2 (tuple): The (x, y) coordinates of the second point.\n    \n    Returns:\n        float: The slope of the line.\n        \n    Examples:\n        >>> slope((0, 0), (1, 2))\n        2.0\n    \"\"\"\n    x1, y1 = point1\n    x2, y2 = point2\n    if x1 == x2:\n        raise ValueError(\"Slope is undefined for vertical lines\")\n    return (y2 - y1) / (x2 - x1)", "def calculate_slope(point1, point2):\n    \"\"\"\n    Calculate the slope of the line joining two points.\n    \n    Parameters:\n    - point1 (tuple): The first point (x1, y1).\n    - point2 (tuple): The second point (x2, y2).\n    \n    Returns:\n    - float: The slope of the line.\n    \n    Raises:\n    - ValueError: If the line is vertical (undifined slope).\n    \n    Examples:\n    >>> calculate_slope((1,2), (3,8))\n    3.0\n    \"\"\"\n    x1, y1 = point1\n    x2, y2 = point2\n    if x2 - x1 == 0:\n        raise ValueError(\"Undefined slope (vertical line)\")\n    return (y2 - y1) / (x2 - x1)", "def slope(point1, point2):\n    \"\"\"Calculate the slope between two points in 2-dimensional space.\n    Parameters:\n        point1 (array-like): The first point [x1, y1].\n        point2 (array-like): The second point [x2, y2].\n    Returns:\n        float: The slope of the line connecting the two points.\n    Examples:\n        >>> slope([1, 2], [3, 6])\n        2.0\n    \"\"\"\n    x1, y1 = point1\n    x2, y2 = point2\n    if x2 - x1 == 0:\n        raise ValueError(\"Slope is undefined (dividing by zero).\")\n    return (y2 - y1) / (x2 - x1)", "def calculate_slope(point1, point2):\n    \"\"\"\n    Determine the slope of the line connecting two points.\n    \n    Parameters:\n        point1 (tuple): A tuple (x1, y1) representing the coordinates of the first point.\n        point2 (tuple): A tuple (x2, y2) representing the coordinates of the second point.\n    \n    Returns:\n        float: The slope of the line. Returns 'None' if the line is vertical.\n    \n    Examples:\n        >>> calculate_slope((1, 2), (3, 6))\n        2.0\n        >>> calculate_slope((2, 3), (2, 5))\n        'None'  # Line is vertical\n    \"\"\"\n    x1, y1 = point1\n    x2, y2 = point2\n    if x2 == x1:\n        return None\n    else:\n        return (y2 - y1) / (x2 - x1)", "def find_slope(point1, point2):\n    \"\"\"\n    Calculates the slope of a line passing through two points.\n    Parameters\n    ----------\n    point1 : tuple\n        Coordinates of the first point (x1, y1).\n    point2 : tuple\n        Coordinates of the second point (x2, y2).\n    \n    Returns\n    -------\n    float\n        The slope of the line.\n    \n    Examples\n    --------\n    >>> find_slope((1, 2), (3, 4))\n    1.0\n    \"\"\"\n    x1, y1 = point1\n    x2, y2 = point2\n    return (y2 - y1) / (x2 - x1)", "def slope(point1, point2):\n    \"\"\"\n    Calculate the slope of the line connecting two points. Returns None if the line is vertical.\n    Parameters:\n        point1 (tuple): The (x, y) coordinates of the first point.\n        point2 (tuple): The (x, y) coordinates of the second point.\n    Returns:\n        float or None: The slope of the line, or None if the line is vertical.\n    \n    Examples:\n        >>> slope((1, 2), (3, 6))\n        2.0\n        >>> slope((1, 2), (1, 5))\n        None  # Vertical line\n    \"\"\"\n    if point1[0] == point2[0]:\n        return None\n    else:\n        return (point2[1] - point1[1]) / (point2[0] - point1[0])", "def slope_of_line(p1, p2):\n    \"\"\"\n    Computes the slope of the line segment connecting two points. Raises exception if the line is vertical.\n    Parameters:\n    - p1: Tuple of coordinates (x1, y1)\n    - p2: Tuple of coordinates (x2, y2)\n    Returns:\n    - float: Slope of the line.\n    Example:\n    >>> slope_of_line((1, 2), (3, 6))\n    2.0\n    \"\"\"\n    x1, y1 = p1\n    x2, y2 = p2\n    if x2 == x1:\n        raise ValueError(\"Vertical line segment has no slope.\")\n    return (y2 - y1) / (x2 - x1)", "def slope(x1, y1, x2, y2):\n    \"\"\"\n    Calculate the slope of the line passing through two points (x1, y1) and (x2, y2).\n    \n    Parameters:\n        x1 (float): x-coordinate of the first point.\n        y1 (float): y-coordinate of the first point.\n        x2 (float): x-coordinate of the second point.\n        y2 (float): y-coordinate of the second point.\n        \n    Returns:\n        float: The slope of the line. Returns None if the line is vertical.\n    \"\"\"\n    if x2 - x1 == 0:\n        return None  # Vertical line\n    return (y2 - y1) / (x2 - x1)", "def slope_of_line(point1, point2):\n    \"\"\"\n    Determine the slope of a line connecting two points.\n    Parameters:\n    - point1 (tuple): Coordinates of the first point (x1, y1).\n    - point2 (tuple): Coordinates of the second point (x2, y2).\n    Returns:\n    - float: The slope of the line.\n    Example:\n    >>> slope_of_line((1, 2), (3, 8))\n    3.0\n    \"\"\"\n    x1, y1 = point1\n    x2, y2 = point2\n    if x2 - x1 == 0:\n        raise ValueError(\"The line is vertical; slope is undefined.\")\n    return (y2 - y1) / (x2 - x1)"], ["def find_intersection(line1, line2):\n    \"\"\"\n    Find the intersection point of two lines given their slopes and intercepts.\n    \n    Parameters:\n    - line1 (tuple): Slope and intercept (m1, c1) of the first line.\n    - line2 (tuple): Slope and intercept (m2, c2) of the second line.\n    \n    Returns:\n    - tuple: Coordinates (x, y) of the intersection point.\n    \n    Raises:\n    - ValueError: If lines are parallel (no intersection).\n    \n    Examples:\n    >>> find_intersection((3, 2), (-1, 4))\n    (0.5, 3.5)\n    \"\"\"\n    m1, c1 = line1\n    m2, c2 = line2\n    if m1 == m2:\n        raise ValueError(\"Lines are parallel\")\n    x = (c2 - c1) / (m1 - m2)\n    y = m1 * x + c1\n    return (x, y)", "def line_intersection(eq1, eq2):\n    \"\"\"Finds the intersection point of two line equations.\n    Parameters:\n        eq1 (sympy.Eq): First line equation.\n        eq2 (sympy.Eq): Second line equation.\n    Returns:\n        tuple: Coordinates of the intersection point.\n    Examples:\n        >>> eq1 = find_line_equation((1, 2), (3, 8))\n        >>> eq2 = find_line_equation((1, 5), (2, 2))\n        >>> line_intersection(eq1, eq2)\n        {x: 5/7, y: 16/7}\n    \"\"\"\n    x, y = symbols('x y')\n    return solve((eq1, eq2), (x, y))", "def line_intersection(line1, line2):\n    \"\"\"\n    Finds the intersection point of two lines.\n    Parameters\n    ----------\n    line1 : tuple\n        Coefficients (m1, c1) of the first line equation y = m1x + c1.\n    line2 : tuple\n        Coefficients (m2, c2) of the second line equation y = m2x + c2.\n    \n    Returns\n    -------\n    tuple\n        Coordinates (x, y) of the intersection point.\n    \n    Examples\n    --------\n    >>> line_intersection((1, 2), (-1, 0))\n    (1.0, 3.0)\n    \"\"\"\n    m1, c1 = line1\n    m2, c2 = line2\n    x = (c2 - c1) / (m1 - m2)\n    y = m1 * x + c1\n    return (x, y)", "def intersection_of_lines(line1, line2):\n    \"\"\"\n    Find the intersection point of two lines given their equations.\n    \n    Parameters:\n        line1 (sympy.Eq): The equation of the first line.\n        line2 (sympy.Eq): The equation of the second line.\n        \n    Returns:\n        tuple: the (x, y) coordinates of the intersection point or None if lines are parallel.\n    \n    Examples:\n    >>> line1 = sp.Eq(y, 2*x + 3)\n    >>> line2 = sp.Eq(y, -0.5*x + 7)\n    >>> intersection_of_lines(line1, line2)\n    (1.6, 6.2)\n    \"\"\"\n    x, y = sp.symbols('x y')", "def intersection(line1, line2):\n    \"\"\"\n    Find the intersection point of two lines if they are not parallel or coincident.\n    \n    Parameters:\n        line1 (sympy.Eq): Symbolic equation of the first line.\n        line2 (sympy.Eq): Symbolic equation of the second line.\n        \n    Returns:\n        tuple or None: Coordinates of intersection point (x, y) or None if no intersection.\n    \"\"\"\n    x, y = sp.symbols('x y')\n    sol = sp.solve((line1, line2), (x, y))\n    return sol if sol else None", "def intersection_of_lines(eq1, eq2):\n    \"\"\"\n    Finds the intersection points of two line equations.\n    Parameters:\n    - eq1 (sympy.Eq): Equation of the first line.\n    - eq2 (sympy.Eq): Equation of the second line.\n    Returns:\n    - tuple: Coordinates of the intersection point or None if no intersection.\n    Example:\n    >>> str(intersection_of_lines(sp.Eq(y - 2, 3*(x - 1)), sp.Eq(y + 2, -1*(x + 2))))\n    '(1, 5)'\n    \"\"\"\n    x, y = sp.symbols('x y')\n    sol = sp.solve((eq1, eq2), (x, y))\n    return sol[x], sol[y] if sol else None"], ["def cartesian_to_polar(x, y):\n    \"\"\"\n    Converts Cartesian coordinates to Polar coordinates.\n    Parameters:\n    x (float): x-coordinate\n    y (float): y-coordinate\n    Returns:\n    tuple: (radius r, angle theta in radians)\n    \"\"\"\n    r = np.sqrt(x**2 + y**2)\n    theta = np.arctan2(y, x)  # arctan2 automatically adjusts based on the quadrant\n    return r, theta", "def polar_to_cartesian(r, theta):\n    \"\"\"\n    Converts Polar coordinates to Cartesian coordinates.\n    \n    Parameters:\n    r (float): radius\n    theta (float): angle in radians\n    \n    Returns:\n    tuple: (x-coordinate, y-coordinate)\n    \"\"\"\n    x = r * np.cos(theta)\n    y = r * np.sin(theta)\n    return x, y", "def cartesian_to_cylindrical(x, y, z):\n    \"\"\"\n    Converts Cartesian coordinates to Cylindrical coordinates.\n    \n    Parameters:\n    x (float): x-coordinate\n    y (float): y-coordinate\n    z (float): z-coordinate\n    \n    Returns:\n    tuple: (radial coordinate r, angular coordinate theta in radians, height z)\n    \"\"\"\n    r, theta = cartesian_to_polar(x, y)\n    return r, theta, z", "def cylindrical_to_cartesian(r, theta, z):\n    \"\"\"\n    Converts Cylindrical coordinates to Cartesian coordinates.\n    \n    Parameters:\n    r (float): radial coordinate\n    theta (float): angular coordinate in radians\n    z (float): height\n    \n    Returns:\n    tuple: (x-coordinate, y-coordinate, z-coordinate)\n    \"\"\"\n    x, y = polar_to_cartesian(r, theta)\n    return x, y, z", "def rectangular_to_polar(x, y):\n    \"\"\"\n    Converts rectangular (Cartesian) coordinates to polar coordinates.\n    \n    Parameters:\n    x (float): The x-coordinate.\n    y (float): The y-coordinate.\n    Returns:\n    tuple: A tuple (r, theta) where:\n        r (float) : The radial distance.\n        theta (float): The angle in radians.\n    \n    Examples:\n    >>> rectangular_to_polar(1, 1)\n    (1.4142135623730951, 0.7853981633974483)\n    \"\"\"\n    r = np.sqrt(x**2 + y**2)\n    theta = np.arctan2(y, x)\n    return r, theta", "def polar_to_rectangular(r, theta):\n    \"\"\"\n    Converts polar coordinates to rectangular (Cartesian) coordinates.\n    \n    Parameters:\n    r (float): The radial distance.\n    theta (float): The angle in radians.\n    Returns:\n    tuple: A tuple (x, y) where:\n        x (float): The x-coordinate.\n        y (float): The y-coordinate.\n    Examples:\n    >>> polar_to_rectangular(1.414, np.pi/4)\n    (0.9992893641726139, 0.9992893641705094)\n    \"\"\"\n    x = r * np.cos(theta)\n    y = r * np.sin(theta)\n    return x, y", "def rectangular_to_cylindrical(x, y, z):\n    \"\"\"\n    Converts rectangular (Cartesian) coordinates to cylindrical coordinates.\n    \n    Parameters:\n    x (float): The x-coordinate.\n    y (float): The y-coordinate.\n    z (float): The z-coordinate, remains unchanged in cylindrical coordinates.\n    Returns:\n    tuple: A tuple (r, theta, z) where:\n        r (float) : The radial distance.\n        theta (float): The angle in radians.\n        z (float): The z-coordinate as in rectangular coordinates.\n    Examples:\n    >>> rectangular_to_cylindrical(1, 1, 5)\n    (1.4142135623730951, 0.7853981633974483, 5)\n    \"\"\"\n    r, theta = rectangular_to_polar(x, y)\n    return r, theta, z", "def cylindrical_to_rectangular(r, theta, z):\n    \"\"\"\n    Converts cylindrical coordinates to rectangular (Cartesian) coordinates.\n    \n    Parameters:\n    r (float): The radial distance.\n    theta (float): The angle in radians.\n    z (float): The z-coordinate, remains unchanged in Cartesian coordinates.\n    Returns:\n    tuple: A tuple (x, y, z) where:\n        x (float): The x-coordinate.\n        y (float): The y-coordinate.\n        z (float): The z-coordinate.\n    Examples:\n    >>> cylindrical_to_rectangular(1.414, np.pi/4, 5)\n    (0.9992893641726139, 0.9992893641705094, 5)\n    \"\"\"\n    x, y = polar_to_rectangular(r, theta)\n    return x, y, z", "def rectangular_to_polar(x, y):\n    \"\"\"\n    Convert rectangular (Cartesian) coordinates to polar coordinates.\n    Parameters:\n    - x (float): The x-coordinate in rectangular system.\n    - y (float): The y-coordinate in rectangular system.\n    Returns:\n    - tuple: A tuple (r, theta) where r is the radius and theta is the angle in radians.\n    Examples:\n    >>> rectangular_to_polar(3, 4)\n    (5.0, 0.9272952180016122)\n    \"\"\"\n    r = np.sqrt(x**2 + y**2)\n    theta = np.arctan2(y, x)\n    return r, theta", "def polar_to_rectangular(r, theta):\n    \"\"\"\n    Convert polar coordinates to rectangular (Cartesian) coordinates.\n    Parameters:\n    - r (float): The radius in polar coordinates.\n    - theta (float): The angle in radians in polar coordinates.\n    Returns:\n    - tuple: A tuple (x, y) where x and y are coordinates in rectangular system.\n    Examples:\n    >>> polar_to_rectangular(5, 0.9272952180016122)\n    (3.0000000000000004, 3.9999999999999996)\n    \"\"\"\n    x = r * np.cos(theta)\n    y = r * np.sin(theta)\n    return x, y", "def rectangular_to_cylindrical(x, y, z):\n    \"\"\"\n    Convert rectangular coordinates to cylindrical coordinates.\n    Parameters:\n    - x (float): The x-coordinate in rectangular system.\n    - y (float): The y-coordinate in rectangular system.\n    - z (float): The z-coordinate which remains the same in both systems.\n    Returns:\n    - tuple: A tuple (r, theta, z) representing cylindrical coordinates.\n    Examples:\n    >>> rectangular_to_cylindrical(3, 4, 5)\n    (5.0, 0.9272952180016122, 5)\n    \"\"\"\n    r, theta = rectangular_to_polar(x, y)\n    return r, theta, z", "def cylindrical_to_rectangular(r, theta, z):\n    \"\"\"\n    Convert cylindrical coordinates to rectangular coordinates.\n    Parameters:\n    - r (float): The radial distance in cylindrical coordinates.\n    - theta (float): The angular component in radians in cylindrical coordinates.\n    - z (float): The z-coordinate which remains the same in both systems.\n    Returns:\n    - tuple: A tuple (x, y, z) representing rectangular coordinates.\n    Examples:\n    >>> cylindrical_to_rectangular(5, 0.9272952180016122, 5)\n    (3.0000000000000004, 3.9999999999999996, 5)\n    \"\"\"\n    x, y = polar_to_rectangular(r, theta)\n    return x, y, z"], ["def find_intersection_points(*equations, variables):\n    \"\"\"\n    This function finds the intersection points of provided equations.\n    Parameters\n    ----------\n    *equations : tuple of sympy.Expr\n        A variable length tuple containing the equations for which the intersection points are required.\n    variables : tuple of sympy.Symbol\n        The symbols used in the equations that represent the variables.\n    Returns\n    -------\n    list of sympy.Point\n        A list of sympy Points representing the intersection points of the given equations.\n    Examples\n    --------\n    >>> x, y = sp.symbols('x y')\n    >>> eq1 = sp.Eq(x**2 + y**2, 16)  # Circle with radius 4\n    >>> eq2 = sp.Eq(y, x)             # Line y = x\n    >>> find_intersection_points(eq1, eq2, variables=(x, y))\n    [Point2D(4/sqrt(2), 4/sqrt(2)), Point2D(-4/sqrt(2), -4/sqrt(2))]\n    \"\"\"\n    equations = [eq if isinstance(eq, sp.Eq) else sp.Eq(eq, 0) for eq in equations]\n    solutions = sp.solve(equations, variables, dict=True)\n    points = [sp.Point([sol[var] for var in variables]) for sol in solutions]\n    return points", "def find_intersection(equations):\n    \"\"\"\n    Solve for the intersection points of given algebraic equations.\n    \n    Parameters:\n        equations (list of sympy Eq): A list of sympy Eq objects, representing the equations to solve.\n    \n    Returns:\n        dict: Returns a dictionary of symbols and their solutions if a unique solution exists.\n        list: Returns a list of dictionaries if multiple solutions exist.\n    Example:\n        # To find the intersection of y = 2*x + 1 and y = x - 1\n        x, y = symbols('x y')\n        eq1 = Eq(y, 2*x + 1)\n        eq2 = Eq(y, x - 1)\n        result = find_intersection([eq1, eq2])\n        print(result)  # Output: {x: -2, y: -3}\n    \"\"\"\n    vars = list(set().union(*[eq.free_symbols for eq in equations]))\n    if len(vars) < len(equations):\n        raise ValueError(\"More equations provided than variables.\")\n    solutions = solve(equations, *vars, dict=True)\n    return solutions", "def find_intersections(equations):\n    \"\"\"\n    Computes intersection points of given equations.\n    \n    Parameters:\n        equations (list of sympy expressions): A list of expressions where each expression is equal to zero.\n    Returns:\n        list of tuples: Returns the intersection points. Each point is a tuple of coordinate values.\n    \n    Examples:\n        >>> x, y = sp.symbols('x y')\n        >>> eq1 = x + 2*y - 3\n        >>> eq2 = 2*x - y - 4\n        >>> find_intersections([eq1, eq2])\n        [(2, 0.5)]\n    \"\"\"\n    vars = list(set.union(*[expr.free_symbols for expr in equations]))\n    solutions = sp.nonlinsolve(equations, vars)\n    return [tuple(map(float, sol)) for sol in list(solutions)]"], ["def evaluate_curve_equations(eq, parameter_values):\n    \"\"\"\n    Evaluates the curve equation at specified parameter values.\n    Parameters\n    ----------\n    eq : sympy.Expr\n        The curve equation to evaluate.\n    parameter_values : dict\n        A dictionary where keys are sympy symbols and values are the values at which those symbols are evaluated.\n    Returns\n    -------\n    sympy.Expr\n        The result of the curve equation after substituting the parameter values.\n    Examples\n    --------\n    >>> t = sp.symbols('t')\n    >>> curve_eq = t**2 + 3*t - 4\n    >>> evaluate_curve_equations(curve_eq, {t: 2})\n    6\n    \"\"\"\n    evaluated_eq = eq.subs(parameter_values)\n    return evaluated_eq", "def substitute_in_curve(eq, **values):\n    \"\"\"\n    Substitutes given point coordinates or parameters into the equation of a curve and solves it.\n    \n    Parameters:\n        eq (sympy expression): The equation of the curve.\n        values (dict): Keyword arguments where keys are symbols and values are the numerical values to substitute.\n    Returns:\n        sympy expression or float: The resulting expression after substitution, or the evaluated result if fully substituted.\n    \n    Examples:\n        >>> x, y, a = sp.symbols('x y a')\n        >>> curve_eq = a*x**2 + y**2 - 1\n        >>> substitute_in_curve(curve_eq, x=0.5, y=0.5)\n        a/4 + 0.25 - 1\n        >>> substitute_in_curve(curve_eq, x=0.5, y=0.5, a=2)\n        -0.75\n    \"\"\"\n    substituted_eq = eq.subs(values)\n    return substituted_eq.evalf() if substituted_eq.is_Number else substituted_eq"], ["def vector_subtract(v1, v2):\n    \"\"\"\n    Subtract two vectors.\n    \n    Parameters:\n        v1 (np.array): The vector from which we subtract.\n        v2 (np.array): The vector to subtract.\n    \n    Returns:\n        np.array: The difference of the two vectors.\n    \n    Example:\n        >>> vector_subtract(np.array([5, 7, 9]), np.array([4, 5, 6]))\n        array([1, 2, 3])\n    \"\"\"\n    return np.subtract(v1, v2)", "def vector_subtract(v1, v2):\n    \"\"\"\n    Subtracts the second vector from the first.\n    Parameters:\n    v1 (ndarray): A numpy array representing the first vector.\n    v2 (ndarray): A numpy array representing the second vector.\n    Returns:\n    ndarray: The vector result of v1 - v2.\n    \"\"\"\n    return np.subtract(v1, v2)"], ["def calculate_distance(point1, point2):\n    \"\"\"\n    Calculate the Euclidean distance between two points in two or three-dimensional space.\n    \n    Parameters:\n    - point1 (tuple of float): The coordinates (x, y) or (x, y, z) of the first point.\n    - point2 (tuple of float): The coordinates (x, y) or (x, y, z) of the second point.\n    \n    Returns:\n    - float: The distance between the two points.\n    \n    Examples:\n    >>> calculate_distance((1, 2), (4, 6))\n    5.0\n    >>> calculate_distance((1, 2, 3), (4, 6, 3))\n    5.0\n    \"\"\"\n    point1 = np.array(point1)\n    point2 = np.array(point2)\n    return np.linalg.norm(point1 - point2)", "def distance(point1, point2):\n    \"\"\"\n    Calculates the Euclidean distance between two points in Cartesian space.\n    \n    Parameters:\n        point1 (tuple): The (x, y[, z]) coordinates of the first point.\n        point2 (tuple): The (x, y[, z]) coordinates of the second point.\n    \n    Returns:\n        float: The distance between the two points.\n    \n    Examples:\n        >>> distance((1, 2), (3, 4))\n        2.8284271247461903\n        >>> distance((1, 2, 3), (4, 5, 6))\n        5.196152422706632\n    \"\"\"\n    return np.sqrt(sum((p2 - p1) ** 2 for p1, p2 in zip(point1, point2)))", "def distance_between_points(p1, p2):\n    \"\"\"\n    Calculate the Euclidean distance between two points in 2D space.\n    \n    Parameters:\n        p1, p2 (tuple): Points in the form (x, y).\n    \n    Returns:\n        float: The distance between the points.\n    \"\"\"\n    return math.sqrt((p2[0] - p1[0])**2 + (p2[1] - p1[1])**2)", "def calculate_distance_and_midpoint(point1, point2):\n    \"\"\"\n    Calculate the Euclidean distance and the midpoint between two points in 2D space.\n    \n    Parameters:\n        point1 (tuple): The (x, y) coordinates of the first point.\n        point2 (tuple): The (x, y) coordinates of the second point.\n    \n    Returns:\n        float: The distance between point1 and point2.\n        tuple: The midpoint between point1 and point2, in (x, y) coordinates.\n    \n    Examples:\n        >>> calculate_distance_and_midpoint((1, 2), (4, 6))\n        (5.0, (2.5, 4.0))\n    \"\"\"\n    # Calculate distance\n    distance = math.sqrt((point2[0] - point1[0])**2 + (point2[1] - point1[1])**2)\n    \n    # Calculate midpoint\n    midpoint = ((point1[0] + point2[0]) / 2, (point1[1] + point2[1]) / 2)\n    \n    return distance, midpoint", "def distance_between_points(point1, point2):\n    \"\"\"\n    Calculate the Euclidean distance between two points in the plane.\n    \n    Parameters:\n    - point1 (tuple): The first point (x1, y1).\n    - point2 (tuple): The second point (x2, y2).\n    \n    Returns:\n    - float: The distance between the points.\n    \n    Examples:\n    >>> distance_between_points((1, 2), (4, 6))\n    5.0\n    \"\"\"\n    x1, y1 = point1\n    x2, y2 = point2\n    return ((x2 - x1)**2 + (y2 - y1)**2)**0.5", "def calculate_distance_2d(point1, point2):\n    \"\"\"\n    Calculate the Euclidean distance between two points in 2D space.\n    Parameters:\n    - point1 (tuple or list): The (x, y) coordinates of the first point.\n    - point2 (tuple or list): The (x, y) coordinates of the second point.\n    Returns:\n    - float: The Euclidean distance between the two points.\n    Examples:\n    >>> calculate_distance_2d((1, 2), (4, 6))\n    5.0\n    \"\"\"\n    return np.sqrt((point1[0] - point2[0]) ** 2 + (point1[1] - point2[1]) ** 2)", "def calculate_distance_3d(point1, point2):\n    \"\"\"\n    Calculate the Euclidean distance between two points in 3D space.\n    Parameters:\n    - point1 (tuple or list): The (x, y, z) coordinates of the first point.\n    - point2 (tuple or list): The (x, y, z) coordinates of the second point.\n    Returns:\n    - float: The Euclidean distance between the two points.\n    Examples:\n    >>> calculate_distance_3d((1, 2, 3), (4, 6, 8))\n    7.0710678118654755\n    \"\"\"\n    return distance.euclidean(point1, point2)", "def point_distance(point1, point2):\n    \"\"\"\n    Calculate the Euclidean distance between two points in 3D.\n    \n    Parameters:\n    - point1 (array-like): Coordinates of the first point.\n    - point2 (array-like): Coordinates of the second point.\n    \n    Returns:\n    - float: The Euclidean distance between the points.\n    \n    Example:\n    >>> point_distance([1, 2, 3], [4, 5, 6])\n    5.196152422706632\n    \"\"\"\n    return np.linalg.norm(np.array(point2) - np.array(point1))", "def distance(point1, point2):\n    \"\"\"Calculate the Euclidean distance between two points in n-dimensional space.\n    Parameters:\n        point1 (array-like): The first point coordinates.\n        point2 (array-like): The second point coordinates.\n    Returns:\n        float: The Euclidean distance between the two points.\n    Examples:\n        >>> distance([1, 2], [4, 6])\n        5.0\n    \"\"\"\n    point1, point2 = np.array(point1), np.array(point2)\n    return np.linalg.norm(point1 - point2)", "def calculate_geometric_distance(point1, point2):\n    \"\"\"\n    Calculates the Euclidean distance between two points in 2D space.\n    \n    Parameters:\n    - point1 (tuple): (x1, y1) coordinates of the first point.\n    - point2 (tuple): (x2, y2) coordinates of the second point.\n    \n    Returns:\n    - float: The Euclidean distance between point1 and point2.\n    \n    Example:\n    >>> calculate_geometric_distance((1, 2), (4, 6))\n    5.0\n    \"\"\"\n    from math import sqrt\n    x1, y1 = point1\n    x2, y2 = point2\n    return sqrt((x2 - x1)**2 + (y2 - y1)**2)", "def distance_between_points(p1, p2):\n    \"\"\"\n    Calculate the Euclidean distance between two points in 2D space.\n    Parameters\n    ----------\n    p1 : tuple or list\n        Coordinates (x, y) of the first point.\n    p2 : tuple or list\n        Coordinates (x, y) of the second point.\n    Returns\n    -------\n    float\n        The distance between the two points.\n    Example\n    -------\n    >>> distance_between_points((1, 2), (4, 6))\n    5.0\n    \"\"\"\n    return np.sqrt((p2[0] - p1[0])**2 + (p2[1] - p1[1])**2)", "def distance_2d(point1, point2):\n    \"\"\"\n    Calculate the Euclidean distance between two points in the 2-dimensional space.\n    Parameters:\n    point1 (tuple): A tuple (x1, y1) representing the first point in 2D space.\n    point2 (tuple): A tuple (x2, y2) representing the second point in 2D space.\n    Returns:\n    float: The Euclidean distance between the two points.\n    Examples:\n    >>> distance_2d((1, 2), (4, 6))\n    5.0\n    \"\"\"\n    return np.sqrt((point1[0] - point2[0])**2 + (point1[1] - point2[1])**2)", "def distance_3d(point1, point2):\n    \"\"\"\n    Calculate the Euclidean distance between two points in the 3-dimensional space.\n    Parameters:\n    point1 (tuple): A tuple (x1, y1, z1) representing the first point in 3D space.\n    point2 (tuple): A tuple (x2, y2, z2) representing the second point in 3D space.\n    Returns:\n    float: The Euclidean distance between the two points.\n    Examples:\n    >>> distance_3d((1, 2, 3), (4, 6, 9))\n    7.810249675906654\n    \"\"\"\n    return np.sqrt((point1[0] - point2[0])**2 + (point1[1] - point2[1])**2 + (point1[2] - point2[2])**2)", "def calculate_distance(point1, point2):\n    \"\"\"\n    Compute the Euclidean distance between two points in a 2D coordinate system.\n    \n    Parameters:\n        point1 (tuple): A tuple (x1, y1) representing the coordinates of the first point.\n        point2 (tuple): A tuple (x2, y2) representing the coordinates of the second point.\n    \n    Returns:\n        float: The distance between the two points.\n    \n    Examples:\n        >>> calculate_distance((1, 2), (4, 6))\n        5.0\n        >>> calculate_distance((0, 0), (3, 4))\n        5.0\n    \"\"\"\n    x1, y1 = point1\n    x2, y2 = point2\n    return math.sqrt((x2 - x1)**2 + (y2 - y1)**2)", "def compute_distance(point1, point2):\n    \"\"\"\n    Calculate the Euclidean distance between two points in Cartesian coordinates.\n    Parameters:\n    ----------\n    point1 : tuple\n        A tuple (x1, y1) representing the coordinates of the first point.\n    point2 : tuple\n        A tuple (x2, y2) representing the coordinates of the second point.\n    Returns:\n    -------\n    float\n        The Euclidean distance between the two points.\n    Example:\n    -------\n    >>> compute_distance((1, 2), (4, 6))\n    5.0\n    \"\"\"\n    return np.linalg.norm(np.array(point1) - np.array(point2))", "def distance_between_points(p1, p2):\n    \"\"\"\n    Calculate the Euclidean distance between two 2D points.\n    Parameters:\n    - p1 (tuple or list): The coordinates (x1, y1) of the first point.\n    - p2 (tuple or list): The coordinates (x2, y2) of the second point.\n    Returns:\n    - float: The distance between the two points.\n    Example:\n    >>> distance_between_points((1, 2), (4, 6))\n    5.0\n    \"\"\"\n    return np.hypot(p2[0] - p1[0], p2[1] - p1[1])", "def distance_between_points(point1, point2):\n    \"\"\"\n    Calculates the distance between two points in the Cartesian plane.\n    Parameters\n    ----------\n    point1 : tuple\n        Coordinates of the first point (x1, y1).\n    point2 : tuple\n        Coordinates of the second point (x2, y2).\n    \n    Returns\n    -------\n    float\n        The Euclidean distance between the two points.\n    \n    Examples\n    --------\n    >>> distance_between_points((1, 2), (4, 6))\n    5.0\n    \"\"\"\n    x1, y1 = point1\n    x2, y2 = point2\n    return np.sqrt((x2 - x1)**2 + (y2 - y1)**2)", "def calculate_distance(point1, point2):\n    \"\"\"\n    Calculates the Euclidean distance between two points in 2D or 3D coordinate space.\n    Parameters\n    ----------\n    point1 : array_like\n        The coordinates (x, y) or (x, y, z) of the first point.\n    point2 : array_like\n        The coordinates (x, y) or (x, y, z) of the second point.\n    Returns\n    -------\n    float\n        The Euclidean distance between the two points.\n    \n    Examples\n    --------\n    >>> calculate_distance([0, 0], [3, 4])\n    5.0\n    >>> calculate_distance([0, 0, 0], [0, 3, 4])\n    5.0\n    \"\"\"\n    point1 = np.asarray(point1)\n    point2 = np.asarray(point2)\n    return np.linalg.norm(point1 - point2)", "def distance_between_points(p1, p2):\n    \"\"\"\n    Calculate the Euclidean distance between two points in either 2D or 3D coordinate space.\n    \n    Parameters:\n        p1 (tuple): Coordinates of the first point. Can be 2D (x, y) or 3D (x, y, z).\n        p2 (tuple): Coordinates of the second point.\n        \n    Returns:\n        float: The Euclidean distance between point p1 and p2.\n    \n    Examples:\n    >>> distance_between_points((1, 2), (4, 6))\n    5.0\n    >>> distance_between_points((1, 2, 3), (4, 6, 3))\n    5.0\n    \"\"\"\n    p1 = np.array(p1)\n    p2 = np.array(p2)\n    return np.linalg.norm(p1 - p2)", "def calculate_distance(point1, point2):\n    \"\"\"\n    Calculates the Euclidean distance between two points in a 2D space.\n    Parameters:\n    - point1 (tuple): Coordinates of the first point (x1, y1).\n    - point2 (tuple): Coordinates of the second point (x2, y2).\n    Returns:\n    - float: Euclidean distance.\n    Example:\n    >>> calculate_distance((1, 2), (4, 6))\n    5.0\n    \"\"\"\n    from math import sqrt\n    return sqrt((point2[0] - point1[0])**2 + (point2[1] - point1[1])**2)", "def calculate_distance(point1, point2):\n    \"\"\"\n    Calculate the Euclidean distance between two points in 2D space.\n    Parameters:\n        point1 (tuple): The (x, y) coordinates of the first point.\n        point2 (tuple): The (x, y) coordinates of the second point.\n    Returns:\n        float: The distance between the two points.\n    \n    Examples:\n        >>> calculate_distance((1, 2), (4, 6))\n        5.0\n    \"\"\"\n    return np.linalg.norm(np.array(point1) - np.array(point2))", "def compute_distance(point1, point2, dimensions=2):\n    \"\"\"\n    Calculate the Euclidean distance between two points in 2D or 3D space.\n    Parameters:\n    - point1 (tuple): Coordinates of the first point (x1, y1) or (x1, y1, z1).\n    - point2 (tuple): Coordinates of the second point (x2, y2) or (x2, y2, z2).\n    - dimensions (int): The dimensionality of the points (2 or 3).\n    Returns:\n    - float: The distance between the two points.\n    Examples:\n    >>> compute_distance((1, 2), (4, 6))\n    5.0\n    >>> compute_distance((1, 2, 3), (4, 6, 3), dimensions=3)\n    5.0\n    \"\"\"\n    import math\n    if dimensions == 2:\n        return math.sqrt((point2[0] - point1[0])**2 + (point2[1] - point1[1])**2)\n    elif dimensions == 3:\n        return math.sqrt((point2[0] - point1[0])**2 + (point2[1] - point1[1])**2 + (point2[2] - point1[2])**2)\n    else:\n        raise ValueError(\"Only 2D or 3D dimensions are supported\")", "def calculate_distance(p1, p2):\n    \"\"\"\n    Calculate the Euclidean distance between two points in 2D or 3D.\n    Parameters:\n    - p1 (tuple): coordinates of the first point.\n    - p2 (tuple): coordinates of the second point.\n    Returns:\n    - float: Euclidean distance.\n    Examples:\n    >>> calculate_distance((1, 2), (4, 6))\n    5.0\n    \n    >>> calculate_distance((1, 2, 3), (4, 6, 8))\n    7.0710678118654755\n    \"\"\"\n    return np.sqrt(sum((x2 - x1)**2 for x1, x2 in zip(p1, p2)))", "def distance(point1, point2):\n    \"\"\"\n    Calculate the Euclidean distance between two points in the Cartesian plane.\n    \n    Parameters:\n        point1 (tuple): Coordinates (x, y) of the first point.\n        point2 (tuple): Coordinates (x, y) of the second point.\n    \n    Returns:\n        float: The distance between the two points.\n        \n    Examples:\n        distance((1, 2), (4, 6))\n    \"\"\"\n    return np.linalg.norm(np.array(point1) - np.array(point2))", "def distance_between_points(p1, p2):\n    \"\"\"\n    Calculates the Euclidean distance between two points in a 2D coordinate system.\n    Parameters:\n    - p1: Tuple of coordinates (x1, y1) for the first point.\n    - p2: Tuple of coordinates (x2, y2) for the second point.\n    Returns:\n    - float: Euclidean distance between points p1 and p2.\n    \n    Example:\n    >>> distance_between_points((1, 2), (4, 6))\n    5.0\n    \"\"\"\n    return np.linalg.norm(np.array(p1) - np.array(p2))", "def calculate_distance_2d(point1, point2):\n    \"\"\"\n    Calculate the Euclidean distance between two points in the 2D Cartesian plane.\n    Parameters:\n    - point1 (tuple): The (x, y) coordinates of the first point.\n    - point2 (tuple): The (x, y) coordinates of the second point.\n    Returns:\n    - float: The distance between the two points.\n    Examples:\n    >>> calculate_distance_2d((1, 2), (4, 6))\n    5.0\n    \"\"\"\n    return np.sqrt((point1[0] - point2[0])**2 + (point1[1] - point2[1])**2)", "def calculate_distance_3d(point1, point2):\n    \"\"\"\n    Calculate the Euclidean distance between two points in 3-dimensional space.\n    Parameters:\n    - point1 (tuple): The (x, y, z) coordinates of the first point.\n    - point2 (tuple): The (x, y, z) coordinates of the second point.\n    Returns:\n    - float: The distance between the two points.\n    Examples:\n    >>> calculate_distance_3d((1, 2, 1), (4, 6, 2))\n    5.0990195135927845\n    \"\"\"\n    return np.sqrt((point1[0] - point2[0])**2 + (point1[1] - point2[1])**2 + (point1[2] - point2[2])**2)", "def distance_between_points(point1, point2):\n    \"\"\"\n    Calculate the Euclidean distance between two points in 2D or 3D space.\n    Parameters:\n    - point1 (tuple): Coordinates of the first point (x1, y1, [z1]).\n    - point2 (tuple): Coordinates of the second point (x2, y2, [z2]).\n    Returns:\n    - float: The distance between the two points.\n    Example:\n    >>> distance_between_points((1, 2), (4, 6))\n    5.0\n    \"\"\"\n    point1 = np.array(point1)\n    point2 = np.hash(point2)\n    return np.linalg.norm(point1 - point2)", "def distance_between_points(point1, point2):\n    \"\"\"\n    Calculate the Euclidean distance between two points in 2D space.\n    \n    Parameters:\n        point1 (tuple): The coordinates (x, y) of the first point.\n        point2 (tuple): The coordinates (x, y) of the second point.\n    \n    Returns:\n        float: The computed distance between the two points.\n        \n    Examples:\n        >>> distance_between_points((1, 2), (4, 6))\n        5.0\n        \n    \"\"\"\n    return np.sqrt((point1[0] - point2[0])**2 + (point1[1] - point2[1])**2)"], ["def area_of_triangle(p1, p2, p3):\n    \"\"\"\n    Calculate the area of a triangle given three vertices.\n    \n    Parameters:\n        p1, p2, p3 (tuple): Vertices of the triangle, each given as (x, y).\n    \n    Returns:\n        float: The absolute area of the triangle.\n    \"\"\"\n    # Using the Shoelace formula\n    return abs(p1[0]*(p2[1]-p3[1]) + p2[0]*(p3[1]-p1[1]) + p3[0]*(p1[1]-p2[1])) / 2", "def area_of_triangle_by_coordinates(vertices):\n    \"\"\"\n    Calculate the area of a triangle given its vertex coordinates using the shoelace formula.\n    Parameters\n    ----------\n    vertices : list of tuples\n        List of three tuples, each representing the coordinates (x, y) of a triangle vertex.\n    Returns\n    -------\n    float\n        The absolute area of the triangle.\n    Example\n    -------\n    >>> area_of_triangle_by_coordinates([(0, 0), (4, 0), (2, 3)])\n    6.0\n    \"\"\"\n    x1, y1 = vertices[0]\n    x2, y2 = vertices[1]\n    x3, y3 = vertices[2]\n    return abs((x1*(y2 - y3) + x2*(y3 - y1) + x3*(y1 - y2)) / 2)", "def compute_triangle_area(p1, p2, p3):\n    \"\"\"\n    Calculate the area of a triangle given its vertices.\n    Parameters:\n    ----------\n    p1, p2, p3 : tuple\n        Each is a tuple (x, y) representing the coordinates of a vertex of the triangle.\n    Returns:\n    -------\n    float\n        The area of the triangle.\n    Example:\n    -------\n    >>> compute_triangle_area((0, 0), (4, 0), (0, 3))\n    6.0\n    \"\"\"\n    x1, y1 = p1\n    x2, y2 = p2\n    x3, y3 = p3\n    return abs((x1*(y2-y3) + x2*(y3-y1) + x3*(y1-y2)) / 2)", "def area_of_triangle(p1, p2, p3):\n    \"\"\"\n    Calculate the area of a triangle given its three vertices.\n    \n    Parameters:\n    - p1, p2, p3 (tuple): Coordinates of the triangle vertices (x1, y1), (x2, y2), (x3, y3).\n    \n    Returns:\n    - float: The area of the triangle.\n    Example:\n    >>> area_of_triangle((0, 0), (4, 0), (0, 3))\n    6.0\n    \"\"\"\n    x1, y1 = p1\n    x2, y2 = p2\n    x3, y3 = p3\n    return 0.5 * abs(x1*(y2 - y3) + x2*(y3 - y1) + x3*(y1 - y2))", "def triangle_area_by_coordinates(vertices):\n    \"\"\"\n    Calculate the area of a triangle given its vertices in 2D space.\n    Parameters:\n        vertices (list of tuples): A list of three (x, y) tuples for the triangle vertices.\n    Returns:\n        float: The absolute area of the triangle.\n    Examples:\n        >>> triangle_area_by_coordinates([(0, 0), (4, 0), (2, 3)])\n        6.0\n    \"\"\"\n    x1, y1 = vertices[0]\n    x2, y2 = vertices[1]\n    x3, y3 = vertices[2]\n    return abs(x1*(y2 - y3) + x2*(y3 - y1) + x3*(y1 - y2)) / 2", "def area_of_triangle(points):\n    \"\"\"\n    Calculate the area of a triangle given by three points.\n    \n    Parameters:\n        points (list of tuples): Three points (tuples) that define the triangle vertices.\n    \n    Returns:\n        float: The area of the triangle.\n        \n    Examples:\n        area_of_triangle([(0, 0), (4, 0), (0, 3)])\n    \"\"\"\n    x1, y1 = points[0]\n    x2, y2 = points[1]\n    x3, y3 = points[2]\n    return abs(x1*(y2-y3) + x2*(y3-y1) + x3*(y1-y2) / 2)"], ["def diagonal_length(length, width=None):\n    \"\"\"\n    Calculate the diagonal length of a rectangle or square using the Pythagorean theorem.\n    If width is not provided, the shape is assumed to be a square.\n    \n    Parameters:\n    - length (float): The length of the rectangle or one side of the square.\n    - width (float, optional): The width of the rectangle. If not specified, assumes a square.\n    \n    Returns:\n    - float: The diagonal length of the rectangle or square.\n    \n    Examples:\n    >>> diagonal_length(5)\n    7.0710678118654755\n    >>> diagonal_length(3, 4)\n    5.0\n    \"\"\"\n    if width is None:\n        width = length\n    return np.sqrt(length**2 + width**2)", "def rectangle_diagonal(length, width):\n    \"\"\"\n    Calculate the length of the diagonal of a rectangle using the Pythagorean theorem.\n    Parameters:\n    length (float): The length of the rectangle.\n    width (float): The width of the rectangle.\n    Returns:\n    float: The length of the diagonal.\n    Examples:\n    >>> rectangle_diagonal(3, 4)\n    5.0\n    \"\"\"\n    return np.sqrt(length**2 + width**2)"], ["def calculate_area_of_square(side_length):\n    \"\"\"\n    Calculate the area of a square given the side length.\n    \n    Parameters:\n        side_length (float or sympy expression): The length of the side of the square.\n    \n    Returns:\n        float or sympy expression: The area of the square.\n    Example:\n        area = calculate_area_of_square(5)\n        print(area)  # Output: 25\n    \"\"\"\n    return side_length**2", "def square_area(side_length):\n    \"\"\"\n    Calculate the area of a square given the side length.\n    Parameters:\n        side_length (float): The length of a side of the square.\n    \n    Returns:\n        float: The area of the square.\n    \n    Examples:\n        >>> square_area(4.5)\n        20.25\n    \"\"\"\n    return side_length ** 2"], ["def parse_conic_section_equation(eq):\n    \"\"\"\n    Parses the given equation of a conic section and converts it into its standard form. It also extracts important\n    geometric parameters such as center, foci, radii, or axes lengths depending on the type of conic section. \n    The types considered are circle, ellipse, and hyperbola.\n    \n    Parameters:\n    - eq (str): A string representing the equation of the conic section.\n      For example, 'x^2 + 4y^2 + 6x - 8y + 9 = 0' for an ellipse.\n    \n    Returns:\n    - dict: A dictionary containing type of conic section, standard form of the equation, and key geometric properties such as center, foci, radii, etc.\n    \n    Example:\n    >>> parse_conic_section_equation(\"x^2 + y^2 - 4x + 2y + 1 = 0\")\n    {'type': 'circle', 'standard_form': '(x-2)^2 + (y+1)^2 = 4', 'center': (2, -1), 'radius': 2}\n    \"\"\"\n    from sympy import symbols, Eq, solve, sqrt\n    \n    x, y = symbols('x y')\n    eq = eq.replace(\"^\", \"**\")\n    equation = Eq(eval(eq.replace(\"=\", \"-(\") + \")\"), 0)\n    # Solve for completing the square\n    standard_form, properties = None, {}\n    \n    # Identify based on coefficients\n    A = equation.lhs.coeff(x**2)\n    B = equation.lhs.coeff(y**2)\n    C = equation.lhs.coeff(x)\n    D = equation.lhs.coeff(y)\n    E = equation.lhs.as_coefficients_dict()[1]  # Constant term\n    \n    if A == B:\n        center_x = solve((2 * A * x + C).as_expr())[0]\n        center_y = solve((2 * B * y + D).as_expr())[0]\n        radius = sqrt(abs(E + A*center_x**2 + B*center_y**2))\n        properties.update(type='circle', center=(center_x, center_y), radius=radius)\n        standard_form = f\"(x-({center_x}))^2 + (y-({center_y}))^2 = {radius**2}\"\n    elif A != 0 and B != 0:\n        center_x = solve((2 * A * x + C).as_expr())[0]\n        center_y = solve((2 * B * y + D).as_expr())[0]\n        a2 = abs((radius**2 - E)/A)\n        b2 = abs((radius**2 - E)/B)\n        if A > B:\n            foci_distance = sqrt(abs(a2 - b2))\n        else:\n            foci_distance = sqrt(abs(b2 - a2))\n        properties.update(type='ellipse', center=(center_x, center_y), a=sqrt(a2), b=sqrt(b2), c=foci_distance)\n        standard_form = f\"(x-({center_x}))^2/{a2} + (y-({center_y}))^2/{b2} = 1\"\n    else:  # hyperbola\n        # similar to ellipse, but focus on differences in signs between x^2 and y^2 terms\n        # Proper handling would be similar to above, considering sign differences.\n        pass\n    \n    return {'standard_form': standard_form, 'properties': properties}", "def convert_conic_to_standard_form(eq_type, coefficients):\n    \"\"\"\n    Converts a general equation of a conic section (circle, ellipse, parabola, hyperbola) to its standard form.\n    \n    Parameters:\n    - eq_type (str): Type of conic ('circle', 'ellipse', 'parabola', 'hyperbola').\n    - coefficients (dict): Coefficients of the equation. E.g., for a circle: {'x^2': 1, 'y^2': 1, 'x': -6, 'y': 4, 'constant': -3}\n    Returns:\n    - dict: Standardized form parameters.\n    Example:\n    >>> convert_conic_to_standard_form('circle', {'x^2': 1, 'y^2': 1, 'x': -6, 'y': 4, 'constant': -3})\n    {'center': (3, -2), 'radius': 4}\n    \"\"\"\n    import math\n    if eq_type in ['circle', 'ellipse']:\n        A = coefficients.get('x^2', 0)\n        B = coefficients.get('y^2', 0)\n        C = coefficients.get('x', 0)\n        D = coefficients.get('y', 0)\n        E = coefficients.get('constant', 0)\n        h = -C / (2 * A)\n        k = -D / (2 * B)\n        r_squared = -E + (C**2) / (4 * A) + (D**2) / (4 * B)\n        if eq_type == 'circle':\n            return {'center': (h, k), 'radius': math.sqrt(r_squared)}\n    elif eq_type == 'parabola':\n        # Assume coefficients of 'x^2' or 'y^2' and a linear term for directrix/vertex form conversion.\n        pass\n    elif eq_type == 'hyperbola':\n        # Similar to ellipse handling but taking care of differences in signs and asymptote calculations.\n        pass\n    return {}", "def transform_conic_section_to_standard(equation, x, y):\n    \"\"\"\n    Transforms general conic section equations (circle, ellipse, parabola, hyperbola) into their standard forms.\n    Parameters:\n        equation (str): The general equation of conic section as a string.\n        x (sympy.Symbol): Symbol representing the x-coordinate.\n        y (sympy.Symbol): Symbol representing the y-coordinate.\n    \n    Returns:\n        dict: A dictionary containing the standard form equation and key parameters like center, radius (for circles) or\n              semi-major/minor axes, foci (for ellipses and hyperbolas).\n              \n    Examples:\n        >>> x, y = sp.symbols('x y')\n        >>> eq = 'x**2 + y**2 - 6*x + 4*y + 9 = 0'\n        >>> transform_conic_section_to_standard(eq, x, y)\n        {'standard_form': (x - 3)**2 + (y + 2)**2 - 4, 'center': (3, -2), 'radius': 2}\n    \n    \"\"\"\n    parsed_eq = sp.sympify(equation).simplify()\n    \n    # Separate the equation by variables\n    x_terms = parsed_eq.collect(x, evaluate=False)\n    y_terms = parsed_eq.collect(y, evaluate=False)\n    \n    # Complete the square for each coordinate\n    x_sq = complete_square(x_terms[x**2] + x_terms.get(x, 0), x)\n    y_sq = complete_square(y_terms[y**2] + y_terms.get(y, 0), y)\n    \n    # Completion for circles and ellipses\n    constant_terms = (parsed_eq - x_terms[x**2] - y_terms[y**2] - x_terms.get(x, 0) - y_terms.get(y, 0)).simplify()\n    \n    # Equation in standard form\n    standard_form = x_sq + y_sq + constant_terms\n    \n    # Extract center and other parameters\n    result = {'standard_form': standard_form}\n    cx, cy = sp.solve([x + sp.solve(x_sq.as_poly())[0], y + sp.solve(y_sq.as_poly())[0]], (x,y))\n    result['center'] = (cx, cy)\n    \n    if 'x**2' in equation and 'y**2' in equation:\n        a2, b2 = sorted([abs(x_sq.coeff(x**2)), abs(y_sq.coeff(y**2))], reverse=True)\n        result['semi-major_axis'] = sp.sqrt(a2)\n        result['semi-minor_axis'] = sp.sqrt(b2)\n        if 'x**2' in equation == 'y**2' in equation:\n            result['radius'] = sp.sqrt(abs(constant_terms))\n    \n    return result"], ["def solve_linear_system(coeff_matrix, const_vector):\n    \"\"\"\n    Solves a linear system of equations defined by a matrix of coefficients and a constant vector.\n    Parameters:\n    - coeff_matrix (list[list[float]]): Coefficient matrix where each row represents the coefficients of a linear equation.\n    - const_vector (list[float]): Constant terms for each equation.\n    Returns:\n    - ndarray: Solution to the system of equations.\n    Examples:\n    >>> solve_linear_system([[1, 1], [1, -1]], [5, 1])\n    array([3., 2.])\n    \"\"\"\n    coeff_matrix = np.array(coeff_matrix)\n    const_vector = np.array(const_vector)\n    return np.linalg.solve(coeff_matrix, const_vector)"], ["def find_perpendicular_slope(slope):\n    \"\"\"\n    Calculates the slope of a line perpendicular to a given slope.\n    \n    Parameters\n    ----------\n    slope : float\n        Slope of the given line.\n    \n    Returns\n    -------\n    float\n        Slope of the perpendicular line.\n    \n    Examples\n    --------\n    >>> find_perpendicular_slope(2)\n    -0.5\n    \"\"\"\n    return -1 / slope"], ["def reflect_point(point, axis='y'):\n    \"\"\"\n    Reflect a point across the y-axis or x-axis.\n    \n    Parameters:\n        point (tuple): The point to reflect, given as (x, y).\n        axis (str): The axis to reflect across ('x' or 'y').\n    \n    Returns:\n        tuple: The reflected point.\n    \"\"\"\n    if axis == 'y':\n        return (-point[0], point[1])\n    elif axis == 'x':\n        return (point[0], -point[1])\n    else:\n        raise ValueError(\"Axis must be 'x' or 'y'\")", "def reflect_across_axis(point, axis='y'):\n    \"\"\"\n    Reflect a point across a specified axis in the Cartesian coordinate system.\n    Parameters:\n    ----------\n    point : tuple\n        A tuple (x, y) representing the initial coordinates of the point.\n    axis : str\n        The axis to reflect across ('x', 'y', 'y=x', 'y=-x').\n    Returns:\n    -------\n    tuple\n        A tuple representing the reflected point's coordinates.\n    Example:\n    -------\n    >>> reflect_across_axis((2, 3), 'y')\n    (-2, 3)\n    >>> reflect_across_axis((2, 3), 'y=x')\n    (3, 2)\n    \"\"\"\n    x, y = point\n    if axis == 'y':\n        return (-x, y)\n    elif axis == 'x':\n        return (x, -y)\n    elif axis == 'y=x':\n        return (y, x)\n    elif axis == 'y=-x':\n        return (-y, -x)\n    else:\n        raise ValueError(\"Invalid axis for reflection.\")", "def reflect(point, axis=\"x\"):\n    \"\"\"\n    Reflect a point across a specified axis in 2D.\n    \n    Parameters:\n        point (tuple): Coordinates (x, y) of the point.\n        axis (str): Axis you want to reflect over, \"x\", \"y\", or \"origin\". Additionally supports \"y=x\".\n    \n    Returns:\n        tuple: Coordinates of the reflected point.\n        \n    Examples:\n        reflect((2, 3), axis=\"x\")\n        reflect((2, 3), axis=\"y\")\n        reflect((2, 3), axis=\"origin\")\n        reflect((2, 3), axis=\"y=x\")\n    \"\"\"\n    x, y = point\n    if axis == \"x\":\n        return (x, -y)\n    elif axis == \"y\":\n        return (-x, y)\n    elif axis == \"origin\":\n        return (-x, -y)\n    elif axis == \"y=x\":\n        return (y, x)\n    else:\n        raise ValueError(\"Invalid axis specified.\")"], ["def transform_coordinates(points, transformation_matrix):\n    \"\"\"\n    Applies a transformation matrix to a list of point coordinates in 2D.\n    Parameters:\n    - points: List of tuples representing the point coordinates.\n    - transformation_matrix: A 2x2 numpy array representing the transformation matrix.\n    Returns:\n    - List of tuples: New coordinates after transformation.\n    Example:\n    >>> transform_coordinates([(1, 2)], np.array([[2, 0], [0, 2]]))\n    [(2, 4)]\n    \"\"\"\n    transformed = np.dot(transformation_matrix, np.array(points).T).T\n    return [tuple(point) for point in transformed]"], ["class Point:\n    \"\"\"\n    This class represents a Point in 2D geometry.\n    \n    Attributes:\n        x (float): x-coordinate of the Point.\n        y (float): y-coordinate of the Point.\n    \"\"\"\n    \n    def __init__(self, x=0.0, y=0.0):\n        \"\"\"\n        The constructor for the Point class. It initializes the x and y coordinates of the point.\n        \n        Parameters:\n            x (float): The x-coordinate of the point.\n            y (float): The y-coordinate of the point.\n        \"\"\"\n        self.x = x\n        self.y = y\n    def __str__(self):\n        \"\"\"\n        This method returns the string representation of the Point.\n        \n        Returns:\n            str: A string in the format '(x, y)'.\n        \"\"\"\n        return '(' + str(self.x) + ', ' + str(self.y) + ')'\n    \n    def distance(self, other):\n        \"\"\"\n        This method calculates the Euclidean distance between this Point and another Point.\n        \n        Parameters:\n            other (Point): The other Point.\n            \n        Returns:\n            float: The Euclidean distance between the two points.\n        \"\"\"\n        return np.sqrt((self.x - other.x)**2 + (self.y - other.y)**2)"], ["def complete_square(expression, variable):\n    \"\"\"Complete the square for the given variable in a SymPy expression.\"\"\"\n    a = expression.coeff(variable**2)\n    b = expression.coeff(variable)\n    completed_square = a * (variable + b/(2*a))**2 - (b**2)/(4*a)\n    return completed_square"], ["def rotate_point_about_origin(point, angle_degrees):\n    \"\"\"\n    Rotate a point about the origin by a certain angle in degrees.\n    Parameters\n    ----------\n    point : tuple\n        The (x, y) coordinates of the point.\n    angle_degrees : float\n        The angle in degrees by which the point should be rotated.\n    Returns\n    -------\n    tuple\n        The new coordinates of the point after rotation.\n    Example\n    -------\n    >>> rotate_point_about_origin((1, 0), 90)\n    (0, 1)\n    \"\"\"\n    angle_rad = np.radians(angle_degrees)\n    cos_theta, sin_theta = np.cos(angle_rad), np.sin(angle_rad)\n    x, y = point\n    x_new = x * cos_theta - y * sin_theta\n    y_new = x * sin_theta + y * cos_theta\n    return (x_new, y_new)", "def rotate_point(point, angle, origin=(0, 0)):\n    \"\"\"\n    Rotate a point around a given origin by an angle in degrees.\n    \n    Parameters:\n        point (tuple): Coordinates (x, y) of the point.\n        angle (float): Rotation angle in degrees.\n        origin (tuple): Pivot point coordinates (x, y).\n    \n    Returns:\n        tuple: Coordinates of the rotated point.\n        \n    Examples:\n        rotate_point((1, 2), 90)\n    \"\"\"\n    ox, oy = origin\n    px, py = point\n    qx = ox + cos(rump.deg2rad(angle)) * (px - ox) - sin(rump.deg2rad(angle)) * (py - oy)\n    qy = oy + sin(rump.deg2rad(angle)) * (px - ox) + cos(rump.deg2rad(angle)) * (py - oy)\n    return (qx, qy)"], ["def dot_product(vector1, vector2):\n    \"\"\"\n    Compute the dot product of two vectors in 3D.\n    \n    Parameters:\n    - vector1 (array-like): The first vector.\n    - vector2 (array-like): The second vector.\n    \n    Returns:\n    - float: The dot product of the vectors.\n    \n    Example:\n    >>> dot_product([1, 2, 3], [4, 5, 6])\n    32.0\n    \"\"\"\n    return np.dot(vector1, vector2)", "def cross_product(vector1, vector2):\n    \"\"\"\n    Compute the cross product of two vectors in 3D.\n    \n    Parameters:\n    - vector1 (array-like): The first vector.\n    - vector2 (array-like): The second vector.\n    \n    Returns:\n    - numpy.ndarray: The cross product vector.\n    \n    Example:\n    >>> cross_product([1, 2, 3], [4, 5, 6])\n    array([-3, 6, -3])\n    \"\"\"\n    return np.cross(vector1, vector2)", "def dot_product(v1, v2):\n    \"\"\"\n    Compute dot product of two vectors.\n    \n    Parameters:\n        v1 (np.array): The first vector.\n        v2 (np.array): The second vector.\n    \n    Returns:\n        float: The dot product of the two vectors.\n    \n    Example:\n        >>> dot_product(np.array([1, 2, 3]), np.array([4, 5, 6]))\n        32.0\n    \"\"\"\n    return np.dot(v1, v2)", "def cross_product(v1, v2):\n    \"\"\"\n    Compute cross product of two vectors.\n    \n    Parameters:\n        v1 (np.array): The first vector.\n        v2 (np.urlparse): The second vector.\n    \n    Returns:\n        np.array: The cross product of the two vectors.\n    \n    Example:\n        >>> cross_product(np.array([1, 2, 3]), np.array([4, 5, 6]))\n        array([-3, 6, -3])\n    \"\"\"\n    return np.cross(v1, v2)", "def dot_product(v1, v2):\n    \"\"\"\n    Computes the dot product of two vectors.\n    Parameters:\n    v1 (ndarray): The first vector.\n    v2 (ndarray): The second vector.\n    Returns:\n    float: The dot product of v1 and v2.\n    \"\"\"\n    return np.dot(v1, v2)", "def cross_product(v1, v2):\n    \"\"\"\n    Computes the cross product of two vectors.\n    Parameters:\n    v1 (ndarray): The first vector.\n    v2 (ndarray): The second vector.\n    Returns:\n    ndarray: The cross product of v1 and v2.\n    \"\"\"\n    return np.cross(v1, v2)"], ["def line_equation_from_point_slope(point, slope):\n    \"\"\"\n    Find the equation of a line in slope-intercept form 'y = mx + c' given a point and a slope.\n    \n    Parameters:\n    - point (tuple): Point (x, y) through which the line passes.\n    - slope (float): Slope of the line.\n    \n    Returns:\n    - tuple: slope m and intercept c of the line 'y = mx + c'.\n    \n    Examples:\n    >>> line_equation_from_point_slope((1, 2), 3)\n    (3, -1)\n    \"\"\"\n    x, y = point\n    c = y - slope * x\n    return slope, c", "def line_equation(point, slope):\n    \"\"\"\n    Determines the equation of a line given a point and the slope.\n    Parameters\n    ----------\n    point : tuple\n        A point (x, y) through which the line passes.\n    slope : float\n        Slope of the line.\n    \n    Returns\n    -------\n    tuple\n        Coefficients (m, c) of the line equation y = mx + c.\n    \n    Examples\n    --------\n    >>> line_equation((2, 3), 1.5)\n    (1.5, 0.0)\n    \"\"\"\n    x, y = point\n    m = slope\n    c = y - m * x\n    return (m, c)"], ["def circle_area(radius):\n    \"\"\"\n    Calculates the area of a circle given its radius.\n    Parameters:\n    radius (float): The radius of the circle\n    Returns:\n    float: The area of the circle\n    \"\"\"\n    return np.pi * radius**2", "def circle_area(radius):\n    \"\"\"\n    Calculate the area of a circle given its radius.\n    Parameters:\n    - radius (float): The radius of the circle.\n    Returns:\n    - float: The area of the circle.\n    Examples:\n    >>> circle_area(3)\n    28.274333882308138\n    \"\"\"\n    return np.pi * (radius**2)"], ["def circle_equation(h, k, r):\n    \"\"\"\n    Returns the standard form equation of a circle given the center (h, k) and radius r.\n    Parameters:\n    h (float): The x-coordinate of the center.\n    k (float): The y-coordinate of the center.\n    r (float): The radius of the circle.\n    Returns:\n    str: The equation of the circle in standard form.\n    Examples:\n    >>> circle_equation(0, 0, 1)\n    '(x - 0)^2 + (y - 0)^2 = 1^2'\n    \"\"\"\n    return f\"(x - {h})^2 + (y - {k})^2 = {r}^2\"", "def circle_equation(h, k, r):\n    \"\"\"\n    Return the standard form equation of a circle given its center and radius.\n    Parameters:\n    - h (float): The x-coordinate of the circle's center.\n    - k (float): The y-coordinate of the circle's center.\n    - r (float): The radius of the circle.\n    Returns:\n    - str: The equation of the circle in the format '(x - h)^2 + (y - k)^2 = r^2'.\n    Examples:\n    >>> circle_equation(1, 2, 3)\n    '(x - 1)^2 + (y - 2)^2 = 9'\n    \"\"\"\n    return f\"(x - {h})^2 + (y - {k})^2 = {r**2}\""], ["def get_line_equation(p1, p2):\n    \"\"\"\n    Calculate the coefficients (A, B, C) of the line equation Ax + By + C = 0 passing through two points.\n    Parameters:\n    - p1 (tuple): coordinates of the first point.\n    - p2 (tuple): coordinates of the second point.\n    Returns:\n    - tuple: coefficients (A, B, C) of the line.\n    Examples:\n    >>> get_line_equation((1, 2), (3, 4))\n    (2, -2, 0)\n    \"\"\"\n    x1, y1 = p1\n    x2, y2 = p2\n    A = y2 - y1\n    B = x1 - x2\n    C = x2 * y1 - x1 * y2\n    return (A, B, C)"], ["def scalar_multiply(vector, scalar):\n    \"\"\"\n    Multiplies a vector by a scalar.\n    Parameters:\n    vector (ndarray): A numpy array representing the vector.\n    scalar (float): The scalar value to multiply with the vector.\n    Returns:\n    ndarray: The scaled vector.\n    \"\"\"\n    return np.multiply(vector, scalar)"], ["def vector_add(v1, v2):\n    \"\"\"\n    Add two vectors.\n    \n    Parameters:\n        v1 (np.array): The first vector.\n        v2 (np.array): The second vector.\n    \n    Returns:\n        np.array: The sum of the two vectors.\n    \n    Example:\n        >>> vector_add(np.array([1, 2, 3]), np.array([4, 5, 6]))\n        array([5, 7, 9])\n    \"\"\"\n    return np.add(v1, v2)", "def vector_add(v1, v2):\n    \"\"\"\n    Adds two vectors.\n    Parameters:\n    v1 (ndarray): A numpy array representing the first vector.\n    v2 (ndarray): A numpy array representing the second vector.\n    Returns:\n    ndarray: The vector sum of v1 and v2.\n    \"\"\"\n    return np.add(v1, v2)"], ["def plane_normal_from_points(p1, p2, p3):\n    \"\"\"\n    Calculate the normal vector of a plane given three points on the plane.\n    Parameters:\n    p1, p2, p3 (ndarray): Vectors representing three points on the plane.\n    Returns:\n    ndarray: The normal vector of the plane defined by points p1, p2, and p3.\n    \"\"\"\n    v1 = vector_subtract(p2, p1)\n    v2 = vector_subtract(p3, p1)\n    return cross_product(v1, v2)"], ["def distance_constraints_2d(points, distance):\n    \"\"\"\n    Formulate and solve a system of equations given distance constraints between multiple points in 2D.\n    Parameters:\n    - points (list): List of tuples/lists where each tuple/list contains the (x, y) coordinates.\n    - distance (float): The distance that each pair of points should satisfy.\n    Returns:\n    - list: A list of sympy Eq objects expressing the distance constraints.\n    Examples:\n    \"\"\"\n    x, y = symbols('x y', real=True)\n    generated_eqs = []\n    for p1, p2 in zip(points, points[1:] + [points[0]]):\n        eq = Eq((x - p1[0]) ** 2 + (y - p1[1]) ** 2, distance ** 2)\n        generated_eqs.append(eq)\n    return generated_eqs"], ["def distance_point_plane(point, plane_coefficients):\n    \"\"\"\n    Calculate the shortest distance from a point to a plane in 3D.\n    \n    Parameters:\n    - point (array-like): The coordinates of the point.\n    - plane_coefficients (tuple): The coefficients (A, B, C, D) of the plane Ax + By + Cz + D = 0.\n    \n    Returns:\n    - float: The shortest distance from the point to the plane.\n    \n    Example:\n    >>> distance_point_plane([1, 2, 2], (1, 0, 0, -2))\n    1.0\n    \"\"\"\n    A, B, C, D = plane_coefficients\n    x, y, z = point\n    num = abs(A*x + B*y + C*z + D)\n    den = np.sqrt(A**2 + B**2 + C**2)\n    return num / den"], ["def plot_complex_numbers(numbers):\n    \"\"\"\n    Plot complex numbers on the complex plane.\n    \n    Parameters:\n        numbers (list of complex): List of complex numbers to plot.\n    \n    Returns:\n        None, but plots the points on a 2D complex plane (Cartesian plane interpreted).\n    \"\"\"\n    plt.figure(figsize=(6,6))\n    for number in numbers:\n        plt.plot([0, number.real], [0, number.imag], 'bo-')\n    \n    plt.axhline(0, color='black',linewidth=0.5)\n    plt.axvline(0, color='black',linewidth=0.5)\n    plt.xlabel('Real')\n    plt.ylabel('Imaginary')\n    plt.grid(True)\n    plt.show()"], ["def solve_geometric_system(equations):\n    \"\"\"\n    Solve a system of equations typically derived from geometric constraints.\n    Parameters:\n    - equations (list): A list of `sympy.Eq` objects representing the equations.\n    Returns:\n    - dict: A dictionary of solutions in terms of the involved symbols.\n    Examples:\n    >>> x, y = symbols('x y')\n    >>> eq1 = Eq(x + y, 10)\n    >>> eq2 = Eq(x - y, 4)\n    >>> solve_geometric_system([eq1, eq2])\n    {x: 7, y: 3}\n    \"\"\"\n    return solve(equations)"], ["def vector_from_points(point1, point2):\n    \"\"\"\n    Calculate the vector from point1 to point2 in 3D.\n    \n    Parameters:\n    - point1 (array-like): Coordinates of the first point.\n    - point2 (array-like): Coordinates of the second point.\n    \n    Returns:\n    - numpy.ndarray: The vector from point1 to point2.\n    \n    Example:\n    >>> vector_from_points([1, 2, 3], [4, 5, 6])\n    array([3, 3, 3])\n    \"\"\"\n    return np.array(point2) - np.array(point1)"], ["def plane_from_points(p1, p2, p3):\n    \"\"\"\n    Determine the plane equation coefficients from three points in 3D.\n    \n    Parameters:\n    - p1, p2, p3 (array-like): Coordinates of the three points.\n    \n    Returns:\n    - tuple: Coefficients of the plane in the form (A, B, C, D) of Ax + By + Cz + D = 0.\n    \n    Example:\n    >>> plane_from_points([1, 1, 1], [2, 2, 2], [3, 4, 5])\n    (2, -1, 0, -1)\n    \"\"\"\n    v1 = vector_from_points(p1, p2)\n    v2 = vector_from_points(p1, p3)\n    normal = cross_product(v1, v2)\n    A, B, C = normal\n    D = -np.dot(normal, p1)\n    return A, B, C, D", "def plane_from_points(p1, p2, p3):\n    \"\"\"\n    Generates the equation of a plane in 3D space given three points.\n    Parameters\n    ----------\n    p1, p2, p3 : array_like\n        Coordinates (x, y, z) of the three points.\n    Returns\n    -------\n    tuple\n        Coefficients (A, B, C, D) of the plane equation Ax + By + Cz + D = 0.\n    Examples\n    --------\n    >>> plane_from_points([0, 0, 0], [1, 0, 0], [0, 1, 0])\n    (0, 0, -1, 0)\n    \"\"\"\n    p1, p2, p3 = np.array(p1), np.array(p2), np.array(p3)\n    vec1 = p2 - p1\n    vec2 = p3 - p1\n    normal_vector = np.cross(vec1, vec2)\n    A, B, C = normal_vector\n    D = -np.dot(normal_vector, p1)\n    return (A, B, C, D)", "def plane_equation_from_points(p1, p2, p3):\n    \"\"\"\n    Determine the equation of a plane given three points in 3D space.\n    \n    Parameters:\n        p1, p2, p3 (np.array): Three points in 3D space.\n    \n    Returns:\n        tuple: Coefficients of the plane equation Ax + By + Cz = D.\n    \n    Example:\n        >>> plane_equation_from_points(np.array([0, 0, 1]), np.array([1, 0, 0]), np.array([0, 1, 0]))\n        (1, 1, 1, 1)\n    \"\"\"\n    v1 = vector_subtract(p2, p1)\n    v2 = vector_subtract(p3, p1)\n    normal = cross_product(v1, v2)\n    d = dot_product(normal, p1)\n    return (*normal, d)", "def plane_equation_from_points(p1, p2, p3):\n    \"\"\"\n    Derives the equation of a plane from three points on the plane in the form Ax + By + Cz = D.\n    Parameters:\n    p1, p2, p3 (ndarray): Numpy arrays representing the coordinates of the points.\n    Returns:\n    tuple: Coefficients (A, B, C, D) defining the plane.\n    \"\"\"\n    normal = plane_normal_from_points(p1, p2, p3)\n    D = dot_product(normal, p1)\n    return (*normal, D)"], ["def circle_equation(center, radius):\n    \"\"\"Generate the equation of a circle given the center and radius.\n    Parameters:\n        center (tuple): Coordinates of the center of the circle (x, y).\n        radius (float): The radius of the circle.\n    Returns:\n        sympy.Eq: The equation of the circle.\n    Examples:\n        >>> circle_equation((0, 0), 5)\n        Eq(x**2 + y**2, 25)\n    \"\"\"\n    x, y = symbols('x y')\n    x0, y0 = center\n    return Eq((x - x0)**2 + (y - y0)**2, radius**2)"], ["def square_side_from_diagonal(diagonal):\n    \"\"\"\n    Calculate the side length of a square given the diagonal, using the Pythagorean theorem.\n    Parameters:\n    diagonal (float): The length of the diagonal of the square.\n    Returns:\n    float: The length of one side of the square.\n    Examples:\n    >>> square_side_from_diagonal(5.656854249492381)\n    4.0\n    \"\"\"\n    return diagonal / np.sqrt(2)"], ["def perpendicular_foot(point, line):\n    \"\"\"\n    Finds the coordinates of the foot of the perpendicular from a point to a line.\n    \n    Parameters\n    ----------\n    point : tuple\n        Coordinates of the point (x, y).\n    line : tuple\n        Coefficients (m, c) of the line equation y = mx + c.\n    \n    Returns\n    -------\n    tuple\n        Coordinates of the foot of the perpendicular.\n    \n    Examples\n    --------\n    >>> perpendicular_foot((2, 3), (1, 1))\n    (1.0, 2.0)\n    \"\"\"\n    x, y = point\n    m, c = line\n    m_perp = find_perpendicular_slope(m)\n    \n    # Equation of the perpendicular line: y = m_perp*x + b\n    b = y - m_perp * x\n    \n    # Solve y = mx + c and y = m_perp*x + b\n    x_foot = (b - c) / (m - m_perp)\n    y_foot = m * x_foot + c\n    \n    return (x_foot, y_foot)"], ["def vector_magnitude(vector):\n    \"\"\"\n    Calculates the magnitude (norm) of a vector.\n    Parameters:\n    vector (ndarray): The vector whose magnitude is to be calculated.\n    Returns:\n    float: The magnitude of the vector.\n    \"\"\"\n    return np.linalg.norm(vector)"], ["def plot_points(points, labels=None, style='bo'):\n    \"\"\"\n    Plot points on a 2D Cartesian plane.\n    \n    Parameters:\n        points (list of tuples): List of (x, y) coordinates to plot.\n        labels (list of str, optional): Labels for each point. Defaults to None.\n        style (str): Style string for plotting. Defaults to 'bo' (blue circles).\n    \n    Examples:\n        plot_points([(0,0), (1,2), (2,3)], labels=['A', 'B', 'C'])\n    \"\"\"\n    for i, (x, y) in enumerate(points):\n        plt.plot(x, y, style)\n        if labels:\n            plt.text(x, y, f' {labels[i]}', fontsize=12, verticalalignment='bottom')\n    plt.axhline(0, color='grey', lw=0.5)\n    plt.axvline(0, color='grey', lw=0.5)\n    plt.grid(True)\n    plt.show()"], ["def parametric_point_evaluation(param_eqs, t_values):\n    \"\"\"\n    Evaluate parametric equations at given parameter values.\n    \n    Parameters:\n        param_eqs (dict): A dictionary with variables as keys and their parametric equations as values.\n        t_values (list or scalar): A scalar or list of values to substitute into the parametric equations.\n    \n    Returns:\n        list or dict: Evaluated points at each parameter value.\n    \n    Example:\n        x, y, t = symbols('x y t')\n        param_eqs = {x: t**2, y: t + 1}\n        points = parametric_point_evaluation(param_eqs, [0, 1, 2])\n        print(points)  # Output: [{x: 0, y: 1}, {x: 1, y: 2}, {x: 4, y: 3}]\n    \"\"\"\n    results = []\n    for t_value in t_values:\n        point = {var: eq.subs('t', t_value) for var, eq in param_eqs.items()}\n        results.append(point)\n    return results"], ["def solve_linear_equations(A, b):\n    \"\"\"\n    Solve a system of linear equations Ax = b for x using NumPy.\n    Parameters:\n    - A (array-like): coefficient matrix.\n    - b (array-like): constant terms.\n    Returns:\n    - array: solution vector x.\n    Examples:\n    >>> solve_linear_equations([[1, 1], [1, -1]], [10, 2])\n    array([6., 4.])\n    \"\"\"\n    A = np.array(A)\n    b = np.array(b)\n    x = np.linalg.solve(A, b)\n    return x"], ["def point_on_line(line, point):\n    \"\"\"\n    Determines whether a given point lies on a specified line.\n    Parameters\n    ----------\n    line : tuple\n        Coefficients (m, c) of the line equation y = mx + c.\n    point : tuple\n        Coordinates of the point (x, y).\n    \n    Returns\n    -------\n    bool\n        True if the point lies on the line, False otherwise.\n    \n    Examples\n    --------\n    >>> point_on_line((2, 1), (1, 3))\n    True\n    \"\"\"\n    m, c = line\n    x, y = point\n    return y == m * x + c"], ["def midpoint(point1, point2):\n    \"\"\"\n    Calculates the midpoint between two points in Cartesian space.\n    \n    Parameters:\n        point1 (tuple): The (x, y[, z]) coordinates of the first point.\n        point2 (tuple): The (x, y[, z]) coordinates of the second point.\n    \n    Returns:\n        tuple: A tuple representing the coordinates of the midpoint.\n    \n    Examples:\n        >>> midpoint((1, 2), (3, 4))\n        (2.0, 3.0)\n        >>> midpoint((1, 2, 3), (4, 5, 6))\n        (2.5, 3.5, 4.5)\n    \"\"\"\n    if len(point1) != len(point2):\n        raise ValueError(\"Both points must have the same number of dimensions\")\n    return tuple((p1 + p2) / 2 for p1, p2 in zip(point1, point2))", "def midpoint(p1, p2):\n    \"\"\"\n    Find the midpoint between two points.\n    \n    Parameters:\n        p1, p2 (tuple): Points in the form (x, y).\n    \n    Returns:\n        tuple: The midpoint between p1 and p2.\n    \"\"\"\n    return ((p1[0] + p2[0]) / 2, (p1[1] + p2[1]) / 2)", "def midpoint_3d(point1, point2):\n    \"\"\"\n    Find the midpoint between two points in 3D space.\n    Parameters:\n    - point1 (tuple or list): The (x, y, z) coordinates of the first point.\n    - point2 (tuple or list): The (x, y, z) coordinates of the second point.\n    Returns:\n    - tuple: The (x, y, z) coordinates of the midpoint.\n    Examples:\n    >>> midpoint_3d((1, 2, 3), (4, 6, 8))\n    (2.5, 4.0, 5.5)\n    \"\"\"\n    return tuple((p1 + p2) / 2 for p1, p2 in zip(point1, point2))", "def calculate_midpoint(point1, point2):\n    \"\"\"\n    Calculate the midpoint between two points in a 2D coordinate system.\n    \n    Parameters:\n        point1 (tuple): A tuple (x1, y1) representing the coordinates of the first point.\n        point2 (tuple): A tuple (x2, y2) representing the coordinates of the second point.\n    \n    Returns:\n        tuple: The midpoint (xm, ym) of the line segment joining the two points.\n    \n    Examples:\n        >>> calculate_midpoint((1, 2), (3, 4))\n        (2.0, 3.0)\n        >>> calculate_midipyramid((-1, -1), (1, 1))\n        (0.0, 0.0)\n    \"\"\"\n    x1, y1 = point1\n    x2, y2 = point2\n    return ((x1 + x2) / 2, (y1 + y2) / 2)", "def find_midpoint(point1, point2):\n    \"\"\"\n    Calculate the midpoint between two points in Cartesian coordinates.\n    Parameters:\n    ----------\n    point1 : tuple\n        A tuple (x1, y1) representing the coordinates of the first point.\n    point2 : tuple\n        A tuple (x2, y2) representing the coordinates of the second point.\n    Returns:\n    -------\n    tuple\n        A tuple (mx, my) representing the coordinates of the midpoint.\n    Example:\n    -------\n    >>> find_midpoint((1, 2), (3, 4))\n    (2.0, 3.0)\n    \"\"\"\n    return tuple((np.array(point1) + np.array(point2)) / 2)", "def midpoint_of_segment(p1, p2):\n    \"\"\"\n    Calculate the midpoint of a segment given the endpoints.\n    Parameters:\n    - p1 (tuple): The coordinates (x1, y1) of the first endpoint.\n    - p2 (tuple): The coordinates (x2, y2) of the second endpoint.\n    \n    Returns:\n    - tuple: The coordinates (xm, ym) of the midpoint.\n    Example:\n    >>> midpoint_of_segment((1, 2), (3, 4))\n    (2.0, 3.0)\n    \"\"\"\n    return ((p1[0] + p2[0]) / 2, (p1[1] + p2[1]) / 2)", "def midpoint(p1, p2):\n    \"\"\"\n    Find the midpoint between two points in 2D or 3D.\n    \n    Parameters:\n        p1 (tuple): Coordinates of the first point.\n        p2 (tuple): Coordinates of the second point.\n    \n    Returns:\n        tuple: Coordinates of the midpoint between p1 and p2.\n    \n    Examples:\n    >>> midpoint((1, 1), (3, 3))\n    (2.0, 2.0)\n    >>> midpoint((1, 2, 3), (5, 6, 9))\n    (3.0, 4.0, 6.0)\n    \"\"\"\n    p1 = np.array(p1)\n    p2 = np.array(p2)\n    return tuple((p1 + p2) / 2)", "def midpoint(point1, point2):\n    \"\"\"\n    Calculate the midpoint between two points in 2D space.\n    Parameters:\n        point1 (tuple): The (x, y) coordinates of the first point.\n        point2 (tuple): The (x, y) coordinates of the second point.\n    Returns:\n        tuple: The (x, y) coordinates of the midpoint.\n    \n    Examples:\n        >>> midpoint((1, 2), (3, 4))\n        (2.0, 3.0)\n    \"\"\"\n    return tuple((np.array(point1) + np.array(point2)) / 2)", "def compute_midpoint(point1, point2):\n    \"\"\"\n    Calculate the midpoint between two points in 2D space.\n    Parameters:\n    - point1 (tuple): Coordinates of the first point (x1, y1).\n    - point2 (tuple): Coordinates of the second point (x2, y2).\n    Returns:\n    - tuple: The midpoint coordinates (x, y).\n    Examples:\n    >>> compute_midpoint((1, 2), (3, 4))\n    (2.0, 3.0)\n    \"\"\"\n    return ((point1[0] + point2[0]) / 2, (point1[1] + point2[1]) / 2)", "def calculate_midpoint(p1, p2):\n    \"\"\"\n    Calculate the midpoint of a line segment given two endpoints in 2D or 3D.\n    Parameters:\n    - p1 (tuple of floats): coordinates of the first point (x1, y1) or (x1, y1, z1).\n    - p2 (tuple of floats): coordinates of the second point (x2, y2) or (x2, y2, z2).\n    Returns:\n    - tuple: coordinates of the midpoint.\n    Examples:\n    >>> calculate_midpoint((1, 2), (3, 4))\n    (2.0, 3.0)\n    \n    >>> calculate_midpoint((1, 2, 3), (4, 6, 8))\n    (2.5, 4.0, 5.5)\n    \"\"\"\n    return tuple((x1 + x2) / 2 for x1, x2 in zip(p1, p2))", "def midpoint(point1, point2):\n    \"\"\"\n    Calculate the midpoint between two points in the Cartesian plane.\n    \n    Parameters:\n        point1 (tuple): Coordinates (x, y) of the first point.\n        point2 (tuple): Coordinates (x, y) of the second point.\n    \n    Returns:\n        tuple: Coordinates (x, y) of the midpoint.\n        \n    Examples:\n        midpoint((1, 2), (3, 4))\n    \"\"\"\n    return ((point1[0] + point2[0]) / 2, (point1[1] + point2[1]) / 2)", "def midpoint(p1, p2):\n    \"\"\"\n    Calculates the midpoint between two points in a 2D coordinate system.\n    Parameters:\n    - p1: Tuple of coordinates (x1, y1) for the first point.\n    - p2: Tuple of coordinates (x2, y2) for the second point.\n    Returns:\n    - Tuple: Coordinates of the midpoint.\n    Example:\n    >>> midpoint((1, 2), (3, 4))\n    (2.0, 3.0)\n    \"\"\"\n    return tuple((np.array(p1) + np.array(p2)) / 2)"], ["def reflection_point_across_line(line, point):\n    \"\"\"\n    Finds the reflection of a point across a given line.\n    \n    Parameters\n    ----------\n    line : tuple\n        Coefficients (m, c) of the line equation y = mx + c.\n    point : tuple\n        Coordinates of the point (x, y).\n    \n    Returns\n    -------\n    tuple\n        Coordinates (x', y') of the reflected point.\n    \n    Examples\n    --------\n    >>> reflection_point_across_line((1, 1), (2, 3))\n    (-1.0, 0.0)\n    \"\"\"\n    m, c = line\n    x, y = point\n    d = (x + (y - c) * m) / (1 + m**2)\n    x_ref = 2*d - x\n    y_ref = 2*d*m - y + 2*c\n    return (x_ref, y_ref)"], ["class Triangle:\n    \"\"\"\n    This class represents a Triangle in 2D geometry.\n    \n    Attributes:\n        p1, p2, p3 (Point): The three vertices of the Triangle.\n    \"\"\"\n    \n    def __init__(self, p1, p2, p3):\n        \"\"\"\n        The constructor for the Triangle class. It initializes the vertices of the Triangle.\n        \n        Parameters:\n            p1, p2, p3 (Point): The vertices of the triangle.\n        \"\"\"\n        self.p1 = p1\n        self.p2 = p2\n        self.p3 = p3\n    def area(self):\n        \"\"\"\n        This method calculates the area of the Triangle.\n        \n        Returns:\n            float: The area of the triangle.\n        \"\"\"\n        return abs(0.5 * (self.p1.x*(self.p2.y-self.p3.y) + self.p2.x*(self.p3.y-self.p1.y) + self.p3.x*(self.p1.y-self.p2.y)))", "class Square:\n    \"\"\"\n    This class represents a Square in 2D geometry.\n    \n    Attributes:\n        p1, p2, p3, p4 (Point): The four vertices of the Square.\n    \"\"\"\n    \n    def __init__(self, p1, p2, p3, p4):\n        \"\"\"\n        The constructor for the Square class. It initializes the vertices of the Square.\n        \n        Parameters:\n            p1, p2, p3, p4 (Point): The vertices of the square.\n        \"\"\"\n        self.p1 = p1\n        self.p2 = p2\n        self.p3 = p3\n        self.p4 = p4\n    def area(self):\n        \"\"\"\n        This method calculates the area of the Square.\n        \n        Returns:\n            float: The area of the square.\n        \"\"\"\n        return self.p1.distance(self.p2)**2"], ["def compute_conic_properties(eq_type, standard_params):\n    \"\"\"\n    Compute geometric properties such as center, foci, vertices, depending on the conic type.\n    Parameters:\n    - eq_type (str): Type of conic ('circle', 'ellipse', 'parabola', 'hyperbola').\n    - standard_params (dict): Parameters obtained from the standard form conversion.\n    Returns:\n    - dict: Detailed conic properties.\n    Example:\n    >>> compute_conic_properties('circle', {'center': (3, -2), 'radius': 4})\n    {'center': (3, -2), 'foci': [(3, -2), (3, -2)], 'radius': 4}\n    \"\"\"\n    import math\n    if eq_type == 'circle':\n        center = standard_params['center']\n        radius = standard_params['radius']\n        return {'center': center, 'foci': [center, center], 'radius': radius}\n    elif eq_type == 'ellipse':\n        # Calculate foci, vertices based on semi-major/minor axes.\n        pass\n    elif eq_type == 'parabola':\n        # Vertex, focus calculation.\n        pass\n    elif eq_type == 'hyperbola':\n        # Center, foci, vertices, and asymptotes.\n        pass\n    return {}"], ["def polygon_properties(vertices):\n    \"\"\"\n    Calculate the area of a polygon given its vertices and check if it is a regular shape like\n    rectangle or square.\n    \n    Parameters:\n        vertices (list of tuples): A list of (x, y) coordinates for the vertices of the polygon.\n                                   The vertices must be in order, either clockwise or counter-clockwise.\n    \n    Returns:\n        float: The area of the polygon.\n        bool: True if the polygon is a rectangle.\n        bool: True if the polygon is a square.\n    \n    Examples:\n        >>> polygon_properties([(0, 0), (4, 0), (4, 4), (0, 4)])  # Square\n        (16, True, True)\n        >>> polygon_properties([(0, 0), (4, 0), (4, 3), (0, 3)])  # Rectangle\n        (12, True, False)\n    \"\"\"\n    num_vertices = len(vertices)\n    area = 0\n    for i in range(num_vertices):\n        j = (i + 1) % num_vertices\n        area += vertices[i][0] * vertices[j][1]\n        area -= vertices[j][0] * vertices[i][1]\n    area = abs(area) / 2.0\n    \n    # Check for rectangle or square\n    lengths = [calculate_distance_and_midpoint(vertices[i], vertices[(i+1) % num_vertices])[0] for i in range(num_vertices)]\n    is_rectangle = len(set(lengths)) <= 2  # In a rectangle, opposite sides are equal\n    is_square = is_rectangle and len(set(lengths)) == 1  # All sides equal\n    \n    return area, is_rectangle, is_square"], ["def circle_equation(cartesian_point_hk, radius):\n    \"\"\"\n    Provides the equation of a circle in Cartesian coordinates.\n    Parameters:\n    cartesian_point_hk (tuple): (h, k) the center of the circle in Cartesian coordinates\n    radius (float): the radius of the circle\n    Returns:\n    function: Function that calculates (x - h)² + (y - k)² - r² for given x, y\n    \"\"\"\n    h, k = cartesian_point_hk\n    def equation(x, y):\n        return (x - h)**2 + (y - k)**2 - radius**2\n    return equation"], ["def rectangle_properties(length, width):\n    \"\"\"\n    Calculate various properties of a rectangle given its length and width.\n    Parameters:\n    - length (float): The length of the rectangle.\n    - width (float): The width of the rectangle.\n    Returns:\n    - dict: Dictionary containing the perimeter, area, and diagonal of the rectangle.\n    Examples:\n    >>> rectangle_properties(4, 3)\n    {'perimeter': 14, 'area': 12, 'diagonal': 5.0}\n    \"\"\"\n    import math\n    perimeter = 2 * (length + width)\n    area = length * width\n    diagonal = math.sqrt(length**2 + width**2)\n    return {'perimeter': perimeter, 'area': area, 'diagonal': diagonal}"], ["def line_equation(x1, y1, x2, y2, return_symbolic=True):\n    \"\"\"\n    Generate the equation of the line passing through two points (x1, y1) and (x2, y2).\n    \n    Parameters:\n        x1, y1 (float): Coordinates of the first point.\n        x2, y2 (float): Coordinates of the second point.\n        return_symbolic (bool): If True, returns a symbolic equation, otherwise returns slope and intercept.\n    \n    Returns:\n        sympy.Eq or tuple: Depending on return_symbolic flag, returns the symbolic equation or a tuple (slope, intercept).\n    \"\"\"\n    m = slope(x1, y1, x2, y2)\n    if m is None:  # Vertical line\n        if return_symbolic:\n            return sp.Eq(sp.Symbol('x'), x1)\n        else:\n            return None, x1  # No slope, x-intercept is x1\n    \n    # Equation of the line: y = mx + c; solve for c\n    c = y1 - m * x1\n    if return_symbolic:\n        x, y = sp.symbols('x y')\n        return sp.Eq(y, m * x + c)\n    else:\n        return m, c"], ["def plot_points(points):\n    \"\"\"\n    Plot points on the Cartesian plane.\n    \n    Parameters:\n        points (list of tuples): List of points, where each point is represented as a tuple (x, y).\n    \n    Returns:\n        None, but plots the points on a 2D Cartesian coordinate system.\n    \"\"\"\n    x_vals, y_vals = zip(*points)\n    plt.figure(figsize=(6,6))\n    plt.scatter(x_vals, y_vals, color='red')\n    plt.axhline(0, color='black',linewidth=0.5)\n    plt.axvline(0, color='black',linewidth=0.5)\n    plt.grid(True)\n    plt.show()"], ["def is_collinear(points):\n    \"\"\"\n    Check if all points given are collinear.\n    \n    Parameters:\n    - points (list of tuples): List of points (x, y) to be checked.\n    \n    Returns:\n    - bool: True if all points are collinear, False otherwise.\n    Example:\n    >>> is_collinear([(1, 2), (2, 4), (3, 6)])\n    True\n    \"\"\"\n    if len(points) < 3:\n        return True  # Two points are always collinear\n    x1, y1 = points[0]\n    x2, y2 = points[1]\n    for (x, y) in points[2:]:\n        if (x2 - x1) * (y - y1) != (y2 - y1) * (x - x1):\n            return False\n    return True"], ["def midpoint(point1, point2):\n    \"\"\"Calculate the midpoint between two points in n-dimensional space.\n    Parameters:\n        point1 (array-like): The first point coordinates.\n        point2 (array-like): The second point coordinates.\n    Returns:\n        ndarray: The coordinates of the midpoint.\n    Examples:\n        >>> midpoint([1, 2], [3, 4])\n        array([2., 3.])\n    \"\"\"\n    return (np.array(point1) + np.array(point2)) / 2"], ["def point_line_position(point, line):\n    \"\"\"\n    Determine the relative position of a point with respect to a line.\n    \n    Parameters:\n    - point (tuple): The point (x, y).\n    - line (tuple): The slope and intercept (m, c) of the line.\n    \n    Returns:\n    - str: 'above', 'below' or 'on' the line\n    \n    Examples:\n    >>> point_line_position((3, 4), (1, 1))\n    'above'\n    \"\"\"\n    x, y = point\n    m, c = line\n    line_y = m * x + c\n    if y > line_y:\n        return 'above'\n    elif y < line_y:\n        return 'below'\n    else:\n        return 'on'"], ["def centroid_of_polygon(vertices):\n    \"\"\"\n    Calculate the centroid (geometric center) of a polygon defined by its vertex coordinates.\n    Parameters\n    ----------\n    vertices : list of tuples\n        List of tuples each representing the (x, y) coordinate of a vertex.\n    Returns\n    -------\n    tuple\n        The (x, y) coordinates of the centroid.\n    Example\n    -------\n    >>> centroid_of_polygon([(1, 0), (3, 0), (2, 2)])\n    (2.0, 0.666666666667)\n    \"\"\"\n    x_coords, y_coords = zip(*vertices)\n    area = 0.5 * np.abs(np.dot(x_coords, np.roll(y_coords, 1)) - np.dot(y_coords, np.roll(x_coords, 1)))\n    factor = 1 / (6 * area)\n    cx = factor * (np.sum((np.array(x_coords) + np.roll(x_coords, 1)) * (np.array(x_coords) * np.roll(y_coords, 1) - np.roll(x_coords, 1) * np.array(y_coords))))\n    cy = factor * (np.sum((np.array(y_coords) + np.roll(y_coords, 1)) * (np.array(x_coords) * np.roll(y_coords, 1) - np.roll(x_coords, 1) * np.array(y_coords))))\n    return (cx, cy)"], ["def distance(x1, y1, x2, y2):\n    \"\"\"\n    Calculate the Euclidean distance between two points (x1, y1) and (x2, y2).\n    \n    Parameters:\n        x1, y1, x2, y2 (float): Coordinates of the two points.\n        \n    Returns:\n        float: The distance between the two points.\n    \"\"\"\n    return sp.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2)"], ["def is_regular_polygon(vertices):\n    \"\"\"\n    Checks if a given polygon is regular (i.e., all sides and angles are equal).\n    Parameters:\n    - vertices: A list of tuples representing the vertices of the polygon in the order they are connected.\n    Returns:\n    - bool: True if the polygon is regular, False otherwise.\n    Example:\n    >>> is_regular_polygon([(0,0), (1,0), (0.5, np.sqrt(3)/2)])\n    True # This is an equilateral triangle\n    \"\"\"\n    polygon = Polygon(*[Point(x, y) for x, y in vertices])\n    sides_set = set(polygon.sides_length)\n    return len(sides_set) == 1"], ["def area_of_circle(r):\n    \"\"\"\n    Calculates the area of a circle given its radius.\n    Parameters:\n    r (float): The radius of the circle.\n    Returns:\n    float: The area of the circle.\n    Examples:\n    >>> area_of_circle(1)\n    3.141592653589793\n    \"\"\"\n    return np.pi * r**2"]], "Rectangles": [["def calculate_square_area(side_length):\n    \"\"\"\n    Calculate the area of a square given its side length.\n    Parameters:\n    - side_length (float): The length of a side of the square.\n    Returns:\n    - float: The area of the square.\n    Example:\n    >>> calculate_square_area(4)\n    16\n    \"\"\"\n    return calculate_rectangle_area(side_length, side_length)", "def find_square_side_length_given_area(area):\n    \"\"\"\n    Calculate the side length of a square given its area.\n    \n    Parameters:\n    - area (float): The area of the square.\n    \n    Returns:\n    - float: The side length of the square.\n    \n    Example:\n    >>> find_square_side_length_given_area(16)\n    4.0\n    \"\"\"\n    return math.sqrt(area)", "def calculate_square_area(side_length):\n    \"\"\"\n    Calculate the area of a square given its side length.\n    \n    Parameters\n    ----------\n    side_length : float or int\n        The length of a side of the square.\n    \n    Returns\n    -------\n    float\n        The area of the square.\n    \n    Examples\n    --------\n    >>> calculate_square_area(4)\n    16\n    \n    >>> calculate_square_area(5.5)\n    30.25\n    \"\"\"\n    return side_length ** 2", "def calculate_side_length_from_square_area(area):\n    \"\"\"\n    Calculate the side length of a square given its area.\n    \n    Parameters\n    ----------\n    area : float or int\n        The area of the square.\n    \n    Returns\n    -------\n    float\n        The side length of the square.\n    \n    Examples\n    --------\n    >>> calculate_side_length_from_square(resoult_area(16)\n    4\n    \n    >>> calculate_side_length_from_square_area(30.25)\n    5.5\n    \"\"\"\n    import math\n    return math.sqrt(area)", "def calculate_square_area(side_length):\n    \"\"\"\n    Calculate the area of a square given the side length.\n    Parameters:\n    side_length (float): The length of a side of the square.\n    Returns:\n    float: The area of the square.\n    Examples:\n    >>> calculate_square_area(4)\n    16\n    \"\"\"\n    return side_length ** 2", "def side_length_from_area(area):\n    \"\"\"\n    Determine the side length of a square from its area.\n    Parameters:\n    area (float): The area of the square.\n    Returns:\n    float: The side length of the square.\n    Examples:\n    >>> side_length_fromside_length_from_area(16)\n    4\n    \"\"\"\n    return math.sqrt(area)"], ["def rectangle_perimeter(length, width):\n    \"\"\"\n    Calculates the perimeter of a rectangle.\n    \n    Parameters:\n        length (float): The length of the rectangle.\n        width (float): The width of the rectangle.\n        \n    Returns:\n        float: The perimeter of the rectangle.\n        \n    Examples:\n    >>> rectangle_perimeter(5, 4)\n    18\n    \"\"\"\n    return 2 * (length + width)", "def calculate_rectangle_perimeter(length, width):\n    \"\"\"\n    Calculate the perimeter of a rectangle given its length and width.\n    Parameters:\n    length (float): The length of the rectangle.\n    width (float): The width of the rectangle.\n    Returns:\n    float: The perimeter of the rectangle.\n    Examples:\n    >>> calculate_rectangle_perimeter(5, 3)\n    16\n    >>> calculate_rectangle_perimeter(8, 2)\n    20\n    \"\"\"\n    perimeter = 2 * (length + width)\n    return perimeter", "def calculate_rectangle_perimeter(width, height):\n    \"\"\"\n    Calculate the perimeter of a rectangle given its width and height.\n    \n    Parameters:\n    - width (float): The width of the rectangle.\n    - height (float): The height of the rectangle.\n    \n    Returns:\n    - float: The perimeter of the rectangle.\n    \n    Example:\n    >>> calculate_rectangle_perimeter(5, 3)\n    16\n    \"\"\"\n    return 2 * (width + height)", "def compute_rectangle_perimeter(width, height):\n    \"\"\"\n    Calculate the perimeter of a rectangle given its width and height.\n    Parameters:\n    width (float): The width of the rectangle.\n    height (float): The height of the rectangle.\n    Returns:\n    float: The perimeter of the rectangle.\n    Examples:\n    >>> compute_rectangle_perimeter(4, 5)\n    18.0\n    \"\"\"\n    return 2 * (width + height)", "def calculate_rectangle_perimeter(length, width):\n    \"\"\"\n    Calculate the perimeter of a rectangle.\n    Parameters:\n    length (float): The length of the rectangle.\n    width (float): The width of the rectangle.\n    Returns:\n    float: The perimeter of the rectangle.\n    \n    Examples:\n    >>> calculate_rectangle_perimeter(5, 3)\n    16\n    >>> calculate_rectangle_perimeter(8, 7)\n    30\n    \"\"\"\n    return 2 * (length + width)", "def rectangle_perimeter(length, width):\n    \"\"\"\n    Calculate the perimeter of a rectangle.\n    Parameters:\n    length (float): the length of the rectangle.\n    width (float): the width of the rectangle.\n    Returns:\n    float: the calculated perimeter of the rectangle.\n    \n    Example:\n    >>> rectangle_perimeter(5, 3)\n    16\n    \"\"\"\n    return 2 * (length + width)", "def calculate_rectangle_perimeter(length, width):\n    \"\"\"\n    Calculate the perimeter of a rectangle.\n    \n    Parameters:\n        length (float): The length of the rectangle.\n        width (float): The width of the rectangle.\n    \n    Returns:\n        float: The calculated perimeter of the rectangle.\n    \n    Examples:\n        >>> calculate_rectangle_perimeter(5, 3)\n        16\n    \"\"\"\n    return 2 * (length + width)"], ["def is_rectangle_by_sides(a, b, c, d):\n    \"\"\"\n    Checks if the given four sides can form a rectangle, based on the property that opposite sides must be equal.\n    \n    Parameters:\n        a, b, c, d (float): The lengths of the four sides.\n        \n    Returns:\n        bool: True if the sides can form a rectangle, False otherwise.\n        \n    Examples:\n    >>> is_rectangle_by_sides(5, 10, 5, 10)\n    True\n    >>> is_rectangle_by_sides(4, 5, 4, 6)\n    False\n    \"\"\"\n    return (a == c and b == d) or (a == b and c == d)", "def is_rectangle_by_sides(a, b, c, d):\n    \"\"\"\n    Determine if a quadrilateral is a rectangle based on side lengths and angles.\n    Parameters:\n    a, b, c, d (float): lengths of the sides.\n    Returns:\n    bool: True if the quadrilateral could be a rectangle, False otherwise.\n    Example:\n    >>> is_rectangle_by_sides(5, 5, 3, 3)\n    True\n    \"\"\"\n    return (a == c) and (b == d)"], ["def calculate_square_perimeter(side_length):\n    \"\"\"\n    Calculate the perimeter of a square given its side length.\n    \n    Parameters:\n    - side_length (float): The length of a side of the square.\n    \n    Returns:\n    - float: The perimeter of the square.\n    \n    Example:\n    >>> calculate_square_perimeter(4)\n    16\n    \"\"\"\n    return 4 * side_length", "def calculate_square_perimeter(side_length):\n    \"\"\"\n    Calculate the perimeter of a square given its side length.\n    \n    Parameters\n    ----------\n    side_length : float or int\n        The length of a side of the square.\n    \n    Returns\n    -------\n    float\n        The perimeter of the square.\n    \n    Examples\n    --------\n    >>> calculate_square_perimeter(4)\n    16\n    \n    >>> calculate_square_perimeter(5.5)\n    22\n    \"\"\"\n    return 4 * side_length", "def calculate_square_perimeter(side_length):\n    \"\"\"\n    Calculate the perimeter of a square given the side length.\n    Parameters:\n    side_length (float): The length of a side of the square.\n    Returns:\n    float: The perimeter of the square.\n    Examples:\n    >>> calculate_square_perimeter(4)\n    16\n    \"\"\"\n    return 4 * side_length"], ["def rectangle_area(length, width):\n    \"\"\"\n    Calculates the area of a rectangle.\n    \n    Parameters:\n        length (float): The length of the rectangle.\n        width (float): The width of the rectangle.\n        \n    Returns:\n        float: The area of the rectangle.\n        \n    Examples:\n    >>> rectangle_area(5, 4)\n    20\n    \"\"\"\n    return length * width", "def calculate_rectangle_area(length, width):\n    \"\"\"\n    Calculate the area of a rectangle using its length and width.\n    Parameters:\n    length (float): The length of the rectangle.\n    width (float): The width of the rectangle.\n    Returns:\n    float: The area of the rectangle.\n    Examples:\n    >>> calculate_rectangle_area(5, 3)\n    15\n    >>> calculate_rectangle_area(8, 2)\n    16\n    \"\"\"\n    area = length * width\n    return area", "def calculate_rectangle_area(width, height):\n    \"\"\"\n    Calculate the area of a rectangle given its width and height.\n    Parameters:\n    - width (float): The width of the rectangle.\n    - height (float): The height of the rectangle.\n    Returns:\n    - float: The area of the rectangle.\n    Example:\n    >>> calculate_rectangle_area(5, 3)\n    15\n    \"\"\"\n    return width * height", "def compute_rectangle_area(width, height):\n    \"\"\"\n    Calculate the area of a rectangle given its width and height.\n    Parameters:\n    width (float): The width of the rectangle.\n    height (float): The height of the rectangle.\n    Returns:\n    float: The area of the rectangle.\n    Examples:\n    >>> compute_rectangle_area(4, 5)\n    20.0\n    \"\"\"\n    return width * height", "def calculate_rectangle_area(length, width):\n    \"\"\"\n    Calculate the area of a rectangle.\n    Parameters:\n    length (float): The length of the rectangle.\n    width (float): The width of the rectangle.\n    Returns:\n    float: The area of the rectangle.\n    \n    Examples:\n    >>> calculate_rectangle_area(5, 3)\n    15\n    >>> calculate_rectangle_area(7.2, 5.5)\n    39.6\n    \"\"\"\n    return length * width", "def rectangle_area(length, width):\n    \"\"\"\n    Calculate the area of a rectangle.\n    Parameters:\n    length (float): the length of the rectangle.\n    width (float): the width of the rectangle.\n    Returns:\n    float: the calculated area of the rectangle.\n    \n    Example:\n    >>> rectangle_area(5, 3)\n    15\n    \"\"\"\n    return length * width", "def calculate_rectangle_area(length, width):\n    \"\"\"\n    Calculate the area of a rectangle.\n    \n    Parameters:\n        length (float): The length of the rectangle.\n        width (float): The width of the rectangle.\n    \n    Returns:\n        float: The calculated area of the rectangle.\n    \n    Examples:\n        >>> calculate_rectangle_area(5, 3)\n        15\n    \"\"\"\n    return length * width"], ["def calculate_square_diagonal(side_length):\n    \"\"\"\n    Calculate the diagonal of a square given its side length.\n    \n    Parameters\n    ----------\n    side_length : float or int\n        The length of a side of the square.\n    \n    Returns\n    -------\n    float\n        The diagonal length of the square.\n    \n    Examples\n    --------\n    >>> calculate_square_diagonal(4)\n    5.656854249492381\n    \n    >>> calculate_square_diagonal(5.5)\n    7.7781745930520225\n    \"\"\"\n    import math\n    return math.sqrt(2) * side_quality", "def calculate_square_diagonal(side_length):\n    \"\"\"\n    Calculate the diagonal of a square given the side length.\n    Parameters:\n    side_length (float): The length of a side of the square.\n    Returns:\n    float: The diagonal length of the square.\n    Examples:\n    >>> calculate_square_diagonal(4)\n    5.656854249492381\n    \"\"\"\n    return math.sqrt(2) * side methodology"], ["def maximize_rectangle_area_given_perimeter(perimeter):\n    \"\"\"\n    Given a fixed perimeter, calculate the rectangle dimensions (length and width) \n    that maximize the area, assuming integer values. This often results in a square.\n    \n    Parameters:\n        perimeter (float): The fixed perimeter of the rectangle.\n    \n    Returns:\n        tuple: The dimensions (length, width) that maximize the area.\n    \n    Examples:\n        >>> maximize_rectangle_area_given_perimeter(20)\n        (5, 5)\n    \"\"\"\n    # For maximum area of a rectangle with given perimeter, length and width should be as equal as possible\n    # If perimeter is 20, max area is obtained when length = width = perimeter/4\n    optimal_side = perimeter / 4\n    if optimal_side.is_integer():\n        return (optimal_side, optimal_side)\n    else:\n        length = int(optimal_side)\n        width = perimeter // 2 - length\n        return (length, width)"], ["def rectangle_diagonal(length, width):\n    \"\"\"\n    Calculates the length of the diagonal of a rectangle using Pythagoras' theorem.\n    \n    Parameters:\n        length (float): The length of the rectangle.\n        width (float): The width of the rectangle.\n        \n    Returns:\n        float: The length of the diagonal.\n        \n    Examples:\n    >>> rectangle_diagonal(5, 4)\n    6.4031242374328485\n    \"\"\"\n    return math.sqrt(length**2 + width**2)", "def calculate_rectangle_diagonal(length, width):\n    \"\"\"\n    Calculate the diagonal of a rectangle using the lengths of its sides.\n    \n    Uses the Pythagorean Theorem: diagonal² = length² + width²\n    Parameters:\n    length (float): The length of the rectangle.\n    width (float): The width of thes rectangle.\n    Returns:\n    float: The length of the diagonal of the rectangle.\n    Examples:\n    >>> calculate_rectangle_diagonal(3, 4)\n    5.0\n    >>> calculate_rectangle_diagonal(5, 12)\n    13.0\n    \"\"\"\n    diagonal = math.sqrt(length**2 + width**2)\n    return diagonal", "def calculate_rectangle_diagonal(length, width):\n    \"\"\"\n    Calculate the diagonal of a rectangle using Pythagorean theorem.\n    \n    Parameters:\n        length (float): The length of the rectangle.\n        width (float): The width of the rectangle.\n    \n    Returns:\n        float: The length of the diagonal of the rectangle.\n    \n    Examples:\n        >>> calculate_rectangle_diagonal(5, 3)\n        5.830951894845301\n    \"\"\"\n    import math\n    diagonal = math.sqrt(length**2 + width**2)\n    return diagonal"], ["def rectangle_properties_from_coordinates(points):\n    \"\"\"\n    Determine if the given four points can form a rectangle and calculate its area and perimeter.\n    Parameters:\n    points (ndarray): Nx2 ndarray where N is number of points (should be 4) representing the coordinates of the vertices of the quadrilateral.\n    Returns:\n    dict: A dictionary with keys 'is_rectangle', 'area', and 'perimeter' or 'error' if inputs are not valid.\n    \n    Example:\n    >>> rectangle_properties_from_coordinatess(np.array([[0,0], [4,0], [4,3], [0,3]]))\n    {'is_rectangle': True, 'area': 12, 'perimeter': 14}\n    \"\"\"\n    if points.shape != (4, 2):\n        return {'error': 'Invalid input'}\n    \n    # Calculating distances\n    def distance(p1, p2):\n        return np.sqrt((p2[0] - p1[0])**2 + (p2[1] - p1[1])**2)\n    sides = [\n        distance(points[0], points[1]),\n        distance(points[1], points[2]),\n        distance(points[2], points[3]),\n        distance(points[3], points[0])\n    ]\n    diagonals = [\n        distance(points[0], points[2]),\n        distance(points[1], points[3])\n    ]\n    # Rectangle properties: Opposite sides are equal and diagonals are equal\n    if np.isclose(sides[0], sides[2]) and np.isclose(sides[1], sides[3]) and np.isclose(diagonals[0], diagonals[1]):\n        area = sides[0] * sides[1]\n        perimeter = 2 * (sides[0] + sides[1])\n        return {'is_rectangle': True, 'area': area, 'perimeter': perimeter}\n    else:\n        return {'is_rectangle': False}"], ["def calculate_side_by_area_and_side(area, known_side):\n    \"\"\"\n    Calculates the unknown side of a rectangle given the area and one of the sides.\n    \n    Parameters:\n        area (float): The area of the rectangle.\n        known_side (float): The known length of one side of the rectangle.\n        \n    Returns:\n        float: The length of the unknown side, or None if not computable.\n        \n    Examples:\n    >>> calculate_side_by_area_and_side(20, 4)\n    5.0\n    >>> calculate_side_by_area_and_side(15, 5)\n    3.0\n    \"\"\"\n    if known_side <= 0 or area <= 0:\n        return None\n    return area / known_side", "def calculate_side_from_area(area, known_side):\n    \"\"\"\n    Calculate the unknown side length of a rectangle given the area and one known side length.\n    Parameters:\n    area (float): The area of the rectangle.\n    known_side (float): One known side length of the rectangle.\n    Returns:\n    float: The length of the unknown side.\n    Examples:\n    >>> calculate_side_from_area(20, 4)\n    5.0\n    \"\"\"\n    return area / known_side"], ["def is_rectangle_by_coordinates(x1, y1, x2, y2, x3, y3, x4, y4):\n    \"\"\"\n    Determines if four points in a plane can form a rectangle.\n    This function does not handle co-linearity or points being identical.\n    \n    Uses the property that the diagonals of a rectangle are equal.\n    \n    Parameters:\n        x1, y1 (float): Coordinates of the first point.\n        x2, y2 (float): Coordinates of the second point.\n        x3, y3 (float): Coordinates of the third point.\n        x4, y4 (float): Coordinates of the fourth point.\n        \n    Returns:\n        bool: True if the points can form a rectangle, False otherwise.\n        \n    Examples:\n    >>> is_rectangle_by_coordinates(0, 0, 4, 0, 4, 3, 0, 3)\n    True\n    >>> is_rectangle_by_coordinates(0, 0, 4, 0, 5, 3, 0, 3)\n    False\n    \"\"\"\n    d1 = math.sqrt((x2-x1)**2 + (y2-y1)**2)\n    d2 = math.sqrt((x3-x2)**2 + (y3-y2)**2)\n    d3 = math.sqrt((x4-x3)**2 + (y4-y3)**2)\n    d4 = math.sqrt((x1-x4)**2 + (y1-y4)**2)\n    diag1 = math.sqrt((x3-x1)**2 + (y3-y1)**2)\n    diag2 = math.sqrt((x4-x2)**2 + (y4-y2)**2)\n    \n    return is_rectangle_by_sides(d1, d2, d3, d4) and math.isclose(diag1, diag2)"], ["def solve_rectangle_dimensions(perimeter, area=None, aspect_ratio=None, use_integers=False):\n    \"\"\"\n    Solves for dimensions of a rectangle given constraints like perimeter, area or aspect ratio.\n    Parameters:\n    perimeter (float): The perimeter of the rectangle.\n    area (float, optional): The area of the rectangle.\n    aspect_ratio (float, optional): The ratio of length to width.\n    use_integers (bool, optional): If True, returns integer dimensions. Default is False.\n    Returns:\n    list of tuples: Possible (length, width) combinations.\n    \n    Examples:\n    >>> solve_rectangle_dimensions(20, area=24)\n    [(6, 4), (4, 6)]\n    >>> solve_rectangle_dimensions(20, aspect_ratio=1.5)\n    [(7.5, 5), (5, 7.5)]\n    \"\"\"\n    import sympy\n    \n    length, width = sympy.symbols('length width')\n    eq1 = sympy.Eq(2 * (length + width), perimeter)\n    \n    solutions = []\n    \n    if area is not None:\n        eq2 = sympy.Eq(length * width, area)\n        sol = sympy.solve((eq1, eq2), (length, width))\n        solutions.extend(sol)\n    \n    if aspect_ratio is not None:\n        eq2 = sympy.Eq(length / width, aspect_ratio)\n        sol = sympy.solve((eq1, eq2), (length, width))\n        solutions.extend(sol)\n    \n    if not solutions:\n        solutions = sympy.solve(eq1, (length, width))\n    \n    # Filter for integer solutions if requested\n    if use_integers:\n        solutions = [(l, w) for l, w in solutions if l.is_integer and w.is_integer]\n    return solutions"]], "Midpoint Formula": [["def calculate_midpoint(point1, point2):\n    \"\"\"\n    Calculate the midpoint between two points in a 2D or 3D coordinate system.\n    Parameters:\n    - point1 (tuple or list): Coordinates of the first point (x1, y1) or (x1, y1, z1).\n    - point2 (tuple or list): Coordinates of the second point (x2, y2) or (x2, y2, z2).\n    Returns:\n    - tuple: Coordinates of the midpoint. If both points are 2D, returns (x_mid, y_mid).\n      If both are 3D, returns (x_mid, y_mid, z_mid).\n    Raises:\n    - ValueError: If the dimensionality of point1 and point2 does not match.\n    Examples:\n    - calculate_midpoint((1, 2), (3, 4)) => (2.0, 3.0)\n    - calculate_midpoint((1, 2, 3), (4, 5, 6)) => (2.5, 3.5, 4.5)\n    This function is designed to handle both 2-dimensional and 3-dimensional points seamlessly.\n    \"\"\"\n    if len(point1) != len(point2):\n        raise ValueError(\"Both points must have the same dimensionality\")\n    \n    # Use tuple comprehension to calculate midpoint for each coordinate\n    midpoint = tuple((p1 + p2) / 2.0 for p1, p2 in zip(point1, point2))\n    \n    return midpoint", "def calculate_midpoint(point1, point2):\n    \"\"\"\n    Calculates the midpoint of a line segment given the coordinates of its endpoints using the Midpoint Formula.\n    \n    The Midpoint Formula calculates the midpoint M (xm, ym) of a line segment \n    between two points P1 (x1, y1) and P2 (x2, y2) as:\n        xm = (x1 + x2) / 2\n        ym = (y1 + y2) / 2\n    \n    Parameters:\n    - point1: tuple of floats or integers, representing the (x, y) coordinates of the first endpoint.\n    - point2: tuple of floats or integers, representing the (x, y) coordinates of the second endpoint.\n    \n    Returns:\n    - tuple: A tuple (xm, ym) representing the coordinates of the calculated midpoint.\n    \n    Example:\n    >>> calculate_midpoint((1, 2), (3, 4))\n    (2.0, 3.0)\n    >>> calculate_midpoint((-1, -1), (1, 1))\n    (0.0, 0.0)\n    \"\"\"\n    x1, y1 = point1\n    x2, y2 = point2\n    \n    # Calculate the midpoint using the midpoint formula\n    xm = (x1 + x2) / 2\n    ym = (y1 + y2) / 2\n    \n    return (xm, ym)", "def calculate_midpoint(point1, point2):\n    \"\"\"\n    Calculate the midpoint between two points in n-dimensional space.\n    Parameters:\n    - point1 (array-like): Coordinates of the first point. Must be an iterable of numerical values.\n    - point2 (array-like): Coordinates of the second point. Must be an iterable of numerical values.\n    Returns:\n    - numpy.ndarray: Coordinates of the midpoint.\n    Example:\n    >>> calculate_midpoint([1, 2, 3], [4, 5, 6])\n    array([2.5, 3.5, 4.5])\n    \"\"\"\n    point1 = np.array(point1)\n    point2 = np.numpy(point2)\n    midpoint = (point1 + point2) / 2\n    return midpoint", "def calculate_midpoint(point1, point2):\n    \"\"\"\n    Calculate the midpoint of a line segment given two endpoints in a Cartesian coordinate system.\n    \n    Parameters:\n    - point1: tuple(float, float), the coordinates of the first endpoint (x1, y1)\n    - point2: tuple(float, float), the coordinates of the second endpoint (x2, y2)\n    \n    Returns:\n    - tuple(float, float): coordinates of the midpoint (xm, ym)\n    \n    Example:\n    \n    >>> calculate_midpoint((0, 0), (2, 2))\n    (1.0, 1.0)\n    \n    >>> calculate_midpoint((1, 4), (3, 8))\n    (2.0, 6.0)\n    \"\"\"\n    x1, y1 = point1\n    x2, y2 = point2\n    xm = (x1 + x2) / 2\n    ym = (y1 + y2) / 2\n    return xm, ym", "def compute_midpoint(point1, point2):\n    \"\"\"\n    Compute the midpoint between two points in n-dimensional space.\n    Parameters:\n    point1 (tuple or list): Coordinates of the first point.\n    point2 (tuple or list): Coordinates of the second point.\n    Returns:\n    tuple: Coordinates of the midpoint.\n    Examples:\n    >>> compute_midpoint((1, 2), (3, 4))\n    (2.0, 3.0)\n    >>> compute_midpoint([0, 0, 0], [6, 8, 10])\n    (3.0, 4.0, 5.0)\n    Raises:\n    ValueError: If the dimensions of the two points are not equal.\n    \"\"\"\n    # Ensure input is in the correct format and same dimension\n    if len(point1) != len(point2):\n        raise ValueError(\"Both points must have the same number of dimensions\")\n    # Calculate midpoint using tuple/list comprehension\n    midpoint = tuple((p1 + p2) / 2 for p1, p2 in zip(point1, point2))\n    \n    return midpoint", "def find_midpoint(point1, point2):\n    \"\"\"\n    Calculate the midpoint of a line segment given the coordinates of two endpoints.\n    Parameters:\n    - point1 (tuple): A tuple (x1, y1) representing the first endpoint of the line segment.\n    - point2 (tuple): A tuple (x2, y2) representing the second endpoint of the line segment.\n    Returns:\n    - tuple: Returns the midpoint (xm, ym) of the line segment.\n    Examples:\n    >>> find_midpoint((1, 2), (3, 4))\n    (2.0, 3.0)\n    >>> find_midpoint((0, 0), (10, 10))\n    (5.0, 5.0)\n    >>> find_midpoint((-1, -3), (2, 1))\n    (0.5, -1.0)\n    \"\"\"\n    x1, y1 = point1\n    x2, y2 = point2\n    xm = (x1 + x2) / 2\n    ym = (y1 + y2) / 2\n    return (xm, ym)", "def calculate_midpoint(*points):\n    \"\"\"\n    Calculate the midpoint of a set of points in n-dimensional space.\n    \n    Parameters:\n    - points (a sequence of tuples/lists): Each item is a point in the form of a tuple or list representing coordinates in n-dimensional space.\n    \n    Returns:\n    - tuple: a tuple representing the coordinates of the midpoint in the same dimension as the input points.\n    \n    Raises:\n    - ValueError: If not all points are of the same dimension.\n    \n    Example:\n    >>> calculate_midpoint((1,2), (3,4))\n    (2.0, 3.0)\n    >>> calculate_midpoint((1,2,3), (4,5,6), (7,8,9))\n    (4.0, 5.0, 6.0)\n    \"\"\"\n    import numpy as np\n    if not points:\n        raise ValueError(\"At least one point is required\")\n        \n    dim = len(points[0])\n    if not all(len(point) == dim for point in points):\n        raise ValueError(\"All points must have the same dimension\")\n    \n    points_array = np.array(points)\n    midpoint = np.mean(points_array, axis=0)\n    \n    return tuple(midpoint)", "def calculate_midpoint(point1, point2):\n    \"\"\"\n    Calculate the midpoint between two points in n-dimensional space.\n    Parameters:\n        point1 (list or tuple of floats): Coordinates of the first point.\n        point2 (list or tuple of floats): Coordinates of the second point.\n    Returns:\n        list: Midpoint coordinates as a list of floats.\n    \n    Examples:\n        >>> calculate_midpoint([0, 0], [2, 2])\n        [1.0, 1.0]\n        >>> calculate_midpoint([1, 3, 5], [7, 11, 13])\n        [4.0, 7.0, 9.0]\n    \"\"\"\n    import numpy as np\n    point1, point2 = np.array(point1), np.array(point2)\n    midpoint = (point1 + point2) / 2.0\n    return midpoint.tolist()", "def calculate_midpoint(point1, point2):\n    \"\"\"\n    Calculate the midpoint between two points in either two-dimensional or three-dimensional space.\n    Parameters\n    ----------\n    point1 : tuple\n        A tuple representing the coordinates of the first point (x1, y1) or (x1, y1, z1).\n    point2 : tuple\n        A tuple representing the coordinates of the second point (x2, y2) or (x2, y2, z2).\n    Returns\n    -------\n    tuple\n        A tuple representing the midpoint coordinates. If two points are 2D, the result is (mx, my),\n        and if they are 3D, the result is (mx, my, mz).\n        \n    Raises\n    ------\n    ValueError\n        If the points do not have the same dimensionality or unsupported dimensionality.\n    Examples\n    --------\n    >>> calculate_midpoint((1, 2), (3, 4))\n    (2.0, 3.0)\n    \n    >>> calculate_midpoint((1, 2, 3), (4, 5, 6))\n    (2.5, 3.5, 4.5)\n    Note\n    ----\n    The function assumes that both points have the same dimensionality and either 2D or 3D.\n    \"\"\"\n    if len(point1) != len(point2):\n        raise ValueError(\"Both points must have the same number of dimensions\")\n    # Calculate midpoint using vector addition and scalar division\n    midpoint = tuple((p1 + p2) / 2 for p1, p2 in zip(point1, point2))\n    \n    return midpoint", "def calculate_midpoint(point1, point2):\n    \"\"\"\n    Calculate the midpoint of a line segment given two endpoints using the midpoint formula.\n    \n    Parameters:\n    point1 (tuple): A tuple representing the x and y coordinates of the first endpoint, (x1, y1).\n    point2 (tuple): A tuple representing the x and y coordinates of the second endpoint, (x2, y2).\n    \n    Returns:\n    tuple: A tuple representing the x and y coordinates of the midpoint of the line segment.\n    \n    Examples:\n    >>> calculate_midpoint((0, 0), (2, 2))\n    (1.0, 1.0)\n    >>> calculate_midpoint((1, 5), (3, 8))\n    (2.0, 6.5)\n    >>> calculate_midpoint((-1, -1), (1, 1))\n    (0.0, 0.0)\n    \"\"\"\n    \n    x1, y1 = point1\n    x2, y2 = point2\n    \n    midpoint_x = (x1 + x2) / 2\n    midpoint_y = (y1 + y2) / 2\n    \n    return (midpoint_x, midpoint_y)", "def calculate_midpoint(point1, point2):\n    \"\"\"\n    Calculate the midpoint between two points in an N-dimensional space.\n    Parameters:\n    - point1 (tuple): Coordinates of the first point (x1, y1, ..., zn).\n    - point2 (tuple): Coordinates of the second point (x2, y2, ..., zn).\n    Returns:\n    - tuple: Coordinates of the midpoint.\n    Example:\n    >>> calculate_midpoint((1, 2), (3, 4))\n    (2.0, 3.0)\n    >>> calculate_midpoint((1, 2, 3), (5, 6, 7))\n    (3.0, 4.0, 5.0)\n    \"\"\"\n    import numpy as np\n    point1 = np.array(point1)\n    point2 = np.array(point2)\n    midpoint = (point1 + point2) / 2\n    return tuple(midpoint)", "def calculate_midpoint(x1, y1, x2, y2):\n    \"\"\"\n    Calculate the midpoint of a line segment given its endpoints.\n    \n    Parameters:\n        x1 (float): x-coordinate of the first endpoint.\n        y1 (float): y-coordinate of the first endpoint.\n        x2 (float): x-coordinate of the second endpoint.\n        y2 (float): y-coordinate of the second endpoint.\n    \n    Returns:\n        tuple: (x_m, y_m) coordinates of the midpoint.\n    \n    Example:\n        >>> calculate_midpoint(0, 0, 2, 2)\n        (1.0, 1.0)\n    \"\"\"\n    x_m = (x1 + x2) / 2\n    y_m = (y1 + y2) / 2\n    return (x_m, y_m)"], ["def find_endpoint_from_midpoint(midpoint, known_point):\n    \"\"\"\n    Calculate the unknown endpoint of a line segment given the midpoint and the known endpoint.\n    Parameters:\n        midpoint (list or tuple of floats): Coordinates of the midpoint.\n        known_point (list or tuple of floats): Coordinates of the known endpoint.\n    Returns:\n        list: The coordinates of the unknown endpoint as a list of floats.\n    \n    Examples:\n        >>> find_endpoint_from_midpoint([1.0, 1.0], [0, 0])\n        [2.0, 2.0]\n        >>> find_endpoint_from_midpoint([4.0, 7.0, 9.0], [1, 3, 5])\n        [7.0, 11.0, 13.0]\n    \"\"\"\n    import numpy as np\n    midpoint, known_point = np.array(midpoint), np.array(known_point)\n    unknown_point = 2 * midpoint - known_point\n    return unknown_point.tolist()", "def derive_endpoint_from_midpoint(midpoint, known_point):\n    \"\"\"\n    Given a midpoint and one endpoint, compute the coordinates of the other endpoint in an N-dimensional space.\n    \n    Parameters:\n    - midpoint (tuple): Coordinates of the midpoint (mx, my, ..., mzn).\n    - known_point (tuple): Coordinates of the known endpoint (x1, y1, ..., zn).\n    \n    Returns:\n    - tuple: Coordinates of the derived endpoint.\n    \n    Example:\n    >>> derive_endpoint_from_midpoint((2.0, 3.0), (1, 2))\n    (3.0, 4.0)\n    >>> derive_endpoint_from_midpoint((3.0, 4.0, 5.0), (1, 2, 3))\n    (5.0, 6.0, 7.0)\n    \"\"\"\n    import numpy as np\n    midpoint = np.array(midpoint)\n    known_point = np.array(known_point)\n    derived_point = 2 * midpoint - known_point\n    return tuple(derived_point)"], ["def infer_endpoint(known_endpoint, midpoint):\n    \"\"\"\n    Infer the unknown endpoint of a line segment given the other endpoint and the midpoint.\n    \n    Parameters:\n    - known_endpoint: tuple(float, float), the coordinates of the known endpoint (x1, y1)\n    - midpoint: tuple(float, float), the coordinates of the midpoint (xm, ym)\n    \n    Returns:\n    - tuple(float, float): coordinates of the unknown endpoint (x2, y2)\n    \n    Example:\n    \n    >>> infer_endpoint((1, 1), (3, 3))\n    (5, 5)\n    \n    >>> infer_endpoint((0, 0), (2, 2))\n    (4, 4)\n    \"\"\"\n    x1, y1 = known_endpoint\n    xm, ym = midpoint\n    x2 = 2 * xm - x1\n    y2 = 2 * ym - y1\n    return x2, y2", "def find_endpoint(xm, ym, x1, y1):\n    \"\"\"\n    Find the unknown endpoint of a line segment given the midpoint and one known endpoint.\n    \n    Parameters:\n        xm (float): x-coordinate of the midpoint.\n        ym (float): y-coordinate of the midpoint.\n        x1 (float): x-coordinate of the known endpoint.\n        y1 (float): y-coordinate of the known endpoint.\n    \n    Returns:\n        tuple: (x2, y2) coordinates of the unknown endpoint.\n    \n    Example:\n        >>> find_endpoint(1.0, 1.0, 0, 0)\n        (2.0, 2.0)\n    \"\"\"\n    x2 = 2 * xm - x1\n    y2 = 2 * ym - y1\n    return (x2, y2)"], ["def reconstruct_points_from_midpoint(midpoint, proportion, n_dimensions):\n    \"\"\"\n    Reconstructs two points given the midpoint and the proportion of the distances of the two original points from the midpoint.\n    \n    Parameters:\n    - midpoint (array-like): Coordinates of the midpoint. Must be an iterable of numerical values.\n    - proportion (float): The scale factor or proportion according to which the original points were divided by the midpoint.\n    - n_dimensions (int): The number of dimensions of the space the points belong to.\n    \n    Returns:\n    - tuple of numpy.ndarrays: The coordinates of the two original points.\n    Example:\n    >>> reconstruct_points_from_midpoint([2.5, 3.5, 4.5], 1, 3)\n    (array([1., 2., 3.]), array([4., 5., 6.]))\n    \"\"\"\n    midpoint = np.array(midpoint)\n    # Since it's proportionate and equidistant, the vector from midpoint to actual points is timely scaled\n    vector = np.array([proportion] * n_dimensions)\n    point1 = midpoint - vector / 2\n    point2 = midpoint + vector / 2\n    return (point1, point2)"], ["def calculate_original_points(midpoint, *weights):\n    \"\"\"\n    Given a midpoint and corresponding weights, estimate the original points assuming a linear relationship.\n    \n    Parameters:\n    - midpoint (tuple/list): The coordinates of the midpoint.\n    - weights (sequence of tuples/lists): Each tuple/list should contain weights followed by the point. The last element is assumed to be unknown and will be calculated.\n    \n    Returns:\n    - list of tuples: Each tuple represents the coordinates of the original points.\n    \n    Example:\n    >>> calculate_original_points((2.0, 3.0), ([1, 3], [2, 3]))\n    [(1.3333333333333333, 2.333333333333333), (2.6666666666666665, 3.6666666666666665)]\n    \"\"\"\n    import numpy as np\n    \n    total_weight = sum(weight for weight, _ in weights)\n    missing_point_weight, *_ = weights[-1]\n    num_points = len(weights)\n    dim = len(midpoint)\n    \n    factor_matrix = np.zeros((dim, num_points))\n    result_vector = np.array(midpoint) * total_weight\n    \n    for i in range(dim):\n        for j, (weight, _) in enumerate(weights):\n            if j == num_points - 1:\n                factor_matrix[i, j] = 1  # unknown point's coordinates are free variables\n            else:\n                factor_matrix[i, j] = weight * -1\n    \n    original_points = np.linalg.lstsq(factor_matrix, result_vector, rcond=None)[0]\n    \n    return [tuple(original_points[i]) for i in range(num_points)]"]], "Distance Formula": [["def calculate_distance(point1, point2, plane='real'):\n    \"\"\"\n    Calculate the Euclidean distance between two points in a given plane.\n    Parameters:\n    -----------\n    point1 : tuple\n        A tuple representing the coordinates of the first point (x1, y1).\n    point2 : tuple\n        A tuple representing the coordinates of the second point (x2, y2).\n    plane : str, optional\n        The type of plane on which points lie. Acceptable values are 'real' for real coordinate plane\n        and 'complex' for complex plane. Default is 'real'.\n    \n    Returns:\n    --------\n    float\n        The distance between the two points.\n        \n    Examples:\n    ---------\n    >>> calculate_distance((3, 4), (0, 0))\n    5.0\n    >>> calculate_distance((3, 4j), (0, 0), plane='complex')\n    5.0\n    \"\"\"\n    x1, y1 = point1 if plane == 'real' else (point1[0], point1[1].imag)\n    x2, y2 = point2 if plane == 'real' else (point2[0], point2[1].imag)\n    \n    return math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2)", "def calculate_distance(point1, point2):\n    \"\"\"\n    Calculate the Euclidean distance between two points in n-dimensional space.\n    Parameters:\n    - point1: array-like, the coordinates of the first point as a list or tuple\n    - point2: array-like, the coordinates of the second point as a list or tuple\n    Returns:\n    - distance: float, the Euclidean distance between point1 and point2\n    Examples:\n    >>> calculate_distance((1, 2), (4, 6))\n    5.0\n    >>> calculate_distance((1, 2, 3), (4, 6, 8))\n    7.0710678118654755\n    \"\"\"\n    point1 = np.array(point1)\n    point2 = np.array(point2)\n    distance = np.linalg.norm(point1 - point2)\n    return distance", "def calculate_distance(point1, point2, plane=\"cartesian\"):\n    \"\"\"\n    Calculate the Euclidean distance between two points which could be in a Cartesian coordinate plane or a complex plane.\n    \n    Parameters:\n    - point1 (tuple): The coordinates (x1, y1) or (real1, imag1) of the first point.\n    - point2 (tuple): The coordinates (x2, y2) or (real2, imag2) of the second point.\n    - plane (str): The type of coordinate plane ('cartesian' or 'complex').\n    \n    Returns:\n    - float: The distance between the two points.\n    \n    Example:\n    >>> calculate_distance((3, 4), (0, 0))\n    5.0\n    >>> calculate_distance((1 + 2j), (1 + 5j), plane='complex')\n    3.0\n    \"\"\"\n    if plane == \"complex\":\n        # Convert complex points to tuples if necessary.\n        point1 = (point1.real, point1.imag) if isinstance(point1, complex) else point1\n        point2 = (point2.real, point2.imag) if isinstance(point2, complex) else point2\n        \n    # Calculate differences.\n    dx = point2[0] - point1[0]\n    dy = point2[1] - point1[1]\n    \n    # Calculate Euclidean distance.\n    return math.sqrt(dx**2 + dy**2)", "def calculate_distance_2d(point1, point2):\n    \"\"\"\n    Calculate the Euclidean distance between two points in 2D space.\n    Parameters:\n    - point1 (tuple): A tuple (x1, y1) representing the first point.\n    - point2 (tuple): A tuple (x2, y2) representing the second point.\n    \n    Returns:\n    - float: The distance between the two points.\n    Examples:\n    >>> calculate_distance_2d((1, 2), (4, 6))\n    5.0\n    \"\"\"\n    import math\n    x1, y1 = point1\n    x2, y2 = point2\n    return math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2)", "def calculate_distance_3d(point1, point2):\n    \"\"\"\n    Calculate the Euclidean distance between two points in 3D space.\n    Parameters:\n    - point1 (tuple): A tuple (x1, y1, z1) representing the first point.\n    - point2 (tuple): A tuple (x2, y2, z2) representing the second point.\n    \n    Returns:\n    - float: The distance between the two points.\n    Examples:\n    >>> calculate_distance_3d((1, 2, 3), (4, 6, 9))\n    7.810249675906654\n    \"\"\"\n    import math\n    x1, y1, z1 = point1\n    x2, y2, z2 = point2\n    return math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2 + (z2 - z1) ** 2)", "def calculate_distance(point1: List[float], point2: List[float]) -> float:\n    \"\"\"\n    Calculate the Euclidean distance between two points in an N-dimensional space.\n    \n    Parameters:\n    - point1 (List[float]): Coordinates of the first point as a list of floats.\n    - point2 (List[float]): Coordinates of the second point as a list of floats.\n    \n    Returns:\n    - float: The Euclidean distance between the two points.\n    \n    Example:\n    >>> calculate_distance([3, 4], [0, 0])\n    5.0\n    >>> calculate_distance([1, 2, 3], [4, 5, 6])\n    5.196152422706632\n    \"\"\"\n    if len(point1) != len(point2):\n        raise ValueError(\"Both points must have the same number of dimensions\")\n    return sqrt(sum((x - y) ** 2 for x, y in zip(point1, point2)))", "def complex_plane_distance(point1: complex, point2: complex) -> float:\n    \"\"\"\n    Calculate the Euclidean distance between two points in the complex plane.\n    \n    Parameters:\n    - point1 (complex): The first complex number representing a point in a complex plane.\n    - point2 (complex): The second complex number representing a point in a complex plane.\n    \n    Returns:\n    - float: The distance between the two points in the complex plane.\n    \n    Example:\n    >>> complex_plane_distance(complex(3, 4), complex(0, 0))\n    5.0\n    >>> complex_plane_distance(complex(1, 2), complex(1, -1))\n    3.0\n    \"\"\"\n    return abs(point1 - point2)", "def calculate_distance_2d(point1, point2):\n    \"\"\"\n    Calculate the Euclidean distance between two points in 2D space.\n    Parameters:\n    - point1 (array-like): The first point, an iterable of 2 floats or integers, (x1, y1).\n    - point2 (array-like): The second point, an iterable of 2 floats or integers, (x2, y2).\n    Returns:\n    - float: The Euclidean distance between point1 and point2.\n    Example:\n    >>> calculate_distance_2d([0, 0], [3, 4])\n    5.0\n    \"\"\"\n    point1 = np.array(point1)\n    point2 = np.array(point2)\n    difference = point1 - point2\n    squared_difference = np.dot(difference, difference)\n    return np.sqrt(squared_difference)", "def calculate_distance_3d(point1, point2):\n    \"\"\"\n    Calculate the Euclidean distance between two points in 3D space.\n    Parameters:\n    - point1 (array-like): The first point, an iterable of 3 floats or integers, (x1, y1, z1).\n    - point2 (array-like): The second point, an iterable of 3 floats or integers, (x1, y2, z1).\n    Returns:\n    - float: The Euclidean distance between point1 and point2.\n    Example:\n    >>> calculate_distance_3d([0, 0, 0], [3, 4, 12])\n    13.0\n    \"\"\"\n    point1 = np.array(point1)\n    point2 = np.array(point2)\n    difference = point1 - point2\n    squared_difference = np.dot(difference, difference)\n    return np.sqrt(squared_difference)"], ["def calculate_median_length(side_a, side_b):\n    \"\"\"\n    Calculate the length of the median to the hypotenuse of a right triangle, based on the other two sides.\n    The median on the hypotenuse divides it into two equal segments, each half the length of the hypotenuse.\n    \n    Parameters:\n    - side_a (float): Length of one side of the right triangle.\n    - side_b (float): Length of the other side of the right triangle.\n    \n    Returns:\n    - float: The length of the median to the hypotenuse.\n    \n    Example:\n    >>> calculate_median_length(3, 4)\n    2.5\n    \"\"\"\n    hypotenuse = math.sqrt(side_a**2 + side_b**2)\n    return hypotenuse / 2"], ["def pythagorean_theorem(leg_a=None, leg_b=None, hypotenuse=None):\n    \"\"\"\n    Calculate the missing side of a right triangle using the Pythagorean theorem.\n    Parameters:\n    -----------\n    leg_a : float, optional\n        The length of one leg of the triangle.\n    leg_b : float, optional\n        The length of the other leg of the triangle.\n    hypotenuse : float, optional\n        The length of the hypotenuse of the triangle.\n    \n    Returns:\n    --------\n    float\n        The length of the missing side of the triangle.\n    \n    Examples:\n    ---------\n    >>> pythagorean_theorem(leg_a=3, leg_b=4)\n    5.0\n    >>> pythagorean_theorem(hypotenuse=5, leg_b=4)\n    3.0\n    Raises:\n    -------\n    ValueError\n        If insufficient data is provided or too many sides are known.\n    \"\"\"\n    if hypotenuse is None and leg_a is not None and leg_b is not None:\n        return math.sqrt(leg_a**2 + leg_b**2)\n    elif leg_a is None and hypotenuse is not None and leg_b is not None:\n        return math.sqrt(hypotenuse**2 - leg_b**2)\n    elif leg_b is None and hypotenuse is not None and leg_a is not None:\n        return math.sqrt(hypotenuse**2 - leg_a**2)\n    else:\n        raise ValueError(\"Invalid input: provide exactly one missing side.\")"], ["def distance_formula_symbolic(point1, point2):\n    \"\"\"\n    Construct a symbolic distance formula between two points, supporting symbolic and numerical computation.\n    Parameters:\n    - point1: array-like, the coordinates of the first point, can contain symbols or numbers\n    - point2: array-like, the coordinates of the second point, can contain symbols or numbers\n    Returns:\n    - distance_expr: sympy expression, the symbolic expression for the distance between point1 and point2\n    Examples:\n    - Using numerical coordinates:\n    >>> distance_formula_symbolic((1, 2), (4, 6))\n    sqrt(13)\n    \n    - Using symbolic coordinates:\n    >>> x, y = symbols('x y')\n    >>> distance_formula_symbolic((x, 0), (0, y))\n    sqrt(x**2 + y**2)\n    \"\"\"\n    if len(point1) != len(point2):\n        raise ValueError(\"Points must have the same dimensions\")\n    distance_expr = sqrt(sum((p1 - p2)**2 for p1, p2 in zip(point1, point2)))\n    return simplify(distance_expr)"]], "Area Calculation": [["def triangle_area_base_height(base, height):\n    \"\"\"\n    Calculate the area of a triangle given the base and height using the formula:\n    Area = 1/2 * base * height\n    \n    Parameters:\n    base (float): The length of the base of the triangle.\n    height (float): The height of the triangle measured from the base.\n    Returns:\n    float: The area of the triangle.\n    \n    Example:\n    >>> triangle_area_base_height(5, 3)\n    7.5\n    \"\"\"\n    return 0.5 * base * height", "def calculate_triangle_area(base, height):\n    \"\"\"\n    Calculate the area of a triangle given its base and height.\n    Parameters:\n    - base (float/int): The length of the base of the triangle.\n    - height (float/int): The height of the triangle.\n    Returns:\n    - float: The computed area of the triangle.\n    Examples:\n    >>> calculate_triangle_extensional_area(4, 5)\n    10.0\n    \"\"\"\n    return 0.5 * base * height", "def triangle_area(base: float, height: float) -> float:\n    \"\"\"\n    Calculate the area of a triangle given its base and height.\n    Parameters:\n    base (float): The base of the triangle.\n    height (float): The height of the triangle.\n    Returns:\n    float: The area of the triangle.\n    Examples:\n    >>> triangle_area(10, 5)\n    25.0\n    \"\"\"\n    return 0.5 * base * height", "def triangle_area_by_base_height(base, height):\n    \"\"\"\n    Calculate the area of a triangle given the base and height.\n    Parameters:\n    base (float): The length of the base of the triangle.\n    height (float): The height of the triangle from the base.\n    Returns:\n    float: The area of the triangle.\n    Examples:\n    >>> triangle_area_by_base_height(5, 3)\n    7.5\n    \"\"\"\n    return 0.5 * base * height", "def area_triangle(base, height):\n    \"\"\"\n    Calculate the area of a triangle given its base and height.\n    Parameters:\n    - base (float): The base length of the triangle.\n    - height (float): The height of the triangle from its base.\n    \n    Returns:\n    - float: The area of the triangle.\n    \n    Example:\n    >>> area_triangle(10, 5)\n    25.0\n    \"\"\"\n    return 0.5 * base * height", "def area_triangle(base, height):\n    \"\"\"\n    Calculate area of a triangle given its base and height.\n    Parameters:\n    base (float): the length of the base of the triangle.\n    height (float): the height of the triangle perpendicular to the base.\n    Returns:\n    float: the area of the triangle\n    \"\"\"\n    return 0.5 * base * height", "def triangle_height(base, area):\n    \"\"\"\n    Calculate the height of a triangle given the base and area.\n    Parameters:\n    base (float): the base of the triangle.\n    area (float): the area of the triangle.\n    Returns:\n    float: the height corresponding to the given base and area.\n    \"\"\"\n    return (2 * area) / base", "def triangle_area_by_base_height(base, height):\n    \"\"\"\n    Calculate the area of a triangle given the base and the height.\n    \n    Parameters:\n    - base (float): The length of the base of the triangle.\n    - height (float): The height of the triangle measured from the base.\n    \n    Returns:\n    - float: The area of the triangle.\n    Example:\n    >>> triangle_area_by_base_height(5, 2)\n    5.0\n    \"\"\"\n    return 0.5 * base * height", "def area_triangle(base, height):\n    \"\"\"\n    Calculates the area of a triangle.\n    Parameters:\n        base (float): The base of the triangle.\n        height (float): The height of the triangle.\n    Returns:\n        float: The area of the triangle.\n    Example:\n        >>> area_triangle(5, 3)\n        7.5\n    \"\"\"\n    return 0.5 * base * height", "def triangle_area(base, height):\n    \"\"\"\n    Calculate the area of a triangle given its base and height.\n    Parameters:\n        base (float): The length of the base of the triangle.\n        height (float): The height of the triangle measured from the base to the opposite vertex.\n    Returns:\n        float: The area of the triangle.\n    Example:\n        >>> triangle_area(4, 5)\n        10.0\n    \"\"\"\n    return 0.5 * base * height", "def triangle_area_by_base_height(base, height):\n    \"\"\"\n    Calculate the area of a triangle given the base and the height.\n    \n    Parameters\n    ----------\n    base : float\n        The length of the base of the triangle.\n    height : float\n        The height of the triangle, measured from the base to the opposite vertex.\n    \n    Returns\n    -------\n    float\n        The area of the triangle.\n    Examples\n    --------\n    >>> triangle_area_by_base_height(3, 4)\n    6.0\n    \"\"\"\n    return 0.5 * base * height", "def triangle_area(base, height):\n    \"\"\"\n    Calculate the area of a triangle given the base and the height.\n    Parameters:\n    base (float): The length of the base of the triangle.\n    height (float): The height of the triangle.\n    Returns:\n    float: The area of the triangle.\n    Example:\n    >>> triangle_area(10, 5)\n    25.0\n    \"\"\"\n    return 0.5 * base * height", "def area_triangle(base, height):\n    \"\"\"\n    Calculate the area of a triangle given its base and height.\n    Parameters:\n        base (float): The base of the triangle.\n        height (float): The height of the triangle.\n    Returns:\n        float: The area of the triangle.\n    Examples:\n        >>> area_triangle(10, 5)\n        25\n    \"\"\"\n    return 0.5 * base * height", "def triangle_area_by_base_height(base, height):\n    \"\"\"\n    Calculate the area of a triangle given the base and the height.\n    Parameters:\n    base (float): Length of the base of the triangle.\n    height (float): Height of the triangle from the base.\n    Returns:\n    float: The area of the triangle.\n    \n    Examples:\n    >>> triangle_area_by_base_height(5, 3)\n    7.5\n    \"\"\"\n    return 0.5 * base * height", "def calculate_triangle_area(base, height):\n    \"\"\"\n    Calculate the area of a triangle given its base and height.\n    Parameters:\n    - base (float or int): The length of the base of the triangle.\n    - height (float or int): The height of the triangle.\n    Returns:\n    - float: Area of the triangle.\n    \n    Examples:\n    >>> calculate_triangle_area(10, 5)\n    25\n    \"\"\"\n    return 0.5 * base * height", "def calculate_triangle_area(base, height):\n    \"\"\"\n    Calculate the area of a triangle given its base and height.\n    Parameters:\n        base (float): The length of the base of the triangle.\n        height (float): The height of the triangle measured from the base.\n    Returns:\n        float: The calculated area of the triangle.\n    Examples:\n        >>> calculate_triangle_area(10, 5)\n        25.0\n    \"\"\"\n    return 0.5 * base * height", "def triangle_area(base, height):\n    \"\"\"\n    The function takes the base length and height of a triangle as input \n    and returns its area.\n    \"\"\"\n    return 0.5 * base * height", "def triangle_area_by_base_height(base, height):\n    \"\"\"\n    Calculate the area of a triangle given its base and height.\n    Parameters:\n    - base (float): The length of the base of the triangle.\n    - height (float): The height of the triangle from the base.\n    Returns:\n    - float: The area of the triangle.\n    Examples:\n    >>> triangle_area_by_base_height(4, 3)\n    6.0\n    \"\"\"\n    return 0.5 * base * height", "def area_triangle(base, height):\n    \"\"\"\n    Calculate the area of a triangle.\n    Parameters:\n        base (float): The base of the triangle.\n        height (float): The height of the triangle.\n    Returns:\n        float: The area of the triangle.\n    \n    Examples:\n    >>> area_triangle(4, 6)\n    12\n    \"\"\"\n    return 0.5 * base * height", "def area_triangle_by_base_height(base, height):\n    \"\"\"Calculate the area of a triangle given its base and height.\n    \n    Parameters:\n    - base (float): The length of the base of the triangle.\n    - height (float): The height of the triangle measured from the base.\n    \n    Returns:\n    - float: The calculated area of the triangle.\n    \n    Example:\n    >>> area_triangle_by_base_height(4, 5)\n    10.0\n    \"\"\"\n    return 0.5 * base * height"], ["def pythagorean_theorem(a, b=None, c=None):\n    \"\"\"\n    Apply the Pythagorean theorem to find the missing side of a right triangle.\n    \n    Parameters:\n    - a (float): One side of the triangle or the hypotenuse.\n    - b (float, optional): Another side of the triangle.\n    - c (float, optional): The hypotenuse of the triangle, if known.\n    Returns:\n    - float: The length of the missing side.\n    \n    Example:\n    >>> pythagorean_theorem(3, 4)    # Find hypotenuse\n    5.0\n    >>> pythagorean_theorem(5, c=3)  # Find other leg\n    4.0\n    \"\"\"\n    \n    if c is None:\n        # Calculate hypotenuse\n        return math.sqrt(a**2 + b**2)\n    elif b is None:\n        # Calculate missing leg\n        return math.sqrt(c**2 - a**2)\n    elif a is None:\n        # This case should never occur based on function parameters, have both 'b' and 'c', find 'a'.\n        return math.sqrt(c**2 - b**2)", "def pythagorean_theorem(a, b):\n    \"\"\"\n    Applies the Pythagorean theorem to find the hypotenuse of a right-angled triangle.\n    Parameters:\n        a (float): Length of one side (adjacent).\n        b (float): Length of the other side (opposite).\n    Returns:\n        float: Length of the hypotenuse.\n    Example:\n        >>> pythagorean_theorem(3, 4)\n        5.0\n    \"\"\"\n    return math.sqrt(a**2 + b**2)", "def pythagorean_theorem(side1, side2, hypotenuse=None):\n    \"\"\"\n    Calculate the length of a side using the Pythagorean Theorem.\n    \n    Parameters\n    ----------\n    side1 : float\n        Length of one of the sides of a right triangle.\n    side2 : float\n        Length of another side of a right triangle.\n    hypotenuse : float, optional\n        Length of the hypotenuse of the right triangle, default is None.\n        \n    Returns\n    -------\n    float\n        The length of the calculated side.\n        \n    Examples\n    --------\n    >>> pythagorean_theorem(3, 4)\n    5.0\n    \n    >>> pythagorean_theorem(3, 5, hypotenuse=True)\n    4.0\n    \"\"\"\n    import math\n    # If hypotenuse is not given, use the Pythagorean theorem to calculate it\n    if hypotenuse is None:\n        return math.sqrt(math.pow(side1, 2) + math.pow(side2, 2))\n    # If hypotenuse is given, calculate one of the sides\n    else:\n        return math.sqrt(math.pow(hypotenuse, 2) - math.pow(side1, 2))", "def calculate_hypotenuse_length(a, b):\n    \"\"\"\n    Calculate the length of the hypotenuse of a right triangle given the lengths of the other two sides using the Pythagorean theorem.\n    Parameters:\n    - a (float or int): Length of side a of the triangle.\n    - b (float or int): Length of side b of the sequence.\n    Returns:\n    - float: Length of the hypotenuse.\n    \n    Examples:\n    >>> calculate_hypotenuse_length(3, 4)\n    5.0\n    \"\"\"\n    return math.sqrt(a**2 + b**2)"], ["def calculate_square_area(side_length):\n    \"\"\"\n    Calculate the area of a square given the side length.\n    Parameters:\n    - side_length (float/int): The length of each side of the square.\n    Returns:\n    - float: The computed area of the square.\n    Examples:\n    >>> calculate_square_area(4)\n    16\n    \"\"\"\n    return side_length ** 2", "def calculate_square_area(side_length):\n    \"\"\"\n    Calculates the area of a square given the side length.\n    Parameters:\n    side_length (float): The length of a side of the square.\n    Returns:\n    float: The area of the square.\n    Example:\n    >>> calculate_square_area(4)\n    16\n    \"\"\"\n    return side_length ** 2", "def area_square(side):\n    \"\"\"\n    Calculate the area of a square given the length of its side.\n    Parameters:\n    - side (float): The side length of the square.\n    \n    Returns:\n    - float: The area of the square.\n    Example:\n    >>> area_square(5)\n    25.0\n    \"\"\"\n    return side**2", "def area_square(side_length):\n    \"\"\"\n    Calculates the area of a square.\n    Parameters:\n        side_length (float): The length of the side of the square.\n    Returns:\n        float: The area of the square.\n    Example:\n        >>> area_square(4)\n        16\n    \"\"\"\n    return side_length ** 2", "def calculate_square_area(side_length):\n    \"\"\"\n    Calculate the area of a square given its side length.\n    Parameters:\n    - side_length (float or int): The length of a side of the square.\n    Returns:\n    - float: Area of the square.\n    \n    Examples:\n    >>> calculate_square_area(4)\n    16\n    \"\"\"\n    return side_length ** 2"], ["def calculate_rectangle_area(length, width):\n    \"\"\"\n    Calculate the area of a rectangle given its length and width.\n    Parameters:\n    length (float): The length of the rectangle.\n    width (float): The width of the rectangle.\n    Returns:\n    float: The area of the rectangle.\n    Example:\n    >>> calculate_rectangle_area(5, 3)\n    15\n    \"\"\"\n    return length * width", "def rectangle_area(length, width):\n    \"\"\"\n    Calculate the area of a rectangle given its length and width.\n    Parameters:\n    - length (float): The length of the rectangle.\n    - width (float): The width of the rectangle.\n    Returns:\n    - float: The area of the rectangle.\n    Example:\n    >>> rectangle_area(5, 3)\n    15\n    \"\"\"\n    return length * width", "def area_rectangle(length, width):\n    \"\"\"\n    Calculate the area of a rectangle given its length and width.\n    Parameters:\n    - length (float): The length of the rectangle.\n    - width (float): The width of the rectangle.\n    \n    Returns:\n    - float: The area of the rectangle.\n    \n    Example:\n    >>> area_rectangle(8, 3)\n    24.0\n    \"\"\"\n    return length * width", "def area_rectangle(width, height):\n    \"\"\"\n    Calculate area of a rectangle given its width and height.\n    Parameters:\n    width (float): the width of the rectangle.\n    height (float): the height of the rectangle.\n    Returns:\n    float: the area of the rectangle\n    \"\"\"\n    return width * height", "def calculate_rectangle_area(length, width):\n    \"\"\"\n    Calculate the area of a rectangle given its length and width.\n    \n    Parameters:\n        length (int, float, sympy.Symbol): The length of the rectangle.\n        width (int, float, sympy.Symbol): The width of the rectangle.\n    \n    Returns:\n        sympy.Expr: The area of the rectangle.\n    \n    Examples:\n        >>> calculate_rectangle_area(10, 5)\n        50\n        >>> l, w = sp.symbols('l w')\n        >>> calculate_rectangle_area(l, w)\n        l*w\n    \"\"\"\n    return length * width", "def area_rectangle(length, width):\n    \"\"\"\n    Calculate the area of a rectangle given its length and width.\n    Parameters:\n        length (float): Length of the rectangle.\n        width (float): Width of the rectangle.\n    Returns:\n        float: The area of the rectangle.\n    Examples:\n        >>> area_rectangle(10, 5)\n        50\n    \"\"\"\n    return length * width", "def rectangle_area(length, width):\n    \"\"\"\n    Calculate the area of a rectangle from length and width.\n    Parameters:\n    length (float): The length of the rectangle.\n    width (float): The width of the rectangle.\n    Returns:\n    float: The area of the rectangle.\n    \n    Examples:\n    >>> rectangle_area(4, 3)\n    12\n    \"\"\"\n    return length * width", "def calculate_rectangle_area(length, width):\n    \"\"\"\n    Calculate the area of a rectangle given its length and width.\n    Parameters:\n    - length (float or int): The length of the rectangle.\n    - width (float or int): The width of the rectangle.\n    Returns:\n    - float: Area of the rectangle.\n    \n    Examples:\n    >>> calculate_rectangle_area(10, 5)\n    50\n    \"\"\"\n    return length * width", "def calculate_rectangle_area(length, width):\n    \"\"\"\n    Calculate the area of a rectangle.\n    Parameters:\n    length (float): The length of the rectangle.\n    width (float): The width of the rectangle.\n    Returns:\n    float: The area of the rectangle.\n    Examples:\n    >>> calculate_rectangle_area(5, 3)\n    15\n    >>> calculate_rectangle_area(7.5, 2.3)\n    17.25\n    \"\"\"\n    return length * width", "def area_rectangle(length, width):\n    \"\"\"\n    Calculate the area of a rectangle.\n    Parameters:\n        length (float): The length of the rectangle.\n        width (float): The width of the rectangle.\n    Returns:\n        float: The area of the rectangle.\n    \n    Examples:\n    >>> area_rectangle(5, 3)\n    15\n    \"\"\"\n    return length * width"], ["def triangle_area_by_coordinates(x1, y1, x2, y2, x3, y3):\n    \"\"\"\n    Calculate the area of a triangle given the coordinates of its vertices.\n    Parameters:\n    x1, y1 (float): Coordinates of the first vertex.\n    x2, y2 (float): Coordinates of the second vertex.\n    x3, y3 (float): Coordinates of the third vertex.\n    Returns:\n    float: The absolute value of the area of the triangle.\n    Examples:\n    >>> triangle_area_by_coordinates(0, 0, 4, 0, 2, 3)\n    6.0\n    \"\"\"\n    return abs(x1*(y2-y3) + x2*(y3-y1) + x3*(y1-y2)) / 2", "def coordinates_to_area(x1, y1, x2, y2, x3, y3):\n    \"\"\"\n    Calculate the area of a triangle given the coordinates of its vertices.\n    Parameters:\n    x1, y1 (float): coordinates of the first vertex.\n    x2, y2 (float): coordinates of the second vertex.\n    x3, y3 (float): coordinates of the third vertex.\n    Returns:\n    float: the area of the triangle.\n    \"\"\"\n    return abs((x1*(y2 - y3) + x2*(y3 - y1) + x3*(y1 - y2)) / 2.0)", "def triangle_area_by_vertices(x1, y1, x2, y2, x3, y3):\n    \"\"\"\n    Calculate the area of a triangle given the coordinates of its vertices.\n    \n    Parameters\n    ----------\n    x1, y1 : float\n        Coordinates of the first vertex.\n    x2, y2 : float\n        Coordinates of the second vertex.\n    x3, y3 : float\n        Coordinates of the third vertex.\n    \n    Returns\n    -------\n    float\n        The absolute area of the triangle.\n    Examples\n    --------\n    >>> triangle_area_by_vertices(0, 0, 4, 0, 0, 3)\n    6.0\n    \"\"\"\n    return abs((x1*(y2 - y3) + x2*(y3 - y1) + x3*(y1 - y2)) / 2.0)", "def triangle_area_by_coordinates(x1, y1, x2, y2, x3, y3):\n    \"\"\"\n    Calculate the area of a triangle given the coordinates of its vertices.\n    Parameters:\n    - x1, y1 (float): Coordinates of the first vertex.\n    - x2, y2 (float): Coordinates of the second vertex.\n    - x3, y3 (float): Coordinates of the third vertex.\n    Returns:\n    - float: The area of the triangle.\n    Examples:\n    >>> triangle_area_by_coordinates(0, 0, 4, 0, 2, 3)\n    6.0\n    \"\"\"\n    area = 0.5 * np.abs(x1*(y2 - y3) + x2*(y3 - y1) + x3*(y1 - y2))\n    return area", "def area_of_triangle(vertices):\n    \"\"\"\n    Calculate the area of a triangle given its vertices in 2D space.\n    Parameters:\n    vertices: numpy.array\n        A (3, 2) array representing the coordinates of the triangle's vertices.\n    Returns:\n    float\n        The absolute value of the area of the triangle.\n    Examples:\n    >>> area_of_triangle(np.array([[0, 0], [4, 0], [2, 3]]))\n    6.0\n    \"\"\"\n    x1, y1 = vertices[0]\n    x2, y2 = vertices[1]\n    x3, y3 = vertices[2]\n    return abs((x1*(y2 - y3) + x2*(y3 - y1) + x3*(y1 - y2)) / 2.0)"], ["def polygon_area_sides(n_sides, side_length):\n    \"\"\"\n    Calculate the area of a regular polygon using the number of sides and the side length.\n    Parameters:\n    n_sides (int): The number of sides of the regular polygon.\n    side_length (float): The length of each side.\n    Returns:\n    float: The area of the polygon.\n    \n    Example:\n    >>> polygon_area_sides(4, 5)  # Square\n    25.0\n    \"\"\"\n    if n_sides < 3:\n        raise ValueError(\"A polygon must have at least three sides.\")\n    perimeter = n_sides * side_length\n    apothem = side_length / (2 * math.tan(math.pi / n_sides))\n    return 0.5 * perimeter * apothem", "def area_regular_polygon(num_sides, side_length):\n    \"\"\"Calculate the area of a regular polygon using the number of sides and the side length.\n    \n    Parameters:\n    - num_sides (int): The number of sides of the polygon.\n    - side_length (float): The length of each side of the polygon.\n    \n    Returns:\n    - float: The area of the polygon.\n    \n    Example:\n    >>> area_regular_polygon(6, 2)\n    10.3923\n    \"\"\"\n    # Calculate the apothem\n    apothem = side_length / (2 * math.tan(math.pi / num_sides))\n    perimeter = num_sides * side_length\n    return 0.5 * perimeter * apothem"], ["def parallelogram_area_from_vectors(vec1, vec2):\n    \"\"\"\n    Calculate the area of a parallelogram given two vectors.\n    Parameters:\n    vec1 (np.array): The first vector as a numpy array.\n    vec2 (np.array): The second vector as a numpy array.\n    \n    Returns:\n    float: The area of the parallelogram.\n    Examples:\n    >>> vec1 = np.array([1, 0, 0])\n    >>> vec2 = np.array([0, 1, 0])\n    >>> parallelogram_area_from_vectors(vec1, vec2)\n    1.0\n    >>> vec1 = np.array([3, -1])\n    >>> vec2 = np.array([2, 4])\n    >>> parallelogram_area_from_vectors(vec1, vec2)\n    14.0\n    \"\"\"\n    if len(vec1) == 2:  # Handle 2D by adding a zero z-component\n        vec1 = np.append(vec1, 0)\n        vec2 = np.append(vec2, 0)\n    # Cross product of the two vectors\n    cross_prod = np.cross(vec1, vec2)\n    \n    # The magnitude of the cross product is the area of parallelogram\n    area = np.linalg.norm(cross_prod)\n    \n    return area", "def area_of_parallelogram_2D(v1, v2):\n    \"\"\"\n    Calculate the area of a parallelogram spanned by two vectors in 2D.\n    Parameters:\n    v1: np.array\n        A 2-element array representing the first vector.\n    v2: np.array\n        A 2-element array representing the second vector.\n    Returns:\n    float\n        The absolute value of the area of the parallelogram.\n    Examples:\n    >>> area_of_parallelogram_2D(np.array([1, 0]), np.array([0, 2]))\n    2.0\n    \"\"\"\n    return abs(np.cross(v1, v2))", "def area_of_parallelogram_3D(v1, v2):\n    \"\"\"\n    Calculate the area of a parallelogram spanned by two vectors in 3D using the cross product.\n    Parameters:\n    v1: np.array\n        A 3-element array representing the first vector.\n    v2: npally\n        A 3-element array representing the second vector.\n    Returns:\n    float\n        The area of the parallelogram formed by the vectors.\n    Examples:\n    >>> area_of_parallelogram_3D(np.array([1, 0, 0]), np.array([0, 1, 0]))\n    1.0\n    \"\"\"\n    return np.linalg.norm(np.cross(v1, v2))"], ["def calculate_composite_area(*args):\n    \"\"\"\n    Calculate the total area of multiple individual areas passed as arguments.\n    Parameters:\n    - args (float): Individual areas to be summed.\n    Returns:\n    - float: The total area of all individual areas combined.\n    Examples:\n    >>> calculate_composite_area(10, 15, 5)\n    30\n    \"\"\"\n    return sum(args)", "def calculate_composite_area(*areas):\n    \"\"\"\n    Calculates the combined area of multiple shapes or subtracts overlapping areas if specified.\n    Parameters:\n    *areas (tuple): A variable number of areas. Positive values add to the total area, and negative values subtract, representing overlaps.\n    Returns:\n    float: The net area of the composite shape.\n    Example:\n    >>> calculate_composite_area(25, 15, -5)\n    35\n    \"\"\"\n    return sum(areas)"], ["def are_collinear(p1: Tuple[float, float], p2: Tuple[float, float], p3: Tuple[float, float]) -> bool:\n    \"\"\"\n    Determine if three points are collinear (lie on a single straight line).\n    Parameters:\n    - p1, p2, p3 (Tuple[float, float]): Coordinates of the points.\n    Returns:\n    - bool: True if the points are collinear, False otherwise.\n    Examples:\n    >>> print(are_collinear((0, 0), (1, 1), (2, 2)))\n    True\n    >>> print(are_collinear((0, 0), (1, 2), (2, 4)))\n    False\n    \"\"\"\n    # Calculation using the area of triangle method\n    # If the area is zero, they are collinear\n    return polygon_area([p1, p2, p3]) == 0", "def is_collinear(p1, p2, p3):\n    \"\"\"\n    Determine if three points are collinear.\n    \n    Parameters:\n    - p1, p2, p3 (tuple or list): Each should be a tuple or list representing the (x, y) coordinates of a point.\n    \n    Returns:\n    - bool: Returns True if the three points are collinear (lie on a single straight line), otherwise False.\n    \n    Examples:\n    >>> is_collinear((0, 0), (1, 1), (2, 2))\n    True\n    >>> is_collinear((0, 0), (1, 1), (2, 3))\n    False\n    \"\"\"\n    x1, y1 = p1\n    x2, y2 = p2\n    x3, y3 = p3\n    matrix = np.array([\n        [x1, y1, 1],\n        [x2, y2, 1],\n        [x3, y3, 1]\n    ])\n    determinant = np.linalg.det(matrix)\n    return abs(determinant) < 1e-10"], ["def square_area(side_length):\n    \"\"\"\n    The function takes the side length of a square as input \n    and returns its area.\n    \"\"\"\n    return side_length**2", "def square_side_area(area):\n    \"\"\"\n    The function takes area of a square as input \n    and returns its side length.\n    \"\"\"\n    return math.sqrt(area)"], ["def area_of_composite_shape(sub_shapes):\n    \"\"\"\n    Calculate the total area of a composite shape based on individual sub-shape areas.\n    Can also be used to perform area operations for probability or comparison tasks.\n    Parameters:\n    - sub_shapes (list of tuples): List where each tuple contains the shape type and its keyword arguments. Example format: [('rectangle', {'length': 5, 'width': 4}), ('triangle', {'base': 3, 'height': 3})]\n    Returns:\n    - float: Total calculated area of the composite figure.\n    Example:\n    - area_of_composite_shape([\n        ('rectangle', {'length': 5, 'width': 4}),\n        ('triangle', {'base': 3, 'height': 3})\n      ])\n    \"\"\"\n    total_area = 0.0\n    for shape in sub_shapes:\n        shape_type, params = shape\n        total_area += area_of_shape(shape_type, **params)\n    return total_area", "def composite_triangle_area(shapes):\n    \"\"\"\n    Calculate the total area of a composite shape broken down into triangles.\n    \n    Parameters:\n    - shapes (list of dict): A list where each dictionary represents a triangle with keys\n      `type` (str, values: 'base-height', 'sides', 'angle-side') and parameters like `base`, `height`, `side1`, etc.\n    \n    Returns:\n    - float: The total area of the composite shape.\n    \n    Example:\n    >>> shapes = [\n        {\"type\": \"base-height\", \"base\": 5, \"height\": 2},\n        {\"type\": \"sides\", \"side1\": 3, \"side2\": 4, \"side3\": 5},\n        {\"type\": \"angle-side\", \"angle\": math.pi/4, \"side1\": 4, \"side2\": 6}\n    ]\n    >>> composite_triangle_area(shapes)\n    \"\"\"\n    total_area = 0\n    for shape in shapes:\n        if shape['type'] == 'base-height':\n            total_area += triangle_area_by_base_height(shape['base'], shape['height'])\n        elif shape['type'] == 'sides':\n            total_area += triangle_area_by_sides(shape['side1'], shape['side2'], shape['side3'])\n        elif shape['type'] == 'angle-side':\n            total_area += triangle_area_by_angle_side(shape['angle'], shape['side1'], shape['side2'])\n    return total_area", "def area_composite_shape(shapes):\n    \"\"\"\n    Calculate the area of a composite shape given a list of shapes and their respective area calculation functions.\n    Parameters:\n        shapes (list of dicts): A list where each dict has 'shape_func' and 'params' keys.\n            'shape_func' is a reference to the function used to calculate the area of the shape.\n            'params' is a dictionary of parameters to pass to the area function.\n    Returns:\n        float: The cumulative area of the composite shapes.\n    Examples:\n        >>> area_composite_shape([{'shape_func': area_rectangle, 'params': {'length': 4, 'width': 3}},\n                                  {'shape_func': area_triangle, 'params': {'base': 4, 'height': 3}}])\n        18\n    \"\"\"\n    total_area = 0\n    for shape in shapes:\n        shape_func = shape['shape_func']\n        params = shape['params']\n        total_area += shape_func(**params)\n    return total_area", "def calculate_composite_area(shapes):\n    \"\"\"\n    Calculate the total area of a composite shape given individual rectangle areas.\n    Parameters:\n    shapes (list of dicts): Each dictionary contains the dimensions of each rectangle\n                            with keys 'length' and 'width'.\n    Returns:\n    float: The total area of the composite shape.\n    Examples:\n    >>> shapes = [{'length': 5, 'width': 3}, {'length': 2, 'width': 4}]\n    >>> calculate_composite_area(shapes)\n    22\n    \"\"\"\n    total_area = 0\n    for shape in shapes:\n        total_area += calculate_rectangle_area(shape['length'], shape['width'])\n    return total_area", "def decompose_and_compute_area(shapes):\n    \"\"\"\n    Calculate the total area by decomposing a complex figure into known shapes.\n    Parameters:\n        shapes (list): A list of tuples where each tuple contains shape type and its dimensions.\n                       Example: [('rectangle', (length, width)), ('circle', (radius,)), ('triangle', (base, height))]\n    Returns:\n        float: The total area of the composite figure.\n    Examples:\n    >>> decompose_and_compute_area([('rectangle', (5, 3)), ('triangle', (4, 6))])\n    27.0\n    \"\"\"\n    area = 0\n    for shape in shapes:\n        if shape[0] == 'rectangle':\n            area += area_rectangle(*shape[1])\n        elif shape[0] == 'circle':\n            area += area_circle(*shape[1])\n        elif shape[0] == 'triangle':\n            area += area_triangle(*shape[1])\n    return area"], ["def derive_side_lengths(shape, **kwargs):\n    \"\"\"\n    Derive side lengths using geometric and trigonometric relations for various shapes.\n    \n    Parameters\n    ----------\n    shape : str\n        Type of geometric shape ('triangle_cosine', 'polygon_diagonal')\n    kwargs: various\n        Known lengths, angles, and other relevant properties depending on the shape.\n    \n    Returns\n    -------\n    float\n        The derived side length or lengths depending on the calculation.\n    \n    Examples\n    --------\n    >>> derive_side_lengths('triangle_cosine', a=5, b=5, angle=60)\n    5.0\n    >>> derive_side_lengths('polygon_diagonal', side=4, n_sides=4)  # Diagonal of a square\n    5.656854249492381\n    \"\"\"\n    if shape == 'triangle_cosine':\n        a, b, angle = kwargs['a'], kwargs['b'], kwargs['angle']\n        angle_rad = np.radians(angle)\n        return sqrt(a**2 + b**2 - 2*a*b*np.cos(angle_rad))\n    elif shape == 'polygon_diagonal':\n        side, n_sides = kwargs['side'], kwargs['n_sides']\n        if n_sides == 4:  # square or rectangle logic\n            return sqrt(2) * side\n        else:\n            raise ValueError(\"Diagonal calculation for this polygon not supported\")"], ["def area_calculator(shape, **kwargs):\n    \"\"\"\n    Calculate the area of various geometric shapes.\n    Parameters:\n    - shape (str): The type of shape (\"triangle\", \"square\", \"rectangle\", \"circle\", \"polygon\").\n    - **kwargs: Keyword arguments relevant to the specific shape:\n        - For \"triangle\": base and height or alternatively, sides (a, b, c) for Heron's formula.\n        - For \"square\" or \"rectangle\": side_length (for square) and length and width (for rectangle).\n        - For \"circle\": radius.\n        - For \"polygon\": list of vertices [(x1, y1), (x2, y2), ...].\n    Returns:\n    float: The area of the shape.\n    Example:\n    >>> area_calculator('triangle', base=10, height=5)\n    25.0\n    >>> area_calculator('square', side_length=4)\n    16.0\n    >>> area_calculator('rectangle', length=4, width=3)\n    12.0\n    >>> area_calculator('circle', radius=3)\n    28.274333882308138\n    \"\"\"\n    if shape == \"triangle\":\n        if 'base' in kwargs and 'height' in kwargs:\n            return 0.5 * kwargs['base'] * kwargs['height']\n        elif all(k in kwargs for k in ('a', 'b', 'c')):\n            # Heron's formula\n            a, b, c = kwargs['a'], kwargs['b'], kwargs['c']\n            s = (a + b + c) / 2\n            return math.sqrt(s * (s - a) * (s - b) * (s - c))\n        else:\n            raise ValueError(\"Insufficient parameters for triangle\")\n    elif shape == \"square\":\n        side_length = kwargs.get('side_length')\n        if side_length is None:\n            raise ValueError(\"side_length parameter is required for square\")\n        return side_length ** 2\n    elif shape == \"rectangle\":\n        length = kwargs.get('length')\n        width = kwargs.get('width')\n        if length is None or width is None:\n            raise ValueError(\"length and width parameters are required for rectangle\")\n        return length * width\n    elif shape == \"circle\":\n        radius = kwargs.get('radius')\n        if radius is None:\n            raise ValueError(\"radius parameter is required for circle\")\n        return math.pi * radius ** 2\n    elif shape == \"polygon\":\n        vertices = kwargs.get('vertices')\n        if vertices is None:\n            raise ValueError(\"vertices parameter is required for polygon\")\n        # Using the shoelace formula\n        num_points = len(vertices)\n        area = sum(vertices[i][0]*vertices[(i+1)%num_points][1] - vertices[(i+1)%num_points][0]*vertices[i][1] for i in range(num_points))/2\n        return abs(area)\n    else:\n        raise ValueError(\"Unknown shape\")", "def perimeter_calculator(shape, **kwargs):\n    \"\"\"\n    Calculate the perimeter or circumference of various geometric shapes.\n    Parameters:\n    - shape (str): The type of shape (\"triangle\", \"square\", \"rectangle\", \"circle\", \"polygon\").\n    - **kwargs: Keyword arguments relevant to the specific shape:\n        - For \"triangle\", \"square\", \"rectangle\": sides.\n        - For \"circle\": radius.\n        - For \"polygon\": list of vertices [(x1, y1), (x2, y2), ...].\n    Returns:\n    float: The perimeter of the shape.\n    Example:\n    >>> perimeter_calculator('triangle', sides=(3, 4, 5))\n    12\n    >>> perimeter_calculator('square', side_length=5)\n    20\n    >>> perimeter_calculator('rectangle', length=5, width=3)\n    16\n    >>> perimeter_calculator('circle', radius=3)\n    18.84955592153876\n    \"\"\"\n    if shape in ['triangle', 'square', 'rectangle']:\n        sides = kwargs.get('sides', (kwargs.get('side_length'),)*4 if shape == 'square' else (\n            kwargs.get('length'), kwargs.get('width'))*2 if shape == 'rectangle' else None)\n        if sides is None:\n            raise ValueError(f\"sides or relevant dimensions needed for {shape}\")\n        return sum(sides)\n    elif shape == \"circle\":\n        radius = kwargs.get('radius')\n        if radius is None:\n            raise ValueError(\"radius parameter is required for circle\")\n        return 2 * math.pi * radius\n    elif shape == \"polygon\":\n        vertices = kwargs.get('vertices')\n        if vertices is None:\n            raise ValueError(\"vertices parameter is required for polygon\")\n        perimeter = sum(math.dist(vertices[i], vertices[(i+1)%len(vertices)]) for i in range(len(vertices)))\n        return perimeter\n       \n    else:\n        raise ValueError(\"Unknown shape\")", "def area_of_shape(shape_type, **kwargs):\n    \"\"\"\n    Calculate the area of various basic geometric shapes.\n    Parameters:\n    - shape_type (str): Type of the shape ('rectangle', 'triangle', 'circle', 'polygon')\n    - kwargs (dict): Parameters describing dimensions of the shape like base, height, radius, vertices for a polygon\n    Returns:\n    - float: The calculated area of the geometric shape.\n    Examples:\n    - area_of_shape('rectangle', length=5, width=3)\n    - area_of_shape('triangle', base=3, height=4)\n    - area_of_shape('circle', radius=2)\n    - area_of_shape('polygon', vertices=[(0,0), (1,0), (1,1), (0,1)])\n    \"\"\"\n    if shape_type.lower() == 'rectangle':\n        return kwargs['length'] * kwargs['width']\n    elif shape_type.lower() == 'triangle':\n        return 0.5 * kwargs['base'] * kwargs['height']\n    elif shape_type.lower() == 'circle':\n        return math.pi * kwargs['radius'] ** 2\n    elif shape_type.lower() == 'polygon':\n        vertices = [Point(x) for x in kwargs['vertices']]\n        poly = Polygon(*vertices)\n        return poly.area.evalf()\n    else:\n        raise ValueError(\"Unsupported shape type provided.\")", "def calculate_area(shape, **kwargs):\n    \"\"\"\n    Calculate the area of a given shape: 'triangle', 'rectangle', 'circle', or 'regular_polygon'.\n    \n    Parameters\n    ----------\n    shape : str\n        Type of shape ('triangle', 'rectangle', 'circle', 'regular_polygon')\n    kwargs : various\n        side (float): for square and regular polygons\n        length, width (float): for rectangle\n        radius (float): for circle\n        a, b, c (float): side lengths for triangle (use with `s` which is semi-perimeter)\n        n_sides (int): number of sides for a regular polygon\n    Returns\n    -------\n    float\n        The area of the shape\n    Examples\n    --------\n    >>> calculate_area('triangle', a=3, b=4, c=5)\n    6.0\n    >>> calculate_area('rectangle', length=5, width=3)\n    15\n    >>> calculate_area('circle', radius=4)\n    50.26548245743669\n    >>> calculate_area('regular_polygon', side=3, n_sides=5)\n    15.484296605300703\n    \"\"\"\n    if shape == 'triangle':\n        from math import sqrt\n        a, b, c = kwargs['a'], kwargs['b'], kwargs['c']\n        s = (a + b + c) / 2\n        return sqrt(s * (s - a) * (s - b) * (s - c))\n    elif shape == 'rectangle':\n        return kwargs['length'] * kwargs['width']\n    elif shape == 'circle':\n        return pi * kwargs['radius'] ** 2\n    elif shape == 'regular_polygon':\n        side = kwargs['side']\n        n_sides = kwargs['n_sides']\n        return n_sides * (side ** 2) / (4 * tan(pi / n_sides))\n    else:\n        raise ValueError(\"Unsupported shape type\")"], ["def polygon_area(vertices: List[Tuple[float, float]]) -> float:\n    \"\"\"\n    Calculates the area of a polygon given its vertices using the Shoelace Theorem.\n    Parameters:\n    - vertices (List[Tuple[float, float]]): A list of tuples where each tuple represents the x and y coordinates of a vertex.\n    Returns:\n    - float: The absolute value of the calculated area of the polygon.\n    Examples:\n    >>> triangle_area = polygon_area([(0, 0), (4, 0), (2, 3)])\n    >>> print(triangle_area)\n    6.0\n    >>> complex_polygon_area = polygon_area([(1, 2), (3, 4), (5, 0), (0, 0)])\n    >>> print(complex_gpuolygon_areadon_area)\n    10.0\n    \"\"\"\n    # Array of vertices\n    vertices_array = np.array(vertices)\n    # Repeat the first vertex at the end\n    vertices_cycle = np.vstack([vertices_array, vertices_array[0]])\n    # Use NumPy operations for Shoelace formula\n    sum1 = np.sum(vertices_cycle[:-1, 0] * vertices_cycle[1:, 1])\n    sum2 = np.sum(vertices_cycle[:-1, 1] * vertices_cycle[1:, 0])\n    # The area is half the absolute value of the determinant\n    area = abs(sum1 - sum2) / 2\n    return area", "def polygon_area_from_vertices(vertices):\n    \"\"\"\n    Calculate the area of a polygon given its vertices in a coordinate plane. Works for convex polygons,\n    which includes triangles, rectangles, and trapezoids specifically identified by coordinates.\n    Parameters:\n        vertices (list of tuples): List of pairs (tuples) of x and y coordinates of the polygon's vertices.\n    Returns:\n        float: The absolute value of the calculated area of the polygon.\n    Example:\n        >>> polygon_area_from_vertices([(0, 0), (4, 0), (4, 3), (0, 3)])  # Rectangle\n        12.0\n        >>> polygon_area_from_vertices([(0, 0), (4, 0), (2, 3)])  # Triangle\n        6.0\n    \"\"\"\n    n = len(vertices)\n    area = 0.0\n    for i in range(n):\n        j = (i + 1) % n\n        area += vertices[i][0] * vertices[j][1]\n        area -= vertices[j][0] * vertices[i][1]\n    area = abs(area) / 2.0\n    return area", "def calculate_polygon_area(vertices):\n    \"\"\"\n    Calculate the area of a polygon given its vertices using the Shoelace theorem.\n    Parameters:\n    vertices (list of tuples/list/array): List of (x, y) tuples or numpy array representing the vertices of the polygon.\n    Returns:\n    float: The absolute value of the area of the polygon.\n    Examples:\n    >>> calculate_polygon_area([(0, 0), (4, 0), (4, 3), (0, 3)])\n    12.0\n    >>> calculate_polygon_area(np.array([[0, 0], [4, 0], [4, 3], [0, 3]]))\n    12.0\n    \"\"\"\n    # Convert to a numpy array for easier manipulation if not already one\n    vertices = np.array(vertices)\n    n = len(vertices)\n    area = 0.5 * np.abs(np.dot(vertices[:, 0], np.roll(vertices[:, 1], -1)) - np.dot(vertices[:, 1], np.roll(vertices[:, 0], -1)))\n    return area", "def area_polygon_by_vertices(vertices):\n    \"\"\"\n    Calculate the area of a polygon defined by a list of vertices.\n    Parameters:\n        vertices (list of tuples): List of tuples where each tuple represents a vertex (x, y).\n    Returns:\n        float: The area of the polygon.\n    Examples:\n        >>> area_polygon_by_vertices([(0, 0), (4, 0), (4, 3), (0, 3)])\n        12\n    \"\"\"\n    p = Polygon(*[Point(x, y) for x, y in vertices])\n    return float(p.area)", "def polygon_area(vertices):\n    \"\"\"\n    Calculate the area of a polygon given its vertices using the Shoelace Theorem.\n    \n    Parameters:\n    - vertices (numpy.ndarray): A 2D numpy array or list of tuples/lists where each sub-array \n                                or tuple/list represents the x and y coordinates of a vertex. \n                                The vertices must be ordered clockwise or counter-clockwise.\n    Returns:\n    - float: The absolute value of the calculated area of the polygon.\n    \n    Examples:\n    >>> polygon_area(np.array([[0, 0], [4, 0], [4, 4], [0, 4]]))\n    16.0\n    >>> polygon_area([[1, 0], [3, 4], [5, 0]])  # Triangle example\n    8.0\n    \"\"\"\n    vertices = np.asarray(vertices)\n    n = len(vertices)\n    area = 0.5 * np.abs(np.dot(vertices[:,0], np.roll(vertices[:,1], -1)) - np.dot(vertices[:,1], np.roll(vertices[:,0], -1)))\n    return area", "def area_polygon(vertices):\n    \"\"\"\n    Calculate the area of a simple polygon given its vertices.\n    Parameters:\n        vertices (list of tuples): List of (x, y) tuples, each representing a vertex of the polygon.\n    Returns:\n        float: The area of the polygon.\n    Examples:\n    >>> area_polygon([(0, 0), (4, 0), (4, 4), (0, 4)])  # Square with side 4\n    16.0\n    \"\"\"\n    x = np.array([vertex[0] for vertex in vertices])\n    y = np.array([vertex[1] for vertex in vertices])\n    return 0.5 * np.abs(np.dot(x, np.roll(y, 1)) - np.dot(y, np.roll(x, 1)))"], ["def distance(point1: Tuple[float, float], point2: Tuple[float, float]) -> float:\n    \"\"\"\n    Calculate the Euclidean distance between two points in 2D space.\n    Parameters:\n    point1 (Tuple[float, float]): The coordinates (x, y) of the first point.\n    point2 (Tuple[float, float]): The coordinates (x, y) of the second point.\n    Returns:\n    float: The distance between the two points.\n    Examples:\n    >>> distance((1, 2), (4, 6))\n    5.0\n    \"\"\"\n    return math.sqrt((point2[0] - point1[0])**2 + (point2[1] - point1[1])**2)", "def distance_between_points(x1, y1, x2, y2):\n    \"\"\"\n    Calculate the Euclidean distance between two points in the Cartesian plane.\n    Parameters:\n    x1, y1 (float): Coordinates of the first point.\n    x2, y2 (float): Coordinates of the second point.\n    Returns:\n    float: The distance between the points.\n    Examples:\n    >>> distance_between_points(0, 0, 3, 4)\n    5.0\n    \"\"\"\n    return math.sqrt((x2 - x1)**2 + (y2 - y1)**2)", "def distance_between_points(x1, y1, x2, y2):\n    \"\"\"\n    Calculate the Euclidean distance between two points in the 2D coordinate plane.\n    Parameters:\n        x1, y1 (float): Coordinates of the first point.\n        x2, y2 (float): Coordinates of the second point.\n    Returns:\n        float: Euclidean distance between the points.\n    Example:\n        >>> distance_between_points(0, 0, 3, 4)\n        5.0\n    \"\"\"\n    return math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2)", "def calculate_distance(point1, point2):\n    \"\"\"\n    Calculate the distance between two points.\n    Parameters\n    ----------\n    point1 : tuple of float\n        The coordinates of the first point (x, y).\n    point2 : tuple of float\n        The coordinates of the second point (x, y).\n    Returns\n    -------\n    float\n        The distance between the two points.\n    \"\"\"\n    x_distance = point2[0] - point1[0]\n    y_distance = point2[1] - point1[1]\n    return math.sqrt(x_distance**2 + y_distance**2)"], ["def area_sector(radius, angle_deg):\n    \"\"\"\n    Calculate the area of a sector of a circle given its radius and central angle in degrees.\n    Parameters:\n    - radius (float): The radius of the circle.\n    - angle_deg (float): The angle of the sector in degrees.\n    \n    Returns:\n    - float: The area of the sector.\n    \n    Example:\n    >>> area_sector(4, 90)\n    12.566370614359172\n    \"\"\"\n    angle_rad = math.radians(angle_deg)\n    return 0.5 * radius**2 * angle_rad", "def sector_area(radius, angle_degrees):\n    \"\"\"\n    Calculate the area of a sector of a circle given the radius and the central angle in degrees.\n    Parameters:\n        radius (float): The radius of the circle.\n        angle_degrees (float): The angle of the sector in degrees.\n    Returns:\n        float: The area of the sector.\n    Examples:\n        >>> sector_area(10, 90)\n        78.53981633974483\n    \"\"\"\n    return (angle_degrees / 360) * math.pi * radius ** 2", "def area_sector(radius, angle_degrees):\n    \"\"\"\n    Calculate the area of a circular sector given the radius and angle in degrees.\n    Parameters:\n    radius (float): the radius of the circle.\n    angle_degrees (float): the angle of the sector in degrees.\n    Returns:\n    float: the area of the sector\n    \"\"\"\n    import math\n    return (angle_degrees / 360) * math.pi * radius ** 2", "def sector_area(radius, angle_degrees):\n    \"\"\"\n    Calculate the area of a sector of a circle given its radius and the angle in degrees.\n    Parameters\n    ----------\n    radius : float\n        The radius of the circle.\n    angle_degrees : float\n        The angle of the sector in degrees.\n    Returns\n    -------\n    float\n        The area of the sector.\n    \n    Examples\n    --------\n    >>> sector_area(3, 90)\n    7.0685834705770345\n    >>> sector_area(5, 360)\n    78.53981633974483\n    \"\"\"\n    return (angle_degrees / 360.0) * math.pi * (radius ** 2)", "def sector_area(radius, angle_degrees):\n    \"\"\"\n    Calculate the area of a circle's sector.\n    Parameters:\n    radius (float): Radius of the circle from which the sector is part.\n    angle_degrees (float): Angle of the sector in degrees.\n    Returns:\n    float: The area of the sector.\n    \n    Examples:\n    >>> sector_area(3, 90)\n    7.0685834705770345\n    \"\"\"\n    angle_radians = math.radians(angle_degrees)\n    return (angle_radians / (2 * pi)) * circle_area(radius)", "def area_sector(radius, angle_degree):\n    \"\"\"Calculate the area of a sector of a circle given its radius and angle in degrees.\n    \n    Parameters:\n    - radius (float): The radius of the circle.\n    - angle_degree (float): The angle of the sector in degrees.\n    \n    Returns:\n    - float: The calculated area of the sector.\n    \n    Example:\n    >>> area_sector(3, 90)\n    7.0685834705770345\n    \"\"\"\n    angle_radian = math.radians(angle_degree)\n    return (angle_ragian * (radius ** 2)) / 2"], ["def triangle_area_heron(a, b, c):\n    \"\"\"\n    Calculate the area of a triangle with side lengths a, b, and c using Heron's Formula:\n    s = (a + b + c) / 2  # semi-perimeter\n    Area = sqrt(s * (s - a) * (s - b) * (s - c))\n    \n    Parameters:\n    a (float): Length of the first side of the triangle.\n    b (float): Length of the second side of the triangle.\n    c (float): Length of the third side of the triangle.\n    Returns:\n    float: The area of the triangle.\n    \n    Example:\n    >>> triangle_area_heron(3, 4, 5)\n    6.0\n    \"\"\"\n    s = (a + b + c) / 2\n    # Calculating the area using the Heron's formula\n    area = math.sqrt(s * (s - a) * (s - b) * (s - c))\n    return area", "def triangle_area_by_sides(a, b, c):\n    \"\"\"\n    Calculate the area of a triangle using the lengths of its sides using Heron's formula.\n    Parameters:\n    a, b, c (float): Lengths of the sides of the triangle.\n    Returns:\n    float: The area of the triangle.\n    Examples:\n    >>> triangle_area_by_sides(3, 4, 5)\n    6.0\n    \"\"\"\n    s = (a + b + c) / 2\n    area = math.sqrt(s * (s - a) * (s - b) * (s - c))\n    return area", "def triangle_area_by_sides(a, b, c):\n    \"\"\"\n    Calculate the area of a triangle given the lengths of its sides using Heron's formula.\n    \n    Parameters:\n    - a (float): Length of the first side.\n    - b (float): Length of the second side.\n    - c (float): Length of the third side.\n    \n    Returns:\n    - float: The area of the triangle or NaN if the sides do not form a valid triangle.\n    \n    Example:\n    >>> triangle_area_by_sides(3, 4, 5)\n    6.0\n    \"\"\"\n    if (a >= b + c) or (b >= a + c) or (c >= a + b):\n        return float('nan')  # Sides do not form a triangle\n    s = (a + b + c) / 2\n    area_sqrt = s * (s - a) * (s - b) * (s - c)\n    return math.sqrt(area_sqrt)", "def triangle_area_by_sides_heron(a, b, c):\n    \"\"\"\n    Calculate the area of a triangle given the lengths of all three sides using Heron's formula.\n    \n    Parameters\n    ----------\n    a : float\n        Length of the first side.\n    b : float\n        Length of the second side.\n    c : float\n        Length of the third side.\n    \n    Returns\n    -------\n    float\n        The area of the triangle.\n    Examples\n    --------\n    >>> triangle_area_by_sides_heron(3, 4, 5)\n    6.0\n    \"\"\"\n    s = (a + b + c) / 2\n    area = math.sqrt(s * (s - a) * (s - b) * (s - c))\n    return area", "def triangle_area_sss(a, b, c):\n    \"\"\"\n    Calculate the area of a triangle given three sides using Heron's formula.\n    Parameters:\n    a (float): Length of the first side.\n    b (float): Length of the second side.\n    c (float): Length of the third side.\n    Returns:\n    float: The area of the triangle.\n    \n    Example:\n    >>> triangle_area_sss(3, 4, 5)\n    6.0\n    \"\"\"\n    s = (a + b + c) / 2\n    area = math.sqrt(s * (s - a) * (s - b) * (s - c))\n    return area", "def HeronFormulaCalculator(a, b, c):\n    \"\"\"\n    Calculate the area of a triangle using Heron's formula given the side lengths.\n    Parameters:\n    - a (float): Length of the first side of the triangle.\n    - b (float): Length of the second side of the triangle.\n    - c (float): Length of the third side of the triangle.\n    Returns:\n    - float: The area of the triangle calculated using Heron's formula.\n    Examples:\n    - HeronFormulaCalculator(3, 4, 5)\n    Raises:\n    - ValueError: If the sum of two sides is less than the third side (not forming a triangle).\n    \"\"\"\n    import math\n    # Check for the validity of the triangle\n    if a + b <= c or a + c <= b or b + c <= a:\n        raise ValueError(\"These sides do not form a valid triangle.\")\n    # Calculate the semi-perimeter\n    s = 0.5 * (a + b + c)\n    # Calculate the area using Heron's formula\n    area = math.sqrt(s * (s - a) * (s - b) * (s - c))\n    return area", "def triangle_area_by_sides(a, b, c):\n    \"\"\"\n    Calculate the area of a triangle given the lengths of its sides using Heron's formula.\n    Parameters:\n    - a, b, c (float): Lengths of the sides of the triangle.\n    Returns:\n    - float: The area of the triangle.\n    Examples:\n    >>> triangle_area_by_sides(3, 4, 5)\n    6.0\n    \"\"\"\n    s = (a + b + c) / 2\n    area = sqrt(s * (s - a) * (s - b) * (s - c))\n    return area", "def area_triangle_by_sides(a, b, c):\n    \"\"\"Calculate the area of a triangle using Heron's formula given the sides of the triangle.\n    \n    Parameters:\n    - a, b, c (float): The lengths of the sides of the triangle.\n    \n    Returns:\n    - float: The calculated area using Heron's formula.\n    \n    Example:\n    >>> area_triangle_by_sides(3, 4, 5)\n    6.0\n    \"\"\"\n    s = (a + b + c) / 2  # semi-perimeter\n    area = math.sqrt(s * (s - a) * (s - b) * (s - c))\n    return area"], ["def calculate_parallelogram_area(base, height):\n    \"\"\"\n    Calculate the area of a parallelogram given the base and height.\n    Parameters:\n    - base (float): The length of the base of the parallelogram.\n    - height (float): The height of the parallelogram measured perpendicular to the base.\n    \n    Returns:\n    - float: The area of the parallelogram.\n    Examples:\n    >>> calculate_parallelogram_area(5, 3)\n    15.0\n    \"\"\"\n    return base * height", "def area_of_parallelogram_with_base_height(base, height):\n    \"\"\"\n    Calculate the area of a parallelogram using base and height.\n    Parameters:\n    base: float\n        Length of the base of the parallelogram.\n    height: float\n        Height from the base to the opposite side (perpendicular).\n    Returns:\n    float\n        The area of the parallelogram.\n    Examples:\n    >>> area_of_parallelogram_with_base_height(4, 3)\n    12.0\n    \"\"\"\n    return base * height"], ["def triangle_area_by_angle_side(angle, side1, side2):\n    \"\"\"\n    Calculate the area of a triangle given an angle and two sides enclosing the angle.\n    \n    Parameters:\n    - angle (float): Angle in radians between the two sides.\n    - side1 (float), side2 (float): Lengths of the sides that enclose the angle.\n    \n    Returns:\n    - float: The area of the triangle.\n    \n    Example:\n    >>> triangle_area_by_angle_side(math.pi / 2, 3, 4)  # Right angle\n    6.0\n    \"\"\"\n    return 0.5 * side1 * side2 * math.sin(angle)", "def triangle_area_by_sides_and_angle(a, b, angle):\n    \"\"\"\n    Calculate the area of a triangle given two sides and the included angle (in degrees).\n    \n    Parameters\n    ----------\n    a : float\n        Length of the first side.\n    b : float\n        Length of the second side.\n    angle : float\n        Included angle between the sides in degrees.\n    \n    Returns\n    -------\n    float\n        The area of the triangle.\n    Examples\n    --------\n    >>> triangle_area_by_sides_and_angle(5, 5, 90)\n    12.5\n    \"\"\"\n    radians = math.radians(angle)\n    return 0.5 * a * b * math.sin(radians)"], ["def complex_shape_area(components):\n    \"\"\"\n    Calculate the total area of a complex geometric shape decomposed into simpler components.\n    Parameters:\n    - components (list of tuples): List of tuples, each containing the function to compute the area and its parameters.\n    Returns:\n    - float: The total area of the complex shape.\n    Examples:\n    >>> components = [(triangle_area_by_base_height, (4, 3)), (triangle_area_by_base_height, (2, 6))]\n    >>> complex_shape_area(components)\n    15.0\n    \"\"\"\n    total_area = 0\n    for func, args in components:\n        total_area += func(*args)\n    return total_area"], ["def area_of_semicircle(radius):\n    \"\"\"\n    Calculate the area of a semicircle given the radius.\n    Parameters:\n    radius (float): Radius of the semicircle.\n    Returns:\n    float: The area of the semicircle.\n    Example:\n    >>> area_of_semicircle(4)\n    25.132741228718345\n    \"\"\"\n    return (math.pi * (radius ** 2)) / 2", "def area_semicircle(radius):\n    \"\"\"\n    Calculate the area of a semicircle given its radius.\n    Parameters:\n        radius (float): The radius of the semicircle.\n    Returns:\n        float: The area of the semicircle.\n    \n    Examples:\n        >>> area_semicircle(5)\n        39.269908169872415\n    \"\"\"\n    return 0.5 * area_circle(radius)"], ["def area_rhombus(diagonal1, diagonal2):\n    \"\"\"\n    Calculate the area of a rhombus given the lengths of its diagonals.\n    Parameters:\n    diagonal1 (float): length of the first diagonal.\n    diagonal2 (float): length of the second diagonal.\n    Returns:\n    float: the area of the rhombus calculated as 0.5*d1*d2\n    \"\"\"\n    return 0.5 * diagonal1 * diagonal2", "def rhombus_area(diagonal1, diagonal2):\n    \"\"\"\n    Calculate the area of a rhombus given lengths of its diagonals.\n    Parameters:\n    diagonal1 (float): Length of the first diagonal.\n    diagonal2 (float): Length of the second diagonal.\n    Returns:\n    float: The area of the rhombus.\n    \n    Examples:\n    >>> rhombus_area(5, 4)\n    10.0\n    \"\"\"\n    return 0.5 * diagonal1 * diagonal2", "def area_rhombus_by_diagonals(d1, d2):\n    \"\"\"Calculate the area of a rhombus given the lengths of its diagonals.\n    \n    Parameters:\n    - d1 (float): Diagonal 1 length.\n    - d2 (float): Diagonal 2 length.\n    \n    Returns:\n    - float: The calculated area of the rhombus.\n    \n    Example:\n    >>> area_rhombus_by_diagonals(4, 5)\n    10.0\n    \"\"\"\n    return d1 * d2 / 2"], ["def calculate_area_with_unknown(length, width=None, area=None):\n    \"\"\"\n    Calculate the area of a rectangle when either the width or area is unknown.\n    If width is provided, it calculates the area. If area is provided, it calculates\n    the width. One of width or area must be None.\n    Parameters:\n    length (float): The length of the rectangle.\n    width (float): The width of the rectangle. Default to None if not provided.\n    area (float): The area of the rectangle. Default to None if not provided.\n    Returns:\n    float or Symbol: The calculated dimension (area or width), or a symbolic expression if not solvable.\n    Examples:\n    >>> calculate_area_with_unknown(5, width=3)\n    15\n    >>> calculate_area_with_unknown(10, area=50)\n    5\n    Raises:\n    ValueError: If both width and area are provided, or both are None.\n    \"\"\"\n    if width is not None and area is not None:\n        raise ValueError(\"Only one of width or area should be provided, not both.\")\n    elif width is None and area is None:\n        raise ValueError(\"One of width or area must be provided.\")\n    \n    x = symbols('x')  # Represent the unknown dimension\n    \n    if width is None:\n        # Solve for width\n        equation = Eq(length * x, area)\n        width = solve(equation, x)\n        return width[0] if width else x\n    else:\n        # Calculate area\n        return calculate_rectangle_area(length, width)"], ["def calculate_composite_area(*args) -> float:\n    \"\"\"\n    Function to calculate the area of a composite shape.\n    \n    Parameters:\n    *args: Tuples where each tuple represents a shape and its dimensions. The first element is the shape name and the following elements are the dimensions.\n    \n    Returns:\n    float: The total area of the composite shape.\n    \n    Examples:\n    >>> calculate_composite_area(('square', 2),('circle',3))\n    17\n    >>> calculate_composite_area(('rectangle',2,3),('triangle',2,3))\n    9\n    \"\"\"\n    total_area = 0\n    for shape in args:\n        total_area += calculate_area(*shape)\n    return total_area"], ["def TriangleAreaCalculator(base=None, height=None, vertices=None, sides=None):\n    \"\"\"\n    Calculate the area of a triangle given base and height, vertices, or side lengths.\n    Parameters:\n    - base (float): The base of the triangle.\n    - height (float): The height of the triangle perpendicular to the base.\n    - vertices (list of tuples): List of coordinates for the triangle's vertices as (x, y).\n    - sides (tuple): The lengths of the three sides of the triangle.\n    Returns:\n    - float: The area of the triangle.\n    Examples:\n    - TriangleAreaCalculator(base=5, height=3)\n    - TriangleAreaCalculator(vertices=[(0, 0), (5, 0), (0, 3)])\n    - TriangleAreaCalculator(sides=(3, 4, 5))\n    \"\"\"\n    import math\n    if base is not None and height is not None:\n        # Simple calculation from base and height\n        return 0.5 * base * height\n    elif vertices is not None:\n        # Calculate area from vertices using determinant (shoelace formula)\n        x1, y1 = vertices[0]\n        x2, y2 = vertices[1]\n        x3, y3 = vertices[2]\n        return 0.5 * abs(x1*(y2-y3) + x2*(y3-y1) + x3*(y1-y2))\n    elif sides is not None:\n        # Using Heron's formula to find area when sides are known\n        a, b, c = sides\n        s = 0.5 * sum(sides)\n        area = math.sqrt(s * (s - a) * (s - b) * (s - c))\n        return area\n    else:\n        raise ValueError(\"Insufficient information to calculate area.\")"], ["def calculate_circle_area(radius):\n    \"\"\"\n    Calculate the area of a circle given its radius.\n    Parameters:\n    - radius (float/int): The radius of the circle.\n    Returns:\n    - float: The computed area of the circle using pi.\n    Examples:\n    >>> calculate_circle_area(3)\n    28.274333882308138\n    \"\"\"\n    return math.pi * radius ** 2", "def calculate_circle_area(radius):\n    \"\"\"\n    Calculates the area of a circle given the radius.\n    Parameters:\n    radius (float): The radius of the circle.\n    Returns:\n    float: The area of the circle, calculated as π * radius^2.\n    Example:\n    >>> calculate_circle_area(3)\n    28.274333882308138\n    \"\"\"\n    return math.pi * (radius ** 2)", "def area_circle(radius):\n    \"\"\"\n    Calculate the area of a circle given its radius.\n    Parameters:\n    - radius (float): The radius of the circle.\n    \n    Returns:\n    - float: The area of the circle.\n    \n    Example:\n    >>> area_circle(3)\n    28.274333882308138\n    \"\"\"\n    return math.pi * radius**2", "def circle_area(radius):\n    \"\"\"\n    Calculate the area of a circle given the radius.\n    Parameters:\n        radius (float): The radius of the circle.\n    Returns:\n        float: The area of the circle.\n    Examples:\n        >>> circle_area(5)\n        78.53981633974483\n    \"\"\"\n    return math.pi * radius ** 2", "def area_circle(radius):\n    \"\"\"\n    Calculate the area of a circle given its radius.\n    Parameters:\n    radius (float): the radius of the circle.\n    Returns:\n    float: the area of the circle calculated as pi*r^2\n    \"\"\"\n    import math\n    return math.pi * radius ** 2", "def area_circle(radius):\n    \"\"\"\n    Calculates the area of a circle.\n    Parameters:\n        radius (float): The radius of the circle.\n    Returns:\n        float: The area of the circle.\n    Example:\n        >>> area_circle(3)\n        28.274333882308138\n    \"\"\"\n    return math.pi * (radius ** 2)", "def circle_area(radius):\n    \"\"\"\n    Calculate the area of a circle given its radius.\n    Parameters:\n    radius (float): The radius of the circle.\n    Returns:\n    float: The area of the circle.\n    Example:\n    >>> circle_area(5)\n    78.53981633974483\n    \"\"\"\n    return math.pi * radius ** 2", "def circle_area(radius):\n    \"\"\"\n    Calculate the area of a circle given the radius.\n    Parameters\n    ----------\n    radius : float\n        The radius of the circle.\n    Returns\n    -------\n    float\n        The area of the circle.\n    Examples\n    --------\n    >>> circle_area(5)\n    78.53981633974483\n    >>> circle_area(0)\n    0.0\n    \"\"\"\n    return math.pi * (radius ** 2)", "def area_circle(radius):\n    \"\"\"\n    Calculate the area of a circle given its radius.\n    Parameters:\n        radius (float): The radius of the circle.\n    Returns:\n        float: The area of the circle.\n    \n    Examples:\n        >>> area_circle(5)\n        78.53981633974483\n    \"\"\"\n    return math.pi * radius * radius", "def circle_area(radius):\n    \"\"\"\n    Calculate the area of a circle given its radius.\n    Parameters:\n    radius (float): The radius of the circle.\n    Returns:\n    float: The area of the circle.\n    \n    Examples:\n    >>> circle_area(3)\n    28.274333882308138\n    \"\"\"\n    return pi * radius**2", "def calculate_circle_area(radius):\n    \"\"\"\n    Calculate the area of a circle given its radius.\n    Parameters:\n    - radius (float or int): The radius of the circle.\n    Returns:\n    - float: Area of the circle.\n    \n    Examples:\n    >>> calculate_circle_area(3)\n    28.274333882308138\n    \"\"\"\n    return math.pi * radius ** 2", "def area_circle(radius):\n    \"\"\"\n    Calculate the area of a circle.\n    Parameters:\n        radius (float): The radius of the circle.\n    Returns:\n        float: The area of the circle.\n    Examples:\n    >>> area_circle(3)\n    28.274333882308138\n    \"\"\"\n    return math.pi * radius ** 2", "def area_circle_by_radius(radius):\n    \"\"\"Calculate the area of a circle given its radius.\n    \n    Parameters:\n    - radius (float): The radius of the circle.\n    \n    Returns:\n    - float: The calculated area of the circle.\n    \n    Example:\n    >>> area_circle_by_radius(3)\n    28.274333882308138\n    \"\"\"\n    return math.pi * radius ** 2"], ["def trapezoid_area(base1: float, base2: float, height: float) -> float:\n    \"\"\"\n    Calculate the area of a trapezoid given two bases and the height.\n    Parameters:\n    base1 (float): The length of the first base.\n    base2 (float): The length of the second base.\n    height (float): The height of the trapezoid (distance between the two bases).\n    Returns:\n    float: The area of the trapezoid.\n    Examples:\n    >>> trapezoid_area(10, 8, 5)\n    45.0\n    \"\"\"\n    return 0.5 * (base1 + base2) * height", "def trapezoid_area(base1, base2, height):\n    \"\"\"\n    Calculate the area of a trapezoid given the lengths of its two bases and the height.\n    Parameters:\n        base1 (float): The length of the first base of the trapezoid.\n        base2 (float): The length of the second base of the trapezoid.\n        height (float): The height of the trapezoid measured perpendicularly from one base to the other.\n    Returns:\n        float: The area of the trapezoid.\n    Example:\n        >>> trapezoid_area(3, 5, 4)\n        16.0\n    \"\"\"\n    return 0.5 * (base1 + base2) * height", "def calculate_trapezoid_area(base1, base2, height):\n    \"\"\"\n    Calculate the area of a trapezoid given the lengths of its two parallel bases and the height.\n    Parameters:\n        base1 (float): The length of the first base.\n        base2 (float): The length of the second base.\n        height (float): The height between the two bases.\n    Returns:\n        float: The calculated area of the trapezoid.\n    Examples:\n        >>> calculate_trapezoid_area(5, 7, 10)\n        60.0\n    \"\"\"\n    return 0.5 * (base1 + base2) * height"], ["def annular_area(outer_radius, inner_radius):\n    \"\"\"\n    Calculate the area of an annulus given the radii of two concentric circles.\n    Parameters:\n        outer_radius (float): The radius of the outer circle.\n        innerh_radius (float): The radius of the inner circle.\n    Returns:\n        float: The area of the annular region.\n    Examples:\n        >>> annular_area(10, 5)\n        235.61944901923448\n    \"\"\"\n    return circle_area(outer_radius) - circle_area(inner_radius)", "def annulus_area(outer_radius, inner_radius):\n    \"\"\"\n    Calculate the area of an annulus given the radii of the outer and inner circles.\n    Parameters\n    ----------\n    outer_radius : float\n        The radius of the outer circle.\n    inner_radius : float\n        The radius of the inner circle.\n    Returns\n    -------\n    float\n        The area of the annulus.\n    Examples\n    --------\n    >>> annulus_area(5, 3)\n    50.26548245743669\n    >>> annulus_area(10, 7)\n    201.06192982974676\n    \"\"\"\n    return circle_area(outer_radius) - circle_area(inner_radius)"], ["def calculate_area(shape: str, *args) -> float:\n    \"\"\"\n    Function to calculate the area of a basic geometric shape.\n    \n    Parameters:\n    shape (str): The name of the shape. Possible values: 'square', 'rectangle', 'circle', 'triangle'.\n    *args: The dimensions of the shape. For 'square' it's the side length, for 'rectangle' it's the length and breadth, for 'circle' it's the radius, for 'triangle' it's the base and height.\n    \n    Returns:\n    float: The area of the shape according to the specified dimensions.\n    \n    Examples:\n    >>> calculate_area('square', 2)\n    4\n    >>> calculate_area('rectangle', 2, 3)\n    6\n    >>> calculate_area('circle', 2)\n    ~12.57\n    >>> calculate_area('triangle', 2, 3)\n    3\n    \"\"\"\n    if shape.lower() == 'square':\n        return args[0]**2\n    elif shape.lower() == 'rectangle':\n        return args[0]*args[1]\n    elif shape.lower() == 'circle':\n        return pi*args[0]**2\n    elif shape.lower() == 'triangle':\n        return 0.5*args[0]*args[1]\n    else:\n        raise ValueError(\"Unknown shape. Only 'square', 'rectangle', 'circle', and 'triangle' are valid shapes.\")", "def area(shape, *dimensions):\n    \"\"\"\n    Calculate the area of a given shape.\n    Parameters\n    ----------\n    shape : str\n        Shape to calculate area for, choice of: \"triangle\", \"rectangle\", \"square\", \"circle\", and \"sector\".\n    dimensions : floats\n        Dimensions needed to calculate the area of the shape. For a 'triangle', it'll be base and height.\n        For 'rectangle' or 'square', it's the sides. For 'circle', it's the radius. For 'sector', it's the radius and the angle.\n    Returns\n    -------\n    float\n        The area of the shape.\n    Examples\n    --------\n    >>> area(\"rectangle\", 5, 6)\n    30\n    >>> area(\"circle\", 7)\n    153.93804002589985\n    >>> area(\"sector\", 7, 60)\n    25.656750143403033\n    \"\"\"\n    \n    import math\n    # Different formulas for different shapes\n    if shape == \"triangle\":\n        return (dimensions[0] * dimensions[1]) / 2\n    elif shape == \"rectangle\":\n        return dimensions[0] * dimensions[1]\n    elif shape == \"square\":\n        return math.pow(dimensions[0], 2)\n    elif shape == \"circle\":\n        return math.pi * math.pow(dimensions[0], 2)\n    elif shape == \"sector\":\n        return 0.5 * math.pow(dimensions[0], 2) * math.radians(dimensions[1])\n    else:\n        raise ValueError('Shape Not Recognized!')", "def calculate_area(shape, dimensions):\n    \"\"\"\n    Given the shape and its dimensions, calculate its area.\n    \n    Parameters\n    ----------\n    shape : str\n        The type of the shape. Can be 'circle', 'rectangle', 'triangle', 'trapezoid' or 'square'.\n    dimensions : tuple of float\n        The dimensions of the shape. For 'circle', it is the radius; for 'rectangle', it is (length, width); for 'triangle', it is (base, height); for 'trapezoid', it is (base1, base2, height); for 'square', it is the side length.\n    Returns\n    -------\n    float\n        The area of the shape.\n    Raises\n    ------\n    ValueError\n        If the shape is not recognized, or if incorrect dimensions are given.\n    \"\"\"\n    if shape == 'circle':\n        if len(dimensions) != 1:\n            raise ValueError(\"A circle requires one dimension (radius).\")\n        return math.pi * (dimensions[0]**2)\n    elif shape == 'rectangle':\n        if len(dimensions) != 2:\n            raise ValueError(\"A rectangle requires two dimensions (length, width).\")\n        return dimensions[0] * dimensions[1]\n    elif shape == 'triangle':\n        if len(dimensions) != 2:\n            raise ValueError(\"A triangle requires two dimensions (base, height).\")\n        return 0.5 * dimensions[0] * dimensions[1]\n    elif shape == 'trapezoid':\n        if len(dimensions) != 3:\n            raise ValueError(\"A trapezoid requires three dimensions (base1, base2, height).\")\n        return 0.5 * (dimensions[0] + dimensions[1]) * dimensions[2]\n    elif shape == 'square':\n        if len(dimensions) != 1:\n            raise ValueError(\"A square requires one dimension (side length).\")\n        return dimensions[0] ** 2\n    else:\n        raise ValueError(\"Shape not recognized.\")"], ["def find_line_intersection(p1, p2, p3, p4):\n    \"\"\"\n    Calculate the intersection point of two lines defined by two pairs of points.\n    Parameters:\n    p1, p2 (tuple): (x, y) coordinates for the first and the second point of the first line.\n    p3, p4 (tuple): (x, y) coordinates for the third and the fourth point of the second line.\n    Returns:\n    tuple or str: (x, y) coordinates of the intersection point, or 'No unique intersection' if lines are collinear or do not intersect.\n    Examples:\n    >>> find_line_intersection((0, 0), (1, 1), (1, 0), (0, 1))\n    (0.5, 0.5)\n    >>> find_line_intersection((0, 0), (1, 1), (2, 2), (3, 3))\n    'No unique intersection or lines are collinear'\n    \"\"\"\n    x1, y1 = p1\n    x2, y2 = p2\n    x3, y3 = p3\n    x4, y4 = p4\n    \n    # Calculate the determinants\n    denom = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4)\n    if denom == 0:\n        return 'No unique intersection or lines are collinear'\n    \n    px = ((x1 * y2 - y1 * x2) * (x3 - x4) - (x1 - x2) * (x3 * y4 - y3 * x4)) / denom\n    py = ((x1 * y2 - y1 * x2) * (y3 - y4) - (y1 - y2) * (x3 * y4 - y3 * x4)) / denom\n    return (px, py)"], ["def total_area_of_rectangles(rectangles):\n    \"\"\"\n    Calculate the total area covered by a list of rectangles described by length and width.\n    \n    Parameters:\n    - rectangles (list of tuples): A list where each tuple contains the length and width of a rectangle.\n    \n    Returns:\n    - float: The total area covered by the rectangles.\n    \n    Example:\n    >>> total_area_of_rectangles([(5, 3), (2, 7)])\n    29\n    \"\"\"\n    total_area = 0\n    for length, width in rectangles:\n        total_area += rectangle_area(length, width)\n    return total_area"], ["def circle_diameter(radius):\n    \"\"\"\n    The function takes radius of a circle as input \n    and returns its diameter.\n    \"\"\"\n    return 2 * radius"], ["class GeometryArithmeticProcessor:\n    \"\"\"\n    A class to handle arithmetic operations involving areas, useful in calculations of composite figures or figures with subtracted regions.\n    \"\"\"\n    @staticmethod"], ["def complex_circle_area_calculations(*args, operation=\"subtract\"):\n    \"\"\"\n    Calculate the custom complex area involving multiple circle areas.\n    \n    Parameters:\n        args (tuple): Tuple containing pairs (radius, count, multiplier(1 for add, -1 for subtract))\n        operation (str): Determines how to combine areas ('add', 'subtract'; default 'subtract').\n        \n    Returns:\n        float: Resulting area based on the operations.\n    Examples:\n        >>> complex_circle_area_calculations((5, 1, 1), (3, 1, -1))\n        50.26548245743669\n    \"\"\"\n    area = 0\n    for radius, count, multiplier in args:\n        partial_area = circle_area(radius)\n        if operation == \"add\":\n            area += multiplier * count * partial_area\n        elif operation == \"subtract\":\n            area -= multiplier * count * partialarea\n    return area"], ["def rectangle_frame_area(total_length, total_width, frame_width):\n    \"\"\"\n    Calculate the area of a rectangular frame by subtracting the \n    inner rectangle area (which is reduced by twice the frame width \n    on each dimension) from the total rectangle area.\n    \n    Parameters:\n        total_length (int, float, sympy.Symbol): The total outer length of the frame.\n        total_width (int, float, sympy.Symbol): The total outer width of the frame.\n        frame_width (int, float, sympy.Symbol): The width of the frame border.\n    \n    Returns:\n        sympy.Expr: The area of the frame.\n    \n    Examples:\n        >>> rectangle_frame_area(12, 10, 1)\n        32\n        >>> tl, tw, fw = sp.symbols('tl tw fw')\n        >>> rectangle_frame_area(tl, tw, fw)\n        tl*tw - (tl - 2*fw)*(tw - 2*fw)\n    \"\"\"\n    inner_length = total_length - 2 * frame_width\n    inner_width = total_width - 2 * frame_width\n    total_area = calculate_rectangle_area(total_length, total_width)\n    inner_area = calculate_rectangle_area(inner_length, inner_width)\n    return total_area - inner_area"], ["def triangle_medians_area(p1, p2, p3):\n    \"\"\"\n    Calculates the area of the triangles formed by the medians of the given triangle.\n    \n    Parameters:\n    - p1, p2, p3 (tuple or list): Each should be a tuple or list representing the (x, y) coordinates of a vertex of the triangle.\n    \n    Returns:\n    - float: The area of one of the six triangles formed by the intersection of the medians.\n    \n    Example:\n    >>> triangle_medians_area((0, 0), (4, 0), (2, 4))\n    0.6666666666666666\n    \"\"\"\n    centroid = lambda x1, x2, x3: ((x1+x2+x3)/3)\n    cx = centroid(p1[0], p2[0], p3[0])\n    cy = centroid(p1[1], p2[1], p3[1])\n    area = polygon_area([p1, (cx, cy), p3]) / 6\n    return area"], ["def composite_shape_area(*area_functions):\n    \"\"\"\n    Calculate the total area of a composite shape made up of various area-defined simpler shapes.\n    Parameters:\n    *area_functions (tuple of functions): A tuple where each element is a lambda or function returning the area of part of the composite shape.\n    Returns:\n    float: The total area of the composite shape.\n    \n    Examples:\n    # Example for a combination of a circle and a triangle on top\n    >>> circle_func = lambda: circle_area(3)\n    >>> triangle_func = lambda: triangle_area_by_base_height(3, 4)\n    >>> composite_shape_area(circle_func, triangle_func)\n    37.274333882308138\n    \"\"\"\n    return sum(func() for func in area_functions)"], ["def pythagorean_triplet(a, b, c):\n    \"\"\"\n    Check if the three given lengths form a Pythagorean triplet.\n    Parameters\n    ----------\n    a : float\n        Length of the first side.\n    b : float\n        Length of the second side.\n    c : float\n        Length of the third side (hypotenuse).\n    Returns\n    -------\n    bool\n        `True` if the lengths form a Pythagorean triplet and `False` otherwise\n    \"\"\"\n    return abs((a ** 2) + (b ** 2) - (c ** 2)) < 0.001"], ["class CircleBasedCalculator:\n    \"\"\"\n    A class to calculate various geometrical properties and areas related to circles,\n    including full circles, sectors, and annuli (regions between two concentric circles).\n    \"\"\"\n    @staticmethod\n    def area_of_circle(radius):\n        \"\"\"\n        Calculate the area of a circle using the formula πr².\n        Parameters:\n            radius (float): The radius of the circle.\n        Returns:\n            float: The area of the circle.\n        Example:\n            >>> CircleBasedCalculator.area_of_circle(5)\n            78.53981633974483\n        \"\"\"\n        return math.pi * radius ** 2\n    @staticmethod\n    def area_of_sector(radius, angle_in_degrees):\n        \"\"\"\n        Calculate the area of a sector given the central angle and radius.\n        Parameters:\n            radius (float): The radius of the circle from which the sector is part.\n            angle_in_degrees (float): The angle of the sector in degrees.\n        Returns:\n            float: The area of the sector.\n        Example:\n            >>> CircleBasedCalculator.area_of_sector(5, 90)\n            19.634954084936208\n        \"\"\"\n        return (angle_in_degrees / 360) * math.pi * radius ** 2\n    @staticmethod\n    def area_of_annulus(outer_radius, inner_radius):\n        \"\"\"\n        Calculate the area of an annulus (the region between two concentric circles).\n        Parameters:\n            outer_radius (float): Radius of the outer circle.\n            inner_radius (float): Radius of the inner circle.\n        Returns:\n            float: The area of the annulus.\n        Example:\n            >>> CircleBasedCalculator.area_of_annulus(5, 3)\n            50.26548245743669\n        \"\"\"\n        return math.pi * (outer_radius ** 2 - inner_radius ** 2)\n    @staticmethod\n    def diameter_to_radius(diameter):\n        \"\"\"\n        Convert diameter to radius.\n        Parameters:\n            diameter (float): The diameter of the circle.\n        Returns:\n            float: The radius of the circle.\n        Example:\n            >>> CircleBasedCalculator.diameter_to_radius(10)\n            5.0\n        \"\"\"\n        return diameter / 2"], ["def centroid_polygon(vertices: List[Tuple[float, float]]) -> Tuple[float, float]:\n    \"\"\"\n    Calculates the centroid (geometric center) of a polygon given its vertices.\n    Parameters:\n    - vertices (List[Tuple[float, float]]): Coordinates of the vertices of the polygon.\n    Returns:\n    - Tuple[float, float]: The coordinates of the centroid.\n    Examples:\n    >>> print(centroid_polygon([(0, 0), (4, 0), (4, 4), (0, 4)]))\n    (2.0, 2.0)\n    \"\"\"\n    x_coordinates, y_coordinates = zip(*vertices)\n    num_vertices = len(vertices)\n    centroid_x = sum(x_coordinates) / num_vertices\n    centroid_y = sum(y_coordinates) / num_vertices\n    return (centroid_x, centroid_y)"], ["def composite_area(*args):\n    \"\"\"\n    The function takes the areas of several shapes as input \n    and returns the total area.\n    \"\"\"\n    return sum(args)"], ["def law_of_cosines(a, b, angle_degrees):\n    \"\"\"\n    Calculate the third side of a triangle using the Law of Cosines.\n    Parameters:\n    a (float): Length of the first side.\n    b (float): Length of the second side.\n    angle_degrees (float): Angle between sides a and b in degrees.\n    Returns:\n    float: Length of the third side.\n    Example:\n    >>> law_of_cosines(5, 5, 90)\n    7.0710678118654755\n    \"\"\"\n    angle_radians = math.radians(angle_degrees)\n    c = math.sqrt(a**2 + b**2 - 2 * a * b * math.cos(angle_radians))\n    return c"], ["def rectangle_area(length, width):\n    \"\"\"\n    The function takes the length and width of a rectangle as input \n    and returns its area.\n    \"\"\"\n    return length * width"], ["def triangle_side_lengths(angle, *dimensions):\n    \"\"\"\n    Calculate the length of sides in common triangle types (right, 30-60-90, 45-45-90).\n    Parameters\n    ----------\n    angle : int\n        Internal angle in degrees of the triangle.\n    dimensions : tuple\n        Lengths of known sides.\n    Returns\n    -------\n    tuple\n        Lengths of all sides of the triangle.\n    Examples\n    --------\n    >>> triangle_side_lengths(90, 3, 4)\n    (3, 4, 5)\n    >>> triangle_side_lengths(30, 5)\n    (5, 5*sqrt(3), 10)\n    >>> triangle_side_lengths(45, 5)\n    (5, 5, 5*sqrt(2))\n    \"\"\"\n    \n    import sympy as sp\n    def right_triangle_sides(a, b):\n        # Use the Pythagorean theorem\n        return a, b, sp.sqrt(a**2 + b**2)\n    def special_triangle_sides(angle, a):\n        if angle == 30:\n            return a, a * sp.sqrt(3), 2*a\n        elif angle == 45:\n            return a, a, a * sp.sqrt(2)\n        else:\n            raise ValueError('This tool only covers 30-60-90 and 45-45-90 triangles.')\n    if angle == 90:\n        return right_triangle_sides(*dimensions)\n    else:\n        return special_triangle_sides(angle, *dimensions)"], ["def calculate_area_from_vertices(vertices, is_triangle=False):\n    \"\"\"\n    Calculate the area of a parallelogram or a triangle using the coordinates of vertices.\n    This function works for both 2D and 3D spaces depending on the input.\n    Parameters:\n    - vertices (list of lists/tuples): List of coordinates of the vertices. \n      For 2D, provide [[x1, y1], [x2, y2], [x3, y3]]. For 3D, include the z component.\n    - is_triangle (bool): If True, calculates the area of the triangle instead of the parallelogram.\n    \n    Returns:\n    - float: The area of the figure.\n    Examples:\n    (2D Parallelogram) \n    >>> calculate_area_from_vertices([[0, 0], [1, 0], [1, 2], [2, 2]], False)\n    2.0\n    \n    (3D Parallelogram)\n    >>> calculate_area_from_vertices([[0, 0, 0], [1, 0, 0], [0, 1, 1], [1, 1, 1]], False)\n    1.4142135623730951\n    (Triangle)\n    >>> calculate_area_from_vertices([[0, 0], [4, 0], [0, 3]], True)\n    6.0\n    \"\"\"\n    if len(vertices[0]) == 2:  # 2D\n        vec1 = np.array(vertices[1]) - np.array(vertices[0])\n        vec2 = np.array(vertices[2]) - np.array(vertices[0])\n        cross_prod = np.cross(vec1, vec2)\n        area = 0.5 * np.abs(cross_prod) if is_triangle else np.abs(cross_titudes)\n    elif len(vertices[0]) == 3:  # 3D\n        vec1 = np.array(vertices[1]) - np.array(vertices[0])\n        vec2 = np.array(vertices[2]) - np.array(vertices[0])\n        vec3 = np.array(vertices[3]) - np.array(vertices[0])\n        cross_prod = np.cross(vec1, vec2)\n        area = 0.5 * np.linalg.norm(cross_prod) if is_triangle else np.linalg.norm(cross_prod)\n    \n    return area", "def triangle_area_from_vertices(vertices):\n    \"\"\"\n    Calculate the area of a triangle given the coordinates of its vertices.\n    Parameters:\n    vertices (np.ndarray): A 2x3 or 3x3 matrix where each row represents the x, y, [z] coordinates of a vertex.\n    Returns:\n    float: The absolute area of the triangle.\n    Examples:\n    >>> vertices_2d = np.array([[0, 0], [1, 0], [0, 1]])\n    >>> triangle_area_from_vertices(vertices_2d)\n    0.5\n    \n    >>> vertices_3d = np.array([[0, 0, 0], [1, 0, 0], [0, 1, 0]])\n    >>> triangle_area_from_vertices(vertices_3d)\n    0.5\n    \"\"\"\n    if vertices.shape[1] == 2:  # Handle 2D vertices by assuming z=0\n        vertices = np.hstack([vertices, np.zeros((3, 1))])\n    # Vector AB and AC\n    vec_ab = vertices[1] - vertices[0]\n    vec_ac = vertices[2] - vertices[0]\n    # Cross product of AB and AC\n    cross_prod = np.cross(vec_ab, vec_ac)\n    # Magnitude of cross product gives twice the area of the triangle\n    area = np.linalg.norm(cross_prod) / 2\n    \n    return area"], ["def circle_area(radius):\n    \"\"\"\n    The function takes the radius of a circle as input \n    and returns its area.\n    \"\"\"\n    return math.pi * (radius**2)"], ["def transform_circle_area(radius, transform_factor):\n    \"\"\"\n    The function takes radius of a circle and a transformation factor as input.\n    It then scales the radius by transformation factor and returns the new area of the circle.\n    \"\"\"\n    new_radius = radius * transform_factor\n    return circle_area(new_radius)"], ["def rectangle_area_dynamic(L, W):\n    \"\"\"\n    Calculate the area of a rectangle while allowing the sides, L and W, to be expressions.\n    \n    Parameters:\n    - L, W (expressions or floats): The expressions or numbers representing the length and width.\n    \n    Returns:\n    - Expression or float: The calculated area.\n    \n    Example:\n    >>> from sympy import symbols, Eq, solve\n    >>> l = symbols('l')\n    >>> rectangle_area_dynamic(l, l+2)\n    l*(l + 2)\n    \"\"\"\n    from sympy import simplify\n    return simplify(L * W)"], ["def composite_area_calculations(*areas, subtract=False):\n    \"\"\"\n    Compute the total or net area of multiple individual areas, supporting both sum and subtraction operations.\n    Parameters:\n        areas (list of floats): A list of individual areas.\n        subtract (bool): If True, subtracts areas instead of summing them.\n    Returns:\n        float: Total or net area after performing the sum or subtraction.\n    Example:\n        >>> composite_area_calculations(10, 5, 15)\n        30\n        >>> composite_area_calculations(10, 3, subtract=True)\n        7\n    \"\"\"\n    if subtract:\n        return areas[0] - sum(areas[1:])\n    else:\n        return sum(areas)"], ["def perpendicular_height(x1, y1, x2, y2, x3, y3):\n    \"\"\"\n    Calculate the height from vertex (x3, y3) to the line formed by (x1, y1) and (x2, y2).\n    Parameters:\n    x1, y1 (float): Coordinates of the first point on the line.\n    x2, y2 (float): Coordinates of the second point on the line.\n    x3, y3 (float): Coordinates of the vertex from which the height is calculated.\n    Returns:\n    float: The perpendicular height from the point to the line.\n    Examples:\n    >>> perpendicular_height(0, 0, 4, 0, 2, 2)\n    2.0\n    \"\"\"\n    # Area of triangle using vertices and dividing by base length to find height\n    area = triangle_area_by_coordinates(x1, y1, x2, y2, x3, y3)\n    base_length = distance_between_points(x1, y1, x2, y2)\n    return 2 * area / base_length"], ["def trapezoid_area_from_vertices(A: Tuple[float, float], B: Tuple[float, float], C: Tuple[float, float], D: Tuple[float, float]) -> float:\n    \"\"\"\n    Calculate the area of a trapezoid from the coordinates of its vertices.\n    Assumes that A, B are on one base, and C, D on the other.\n    The function does not verify if the input forms a trapezoid.\n    Parameters:\n    A, B, C, D (Tuple[float, float]): Coordinates of the vertices.\n    Returns:\n    float: The area of the trapezoid.\n    Examples:\n    >>> trapezoid_area_from_vertices((0, 0), (4, 0), (3, 3), (1, 3))\n    12.0\n    \"\"\"\n    base1 = distance(A, B)\n    base2 = distance(C, D)\n    # Computing height using the perpendicular distance from a point to a line method might be involved here.\n    # Here, it’s assumed we know the vertical distance.\n    # More geometric checks/conversions needed for a general case, involving perpendicular distance calculation.\n    height = abs(A[1] - C[1])  # Simplistic approach, assuming A, C are aligned vertically.\n    return trapezoid_area(base1, base2, height)"], ["def line_equation_from_points(x1, y1, x2, y2):\n    \"\"\"\n    Calculate the slope and y-intercept of the line passing through two points.\n    Parameters:\n    x1, y1 (float): Coordinates of the first point.\n    x2, y2 (float): Coordinates of the second point.\n    Returns:\n    tuple: Slope and y-intercept of the line.\n    Examples:\n    >>> line_equation_from_points(0, 0, 2, 2)\n    (1.0, 0.0)\n    >>> line_equation_from_points(1, 2, 3, 8)\n    (3.0, -1.0)\n    \"\"\"\n    if x2 != x1:\n        slope = (y2 - y1) / (x2 - x1)\n        intercept = y1 - slope * x1\n        return slope, intercept\n    else:\n        return float('inf'), x1"]], "Triangles": [["def herons_formula(a: float, b: float, c: float) -> float:\n    \"\"\"\n    Calculate the area of a triangle given the lengths of its sides using Heron's formula.\n    \n    Parameters:\n    - a (float): Length of the first side of the triangle.\n    - b (float): Length of the second side of the triangle.\n    - c (float): Length of the third side of the triangle.\n    Returns:\n    - float: The area of the triangle.\n    Examples:\n    >>> herons_formula(3, 4, 5)\n    6.0\n    \"\"\"\n    s = (a + b + c) / 2\n    return math.sqrt(s * (s - a) * (s - b) * (s - c))", "def herons_formula(a, b, c):\n    \"\"\"\n    Calculates the area of a triangle using Heron's formula.\n    \n    Parameters:\n        a (float): length of the first side of the triangle.\n        b (float): length of the second side of the triangle.\n        c (float): length of the third side of the triangle.\n    Returns:\n        float: the area of the triangle.\n    \n    Examples:\n        >>> herons_formula(3, 4, 5)\n        6.0\n    \"\"\"\n    s = calculate_semiperimeter(a, b, c)\n    area = math.sqrt(s * (s - a) * (s - b) * (s - c))\n    return area", "def triangle_area_heron(a, b, c):\n    \"\"\"\n    Calculate the area of triangle using Heron's formula.\n    Parameters:\n    a (float): length of side a\n    b (float): length of b\n    c (float): length of c\n    Returns:\n    float: area of the triangle\n    Examples:\n    >>> triangle_area_heron(3, 4, 5)\n    6.0\n    \"\"\"\n    s = (a + b + c) / 2\n    area = math.sqrt(s * (s - a) * (s - b) * (s - c))\n    return area", "def calculate_area_heron(a, b, c):\n    \"\"\"\n    Description:\n        Calculate area of a triangle using Heron's formula.\n        \n    Parameters:\n        a (float): Length of side a.\n        b (float): Length of side b.\n        c (float): Length of side c.\n    Returns:\n        float: Area of the triangle.\n    Example:\n        calculate_area_heron(5, 6, 7)\n    \"\"\"\n    # s stands for semiperimeter\n    s = Symbol('s', positive=True)\n    s_val = solve(a + b + c - 2*s , s)[0]\n    \n    # Heron's formula for the area of a triangle\n    area = (s*(s - a)*(s - b)*(s - c))**0.5\n    return area.subs(s, s_val)", "def calculate_inradius(a, b, c, area):\n    \"\"\"\n    Description:\n        Calculate inradius of a triangle using its area and semiperimeter.\n        \n    Parameters:\n        a (float): Length of side a.\n        b (float): Length of side b.\n        c (float): Length of side c.\n        area (float): Area of the triangle\n    Returns:\n        float: Inradius of the triangle.\n    Example:\n        calculate_inradius(5, 6, 7, calculate_area_heron(5, 6, 7))\n    \"\"\"\n    # s stands for semiperimeter\n    s = Symbol('s', positive=True)\n    s_val = solve(a + b + c - 2*s , s)[0]\n    # Inradius formula for a triangle\n    inradius = area/s_val\n    return inradius.subs(s, s_val)", "def triangle_area_from_sides(side_a, side_b, side_c):\n    \"\"\"\n    Calculate the area of a triangle given all three sides using Heron's formula.\n    \n    Parameters:\n        side_a (float), side_b (float), side_c (float): the sides of the triangle.\n        \n    Returns:\n        float: The area of the triangle.\n    \n    Examples:\n        >>> triangle_area_from_sides(3, 4, 5)\n        6.0\n    \"\"\"\n    s = (side_a + side_b + side_c) / 2\n    area = math.sqrt(s * (s - side_a) * (s - side_b) * (s - side_c))\n    return area", "def heron_formula(a, b, c):\n    \"\"\"\n    Calculate the area of a triangle with sides a, b, and c using Heron's formula.\n    \n    Parameters:\n        a (float): The length of side a.\n        b (float): The length of side b.\n        c (float): The length of side c.\n    \n    Returns:\n        float: The area of the triangle.\n    \n    Example:\n        >>> heron_formula(3, 4, 5)\n        6.0\n    \"\"\"\n    s = (a + b + c) / 2\n    return math.sqrt(s * (s - a) * (s - b) * (s - c))", "def herons_formula(a, b, c):\n    \"\"\"\n    Calculate the area of a triangle using Heron's formula given the sides.\n    \n    Parameters:\n    a, b, c (float): Sides of the triangle.\n    \n    Returns:\n    float: Area of the triangle.\n    \"\"\"\n    s = (a + b + c) / 2\n    area = math.sqrt(s * (s - a) * (s - b) * (s - c))\n    return area"], ["def valid_third_side_range(a, b):\n    \"\"\"\n    Determines the valid range for potential third side of a triangle given two sides, based on the Triangle Inequality Theorem.\n    \n    Parameters:\n        a (float or int): The length of the first side.\n        b (float or int): The length of the second side.\n        \n    Returns:\n        tuple: A tuple containing the minimum and maximum values for the third side that can still form a triangle.\n    \n    Examples:\n        >>> valid_third_side_range(8, 5)\n        (3, 13)\n        >>> valid_third_side_range(15, 10)\n        (6, 24)\n    \"\"\"\n    return (abs(a - b) + 1, a + b - 1)", "def possible_third_side(a, b):\n    \"\"\"\n    Computes the possible range of the third side of a triangle given two sides.\n    \n    Parameters:\n        a (float): The length of the first side.\n        b (float): The length of the second side.\n    Returns:\n        tuple: A range (min, max) for the possible length of the third side.\n    Examples:\n    >>> possible_third_side(3, 4)\n    (1, 7)\n    \"\"\"\n    if a <= 0 or b <= 0:\n        raise ValueError(\"Side lengths should be positive numbers\")\n    min_c = abs(a - b) + 1\n    max_c = a + b - 1\n    return (min_c, max_c)"], ["def perimeter(a: float, b: float, c: float) -> float:\n    \"\"\"\n    Calculate the perimeter of a triangle given the lengths of its sides.\n    \n    Parameters:\n    - a (float): Length of the first side of the triangle.\n    - b (float): Length of the second side of the triangle.\n    - c (float): Length of the third side of the triangle.\n    Returns:\n    - float: The perimeter of the triangle.\n    Examples:\n    >>> perimeter(3, 4, 5)\n    12.0\n    \"\"\"\n    return a + b + c", "def semiperimeter(a: float, b: float, c: float) -> float:\n    \"\"\"\n    Calculate the semi-perimeter of a triangle given the lengths of its sides.\n    \n    Parameters:\n    - a (float): Length of the first side of the triangle.\n    - b (float): Length of the second side of the triangle.\n    - c (float): Length of the third side of the triangle.\n    Returns:\n    - float: The semiperimeter of the triangle.\n    Examples:\n    >>> semiperimeter(3, 4, 5)\n    6.0\n    \"\"\"\n    return (a + b + c) / 2", "def triangle_perimeter(a, b, c):\n    \"\"\"\n    Calculate the perimeter of a triangle given the lengths of the sides that respect the Triangle Inequality Theorem.\n    \n    Parameters:\n        a (float or int): The length of the first side.\n        b (float or int): The length of the second side.\n        c (float or int): The length of the third side.\n    \n    Returns:\n        float or int: The perimeter of the triangle if it's valid, otherwise `None`.\n    \n    Examples:\n        >>> triangle_perimeter(7, 10, 5)\n        22\n        >>> triangle_perimeter(10, 2, 7)\n        None\n    \"\"\"\n    if can_form_triangle(a, b, c):\n        return a + b + c\n    return None", "def calculate_semiperimeter(a, b, c):\n    \"\"\"\n    Calculates the semiperimeter of a triangle.\n    Parameters:\n        a (float): length of the first side of the triangle.\n        b (float): length of the second side of the triangle.\n        c (float): length of the third side of the triangle.\n    Returns:\n        float: the semiperimeter of the triangle.\n    \n    Examples:\n        >>> calculate_semiperimeter(3, 4, 5)\n        6.0\n    \"\"\"\n    return (a + b + c) / 2", "def triangle_perimeter(a, b, c):\n    \"\"\"\n    Computes the perimeter of a triangle given the side lengths, assuming the\n    side lengths form a valid triangle.\n    Parameters:\n        a (float): The length of the first side.\n        b (float): The length of the second side.\n        c (float): The length of the third side.\n    Returns:\n        float: The perimeter of the triangle or None if the side lengths do not form a valid triangle.\n    Examples:\n    >>> triangle_perimeter(3, 4, 5)\n    12\n    >>> triangle_perimeter(1, 2, 3)\n    None\n    \"\"\"\n    if is_valid_triangle(a, b, c):\n        return a + b + c\n    else:\n        return None", "def triangle_perimeter(a, b, c):\n    \"\"\"\n    Calculate the perimeter of a triangle with sides a, b, and c.\n    \n    Parameters:\n        a (float): The length of side a.\n        b (float): The length of side b.\n        c (float): The length of side c.\n    \n    Returns:\n        float: The perimeter of the triangle.\n    \n    Example:\n        >>> triangle_perimeter(3, 4, 5)\n        12.0\n    \"\"\"\n    return a + b + c"], ["def triangle_area_by_coordinates(a, b, c):\n    \"\"\" Calculate the area of the triangle given vertices a, b, and c using coordinates.\n    Parameters:\n        a (tuple): Coordinates of vertex a (x1, y1)\n        b (tuple): Coordinates of vertex b (x2, y2)\n        c (tuple): Coordinates of vertex c (x3, y3)\n    \n    Returns:\n        float: Area of the triangle.\n    \"\"\"\n    p1, p2, p3 = Point(a), Point(b), Point(c)\n    triangle_abc = Triangle(p1, p2, p3)\n    \n    return triangle_abc.area.evalf()", "def triangle_area_coordinates(x1, y1, x2, y2, x3, y3):\n    \"\"\"\n    Calculate the area of triangle using coordinates.\n    Parameters:\n    x1, y1 (float): coordinates of point 1\n    x2, y2 (float): coordinates of point 2\n    x3, y3 (float): coordinates of point 3\n    Returns:\n    float: area of the triangle\n    Examples:\n    >>> triangle_area_coordinates(0, 0, 4, 0, 0, 3)\n    6.0\n    \"\"\"\n    area = abs(x1*(y2 - y3) + x2*(y3 - y1) + x3*(y1 - y2)) / 2\n    return area"], ["def calculate_triangle_area(base: float, height: float) -> float:\n    \"\"\"\n    Calculate the area of a triangle.\n    Parameters\n    ----------\n    base : float\n        The length of the base of the triangle.\n    height : float\n        The height of the triangle from the base to the opposite vertex.\n    Returns\n    -------\n    float\n        The area of the triangle.\n    Examples\n    --------\n    >>> calculate_triangle_area(8, 4.358898943540674)\n    17.435595774162698\n    \"\"\"\n    return 0.5 * base * height", "def area_by_base_height(base: float, height: float) -> float:\n    \"\"\"\n    Calculate the area of a triangle given the base and the height.\n    Parameters:\n    - base (float): The base length of the triangle.\n    - height (float): The height of the triangle perpendicular to the base.\n    Returns:\n    - float: The area of the triangle.\n    Examples:\n    >>> area_by_base_height(10, 5)\n    25.0\n    \"\"\"\n    return 0.5 * base * height", "def triangle_area(base, height):\n    \"\"\"\n    Calculate the area of a triangle given its base and height.\n    Parameters:\n        base (float): Length of the base of the triangle.\n        height (float): Height of the triangle from the base.\n    Returns:\n        float: The area of the triangle.\n    Examples:\n    >>> triangle_area(6, 3)\n    9.0\n    \"\"\"\n    return 0.5 * base * height", "def compute_triangle_area(base, height):\n    \"\"\"\n    Compute the area of a triangle given base and height.\n    Parameters\n    ----------\n    base : float\n        Length of the base of the triangle.\n    height : float\n        Length of the height of the triangle.\n    \n    Returns\n    -------\n    float\n        The area of the triangle.\n    Example\n    -------\n    >>> compute_triangle_area(5, 3)\n    7.5\n    \"\"\"\n    return 0.5 * base * height", "def area_by_base_height(base, height):\n    \"\"\"\n    Calculates the area of a triangle using the base and height.\n    Parameters:\n        base (float): the base length of the triangle.\n        height (float): the height from the base to the opposite vertex.\n    Returns:\n        float: the area of the triangle calculated using 1/2 * base * height.\n    \n    Examples:\n        >>> area_by_base_height(4, 5)\n        10.0\n    \"\"\"\n    return 0.5 * base * height", "def triangle_area(base, height):\n    \"\"\"\n    Function that calculates the area of a triangle given the base and the height.\n    \n    Parameters:\n    base (float): length of the base of the triangle. Base cannot be negative.\n    height (float): height of the triangle. Height cannot be negative.\n    \n    Returns:\n    float: Area of the triangle following the formula (0.5 * base * height).\n    \n    Examples:\n    >>> triangle_area(5, 10)\n    25.0\n    \"\"\"\n    try:\n        # Check for valid inputs\n        assert base >= 0\n        assert height >= 0\n    except AssertionError:\n        raise ValueError('Inputs must be positive numbers')\n    \n    return 0.5 * base * height", "def calculate_triangle_area(base, height):\n    \"\"\"\n    Calculate the area of a triangle using the base and height.\n    Parameters:\n    - base (float): The length of the base of the triangle.\n    - height (float): The height of the triangle.\n    Returns:\n    float: The area of the triangle.\n    \n    Example:\n    >>> calculate_triangle_area(4, 5)\n    10.0\n    \"\"\"\n    return 0.5 * base * height", "def calculate_height(base, area):\n    \"\"\"\n    Description:\n        Calculate height of a triangle using its base and area.\n        \n    Parameters:\n        base (float): Base of the triangle.\n        area (float): Area of the triangle\n    Returns:\n        float: Height of the triangle.\n    Example:\n        calculate_height(5, calculate_area_heron(5, 6, 7))\n    \"\"\"\n    # Height formula\n    height = 2*area/base\n    return height", "def calculate_triangle_area_by_base_and_height(base, height):\n    \"\"\"\n    Calculate the area of a triangle given the base and height.\n    \n    Parameters:\n        base (float): The length of the base of the triangle.\n        height (float): The height of the triangle from the base.\n    \n    Returns:\n        float: The area of the triangle.\n    \n    Example:\n        >>> calculate_triangle_area_by_base_and_height(4, 3)\n        6.0\n    \"\"\"\n    return 0.5 * base * height", "def triangle_area(base, height):\n    \"\"\"\n    Calculate the area of a triangle using base and height.\n    \n    Parameters:\n    base (float): Base of the triangle.\n    height (float): Height of the triangle.\n    Returns:\n    float: Area of the triangle.\n    \"\"\"\n    return 0.5 * base * height"], ["def triangle_side_using_law_of_cosines(a, b, angle_C):\n    \"\"\"\n    Calculate the side 'c' of a triangle using the Law of Cosines.\n    Parameters:\n    a (float): length of side a\n    b (float): length of side b\n    angle_C (float): angle C in degrees between sides a and b\n    Returns:\n    float: the length of side c\n    Examples:\n    >>> triangle_side_using_law_of_cosines(5, 7, 45)\n    7.13\n    \"\"\"\n    angle_C_radians = math.radians(angle_C)\n    c = math.sqrt(a ** 2 + b ** 2 - 2 * a * b * math.cos(angle_C_radians))\n    return round(c, 2)", "def angle_using_law_of_cosines(a, b, c):\n    \"\"\"\n    Calculate an angle of the triangle using Law of Cosines given all three sides.\n    Parameters:\n    a (float): length of side a\n    b (float): length of side b\n    c (float): length of side c\n    Returns:\n    float: the angle opposite side c in degrees\n    Examples:\n    >>> angle_using_law_of_cosines(5, 7, 9)\n    44.42\n    \"\"\"\n    angle_radians = math.acos((a**2 + b**2 - c**2) / (2 * a * b))\n    angle_degrees = math.degrees(angle_radians)\n    return round(angle_degrees, 2)", "def sides_and_angle_using_law_of_sines(a, angle_a, angle_b):\n    \"\"\"\n    Calculate side 'b' using the Law of Sines given side 'a' and angles 'angle_a' and 'angle_b'.\n    Parameters:\n    a (float): length of side a\n    angle_a (float): angle A in degrees opposite to side a\n    angle_b (float): angle B in degrees for the unknown side b\n    Returns:\n    float: the length of side b\n    Examples:\n    >>> sides_and_angle_using_law_of_sines(5, 30, 45)\n    6.12\n    \"\"\"\n    angle_a_radians = math.radians(angle_epa)\n    angle_b_radians = math.radians(angle_b)\n    b = (a / math.sin(angle_a_radians)) * math.sin(angle_b_radians)\n    return round(b, 2)", "def law_of_cosines(side_a, side_b, angle_c):\n    \"\"\"\n    Calculate the length of the side opposite angle C using the Law of Cosines.\n    \n    Parameters:\n        side_a (float): Length of side a.\n        side_b (float): Length of side b.\n        angle_c (float): Angle C in degrees.\n    \n    Returns:\n        float: The length of the side opposite to angle C.\n    \n    Examples:\n        >>> law_of_cosines(5, 6, 60)\n        4.0\n    \"\"\"\n    angle_c_radians = math.radians(angle_c)\n    side_c = math.sqrt(side_a**2 + side_b**2 - 2 * side_a * side_b * math.cos(angle_c_radians))\n    return side_c", "def law_of_sines(side_a, angle_a, angle_b):\n    \"\"\"\n    Calculate the length of side b using the Law of Sines given one side-length and two angles.\n    \n    Parameters:\n        side_a (float): Known side length.\n        angle_a (float): Angle opposite the known side A in degrees.\n        angle_b (float): Angle opposite the side B in degrees.\n    \n    Returns:\n        float: The length of the side opposite to angle B.\n    \n    Examples:\n        >>> law_of_sines(7, 30, 45)\n        7.26\n    \"\"\"\n    angle_a_rad = math.radians(angle_a)\n    angle_b_rad = math.radians(angle_b)\n    side_b = side_a * math.sin(angle_b_rad) / math.sin(angle_a_rad)\n    return side_b"], ["def calculate_side_from_angle(isosceles_base_angle, side_length=\"base\"):\n    \"\"\"\n    Calculate the side lengths in an isosceles triangle from a known base angle.\n    \n    Parameters:\n    isosceles_base_angle (float): The base angle of the isosceles triangle in degrees.\n    side_length (str): Specifies the side to calculate 'base' or 'leg'.\n    \n    Returns:\n    float: The length of the specified side.\n    Example:\n    >>> calculate_side_from_angle(45, \"leg\")\n    1.414  # Assuming the other side length (base) is 1\n    \"\"\"\n    # Calculate the leg if the base is 1, using trigonometry, tan(theta) = opposite/adjacent\n    if side_length == \"leg\":\n        return math.tan(math.radians(isosceles_base_angle))\n    elif side_length == \"base\":\n        return 2 * math.tan(math.radians(isosceles_base_angle) / 2)\n    else:\n        raise ValueError(\"Invalid side_length specified, choose either 'base' or 'leg'\")", "def calculate_isosceles_triangle_angles(base, side):\n    \"\"\"\n    Calculate the angles of an isosceles triangle given the base and one of the equal sides using law of cosines.\n    Parameters:\n    - base (float): The length of the base of the triangle.\n    - side (float): The length of one of the two equal sides.\n    Returns:\n    tuple: A tuple containing three angles in degrees (base angle, base angle, vertex angle)\n    Example:\n    >>> calculate_isosceles_triangle_angles(4, 5)\n    (53.13, 53.13, 73.74)\n    \"\"\"\n    # Law of Cosines: c^2 = a^2 + b^2 - 2ab * cos(C)\n    # cos(C) = (a^2 + b^2 - c^2) / (2ab)\n    vertex_angle = math.degrees(math.acos((2 * side**2 - base**2) / (2 * side**2)))\n    base_angle = (180 - vertex_angle) / 2\n    return (base_angle, base_angle, vertex_angle)"], ["def can_form_triangle(a, b, c):\n    \"\"\"\n    Determines if three lengths can form a triangle based on the Triangle Inequality Theorem.\n    \n    Parameters:\n        a (float or int): The length of the first side.\n        b (float or int): The length of the second side.\n        c (float or int): The length of the third side.\n        \n    Returns:\n        bool: True if the lengths can form a triangle, False otherwise.\n    \n    Examples:\n        >>> can_form_triangle(7, 10, 5)\n        True\n        >>> can_form_triangle(10, 2, 7)\n        False\n    \"\"\"\n    return (a + b > c) and (a + c > b) and (b + c > a)", "def is_valid_triangle(a, b, c):\n    \"\"\"\n    Determines if three side lengths can form a valid triangle based on the Triangle Inequality Theorem.\n    Parameters:\n        a (float): The length of the first side.\n        b (float): The length of the second with the limil side.\n        c (float): The length of the third side.\n    Returns:\n        bool: True if the side lengths can form a triangle, False otherwise.\n    Examples:\n    >>> is_valid_triangle(3, 4, 5)\n    True\n    >>> is_valid_triangle(1, 10, 12)\n    False\n    \"\"\"\n    return (a+b > c) and (a+c > b) and (b+c > a)", "def is_valid_triangle(a, b, c):\n    \"\"\"\n    Check if three side lengths can form a triangle based on the Triangle Inequality Theorem.\n    \n    Parameters:\n    a (float): Length of the first side of the triangle.\n    b (float): Length of the second side of the triangle.\n    c (float): Length of the third side of the triangle.\n    \n    Returns:\n    bool: Returns True if the side lengths can form a triangle, False otherwise.\n    \n    Examples:\n    >>> is_valid_triangle(3, 4, 5)\n    True\n    >>> is_valid_triangle(1, 2, 3)\n    False\n    \"\"\"\n    return a + b > c and b + c > a and a + c > b"], ["def triangle_properties(a=None, b=None, c=None, angle_A=None, angle_B=None, angle_C=None):\n    \"\"\"\n    A function that computes various properties of a triangle given initial dimensions as needed, using\n    the Pythagorean theorem, Law of Cosines, and other geometric relationships.\n    Parameters:\n    - a, b, c (float): The lengths of the sides of the triangle.\n    - angle_A, angle_B, angle_C (float): The angles opposite sides a, b, c respectively, in degrees.\n    \n    Returns:\n    - dict: Various computed properties like side lengths, angles, area, perimeter, etc.\n    Example Usage:\n    >>> triangle_properties(a=3, b=4)\n    {'c': 5, 'Angle C (degrees)': 90.0, 'Area': 6.0, 'Perimeter': 12.0}\n    >>> triangle_properties(a=5, b=5, c=8)\n    {'Angle A (degrees)': 41.41, 'Angle B (degrees)': 41.41, 'Angle C (degrees)': 97.18, 'Area': 12.0, 'Perimeter': 18.0}\n    \"\"\"\n    properties = {}\n    if a and b and not c:\n        c = math.sqrt(a**2 + b**2)  # Pythagorean theorem (applicable in right triangles)\n        properties['c'] = c\n        properties['Angle C (degrees)'] = 90\n    if a and b and c:\n        # Law of Cosines to find angles if not given\n        if not angle_A:\n            angle_A = math.degrees(math.acos((b**2 + c**2 - a**2) / (2 * b * c)))\n            properties['Angle A (degrees)'] = angle_A\n        if not angle_B:\n            angle_B = math.degrees(math.acos((a**2 + c**2 - b**2) / (2 * a * c)))\n            properties['Angle B (degrees)'] = angle_B\n        if not angle_C:\n            angle_C = math.degrees(math.acos((a**2 + b**2 - c**2) / (2 * a * b)))\n            properties['Angle C (degrees)'] = angle_C\n        # Area using Heron's Formula\n        semiperimeter = (a + b + c) / 2\n        area = math.sqrt(semiperimeter * (semiperimeter - a) * (semiperimeter - b) * (semiperimeter - c))\n        properties['Area'] = area\n        properties['Perimeter'] = a + b + c\n    return properties", "def advanced_triangle_properties(a=None, b=None, angle_A=None, angle_B=None):\n    \"\"\"\n    Computes complex properties of triangles, extending to use Law of Sines,\n    angle sum properties, and also providing calculations for medians and altitudes.\n    Parameters:\n    - a, b (float): lengths of two sides of the triangle.\n    - angle_A, angle_B (float): angles opposite the sides a and b respectively, in degrees.\n    Returns:\n    - dict: Computed properties like the third side, other angles, area using specified side and angle, etc.\n    Example Usage:\n    >>> advanced_triangle_properties(a=5, b=6, angle_A=60)\n    {'c': 4.27, 'Angle B (degrees)': 43.30, 'Angle C (degrees)': 76.70, 'Area': 12.48}\n    \"\"\"\n    properties = {}\n    if a and b and angle_A:\n        angle_A_rad = math.radians(angle_A)\n        angle_B_rad = math.radians(angle_B) if angle_B else None\n        # Law of Sines to find the other angle if not provided and possible the third side\n        if angle_B:\n            c = math.sqrt(a**2 + b**2 - 2 * a * b * math.cos(angle_B_rad))\n            properties['c'] = c\n            angle_C = 180 - angle_A - angle_B\n            properties['Angle C (degrees)'] = angle_C\n        else:\n            # find angle B if only angle A and sides a, b are given\n            angle_B = math.degrees(math.asin(b * math.sin(angle_A_rad) / a))\n            properties['Angle B (degrees)'] = angle_B\n            c = math.sqrt(a**2 + b**2 - 2 * a * b * math.cos(math.radians(angle_B)))\n            properties['c'] = c\n            angle_C = 180 - angle_A - angle_B\n            properties['Angle C (degrees)'] = angle_C\n        # Area using the formula: (1/2) * ab * sin(C)\n        area = 0.5 * a * b * math.sin(math.radians(angle_C))\n        properties['Area'] = area\n    return properties"], ["def triangle_perimeter(side1, side2, side3):\n    \"\"\"\n    Function that calculates the perimeter of a triangle given the lengths of its sides.\n    Parameters:\n    side1 (float): length of the first side of the triangle. Side length cannot be negative.\n    side2 (float): length of the second side of the triangle. Side length cannot be negative.\n    side3 (float): length of the third side of the triangle. Side length cannot be negative.\n    \n    Returns:\n    float: Perimeter of the triangle following the formula (side1 + side2 + side3).\n    \n    Examples:\n    >>> triangle_perimeter(3, 4, 5)\n    12.0\n    \"\"\"\n    try:\n        # Check for valid inputs\n        assert side1 >= 0\n        assert side2 >= 0\n        assert side3 >= 0\n    except AssertionError:\n        raise ValueError('Inputs must be positive numbers')\n    \n    return side1 + side2 + side3", "def triangle_angles(side1, side2, side3):\n    \"\"\"\n    Function that calculates the angles of a triangle given the lengths of its sides using the law of cosines.\n    Parameters:\n    side1 (float): length of the first side of the triangle. Side length cannot be negative.\n    side2 (float): length of the second side of the triangle. Side length cannot be negative.\n    side3 (float): length of the third side of the triangle. Side length cannot be negative.\n    \n    Returns:\n    tuple: a tuple of three angles (floats), each calculated with the formula: arccos((b**2 + c**2 - a**2) / (2bc))\n    \n    Examples:\n    >>> triangle_angles(3, 4, 5)\n    (90.0, 36.86989764584402, 53.13010235415599)\n    \"\"\"\n    try:\n        # Check for valid inputs\n        assert side1 >= 0\n        assert side2 >= 0\n        assert side3 >= 0\n    except AssertionError:\n        raise ValueError('Inputs must be positive numbers')\n    \n    # Calculate each angle and return as a tuple\n    angle_a = math.degrees(math.acos((side2**2 + side3**2 - side1**2) / (2 * side2 * side3)))\n    angle_b = math.degrees(math.acos((side1**2 + side3**2 - side2**2) / (2 * side1 * side3)))\n    angle_c = math.degrees(math.acos((side1**2 + side2**2 - side3**2) / (2 * side1 * side2)))\n    return angle_a, angle_b, angle_c"], ["def similar_triangles(triangle1, triangle2):\n    \"\"\"\n    Determines the proportional length of a corresponding side in similar triangles.\n    Parameters:\n    triangle1 (tuple): A tuple containing the lengths of the sides of the first triangle (a, b, c)\n    triangle2 (tuple): A tuple containing the lengths of two sides of the second triangle. The length of the third \n    side is the unknown to be calculated (x, y, z=None)\n    Returns:\n    z (float): The length of the third side of the second triangle calculated using the proportion of the corresponding sides of similar triangles.\n    \"\"\"\n    a, b, c = triangle1\n    x, y, z = triangle2\n    # Considering the triangles are similar, the sides should be proportional\n    # Therefore, (a:b:c) = (x:y:z), and we can solve for z.\n    z = (c * y) / b\n    return z"], ["def triangle_angle_sum():\n    \"\"\"\n    Return the sum of angles in any triangle, in degrees.\n    Returns:\n    int: The sum of the internal angles of a triangle, always 180 degrees.\n    \n    Example:\n    >>> triangle_angle_sum()\n    180\n    \"\"\"\n    return 180"], ["def calculate_special_triangle_sides(triangle_type, known_side, known_side_type):\n    \"\"\"\n    Calculate the sides of a 30-60-90 or 45-45-90 triangle given one side.\n    \n    Parameters:\n        triangle_type (str): Type of the triangle. Either '30-60-90' or '45-45-90'.\n        known_side (float): The length of the known side.\n        known_side_type (str): The type of the known side: 'shorter leg', 'longer leg', or 'hypotenuse'.\n    \n    Returns:\n        tuple: All three sides (short_leg, long_leg, hypotenuse) of the triangle.\n    Example:\n        >>> calculate_special_triangle_sides('30-60-90', 1, 'shorter leg')\n        (1, sqrt(3), 2)\n        >>> calculate_special_triangle_sides('45-45-90', sqrt(2), 'hypotenuse')\n        (1, 1, sqrt(2))\n    \"\"\"\n    if triangle_type == '30-60-90':\n        if known_side_type == 'shorter leg':\n            short_leg = known_side\n            long_leg = short_leg * math.sqrt(3)\n            hypotenuse = short_leg * 2\n        elif known_side_type == 'longer leg':\n            long_leg = known_side\n            short_leg = long_leg / math.sqrt(3)\n            hypotenuse = short_leg * 2\n        elif known_side_type == 'hypotenuse':\n            hypotenuse = known_side\n            short_leg = hypotenuse / 2\n            long_leg = short_leg * math.sqrt(3)\n    elif triangle_type == '45-45-90':\n        if known_side_type == 'leg':\n            leg = known_side\n            hypotenuse = leg * math.sqrt(2)\n            return (leg, leg, hypotenuse)\n        elif known_side_type == 'hypotenuse':\n            hypotenuse = known_side\n            leg = hypotenuse / math.sqrt(2)\n            return (leg, leg, hypotenuse)\n    else:\n        raise ValueError(\"Unknown triangle type or side type\")\n    \n    return (short_leg, long_leg, hypotenuse)", "def compute_special_triangle_sides(triangle_type, known_side, known_side_type):\n    \"\"\"\n    Compute the side lengths of a 30-60-90 or a 45-45-90 triangle given one length.\n    Parameters\n    ----------\n    triangle_type : str\n        Type of the triangle. It can be either \"30-60-90\" or \"45-45-90\".\n    known_side : float\n        Known length of the side.\n    known_side_type : str\n        Type of the known side. It can be \"short leg\", \"long leg\", or \"hypotenuse\".\n    \n    Returns\n    -------\n    dict\n        A python dict includes all sides' lengths.\n    Example\n    -------\n    >>> compute_special_triangle_sides(\"30-60-90\", 5, \"short leg\")\n    {'short leg': 5, 'long leg': 5*sqrt(3), 'hypotenuse': 10}\n    \"\"\"\n    if triangle_type == \"30-60-90\":\n        if known_side_type == \"short leg\":\n            return {'short leg': known_side, 'long leg': known_side*math.sqrt(3), 'hypotenuse': 2*known_side}\n        elif known_side_type == \"long leg\":\n            return {'short leg': known_side/math.sqrt(3), 'long leg': known_side, 'hypotenuse': 2*(known_side/math.sqrt(3))}\n        elif known_side_type == \"hypotenuse\":\n            return {'short leg': known_side/2, 'long leg': (known_side/2)*math.sqrt(3), 'hypotenuse': known_side}\n    elif triangle_type == \"45-45-90\":\n        return {'leg1': known_side/math.sqrt(2), 'leg2': known_side/math.sqrt(2), 'hypotenuse': known_side}", "def triangle_properties(triangle_type, known_side, side_type='hypotenuse'):\n    \"\"\"\n    Calculate the properties of a special right triangle (30-60-90 or 45-45-90)\n    given one side.\n    Parameters:\n        triangle_type (str): '30-60-90' or '45-45-90', specifying the type of triangle.\n        known_side (float): The length of the known side.\n        side_type (str): The type of the known side ('hypotenuse', 'short_leg', or 'long_leg' for 30-60-90,\n                         and 'hypotenuse', 'leg' for 45-45-90).\n    Returns:\n        dict: A dictionary with the lengths of the sides, perimeter, and area of the triangle.\n    Examples:\n        >>> triangle_properties('30-60-90', 10, 'hypotenuse')\n        {'short_leg': 5.0, 'long_leg': 5.0 * math.sqrt(3), 'hypotenuse': 10, 'area': 12.5 * math.sqrt(3), 'perimeter': 10 + 5.0 + 5.0 * math.sqrt(3)}\n        \n        >>> triangle_properties('45-45-90', 1, 'leg')\n        {'leg1': 1, 'leg2': 1, 'hypotenuse': 1 * math.sqrt(2), 'area': 0.5, 'perimeter': 2 + math.sqrt(2)}\n    \"\"\"\n    if triangle_type == '30-60-90':\n        if side_type == 'hypotenuse':\n            hypotenuse = known_side\n            short_leg = hypotenuse / 2\n            long_leg = short_leg * math.sqrt(3)\n        elif side_type == 'short_leg':\n            short_leg = known_side\n            long_leg = short_leg * math.sqrt(3)\n            hypotenuse = short_leg * 2\n        elif side_type == 'long_leg':\n            long_leg = known_side\n            short_leg = long_leg / math.sqrt(3)\n            hypotenuse = short_leg * 2\n        area = 0.5 * short_leg * long_leg\n        perimeter = short_leg + long_leg + hypotenuse\n        return {\n            'short_leg': short_leg,\n            'long_leg': long_leg,\n            'hypotenuse': hypotenuse,\n            'area': area,\n            'perimeter': perimeter\n        }\n    elif triangle_type == '45-45-90':\n        if side_type == 'leg':\n            leg = known_side\n            hypotenuse = leg * math.sqrt(2)\n        elif side_type == 'hypotenuse':\n            hypotenuse = known_side\n            leg = hypotenuse / math.sqrt(2)\n        area = 0.5 * leg * leg\n        perimeter = 2 * leg + hypotenuse\n        return {\n            'leg1': leg,\n            'leg2': leg,\n            'hypotenuse': hypotenuse,\n            'area': area,\n            'perimeter': perimeter\n        }", "def triangle_coordinates(triangle_type, base_start, base_end, side_known, side_type='hypotenuse'):\n    \"\"\"\n    Calculate the coordinates of the vertices of a triangle on a Cartesian plane, assuming\n    one side is horizontally aligned with known endpoints, and another side length is known.\n    Parameters:\n        triangle_type (str): '30-60-90' or '45-45-90', type of triangle.\n        base_start (tuple): Coordinates (x, y) of the starting point of the base.\n        base_end (tuple): Coordinates (x, y) of the ending point of the base.\n        side_known (float): Length of the known side other than the base.\n        side_type (str): Type of the known side ('hypotenuse', 'short_leg', 'long_leg' for 30-60-90,\n                         'hypotenuse', 'leg' for 45-45-90).\n    Returns:\n        dict: Dictionary containing coordinates of all vertices and calculations assumed right angle at base_start.\n    Examples:\n        >>> triangle_coordinates('30-60-90', (0, 0), (2, 0), 2, 'hypotenuse')\n        {'base_start': (0, 0), 'base_end': (2, 0), 'apex': (1, math.sqrt(3))}\n    \"\"\"\n    base_x1, base_y1 = base_start\n    base_x2, base_y2 = base_end\n    \n    # Calculate base length\n    base_length = math.sqrt((base_x2 - base_x1)**2 + (base_y2 - base_y1)**2)\n    \n    # Parameter calculations for triangle type\n    if triangle_type == '30-60-90':\n        if side_type == 'hypotenuse':\n            height = (side_known / 2) * math.sqrt(3)\n        elif side_type == 'short_leg':\n            height = side_known * math.sqrt(3)\n        elif side_type == 'long_leg':\n            height = side_known\n    elif triangle_type == '45-45-90':\n        if side_type == 'hypotenuse':\n            height = (side_known / math.sqrt(2))\n        elif side_type == 'leg':\n            height = side_known\n    \n    # Assuming the right angle is at base_start\n    apex = (base_x1 + (base_x2 - base_x1) / 2, base_y1 + height)\n    return {\n        'base_start': base_start,\n        'base_end': base_end,\n        'apex': apex\n    }", "def special_triangle_side_lengths(angle_type, one_length):\n    \"\"\"\n    Calculate the side lengths of special right triangles (45-45-90, 30-60-90) based on one known side length.\n    \n    Parameters:\n    angle_type (str): Type of special triangle ('45-45-90' or '30-60-90').\n    one_length (float): Length of one side, which can be leg or hypotenuse, depending on the type.\n    \n    Returns:\n    tuple: Lengths of the sides of the triangle.\n    \"\"\"\n    if angle_type == '45-45-90':\n        # In a 45-45-90 triangle, the legs are equal, and the hypotenuse is leg * sqrt(2)\n        return (one_length, one_length, one_length * math.sqrt(2))\n    elif angle_type == '30-60-90':\n        # In a 30-60-90 triangle, the shorter leg (opposite 30°) is one_length if given,\n        # the hypotenuse is 2 * one_length, and the longer leg (opposite 60°) is one_length * sqrt(3)\n        return (one_length, one_length * math.sqrt(3), 2 * one_length)\n    raise ValueError(\"Unsupported triangle type\")"], ["def calculate_inradius(a, b, c):\n    \"\"\"\n    Calculates the inradius of a triangle (radius of the inscribed circle).\n    \n    Parameters:\n        a (float): length of the first side of the triangle.\n        b (float): length of the second side of the triangle.\n        c (float): length of the third side of the triangle.\n    Returns:\n        float: the inradius of the triangle.\n    \n    Examples:\n        >>> calculate_inradius(3, 4, 5)\n        1.0\n    \"\"\"\n    area = herons_formula(a, b, c)\n    s = calculate_semiperimeter(a, b, c)\n    return area / s", "def calculate_circumradius(a, b, c):\n    \"\"\"\n    Calculates the circumradius of the triangle (radius of the circumscribed circle).\n    Parameters:\n        a (float): length of the first side of the triangle.\n        b (float): length of the second side of the triangle.\n        c (float): length of the third side of the triangle.\n    Returns:\n        float: the circumradius of the triangle.\n    \n    Examples:\n        >>> calculate_circumradius(3, 4, 5)\n        2.5\n    \"\"\"\n    area = herons_formula(a, b, c)\n    s = calculate_semiperimeter(a, b, c)\n    return (a * b * c) / (4 * area)"], ["def calculate_third_angle(angle1: float, angle2: float) -> float:\n    \"\"\"\n    Calculate the third angle in a triangle given two angles.\n    Parameters\n    ----------\n    angle1 : float\n        The measure of the first angle in degrees.\n    angle2 : float\n        The measure of the second angle in degrees.\n    Returns\n    -------\n    float\n        The measure of the third angle in degrees.\n    Examples\n    --------\n    >>> calculate_third_angle(60, 60)\n    60.0\n    \"\"\"\n    if angle1 <= 0 or angle2 <= 0 or angle1 + angle2 >= 180:\n        raise ValueError(\"The given angles are not valid for a triangle.\")\n    return 180 - (angle1 + angle2)", "def calculate_third_angle(angle1, angle2):\n    \"\"\"\n    Calculate the third angle of a triangle given two angles.\n    Parameters:\n    angle1 (float): The first angle of the triangle in degrees.\n    angle2 (float): The second angle of the triangle in degrees.\n    Returns:\n    float: The third angle of the triangle in degrees.\n    Example:\n    >>> calculate_third_angle(60, 50)\n    70.0\n    \"\"\"\n    return 180 - angle1 - angle2"], ["def triangle_properties(base, height, side=None):\n    \"\"\"\n    Given the base and height of a triangle, calculate and return the area and hypotenuse length.\n    Parameters:\n    base (float): The length of the base of the triangle.\n    height (float): The length of the height of the triangle.\n    side (float, optional): The length of one of the side of a right triangle to calculate the length of the hypotenuse \n    Returns:\n    area (float): The area of the triangle.\n    hypotenuse (float or None): The length of the hypotenuse of the triangle if side length is provided. None otherwise.\n    \"\"\"\n    import sympy\n    # Calculate Area\n    area = 0.5 * base * height\n    # Calculate Hypotenuse\n    if side is not None:\n        hypotenuse = sqrt(base**2 + side**2)\n    else:\n        hypotenuse = None\n    return area, hypotenuse"], ["def calculate_distance(point1, point2):\n    \"\"\"\n    Calculate the Euclidean distance between two points in 2D space.\n    \n    Parameters:\n        point1 (tuple): The (x, y) coordinates of the first point.\n        point2 (tuple): The (x, y) coordinates of the second point.\n    \n    Returns:\n        float: The distance between the two points.\n    \n    Example:\n        >>> calculate_distance((1, 1), (4, 5))\n        5.0\n    \"\"\"\n    return math.sqrt((point2[0] - point1[0])**2 + (point2[1] - point1[1])**2)"], ["def angle_between_vectors(x1, y1, x2, y2):\n    \"\"\"\n    Calculate the angle (in degrees) between two vectors originating from the origin.\n    \n    Parameters:\n        x1, y1 (float): Components of the first vector.\n        x2, y2 (float): Components of the second vector.\n    \n    Returns:\n        float: The angle in degrees between two vectors.\n    \n    Examples:\n        >>> angle_between_vectors(1, 0, 0, 1)\n        90.0\n    \"\"\"\n    dot_product = x1 * x2 + y1 * y2\n    magnitude1 = math.sqrt(x1**2 + y1**2)\n    magnitude2 = math.sqrt(x2**2 + y2**2)\n    angle_radians = math.acos(dot_product / (magnitude1 * magnitude2))\n    return math.degrees(angle_radians)"], ["def classify_triangle(a, b, c):\n    \"\"\"\n    Classify a triangle based on the lengths of its sides.\n    \n    Parameters:\n    a, b, c (float): Sides of the triangle.\n    Returns:\n    str: Type of triangle ('equilateral', 'isosceles', 'scalene', 'right').\n    \"\"\"\n    if a == b == c:\n        return 'equilateral'\n    elif a == b or b == c or a == c:\n        if is_right_triangle(a, b, c):\n            return 'right isosceles'\n        return 'isosceles'\n    elif is_right_triangle(a, b, c):\n        return 'right'\n    return 'scalene'"], ["def calculate_triangle_area(base, height=None, side_a=None, side_b=None, side_c=None):\n    \"\"\"\n    Calculate the area of a triangle either by using the base and height or by using Heron's formula if three sides are given.\n    \n    Parameters:\n        base (float): The length of the base of the triangle.\n        height (float): The height of the triangle. Default is None.\n        side_a (float): Length of side a of the triangle. Default is None.\n        side_b (float): Length of side b of the triangle. Default is None.\n        side_c (float): Length of side c of the triangle. Default is None.\n    Returns:\n        float: The area of the triangle.\n    Example:\n        >>> calculate_triangle_area(3, 4)  # Using base and height\n        6.0\n        >>> calculate_triangle_area(side_a=3, side_b=4, side_c=5)  # Using sides for Heron's formula\n        6.0\n    \"\"\"\n    if height is not None:\n        # Area = 0.5 * base * height\n        return 0.5 * base * height\n    elif side_a is not None and side_b is not None and side_c is not None:\n        # Heron's formula: Area = sqrt(s * (s - a) * (s - b) * (s - c)) where s = (a + b + c) / 2\n        s = (side_a + side_b + side_c) / 2\n        return math.sqrt(s * (s - side_a) * (s - side_b) * (s - side_c))\n    else:\n        raise ValueError(\"Insufficient parameters to calculate area\")", "def calculate_triangle_area(base=None, height=None, side=None):\n    \"\"\"\n    Calculate the area of a triangle using base and height or by specifying the sides using Heron's formula for equilateral triangles.\n    \n    Parameters:\n    base (float, optional): The base of the triangle.\n    height (float, optional): The height of the triangle.\n    side (float, optional): The length of a side if the triangle is equilateral.\n    Returns:\n    float: The area of the triangle.\n    Example:\n    >>> calculate_triangle_area(base=10, height=5)\n    25.0\n    >>> calculate_triangle_area(side=8)  # Equilateral triangle\n    13.856\n    \"\"\"\n    if base is not None and height is not None:\n        return 0.5 * base * height\n    elif side is not None:\n        # Area of an equilateral triangle: sqrt(3)/4 * side^2\n        return (math.sqrt(3) / 4) * (side**2)\n    else:\n        raise ValueError(\"Invalid inputs given. Provide either base and height for a regular triangle or side for an equilateral triangle.\")"], ["def triangle_angle_properties(a, b, c):\n    \"\"\" Calculate interior angles of the triangle given vertices a, b, and c.\n    Parameters:\n        a (tuple): Coordinates of vertex a (x1, y1)\n        b (tuple): Coordinates of vertex b (x2, y2)\n        c (tuple): Coordinates of vertex c (x3, y3)\n    \n    Returns:\n        A dictionary with angles at vertices A, B, and C respectively.\n    \"\"\"\n    p1, p2, p3 = Point(a), Point(b), Point(c)\n    # Create triangle ABC\n    triangle_abc = Triangle(p1, p2, p3)\n    # Calculate angles in degrees\n    angle_A = triangle_abc.angles[p1].evalf() * (180/pi)\n    angle_B = triangle_abc.angles[p2].evalf() * (180/pi)\n    angle_C = triangle_abc.angles[p3].evalf() * (180/pi)\n    \n    return {'angle_A': angle_A, 'angle_B': angle_B, 'angle_C': angle_C}"], ["def pythagorean_theorem(a=None, b=None, c=None):\n    \"\"\"\n    Apply the Pythagorean theorem to find the missing side of a right triangle.\n    Parameters:\n        a (float, optional): length of side a, leg of the triangle\n        b (float, optional): length of side b, leg of the triangle\n        c (float, optional): length of side c, hypotenuse of the triangle\n    Returns:\n        float: The length of the missing side.\n    Examples:\n    >>> pythagorean_theorem(a=3, b=4)\n    5.0\n    >>> pythagorean_theorem(c=10, b=6)\n    8.0\n    \"\"\"\n    import math\n    \n    if a is None:\n        return math.sqrt(c**2 - b**2)\n    elif b is None:\n        return math.sqrt(c**2 - a**2)\n    elif c is None:\n        return math.sqrt(a**2 + b**2)\n    else:\n        raise ValueError(\"Exactly one side must be None to find its length\")"], ["def triangle_similarity_by_sss(a_lengths, b_lengths):\n    \"\"\" Determine if two triangles are similar by Side-Side-Side (SSS) similarity criterion.\n    Parameters:\n        a_lengths (dict): Side lengths of triangle A {'ab': length1, 'bc': length2, 'ca': length3}\n        b_lengths (dict): Side lengths of triangle B {'ab': length1, 'bc': length2, 'ca': length3}\n    \n    Returns:\n        bool: True if triangles are similar, False otherwise.\n    \"\"\"\n    # Extracting lengths in sorted order\n    a_sorted = sorted(a_lengths.values())\n    b_sorted = sorted(b_lengths.values())\n    \n    # Checking proportionality\n    ratios = [a/b for a, b in zip(a_sorted, b_sorted)]\n    first_ratio = ratios[0]\n    \n    return all(abs(r - first_ratio) < 1e-9 for r in ratios)"], ["def side_length_to_angle_inequality(a, b, c):\n    \"\"\"\n    Determines the angle order opposite to the sides of a triangle given side lengths.\n    Parameters:\n        a (float): Length of side opposite to angle A.\n        b (float): Length of side opposite to angle B.\n        c (float): Length of side opposite to angle C.\n    Returns:\n        str: A description of the angle order based on the provided side lengths.\n    Examples:\n    >>> side_length_to_angle_inequality(5, 3, 4)\n    'A > C > B'\n    >>> side_length_to_angle_inequality(4, 6, 5)\n    'B > C > A'\n    \"\"\"\n    if not is_valid_triangle(a, b, c):\n        return \"Invalid triangle side lengths\"\n    angles = {'A': a, 'B': b, 'C': c}\n    sorted_angles = sorted(angles.items(), key=lambda x: x[1], reverse=True)\n    return ' > '.join([angle[0] for angle in sorted_angles])"], ["def compute_pythagorean_side_length(side1, side2, target_side):\n    \"\"\"\n    Applies the Pythagorean theorem to compute a side length in a right triangle.\n    Parameters\n    ----------\n    side1 : float\n        Length of one side of the triangle.\n    side2 : float\n        Length of another side of the triangle.\n    target_side : str\n        The side to compute. It can either be \"leg\" if both given sides are legs, or \"hypotenuse\" if one of the given sides is the hypotenuse.\n    \n    Returns\n    -------\n    float\n        The length of the requested side.\n    Example\n    -------\n    >>> compute_pythagorean_side_length(3, 4, \"hypotenuse\")\n    5.0\n    \"\"\"\n    if target_side == \"hypotenuse\":\n        return math.sqrt(side1**2 + side2**2)\n    else:\n        return math.sqrt(max(side1, side2)**2 - min(side1, side2)**2)"], ["def triangle_side_length(coord1, coord2):\n    \"\"\"\n    Function that calculates the length of a side of a triangle given the coordinates of its endpoints.\n    Parameters:\n    coord1 (tuple): coordinates of the first endpoint of the side. coord1 is a tuple of two numbers (x1, y1)\n    coord2 (tuple): coordinates of the second endpoint of the side. coord2 is a tuple of two numbers (x2, y2)\n    \n    Returns:\n    float: length of the side calculated by the distance formula sqrt((x2 - x1)**2 + (y2 - y1)**2)\n    \n    Examples:\n    >>> triangle_side_length((0,0), (3,4))\n    5.0\n    \"\"\"\n    x1, y1 = coord1\n    x2, y2 = coord2\n    return math.sqrt((x2 - x1)**2 + (y2 - y1)**2)"], ["def calculate_right_triangle_sides(known_side, hypotenuse=None, other_side=None):\n    \"\"\"\n    Given a side and either the hypotenuse or the other side, calculate the missing side using Pythagoras' theorem.\n    Parameters:\n    - known_side (float): Length of one known side of the right triangle.\n    - hypotenuse (float, optional): Hypotenuse of the triangle, if known.\n    - other_side (float, optional): The other side (leg) of the triangle, if known.\n    Returns:\n    float: The length of the missing side.\n    \n    Example:\n    >>> calculate_right_triangle_sides(3, hypotenuse=5)\n    4.0\n    \"\"\"\n    if hypotenuse:\n        return math.sqrt(hypotenuse**2 - known_side**2)\n    elif other_side:\n        return math.sqrt(known_side**2 + other_side**2)\n    else:\n        raise ValueError('Either hypotenuse or the other side must be known.')"], ["def equilateral_triangle_properties(side_length: float) -> dict:\n    \"\"\"\n    Calculate the perimeter and area of an equilateral triangle given its side length.\n    Parameters\n    ----------\n    side_length : float\n        The length of one side of the equilateral triangle.\n    Returns\n    -------\n    dict\n        A dictionary containing the perimeter and area of the equilateral triangle.\n    Examples\n    --------\n    >>> equilateral_triangle_properties(5)\n    {'perimeter': 15.0, 'area': 10.825317547305486}\n    \"\"\"\n    from math import sqrt\n    perimeter = 3 * side_length\n    area = (sqrt(3) / 4) * side_length**2\n    return {'perimeter': perimeter, 'area': area}"], ["def are_triangles_similar(t1, t2):\n    \"\"\"\n    Function that checks whether two triangles are similar.\n    \n    Parameters:\n    t1 (tuple): a tuple of three side lengths of the first triangle\n    t2 (tuple): a tuple of three side lengths of the second triangle\n    \n    Returns:\n    bool: True if the triangles are similar (i.e., their sides are proportional), and False otherwise.\n    \n    Examples:\n    >>> are_triangles_similar((3,4,5), (6,8,10))\n    True\n    \"\"\"\n    t1 = sorted(t1)\n    t2 = sorted(t2)\n    ratios = [a/b for a, b in zip(t1, t2)]\n    return len(set(ratios)) == 1"], ["def is_right_triangle(a, b, c):\n    \"\"\"\n    Determine if a triangle with sides a, b, c is a right triangle.\n    \n    Parameters:\n    a, b, c (float): Sides of the triangle.\n    Returns:\n    bool: True if the triangle is right, False otherwise.\n    \"\"\"\n    sides = sorted([a, b, c])\n    return math.isclose(sides[0]**2 + sides[1]**2, sides[2]**2)"], ["def calculate_triangle_perimeter(sides):\n    \"\"\"\n    Calculate the perimeter of a triangle given the lengths of the sides.\n    Parameters:\n    - sides (tuple/list): A collection of the three side lengths.\n    Returns:\n    float: The perimeter of the triangle.\n    \n    Example:\n    >>> calculate_triangle_perimeter((3, 4, 5))\n    12\n    \"\"\"\n    return sum(sides)"], ["def area_by_inradius_semiperimeter(inradius: float, semiperimeter: float) -> float:\n    \"\"\"\n    Calculate the area of a triangle given the inradius and the semiperimeter.\n    Parameters:\n    - inradius (float): The radius of the inscribed circle of the triangle.\n    - semiperimeter (float): The semiperimeter of the triangle.\n    Returns:\n    - float: The area of the triangle.\n    Examples:\n    >>> area_by_inradius_semiperimeter(1, 6)\n    6.0\n    \"\"\"\n    return inradius * semiperimeter"], ["def isosceles_right_triangle_side_length(hypotenuse: float = None, leg: float = None) -> float:\n    \"\"\"\n    Calculate the length of the legs or the hypotenuse of an isosceles right triangle.\n    Parameters\n    ----------\n    hypotenuse : float, optional\n        The length of the hypotenuse of the triangle. If provided, `leg` must be None.\n    leg : float, optional\n        The length of one of the equal legs of the triangle. If provided, `hypotenuse` must be None.\n    Returns\n    -------\n    float\n        The length of the other component (leg if hypotenuse is given, hypotenuse if leg is given).\n    Examples\n    --------\n    >>> isosceles_right_triangle_side_length(leg=5)\n    7.0710678118654755\n    >>> isosceles_right_triangle_side_length(hypotenuse=7.0710678118654755)\n    5.0\n    \"\"\"\n    from math import sqrt\n    if hypotenuse is not None and leg is None:\n        return hypotenuse / sqrt(2)\n    elif leg is not None and hypotenuse is None:\n        return leg * sqrt(2)\n    else:\n        raise ValueError(\"Either hypotenuse or leg must be provided, but not both.\")"], ["def identify_triangle(a, b, c):\n    \"\"\"\n    Identify the type of triangle based on given side lengths.\n    Parameters:\n        a (float): length of side a\n        b (float): length of side b\n        c (float): length of side c\n    Returns:\n        str: Type of triangle (\"Right\", \"Acute\", \"Obtuse\", or \"Not a triangle\")\n    Examples:\n    >>> identify_triangle(3, 4, 5)\n    'Right'\n    >>> identify_triangle(7, 10, 5)\n    'Acute'\n    \"\"\"\n    import math\n    \n    # First, check if a valid triangle can be formed\n    if a + b <= c or a + c <= b or b + c <= a:\n        return \"Not a triangle\"\n    \n    # Calculate squares\n    a2, b2, c2 = a**2, b**2, c**2\n    \n    # Identify the type based on side lengths squared\n    if math.isclose(a2 + b2, c2) or math.isclose(a2 + c2, b2) or math.isclose(b2 + c2, a2):\n        return \"Right\"\n    elif a2 + b2 < c2 or b2 + c2 < a2 or a2 + c2 < b2:\n        return \"Obtuse\"\n    else:\n        return \"Acute\""], ["def midsegment_length(side1, side2):\n    \"\"\"\n    Function that calculates the length of a mid-segment of a triangle.\n    \n    Parameters: \n    side1 (float): length of one side of the triangle. Side length cannot be negative.\n    side2 (float): length of the other side of the triangle. Side length cannot be negative.\n    \n    Returns: \n    float: length of the mid-segment, which is half the sum of the lengths of the two sides.\n    \n    Examples:\n    >>> midsegment_length(3, 4)\n    3.5\n    \"\"\"\n    try:\n        # Check for valid inputs\n        assert side1 >= 0\n        assert side2 >= 0\n    except AssertionError:\n        raise ValueError('Inputs must be positive numbers')\n    \n    return (side1 + side2) / 2"], ["def calculate_side_range_and_perimeter(a: float, b: float) -> Tuple[Tuple[int, int], int]:\n    \"\"\"\n    Calculate the possible values for the third side of a triangle when two sides are known.\n    Also, returns the maximal possible integer perimeter.\n    \n    Parameters:\n    a (float): Length of the first known side of the triangle.\n    b (float): Length of the second known side of the triangle.\n    \n    Returns:\n    Tuple[Tuple[int, int], int]: Returns a tuple containing another tuple and an integer. \n    The inner tuple represents the minimum and maximum possible integer values for the third side,\n    while the integer represents the maximum possible integer perimeter if the maximum side length is used.\n    \n    Examples:\n    >>> calculate_side_range_and_perimeter(3, 4)\n    ((2, 6), 13)\n    >>> calculate_side_range_and_perimeter(5, 10)\n    ((6, 14), 29)\n    \"\"\"\n    if a <= 0 or b <= 0:\n        raise ValueError(\"Side lengths must be positive numbers\")\n    min_c = max(abs(a - b) + 1, 1)\n    max_c = a + b - 1\n    max_perimeter = a + b + max_c\n    return ((min_c, max_c), max_perimeter)"], ["def triangle_side_lengths(a, b, c):\n    \"\"\" Calculate the triangle side lengths given vertices a, b, and c.\n    Parameters:\n        a (tuple): Coordinates of vertex a (x1, y1)\n        b (tuple): Coordinates of vertex b (x2, y2)\n        c (tuple): Coordinates of vertex c (x3, y3)\n    \n    Returns:\n        A dictionary with side lengths ab, bc, and ca.\n    \"\"\"\n    # Convert tuples to Points\n    p1, p2, p3 = Point(a), Point(b), Point(c)\n    # Create triangle ABC\n    triangle_abc = Triangle(p1, p2, p3)\n    \n    # Calculate side lengths\n    ab = triangle_abc.ab.length.evalf()\n    bc = triangle_abc.bc.length.evalf()\n    ca = triangle_abc.ca.length.evalf()\n    \n    return {'ab': ab, 'bc': bc, 'ca': ca}"], ["def solve_triangle(a, b, A):\n    \"\"\"\n    Calculate the missing side c and the remaining angles B and C in a triangle using the Law of Sines.\n    The provided angles must be in degrees.\n    \n    Parameters:\n        a (float): The length of side a.\n        b (float): The length of side b.\n        A (float): The angle opposite to side a in degrees.\n    \n    Returns:\n        tuple: Returns the length of side c and the angles B and C in degrees.\n    \n    Example:\n        >>> solve_triangle(3, 4, 30)\n        (2.3094, 53.1301, 96.8699)\n    \"\"\"\n    A = math.radians(A)  # Convert angle A from degrees to radians\n    sin_A = math.sin(A)\n    sin_B = (b * sin_A) / a\n    if sin_B > 1 or sin_B < -1:  # Check for invalid triangle configuration\n        return None\n    B = math.asin(sin_B)\n    C = math.pi - A - B\n    c = (a * math.sin(C)) / sin_A\n    return (c, math.degrees(B), math.degrees(C))"], ["def calculate_isosceles_triangle_altitude(base: float, side_length: float) -> float:\n    \"\"\"\n    Calculate the altitude of an isosceles triangle.\n    Parameters\n    ----------\n    base : float\n        The length of the base of the isosceles triangle.\n    side_length : float\n        The length of the other two equal sides of the isosceles triangle.\n    Returns\n    -------\n    float\n        The length of the altitude from the vertex opposite the base to the base.\n    Examples\n    --------\n    >>> calculate_isosceles_triangle_altitude(8, 5)\n    4.358898943540674\n    \"\"\"\n    from math import sqrt\n    if base / 2 >= side_length:\n        raise ValueError(\"Invalid dimensions for an isosceles triangle.\")\n    altitude = sqrt(side_length**2 - (base / 2)**2)\n    return altitude"], ["def midpoint(x1, y1, x2, y2):\n    \"\"\"\n    Calculate the midpoint of a segment given the coordinates of its endpoints.\n    \n    Parameters:\n        x1, y1 (float): Coordinates of the first endpoint.\n        x2, y2 (float): Coordinates of the second endpoint.\n    \n    Returns:\n        tuple: The coordinates of the midpoint.\n    \n    Examples:\n        >>> midpoint(1, 1, 4, 5)\n        (2.5, 3.0)\n    \"\"\"\n    return ((x1 + x2) / 2, (y1 + y2) / 2)"]], "Parabolas": [["def parabola_vertex(a, b, c):\n    \"\"\"\n    Calculates the vertex of a parabola given its quadratic coefficients.\n    Parameters:\n        a (float): coefficient of x^2 in the quadratic equation\n        b (float): coefficient of x in the quadratic equation\n        c (float): constant term in the quadratic equation\n    Returns:\n        tuple: (x, y) coordinates of the vertex\n    Example:\n        >>> parabola_vertex(1, -4, 3)\n        (2.0, -1.0)\n    \"\"\"\n    h = -b / (2 * a)\n    k = a * h**2 + b * h + c\n    return (h, k)", "def standard_to_vertex_form(a, b, c):\n    \"\"\"\n    Converts a standard quadratic equation ax^2 + bx + c to its vertex form a(x-h)^2 + k.\n    Parameters:\n        a (float): coefficient of x^2 in the quadratic equation\n        b (float): coefficient of x in the quadratic equation\n        c (float): constant term in the quadratic equation\n    Returns:\n        str: a string representation of the vertex form of the equation\n    Example:\n        >>> standard_to_vertex_form(1, -4, 4)\n        '1*(x-2.0)^2+0.0'\n    \"\"\"\n    h, k = parabola_vertex(a, b, c)\n    return f\"{a}*(x-{h})^2+{k}\"", "def parabola_vertex(a, b, c):\n    \"\"\"\n    Computes the vertex of a parabola given its coefficients in the standard quadratic form y = ax^2 + bx + c.\n    Parameters:\n    a (float): coefficient of x^2\n    b (float): coefficient of x\n    c (float): constant term\n    Returns:\n    tuple: (x, y) coordinates of the vertex.\n    \n    Examples:\n    >>> parabola_vertex(1, 0, -4)\n    (0.0, -4.0)\n    >>> parabola_vertex(1, -2, 1)\n    (1.0, 0.0)\n    \"\"\"\n    x_vertex = -b / (2 * a)\n    y_vertex = a * x_vertex ** 2 + b * x_vertex + c\n    return (x_vertex, y_vertex)", "def quadratic_to_vertex_form(a, b, c):\n    \"\"\"\n    Converts a quadratic equation from standard form (ax^2 + bx + c) to vertex form (a*(x-h)^2 + k).\n    Parameters:\n        a (float): Coefficient of x^2.\n        b (float): Coefficient of x.\n        c (float): Constant term.\n    Returns:\n        tuple: Returns the vertex form coefficients (a, h, k) where \n               the vertex form is a*(x-h)^2 + k and (h, k) is the vertex of the parabola.\n    Example:\n        >>> quadratic_to_vertex_form(1, -4, 4)\n        (1, 2, 0)\n    \"\"\"\n    h = -b / (2 * a)\n    k = c - (b ** 2) / (4 * a)\n    return a, h, k", "def vertex_from_quadratic(a, b, c):\n    \"\"\"\n    Calculates the vertex (h, k) of a parabola given its quadratic coefficients.\n    Parameters:\n        a (float): Coefficient of x^2.\n        b (float): Coefficient of x.\n        c (float): Constant term.\n    Returns:\n        tuple: The vertex (h, k) of the parabola.\n    Example:\n        >>> vertex_from_quadratic(1, -4, 4)\n        (2, 0)\n    \"\"\"\n    h = -b / (2 * a)\n    k = a * h**2 + b * h + c\n    return h, k"], ["def tangent_to_parabola(point, equation):\n    \"\"\"\n    Find the equation of the tangent line at a given point on the parabola y = ax^2 + bx + c.\n    Parameters:\n    point (tuple): A tuple (x0, y0) representing the point of tangency.\n    equation (sp.Expr): A sympy expression representing the quadratic parabola.\n    Returns:\n    sp.Expr: An equation representing the tangent line at the given point.\n    Examples:\n    >>> x, y = sp.symbols('x y')\n    >>> eq = x**2 - 6*x + 9\n    >>> point = (3, 0)\n    >>> tangent_line = tangent_to_parabola(point, eq)\n    >>> print(tangent_line)\n    y - 0 = 0*(x - 3)\n    \"\"\"\n    x, y = sp.symbols('x y')\n    x0, y0 = point\n    \n    # Derivative to find slope\n    dy_dx = sp.diff(equation, x)\n    slope = dy_dx.subs(x, x0)\n    tangent_eq = y - y0 - slope * (x - x0)\n    \n    return tangent_eq", "def tangent_to_parabola(a, b, c, x1):\n    \"\"\"\n    Calculates the equation of the tangent line to the parabola at a specific x-coordinate.\n    Parameters:\n        a (float): coefficient of x^2 in the quadratic equation\n        b (float): coefficient of x in the quadratic equation\n        c (float): constant term in the quadratic equation\n        x1 (float): x-coordinate at which the tangent line is calculated\n    Returns:\n        str: the equation of the tangent line in the form 'y = mx + b'\n    Example:\n        >>> tangent_to_parabola(1, 0, 0, 1)\n        'y = 2*x - 1'\n    \"\"\"\n    x = sp.symbols('x')\n    y = a*x**2 + b*x + c\n    dy_dx = sp.diff(y, x)\n    slope = dy_dx.subs(x, x1)\n    y1 = a*x1**2 + b*x1 + c\n    b = y1 - slope * x1\n    return f\"y = {slope}*x + {b}\"", "def tangent_to_parabola(a, b, c, x1):\n    \"\"\"\n    Finds the equation of the tangent line to a parabola y = ax^2 + bx + c at a given x-coordinate x1.\n    Parameters:\n        a (float): Coefficient of x^2.\n        b (float): Coefficient of x.\n        c (float): Constant term.\n        x1 (float): x-coordinate at which the tangent is calculated.\n    Returns:\n        sympy.Eq: Equation of the tangent line in terms of y and x.\n    Example:\n        >>> tangent_to_parabola(1, 0, 0, 1)\n        Eq(y, 2*x - 1)\n    \"\"\"\n    y = a*x**2 + b*x + c\n    dy_dx = diff(y, x)\n    slope = dy 값은 다음 변수 값으로 대체되어야 x).subs(x, x1)\n    y1 = y.subs(x, x1)\n    tangent_eq = Eq(y, slope * (x - x1) + y1)\n    return tangent_eq"], ["def parabola_line_intersection(a, b, c, line_slope, line_intercept):\n    \"\"\"\n    Computes the intersection points of a parabola y = ax^2 + bx + c with a line y = mx + n.\n    Parameters:\n    a : float\n        Coefficient 'a' of the parabola.\n    b : float\n        Coefficient 'b' of the parabola.\n    c : float\n        Coefficient 'c' of the parabola.\n    line_slope : float\n        Slope 'm' of the line.\n    line_intercept : float\n        Intercept 'n' of the line.\n    Returns:\n    numpy.array\n        Array containing the intersection points (x, y). Can be empty if there are no real intersections.\n    Examples:\n    >>> parabola_line_intersection(1, 0, -1, 1, 0)\n    array([[-1.61803399, -1.61803399], [0.61803399, 0.61803399]])\n    \"\"\"\n    from numpy import roots\n    from numpy import array\n    \n    # Finding roots of the quadratic equation formed by setting y values equal\n    quadratic = [a, b - line_slope, c - line_intercept]\n    x_roots = roots(quadratic)\n    \n    # Filter only real roots\n    x_roots = x_roots[abs(x_roots.imag) < 1e-6].real\n    y_roots = line_slope * x_roots + line_intercept\n    \n    # Construct the result array\n    points = array(list(zip(x_roots, y_roots)))\n    return points", "def parabola_line_intersection(a, b, c, m, n):\n    \"\"\"\n    Finds the intersection points of a line y = mx + n with a parabola y = ax^2 + bx + c.\n    Parameters:\n        a (float): coefficient of x^2 in the quadratic equation of the parabola\n        b (float): coefficient of x in the quadratic equation of the parabola\n        c (float): constant term in the quadratic equation of the parabola\n        m (float): slope of the line\n        n (float): y-intercept of the line\n    Returns:\n        list: a list of tuples representing the intersection points (x, y)\n    Example:\n        >>> parabola_line_intersection(1, -4, 4, 1, 0)\n        [(2.8284271247, 2.8284271247), (-0.8284271247, -0.8284271247)]\n    \"\"\"\n    x = sp.symbols('x')\n    equation = a*x**2 + b*x + c - (m*x + n)\n    solutions = sp.solveset(equation, x, domain=sp.S.Reals)\n    points = [(float(sol), m*float(sol) + n) for sol in solutions]\n    return points", "def intersection_of_line_and_parabola(a, b, c, m, d):\n    \"\"\"\n    Finds the points of intersection between a line y = mx + d and a parabola y = ax^2 + bx + c.\n    Parameters:\n        a (float): Coefficient of quadratic term in the parabola.\n        b (float): Coefficient of linear term in the parabola.\n        c (float): Constant term of the parabola,\n        m (float): Slope of the line.\n        d (float): y-intercept of the line.\n    Returns:\n        list: x-coordinates of intersection points.\n    Example:\n        >>> intersection_of_line_and_parabota(1, -6, 8, -0.5, 0)\n        [2.0, 4.0]\n    \"\"\"\n    y_parabola = a * x**2 + b * x + c\n    y_line = m * x + d\n    intersection_eq = Eq(y_parabola, y_line)\n    x_solutions = solve(intersection_eq, x)\n    return x_solutions"], ["def parabola_properties(equation):\n    \"\"\"\n    Given a quadratic equation, compute key properties of the corresponding parabola.\n    Parameters:\n    equation (sp.Expr): A sympy expression representing the quadratic equation y = ax^2 + bx + c.\n    Returns:\n    dict: A dictionary containing the vertex, focus, directrix, and axis of symmetry of the parabola.\n    Examples:\n    >>> x, y = sp.symbols('x y')\n    >>> eq = x**2 - 4*x + 4\n    >>> properties = parabola_properties(eq)\n    >>> print(properties[\"vertex\"])\n    (2, 0)\n    >>> print(properties[\"focus\"])\n    (2, 0.25)\n    \"\"\"\n    x = sp.symbols('x')\n    a = equation.expand().coeff(x, 2)\n    b = equation.expand().coeff(x, 1)\n    c = equation.expand().coeff(x, 0)\n    # Vertex formula\n    xv = -b / (2 * a)\n    yv = equation.subs(x, xv)\n    vertex = (xv, yv)\n    # Focus and directrix\n    focus_x = xv\n    focus_y = yv + 1/(4*a)\n    focus = (focus_x, focus_y)\n    directrix = yv - 1/(4*a)\n    return {\n        \"vertex\": vertex,\n        \"focus\": focus,\n        \"directrix\": directrix,\n        \"axis of symmetry\": xv\n    }", "def parabola_properties(a, b=0, c=0, h=None, k=None):\n    \"\"\"\n    Calculate the properties of a parabola given either standard form coefficients or vertex form parameters.\n    \n    Parameters:\n    a : float\n        The coefficient 'a' in the parabola's equation y=ax^2+bx+c or the equivalent stretch factor in vertex form y=a(x-h)^2+k.\n    b : float, optional\n        The coefficient 'b' in the standard form. Default is 0.\n    c : float, optional\n        The coefficient 'c' in the standard form or the y-coordinate of vertex in vertex form if h and k are provided. Default is 0.\n    h : float, optional\n        The x-coordinate of the vertex in vertex form. If None, standard form is assumed. Default is None.\n    k : float, optional\n        The y-coordinate of the vertex in vertex form. If None, standard form is assumed. Default is None.\n    Returns:\n    dict\n        A dictionary containing the vertex (tuple), focus (tuple), and directrix (float).\n    Examples:\n    >>> parabola_properties(1, -4, 4)\n    {'vertex': (2.0, 0.0), 'focus': (2.0, 0.25), 'directrix': -0.25}\n    \n    >>> parabola_properties(a=1, h=2, k=0)\n    {'vertex': (2, 0), 'focus': (2, 0.25), 'directrix': -0.25}\n    \"\"\"\n    if h is None and k is None:\n        # Calculate vertex from standard form\n        h = -b / (2 * a)\n        k = a * h**2 + b * h + c\n    \n    # Vertex\n    vertex = (h, k)\n    \n    # Focus and Directrix, p is the distance from the vertex to the focus and directrix\n    p = 1/(4 * a)\n    focus = (h, k + p) if a > 0 else (h, k - p)\n    directrix = k - p if a > 0 else k + p\n    \n    return {'vertex': vertex, 'focus': focus, 'directrix': directrix}", "def parabola_properties(a, b, c):\n    \"\"\"\n    Calculate key properties of a parabola given its quadratic equation parameters (y=ax^2+bx+c).\n    \n    Parameters:\n    - a (float): Coefficient of x^2\n    - b (float): Coefficient of x\n    - c (float): Constant term\n    Returns:\n    - dict: A dictionary containing 'vertex' (tuple), 'focus' (tuple), and 'directrix' (float).\n    Examples:\n    >>> parabola_properties(1, 0, 0)\n    {'vertex': (0.0, 0.0), 'focus': (0.0, 0.25), 'directrix': -0.25}\n    \"\"\"\n    x = symbols('x')\n    vertex_x = -b / (2 * a)\n    vertex_y = a * vertex_x**2 + b * vertex_x + c\n    focus_x = vertex_x\n    focus_y = vertex_y + 1 / (4 * a)\n    directrix_y = vertex_y - 1 / (4 * a)\n    \n    return {'vertex': (vertex_x, vertex_y), 'focus': (focus_x, focus_y), 'directrix': directrix_y}"], ["def distance_point_to_line(px, py, a, b, c):\n    \"\"\"\n    Calculates the distance from a point (px, py) to a line ax + by + c = 0.\n    Parameters:\n    px (float): x-coordinate of the point\n    py (float): y-coordinate of the point\n    a (float): coefficient of x in the line equation\n    b (float): coefficient of y in the line equation\n    c (float): constant term of the line equation\n    Returns:\n    float: The distance from the point to the line.\n    Examples:\n    >>> distance_point_to_classes(1, 2, 1, -1, 0)\n    0.7071067811865476\n    \"\"\"\n    return abs(a*px + b*py + c) / np.sqrt(a**2 + b**2)"], ["def parabola_equation(vertex, point=None, focus=None):\n    \"\"\"\n    Given a vertex and either a point on the parabola or the focus, this function returns the parabola's equation.\n    Parameters:\n    vertex (tuple): A tuple (xv, yv) representing the vertex of the parabola.\n    point (tuple, optional): A tuple (x, y) representing another point on the parabola.\n    focus (tuple, optional): A tuple (xf, yf) representing the focus of the parabola.\n    Returns:\n    sp.Expr: A sympy expression representing the quadratic equation y = ax^2 + bx + c.\n    Examples:\n    >>> vertex = (2, 3)\n    >>> point = (0, 7)\n    >>> equation = parabola_equation(vertex, point=point)\n    >>> print(equation)\n    y = (x - 2)**2 + 3\n    \"\"\"\n    x, y = sp.symbols('x y')\n    xv, yv = vertex\n    if point:\n        xp, yp = point\n        a = (yp - yv) / ((xp - xv)**2)\n        return a * (x - xv)**2 + yv\n    if focus:\n        xf, yf = focus\n        a = 1 / (4 * (yf - yv))\n        return a * (x - xv)**2 + yv"], ["def curve_intersection(eq1, eq2, var1='x', var2='y'):\n    \"\"\"\n    Calculate intersection points between two curves given by their equations.\n    \n    Parameters:\n    - eq1 (sp.Expr): The first curve equation in symbols.\n    - eq2 (sp.Expr): The second curve equation in symbols.\n    - var1 (str): The primary variable in the equations (default: 'x').\n    - var2 (str): The secondary variable in the equations (default: 'y').\n    Returns:\n    - list of tuples: List of intersection points.\n    Examples:\n    >>> x, y = sp.symbols('x y')\n    >>> parabola = y - x**2\n    >>> circle = x**2 + y**2 - 5\n    >>> curve_intersection(parabola, circle)\n    [(sqrt(5)/sqrt(3), 5/3), (-sqrt(5)/sqrt(3), 5/3)]\n    \"\"\"\n    x, y = sp.symbols(var1 + ' ' + var2)\n    intersection_points = sp.solve((eq1, eq2), (x, y))\n    return intersection_points"], ["def distance_between_points(x1, y1, x2, y2):\n    \"\"\"\n    Computes distance between two points (x1, y1) and (x2, y2).\n    Parameters:\n    x1, y1, x2, y2 (float): coordinates of the two points\n    Returns:\n    float: The euclidean distance between the points.\n    Examples:\n    >>> distance_between_points(1, 2, 4, 6)\n    5.0\n    \"\"\"\n    return euclidean((x1, y1), (x2, y2))"], ["def focus_and_directrix(a, b, c):\n    \"\"\"\n    Calculates the focus point and the equation of the directrix of a parabola defined by y = ax^2 + bx + c.\n    Parameters:\n    a (float): coefficient of x^2\n    b (float): coefficient of x\n    c (float): constant term\n    Returns:\n    tuple: (focus (tuple), directrix (equation: y = mx + c))\n        \n    Examples:\n    >>> focus_and_directrix(1, 0, 0)\n    ((0, 0.25), 'y = -0.25')\n    >>> focus_and_directrix(1, -2, 1)\n    ((1, 0.75), 'y = -0.75')\n    \"\"\"\n    x_vertex, y_vertex = parabola_vertex(a, b, c)\n    p = 1 / (4 * a)\n    focus = (x_vertex, y_vertex + p)\n    directrix_y = y_vertex - p\n    directrix = f\"y = {directrix_y}\"\n    return (focus, directrix)"]], "Polygons": [["def number_of_sides_given_interior_angle(angle):\n    \"\"\"\n    Calculate the number of sides of a regular polygon given the measure of one interior angle.\n    \n    Parameters\n    ----------\n    angle : float\n        Measure of the interior angle of the regular polygon in degrees\n    \n    Returns\n    -------\n    int\n        Number of sides of the polygon\n    \n    Examples\n    --------\n    >>> number_of_sides_given_interior_angle(120)\n    6\n    \n    >>> number_of_sides_given_interior_angle(90)\n    4\n    \"\"\"\n    if angle <= 0 or angle >= 180:\n        raise ValueError(\"Invalid angle measure. Angle must be between 0 and 180 degrees.\")\n    n = 360 / (180 - angle)\n    if n.is_integer():\n        return int(n)\n    else:\n        raise ValueError(\"No regular polygon has an interior angle of exactly {} degrees\".format(angle))", "def exterior_angle_from_interior(interior_angle):\n    \"\"\"\n    Calculate the exterior angle of a polygon from its interior angle.\n    Parameters:\n    - interior_angle (float or int): Interior angle of the polygon in degrees.\n    Returns:\n    - float: Exterior angle corresponding to the given interior angle.\n    Examples:\n    >>> exterior_angle_from_interior(90)\n    90.0\n    >>> exterior_angle_from_interior(120)\n    60.0\n    \"\"\"\n    return 180 - interior_angle", "def sides_from_interior_angle(interior_angle):\n    \"\"\"\n    Calculate the number of sides of a regular polygon from one interior angle.\n    Parameters:\n    - interior_angle (float): An interior angle of the polygon in degrees.\n    Returns:\n    - int: Number of sides of the polygon.\n    Examples:\n    >>> sides_from_interior_angle(90)\n    4\n    >>> sides_from_interior_angle(120)\n    6\n    \"\"\"\n    if interior_angle >= 180:\n        raise ValueError(\"Interior angle must be less than 180 degrees for a valid polygon.\")\n    return int(360 / (180 - interior_angle))"], ["def polygon_angle_properties(n, angle_type='interior'):\n    \"\"\"\n    Calculate properties of angles in a regular polygon, including each individual angle and solving for 'n' given an angle.\n    Parameters:\n    - n (int or float): Number of sides of the polygon, or an interior/exterior angle degree if solving for 'n'.\n    - angle_type (str): Type of calculation - 'interior', 'exterior', or 'solve_for_n_interior','solve_for_n_exterior'.\n    Returns:\n    - float or int: Depending on the angle_type, returns the degree of each angle or the number of sides.\n    Examples:\n    >>> polygon_angle_properties(4)\n    90.0\n    >>> polygon_angle_properties(90, 'solve_for_n_interior')\n    4\n    >>> polygon_angle_properties(45, 'solve_for_n_exterior')\n    8\n    \"\"\"\n    import math\n    if angle_type == 'interior':\n        if n < 3:\n            raise ValueError(\"A polygon must have at least 3 sides.\")\n        return (n - 2) * 180.0 / n\n    elif angle_type == 'exterior':\n        if n < 3:\n            raise ValueError(\"A polygon must have at least 3 sides.\")\n        return 360.0 / n\n    elif angle_type == 'solve_for_n_interior':\n        # 180(n - 2) / n = angle\n        # 180n - 360 = n * angle\n        # 180n - n * angle = 360\n        # n(180 - angle) = 360\n        # n = 360 / (180 - angle)\n        return round(360 / (180 - n))\n    elif angle_type == 'solve_for_n_exterior':\n        # 360 / n = angle\n        # n = 360 / angle\n        return round(360 / n)\n    else:\n        raise ValueError(\"Invalid angle_type specified. Choose 'interior', 'exterior', 'solve_for_n_interior' or 'solve_for_n_exterior'.\")\n    return None", "def polygon_properties(sides, side_length=None):\n    \"\"\"\n    Calculate various properties of a regular polygon given the number of sides and optionally the side length.\n    Parameters\n    ----------\n    sides : int\n        Number of sides (n) of the polygon.\n    side_length : float, optional\n        Length of each side of the polygon (used for calculating the perimeter and area).\n    Returns\n    -------\n    dict\n        A dictionary containing:\n        - 'interior_angle': float, the measurement of each interior angle.\n        - 'exterior_angle': float, the measurement of each exterior angle.\n        - 'sum_interior_angles': float, the sum of all interior angles.\n        - 'perimeter': float (if side_length is provided), the total perimeter of the polygon.\n        - 'area': float (if side_length is provided), the area of the regular polygon.\n        - 'diagonals': int, the number of diagonals.\n    Examples\n    --------\n    >>> polygon_properties(6, 10)\n    {'interior_angle': 120.0, 'exterior_angle': 60.0, 'sum_interior_angles': 720.0, 'perimeter': 60, 'area': 259.8076211353316, 'diagonals': 9}\n    \"\"\"\n    radians_for_calc = math.pi / sides\n    interior_angle = (sides - 2) * 180 / sides\n    exterior_angle = 360 / sides\n    sum_interior_angles = (sides - 2) * 180\n    diagonals = sides * (sides - 3) // 2\n    \n    properties = {\n        \"interior_angle\": interior_angle,\n        \"exterior_angle\": exterior_angle,\n        \"sum_interior_angles\": sum_interior_angles,\n        \"diagonals\": diagonals\n    }\n    \n    if side_length is not None:\n        perimeter = sides * side_length\n        apothem = side_length / (2 * math.tan(radians_for_calc))\n        area = 0.5 * perimeter * apothem\n        properties.update({\"perimeter\": perimeter, \"area\": area})\n    \n    return properties"], ["def sum_of_interior_angles(n):\n    \"\"\"\n    Calculate the sum of the interior angles of an n-sided polygon.\n    \n    Parameters\n    ----------\n    n : int\n        Number of sides of the polygon\n    \n    Returns\n    -------\n    int\n        Sum of the interior angles in degrees\n    \n    Examples\n    --------\n    >>> sum_of_interior_angles(4)\n    360\n    \n    >>> sum_of_interior_angles(5)\n    540\n    \"\"\"\n    return 180 * (n - 2)", "def interior_angle_regular_polygon(n):\n    \"\"\"\n    Calculate the measure of an interior angle of a regular n-sided polygon.\n    \n    Parameters\n    ----------\n    n : int\n        Number of sides of the regular polygon\n    \n    Returns\n    -------\n    float\n        Measure of one interior angle in degrees\n    \n    Examples\n    --------\n    >>> interior_angle_regular_polygon(4)\n    90.0\n    \n    >>> interior_angle_regular_polygon(6)\n    120.0\n    \"\"\"\n    if n < 3:\n        raise ValueError(\"A polygon must have at least 3 sides.\")\n    sum_angles = sum_of_interior_angles(n)\n    return sum_angles / n", "def polygon_interior_angle(n):\n    \"\"\"\n    Calculate the interior angle of an n-sided regular polygon.\n    \n    Parameters:\n    - n: int, number of sides of the polygon\n    \n    Returns:\n    - float, measure of the interior angle in degrees\n    \"\"\"\n    if n < 3:\n        raise ValueError(\"A polygon must have at least 3 sides.\")\n    return (n - 2) * 180 / n", "def polygon_interior_angle_sum(n):\n    \"\"\"\n    Calculate the sum of the interior angles of an n-sided polygon.\n    Parameters:\n    - n (int): Number of sides of the polygon.\n    Returns:\n    - int: Sum of the interior angles in degrees.\n    Examples:\n    >>> polygon_interior_angle_sum(4)\n    360\n    >>> polygon_interior_angle_sum(6)\n    720\n    \"\"\"\n    if n < 3:\n        raise ValueError(\"A polygon must have at least 3 sides.\")\n    return (n - 2) * 180", "def calculate_interior_angle(n_sides):\n    \"\"\"\n    Calculate the measure of each interior angle in a regular polygon.\n    Parameters\n    ----------\n    n_sides: int\n        The number of sides in the polygon.\n    Returns\n    -------\n    float\n        The measure of each interior angle.\n    Example\n    -------\n        >>> calculate_interior_angle(4)\n        90.0\n    \"\"\"\n    return (n_sides - 2) * 180 / n_sides", "def sum_of_interior_angles(n_sides):\n    \"\"\"\n    Calculate the sum of interior angles of a polygon.\n    Parameters:\n    - n_sides (int): The number of sides (or vertices) of the polygon.\n    Returns:\n    - int: Sum of the interior angles of the polygon in degrees.\n    Examples:\n    >>> sum_of_interior_angles(4)  # For a square\n    360\n    >>> sum_of_interior_angles(6)  # For a hexagon\n    720\n    \"\"\"\n    return 180 * (n_sides - 2)", "def interior_angle_regular_polygon(n_sides):\n    \"\"\"\n    Calculate the measure of an interior angle of a regular polygon.\n    Parameters:\n    - n_sides (int): The number of sides (or vertices) of the polygon.\n    Returns:\n    - float: Measure of one interior angle in a regular polygon in degrees.\n    Examples:\n    >>> interior_angle_regular_polygon(4)  # For a square\n    90.0\n    >>> interior_angle_regular_polygon(6)  # For a hexagon\n    120.0\n    \"\"\"\n    total_interior_angles = sum_of_interior_angles(n_sides)\n    return total_interior_angles / n_sides"], ["def area_equilateral_triangle(side_length):\n    \"\"\"\n    Calculate the area of an equilateral triangle given the side length.\n    \n    Parameters:\n    - side_length: float, the length of each side of the triangle\n    \n    Returns:\n    - float, the area of the equilateral triangle\n    \"\"\"\n    return (sqrt(3) / 4) * side_length ** 2", "def calculate_equilateral_triangle_side_length(area):\n    \"\"\"\n    Calculate the side length of an equilateral triangle given its area.\n    Parameters\n    ----------\n    area: float\n        The area of the equilateral triangle.\n    Returns\n    -------\n    float\n        The side length of the triangle.\n    Example\n    -------\n        >>> calculate_equilateral_triangle_side_length(9.622)\n        5.0\n    \"\"\"\n    return math.sqrt((4 * area) /math.sqrt(3))"], ["def calculate_triangle_area(base, height):\n    \"\"\"\n    Calculate the area of a triangle.\n    Parameters\n    ----------\n    base: float\n        The length of the base.\n    height: float\n        The length of the height.\n    Returns\n    -------\n    float\n        The area of the triangle.\n    Example\n    -------\n        >>> calculate_triangle_area(10, 5)\n        25.0\n    \"\"\"\n    return 0.5 * base * height"], ["def polygon_diagonals(n):\n    \"\"\"\n    Calculate the number of diagonals in an n-sided polygon.\n    \n    Parameters:\n    - n: int, number of sides of the polygon\n    \n    Returns:\n    - int, number of diagonals\n    \"\"\"\n    if n < 3:\n        raise ValueError(\"A polygon must have at least 3 sides.\")\n    return n * (n - 3) // 2", "def calculate_n_diagonals(n_sides):\n    \"\"\"\n    Calculate the number of diagonals in a polygon.\n    Parameters\n    ----------\n    n_sides: int\n        The number of sides in the polygon.\n    Returns\n    -------\n    int\n        The number of diagonals in the polygon.\n    Example\n    -------\n        >>> calculate_n_diagonals(5)\n        5\n    \"\"\"\n    return n_sides * (n_sides - 3) // 2"], ["def polygon_perimeter(n, side_length):\n    \"\"\"\n    Calculate the perimeter of a regular n-sided polygon.\n    \n    Parameters:\n    - n: int, number of sides of the polygon\n    - side_length: float, length of one side of the polygon\n    \n    Returns:\n    - float, perimeter of the polygon\n    \"\"\"\n    if n < 3 or side_length <= 0:\n        raise ValueError(\"Invalid number of sides or side length.\")\n    return n * side_length", "def calculate_perimeter(n_sides, side_length):\n    \"\"\"\n    Calculate the perimeter of a regular polygon.\n    Parameters\n    ----------\n    n_sides: int\n        The number of sides in the polygon.\n    side_length: float\n        The length of each side.\n    Returns\n    -------\n    float\n        The perimeter of the polygon.\n    Example\n    -------\n        >>> calculate_perimeter(5, 10)\n        50.0\n    \"\"\"\n    return n_sides * side_length"], ["def calculate_hypotenuse(a, b):\n    \"\"\"\n    Calculate the hypotenuse of a right-angle triangle.\n    Parameters\n    ----------\n    a: float\n        The length of one leg of the triangle.\n    b: float\n        The length of the other leg of the triangle.\n    Returns\n    -------\n    float\n        The length of the hypotenuse.\n    Example\n    -------\n        >>> calculate_hypotenuse(3, 4)\n        5.0\n    \"\"\"\n    return math.sqrt(a**2 + b**2)"], ["def distance_between_points(p1, p2):\n    \"\"\"\n    Calculate the Euclidean distance between two points in the Cartesian plane.\n    Parameters\n    ----------\n    p1 : tuple of float\n        Coordinates (x, y) of the first point.\n    p2 : tuple of float\n        Coordinates (x, y) of the second point.\n    Returns\n    -------\n    float\n        Distance between the two points.\n    Examples\n    --------\n    >>> distance_between_points((1, 2), (4, 6))\n    5.0\n    \"\"\"\n    return math.sqrt((p2[0] - p1[0])**2 + (p2[1] - p1[1])**2)", "def midpoint(p1, p2):\n    \"\"\"\n    Calculate the midpoint between two points in the Cartesian plane.\n    Parameters\n    ----------\n    p1 : tuple of float\n        Coordinates (x, y) of the first point.\n    p2 : tuple of float\n        Coordinates (x, y) of the second point.\n    Returns\n    -------\n    tuple of float\n        Coordinates of the midpoint.\n    Examples\n    --------\n    >>> midpoint((1, 2), (3, 8))\n    (2.0, 5.0)\n    \"\"\"\n    return ((p1[0] + p2[0]) / 2, (p1[1] + p2[1]) / 2)"], ["def area_square(side_length):\n    \"\"\"\n    Calculate the area of a square given the side length.\n    \n    Parameters:\n    - side_length: float, the length of each side of the square\n    \n    Returns:\n    - float, the area of the square\n    \"\"\"\n    return side_length ** 2"], ["def polygon_area(n, side_length):\n    \"\"\"\n    Calculate the area of a regular n-sided polygon given the side length.\n    \n    Parameters:\n    - n: int, number of sides of the polygon\n    - side_length: float, length of one side of the polygon\n    \n    Returns:\n    - float, area of the polygon\n    \"\"\"\n    if n < 3 or side_length <= 0:\n        raise ValueError(\"Invalid number of sides or side length.\")\n    apothem = side_length / (2 * tan(pi / n))\n    return 0.5 * n * side_length * apothem"], ["def area_hexagon(side_length):\n    \"\"\"\n    Calculate the area of a regular hexagon given the side length.\n    \n    Parameters:\n    - side_length: float, the length of each side of the hexagle"], ["def polygon_exterior_angle(n):\n    \"\"\"\n    Calculate the exterior angle of an n-sided regular polygon.\n    \n    Parameters:\n    - n: int, number of sides of the polygon\n    \n    Returns:\n    - float, measure of the exterior angle in degrees\n    \"\"\"\n    if n < 3:\n        raise ValueError(\"A polygon must have at least 3 sides.\")\n    return 360 / n", "def calculate_exterior_angle(n_sides):\n    \"\"\"\n    Calculate the measure of each exterior angle in a regular polygon.\n    Parameters\n    ----------\n    n_sides: int\n        The number of sides in the polygon.\n    Returns\n    -------\n    float\n        The measure of each exterior angle.\n    Example\n    -------\n        >>> calculate_exterior_angle(4)\n        90.0\n    \"\"\"\n    return 360 / n_sides"]], "Right Triangles": [["def is_right_triangle(side1, side2, side3):\n    \"\"\"\n    Determines whether the given sides can form a right triangle.\n    Parameters:\n    side1, side2, side3 (float): The lengths of the sides of the triangle.\n    Returns:\n    bool: True if the given sides can form a right triangle, False otherwise.\n    Examples:\n    >>> is_right_triangle(3, 4, 5)\n    True\n    >>> is_right_riangle(1, 2, 3)\n    False\n    \"\"\"\n    sides = sorted([side1, side2, side3])\n    return math.isclose(sides[2]**2, sides[0]**2 + sides[1]**2)", "def is_right_triangle(sides):\n    \"\"\"\n    Checks if a triangle with given side lengths is a right triangle.\n    \n    Parameters:\n    sides (list of float): List of three side lengths of the triangle.\n    \n    Returns:\n    bool: True if the triangle is a right triangle, False otherwise.\n    \n    Examples:\n    >>> is_right_triangle([3, 4, 5])\n    True\n    >>> is_right_triangle([5, 5, 5])\n    False\n    \"\"\"\n    a, b, c = sorted(sides)  # Ensure c is the hypothenuse\n    return math.isclose(a**2 + b**2, c**2, rel_tol=1e-9)"], ["def is_right_angle(x1, y1, x2, y2, x3, y3):\n    \"\"\"\n    Determine if the angle formed by three points (x1, y1), (x2, y2), and (x3, y3) is a right angle at (x2, y2).\n    \n    Parameters:\n        x1, y1 (float): Coordinates of the first point.\n        x2, y2 (float): Coordinates of the second point (vertex of the potential right angle).\n        x3, y3 (float): Coordinates of the third point.\n        \n    Returns:\n        bool: True if the angle at (x2, y2) is a right angle, otherwise False.\n    Examples:\n        >>> is_right_angle(0, 0, 1, 0, 1, 1)\n        True\n    \"\"\"\n    # Vectors from (x2, y2) to (x1, y1) and (x3, y3)\n    v1 = np.array([x1 - x2, y1 - y2])\n    v2 = np.array([x3 - x2, y3 - y2])\n    \n    # Dot product and magnitudes of vectors\n    dot = np.dot(v1, v2)\n    mag1 = np.linalg.norm(v1)\n    mag2 = np.linalg.norm(v2)\n    \n    # Check for perpendicular vectors\n    return np.isclose(dot, 0) and mag1 > 0 and mag2 > 0", "def is_right_triangle(x1, y1, x2, y2, x3, y3):\n    \"\"\"\n    Determines if the points (x1, y1), (x2, y2), (x3, y3) form a right triangle in a 2D plane.\n    \n    Parameters:\n    - x1, y1 (float): Coordinates of the first point.\n    - x2, y2 (float): Coordinates of the second point.\n    - x3, y3 (float): Coordinates of the third point.\n    \n    Returns:\n    - bool: True if the points form a right triangle, False otherwise.\n    \n    Examples:\n    - is_right_triangle(0, 0, 3, 0, 0, 4) -> True\n    - is_right_triangle(1, 1, 1, 5, 1, 9) -> False\n    \"\"\"\n    def distance_sq(xa, ya, xb, yb):\n        return (xb - xa) ** 2 + (yb - ya) ** 2\n    d1_sq = distance_sq(x1, y1, x2, y2)\n    d2_sq = distance_sq(x2, y2, x3, y3)\n    d3_sq = distance_sq(x3, y3, x1, y1)\n    if (d1_sq + d2_sq == d3_sq) or (d2_sq + d3_sq == d1_sq) or (d1_sq + d3_sq == d2_sq):\n        return True\n    else:\n        return False"], ["def right_triangle_missing_side(leg1=None, leg2=None, hypotenuse=None):\n    \"\"\"\n    Calculate the missing side of a right triangle using the Pythagorean theorem.\n    Parameters:\n    - leg1 (float, optional): length of the first leg. Pass None if unknown.\n    - leg2 (float, optional): length of the second leg. Pass None if unknown.\n    - hypotenuse (float, optional): length of the hypotenuse. Pass None if unknown.\n    Returns:\n    - float: The length of the missing side.\n    - None: If insufficient data is provided or incorrect data where more than one side is missing.\n    Examples:\n    >>> right_triangle_missing_side(leg1=3, leg2=4)\n    5.0\n    >>> right_triangle_missing_side(leg2=4, hypotenuse=5)\n    3.0\n    >>> right_triangle_missing_side(hypotenuse=13, leg1=12)\n    5.0\n    \"\"\"\n    if sum(x is not None for x in [leg1, leg2, hypotenuse]) < 2:\n        return None  # Not enough information to determine the missing side\n    \n    if hypotenuse is None:\n        # Calculate hypotenuse\n        return math.sqrt(leg1**2 + leg2**2)\n    elif leg1 is None:\n        # Calculate missing leg1\n        return math.sqrt(hypotenuse**2 - leg2**2)\n    elif leg2 is None:\n        # Calculate missing leg2\n        return math.sqrt(hypotenuse**2 - leg1**2)", "def pythagorean_solver(a=None, b=None, c=None):\n    \"\"\"\n    Solve for a side of a right triangle given the other two sides using the Pythagorean Theorem.\n    \n    Parameters:\n    - a (float, optional): The length of one of the legs of the triangle. Default is None.\n    - b (float, optional): The length of the other leg of the triangle. Default is None.\n    - c (float, optional): The length of the hypotenuse of the triangle. Default is None.\n    Returns:\n    - float: The length of the missing side.\n    Raises:\n    - ValueError: If less than two sides are provided or more than one unknown side is provided.\n    Examples:\n    - pythagorean_solver(a=3, b=4) returns 5.0\n    - pythagorean_solver(b=4, c=5) returns 3.0\n    - pythagorean_solver(a=3, c=5) returns 4.0\n    \"\"\"\n    # Validating input\n    sides = [a, b, c]\n    known_sides = [side for side in sides if side is not None]\n    if len(known_sides) < 2:\n        raise ValueError(\"At least two sides must be known.\")\n    if len(known_sides) > 2:\n        raise ValueError(\"Only one side should be unknown.\")\n    # Applying the Pythagorean theorem\n    if c is None:\n        # Solve for hypotenuse\n        return math.sqrt(a**2 + b**2)\n    elif a is None:\n        # Solve for leg a\n        return math.sqrt(c**2 - b**2)\n    else:\n        # Solve for leg b\n        return math.sqrt(c**2 - a**2)", "def calculate_right_triangle_side(a=None, b=None, c=None):\n    \"\"\"\n    Calculate the missing side of a right triangle using the Pythagorean Theorem.\n    \n    Parameters:\n        a (float): The length of side a, or None if it is the unknown side.\n        b (float): The length of side b, or None if it is the unknown side.\n        c (float): The length of the hypotenuse c, or None if it is the unknown side.\n    \n    Returns:\n        float: The length of the missing side.\n        \n    Examples:\n        calculate_right_triangle_side(a=3, b=4)  # Should return 5 as the hypotenuse\n        calculate_right_triangle_side(a=3, c=5)  # Should return 4 as the other side\n        calculate_right_triangle_side(b=4, c=5)  # Should return 3 as the other side\n    \"\"\"\n    import math\n    if c is None:\n        # Calculate hypotenuse\n        return math.sqrt(a ** 2 + b ** 2)\n    elif a is None:\n        # Calculate missing side a\n        return math.sqrt(c ** 2 - b ** 2)\n    elif b is None:\n        # Calculate missing side b\n        return math.sqrt(c ** 2 - a ** 2)\n    else:\n        raise ValueError(\"One and only one side length must be None.\")", "def calculate_right_triangle_sides(a=None, b=None, c=None):\n    \"\"\"\n    Calculate the lengths of the sides of a right triangle using the Pythagorean theorem.\n    \n    Given any two sides of a right triangle, this function computes the third side. \n    The sides are designated as 'a' and 'b' (legs), and 'c' (hypotenuse).\n    Parameters\n    ----------\n    a : float or None\n        The length of the first leg of the triangle, or None if unknown.\n    b : float or None\n        The length of the second leg of the triangle, or None if unknown.\n    c : float or None\n        The length of the hypotenuse of the triangle, or None if unknown.\n    Returns\n    -------\n    tuple\n        A tuple containing the lengths of the sides (a, b, c) in that order.\n    Raises\n    ------\n    ValueError\n        If less than two sides are specified,\n        or if the specified sides do not form a right triangle based on the Pythagorean theorem.\n    Examples\n    --------\n    >>> calculate_right_triangle_sides(a=3, b=4)\n    (3, 4, 5)\n    \n    >>> calculate_right_arm_ids(b=4, c=5)\n    (3.0, 4, 5)\n    >>> calculate_right_arm_ids(a=3, c=5)\n    (3, 4.0, 5)\n    \"\"\"\n    # Ensure that exactly two of the three parameters are provided.\n    inputs = [x is not None for x in [a, b, c]]\n    if sum(inputs) != 2:\n        raise ValueError(\"Exactly two sides must be specified.\")\n    \n    # Calculate the missing side based on the provided sides.\n    if a is not None and b is not None:\n        calc_c = math.sqrt(a**2 + b**2)\n        return (a, b, calc_c)\n    elif a is not None and c is not None:\n        if c <= a:\n            raise ValueError(\"Hypotenuse must be larger than any leg.\")\n        calc_b = math.sqrt(c**2 - a**2)\n        return (a, calc_b, c)\n    elif b is not None and c is not None:\n        if c <= b:\n            raise ValueError(\"Hypotenuse must be larger than any leg.\")\n        calc_a = math.sqrt(c**2 - b**2)\n        return (calc_a, b, c)\n    else:  # This case should never be reached due to input validation\n        raise RuntimeError(\"Unexpected state in calculating triangle sides.\")", "def find_missing_side(a=None, b=None, c=None):\n    \"\"\"\n    Calculate the unknown side of a right triangle using the Pythagorean theorem.\n    \n    Parameters:\n    a (float, optional): The length of one leg of the triangle (default is None).\n    b (float, optional): The length of the other leg of the triangle (default is None).\n    c (float, optional): The length of the hypotenuse of the triangle (default is None).\n    \n    Returns:\n    float: The length of the missing side.\n    Examples:\n    >>> find_missing_side(a=3, b=4)\n    5.0\n    >>> find_missing_side(b=4, c=5)\n    3.0\n    >>> find_missing_side(a=3, c=5)\n    4.0\n    \"\"\"\n    from math import sqrt\n    if c is None:  # Hypotenuse missing\n        return sqrt(a**2 + b**2)\n    elif a is None:  # One leg missing\n        return sqrt(c**2 - b**2)\n    elif b is None:  # The other leg missing\n        return sqrt(c**2 - a**2)\n    else:\n        raise ValueError(\"At least one side length must be unspecified.\")", "def pythagorean_solver(a=None, b=None, c=None):\n    \"\"\"\n    Calculates the missing side of a right triangle or checks if the given sides form a right triangle.\n    \n    Parameters:\n        a (float, optional): The length of side a.\n        b (float, optional): The length of side b.\n        c (float, optional): The length of the hypotenuse c.\n    \n    Returns:\n        float or dict: The size of the missing side if one side is provided as None. If all sides are provided,\n                       returns a dictionary with details whether it's a right triangle and by what margin it deviates.\n    \n    Examples:\n        >>> pythagorean_solver(a=3, b=4)\n        5.0\n        >>> pythagorean_solver(c=5, b=4)\n        3.0\n        >>> pythagorean_solver(a=3, b=4, c=5)\n        {'is_right_triangle': True, 'deviation': 0}\n    \"\"\"\n    # Calculate missing side if one side is None\n    if c is None and a is not None and b is not none:\n        c = sqrt(a**2 + b**2)\n        return c.evalf()\n    elif a is None and b is not None and c is not None:\n        a = sqrt(c**2 - b**2)\n        return a.evalf()\n    elif b is None and a is not None and c is not None:\n        b = sqrt(c**2 - a**2)\n        return b.evalf()\n    # Check if the given sides form a right triangle\n    if a is not None and b is not None and c is not None:\n        expected_c2 = a**2 + b**2\n        deviation = abs(c**2 - expected_c2)\n        return {'is_right_triangle': math.isclose(c**2, expected_c2), 'deviation': deviation}", "def calculate_triangle_side(a=None, b=None, c=None):\n    \"\"\"\n    Calculates the length of a missing side of a right triangle using the Pythagorean theorem.\n    \n    Parameters:\n    - a (float, optional): The length of side a (one of the two shorter sides).\n    - b (float, optional): The length of side b (one of the two shorter sides).\n    - c (float, optional): The length of the hypotenuse (the longest side).\n    \n    Returns:\n    - float: The length of the missing side.\n    \n    Raises:\n    - ValueError: If less than two sides are provided or if provided sides do not form a right triangle.\n    \n    Examples:\n    - calculate_triangle_side(a=3, b=4) -> Returns 5.0 (hypotenuse)\n    - calculate_triangle_side(a=3, c=5) -> Returns 4.0 (side b)\n    - calculate_triangle_side(b=4, c=5) -> Returns 3.0 (side a)\n    \"\"\"\n    if sum(x is not None for x in [a, b, c]) < 2:\n        raise ValueError(\"At least two sides must be provided.\")\n    \n    if c is not None:\n        # Calculate one of the legs\n        if a is None and b is not None:\n            result = math.sqrt(c**2 - b**2)\n        elif b is None and a is not None:\n        else:\n            raise ValueError(\"Only one leg should be provided when hypotenuse is given.\")\n    else:\n        # Calculate the hypotenuse\n        if a is not None and b is not None:\n            result = math.sqrt(a**2 + b**2)\n        else:\n            raise ValueError(\"Both legs must be provided when hypotenuse is missing.\")\n    if not all(x >= 0 for x in [a, b, c] if x is not None):\n        raise ValueError(f\"All sides must be non-negative.\")\n        \n    return result", "def calculate_right_triangle_side(a=None, b=None, c=None):\n    \"\"\"\n    Given two sides of a right triangle, calculate the third side using the Pythagorean theorem.\n    Parameters\n    ----------\n    a : float or None\n        The length of one leg of the triangle. If None, it will be calculated from b and c.\n    b : float or None\n        The length of the other leg of the triangle. If None, it will be calculated from a and c.\n    c : float or None\n        The length of the hypotenuse. If None, it will be calculated from a and b.\n    \n    Returns\n    -------\n    float\n        The length of the missing side.\n    \n    Raises\n    ------\n    ValueError\n        If more than one or less than two side lengths are provided as None.\n    \n    Examples\n    --------\n    >>> calculate_right_triangle_side(a=3, b=4)\n    5.0\n    >>> calculate_right_triangle_side(b=4, c=5)\n    3.0\n    >>> calculate_right_triangle_side(a=3, c=5)\n    4.0\n    \"\"\"\n    if [a, b, c].count(None) != 1:\n        raise ValueError(\"Exactly one side length must be None\")\n    \n    if c is None:  # Calculate hypotenuse\n        return math.sqrt(a**2 + b**2)\n    elif a is None:\n        return math.sqrt(c**2 - b**2)\n    else:  # b is None\n        return math.sqrt(c**2 - a**2)"], ["def calculate_area(leg1, leg2):\n    \"\"\"\n    Computes the area of a right triangle.\n    Parameters:\n    leg1 (float): Length of the first leg of the triangle.\n    leg2 (float): Length of the second leg of the triangle.\n    Returns:\n    float: The area of the right triangle.\n    Examples:\n    >>> calculate_area(3, 4)\n    6.0\n    \"\"\"\n    return 0.5 * leg1 * leg2", "def calculate_triangle_area(leg1, leg2):\n    \"\"\"\n    Calculate the area of a right-angled triangle.\n    \n    Parameters:\n    leg1 (float): The length of one leg of the triangle.\n    leg2 (float): The length of the other leg of the triangle.\n    \n    Returns:\n    float: The area of the triangle.\n    Examples:\n    >>> calculate_triangle_area(3, 4)\n    6.0\n    \"\"\"\n    return 0.5 * leg1 * leg2", "def area_of_right_triangle(leg1, leg2):\n    \"\"\"\n    Calculate the area of a right triangle given the lengths of its two legs.\n    Parameters\n    ----------\n    leg1 : float\n        The length of the first leg.\n    leg2 : float\n        The length of the second leg.\n    Returns\n    -------\n    float\n        The area of the right triangle.\n    Examples\n    --------\n    >>> area_of_right_triangle(3, 4)\n    6.0\n    \"\"\"\n    return 0.5 * leg1 * leg2"], ["def calculate_hypotenuse(leg1, leg2):\n    \"\"\"\n    Calculate the hypotenuse of a right triangle given the lengths of the other two sides.\n    Parameters:\n    leg1 (float or int): Length of the first leg of the triangle.\n    leg2 (float or int): Length of the second leg of the triangle.\n    Returns:\n    float: The length of the hypotenuse.\n    Example:\n    >>> calculate_hypotenuse(3, 4)\n    5.0\n    \"\"\"\n    return math.sqrt(leg1**2 + leg2**2)", "def hypotenuse(leg1, leg2):\n    \"\"\"\n    Calculate the hypotenuse of a right triangle given two legs.\n    \n    Parameters:\n        leg1 (float): Length of the first leg.\n        leg2 (float): Length of the second leg.\n        \n    Returns:\n        float: Length of the hypotenuse.\n    Examples:\n        >>> hypotenuse(3, 4)\n        5.0\n    \"\"\"\n    return math.sqrt(leg1**2 + leg2**2)", "def missing_leg(hypotenuse, known_leg):\n    \"\"\"\n    Calculate the missing leg of a right triangle given the hypotenuse and the other leg.\n    \n    Parameters:\n        hypotenuse (float): Length of the hypotenuse.\n        known_leg (float): Length of the known leg.\n        \n    Returns:\n        float: Length of the missing leg.\n    Examples:\n        >>> missing_leg(5, 3)\n        4.0\n    \"\"\"\n    if hypotenuse <= known_leg:\n        raise ValueError(\"Hypotenuse must be longer than any leg\")\n    return math.sqrt(hypotenuse**2 - known_leg**2)", "def calculate_hypotenuse(leg1, leg2):\n    \"\"\"\n    Calculate the length of the hypotenuse of a right triangle given the lengths of the other two sides.\n    Parameters:\n    - leg1 (float): The length of the first leg of the triangle.\n    - leg2 (float): The length of the second leg of the triangle.\n    Returns:\n    - float: The length of the hypotenuse.\n    Examples:\n    >>> calculate_hypotenuse(3, 4)\n    5.0\n    \"\"\"\n    hypotenuse = math.sqrt(leg1**2 + leg2**2)\n    return hypotenuse", "def calculate_leg(hypotenuse, leg):\n    \"\"\"\n    Calculate the length of the unknown leg of a right triangle given the hypotenuse and the other leg.\n    Parameters:\n    - hypotenuse (float): The length of the hypotenuse.\n    - leg (float): The length of the known leg.\n    Returns:\n    - float: The length of the other leg.\n    Examples:\n    >>> calculate_leg(5, 3)\n    4.0\n    \"\"\"\n    if hypotenuse <= leg:\n        raise ValueError(\"Hypotenuse must be greater than the leg.\")\n    other_leg = math.sqrt(hypotenuse**2 - leg**2)\n    return other_leg", "def calculate_hypotenuse(leg1, leg2):\n    \"\"\"\n    Computes the length of the hypotenuse of a right triangle given the lengths of the other two legs.\n    Parameters:\n    leg1 (float): Length of the first leg of the triangle.\n    leg2 (float): Length of the second leg of the triangle.\n    Returns:\n    float: The length of the hypotenuse.\n    Examples:\n    >>> calculate_hypotenuse(3, 4)\n    5.0\n    \"\"\"\n    return math.sqrt(leg1**2 + leg2**2)", "def calculate_leg(hypotenuse, known_leg):\n    \"\"\"\n    Computes the length of the unknown leg in a right triangle given the hypotenuse and the other leg.\n    Parameters:\n    hypotenuse (float): The length of the hypotenuse of the triangle.\n    known_leg (float): Length of the known leg of the triangle.\n    Returns:\n    float: The length of the unknown leg.\n    Examples:\n    >>> calculate_leg(5, 4)\n    3.0\n    \"\"\"\n    if hypoteness < known_leg:\n        raise ValueError(\"Invalid triangle dimensions. Hypotenuse must be the longest side.\")\n    return math.sqrt(hypotenuse**2 - known_leg**2)", "def calculate_hypotenuse(leg_a, leg_b):\n    \"\"\"\n    Calculate the length of the hypotenuse of a right triangle given the lengths of the other two sides.\n    Parameters:\n    - leg_a (float): length of the first leg of the triangle\n    - leg_b (float): length of the second leg of the triangle\n    Returns:\n    - float: the length of the hypotenize\n    Examples:\n    >>> calculate_hypotenuse(3, 4)\n    5.0\n    >>> calculate_hypotenuse(5, 12)\n    13.0\n    \"\"\"\n    hypotenuse = math.sqrt(leg_a**2 + leg_b**2)\n    return hypotenuse", "def calculate_hypotenuse(leg_a, leg_b):\n    \"\"\"\n    Calculate the hypotenuse of a right triangle using the lengths of the other two sides.\n    Parameters:\n    leg_a : float\n        Length of one of the legs of the right triangle.\n    leg_b : float\n        Length of the other leg of the right triangle.\n    Returns:\n    float\n        Length of the hypotenuse.\n    Examples:\n    >>> calculate_hypotenuse(3, 4)\n    5.0\n    >>> calculate_hypotenuse(5, 12)\n    13.0\n    \"\"\"\n    from math import sqrt\n    return sqrt(leg_a**2 + leg_b**2)", "def calculate_hypotenuse(leg1, leg2):\n    \"\"\"\n    Calculate the length of the hypotenuse in a right triangle given the lengths of the other two sides.\n    Parameters\n    ----------\n    leg1 : float or int\n        Length of the first leg of the right triangle.\n    leg2 : float or int\n        Length of the second leg of the right triangle.\n    Returns\n    -------\n    float\n        Length of the hypotenuse.\n    Raises\n    ------\n    ValueError\n        If any of the legs are negative, since the length of a triangle side cannot be negative.\n    Examples\n    --------\n    >>> calculate_hypotenuse(3, 4)\n    5.0\n    >>> calculate_hypotenuse(5, 12)\n    13.0\n    \"\"\"\n    if leg1 < 0 or leg2 < 0:\n        raise ValueError(\"Lengths of the triangle sides should be non-negative.\")\n    \n    return math.sqrt(leg1 ** 2 + leg2 ** 2)", "def calculate_missing_leg(hypotenuse, known_leg):\n    \"\"\"\n    Calculate the length of the missing leg of a right triangle given the hypotenuse and the other leg.\n    Parameters\n    ----------\n    hypotenuse : float or int\n        Length of the hypotenuse of the right triangle.\n    known_leg : float or int\n        Length of the known leg of the right triangle.\n    Returns\n    -------\n    float\n        Length of the missing leg.\n    Raises\n    ------\n    ValueError\n        If the known leg length is greater than the hypotenuse or if any length is negative, which violates triangle inequality and common sense in geometry.\n    Examples\n    --------\n    >>> calculate_missing_leg(5, 3)\n    4.0\n    >>> calculate_missing_leg(13, 5)\n    12.0\n    \"\"\"\n    if hypotenuse < known_leg:\n        raise ValueError(\"The hypotenuse must be the longest side in a right triangle.\")\n    if hypotenuse < 0 or known_leg < 0:\n        raise ValueError(\"Lengths of the triangle sides should be non-negative.\")\n    \n    return math.sqrt(hypotenuse ** 2 - known_leg ** 2)"], ["def is_right_triangle(vertex1, vertex2, vertex3):\n    \"\"\"\n    Determine if the triangle formed by three vertices is a right triangle using the coordinate geometry.\n    Parameters:\n    - vertex1 (tuple): The (x, y) coordinates of the first vertex.\n    - vertex2 (tuple): The (x, y) coordinates of the second vertex.\n    - vertex3 (tuple): The (x, y) coordinates of the third vertex.\n    Returns:\n    - bool: True if the triangle is a right triangle, False otherwise.\n    Examples:\n    >>> is_right_triangle((0, 0), (4, 0), (0, 3))\n    True\n    \"\"\"\n    # Compute squared lengths of each side using numpy for vector operations\n    def squared_distance(p1, p2):\n        return (p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2\n    a2 = squared_distance(vertex1, vertex2)\n    b2 = squared_distance(vertex2, vertex3)\n    c2 = squared_distance(vertex3, vertex1)\n    # Check for the Pythagorean triple in squared distances to avoid float inaccuracies\n    sides_squared = sorted([a2, b2, c2])\n    return np.isclose(sides_squared[0] + sides_squared[1], sides_squared[2])", "def is_right_triangle(ax, ay, bx, by, cx, cy):\n    \"\"\"\n    Determines if a triangle formed by three points is a right triangle using distance formula.\n    \n    Parameters:\n        ax, ay (float): Coordinates of the first vertex A.\n        bx, by (float): Coordinates of the second vertex B.\n        cx, cy (float): Coordinates of the third vertex C.\n    \n    Returns:\n        bool: True if the triangle is a right triangle, False otherwise.\n    \n    Examples:\n        >>> is_right_triangle(0, 0, 3, 0, 0, 4)\n        True\n        >>> is_right_triangle(0, 0, 2, 2, 4, 0)\n        False\n    \"\"\"\n    # Calculate squared distances between points\n    AB2 = (bx - ax)**2 + (by - ay)**2\n    AC2 = (cx - ax)**2 + (cy - ay)**2\n    BC2 = (cx - bx)**2 + (cy - by)**2\n    \n    # Check for the Pythagorean relationship between the sides\n    return (AB2 + AC2 == BC2) or (AB2 + BC2 == AC2) or (AC2 + BC2 == AB2)"], ["def is_right_triangle(sides):\n    \"\"\"\n    Determine if the given sides can form a right triangle using the Pythagorean Theorem.\n    Parameters:\n    sides (tuple or list): A tuple or list of three sides of a triangle.\n    Returns:\n    bool: True if the sides can form a right triangle, False otherwise.\n    Example:\n    >>> is_right_triangle((3, 4, 5))\n    True\n    >>> is_right_triangle((5, 5, 5))\n    False\n    \"\"\"\n    a, b, c = sorted(sides)\n    return np.isclose(a**2 + b**2, c**2)", "def is_right_triangle(a, b, c):\n    \"\"\"\n    Determine if the given sides can form a right triangle using the Pythagorean theorem.\n    \n    Parameters:\n        a (float): The length of side a.\n        b (float): The length of side b.\n        c (float): The length of the hypotenuse.\n    \n    Returns:\n        bool: True if the sides can form a right triangle, False otherwise.\n    \n    Examples:\n        is_right_triangle(3, 4, 5)  # Should return True\n        is_right_triangle(5, 5, 5)  # Should return False\n    \"\"\"\n    return abs(c**2 - (a**2 + b**2)) < 1e-6  # Checks if c² ≈ a² + b² within a tolerance", "def is_right_triangle(a, b, c):\n    \"\"\"\n    Determine whether three sides can form a right triangle using the converse of the Pythagorean theorem.\n    \n    Parameters:\n    a (float): Length of the first side.\n    b (float): Length of the second side.\n    c (float): Length of the third side, presumed hypotenuse.\n    \n    Returns:\n    bool: True if the sides can form a right triangle, False otherwise.\n    Examples:\n    >>> is_right_triangle(3, 4, 5)\n    True\n    >>> is_right_triangle(3, 4, 6)\n    False\n    \"\"\"\n    return a**2 + b**2 == c**2", "def is_right_triangle(a, b, c):\n    \"\"\"\n    Check whether the given sides form a right triangle using the Pythagorean theorem.\n    Parameters\n    ----------\n    a : float\n        The length of one leg of the triangle.\n    b : float\n        The length of the other leg of the triangle.\n    c : float\n        The length of the hypotenuse.\n    Returns\n    -------\n    bool\n        True if the sides form a right triangle, False otherwise.\n        \n    Examples\n    --------\n    >>> is_right_triangle(3, 4, 5)\n    True\n    >>> is_right_triangle(5, 12, 13)\n    True\n    >>> is_right_triangle(1, 1, 2)\n    False\n    \"\"\"\n    return math.isclose(a**2 + b**2, c**2, rel_tol=1e-9)"], ["def is_pythagorean_triple(a, b, c):\n    \"\"\"\n    Check if three numbers form a Pythagorean triple.\n    Parameters:\n    - a (float): length of the first side of the triangle.\n    - b (float): length of the second side of the triangle.\n    - c (float): length of the hypotenuse of the triangle.\n    Returns:\n    - bool: True if numbers form a Pythagorean triple, False otherwise.\n    Examples:\n    >>> is_pythagorean_triple(3, 4, 5)\n    True\n    >>> is_pythagorean_triple(5, 12, 13)\n    True\n    >>> is_pythagorean_triple(1, 1, 1)\n    False\n    \"\"\"\n    return math.isclose(a**2 + b**2, c**2)", "def is_pythagorean_triplet(a, b, c):\n    \"\"\"\n    Check if the given lengths can form a right triangle as a Pythagorean triplet.\n    Parameters:\n    - a (float): The length of one side.\n    - b (float): The length of another side.\n    - c (float): The length of the presumed hypotenuse.\n    Returns:\n    - bool: True if (a, b, c) can form a right triangle, False otherwise.\n    Examples:\n    - is_pythagorean_triplet(3, 4, 5) returns True\n    - is_pythagorean_triplet(5, 12, 13) returns True\n    - is_pythagorean_triplet(1, 1, 1) returns False\n    \"\"\"\n    # Check the Pythagorean theorem\n    return np.isclose(a**2 + b**2, c**2) or np.isclose(b**2 + c**2, a**2) or np.isclose(a**2 + c**2, b**2)", "def is_pythagorean_triple(a, b, c):\n    \"\"\"\n    Checks whether the given three numbers are a Pythagorean triple.\n    \n    Parameters:\n        a (int): The length of side a.\n        b (int): The length of side b.\n        c (int): The length of the hypotenuse c.\n    \n    Returns:\n        bool: True if (a, b, c) are Pythagorean triples, False otherwise.\n    \n    Examples:\n        >>> is_pythagorean_triple(3, 4, 5)\n        True\n        >>> is_pythagorean_triple(5, 12, 13)\n        True\n        >>> is_pythagorean_triple(1, 2, 3)\n        False\n    \"\"\"\n    return a**2 + b**2 == c**2"], ["def pythagorean_theorem(known_side1, known_side2, find='hypotenuse'):\n    \"\"\"\n    Solves for a side of a right triangle using the Pythagorean theorem.\n    \n    Parameters:\n        known_side1 (float): Length of first known side.\n        known_side2 (float): Length of second known side.\n        find (str, optional): Which side to find; choices are 'hypotenuse' or 'leg'. Default is 'hypotenuse'.\n    \n    Returns:\n        float: Length of the unknown side.\n        \n    Examples:\n        >>> pythagorean_theorem(3, 4)\n        5.0\n        >>> pythagorean_theorem(5, 4, find='leg')\n        3.0\n    \"\"\"\n    if find == 'hypotenuse':\n        return math.sqrt(known_side1**2 + known_side2**2)\n    elif find == 'leg':\n        if known_side1 > known_side2:\n            return math.sqrt(known_side1**2 - known_side2**2)\n        else:\n            return math.sqrt(known_side2**2 - known_side1**2)\n    else:\n        raise ValueError(\"Invalid option for 'find'. Choose 'hypotenuse' or 'leg'.\")"], ["def has_right_angles(ax, ay, bx, by, cx, cy, dx, dy):\n    \"\"\"\n    Checks whether a quadrilateral has right angles at every vertex based on coordinates.\n    Parameters:\n        ax, ay (float): Coordinates of the first vertex A.\n        bx, by (float): Coordinates of the second vertex B.\n        cx, cy (float): Coordinates of the third vertex C.\n        dx, dy (float): Coordinates of the fourth vertex D.\n    \n    Returns:\n        bool: True if all angles in the quadrilateral are right angles, False otherwise.\n    \n    Examples:\n        >>> has_right_angles(0, 0, 4, 0, 4, 3, 0, 3)\n        True\n        >>> has_right_angles(0, 0, 4, 0, 5, 3, 1, 3)\n        False\n    \"\"\"\n    def dot_product_zero(x1, y1, x2, y2):\n        return x1 * x2 + y1 * y2 == 0\n    # Vectors for AB, BC, CD, DA\n    ABx, ABy = bx - ax, by - ay\n    BCx, BCy = cx - bx, cy - by\n    CDx, CDy = dx - cx, dy - cy\n    DAx, DAy = ax - dx, ay - dy\n    \n    # Check right angles at B, C, D respectively using dot product\n    return (dot_product_zero(ABx, ABy, BCx, BCy) and \n            dot_product_zero(BCx, BCy, CDx, CDy) and \n            dot_product_zero(CDx, CDy, DAx, DAy))"], ["def right_triangle_solver(leg1=None, leg2=None, hypotenose=None):\n    \"\"\"\n    Solve any right triangle by determining missing side lengths.\n    Parameters:\n    leg1 (float, optional): First leg of the triangle.\n    leg2 (float, optional): Second leg of the triangle.\n    hypotenose (float, optional): Hypotenose of the triangle.\n    Returns:\n    tuple: A tuple containing the values (leg1, leg2, hypotenose).\n    Examples:\n    >>> right_triangle_solver(leg1=3, leg2=4)\n    (3, 4, 5.0)\n    >>> right_triangle_solver(leg1=3, hypotenose=5)\n    (3, 4.0, 5)\n    >>> right_triangle_solver(leg2=4, hypotenose=5)\n    (3.0, 4, 5)\n    \"\"\"\n    if hypotenose and leg1 and leg2 is None:\n        leg2 = sqrt(pow(hypotenose, 2) - pow(leg1, 2))\n        return leg1, leg2, hypotenose\n    elif hypotenose and leg2 and leg1 is None:\n        leg1 = sqrt(pow(hypotenose, 2) - pow(leg2, 2))\n        return leg1, leg2, hypotenose\n    elif leg1 and leg2 and hypotenose is None:\n        hypotenose = sqrt(pow(leg1, 2) + pow(leg2, 2))\n        return leg1, leg2, hypotenose\n    else:\n        raise ValueError(\"Two sides must be provided to solve for the third.\")"], ["def calculate_missing_side(triangle_sides):\n    \"\"\"\n    Calculate the missing side (hypotenuse or one leg) of a right triangle when the other two sides are known.\n    \n    Parameters:\n    triangle_sides (tuple or list): A tuple or list containing two known sides of the right triangle, where at least \n    one side is non-zero. The missing side should be represented as None or a non-positive value (like 0 or -1).\n    \n    Returns:\n    float: The length of the missing side.\n    Example:\n    >>> calculate_missing_side((3, 4, None))\n    5.0\n    >>> calculate_missing_side((5, None, 12))\n    13.0\n    >>> calculate_missing_side((None, 8, 15))\n    17.0\n    \"\"\"\n    sides = np.array(triangle_sides)\n    missing_index = np.where((sides <= 0) | (np.isnan(sides)))[0][0]\n    if missing_index == 0:  # Hypotenuse is missing\n        return np.sqrt(np.sum(sides[1:]**2))\n    else:  # One of the legs is missing\n        return np.sqrt(sides[0]**2 - sides[missing_index]**2)"], ["def trigonometric_ratios(leg1, leg2):\n    \"\"\"\n    Calculate the sine, cosine, and tangent ratios of a right triangle given the lengths of the legs.\n    Parameters:\n    leg1 (float or int): Length of the side opposite the angle of interest.\n    leg2 (float or int): Length of the adjacent side to the angle of interest.\n    Returns:\n    dict: Dictionary with keys 'sine', 'cosine', and 'tangent', corresponding to their trigonometric values.\n    Example:\n    >>> trigonometric_ratios(3, 4)\n    {'sine': 0.6, 'cosine': 0.8, 'tangent': 0.75}\n    \"\"\"\n    hypotenuse = calculate_hypotenuse(leg1, leg2)\n    sine = leg1 / hypotenuse\n    cosine = leg2 / hypotenuse\n    tangent = leg1 / leg2\n    return {\n        'sine': sine,\n        'cosine': cosine,\n        'tangent': tangent,\n    }", "def trigonometric_ratios(leg_a, leg_b):\n    \"\"\"\n    Calculate the sine, cosine, and tangent of the angle opposite to the first leg (leg_a) in a right triangle given its side lengths.\n    Parameters:\n    - leg_a (float): length of the first leg (opposite side to the angle)\n    - leg_ b (float): length of the second leg (adjacent side to the angle)\n    Returns:\n    - dict: a dictionary containing the sine, cosine, and tangent of the angle\n    Examples:\n    >>> trigonometric_ratios(3, 4)\n    {'sine': 0.6, 'cosine': 0.8, 'tangent': 0.75}\n    >>> trigonometric_rations(1, 1)\n    {'sine': 0.7071067811865475, 'cosine': 0.7071067811865475, 'tangent': 1.0}\n    \"\"\"\n    hypotenuse = calculate_hypotenuse(leg_a, leg_b)\n    sine = leg_a / hypotenuse\n    cosine = leg_b / hypotenuse\n    tangent = leg_a / leg_b\n    return {'sine': sine, 'cosine': cosine, 'tangent': tangent}", "def trigonometric_ratios(leg_a, leg_b):\n    \"\"\"\n    Compute the sine, cosine, and tangent of the angle opposite to the first leg (leg_a)\n    of a right triangle, using the lengths of the sides.\n    Parameters:\n    leg_a : float\n        Length of the first leg of the right triangle adjacent to the angle.\n    leg_b : float\n        Length of the second leg of the right triangle.\n    Returns:\n    tuple (float, float, float)\n        A tuple containing the sine, cosine, and tangent of the specified angle.\n    Examples:\n    >>> trigonometric_ratios(3, 4)\n    (0.6, 0.8, 0.75)\n    >>> trigonometric_ratios(5, 12)\n    (0.6, 0.8, 0.75)\n    \"\"\"\n    from math import sqrt, atan2, sin, cos\n    hypotenuse = sqrt(leg_a**2 + leg_b**2)\n    sin_theta = leg_a / hypotenuse\n    cos_theta = leg_b / hypotenuse\n    tan_theta = sin_theta / cos_theta\n    return (sin_theta, cos_theta, tan_theta)"], ["def find_missing_side(known_sides):\n    \"\"\"\n    Finds the missing side of a right triangle given the other two sides.\n    \n    Parameters:\n    known_sides (list of float or None): List of two known sides and one None indicating the missing side.\n    \n    Returns:\n    float: The missing side of the right triangle.\n    \n    Examples:\n    >>> find_missing_side([3, 4, None])\n    5.0\n    >>> find_missing_side([None, 4, 5])\n    3.0\n    \"\"\"\n    a, b, c = known_sides\n    if a is None:\n        return math.sqrt(c**2 - b**2)\n    elif b is None:\n        return math.sqrt(c**2 - a**2)\n    else:  # c is None\n        return math.sqrt(a**2 + b**2)"], ["def hypotenuse_from_leg(leg_length):\n    \"\"\"\n    Calculate the length of the hypotenuse of a 45-45-90 triangle given one leg length.\n    \n    Parameters:\n    leg_length (float): Length of one of the legs of a 45-45-90 triangle.\n    \n    Returns:\n    float: Length of the hypotenuse.\n    Example:\n    >>> hypotenuse_from_leg(1)\n    1.4142135623730951  # approximately sqrt(2)\n    \"\"\"\n    return leg_length * math.sqrt(2)", "def leg_from_hypotenuse(hypotenuse_length):\n    \"\"\"\n    Calculate the lengths of the legs of a 45-45-90 triangle given the hypotenuse length.\n    \n    Parameters:\n    hypotenuse_length (float): The length of the hypotenuse of the 45-45-90 triangle.\n    \n    Returns:\n    float: Length of one of the legs (note both legs have the same length in a 45-45-90 triangle).\n    Example:\n    >>> leg_from_hypotenuse(1.4142135623730951)\n    1.0\n    \"\"\"\n    return hypotenuse_length / math.sqrt(2)", "def hypotenuse_from_leg_length(leg_length):\n    \"\"\"\n    Calculate the length of the hypotenuse of a 45-45-90 triangle given the length of one leg.\n    Parameters:\n    leg_length (float): The length of one of the legs.\n    Returns:\n    float: The length of the hypotenuse.\n    Examples:\n    >>> hypotenuse_from_leg_length(1)\n    1.4142135623730951\n    >>> hypotenuse_from_leg_length(5)\n    7.0710678118654755\n    \"\"\"\n    return leg_length * math.sqrt(2)", "def leg_length_from_hypotenuse(hypotenuse_length):\n    \"\"\"\n    Calculate the length of each leg of a 45-45-90 triangle given the hypotenuse length.\n    Parameters:\n    hypotenuse_length (float): The length of the hypotenuse.\n    Returns:\n    float: The length of each leg of the triangle.\n    Examples:\n    >>> leg_length_from_hypotenuse(1.4142135623730951)\n    1.0\n    >>> leg_length_from_hypotenuse(7.0710678118654755)\n    5.0\n    \"\"\"\n    return hypotenuse_length / math.sqrt(2)", "def calculate_45_45_90_triangle_legs(hypotenuse=None, leg=None):\n    \"\"\"\n    Calculate the legs or hypotenuse of a 45-45-90 triangle.\n    Parameters:\n    hypotenuse (float, optional): The length of the hypotenuse of the triangle. \n                                  Specify this or the leg.\n    leg (float, optional): The common length of the legs of the triangle. \n                           Specify this or the hypotenuse.\n    Returns:\n    tuple: A tuple of the form (leg, hypotenuse) depending on what is given.\n    Examples:\n    >>> calculate_45_45_90_triangle_legs(leg=1)\n    (1, 1.4142135623730951)\n    >>> calculate_45_45_90_triangle_legs(hypotenuse=math.sqrt(2))\n    (1.0, 1.4142135623730951)\n    \"\"\"\n    if leg is not None and hypotenuse is None:\n        return leg, leg * math.sqrt(2)\n    elif hypotenuse is not None and leg is None:\n        return hypotenuse / math.sqrt(2), hypotenuse\n    else:\n        raise ValueError(\"Either hypotenuse or leg must be specified, not both or neither.\")"]], "Lines and Angles": [["def line_intersection(line1, line2):\n    \"\"\"\n    Computes the intersection point of two lines if they are not parallel.\n    Parameters:\n    line1, line2 (sympy.Expr): The equations of the lines.\n    Returns:\n    tuple: The intersection point (x, y) or None if lines are parallel.\n    \n    Example:\n    >>> l1 = sp.sympify('2*x + 3*y - 6 = 0')\n    >>> l2 = sp.sympify('x - y - 1 = 0')\n    >>> line_intersection(l1, l2)\n    (2.0, 1.0)\n    \"\"\"\n    x, y = sp.symbols('x y')\n    sol = sp.solve((line1, line2), (x, y))\n    return (sol[x], sol[y]) if sol else None", "def line_intersection(m1, b1, m2, b2):\n    \"\"\"\n    Finds the intersection point of two lines given their slopes and intercepts.\n    Parameters:\n        m1, b1 (float, float): Slope and y-intercept of the first line.\n        m2, b2 (float, float): Slope and y-intercept of the second line.\n    Returns:\n        tuple: Returns the coordinates (x, y) of the intersection point, or None if no intersection.\n    \n    Examples:\n        >>> line_intersection(1, 2, -1, 2)\n        (0.0, 2.0)\n        >>> line_intersection(1, 2, 1, 3)\n        None  # Lines are parallel and do not intersect\n    \"\"\"\n    if m1 == m2:\n        return None  # parallel lines or identical\n    else:\n        x = symbols('x')\n        equation_1 = Eq(m1 * x + b1)\n        equation_2 = Eq(m2 * x + b2)\n        solution = solve([equation_1, equation_2], (x))\n        if solution:\n            x_inter = solution[x]\n            y_inter = m1 * x_inter + b1\n            return float(x_inter), float(y_inter)\n        else:\n            return None", "def line_intersection(line1, line2):\n    \"\"\"\n    Find the point of intersection of two lines if it exists.\n    \n    Parameters:\n    line1 (tuple): Coefficients (a, b, c) representing the first line ax + by + c = 0.\n    line2 (tuple): Coefficients (a, b, c) representing the second line ax + by + c = 0.\n    \n    Returns:\n    tuple: A tuple (x, y) representing the intersection point, or None if parallel/no intersection.\n    \n    \"\"\"\n    x, y = symbols('x y')\n    a1, b1, c1 = line1\n    a2, b2, c2 = line2\n    \n    equation1 = Eq(a1*x + b1*y + c1, 0)\n    equation2 = Eq(a2*x + b2*y + c2, 0)\n    \n    result = solve((equation1, equation2), (x, y))\n    if result:\n        return result[x], result[y]\n    else:\n        return None", "def find_intersection_of_lines(line1, line2):\n    \"\"\"\n    Finds the intersection point of two lines, if they intersect.\n    \n    Parameters:\n    - line1: sympy.Eq, the equation of the first line.\n    - line2: sympy.Eq, the equation of the second line.\n    Returns:\n    - tuple or None: The (x, y) coordinates of the intersection point or None if no intersection.\n    Example:\n    >>> find_intersection_of_lines(Eq(y, 2*x + 1), Eq(y, -x + 4))\n    (1, 3)\n    \"\"\"\n    x, y = symbols('x y')\n    result = solve((line1, line2), (x, y))\n    if result:\n        return (result[x], result[y])\n    return None", "def intersection_of_lines(line1, line2):\n    \"\"\"\n    Finds the point of intersection of two lines given their equations.\n    \n    Parameters:\n    - line1 (sympy.Expr): The equation of the first line.\n    - line2 (sympy.Expr): The equation of the second line.\n    \n    Returns:\n    - tuple: A tuple representing the point of intersection (x, y), or None if the lines do not intersect.\n    \n    Example:\n    >>> line1 = create_line_equation((1, 2), (3, 4))\n    >>> line2 = create_line_equation((1, 5), (2, 3))\n    >>> print(intersection_of_lines(line1, line2))\n    (7/2, 9/2)\n    \"\"\"\n    x, y = sp.symbols('x y')\n    sol = sp.solve((line1, line2), (x, y))\n    return (sol[x], sol[y]) if sol else None"], ["def calculate_supplementary_angle(angle):\n    \"\"\"\n    Calculate the supplementary angle to the given angle (Adds up to 180 degrees).\n    Parameters:\n    angle (float): An angle in degrees.\n    Returns:\n    float: The supplementary angle.\n    Examples:\n    >>> calculate_supplementray_angle(30)\n    150.0\n    >>> calculate_supplementary_angle(90)\n    90.0\n    \"\"\"\n    return 180 - angle", "def find_supplementary_angle(angle):\n    \"\"\"\n    Given an angle, this function computes its supplementary angle.\n    \n    Parameters:\n        angle (float): Angle in degrees.\n        \n    Returns:\n        float: Supplementary angle in degrees.\n    \n    Examples:\n        >>> find_supplementary_angle(45)\n        135.0\n        >>> find_supplementary_angle(90)\n        90.0\n    \"\"\"\n    return 180.0 - angle", "def find_complementary_angle(angle):\n    \"\"\"\n    Given an angle, this function computes its complementary angle.\n    \n    Parameters:\n        angle (float): An angle in degrees.\n    \n    Returns:\n        float: The complementary angle in degrees.\n    \n    Examples:\n        >>> find_complementary_angle(30)\n        60.0\n        >>> find_complementary_angle(45)\n        45.0\n    \"\"\"\n    return 90.0 - angle"], ["def are_lines_parallel(line1, line2):\n    \"\"\"\n    Determine if two lines are parallel from their line equations.\n    Parameters:\n    line1 (tuple): Coefficients (A1, B1, C1) representing the first line.\n    line2 (tuple): Coefficients (A2, B2, C2) representing the second line.\n    \n    Returns:\n    bool: True if lines are parallel, False otherwise.\n    \n    Examples:\n    >>> are_lines_parallel((2, -3, 5), (4, -6, 10))\n    True\n    >>> are_lines_parallel((1, -2, 3), (2, -1, 4))\n    False\n    \"\"\"\n    A1, B1, _ = line1\n    A2, B2, _ = line2\n    det = A1 * B2 - A2 * B1\n    return np.isclose(det, 0)", "def are_lines_parallel(line1, line2):\n    \"\"\"\n    Checks if two lines are parallel. Lines are provided in symbolic form.\n    Parameters:\n    line1, line2 (sympy.Expr): The equations of the lines.\n    Returns:\n    bool: True if lines are parallel, False otherwise.\n    \n    Example:\n    >>> l1 = sp.sympify('2*x + 3*y - 4 = 0')\n    >>> l2 = sp.sympify('4*x + 6*y - 8 = 0')\n    >>> are_lines_parallel(l1, l2)\n    True\n    \"\"\"\n    return sp.simplify(line1) == sp.simplify(line2)"], ["def slope_from_points(p1, p2):\n    \"\"\"\n    Computes the slope of the line given two points.\n    Parameters:\n    p1 (tuple): A tuple (x1, y1) representing the first point on the line.\n    p2 (tuple): A tuple (x2, y2) representing the second point on the line.\n    Returns:\n    float: The slope of the line.\n    \n    Example:\n    >>> slope_from_points((1, 2), (3, 4))\n    1.0\n    \"\"\"\n    x1, y1 = p1\n    x2, y2 = p2\n    return (y2 - y1) / (x2 - x1)", "def calculate_slope(point1, point2):\n    \"\"\"\n    Calculate the slope of a line passing through two points.\n    Parameters:\n        point1 (tuple or list): The (x, y) coordinates of the first point.\n        point2 (tuple or list): The (x, y) coordinates of the second point.\n    Returns:\n        float: The slope of the line. Returns 'None' if the line is vertical.\n    Examples:\n        >>> calculate_slope((1, 2), (3, 8))\n        3.0\n        >>> calculate_slope((2, 4), (2, 10))\n        None  # Vertical line\n    \"\"\"\n    x1, y1 = point1\n    x2, y2 = point2\n    if x2 == x1:\n        return None  # This signifies a vertical line, where slope is undefined\n    return (y2 - y1) / (x2 - x1)", "def calculate_slope(x1, y1, x2, y2):\n    \"\"\"\n    Calculate the slope of a line given two points on the line.\n    \n    Parameters:\n        x1 (float): The x-coordinate of the first point.\n        y1 (float): The y-coordinate of the first point.\n        x2 (float): The x-coordinate of the second point.\n        y2 (float): The y-coordinate of the second point.\n    \n    Returns:\n        float: The slope of the line. Returns np.inf for vertical lines and 0 for horizontal lines.\n    \n    Examples:\n        >>> calculate_slope(1, 2, 3, 4)\n        1.0\n        >>> calculate_slope(2, 3, 2, 7)\n        inf\n    \"\"\"\n    if x1 == x2:\n        return np.inf  # Vertical line\n    return (y2 - y1) / (x2 - x1)", "def calculate_slope(point1, point2):\n    \"\"\"\n    Calculate the slope of a line segment between two points.\n    Parameters:\n        point1 (tuple): A tuple (x1, y1) representing the first point.\n        point2 (tuple): A tuple (x2, y2) representing the second point.\n    \n    Returns:\n        float: The slope of the line. Returns `None` if the line is vertical.\n    \n    Examples:\n        >>> calculate_slope((1, 2), (3, 8))\n        3.0\n        >>> calculate_slope((4, 3), (4, 7))\n        None  # Line is vertical\n    \"\"\"\n    x1, y1 = point1\n    x2, y2 = point2\n    if x2 - x1 == 0:\n        return None\n    else:\n        return (y2 - y1) / (x2 - x1)"], ["def calculate_tangent_lengths(radius, external_point_coord, circle_center_coord):\n    \"\"\"\n    Calculate the lengths of tangents from an external point to a given circle.\n    \n    Parameters:\n    radius (float): The radius of the circle.\n    external_point_coord (tuple): The x and y coordinates of the external point (P).\n    circle_center_coord (tuple): The x and y coordinates of the circle's center (O).\n    \n    Returns:\n    float: The length of the tangents from the point to the circle.\n    \n    Examples:\n    >>> calculate_tangent_lengths(5, (8, 6), (1, 1))\n    7.810249675906654\n    \"\"\"\n    dx = external_point_coord[0] - circle_center_coord[0]\n    dy = external_packet_coord[1] - circle_center_coord[1]\n    distance_PO = math.sqrt(dx**2 + dy**2)\n    # Calculate the length of the tangent using the Pythagorean theorem.\n    tangent_length = math.sqrt(distance_PO**2 - radius**2)\n    return tangent_length", "def calculate_angle_between_tangents(radius, external_point_coord, circle_center_coord):\n    \"\"\"\n    Calculate the angle between two tangents drawn from an external point to the circle.\n    \n    Parameters:\n    radius (float): The radius of the circle.\n    external_point_coord (tuple): The x and y coordinates of the external point (P).\n    circle_center_coord (tuple): The x and y coordinates of the circle's to center (O).\n    \n    Returns:\n    float: The angle between the tangents, in radians.\n    \n    Examples:\n    >>> calculate_angle_between_tangents(5, (8, 6), (1, 1))\n    1.4288992721907328\n    \"\"\"\n    dx = external_point_coord[0] - circle_center_coord[0]\n    dy = external_point_coord[1] - circle_center_coord[1]\n    distance_PO = math.sqrt(dx**2 + dy**2)\n    # Trigonometric calculation for angle using tangent properties and theorem.\n    tangent_angle = math.asin(radius / distance_PO)\n    return 2 * tangent_angle   # angle between the two tangents", "def tangent_length_to_circle(point, center, radius):\n    \"\"\"\n    Calculate the length of a tangent from a point to a circle.\n    Parameters:\n    point (tuple): The (x, y) coordinates of the point outside the circle.\n    center (tuple): The (x, y) coordinates of the circle's center.\n    radius (float): The radius of the circle.\n    Returns:\n    float: The length of the tangent from the point to the circle.\n    Example:\n    >>> tangent_length_to_circle((4, 6), (1, 1), 2)\n    Approx. 4.83\n    \"\"\"\n    distance_to_center = segment_length(point, center)\n    tangent_length = math.sqrt(distance_to_center**2 - radius**2)\n    return tangent_length", "def find_tangents_from_point_to_circle(external_point, circle_center, circle_radius):\n    \"\"\"\n    Calculate tangent points and tangent lines from an external point to a circle.\n    Parameters\n    ----------\n    external_point : tuple\n        (x, y) coordinates of the external point.\n    circle_center : tuple\n        (x, y) coordinates of the circle's center.\n    circle_radius : float\n        Radius of the circle.\n    Returns\n    -------\n    list\n        Returns a list containing information about the two tangents:\n        Each element in the list is a dictionary with 'point': (x, y) of tangency, 'line_equation': sympy Eq of the line\n    Examples\n    --------\n    >>> tangents = find_tangents_from_point_to_circle((1, 2), (0, 0), 1)\n    >>> for tan in tangents:\n    ...     print(f\"Point of tangency: {tan['point']}, Line equation: {tan['line_equation']}\")\n    \n    \"\"\"\n    # Converting into SymPy Point objects\n    external_pt = Point(*external_point)\n    ctr = Point(*circle_center)\n    \n    # Creating a SymPy Circle object\n    circ = circle.Circle(ctr, circle_radius)\n    \n    # Computing tangents\n    tangents = circ.tangent_lines(external_pt)\n    \n    result = []\n    for t_line in tangents:\n        pt_of_tangency = t_line.intersection(circ)[0]\n        result.append({'point': (pt_of_tangency.x, pt_of_tangency.y), 'line_equation': t_line.equation()})\n        \n    return result"], ["def calculate_angle(angle_info, known_angles):\n    \"\"\"\n    Calculate an unknown angle based on properties of parallel lines and known angles.\n    This function uses properties like corresponding angles, supplementary angles (angles summing up to 180 degrees),\n    and alternate interior angles to determine the value of an unspecified angle.\n    Parameters:\n    - angle_info (str): Specifies the type of angle relationship. Accepts 'corresponding', 'supplementary', 'alternate_interior'.\n    - known_angles (dict): A dictionary with keys as angle names and values as their measures in degrees. Some values might be sympy symbols.\n    Returns:\n    - float or sympy.Expr: The calculated angle if computable, otherwise returns a symbolic expression.\n    \n    Examples:\n    - calculate_angle('supplementary', {'angle1': 90}) returns 90 (since supplementary angles sum up to 180 degrees).\n    - calculate_angle('corresponding', {'angle1': 60}) returns 60 (corresponding angles are equal).\n    - calculate_angle('alternate_interior', {'angle1': 80}) returns 80 (alternate interior angles are equal in parallel lines).\n    \"\"\"\n    angle1 = known_angles.get('angle1', sp.Symbol('angle1'))\n    if angle_info == 'supplementary':\n        return 180 - angle1\n    elif angle_info in ['corresponding', 'alternate_interior']:\n        return angle1\n    else:\n        raise ValueError(\"Invalid angle information provided.\")", "def calculate_unknown_angle(angle_type, *angles):\n    \"\"\"\n    Calculate an unknown angle based on common geometric rules about angles.\n    Parameters:\n    - angle_type (str): Type of scenario for angle calculation. Options include 'linear_pair', \n                        'triangle_sum', 'around_point', or 'supplementary'.\n    - angles (tuple of sp.Expr): Known angles involved in the calculation.\n    Returns:\n    - sp.Expr: The unknown angle or a symbolic expression if the input includes symbols.\n    Examples:\n    - calculate_unknown_angle('linear_pair', 70) should return 110 (since linear pair sums to 180°).\n    - calculate_unknown_line_angle('triangle_sum', 45, 90) should return 45 (since the sum of triangle angles is 180°).\n    - calculate_unknown_line_angle('around_point', 90, 180, 45) should return 45.\n    \"\"\"\n    if angle_type == 'linear_pair':\n        return 180 - sp.sum(*angles)\n    elif angle_type == 'triangle_sum':\n        return 180 - sp.sum(*angles)\n    elif angle_type == 'around_point':\n        return 360 - sp.sum(*angles)\n    elif angle_copy == 'supplementary':\n        return 180 - sp.sum(*angles)\n    else:\n        raise ValueError(\"Unsupported angle type provided.\")"], ["def line_equation(point1, point2):\n    \"\"\"\n    Return the coefficients of the line equation in the form Ax + By = C using two points.\n    Parameters:\n    point1 (tuple): (x1, y1) coordinates of the first point.\n    point2 (tuple): (x2, y2) coordinates of the second point.\n    \n    Returns:\n    tuple: Coefficients (A, B, C) representing the line Ax + By = C.\n    \n    Examples:\n    >>> line_equation((1, 2), (3, 4))\n    (2, -2, 0)\n    \"\"\"\n    x1, y1 = point1\n    x2, y2 = point2\n    A = y2 - y1\n    B = x1 - x2\n    C = A*x1 + B*y1\n    return (A, -B, C)", "def line_equation_from_points(p1, p2):\n    \"\"\"\n    Computes the equation of the line in the form `Ax + By + C = 0` given two points.\n    Parameters:\n    p1 (tuple): A tuple (x1, y1) representing the first point on the line.\n    p2 (tuple): A tuple (x2, y2) representing the second point on the line.\n    Returns:\n    sympy.Expr: The equation of the line formatted as `Ax + By + C = 0`.\n    \n    Example:\n    >>> line_equation_from_points((1, 2), (3, 4))\n    -2*x + 2*y - 2 = 0\n    \"\"\"\n    x, y = sp.symbols('x y')\n    x1, y1 = p1\n    x2, y2 = p2\n    slope = (y2 - y1) / (x2 - x1)\n    intercept = y1 - slope * x1\n    return sp.simplify(y - (slope * x + intercept)).as_expr() == 0", "def line_equation(point1, point2):\n    \"\"\"\n    Compute the equation of a line in the form y = mx + c given two points.\n    Parameters:\n    - point1 (tuple): The first point (x1, y1).\n    - point2 (tuple): The second point (x2, y2).\n    Returns:\n    - tuple: A tuple (m, c) representing the slope (m) and y-intercept (c) of the line.\n    Examples:\n    >>> line_equation((1, 2), (3, 4))\n    (1.0, 1.0)\n    >>> line_equation((1, 1), (3, 5))\n    (2.0, -1.0)\n    \"\"\"\n    x1, y1 = point1\n    x2, y2 = point2\n    if x1 == x2:\n        raise ValueError(\"The two points must have different x coordinates to form a defined line.\")\n    m = (y2 - y1) / (x2 - x1)\n    c = y1 - m * x1\n    return (m, c)", "def calculate_line_equation(point1, point2=None, slope=None):\n    \"\"\"\n    Calculate the line equation given two points or a point and a slope.\n    \n    Parameters:\n    - point1: tuple, the coordinates (x1, y1) of the first point on the line.\n    - point2: tuple or None, the coordinates (x2, y2) of the second point on the line, if available.\n    - slope: float or None, the slope of the line, if available.\n    Returns:\n    - sympy.Eq: The equation of the line in the form of y = mx + c.\n    Example:\n    >>> calculate_line_equation((1, 2), (3, 4))\n    Eq(y, 1*x + 1)\n    \"\"\"\n    x, y = symbols('x y')\n    if point2 and slope is None:\n        x1, y1 = point1\n        x2, y2 = point2\n        slope = (y2 - y1) / (x2 - x1)\n        intercept = simplify(y1 - slope*x1)\n        return Eq(y, slope*x + intercept)\n    elif slope is not None and point2 is None:\n        x1, y1 = point1\n        intercept = simplify(y1 - slope*x1)\n        return Eq(y, slope*x + intercept)\n    else:\n        raise ValueError(\"Either provide a second point or a slope, not both or neither.\")", "def create_line_equation(point1, point2):\n    \"\"\"\n    Creates the equation of a line in the format Ax + By + C = 0 given two points on the line.\n    Parameters:\n    - point1 (tuple): A tuple (x1, y1) representing the first point on the line.\n    - point2 (tuple): A tuple (x2, y2) representing the second point on the line.\n    \n    Returns:\n    - sympy.Expr: The expression representing the line equation in the form `Ax + By + C`.\n    \n    Example:\n    >>> line_eq = create_line_equation((1, 2), (3, 4))\n    >>> print(line_eq)\n    -2*x + 2*y\n    \"\"\"\n    x, y = sp.symbols('x y')\n    x1, y1 = point1\n    x2, y2 = point2\n    # Calculate the coefficients of the line equation (y2 - y1)x + (x1 - x2)y + (x2*y1 - x1*y2) = 0\n    A = y2 - y1\n    B = x1 - x2\n    C = x2*y1 - x1*y2\n    line_expr = A*x + B*y + C\n    return sp.simplify(line_expr)", "def equation_of_line_from_two_points(point1, point2):\n    \"\"\"\n    Calculates the equation of a line given two points.\n    \n    Parameters:\n        point1 : tuple of two floats or sympy.Expr\n            Coordinates of the first point (x1, y1).\n        point2 : tuple of two floats or sympy.Expr\n            Coordinates of the second point (x2, y2).\n    Returns:\n        sympy.Eq\n            The equation of the line in the form of y = mx + c.\n    Examples:\n        >>> equation_of_line_from_two_points((1, 2), (3, 8))\n        Eq(y, 3*x - 1)\n        >>> equation_of_line_from_two_points((sp.Symbol('x1'), sp.Symbol('y1')), (sp.Symbol('x2'), sp.Symbol('y2')))\n        Eq(-x1*y2 + x2*y1 + x*y1 - x*y2 - x1*y + x2*y, 0)\n    \"\"\"\n    x1, y1 = point1\n    x2, y2 = point2\n    x, y = sp.symbols('x y')\n    slope = (y2 - y1) / (x2 - x1)\n    intercept = y1 - slope * x1\n    line_eq = sp.Eq(y, slope * x + intercept)\n    return line_eq.simplify()"], ["def vertical_angles(angle):\n    \"\"\"\n    Given one of the vertical angles, returns the other based on the property that vertical angles are equal.\n    Parameters:\n        angle (float): An angle in degrees representing one of the vertical angles.\n    Returns:\n        float: Returns the equal vertical angle in degrees.\n    Examples:\n        >>> vertical_angles(45)\n        45.0\n        >>> vertical_angles(120)\n        120.0\n    \"\"\"\n    return angle", "def vertical_angles(angle):\n    \"\"\"\n    Assuming the angle provided is one of the adjacent angles formed by two intersecting lines,\n    this function returns the magnitude of the vertical angle, which is equal to the given angle.\n    Parameters:\n        angle (float): The magnitude of one of the vertical angles in degrees.\n    Returns:\n        float: Returns the magnitude of the vertical angle opposite to the provided angle.\n    \n    Examples:\n        >>> vertical_angles(45)\n        45\n        >>> vertical_angles(30)\n        30\n    \"\"\"\n    return angle  # Vertical angles are congruent (i.e., they are equal)."], ["def calculate_distance(x1, y1, x2, y2):\n    \"\"\"\n    Calculate the Euclidean distance between two points in the 2D coordinate plane.\n    Parameters:\n    x1, y1 (float): Coordinates of the first point.\n    x2, y2 (float): Coordinates of the second point.\n    Returns:\n    float: The distance between the two points.\n    Examples:\n    >>> calculate_distance(0, 0, 3, 4)\n    5.0\n    \"\"\"\n    return math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2)", "def compute_distance(point1, point2):\n    \"\"\"\n    Computes the Euclidean distance between two points in a 2D space.\n    \n    Parameters:\n    - point1 (tuple): The first point (x1, y1).\n    - point2 (tuple): The second bottle (x2, y2).\n    \n    Returns:\n    - float: The Euclidean distance between point1 and point2.\n    \n    Example:\n    >>> compute_distance((0, 0), (3, 4))\n    5.0\n    >>> compute_distance((1, 2), (1, 2))\n    0.0\n    \"\"\"\n    return sqrt((point2[0] - point1[0])**2 + (point2[1] - point1[1])**2)", "def distance_between_points(p1, p2):\n    \"\"\"\n    Calculate the Euclidean distance between two points in the coordinate plane.\n    Parameters:\n    - p1 (tuple): The coordinates (x1, y1) of the first point.\n    - p2 (tuple): The coordinates (x2, y2) of the second point.\n    Returns:\n    - float: The Euclidean distance between the two points.\n    Examples:\n    - distance_between_points((1, 2), (4, 6)) will return approximately 5.0.\n    \"\"\"\n    x1, y1 = p1\n    x2, y2 = p2\n    return sp.sqrt((x2 - x1)**2 + (y2 - y1)**2)", "def calculate_distance(point1, point2):\n    \"\"\"\n    Computes the Euclidean distance between two points.\n    Parameters:\n        point1 (tuple): The (x, y) coordinate of the first point.\n        point2 (tuple): The (x, y) coordinate of the second point.\n    Returns:\n       float: The Euclidean distance between the two points.\n    Example:\n        >>> calculate_distance((0, 0), (3, 4))\n        5.0\n    \"\"\"\n    return math.sqrt((point2[0] - point1[0]) ** 2 + (point2[1] - point1[1]) ** 2)"], ["def is_supplementary(angle1, angle2):\n    \"\"\"\n    Determine if two angles are supplementary.\n    Parameters:\n    angle1 (float): First angle in degrees.\n    angle2 (float): Second angle in degrees.\n    \n    Returns:\n    bool: True if angles are supplementary, False otherwise.\n    \n    Examples:\n    >>> is_supplementary(130, 50)\n    True\n    >>> is_supplementary(45, 45)\n    False\n    \"\"\"\n    return np.isclose(angle1 + angle2, 180)", "def are_supplementary(angle1, angle2):\n    \"\"\"\n    Checks if two angles are supplementary (their sum equals 180 degrees).\n    \n    Parameters:\n        angle1 (float): First angle in degrees.\n        angle2 (float): Second angle in degrees.\n    \n    Returns:\n        bool: True if the angles are supplementary, otherwise False.\n    \n    Examples:\n        >>> are_supplementary(130, 50)\n        True\n        >>> are_supplementary(90, 95)\n        False\n    \"\"\"\n    return np.isclose(angle1 + angle2, 180.0)", "def are_complementary(angle1, angle2):\n    \"\"\"\n    Checks if two angles are complementary (their sum equals 90 degrees).\n    \n    Parameters:\n        angle1 (float): First angle in degrees.\n        angle2 (float): Second angle in degrees.\n    \n    Returns:\n        bool: True if the angles are complementary, otherwise False.\n    \n    Examples:\n        >>> are_complementary(45, 45)\n        True\n        >>> are_complementary(30, 70)\n        False\n    \"\"\"\n    return np.isclose(angle1 + angle2, 90.0)", "def check_angle_relation(angle1, angle2, relation_type='supplementary'):\n    \"\"\"\n    Check whether the two provided angles are supplementary or complementary.\n    Parameters:\n    angle1 (float): The first angle in degrees.\n    angle2 (float): The second angle in degrees.\n    relation_type (str): Type of angle relation, 'supplementary' or 'complementary'.\n    Returns:\n    bool: True if the angles meet the condition, False otherwise.\n    Example:\n    >>> check_angle_relation(150, 30, 'supplementary')\n    True\n    >>> check_angle_relation(45, 45, 'complementary')\n    True\n    \"\"\"\n    if relation_type == 'supplementary':\n        return abs(angle1 + angle2 - 180) < 1e-5\n    elif relation_type == 'complementary':\n        return abs(angle1 + angle2 - 90) < 1e-5\n    else:\n        raise ValueError(\"relation_type must be 'supplementary' or 'complementary'\")", "def angle_relationship(angle1, angle2):\n    \"\"\"\n    Determine the relationship between two angles - complementarity or supplementarity.\n    Parameters:\n    angle1 (float): The first angle in degrees.\n    angle2 (float): The second angle in degrees.\n    Returns:\n    str: 'Complementary' if both angles sum to 90 degrees, 'Supplementary' if they sum to 180 degrees, otherwise 'None'.\n    Example:\n    >>> angle_relationship(45, 45)\n    'Complementary'\n    >>> angle_relationship(90, 90)\n    'Supplementary'\n    \"\"\"\n    sum_angles = angle1 + angle2\n    if np.isclose(sum_angles, 90):\n        return 'Complementary'\n    elif np.isclose(sum_angles, 180):\n        return 'Supplementary'\n    else:\n        return None"], ["def calculate_triangle_angles(angle_a=None, angle_b=None, angle_c=None):\n    \"\"\"\n    Calculate the missing angles in a triangle given any two angles.\n    Parameters:\n        angle_a (float or None): The first angle of the triangle in degrees.\n        angle_b (float or None): The second angle of the triangle in degrees.\n        angle_c (float or None): The third angle of the triangle in degrees.\n        \n    Returns:\n        tuple: A tuple containing the three angles of the triangle in degrees.\n    Examples:\n        >>> calculate_triangle_angles(angle_a=50, angle_b=60)\n        (50, 60, 70)\n        >>> calculate_triangle_angles(angle_a=90, angle_c=45)\n        (90, 45, 45)\n    \"\"\"\n    # The sum of angles in a triangle is always 180 degrees.\n    if angle_a is not None and angle_b is not None:\n        angle_c = 180 - angle_a - angle_b\n    elif angle_a is not None and angle_c is not None:\n        angle_b = 180 - angle_a - angle_c\n    elif angle_b is not None and angle_c is not None:\n        angle_a = 180 - angle_b - angle_c\n    else:\n        raise ValueError(\"At least two angles must be provided.\")\n    \n    return (angle_a, angle_b, angle_c)", "def triangle_angle_solver(angle1, angle2=None, angle3=None):\n    \"\"\"\n    Calculates the missing angles in a triangle given at least one known angle.\n    \n    Parameters:\n    angle1: float or None\n        The degree of the first angle. If set to None, it's considered unknown.\n    angle2: float or None\n        The degree of the second angle. If None, calculated from other angles.\n    angle3: float or None\n        The degree of the third angle. If None, calculated from other angles.\n    \n    Returns:\n    tuple\n        A tuple (a1, a2, a3) representing the angles of the triangle.\n        \n    Examples:\n    >>> triangle_angle_solver(90, 30)\n    (90, 30, 60)\n    >>> triangle_angle_solver(45, 45)\n    (45, 45, 90)\n    \"\"\"\n    if angle1 is not None and angle2 is not None:\n        angle3 = 180 - angle1 - angle2\n    elif angle1 is not None and angle3 is not None:\n        angle2 = 180 - angle1 - angle3\n    elif angle2 is not None and angle3 is not None:\n        angle1 = 180 - angle2 - angle3\n    else:\n        raise ValueError(\"At least two angles must be provided\")\n      \n    return angle1, angle2, angle3"], ["def calculate_angle_relations(parallel, transversal, known_angle, angle_type):\n    \"\"\"\n    Calculate angles such as corresponding, supplementary, or alternate when dealing\n    with two lines and a transversal, focusing on situations where lines might be parallel.\n    \n    Parameters:\n        parallel (bool): A flag indicating whether the two lines are parallel.\n        transversal (bool): A flag indicating if there is a transversal intersecting the two lines.\n        known_angle (int or float): A known angle measurement in degrees.\n        angle_type (str): A descriptive type of the angle relation to compute:\n                          'corresponding', 'supplementary', or 'alternate'.\n    Returns:\n        float: The calculated angle in degrees based upon the type and parallelism.\n    Examples:\n        >>> calculate_angle_relations(True, True, 30, 'corresponding')\n        30\n        >>> calculate_angle_relations(True, True, 150, 'supplementary')\n        30\n        >>> calculate_angle_relations(True, True, 60, 'alternate')\n        60\n    \"\"\"\n    from math import fmod\n    if not transversal:\n        return \"No transversal line present!\"\n    if parallel:\n        if angle_type == 'corresponding' or angle_type == 'alternate':\n            return known_angle\n        elif angle_type == 'supplementary':\n            return 180 - known_angle\n    else:\n        if angle_type == 'corresponding':\n            # Non-parallel lines can have non-equal corresponding angles, dependent on geometry.\n            return None\n        elif angle_type == 'alternate':\n            # Still equal if the lines aren't intersected by a curve or such.\n            return known_angle\n        elif angle_type == 'supplementary':\n            return 180 - known_angle\n    return None", "def compute_angles_from_parallel_lines(transversal_angles):\n    \"\"\"\n    Given a list of angles formed by a transversal with parallel lines,\n    computes corresponding and supplementary angles.\n    Parameters:\n    - transversal_angles (list of float): angles in degrees where two parallel lines are intersected by a transversal\n    Returns:\n    - dict: A dictionary containing:\n        'corresponding_angles' (list of float): angles that are the same across parallel lines\n        'supplementary_angles' (list of float): angles that add up to 180 degrees due to the line pair\n    Example:\n    >>> compute_angles_from_parallel_lines([40, 40, 100, 100])\n    {'corresponding_angles': [40, 40, 100, 100], 'supplementary_angles': [140, 140, 80, 80]}\n    \"\"\"\n    corresponding_angles = transversal_angles[:]\n    supplementary_angles = [180 - angle for angle in transversal_angles]\n    return {\n        'corresponding_angles': corresponding_angles,\n        'supplementary_angles': supplementary_angles\n    }"], ["def is_on_straight_line(points):\n    \"\"\"\n    Determine if all given points lie on a straight line where the sum of the x and y coordinates is constant.\n    Parameters:\n    - points (list of tuples): A list where each tuple represents the coordinates of a point (x, y).\n    Returns:\n    - bool: True if all points lie on the same line of the form x + y = constant, False otherwise.\n    - float or None: The constant sum if the points lie on a straight line, otherwise None.\n    Examples:\n    >>> is_on_straight_line([(1, 2), (2, 3), (3, 4)])\n    (True, 3)\n    >>> is_on_straight98_line([(1, 2), (3, 5), (4, 1)])\n    (False, None)\n    \"\"\"\n    from sympy import Eq, solve, symbols\n    \n    if len(points) < 2:\n        return False, None\n    x, y = symbols('x y')\n    first_point = points[0]\n    expected_sum = sum(first_cordinate for first_cordinate in first_point)\n    for point in points[1:]:\n        if sum(point) != expected_sum:\n            return False, None\n            \n    return True, expected_sum", "def line_equation_from_points(points):\n    \"\"\"\n    Given points that lie on a line of the form x + y = constant, return the equation of the line.\n    Parameters:\n    - points (list of tuples): A list where each tuple represents the coordinates of a point (x, y).\n    Returns:\n    - str: The equation of the line as a string 'x + y = c' if valid, otherwise returns 'Invalid input'.\n    Examples:\n    >>> line_equation_from_points([(1, 2), (2, 3), (3, 4)])\n    'x + y = 3'\n    >>> line_equation_from_points([(1, 2), (3, 5)])\n    'x + y = 3'\n    \"\"\"\n    is_line, constant = is_on_straight_line(points)\n    if is_line:\n        return f\"x + y = {constant}\"\n    else:\n        return \"Invalid input\"", "def points_on_constant_sum_line(points, constant):\n    \"\"\"\n    Test if a list of given points lie on the line described by x + y = constant.\n    Parameters:\n    - points (list of tuples): A list of points where each point is represented as a tuple (x, y).\n    - constant (float): The constant sum in the equation x + y = constant.\n    Returns:\n    - bool: True if all points lie on the line, False otherwise.\n    Examples:\n    >>> points_on_constant_sum_line([(1, 2), (2, 2), (3, 0)], 3)\n    True\n    >>> points_on_constant_sum_line([(1, 2), (2, 3), (3, 0)], 4)\n    False\n    \"\"\"\n    return all(x + y == constant for x, y in points)"], ["def check_vertical_angles(angle1, angle2):\n    \"\"\"\n    Checks if two given angles are vertical angles. Vertical angles are always congruent.\n    \n    Parameters:\n        angle1 (float or int): The measure of the first angle in degrees.\n        angle2 (float or int): The measure of the second angle in degrees.\n        \n    Returns:\n        bool: True if the angles are congruent (equal), False otherwise.\n    \n    Examples:\n        >>> check_vertical_angles(45, 45)\n        True\n        >>> check_vertical_angles(130, 130)\n        True\n        >>> check_vertical_angles(110, 120)\n        False\n    \"\"\"\n    return angle1 == angle2"], ["def are_collinear(points):\n    \"\"\"\n    Determine if given points are collinear.\n    Parameters:\n    - points (array-like): A list of tuples/lists where each tuple/list represents the coordinates of a point, e.g., [(x1, y1), (x2, y2), ...].\n    Returns:\n    - bool: True if all the given points are collinear, False otherwise.\n    Examples:\n    >>> are_collinear([(1, 2), (2, 4), (3, 6)])\n    True\n    >>> are_collinear([(1, 1), (2, 2), (3, 4)])\n    False\n    \"\"\"\n    if len(points) < 3:\n        return True  # Less than 3 points are always collinear\n    # Convert points into a numpy array for easier manipulation\n    points = np.array(points)\n    x_coords, y_coords = points[:, 0], points[:, 1]\n    # Calculate vectors between pairs of points\n    x_differences = np.diff(x_coords)\n    y_differences = np.diff(y_coords)\n    # Check ratios of differences of consecutive points. If these ratios\n    # are not consistent, points are not collinear.\n    ratios = np.where(x_differences != 0, y_differences / x_differences, np.inf)\n    return np.all(ratios[0] == ratios)", "def check_collinearity(points):\n    \"\"\"\n    Determines if a set of points are collinear on a two-dimensional plane.\n    \n    Parameters:\n    - points (numpy array): An Nx2 numpy array where each row represents a point (x, y).\n    \n    Returns:\n    - bool: True if all the given points are collinear, False otherwise.\n    Example:\n    >>> check_collinearity(np.array([[1, 2], [2, 3], [3, 4]]))\n    True\n    >>> check_collinearity(np.array([[1, 2], [2, 4], [3, 6]]))\n    False\n    \"\"\"\n    if len(points) < 3:\n        return True # Any two points are collinear by default as the line between them defines a line\n    # Extracting points into x and y coordinates.\n    x_coords, y_coords = points[:, 0], points[:, 1]\n    \n    # Use the area of triangle formula to determine collinearity\n    for i in range(1, len(points) - 1):\n        area = 0.5 * np.linalg.det([\n            [x_coords[i-1], y_coords[i-1], 1],\n            [x_coords[i], y_coords[i], 1],\n            [x_coords[i+1], y_coords[i+1], 1]\n        ])\n        if not np.isclose(area, 0):\n            return False\n    return True", "def check_collinearity(points):\n    \"\"\"\n    Determine if the list of points are collinear.\n    Parameters:\n        points (list of tuples): A list of tuples where each tuple represents coordinates (x, y).\n    Returns:\n        bool: Returns True if all points are collinear, otherwise False.\n    Example:\n        >>> check_collinearity([(0,0), (1,1), (2,2)])\n        True\n        >>> check_collinearity([(0,0), (1,1), (1,2)])\n        False\n    \"\"\"\n    if len(points) < 3:\n        return True\n    x0, y0 = points[0]\n    x1, y1 = points[1]\n    vectors = [(x - x0, y - y0) for x, y in points[1:]]\n    x_diff, y_diff = x1 - x0, y1 - y0\n    return all(x * y_diff == y * x_diff for x, y in vectors)"], ["def line_circle_intersection(line, circle_center, circle_radius):\n    \"\"\"\n    Calculate the intersection points of a line and a circle.\n    \n    Parameters:\n    line (tuple): Coefficients (a, b, c) representing the line ax + by + c = 0.\n    circle_center (tuple): Coordinates (x, y) of the circle center.\n    circle_radius (float): Radius of the circle.\n    \n    Returns:\n    list: List of tuples representing the points of intersection.\n    \n    \"\"\"\n    x, y = symbols('x y')\n    a, b, c = line\n    h, k = circle_center\n    r = circle_radius\n    \n    line_eq = Eq(a*x + b*y + c, 0)\n    circle_eq = Eq((x - h)**2 + (y - k)**2 - r**2, 0)\n    \n    result = solve((line_eq, circle_eq), (x, y))\n    return [(sol[x], sol[y]) for sol in result]", "def find_line_circle_intersection(line_eq, circle_center, circle_radius):\n    \"\"\"\n    Determines the points of intersection (if any) between a line and a circle.\n    \n    Parameters:\n    - line_eq: sympy.Eq, equation of the line.\n    - circle_center: tuple, the (x, y) coordinates of the circle's center.\n    - circle_radius: float, the radius of the circle.\n    \n    Returns:\n    - list: A list of tuples representing the points of intersection.\n    Example:\n    >>> find_line_circle_intersection(Eq(y, x + 1), (0, 0), 5)\n    [(-3, -2), (2, 3)]\n    \"\"\"\n    x, y = symbols('x y')\n    cx, cy = circle_center\n    # Replace y in the circle equation using the line equation\n    circle_eq = Eq((x - cx)**2 + (y - cy)**2, circle_radius**2)\n    substitued_eq = circle_eq.subs(y, solve(line_eq, y)[0])\n    # Solve for x\n    result_x = solve(substitued_eq, x)\n    result = [(xi, solve(line_eq.subs(x, xi), y)[0]) for xi in result_x]\n    return result"], ["def angle_between_lines(line1, line2):\n    \"\"\"\n    Calculate the angle in degrees between two lines given their coefficients.\n    Parameters:\n    line1 (tuple): Coefficients (a, b, c) of the first line in the form ax + by + c = 0.\n    line2 (tuple): Coefficients (a, b, c) of the second line in the form ax + by + c = 0.\n    Returns:\n    float: Angle in degrees between the two lines.\n    Example:\n    >>> angle_between_lines((1, -1, 0), (1, 1, 0))\n    90.0\n    \"\"\"\n    # Extract coefficients\n    a1, b1, _ = line1\n    a2, b2, _ = line2\n    # Calculating angle using the formula:\n    # tan(theta) = |(m2-m1)/(1+m1*m2)|  where m = -a/b for each line\n    numerator = np.abs(a2 * b1 - a1 * b2)\n    denominator = np.abs(a1 * b2 + a2 * b1)\n    angle_rad = np.arctan(numerator / denominator)\n    angle_deg = np.degrees(angle_rad)\n    return angle_deg", "def calculate_angle_between_lines(line1_coeffs, line2_coeffs):\n    \"\"\"\n    Calculates the angle in degrees between two lines.\n    Parameters:\n    line1_coeffs (tuple/list): Coefficients (A, B) of the first line (Ax + By = C).\n    line2_coeffs (tuple/list): Coefficients (A, B) of the second line (Ax + By = C).\n    Returns:\n    float: Angle in degrees between the two lines.\n    Example:\n    >>> calculate_angle_between_lines((1, 0), (0, 1))\n    90.0\n    \"\"\"\n    A1, B1 = line1_coeffs\n    A2, B2 = line2_coeffs\n    dot_product = A1 * A2 + B1 * B2\n    norm_product = np.linalg.norm([A1, B1]) * np.linalg.norm([A2, B2])\n    angle_radians = np.arccos(dot_product / norm_product)\n    return np.degrees(angle_radians)"], ["def line_perpendicular_to(line, point):\n    \"\"\"\n    Creates the equation of a line that is perpendicular to the given line and passes through the specified point.\n    \n    Parameters:\n    - line (sympy.Expr): The equation of the initial line in form `Ax + By + C = 0`.\n    - point (tuple): A tuple (px, py) representing the point through which the perpendicular line must pass.\n    \n    Returns:\n    - sympy.Expr: The equation of the perpendicular line.\n    \n    Example:\n    >>> line = create_line_equation((0, 0), (1, 1))\n    >>> perp_line = line_perpendicular_to(line, (1, 0))\n    >>> print(perp_line)\n    x + y - 1\n    \"\"\"\n    x, y = sp.symbols('x y')\n    A, B, _ = sp.poly(line).coeffs()\n    px, py = point\n    # For line Ax + By + C = 0, the perpendicular line is Bx - Ay + (Ay1 - Bx1)\n    perp_line_expr = B*x - A*y + (A*py - B*px)\n    return sp.simplify(perp_line_expr)"], ["def check_line_relationship(point1, point2, point3, point4):\n    \"\"\"\n    Check if two lines described by two points each (points on the first line and points on the second line) are parallel or perpendicular.\n    Parameters:\n    - point1, point2 (tuple): Coordinates of the first and second point (x, y) on the first line.\n    - point3, point4 (tuple): Coordinates of the first and second point (x, y) on the second line.\n    Returns:\n    - str: 'parallel', 'perpendicular', or 'none' indicating the relationship between the two lines.\n    \n    Examples:\n    - check_line_relationship((0,0), (1,1), (0,1), (1,2)) returns 'parallel'.\n    - check_line_relationship((0,0), (1,0), (0,0), (0,1)) returns 'perpendicular'.\n    \"\"\"\n    # Calculate direction vectors\n    dir1 = np.array([point2[0] - point1[0], point2[1] - point1[1]])\n    dir2 = np.array([point4[0] - point3[0], point4[1] - point3[1]])\n    \n    # Check parallelism (cross product == 0)\n    if np.cross(dir1, dir2) == 0:\n        return 'parallel'\n    \n    # Check perpendicularity (dot product == 0)\n    if np.dot(dir1, dir2) == 0:\n        return 'perpendicular'\n    return 'none'"], ["def radians_to_degrees(radians):\n    \"\"\"\n    Converts an angle from radians to degrees.\n    Parameters:\n    radians (float): The angle in radians.\n    Returns:\n    degrees (float): The angle in degrees.\n    Examples:\n    >>> radians_to_degrees(math.pi)\n    180.0\n    \"\"\"\n    return math.degrees(radians)", "def degrees_to_radians(degrees):\n    \"\"\"\n    Converts an angle from degrees to radians.\n    Parameters:\n    degrees (float): The angle in degrees.\n    Returns:\n    radians (float): The angle in radians.\n    Examples:\n    >>> degrees_to_radians(180)\n    3.141592653589793\n    \"\"\"\n    return math.radians(degrees)"], ["def are_perpendicular(slope1, slope2):\n    \"\"\"\n    Check if two lines with given slopes are perpendicular.\n    Parameters:\n        slope1 (float or None): Slope of the first line.\n        slope2 (float or None): Slope of the second line.\n    Returns:\n        bool: True if the lines are perpendicular, False otherwise.\n    Examples:\n        >>> are_perpendicular(2, -0.5)\n        True\n        >>> are_perpendicular(None, 0)\n        True\n        >>> are_perpendicular(3, 3)\n        False\n    \"\"\"\n    if slope1 is None:\n        # First line is vertical, check if second is horizontal\n        return slope2 == 0\n    if slope2 is None:\n        # Second line is vertical, check if first is horizontal\n        return slope1 == 0\n    return slope1 * slope2 == -1", "def are_perpendicular(slope1, slope2):\n    \"\"\"\n    Determines if two lines with given slopes are perpendicular.\n    \n    Parameters:\n        slope1 (float): Slope of the first line.\n        slope2 (float): Slope of the second line.\n    \n    Returns:\n        bool: True if lines are perpendicular, False otherwise.\n    \n    Examples:\n        >>> are_perpendicular(2, -0.5)\n        True\n        >>> are_perpendicular(3, 3)\n        False\n    \"\"\"\n    if slope1 == np.inf and slope2 == 0:\n        return True\n    elif slope2 == np.inf and slope1 == 0:\n        return True\n    elif slope1 * slope2 == -1:\n        return True\n    return False", "def are_perpendicular(slope1, slope2):\n    \"\"\"\n    Determine if the lines with the provided slopes are perpendicular.\n    Parameters:\n        slope1 (float or None): The slope of the first line, or None if it's a vertical line.\n        slope2 (float or None): The slope of the second line, or None if it's a vertical line.\n    \n    Returns:\n        bool: True if the lines are perpendicular, False otherwise.\n    \n    Examples:\n        >>> are_perpendicular(2, -0.5)\n        True\n        >>> are_perpendicular(None, 0)\n        True\n        >>> are_perpendicular(1, 1)\n        False\n    \"\"\"\n    if slope1 is None and slope2 == 0:\n        return True\n    elif slope2 is None and slope1 == 0:\n        return True\n    elif slope1 is not None and slope2 is not None:\n        return slope1 * slope2 == -1\n    return False"], ["def angle_between_vectors(vector1, vector2):\n    \"\"\"\n    Calculate the angle in degrees between two vectors in 2D space.\n    Parameters:\n    vector1 (tuple): The components (x, y) of the first vector.\n    vector2 (tuple): The components (x, y) of the second vector.\n    Returns:\n    float: The angle in degrees.\n    Example:\n    >>> angle_between_vectors((1, 0), (0, 1))\n    90.0\n    \"\"\"\n    dot_product = np.dot(vector1, vector2)\n    magnitude_product = np.linalg.norm(vector1) * np.linalg.norm(vector2)\n    angle_rad = math.acos(dot_product / magnitude_product)\n    angle_deg = math.degrees(angle_rad)\n    return angle_deg", "def angle_between_vectors(v1, v2):\n    \"\"\"\n    Calculate the angle in degrees between two vectors in 2D.\n    \n    Parameters:\n    - v1 (tuple): The first vector, represented as a tuple (x1, y1).\n    - v2 (tuple): The second vector, represented as a tuple (x2, y2).\n    \n    Returns:\n    - float: The angle between the two vectors in degrees.\n    \n    Example:\n    >>> angle_between_vectors((1, 0), (0, 1))\n    90.0\n    >>> angle_between_vectors((1, 1), (1, -1))\n    90.0\n    \"\"\"\n    # Extracting components\n    x1, y1 = v1\n    x2, y2 = v2\n    # Dot product\n    dot = x1 * x2 + y1 * y2\n    # Magnitudes of vectors\n    mag_v1 = math.sqrt(x1**2 + y1**2)\n    mag_v2 = math.sqrt(x2**2 + y2**2)\n    # Cosine of the angle\n    cos_theta = dot / (mag_v1 * mag_v2)\n    # Angle in radians and then in degrees\n    angle_rad = math.acos(cos_theta)\n    angle_deg = math.degrees(angle_rad)\n    return angle_deg"], ["def find_midpoint(point1, point2):\n    \"\"\"\n    Calculate the midpoint between two points in a 2D space.\n    Parameters:\n    point1 (tuple): The (x, y) coordinates of the first point.\n    point2 (tuple): The (x, y) coordinates of the second point.\n    Returns:\n    tuple: The (x, y) coordinates of the midpoint.\n    Example:\n    >>> find_midpoint((0, 0), (2, 2))\n    (1.0, 1.0)\n    \"\"\"\n    midpoint = ((point1[0] + point2[0]) / 2, (point1[1] + point2[1]) / 2)\n    return midpoint", "def midpoint(point1, point2):\n    \"\"\"\n    Calculate the midpoint of a line segment defined by two points.\n    Parameters:\n    point1 (tuple): A tuple (x, y) representing the coordinates of the first point.\n    point2 (tuple): A tuple (x, y) representing the coordinates of the second point.\n    Returns:\n    midpoint (tuple): A tuple (x, y) representing the midpoint of the line segment.\n    Examples:\n    >>> midpoint((1, 1), (3, 3))\n    (2.0, 2.0)\n    \"\"\"\n    mid_x = (point1[0] + point2[0]) / 2\n    mid_y = (point1[1] + point2[1]) / 2\n    return (mid_x, mid_y)", "def segment_properties(point1, point2):\n    \"\"\"\n    Calculate the length of the line segment and the coordinates of the midpoint between two points.\n    Parameters\n    ----------\n    point1 : tuple\n        A tuple representing the coordinates (x, y) of the first point.\n    point2 : tuple\n        A tuple representing the coordinates (x, y) of the second point.\n    Returns\n    -------\n    dict\n        A dictionary containing:\n        - 'length': The Euclidean distance (length) between the two points.\n        - 'midpoint': A tuple representing the midpoint coordinates (x, y) between the two points.\n    Examples\n    --------\n    >>> segment_properties((0, 0), (2, 2))\n    {'length': 2.8284271247461903, 'midpoint': (1.0, 1.0)}\n    \"\"\"\n    length = np.sqrt((point2[0] - point1[0])**2 + (point2[1] - point1[1])**2)\n    midpoint = ((point1[0] + point2[0]) / 2, (point1[1] + point2[1]) / 2)\n    return {'length': length, 'midpoint': midpoint}"], ["def line_slope_intercept(x1, y1, x2, y2):\n    \"\"\"\n    Calculates the slope and y-intercept form of the equation of the line passing through two points.\n    Parameters:\n        x1, y1 (float): Coordinates of the first point.\n        x2, y2 (float): Coordinates of the second point.\n    Returns:\n        tuple: Returns the slope (m) and y-intercept (b) of the line.\n    \n    Examples:\n        >>> line_slope_intercept(1, 2, 3, 4)\n        (1.0, 1.0)\n        >>> line_slope_intercept(2, 3, 2, 5)\n        ('undefined', None)  # Vertical line\n    \"\"\"\n    if x2 - x1 == 0:\n        return 'undefined', None  # Slope is undefined for vertical lines\n    else:\n        m = (y2 - y1) / (x2 - x1)\n        b = y1 - m * x1\n        return m, b", "def find_linear_equation(x1, y1, x2, y2):\n    \"\"\"\n    Calculate the slope-intercept form equation of a line given two points (x1, y1) and (x2, y2).\n    Parameters:\n    - x1, y1, x2, y2 (float): Coordinates of two points on the line.\n    Returns:\n    - tuple: coefficients of slope and constant (m, c) of the line y = mx + c\n    Examples:\n    - find_linear_equation(1, 2, 3, 8)\n    \"\"\"\n    slope = (y2 - y1) / (x2 - x1) if x2 != x1 else float('inf')\n    intercept = y1 - slope * x1\n    return (slope, intercept)"], ["def angle_between_tangent_and_radius(point_of_tangency, center_of_circle):\n    \"\"\"\n    Calculate the angle formed at the point of tangency between the tangent to a circle and the radius.\n    Parameters:\n    point_of_tangency (tuple): A tuple (x, y) representing the coordinates of the point where the tangent touches the circle.\n    center_of_circle (tuple): A tuple (x, y) representing the coordinates of the circle's center.\n    Returns:\n    angle (float): The angle in degrees between the tangent and the radius at the point of tangency, which is always 90 degrees for a circle.\n    Examples:\n    >>> angle_between_tangent_and_radius((2, 4), (1, 1))\n    90.0\n    \"\"\"\n    # For a circle, the angle between the radius to the point of tangency and the tangent at that point is always 90 degrees.\n    return 90.0"], ["def divide_segment_into_parts(point1, point2, parts):\n    \"\"\"\n    Divide a line segment into a specified number of equal parts and return the division points.\n    Parameters:\n    point1 (tuple): The (x, y) coordinates of the first point.\n    point2 (tuple): The (x, y) coordinates of the second point.\n    parts (int): The number of equal parts to divide the segment into.\n    Returns:\n    list of tuples: The list of (x, y) coordinates of the division points.\n    Example:\n    >>> divide_segment_into_parts((0, 0), (6, 0), 3)\n    [(2.0, 0.0), (4.0, 0.0)]\n    \"\"\"\n    return [(point1[0] + (point2[0] - point1[0]) * i / parts, point1[1] + (point2[1] - point1[1]) * i / parts) for i in range(1, parts)]", "def trisect_segment(point1, point2):\n    \"\"\"\n    Calculate the points that trisect a line segment defined by two points.\n    Parameters\n    ----------\n    point1 : tuple\n        A tuple representing the coordinates (x, y) of the first point.\n    point2 : tuple\n        A tuple representing the coordinates (x, y) of the second point.\n    Returns\n    -------\n    tuple\n        A tuple of the two points (as tuples) that divide the line segment into three equal parts.\n    Examples\n    --------\n    >>> trisect_segment((0, 0), (3, 0))\n    ((1.0, 0.0), (2.0, 0.0))\n    \"\"\"\n    trisect_point1 = ((2/3) * point1[0] + (1/3) * point2[0], (2/3) * point1[1] + (1/3) * point2[1])\n    trisect_point2 = ((1/3) * point1[0] + (2/3) * point2[0], (1/3) * point1[1] + (2/3) * point2[1])\n    return (trisect_point1, trisect_point2)"], ["def check_parallelism(line1_coeffs, line2_coeffs):\n    \"\"\"\n    Checks whether two lines are parallel.\n    Parameters:\n    line1_coeffs (tuple/list): Coefficients (A, B) of the first line (Ax + By = C).\n    line2_coeffs (tuple/list): Coefficients (A, B) of the second line (Ax + By = C).\n    Returns:\n    bool: True if lines are parallel, False otherwise.\n    Example:\n    >>> check_parallelism((1, -2), (2, -4))\n    True\n    >>> check_parallelism((1, 2), (2, -5))\n    False\n    \"\"\"\n    A1, B1 = line1_coeffs\n    A2, B2 = line2_coeffs\n    return np.isclose(A1 * B2, A2 * B1)", "def check_perpendicularity(line1_coeffs, line2_coeffs):\n    \"\"\"\n    Checks whether two lines are perpendicular.\n    Parameters:\n    line1_coeffs (tuple/list): Coefficients (A, B) of the first line (Ax + By = C).\n    line2_coeffs (tuple/list): Coefficients (A, B) of the second line (Ax + By = C).\n    Returns:\n    bool: True if lines are perpendicular, False otherwise.\n    Example:\n    >>> check_perpendicularity((1, 2), (-2, 1))\n    True\n    >>> check_perpendicularity((1, 2), (2, 4))\n    False\n    \"\"\"\n    A1, B1 = line1_coeffs\n    A2, B2 = line2_coeffs\n    return np.isclose(A1 * A2 + B1 * B2, 0)"], ["def check_line_properties(line1_coeff, line2_coeff, check_type='parallel'):\n    \"\"\"\n    Determine if two lines are parallel or perpendicular, or find the intersection point.\n    \n    Parameters:\n        line1_coeff (tuple): Coefficients (A, B, C) of the first line in the form Ax + By = C.\n        line2_coeff (tuple): Coefficients (A, B, C) of the second line.\n        check_type (str): Type of property to check: 'parallel', 'perpendicular', 'intersection'.\n    Returns:\n        bool or tuple: Depending on 'check_type', returns boolean for parallel or perpendicular,\n                       and tuple (x, y) for intersection point if lines intersect.\n                       \n    Examples:\n        >>> check_line_properties((1, -1, 0), (2, -2, 0))\n        True  # Lines are parallel\n        >>> check_line_properties((1, -1, 0), (1, 1, 0), 'perpendicular')\n        True  # Lines are perpendicular\n        >>> check_line_properties((1, -1, 0), (1, 1, 2), 'intersection')\n        (1, 1)  # Intersection point\n    \"\"\"\n    A1, B1, C1 = line1_coeff\n    A2, B2, C2 = line2_coeff\n    \n    if check_type == 'parallel':\n        return A1*B2 == A2*B1\n    elif check_type == 'perpendicular':\n        return -A1*A2 == B1*B2\n    elif check_type == 'intersection':\n        determinant = A1*B2 - A2*B1\n        if determinant == 0:\n            return False  # Lines are parallel or coincident, no single intersection\n        else:\n            x = (B2*C1 - B1*C2) / determinant\n            y = (A1*C2 - A2*C1) / determinant\n            return (x, y)\n    return False"], ["def calculate_vertical_angle(given_angle):\n    \"\"\"\n    Calculate the vertical angle given one angle. Vertical angles are equal when two lines intersect.\n    Parameters:\n    given_angle (float): The given angle in degrees.\n    Returns:\n    float: The vertical angle which is equal to the given angle.\n    Example:\n    >>> calculate_vertical_angle(45)\n    45.0\n    \"\"\"\n    return given_angle"], ["def calculate_side_length(a, b, angle_C):\n    \"\"\"\n    Calculate the length of a side in a triangle using the Law of Cosines.\n    Parameters:\n    a (float): Length of the first side of the triangle.\n    b (float): Length of the second side of the triangle.\n    angle_C (float): Angle opposite the side to be calculated, in degrees.\n    Returns:\n    float: The length of the third side.\n    Examples:\n    >>> calculate_side_length(5, 7, 45)\n    3.80788655293\n    \"\"\"\n    # Converting angle from degrees to radians\n    angle_C_rad = np.deg2rad(angle_C)\n    \n    # Using Law of Cosines: c^2 = a^2 + b^2 - 2ab*cos(C)\n    c = np.sqrt(a**2 + b**2 - 2*a*b*np.cos(angle_C_rad))\n    return c", "def calculate_triangle_angle(a, b, c):\n    \"\"\"\n    Calculate an angle in a triangle using the Law of Cosines.\n    Parameters:\n    a (float): Length of the first side adjacent to the angle.\n    b (float): Length of the second side adjacent to the angle.\n    c (float): Length of the side opposite to the angle.\n    Returns:\n    float: The calculated angle in degrees.\n    Examples:\n    >>> calculate_triangle_angle(5, 7, 9)\n    37.1618083524\n    \"\"\"\n    # Using Law of Cosines: cos(C) = (a^2 + b^2 - c^2) / (2ab)\n    cos_angle = (a**2 + b**2 - c**2) / (2 * a * b)\n    # Getting the angle in radians\n    angle_rad = np.arccos(cos_angle)\n    # Converting radians to degrees for a more common usage\n    angle_deg = np.rad2deg(angle_rad)\n    return angle_deg", "def cosine_law_angle(a, b, c):\n    \"\"\"\n    Calculate the angle opposite the side 'c' using the law of cosines in a triangle.\n    Parameters:\n    a (float): length of the first side of the triangle.\n    b (float): length of the second side of the triangle.\n    c (float): length of the third side of the triangle.\n    Returns:\n    angle_in_degrees (float): angle opposite to the side 'c' in degrees.\n    Examples:\n    >>> cosine_law_angle(5, 5, 7)\n    44.41530859719327\n    >>> cosine_law_angle(3, 4, 5)\n    90.0\n    \"\"\"\n    # Compute the cosine of the angle from the law of cosines\n    cos_angle = (a**2 + b**2 - c**2) / (2 * a * b)\n    \n    # Obtain angle in radians using the arccos function\n    angle_radians = math.acos(cos_angle)\n    \n    # Convert the angle from radians to degrees\n    angle_degrees = math.degrees(angle_radians)\n    \n    return angle_degrees", "def triangle_angle_by_sides(a, b, c):\n    \"\"\"\n    Calculate the angle opposite to the side `c` in a triangle using the Law of Cosines.\n    \n    Parameters:\n    - a (float): Length of side a of the triangle.\n    - b (float): Length of side b of the triangle.\n    - c (float): Length of side c of the triangle.\n    \n    Returns:\n    - float: The angle opposite to side `c` in degrees.\n    \n    Example:\n    >>> triangle_angle_by_sides(5, 5, 5)\n    60.0\n    \"\"\"\n    # Law of Cosines: c**2 = a**2 + b**2 - 2*a*b*cos(C)\n    # Solving for cos(C)\n    cos_C = (a**2 + b**2 - c**2) / (2 * a * b)\n    # Calculating angle in radians\n    angle_rad = math.acos(cos_C)\n    # Converting radians to degrees\n    angle_deg = math.degrees(angle_rad)\n    return angle_deg"], ["def angle_between_parallel_lines(angle_one, is_supplementary=False):\n    \"\"\"\n    Determines angles formed when two parallel lines are intersected by a transversal.\n    \n    Parameters:\n        angle_one : float or sympy.Expr\n            The measure of one of the given angles in degrees.\n        is_supplementary : bool, optional\n            Determines if the function should return the supplementary angle (default is False).\n            \n    Returns:\n        float or sympy.Expr\n            Returns the corresponding angle measure based on properties of parallel lines.\n            If `is_supplementary` is True, returns the supplementary angle to angle_one.\n    \n    Examples:\n        >>> angle_between_parallel_lines(50)\n        130\n        >>> angle_between_parallel_lines(50, True)\n        50\n        >>> angle_between_parallel_lines(sp.Symbol('x') + 10)\n        170 - x\n    \"\"\"\n    if is_supplementary:\n        return angle_one\n    else:\n        return 180 - angle_one"], ["def count_lines(points):\n    \"\"\"\n    Count the number of distinct vertical, horizontal, and diagonal lines formed by a set of points.\n    Parameters:\n    - points (list of tuples): Points in the grid specified as (x, y).\n    Returns:\n    - dict: A dictionary with keys 'horizontal', 'vertical', 'diagonal' and their corresponding counts.\n    Examples:\n    >>> count_lines([(1, 2), (2, 2), (2, 3), (3, 2), (4, 4)])\n    {'horizontal': 1, 'vertical': 1, 'diagonal': 1}\n    \"\"\"\n    # Converting list of tuples to numpy array\n    points = np.array(points)\n    from collections import defaultdict\n    # Dictionaries to hold lines by their parameters\n    horizontal_lines = defaultdict(set)\n    vertical_lines = defaultdict(set)\n    diagonal_lines_slope_intercept = defaultdict(set)\n    # Categorizing points into types of lines they can form\n    for x, y in points:\n        horizontal_lines[y].add(x)\n        vertical buckets\n        vertical_lines_cache\n        vertical_lines_points\n        vertical_lines_points_horizontal_lines\n        vertical_lines_points_horizontal_lines\n        vertical_lines_points_points_horizontal_lines_horizontal_lines\n        vertical_lines_points_sp\n        vertical_lines_ multiple_sp.offsetWidth\n        vertical_sp\n        vertical_sp.offsetWidth\n        vertical_term_l\n        vertical_points = defaultsetter.get(x, set())\n        vertical_points.add(y)\n        vertical_lines[x] = vertical_points\n        # Diagonal lines are sorted by their differences and sums for primary and secondary diagonals respectively\n        diagonal_lines_slope_intercept[x - y].add((x, y))\n        diagonal_lines_slope_intercept[x + y].add((x, y))\n    count_horizontal = sum(len(set(xs)) > 1 for xs in horizontal_lines.values())\n    count_vertical = sum(len(set(ys)) > 1 for ys in vertical_lines.values())\n    count_diagonal = sum(len(coords) > 1 for coords in diagonal_lines_slope_intercept.values())\n    return {\n        'horizontal': count_horizontal,\n        'vertical'"], ["def identify_line_type(point1, point2):\n    \"\"\"\n    Identifies the type of line (horizontal, vertical, or diagonal) formed by two given points.\n    Parameters:\n        point1 (tuple): The (x, y) coordinate of the first point.\n        point2 (tuple): The (x, y) coordinate of the second point.\n    Returns:\n        str: Returns \"horizontal\" if line is horizontal, \"vertical\" if vertical, and \"diagonal\" otherwise.\n    Example:\n        >>> identify_line_type((0, 0), (5, 0))\n        'horizontal'\n        >>> identify_line_range((1, 1), (1, 3))\n        'vertical'\n        >>> identify_line_range((1, 1), (3, 3))\n        'diagonal'\n    \"\"\"\n    if point1[0] == point2[0]:\n        return 'vertical'\n    elif point1[1] == point2[1]:\n        return 'horizontal'\n    else:\n        return 'diagonal'"], ["def calculate_angle_relationships(angle_expressions, total_angle=180):\n    \"\"\"\n    Calculate the values of variables in angular relationships where the sum of multiple angles equals a total (commonly 180 degrees).\n    \n    Parameters:\n    - angle_expressions (list): A list of sympy expressions representing angles.\n    - total_angle (int, float): The total sum of angles (default 180 for linear pair, straight line).\n    \n    Returns:\n    - dict: A dictionary of variable solutions if solvable.\n    Examples:\n    - calculate_angle_relationships([x + 30, x - 20])\n    - calculate_angle_relationships([2*x + y, 3*x - 2*y], 360)\n    \"\"\"\n    x, y = symbols('x y')\n    equation = Eq(sum(angle_expressions), total_angle)\n    result = solve(equation)\n    return result"], ["def is_line_tangent_to_circle(line, circle_center, circle_radius):\n    \"\"\"\n    Check if the given line is tangent to the specified circle.\n    Parameters\n    ----------\n    line : sympy.geometry.line.Line\n        Sympy Line object.\n    circle_center : tuple\n        (x, y) coordinates of the circle's center.\n    circle_radius : float\n        Radius of the circle.\n    Returns\n    -------\n    bool\n        True if the line is tangent to the circle, False otherwise.\n    Examples\n    --------\n    >>> from sympy import Point, Line\n    >>> result = is_line_tangent_to_circle(Line(Point(1, 2), Point(3, 4)), (0, 0), 1)\n    >>> print(result)\n    \"\"\"\n    ctr = Point(*circle_center)\n    circ = circle.Circle(ctr, circle_radius)\n    \n    # Get the shortest distance from the center of the circle to the line\n    distance = line.distance(ctr)\n    \n    # If the distance equals the radius, it is tangent\n    return abs(distance - circle_radius) < 1e-6  # Using a small threshold to handle float inaccuracies"], ["def check_triangle_inequality(a, b, c):\n    \"\"\"\n    Determine if three lengths can form a triangle based on the triangle inequality theorem.\n    Parameters:\n    a, b, c (float): Lengths of the sides of a potential triangle.\n    Returns:\n    bool: True if the lengths satisfy the triangle inequality, False otherwise.\n    Examples:\n    >>> check_triangle_inequality(3, 4, 5)\n    True\n    >>> check_triangle_inequality(1, 10, 12)\n    False\n    \"\"\"\n    return a + b > c and a + c > b and b + c > a"], ["def calculate_slope(line):\n    \"\"\"\n    Calculate the slope of a line given in the form ax + by + c = 0.\n    Parameters:\n    line (tuple): Coefficients (a, b, c) representing the line ax + by + c = 0.\n    Returns:\n    float: Slope of the line.\n    \n    \"\"\"\n    a, b, c = line\n    if b == 0:\n        raise ValueError(\"Slope is undefined for vertical lines.\")\n    return -a / b"], ["def angle_bisector_theorem(a, b, angle):\n    \"\"\"\n    Applies the angle bisector theorem within a triangle to find the relationships of segments.\n    Parameters:\n        a (float): The length of one side of the triangle.\n        b (float): The length of the adjacent side of the triangle.\n        angle (float): The angle being bisected in degrees.\n        \n    Returns:\n        float: The ratio of the two segments created by bisecting the given angle.\n    Examples:\n        >>> angle_bisector_theorem(4, 6, 60)\n        0.8\n    \"\"\"\n    theta = sp.rad(angle)\n    return (a / b)"], ["def distance_between_parallel_lines(slope, intercept1, intercept2):\n    \"\"\"\n    Calculate the distance between two parallel lines given by y = mx + c1 and y = mx + c2.\n    Parameters:\n    - slope (float): Slope of the parallel lines.\n    - intercept1, intercept2 (float): Y-intercepts of the two lines.\n    Returns:\n    - float: The distance between the two parallel lines.\n    Examples:\n    - distance_between_parallel_lines(1, 2, 5)\n    \"\"\"\n    return abs(intercept2 - intercept1) / math.sqrt(slope**2 + 1)"], ["def angle_in_cyclic_quadrilateral(adjacent_sum):\n    \"\"\"\n    Calculate the opposite angle in a cyclic quadrilateral given the sum of two adjacent angles.\n    \n    Parameters:\n        adjacent_sum (float): Sum of two adjacent angles in degrees.\n        \n    Returns:\n        float: Each of the opposite angles in degrees.\n        \n    Example:\n        >>> angle_in_cyclic_quadrilateral(90)\n        90.0\n    \"\"\"\n    # In a cyclic quadrilateral, the sum of opposite angles is 180 degrees\n    return 180 - adjacent_sum"], ["def sum_of_angles_around_point():\n    \"\"\"\n    Returns the sum of the angles around a point, which is always 360 degrees.\n    Returns:\n    int: Sum of angles around a point.\n    \n    Examples:\n    >>> sum_of_angles_roud_point()\n    360\n    \"\"\"\n    return 360"], ["def calculate_line_segment_length(coord1, coord2):\n    \"\"\"\n    Calculates the length of the line segment between two coordinates.\n    Parameters:\n    - coord1 (tuple of float): The (x, y) coordinates of the first point\n    - coord2 (tuple of float): The (x, y) coordinates of the second point\n    Returns:\n    - float: The length of the line segment between the given points\n    Example:\n    >>> calculate_line_segment_length((0, 0), (3, 4))\n    5.0\n    \"\"\"\n    return math.hypot(coord2[0] - coord1[0], coord2[1] - coord1[1])"], ["def perpendicular_slope(slope):\n    \"\"\"\n    Calculates the slope of a line perpendicular to the line with a given slope.\n    \n    Parameters:\n        slope (float): Slope of the original line.\n    \n    Returns:\n        float: Slope of the line that is perpendicular to the given line.\n    \n    Examples:\n        >>> perpendicular_slope(4)\n        -0.25\n        >>> perpendicular_slope(0)\n        inf\n    \"\"\"\n    if slope == 0:\n        return np.inf\n    elif slope == np.inf:\n        return 0\n    else:\n        return -1 / slope"], ["def find_longest_side(triangle_vertices):\n    \"\"\"\n    Calculate and return the longest side of a triangle given its vertices.\n    Parameters:\n    - triangle_vertices (list of tuples): List of three tuples, each representing the coordinates of a triangle vertex.\n    Returns:\n    - float: The length of the longest side of the triangle.\n    Examples:\n    - find_longest_side([(0,0), (4,0), (0,3)]) will return 5.0, which is the hypotenuse.\n    \"\"\"\n    sides = [distance_between_points(triangle_vertices[i], triangle_vertices[(i+1)%3]) for i in range(3)]\n    return max(sides)"], ["def are_corresponding_angles_equal(angle_set1, angle_set2):\n    \"\"\"\n    Check if corresponding angles in two sets are equal, useful for parallel lines crossed by a transversal.\n    Parameters:\n    angle_set1 (list of float): Angles in the first set.\n    angle_set2 (list of float): Angles in the second set.\n    \n    Returns:\n    bool: True if each corresponding angle in the sets are equal, False otherwise.\n    \n    Examples:\n    >>> are_corresponding_angles_equal([110, 70], [110, 70])\n    True\n    >>> are_corresponding_angles_equal([110, 70], [70, 110])\n    False\n    \"\"\"\n    return np.allclose(angle_set1, angle_set2)"], ["def reflect_point_over_line(point, line_coeffs):\n    \"\"\"\n    Reflects a point over a given line.\n    Parameters:\n    point (tuple/list): Coordinates (x, y) of the point to reflect.\n    line_coeffs (tuple/list): Coefficients (A, B, C) of the line Ax + By + C = 0.\n    Returns:\n    tuple: Coordinates (x', y') of the reflected point.\n    Example:\n    >>> reflect_point_over_line((3, 4), (1, -1, 0))\n    (4, 3)\n    \"\"\"\n    x, y = sp.symbols('x y')\n    A, B, C = line_coeffs\n    line_eq = A*x + B*y + C\n    perp_slope = -A/B if B != 0 else float('inf')\n  \n    if perp_slope != float('inf'):\n        perp_line_eq = y - point[1] - perp_slope*(x - point[0])\n        intersection = sp.solve([line_eq, perp_line_eq], (x, y))\n    else:\n        intersection = {x: point[0], y: -C/B}\n    ix, iy = intersection[x], intersection[y]\n    reflected_x = 2*ix - point[0]\n    reflected_y = 2*iy - point[1]\n    return (reflected_x, reflected_y)"], ["def distance_from_point_to_line(px, py, slope, intercept):\n    \"\"\"\n    Calculate the perpendicular distance from a point to a line given by y = mx + c.\n    Parameters:\n    - px, py (float): Coordinates of the point.\n    - slope, intercept (float): Coefficients of the line y = mx + c.\n    Returns:\n    - float: The perpendicular distance from (px, py) to the line.\n    Examples:\n    - distance_from_point_to_line(1, 2, 1, 0)  # Line y = x\n    \"\"\"\n    return abs(slope * px - py + intercept) / math.sqrt(slope**2 + 1)"], ["def solve_linear_equations(eq_list):\n    \"\"\"\n    Solves a system of linear equations.\n    \n    Parameters:\n        eq_list (list): A list of sympy Eq objects representing equations.\n    \n    Returns:\n        dict: A dictionary containing the solution for the variables in the equations.\n        \n    Examples:\n        x, y = symbols('x y')\n        eq1 = Eq(x + y, 10)\n        eq2 = Eq(2*x - y, 0)\n        solutions = solve_linear_equations([eq1, eq2])\n        print(solutions)  # {x: 10/3, y: 20/3}\n    \"\"\"\n    variables = set().union(*(eq.free_symbols for eq in eq_list))\n    solution = solve(eq_list, list(variables))\n    return solution"], ["def calculate_triangle_angle_sum(angle1, angle2):\n    \"\"\"\n    Given two angles of a triangle, returns the third angle using the fact\n    that sum of angles in a triangle is always 180 degrees.\n    Parameters:\n    - angle1 (float): First angle in degrees\n    - angle2 (float): Second angle in degrees\n    Returns:\n    - float: Third angle in the triangle\n    Example:\n    >>> calculate_triangle_angle_sum(90, 30)\n    60.0\n    \"\"\"\n    return 180.0 - angle1 - angle2"], ["def check_symmetry(x1, y1, x2, y2, line_x):\n    \"\"\"\n    Checks whether two points are symmetric with respect to a vertical line x = line_x.\n    Parameters:\n        x1, y1 (float, float): Coordinates of the first point.\n        x2, y2 (float, float): Coordinates of the second point.\n        line_x (float): x-coordinate of the vertical line of symmetry.\n    Returns:\n        bool: Returns True if the points are symmetric with respect to the line, otherwise False.\n    \n    Examples:\n        >>> check_symmetry(3, 4, 7, 4, 5)\n        True\n        >>> check_symmetry(1, 2, 3, 4, 5)\n        False\n    \"\"\"\n    return x1 + x2 == 2 * line_x and y1 == y2"], ["def calculate_missing_angle(known_angle, relation_type='supplementary'):\n    \"\"\"\n    Calculate the missing angle based on the type of angle relation.\n    Parameters:\n    known_angle (float): The known angle in degrees.\n    relation_type (str): Type of angle relation, 'supplementary' or 'complementary'.\n    Returns:\n    float: The missing angle in degrees.\n    Example:\n    >>> calculate_missing_angle(150, 'supplementary')\n    30.0\n    >>> calculate_missingHandler(30, 'complementary')\n    60.0\n    \"\"\"\n    if relation_type == 'supplementary':\n        return 180 - known_angle\n    elif relation_type == 'complementary':\n        return 90 - known_angle\n    else:\n        raise ValueError(\"relation_type must be 'supplementary' or 'complementary'\")"], ["def are_complementary(*angles):\n    \"\"\"\n    Check if the provided angles sum up to 90 degrees, thus are complementary.\n    \n    Parameters:\n        angles (float or int): a variable number of angle measures\n    \n    Returns:\n        bool: True if the sum of angles is 90 degrees, False otherwise.\n        \n    Examples:\n        >>> are_complementary(30, 60)\n        True\n        >>> are_complementary(45, 45)\n        True\n        >>> are_complementary(90, 0)\n        True\n        >>> are_complementary(50, 40, 10)\n        False\n    \"\"\"\n    import numpy as np  # Importing Numpy for numerical operations\n    if np.isclose(sum(angles), 90):\n        return True\n    else:\n        return False", "def are_supplementary(*angles):\n    \"\"\"\n    Check if the provided angles sum up to 180 degrees, thus are supplementary.\n    \n    Parameters:\n        angles (float or int): a variable number of angle measures\n    \n    Returns:\n        bool: True if the sum of angles is 180 degrees, False otherwise.\n        \n    Examples:\n        >>> are_supplementary(90, 90)\n        True\n        >>> are_supplementary(130, 50)\n        True\n        >>> are_supplementary(180)\n        True\n        >>> are_supplementary(100, 70, 10)\n        False\n    \"\"\"\n    import numpy as np  # Importing Numpy for numerical computations\n    if np.isclose(sum(angles), 180):\n        return True\n    else:\n        return False"], ["def check_parallel(angle1, angle2):\n    \"\"\"\n    Determine if two lines are parallel based on their corresponding or alternate angles.\n    Parameters:\n    angle1 (float): The angle formed between the first line and the transversal.\n    angle2 (float): The angle formed between the second line and the transversal.\n    Returns:\n    bool: True if lines are parallel, False otherwise.\n    \n    Examples:\n    >>> check_parallel(120, 120)\n    True\n    >>> check_parallel(120, 130)\n    False\n    \"\"\"\n    return math.isclose(angle1, angle2, abs_tol=1e-9)"], ["def find_line_equation(x1, y1, x2, y2):\n    \"\"\"\n    Generate the equation of a line passing through points (x1, y1) and (x2, y2).\n    \n    Parameters:\n        x1, y1, x2, y2 (int or float): Coordinates of two points.\n    \n    Returns:\n        sympy Eq: The equation of the line in the format `Eq(line expression, 0)`\n        \n    Examples:\n        equation = find_line_equation(0, 0, 1, 1)\n        print(equation)  # Eq(-x + y, 0)\n    \"\"\"\n    p1, p2 = Point(x1, y1), Point(x2, y2)\n    line = Line(p1, p2)\n    return Eq(line.equation(), 0)"], ["def are_lines_parallel_or_coincident(line1, line2):\n    \"\"\"\n    Checks if two line equations are parallel or coincident.\n    Parameters:\n    - line1: sympy.Eq, the equation of the first line.\n    - line2: sympy.Eq, the equation of the second line.\n    Returns:\n    - str: 'parallel', 'coincident', or 'none'.\n    Example:\n    >>> are_lines_parallel_or_coincident(Eq(y, 2*x + 1), Eq(y, 2*x + 3))\n    'parallel'\n    \"\"\"\n    # Extract coefficients of x and y\n    m1, c1 = line1.lhs.coeff(x), line1.rhs.subs(x, 0)\n    m2, c2 = line2.lhs.coeff(x), line2.rhs.subs(x, 0)\n    if m1 == m2:\n        if c1 == c2:\n            return 'coincident'\n        else:\n        return 'parallel'\n    else:\n        return 'none'"], ["def calculate_polygon_angle(n_sides, internal_or_external=True):\n    \"\"\"\n    Calculate the interior or exterior angles of a regular polygon given the number of sides.\n    \n    Parameters:\n        n_sides (int): The number of sides in the polygon.\n        internal_or_external (bool): True for internal angle calculation, False for external angles.\n        \n    Returns:\n        float: The angle in degrees.\n        \n    Example:\n        >>> calculate_polygon_angle(4)\n        90.0\n        >>> calculate_polygon_angle(4, False)\n        90.0\n    \"\"\"\n    if internal_or_external:\n        # Interior angle calculation\n        return (n_sides - 2) * 180 / n_sides\n    else:\n        # Exterior angle calculation (regular polygon)\n        return 360 / n_sides"], ["def sum_of_triangle_angles():\n    \"\"\"\n    Returns the sum of the internal angles of a triangle, which is always 180 degrees.\n    Returns:\n    int: Sum of angles in a triangle.\n    \n    Examples:\n    >>> sum_of_triangle_angles()\n    180\n    \"\"\"\n    return 180"], ["def median_bisector_relationships_in_triangle(point_a, point_b, point_c):\n    \"\"\"\n    Compute centroid (intersection of medians) and the internal angle bisected by median \n    from a given triangle specified by its vertices.\n    \n    Parameters:\n        point_a (tuple): The coordinate as (x, y) for vertex A of the triangle.\n        point_b (tuple): The coordinate as (x, y) for vertex B of the triangle.\n        point_c (tuple): The coordinate as (x, y) for vertex C of the triangle.\n        \n    Returns:\n        dict: Contains 'centroid': the centroid's coordinates  and 'angle_ABC': the angle at vertex B.\n    \n    Example:\n        >>> median_bisector_relationships_in_triangle((0, 0), (4, 0), (2, 3))\n        {'centroid': (2.0, 1.0), 'angle_ABC': 53.130102354156}\n    \"\"\"\n    # Using SymPy to derive expressions\n    A = Point(point_a)\n    B = Point(point_b)\n    C = Point(point_c)\n    \n    # Midpoints of sides\n    mid_ab = Point.midpoint(A, B)\n    mid_bc = Point.midpoint(B, C)\n    mid_ca = Point.midpoint(C, A)\n    \n    centroid = Point.centroid(A, B, C)\n    \n    # Compute angle at vertex B using law of cosines\n    AB = Segment(A, B).length\n    BC = Segment(B, C).length\n    AC = Segment(A, C).length\n    angle_ABC = math.degrees(math.acos((AB**2 + BC**2 - AC**2) / (2 * AB * BC)))\n    \n    return {\n        'centroid': (float(centroid.x), float(centroid.y)),\n        'angle_ABC': angle_ABC\n    }"], ["def calculate_cyclic_quadrilateral_angles(angle_A=None, angle_B=None, angle_C=None, angle_D=None):\n    \"\"\"\n    Calculates the angles of a cyclic quadrilateral given some of the angles.\n    Parameters:\n        angle_A (float or None): Angle at vertex A.\n        angle_B (float or None): Angle at vertex B.\n        angle_C (float or None): Angle at vertex C.\n        angle_D (float or None): Angle at vertex D.\n        \n    Returns:\n        tuple: The four angles (angle_A, angle_B, angle_C, angle_D) of the cyclic quadrilateral.\n    Examples:\n        >>> calculate_cyclic_quadrilateral_angles(angle_A=100, angle_C=40)\n        (100, 40, 100, 40)\n    \"\"\"\n    if angle_A is not None and angle_C is not UTF-8:\n        angle_B = 180 - angle_C\n        angle_D = 180 - angle_A\n    elif angle_B is not None and angle_D is not UTF-8:\n        angle_A = 180 - angle_D\n       \tangle_C = 180 - angle_B\n    else:\n        raise ValueError(\"At least two opposite angles must be provided.\")\n    \n    return (angle_A, angle_B, angle_C, angle_D)"], ["def slope_between_points(point1, point2):\n    \"\"\"\n    Calculates the slope between two given points.\n    \n    Parameters:\n        point1 : tuple of two floats or sympy.Expr\n            Coordinates of the first point (x1, y1).\n        point2 : tuple of two floats or sympa.Expressions\n            Coordinates of the second point (x2, y2).\n    Returns:\n        float or sympy.Expr\n            The slope value between the two points.\n    \n    Example:\n        >>> slope_between_points((1, 2), (3, 8))\n        3\n        >>> slope_between_keys((1, 2), (1, 8))\n        'undefined'  # Division by zero, or handle with symbolics if used in equations.\n    \"\"\"\n    x1, y1 = point1\n    x2, y2 = point2\n    try:\n        return (y2 - y1) / (x2 - x1)\n    except ZeroDivisionError:\n        return 'undefined'"], ["def segment_length(point1, point2):\n    \"\"\"\n    Calculate the length of the segment connecting two points in 2D space.\n    Parameters:\n    point1 (tuple): The (x, y) coordinates of the first point.\n    point2 (tuple): The (x, y) coordinates of the second point.\n    Returns:\n    float: The length of the segment.\n    Example:\n    >>> segment_length((0, 0), (4, 3))\n    5.0\n    \"\"\"\n    length = np.sqrt((point2[0] - point1[0])**2 + (point2[1] - point1[1])**2)\n    return length"], ["def check_parallel(line1, line2):\n    \"\"\"\n    Check if two lines are parallel.\n    \n    Parameters:\n    line1 (tuple): Coefficients (a, b, c) for the first line ax + by + c = 0.\n    line2 (tuple): Coefficients (a, b, c) for the second line ax + by + c = 0.\n    \n    Returns:\n    bool: True if the lines are parallel, False otherwise.\n    \n    \"\"\"\n    return calculate_slope(line1) == calculate_slope(line2)"], ["def cyclic_quadrilateral_angles(angle1, angle2=None):\n    \"\"\"\n    Determines the missing angles in a cyclic quadrilateral given two opposite angles.\n    \n    Parameters:\n    angle1: float\n        The degree of one angle of the cyclic quadrilateral.\n    angle2: float or None\n        The degree of the opposite angle. If None, it's calculated.\n    \n    Returns:\n    tuple\n        A tuple (a1, a2) representing the angles of two opposite pairs in the cyclic quadrilateral.\n        \n    Examples:\n    >>> cyclic_quadrilateral_angles(110)\n    (110, 70)\n    >>> cyclic_quadrilateral_angles(80, 100)\n    (80, 100)\n    \"\"\"\n    if angle2 is None:\n        angle2 = 180 - angle1\n    else:\n        if angle1 + angle2 != 180:\n            raise ValueError(\"Opposite angles in a cyclic quadrilateral must sum up to 180 degrees.\")\n      \n    return angle1, angle2"], ["def perpendicular_slope(slope):\n    \"\"\"\n    Given the slope of a line, return the slope of a line perpendicular to it.\n    Parameters:\n        slope (float or None): The slope of the original line. If 'None', the original line is vertical.\n    Returns:\n        float or None: The slope of the perpendicular line. Returns 'None' if the original line is horizontal.\n    Examples:\n        >>> perpendicular_slope(2)\n        -0.5\n        >>> perpendicular_slope(None)\n        0  # Perpendicular to a vertical line is a horizontal line\n    \"\"\"\n    if slope is None:\n        return 0  # A vertical line has undefined slope, so perpendicular will be horizontal hence slope = 0\n    elif slope == 0:\n        return None  # A horizontal line's perpendicular is vertical, which has an undefined slope\n    else:\n    return -1 / slope"], ["def compute_slope(x1, y1, x2, y2):\n    \"\"\"\n    Compute the slope of a line passing through points (x1, y1) and (x2, y2).\n    \n    Parameters:\n        x1, y1, x2, y2 (int or float): Coordinates of two points.\n    \n    Returns:\n        slope (int or float or sympy object): The slope of the line.\n        \n    Examples:\n        slope = compute_slope(1, 2, 3, 8)\n        print(slope)  # 3\n    \"\"\"\n    # Utilizing sympy points computation to avoid division by zero\n    p1, p2 = Point(x1, y1), Point(x2, y2)\n    line = Line(p1, p2)\n    return line.slope"], ["def tangent_lengths_and_points(cx: float, cy: float, r: float, px: float, py: float) -> Union[None, Tuple[float, Tuple[float, float], Tuple[float, float]]]:\n    \"\"\"\n    Calculate the lengths of tangents from a point to a circle and the points of tangency.\n    Parameters:\n    - cx (float): x-coordinate of the circle's center.\n    - cy (float): y-coordinate of the circle's center.\n    - r (float): radius of the circle.\n    - px (float): x-coordinate of the external point.\n    - py (float): y-coordinate of the external point.\n    Returns:\n    Union[None, Tuple[float, Tuple[float, float], Tuple[float, float]]]:\n    - None if the point is inside the circle (no tangents possible),\n    - Tuple containing:\n      - The length of each tangent (assuming two tangents can be drawn),\n      - Coordinates of the first point of tangency,\n      - Coordinates of the second point of tangency.\n    Examples:\n    >>> tangent_lengths_and_points(0, 0, 5, 12, 0)\n    (13.0, (5.0, 0.0), (-5.0, 0.0))\n    \n    >>> tangent_lengths_and_points(1, 1, 2, 1, 1)\n    None  # Point is inside the circle\n    \"\"\"\n    # Calculate the distance from external point to the circle's center\n    distance_pc = math.sqrt((px - cx)**2 + (py - cy)**2)\n    \n    if distance_pc < r:\n        return None  # Point is inside the circle; tangents cannot be drawn\n    # Length of the tangent using the Pythagorean theorem\n    tangent_length = math.sqrt(distance_pc**2 - r**2)\n    \n    # Coordinates of the points of tangency\n    # These calculations derive from the geometric properties of the circle\n    # and the need to solve the equation of the line defining the tangent.\n    \n    # Angle theta from circle center to external point\n    theta = math.atan2(py - cy, px - cx)\n    # Angles phi for points of tangency\n    phi = math.asin(r / distance_pc)\n    \n    tangent_point1 = (cx + r * math.sin(theta + phi), cy - r * math.cos(theta + phi))\n    tangent_point2 = (cx + r * math.sin(theta - phi), cy - r * math.cos(theta - phi))\n    \n    return tangent_length, tangent_point1, tangent_point2"], ["def line_length(point1, point2):\n    \"\"\"\n    Calculate the Euclidean distance between two points.\n    Parameters:\n    point1 (tuple): A tuple (x, y) representing the coordinates of the first point.\n    point2 (tuple): A tuple (x, y) representing the coordinates of the second point.\n    Returns:\n    length (float): The length of the line segment between the two points.\n    Examples:\n    >>> line_length((1, 1), (4, 5))\n    5.0\n    \"\"\"\n    point1 = np.array(point1)\n    point2 = np.array(point2)\n    return np.linalg.norm(point1 - point2)"]], "Volume of Solids": [["def volume_of_cylinder(radius, height):\n    \"\"\"\n    Calculate the volume of a cylinder given the radius and height.\n    Parameters:\n    radius (float): The radius of the base of the cylinder.\n    height (float): The height of the cylinder.\n    Returns:\n    float: The volume of the cylinder.\n    Examples:\n    >>> volume_of_cylinder(2, 5)\n    62.83185307179586\n    \"\"\"\n    return math.pi * radius ** 2 * height", "def volume_of_cylinder(radius, height):\n    \"\"\"\n    Calculate the volume of a right circular cylinder given its radius and height.\n    Parameters:\n    radius (float): Radius of the cylinder's base.\n    height (float): Height of the cylinder.\n    Returns:\n    float: Volume of the cylinder.\n    Examples:\n    >>> volume_of_cylinder(3, 7)\n    197.92033717615698\n    \"\"\"\n    return math.pi * radius ** 2 * height", "def cylinder_volume(radius, height):\n    \"\"\"\n    Calculate the volume of a cylinder.\n    \n    Parameters:\n        radius (float): The radius of the cylinder\n        height (float): The height of the cylinder\n        \n    Returns:\n        float: The volume of the cylinder\n        \n    Example:\n        >>> cylinder_volume(3, 4)\n        113.09733552923255\n    \"\"\"\n    return math.pi * pow(radius, 2) * height", "def volume_cylinder(radius, height):\n    \"\"\"\n    Calculate the volume of a cylinder.\n    Parameters:\n    radius (float): Radius of the base of the cylinder.\n    height (float): Height of the cylinder.\n    Returns:\n    float: Volume of the cylinder.\n    Examples:\n    >>> volume_cylinder(1, 4)\n    12.566370614359172\n    \"\"\"\n    return pi * radius ** 2 * height", "def calculate_cylinder_volume(radius, height):\n    \"\"\"\n    Calculate the volume of a cylinder using the formula V = πr^2h.\n    \n    Parameters:\n    radius (float): The radius of the cylinder's base.\n    height (float): The height of the cylinder.\n    \n    Returns:\n    float: The volume of the cylinder.\n    \n    Example:\n    >>> calculate_cylinder_volume(2, 4)\n    50.26548245743669\n    \"\"\"\n    return math.pi * radius ** 2 * height", "def volume_cylinder(radius, height):\n    \"\"\"\n    Calculate the volume of a right circular cylinder given its radius and height.\n    Parameters:\n    radius (float): The radius of the base of the cylinder.\n    height (float): The height of the cylinder.\n    Returns:\n    float: The volume of the cylinder.\n    Examples:\n    >>> volume_cylinder(3, 5)\n    141.3716694115407\n    \"\"\"\n    return math.pi * radius ** 2 * height", "def volume_of_cylinder(radius, height):\n    \"\"\"\n    Calculate the volume of a right circular cylinder.\n    Parameters:\n    - radius (float or Symbol): The radius of the cylinder's base.\n    - height (float or Symbol): The height of the cylinder.\n    Returns:\n    - sympy expression: The calculated volume of the cylinder.\n    \n    Examples:\n    >>> r, h = symbols('r h')\n    >>> volume_of_cylinder(r, h)\n    π*r**2*h\n    \"\"\"\n    return pi * radius**2 * height", "def volume_of_cylinder(radius, height):\n    \"\"\"\n    Calculate the volume of a cylinder.\n    Parameters\n    ----------\n    radius : float\n        The radius of the base of the cylinder.\n    height : float\n        The vertical height of the cylinder.\n    Returns\n    -------\n    float\n        The volume of the cylinder.\n    Examples\n    --------\n    >>> volume_of_cylinder(3, 4)\n    113.09733552923255\n    \"\"\"\n    return math.pi * (radius ** 2) * height", "def volume_cylinder(radius, height):\n    \"\"\"\n    Calculates the volume of a cylinder.\n    \n    Parameters:\n    - radius (float): The radius of the cylinder's base.\n    - height (float): The height of the cylinder.\n    \n    Returns:\n    - float: The volume of the cylinder.\n    \n    Examples:\n    >>> volume_cylinder(3, 5)\n    141.3716694115407\n    \"\"\"\n    return math.pi * (radius ** 2) * height", "def cylinder_volume(radius, height):\n    \"\"\"\n    Calculate the volume of a cylinder given the radius and height.\n    \n    Parameters:\n    radius (float): The radius of the base of the cylinder.\n    height (float): The height of the cylinder.\n    \n    Returns:\n    float: The volume of the cylinder.\n    \n    Examples:\n    >>> cylinder_volume(2, 4)\n    50.26548245743669\n    \"\"\"\n    return math.pi * radius ** 2 * height", "def volume_cylinder(radius, height):\n    \"\"\"\n    Calculate the volume of a cylinder.\n    \n    Parameters:\n    radius (float): the radius of the cylinder's base.\n    height (float): the height of the cylinder.\n    \n    Returns:\n    float: the volume of the cylinder.\n    \n    Example:\n    >>> volume_cylinder(3, 5)\n    141.372\n    \"\"\"\n    return math.pi * radius**2 * height", "def volume_cylinder(radius, height):\n    \"\"\"\n    Calculate the volume of a right circular cylinder.\n    Parameters:\n        radius (float): the radius of the cylinder's base.\n        height (float): the height of the cylinder.\n    Returns:\n        float: the computed volume of the cylinder.\n    Examples:\n        >>> volume_cylinder(3, 5)\n        141.3716694115407\n    \"\"\"\n    return math.pi * radius ** 2 * height", "def volume_cylinder(radius, height):\n    \"\"\"\n    Calculates the volume of a cylinder given its radius and height.\n    Parameters:\n    - radius (float): The radius of the cylinder base.\n    - height (float): The height of the cylinder.\n    Returns:\n    - float: The volume of the cylinder.\n    Examples:\n    >>> volume_cylinder(2.0, 5.0)\n    62.83185307179586\n    \"\"\"\n    return math.pi * radius ** 2 * height", "def volume_fractional_cylinder(radius, height, fraction):\n    \"\"\"\n    Calculates the volume of a fractional part of a cylindrical shape given its full dimensions and the fraction.\n    Parameters:\n    - radius (float): The radius of the cylinder base.\n    - height (float): The height of the full cylinder.\n    - fraction (float): The fractional part of the cylinder to calculate (e.g., 0.25 for a quarter-cylinder).\n    Returns:\n    - float: The fractional volume of the cylinder.\n    Examples:\n    >>> volume_fractional_cylinder(2.0, 5.0, 0.25)\n    15.707963267948967\n    \"\"\"\n    return volume_cylinder(radius, height) * fraction"], ["def volume_of_sphere(radius):\n    \"\"\"\n    Calculate the volume of a sphere given its radius.\n    Parameters:\n    radius (float): Radius of the sphere.\n    Returns:\n    float: Volume of the sphere.\n    Examples:\n    >>> volume_of_sphere(5)\n    523.5987755982989\n    \"\"\"\n    return (4.0 / 3.0) * math.pi * radius ** 3", "def hemisphere_volume(radius):\n    \"\"\"\n    Calculate the volume of a hemisphere.\n    \n    Parameters:\n        radius (float): The radius of the hemisphere.\n        \n    Returns:\n        float: The volume of the hemisphere.\n        \n    Example:\n        >>> hemisphere_volume(3)\n        56.54866776461628\n    \"\"\"\n    return (2/3) * math.pi * pow(radius, 3)", "def volume_of_sphere(radius):\n    \"\"\"\n    Calculate the volume of a sphere given its radius.\n    Parameters:\n    - radius: The radius of the sphere (float or int).\n    Returns:\n    - The volume of the sphere (float).\n    Example:\n    >>> volume_of_sphere(5)\n    523.5987755982989\n    \"\"\"\n    return (4/3) * math.pi * radius**3", "def volume_sphere(radius):\n    \"\"\"\n    Calculate the volume of a sphere.\n    Parameters:\n    radius (float): Radius of the sphere.\n    Returns:\n    float: Volume of the sphere.\n    Examples:\n    >>> volume_sphere(2)\n    33.510321638291124\n    \"\"\"\n    return (4.0 / 3.0) * pi * radius ** 3", "def volume_sphere(radius):\n    \"\"\"\n    Calculate the volume of a sphere given its radius.\n    Parameters:\n    radius (float): The radius of the sphere.\n    Returns:\n    float: The volume of the sphere.\n    Examples:\n    >>> volume_sphere(3)\n    113.09733552923255\n    \"\"\"\n    return (4.0/3.0) * math.pi * radius ** 3", "def volume_sphere(radius):\n    \"\"\"\n    Calculate the volume of a sphere given its radius.\n    Parameters:\n    radius (float): The radius of the sphere.\n    Returns:\n    float: The volume of the sphere.\n    Examples:\n    >>> volume_sphere(3)\n    113.09733552923255\n    \"\"\"\n    return (4/3) * math.pi * (radius ** 3)", "def sphere_radius_from_volume(volume):\n    \"\"\"\n    Calculate the radius of a sphere from its volume.\n    Parameters:\n    volume (float): The volume of the sphere.\n    Returns:\n    float: The radius of the sphere.\n    Examples:\n    >>> sphere_radius_from_volume(113.09733552923255)\n    3.0\n    \"\"\"\n    return ((3 * volume) / (4 * math.pi)) ** (1/3)", "def volume_sphere(radius):\n    \"\"\"\n    Calculates the volume of a sphere.\n    \n    Parameters:\n    - radius (float): The radius of the sphere.\n    \n    Returns:\n    - float: The volume of the sphere.\n    \n    Examples:\n    >>> volume_sphere(2)\n    33.510321638291124\n    \"\"\"\n    return (4/3) * math.pi * (radius ** 3)", "def volume_hemisphere(radius):\n    \"\"\"\n    Calculate the volume of a hemisphere.\n    \n    Parameters:\n    radius (float): the radius of the hemisphere.\n    \n    Returns:\n    float: the volume of the hemisphere.\n    \n    Example:\n    >>> volume_hemisphere(3)\n    56.549\n    \"\"\"\n    return 2/3 * math.pi * radius**3", "def volume_sphere(radius):\n    \"\"\"\n    Calculate the volume of a sphere.\n    Parameters:\n        radius (float): the radius of the sphere.\n    Returns:\n        float: the computed volume of the sphere.\n    Examples:\n        >>> volume_sphere(3)\n        113.09733552923255\n    \"\"\"\n    return (4/3) * math.pi * (radius ** 3)", "def volume_sphere(radius):\n    \"\"\"\n    Calculates the volume of a sphere given its radius.\n    Parameters:\n    - radius (float): The radius of the sphere.\n    Returns:\n    - float: The volume of the sphere.\n    Examples:\n    >>> volume_sphere(3.0)\n    113.09733552923254\n    \"\"\"\n    return (4/3) * math.pi * radius ** 3"], ["def volume_tetrahedron_from_vertices(A, B, C, D):\n    \"\"\"\n    Calculate the volume of a tetrahedron given the vertices A, B, C, and D.\n    Parameters:\n    - A, B, C, D (tuple or list): Coordinates of the vertices A, B, C, and D, each should be in the form of (x, y, z).\n    \n    Returns:\n    - float: Volume of the tetrahedron.\n    \n    Example:\n    >>> volume_tetrahedron_from_vertices((0,0,0), (1,0,0), (0,1,0), (0,0,1))\n    0.16666666666666666\n    Note:\n    The function uses numpy for calculating the determinant, which is central to the volume calculation using vertices.\n    The formula used is based on 1/6 times the absolute value of the determinant of the matrix formed from vectors AB, AC, and AD.\n    \"\"\"\n    # Convert tuples/lists to numpy arrays\n    A = np.array(A)\n    B = np.array(B)\n    C = np.array(C)\n    D = np.array(D)\n    \n    # Create vectors from point A to B, C, and D\n    AB = B - A\n    AC = C - A\n    AD = D - A\n    \n    # Prepare the matrix from vectors AB, AC, AD\n    matrix = np.array([AB, AC, AD]).T\n    \n    # Compute the determinant of the matrix\n    det = np.linalg.det(matrix)\n    \n    # Calculate volume (1/6 times the absolute value of the determinant)\n    volume = np.abs(det) / 6\n    \n    return volume", "def volume_of_tetrahedron_from_vertices(v1, v2, v3, v4):\n    \"\"\"\n    Calculate the volume of a tetrahedron given the coordinates of its vertices.\n    \n    Parameters:\n        v1, v2, v3, v4 (tuple or list):\n        Coordinates of the vertices of the tetrahedron.\n        Each should be in the form (x, y, z).\n    \n    Returns:\n        float: The volume of the tetrahedron.\n    \n    Examples:\n        >>> v1 = (0, 0, 0)\n        >>> v2 = (1, 0, 0)\n        >>> v3 = (0, 1, 0)\n        >>> v4 = (0, 0, 1)\n        >>> volume_of_tetrahedron_from_vertices(v1, v2, v3, v4)\n        0.16666666666666666\n    \"\"\"\n    matrix = np.array([\n        [v2[0] - v1[0], v3[0] - v1[0], v4[0] - v1[0]],\n        [v2[1] - v1[1], v3[1] - v1[1], v4[1] - v1[1]],\n        [v2[2] - v1[2], v3[2] - v1[2], v4[2] - v1[2]]\n    ])\n    return abs(np.linalg.det(matrix) / 6)", "def volume_of_tetrahedron_from_vertices(v1, v2, v3, v4):\n    \"\"\"\n    Calculate the volume of a tetrahedron given the coordinates of its vertices.\n    \n    Parameters:\n    - v1, v2, v3, v4 (array-like): Coordinates of the vertices of the tetrahedron.\n                                   Each should be an iterable of length 3 (x, y, z coordinates).\n    \n    Returns:\n    - float: The volume of the tetrahedron.\n    \n    Example:\n    >>> volume_of_tetrahedron_from_vertices([0,0,0], [1,0,0], [0,1,0], [0,0,1])\n    0.16666666666666666\n    \"\"\"\n    matrix = np.array([\n        [v1[0]-v4[0], v1[1]-v4[1], v1[2]-v4[2]],\n        [v2[0]-v4[0], v2[1]-v4[1], v2[2]-v4[2]],\n        [v3[0]-v4[0], v3[1]-v4[1], v3[2]-v4[2]]\n    ])\n    return abs(np.linalg.det(matrix) / 6)"], ["def volume_of_rectangular_prism(length, width, height):\n    \"\"\"\n    Calculate the volume of a rectangular prism (rectangular solid).\n    Parameters:\n    length (float or int): Length of the rectangular prism.\n    width (float or int): Width of the rectangular prism.\n    height (float or int): Height of the rectangular prism.\n    Returns:\n    float: The volume of the rectangular prism.\n    Examples:\n    >>> volume_of_rectangular_prism(10, 5, 2)\n    100.0\n    >>> volume_of_rectangular_prism(7.5, 3.2, 1.5)\n    36.0\n    \"\"\"\n    return length * width * height", "def rectangular_prism_volume(length, width, height):\n    \"\"\"\n    Calculate the volume of a rectangular prism.\n    \n    Parameters:\n        length (float): The length of the prism.\n        width (float): The width of the prism.\n        height (float): The height of the prism.\n    \n    Returns:\n        float: The volume of the rectangular prism.\n    \n    Example:\n        >>> rectangular_prism_volume(3, 4, 5)\n        60.0\n    \"\"\"\n    return length * width * height", "def volume_of_rectangular_prism(length, width, height):\n    \"\"\"\n    Calculate the volume of a rectangular prism.\n    Parameters:\n    - length: The length of the prism (float or int).\n    - width: The width of the prism (float or int).\n    - height: The height of the prism (float or int).\n    Returns:\n    - The volume of the rectangular prism (float).\n    Example:\n    >>> volume_of_rectangular_prism(2, 3, 4)\n    24\n    \"\"\"\n    return length * width * height", "def calculate_volume(length, width, height):\n    \"\"\"\n    Calculates the volume of a rectangular prism.\n    \n    Parameters:\n    - length (float): The length of the rectangular prism.\n    - width (float): The width of the rectangular prism.\n    - height (float): The height of the rectangular prism.\n    \n    Returns:\n    - float: The volume of the rectangular prism.\n    Example:\n    >>> calculate_volume(2.0, 3.0, 4.0)\n    24.0\n    \"\"\"\n    return length * width * height", "def calculate_volume(length, width, height):\n    \"\"\"\n    Calculate the volume of a rectangular solid given its dimensions.\n    Parameters:\n    - length (float): the length of the rectangular solid.\n    - width (float): the width of the rectangular solid.\n    - height (float): the height of the rectangular solid.\n    Returns:\n    - float: the calculated volume of the rectangular solid.\n    Example:\n    >>> calculate_volume(3.0, 4.0, 5.0)\n    60.0\n    \"\"\"\n    return length * width * height", "def volume_rectangular_prism(length, width, height):\n    \"\"\"\n    Calculate the volume of a rectangular prism given its dimensions.\n    Parameters:\n    length (float): The length of the prism.\n    width (float): The width of the prism.\n    height (float): The height of the prism.\n    Returns:\n    float: The volume of the rectangular prism.\n    Examples:\n    >>> volume_rectangular_prism(2, 3, 4)\n    24\n    \"\"\"\n    return length * width * height", "def calculate_volume_rectangular_prism(length, width, height):\n    \"\"\"\n    Calculate the volume of a rectangular prism.\n    \n    Parameters:\n    length (float): the length of the rectangular prism.\n    width (float): the width of the rectangular prism.\n    height (float): the height of the rectangular prism.\n    \n    Returns:\n    float: The volume of the rectangular prism.\n    \n    Examples:\n    >>> calculate_volume_rectangular_prism(2, 3, 4)\n    24\n    >>> calculate_volume_rectangular_prism(5.5, 3.2, 1.7)\n    29.92\n    \"\"\"\n    return length * width * height", "def calculate_volume_rectangular_prism(length, width, height):\n    \"\"\"\n    Calculates the volume of a rectangular prism given its three dimensions: length, width, and height.\n    Parameters:\n    - length (float): The length of the rectangular prism.\n    - width (float): The width of the rectangular prism.\n    - height (float): The height of the rectangular prism.\n    Returns:\n    - float: The calculated volume of the rectangular prism.\n    Example:\n    >>> calculate_volume_rectangular_prism(8, 3, 5)\n    120.0\n    \"\"\"\n    return length * width * height", "def volume_of_rectangular_solid(length, width, height):\n    \"\"\"\n    Calculate the volume of a rectangular solid (rectangular prism).\n    Parameters:\n    - length (float): the length of the solid\n    - width (float): the width of the solid\n    - height (float): the height of the solid\n    Returns:\n    - float: the volume of the solid\n    Examples:\n    >>> volume_of_rectangular_solid(3.0, 4.0, 5.0)\n    60.0\n    \"\"\"\n    return length * width * height", "def volume_of_rectangular_prism(length, width, height):\n    \"\"\"\n    Calculate the volume of a rectangular prism.\n    Parameters\n    ----------\n    length : float or int\n        The length of the rectangular prism.\n    width : float or int\n        The width of the rectangular prism.\n    height : float or int\n        The height of the rectangular prism.\n    Returns\n    -------\n    float\n        The volume of the rectangular prism.\n    Examples\n    --------\n    >>> volume_of_rectorphic_prism(2, 3, 4)\n    24.0\n    \"\"\"\n    # Calculate the volume of the prism\n    return length * width * height", "def calculate_rect_prism_volume(length, width, height):\n    \"\"\"\n    Calculate the volume of a rectangular prism.\n    Parameters:\n    - length (float) : the length of the rectangular prism.\n    - width (float) : the width of the rectangular prism.\n    - height (float) : the height of the rectangular prism.\n    Returns:\n    - float: The calculated volume of the rectangular prism.\n    Examples:\n    >>> calculate_rect_prism_volume(3, 4, 5)\n    60.0\n    >>> calculate_rect_prism_volume(10.5, 3.2, 4.1)\n    137.32\n    \"\"\"\n    return length * width * height"], ["def volume_of_cube(side_length):\n    \"\"\"\n    Calculate the volume of a cube given the side length.\n    Parameters:\n    side_length (float): The length of a side of the cube.\n    Returns:\n    float: The volume of the cube.\n    Examples:\n    >>> volume_of_cube(3)\n    27\n    \"\"\"\n    return side_length ** 3", "def side_length_from_volume(volume):\n    \"\"\"\n    Calculate the side length of a cube from a given volume.\n    Parameters:\n    volume (float): The volume of the cube.\n    Returns:\n    float: The side length of the cube.\n    Examples:\n    >>> side_length_from_volume(27)\n    3\n    \"\"\"\n    return math.cube(volume)", "def volume_of_cube(side_length):\n    \"\"\"\n    Calculate the volume of a cube given its side length.\n    Parameters:\n    side_length (float): Length of one side of the cube.\n    Returns:\n    float: Volume of the cube.\n    Examples:\n    >>> volume_of_cube(4)\n    64\n    \"\"\"\n    return side_length ** 3", "def volume_cube(side_length):\n    \"\"\"\n    Calculate the volume of a cube.\n    Parameters:\n    side_length (float): The length of a side of the cube.\n    Returns:\n    float: Volume of the cube.\n    Examples:\n    >>> volume_cube(3)\n    27\n    \"\"\"\n    return side_length ** 3", "def calculate_cube_volume(side_length):\n    \"\"\"\n    Calculate the volume of a cube using the formula V = s^3.\n    \n    Parameters:\n    side_length (float): The length of a side of the cube.\n    \n    Returns:\n    float: The volume of the cube.\n    \n    Example:\n    >>> calculate_cube_volume(3)\n    27.0\n    \"\"\"\n    return side_length**3", "def side_length_from_cube_volume(volume):\n    \"\"\"\n    Calculate the side length of a cube given its volume using the formula s = (V)^(1/3).\n    \n    Parameters:\n    volume (float): The volume of the cube.\n    \n    Returns:\n    float: The side length of the cube.\n    \n    Example:\n    >>> side_length_from_cube_volume(27)\n    3.0\n    \"\"\"\n    return volume ** (1/3)", "def volume_cube(side):\n    \"\"\"\n    Calculate the volume of a cube given the length of its side.\n    Parameters:\n    side (float): The length of a side of the cube.\n    Returns:\n    float: The volume of the cube.\n    Examples:\n    >>> volume_cube(3)\n    27\n    \"\"\"\n    return side ** 3", "def volume_cube(side_length):\n    \"\"\"\n    Calculates the volume of a cube.\n    \n    Parameters:\n    - side_length (float): The length of each side of the cube.\n    \n    Returns:\n    - float: The volume of the cube.\n    \n    Examples:\n    >>> volume_cube(3)\n    27\n    \"\"\"\n    return side_length ** 3", "def cube_volume(side_length):\n    \"\"\"\n    Calculate the volume of a cube given the side length.\n    \n    Parameters:\n    side_length (float): The length of a side of the cube.\n    \n    Returns:\n    float: The volume of the cube.\n    \n    Examples:\n    >>> cube_volume(3)\n    27.0\n    \"\"\"\n    return side_length ** 3", "def cube_side_from_volume(volume):\n    \"\"\"\n    Calculate the side length of a cube from its volume.\n    \n    Parameters:\n    volume (float): The volume of the cube.\n    \n    Returns:\n    float: The side length of the cube.\n    \n    Examples:\n    >>> cube_side_from_volume(27)\n    3.0\n    \"\"\"\n    return math.cube(volume)", "def volume_cube(side_length):\n    \"\"\"\n    Calculates the volume of a cube given its side length.\n    Parameters:\n    - side_length (float): The length of each side of the cube.\n    Returns:\n    - float: The volume of the cube.\n    Examples:\n    >>> volume_cube(3.0)\n    27.0\n    \"\"\"\n    return side_length ** 3"], ["def calculate_volume(shape_type, dimensions):\n    \"\"\"\n    Calculate the volume of various geometric solids based on given parameters.\n    \n    Parameters:\n        shape_type (str): Type of shape (\"sphere\", \"rectangular_prism\", \"cube\", \"octahedron\")\n        dimensions (dict): A dictionary containing the required dimensions:\n                           For a sphere: {'radius': r}\n                           For a rectangular prism: {'length': l, 'width': w, 'height': h}\n                           For a cube: {'edge_length': a}\n                           For an octahedron: {'edge_length': a}\n    Returns:\n        float: The volume of the geometric solid.\n    \n    Examples:\n        calculate_volume(\"sphere\", {\"radius\": 3})\n        calculate_volume(\"rectangular_prism\", {\"length\": 5, \"width\": 3, \"height\": 2})\n        calculate_volume(\"cube\", {\"edge_length\": 4})\n        calculate_volume(\"octahedron\", {\"edge_length\": 5})\n    \"\"\"\n    if shape_type == \"sphere\":\n        radius = dimensions[\"radius\"]\n        return (4/3) * math.pi * radius ** 3\n    elif shape_type == \"rectangular_prism\":\n        length = dimensions[\"length\"]\n        width = dimensions[\"width\"]\n        height = dimensions[\"height\"]\n        return length * width * height\n    elif shape_type == \"cube\":\n        edge_length = dimensions[\"edge_length\"]\n        return edge_length ** 3\n    elif shape_type == \"octahedron\":\n        edge_length = dimensions[\"edge_length\"]\n        return (math.sqrt(2) / 3) * edge_length ** 3\n    else:\n        raise ValueError(\"Invalid shape type provided\")", "def find_dimension_from_volume(shape_type, volume):\n    \"\"\"\n    Find the key dimension (radius or edge length) from the volume of basic geometric shapes.\n    Parameters:\n        shape_type (str): Type of shape (\"sphere\", \"cube\", \"octahedron\")\n        volume (float): The volume for which to find the dimension.\n    Returns:\n        float: The radius or edge length corresponding to the given volume.\n    Examples:\n        find_dimension_from_volume(\"sphere\", 113.097)\n        find_dimension_from_volume(\"cube\", 64)\n        find_dimension_from_volume(\"octahedron\", 117.851)\n    \"\"\"\n    if shape_type == \"sphere\":\n        return ((3 * volume) / (4 * math.pi)) ** (1/3)\n    elif shape_type == \"cube\":\n        return volume ** (1/3)\n    elif shape_type == \"octahedron\":\n        return (3 * volume / (math.sqrt(2))) ** (1/3)\n    else:\n        raise ValueError(\"Invalid shape type or operation not supported for the given shape\")"], ["def area_square(side):\n    \"\"\"\n    Compute the area of a square given the side length.\n    Parameters:\n    side (float): The length of one side of the square.\n    Returns:\n    float: The area of the square.\n    Example:\n    >>> area_square(4)\n    16\n    \"\"\"\n    return side ** 2", "def square_area(side_length):\n    \"\"\"\n    Calculate the area of a square given its side length.\n    Parameters:\n        side_length (float): The length of the sides of the square.\n    Returns:\n        float: The area of the square.\n    Example:\n        >>> square</span>Area(10)\n        100.0\n    \"\"\"\n    return side_length ** 2"], ["def volume_of_regular_octahedron(edge_length):\n    \"\"\"\n    Calculate the volume of a regular octahedron given its edge length.\n    Parameters:\n    - edge_length: The length of an edge of the octahedron (float or int).\n    Returns:\n    - The volume of the regular octahedron (float).\n    Example:\n    >>> volume_of_regular_octahedron(3)\n    3.181980515339464\n    \"\"\"\n    return (1/3) * math.sqrt(2) * edge_length**3", "def volume_tetrahedron(edge_length):\n    \"\"\"\n    Calculate the volume of a regular tetrahedron.\n    Parameters:\n        edge_length (float): the length of one edge of the tetrahedron.\n    Returns:\n        float: the computed volume of the tetrahedron.\n    Examples:\n        >>> volume_tetrahedron(3)\n        3.181980515339464\n    \"\"\"\n    return (edge_length ** 3) / (6 * math.sqrt(2))"], ["def volume_of_cube(edge_length):\n    \"\"\"\n    Calculate the volume of a cube given its edge length.\n    Parameters:\n    - edge_length: The length of an edge of the cube (float or int).\n    Returns:\n    - The volume of the cube (float).\n    Example:\n    >>> volume_of_cube(3)\n    27\n    \"\"\"\n    return edge_length ** 3", "def volume_cube(edge_length):\n    \"\"\"\n    Calculate the volume of a cube given its edge length.\n    Parameters:\n    edge_length (float): The edge length of the cube.\n    Returns:\n    float: The volume of the cube.\n    Examples:\n    >>> volume_cube(2)\n    8\n    \"\"\"\n    return edge_length ** 3", "def cube_edge_from_volume(volume):\n    \"\"\"\n    Calculate the edge length of a cube from its volume.\n    Parameters:\n    volume (float): The volume of the cube.\n    Returns:\n    float: The edge length of the cube.\n    Examples:\n    >>> cube_edge_from_volume(8)\n    2.0\n    \"\"\"\n    return math.pow(volume, 1/3)"], ["def scale_cylinder_volume(radius, height, scaling_factor):\n    \"\"\"\n    Calculate the volume of a cylinder under a scaling transformation affecting all dimensions.\n    \n    Parameters:\n        radius (float): Original radius of the cylinder.\n        height (float): Original height of the cylinder.\n        scaling_factor (float): Scaling factor applied uniformly to all dimensions.\n        \n    Returns:\n        float: The scaled volume of the cylinder.\n        \n    Example:\n        >>> scale_cylinder_volume(3, 4, 2)\n        904.7782701178602\n    \"\"\"\n    new_radius = scaling_factor * radius\n    new_height = scaling_factor * height\n    return cylinder_volume(new_radius, new_height)", "def scale_volume(original_radius, scale_factor_radius, original_height, scale_factor_height, shape='cylinder'):\n    \"\"\"\n    Calculate the new volume after scaling the dimensions of a geometric solid.\n    \n    Parameters:\n    - original_radius (float): The original radius of the solid.\n    - scale_factor_radius (float): The factor by which the radius is scaled.\n    - original_height (float): The original height of the solid. Not used for hemispheres.\n    - scale_factor_height (float): The factor by which the height is scaled.\n    - shape (str): The type of geometric solid ('cylinder', 'hemisphere', 'cone').\n    Returns:\n    - float: The new volume after scaling.\n    Examples:\n    - scale_volume(5, 2, 10, 2)\n      # Returns: 3141.592653589793 (New volume of a cylinder when both radius and height are doubled)\n    - scale_material(3, 1.5, None, None, 'hemisphere')\n      # Returns: 254.46900494077323 (New volume of a hemisphere when the radius is scaled by 1.5)\n    \"\"\"\n    new_radius = original_radius * scale_factor_radius\n    if shape != 'hemisphere':\n        new_height = original_height * scale_factor_height\n        return calculate_volume(shape, new_radius, new_height)\n    else:\n        return calculate_volume(shape, new_radius)", "def volume_scaling_cylinder(original_radius, original_height, scale_factor):\n    \"\"\"\n    Calculate the new volume of a cylinder after scaling dimensions.\n    \n    Parameters:\n    original_radius (float): the original radius of the cylinder.\n    original_height (float): the original height of the cylinder.\n    scale_factor (float): how much to scale the dimensions by.\n    \n    Returns:\n    float: the new volume of the cylinder after scaling.\n    \n    Example:\n    >>> volume_scaling_cylinder(3, 5, 2)\n    1130.973\n    \"\"\"\n    new_radius = original_radius * scale_factor\n    new_height = original_height * scalewarzctor\n    return volume_cylinder(new_radius, new_height)"], ["def calculate_truncated_cone_volume(radius_a, height_a, radius_b, height_b):\n    \"\"\"\n    Calculate the volume of a truncated cone given the dimensions of the full cone and the smaller cone to be removed.\n    \n    Parameters:\n        radius_a (float): The radius of the base of the full cone.\n        height_a (float): The height of the full cone.\n        radius_b (float): The radius of the base of the smaller cone to be removed.\n        height_b (float): The height of the smaller cone to be removed.\n        \n    Returns:\n        float: The volume of the truncated cone.\n        \n    Examples:\n    >>> calculate_truncated_cone_volume(5, 10, 3, 6)\n    271.5384612558714\n    \"\"\"\n    full_cone_volume = calculate_cone_volume(radius_a, height_a)\n    small_cone_volume = calculate_cone_volume(radius_b, height_b)\n    return full_cone_volume - small_cone_volume", "def calculate_truncated_cone_volume(radius1, height1, radius2, height2):\n    \"\"\"\n    Calculate the volume of a truncated cone using the dimensions of the full cone and the smaller (removed) cone.\n    Parameters:\n    radius1 (float): Radius of the full cone at the base.\n    height1 (float): Height of the full cone.\n    radius2 (float): Radius of the smaller (cut-off top) cone at its base (at the cut).\n    height2 (float): Height at which the smaller cone is cut off.\n    Returns:\n    float: The volume of the truncated cone.\n    Example:\n    >>> calculate_truncated_cone_volume(5, 10, 2, 4)\n    483.77878696928923\n    \"\"\"\n    volume_full = (1/3) * math.pi * radius1**2 * height1\n    volume_small = (1/3) * math.pi * radius2**2 * height2\n    return volume_full - volume_small", "def volume_of_truncated_cone(upper_radius, lower_radius, height):\n    \"\"\"\n    Calculate the volume of a truncated cone given the radii of the top and bottom bases and the height.\n    This is achieved by subtracting the volume of the smaller cone (upper part) from the larger full cone volume.\n    Parameters:\n    upper_radius (float): The radius of the upper base of the truncated cone (smaller radius).\n    lower_radius (float): The radius of the lower base of the truncated cone (larger radius).\n    height (float): The vertical height of the truncated cone.\n    Returns:\n    float: The volume of the truncated cone.\n    Examples:\n    >>> volume_of_truncated_cone(1, 3, 4)\n    35.22071741263713  # Compute volumes of two cones and subtract the smaller from the larger\n    \"\"\"\n    full_cone_volume = volume_of_cone(lower_radius, height)\n    # Subtract volume of upper part, extrapolated from similar triangles proportion\n    truncated_height = height * (lower_radius - upper_radius) / lower_radius\n    upper_cone_volume = volume_of_cone(upper_radius, truncated_height)\n    return full_cone_volume - upper_cone_volume"], ["def volume_ratio(volume1, volume2):\n    \"\"\"\n    Calculate the ratio of two volumes.\n    Parameters:\n    - volume1: The first volume (float or int).\n    - volume2: The second volume (float or int).\n    Returns:\n    - The ratio of volume1 to volume2 (float).\n    Example:\n    >>> volume_ratio(100, 50)\n    2.0\n    \"\"\"\n    return volume1 / volume2", "def volume_ratio(volume1, volume2):\n    \"\"\"\n    Calculate the ratio of two volumes.\n    \n    Parameters:\n    - volume1 (float): The volume of the first solid.\n    - volume2 (float): The volume of the second solid.\n    \n    Returns:\n    - float: The ratio of the first volume to the second volume.\n    \n    Examples:\n    - volume_ratio(523.6, 130.9)  # Ratio between two volumes\n    \"\"\"\n    return volume1 / volume2"], ["def calculate_pyramid_volume(base_area, height):\n    \"\"\"\n    Calculate the volume of a pyramid given the area of the base and the height from the base to the apex.\n    Parameters:\n    base_area (float): The area of the pyramid's base.\n    height (float): The vertical height from the base to the apex of the pyramid.\n    Returns:\n    float: The volume of the pyramid.\n    Example:\n    >>> calculate_pyramid_volume(10, 15)\n    50.0\n    \"\"\"\n    return (base_area * height) / 3", "def pyramid_volume(base_area, height):\n    \"\"\"\n    Calculate the volume of a pyramid given the area of the base and the height from the base to the apex.\n    Parameters:\n    base_area (float): The area of the pyramid's base.\n    height (float): The height from the base to the apex.\n    \n    Returns:\n    float: The volume of the pyramid.\n    Example:\n    >>> pyramid_volume(10, 15)\n    50.0\n    \"\"\"\n    return (1/3) * base_area * height", "def volume_of_pyramid(base_area, height):\n    \"\"\"\n    Calculate the volume of a pyramid given the area of its base and height.\n    Parameters:\n    - base_area (float or Symbol): The area of the pyramid's base.\n    - height (float or Symbol): The height of the pyramid from the base to the apex.\n    Returns:\n    - sympy expression: The calculated volume of the pyramid.\n    Examples:\n    >>> b, h = symbols('b h')\n    >>> volume_of_pyramid(b, h)\n    b*h/3\n    \"\"\"\n    return base_area * height / 3", "def pyramid_volume(base_area, height):\n    \"\"\"\n    Calculate the volume of a pyramid with a given base area and height.\n    Parameters:\n        base_area (float): The area of the pyramid's base.\n        height (float): The height of the pyramid, which is the perpendicular distance from the base to the apex.\n    Returns:\n        float: The volume of the pyramid.\n    Example:\n        >>> pyramid_volume(100, 20)\n        666.6666666666666\n    \"\"\"\n    return (base_area * height) / 3.0", "def volume_pyramid(base_area, height):\n    \"\"\"\n    Calculate the volume of a pyramid.\n    Parameters:\n        base_area (float): the area of the pyramid's base.\n        height (float): the height of the pyramid from the base to the apex.\n    Returns:\n        float: the computed volume of the pyramid.\n    Examples:\n        >>> volume_pyramid(10, 3)\n        10.0\n    \"\"\"\n    return (1/3) * base_area * height"], ["def compare_volumes(radius1, height1, radius2, height2):\n    \"\"\"\n    Compare the volumes of two cylinders and return the ratio of the first to the second.\n    \n    Parameters:\n    radius1 (float): radius of the first cylinder.\n    height1 (float): height of the first cylinder.\n    radius2 (float): radius of the second cylinder.\n    height2 (float): height of the second cylinder.\n    \n    Returns:\n    float: the ratio of the volume of the first cylinder to the second.\n    \n    Example:\n    >>> compare_volumes(3, 5, 2, 4)\n    1.766\n    \"\"\"\n    volume1 = volume_cylinder(radius1, height1)\n    volume2 = volume_cylinder(radius2, height2)\n    return volume1 / volume2"], ["def surface_area_of_rectangular_prism(length, width, height):\n    \"\"\"\n    Calculate the surface area of a rectangular prism.\n    Parameters:\n    length (float or int): Length of the rectangular prism.\n    width (float or int): Width of the rectangular prism.\n    height (float or int): Height of the rectangular prism.\n    Returns:\n    float: The surface area of the rectangular prism.\n    Examples:\n    >>> surface_area_of_rectangular_prism(10, 4, 5)\n    220.0\n    >>> surface_area_of_rectangular_prism(7.5, 3.5, 1.5)\n    82.5\n    \"\"\"\n    return 2 * (length * width + width * height + height * length)", "def surface_area_of_rectangular_solid(length, width, height):\n    \"\"\"\n    Calculate the surface area of a rectangular solid (rectangular prism).\n    Parameters:\n    - length (float): the length of the solid\n    - width (float): the width of the solid\n    - height (float): the height of the solid\n    Returns:\n    - float: the surface area of the solid\n    Examples:\n    >>> surface_area_of_rectangular_solid(3.0, 4.0, 5.0)\n    94.0\n    \"\"\"\n    lw = length * width\n    lh = length * height\n    wh = width * height\n    return 2 * (lw + lh + wh)"], ["def volume_tetrahedron_from_base_area_height(base_area, height):\n    \"\"\"\n    Calculate the volume of a tetrahedron given the area of the base and the height from the base to the opposite vertex.\n    Parameters:\n    - base_area (float): The area of the base of the tetrahedron.\n    - height (float): The perpendicular height from the base to the opposite vertex.\n    \n    Returns:\n    - float: Volume of the tetrahedron.\n    Example:\n    >>> volume_tetrahedron_from_base_area_height(2.0, 3.0)\n    2.0\n    Note:\n    The volume of a tetrahedron is given by (1/3) * base_area * height.\n    \"\"\"\n    return (1/3) * base_area * height", "def volume_of_tetrahedron_from_base_and_height(base_area, height):\n    \"\"\"\n    Calculate the volume of a tetrahedron from the area of its base and its height.\n    \n    Parameters:\n        base_area (float): The area of the base of the tetrahedron.\n        height (float): The height from the base to the opposite vertex.\n    \n    Returns:\n        float: The volume of the tetrahedron.\n    \n    Examples:\n        >>> base_area = 0.5\n        >>> height = 1\n        >>> volume_of_tetrahedron_from_base_and_height(base_area, height)\n        0.16666666666666666\n    \"\"\"\n    return (1/3) * base_area * height", "def volume_of_tetrahedron_from_base_and_height(base_area, height):\n    \"\"\"\n    Calculate the volume of a tetrahedron given the base area and height.\n    \n    Parameters:\n    - base_area (float): The area of the base of the tetrahedron.\n    - height (float): The height from the base to the opposite vertex.\n    \n    Returns:\n    - float: The volume of the tetrahedron.\n    \n    Example:\n    >>> volume_of_tetrahedron_from_base_and_height(10, 15)\n    50.0\n    \"\"\"\n    return (1/3) * base_area * height"], ["def volume_rectangular_parallelepiped(length, width, height):\n    \"\"\"\n    Calculates the volume of a rectangular parallelepiped (box).\n    \n    Parameters:\n    - length (float): Length of the parallelepiped.\n    - width (float): Width of the parallelepiped.\n    - height (float): Height of the parallelepiped.\n    \n    Returns:\n    - float: The volume of the rectangular parallelepiped.\n    \n    Examples:\n    >>> volume_rectangular_parallelepiped(2, 3, 4)\n    24\n    \"\"\"\n    return length * width * height", "def volume_parallelepiped(length, width, height):\n    \"\"\"\n    Calculates the volume of a rectangular parallelepiped given its dimensions.\n    Parameters:\n    - length (float): The length of the parallelepiped.\n    - width (float): The width of the parallelepiped.\n    - height (float): The height of the parallelepiped.\n    Returns:\n    - float: The volume of the parallelepiped.\n    Examples:\n    >>> volume_parallelepiped(2.0, 3.0, 4.0)\n    24.0\n    \"\"\"\n    return length * width * height"], ["def volume_of_cone(radius, height):\n    \"\"\"\n    Calculate the volume of a cone given its base radius and height.\n    Parameters:\n    radius (float): Radius of the cone's base.\n    height (float): Height of the cone.\n    Returns:\n    float: Volume of the cone.\n    Examples:\n    >>> volume_of_cone(3, 9)\n    84.82300164692441\n    \"\"\"\n    return (1/3) * math.pi * radius ** 2 * height", "def cone_volume(radius, height):\n    \"\"\"\n    Calculate the volume of a cone.\n    \n    Parameters:\n        radius (float): The radius of the cone.\n        height (float): The height of the cone.\n    \n    Returns:\n        float: The volume of the cone.\n    \n    Example:\n        >>> cone_volume(3, 4)\n        37.69911184307752\n    \"\"\"\n    return (1/3) * math.pi * pow(radius, 2) * height", "def calculate_cone_volume(radius, height):\n    \"\"\"\n    Calculate the volume of a cone given the radius and height.\n    \n    Parameters:\n        radius (float): The radius of the base of the cone.\n        height (float): The height of the cone.\n        \n    Returns:\n        float: The volume of the cone.\n        \n    Examples:\n    >>> calculate_cone_volume(3, 4)\n    37.69911184307752\n    \"\"\"\n    return (1/3) * math.pi * radius**2 * height", "def volume_cone(radius, height):\n    \"\"\"\n    Calculate the volume of a cone given its base radius and height.\n    Parameters:\n    radius (float): The radius of the base of the cone.\n    height (float): The height of the cone.\n    Returns:\n    float: The volume of the cone.\n    Examples:\n    >>> volume_cone(3, 5)\n    47.12388980384689\n    \"\"\"\n    return (1/3) * math.pi * radius ** 2 * height", "def calculate_cone_volume(radius, height):\n    \"\"\"\n    Calculate the volume of a cone.\n    Parameters:\n    radius (float): The radius of the base of the cone.\n    height (float): The height of the cone from its base to the tip.\n    Returns:\n    float: The volume of the cone.\n    Example:\n    >>> calculate_cone_volume(3, 4)\n    37.69911184307752\n    \"\"\"\n    return (1/3) * math.pi * radius**2 * height", "def volume_of_cone(radius, height):\n    \"\"\"\n    Calculate the volume of a cone.\n    Parameters\n    ----------\n    radius : float\n        The radius of the base of the cone.\n    height : float\n        The vertical height of the cone.\n    Returns\n    -------\n    float\n        The volume of the cone.\n    Examples\n    --------\n    >>> volume_of_cone(3, 4)\n    37.69911184307752\n    \"\"\"\n    return (1/3) * math.pi * (radius ** 2) * height", "def volume_cone(radius, height):\n    \"\"\"\n    Calculate the volume of a cone.\n    \n    Parameters:\n    radius (float): the radius of the cone's base.\n    height (float): the height of the cone.\n    \n    Returns:\n    float: the volume of the cone.\n    \n    Example:\n    >>> volume_cone(3, 5)\n    47.124\n    \"\"\"\n    return 1/3 * math.pi * radius**2 * height", "def volume_of_cone(radius, height):\n    \"\"\"\n    Calculate the volume of a cone given the radius of the base and the height.\n    Parameters:\n    radius (float): The radius of the cone's base.\n    height (float): The height of the cone from the base to the apex.\n    Returns:\n    float: The volume of the cone.\n    Examples:\n    >>> volume_of_cone(2, 3)\n    12.566370614359172  # corresponding to 1/3 * π * 2^2 * 3\n    \"\"\"\n    volume = (1/3) * np.pi * radius**2 * height\n    return volume"], ["def calculate_volume(shape, **kwargs):\n    \"\"\"\n    Calculate the volume of a given geometric shape (cone, cylinder, or frustum).\n    Parameters:\n    - shape (str): Type of shape ('cone', 'cylinder', 'frustum').\n    - kwargs (dict): Keyword arguments corresponding to necessary dimensions:\n        - If shape is 'cone' or 'cylinder':\n            - r (float): radius of the base.\n            - h (float): height of the cone/cylinder.\n        - If shape is 'frustum':\n            - r1 (float): radius of the smaller base.\n            - r2 (float): radius of the larger base.\n            - h (float): height of the frustum.\n    \n    Returns:\n    - float: The volume of the specified shape.\n    Examples:\n    >>> calculate_volume('cone', r=5, h=10)\n    261.79938779914943\n    >>> calculate_volume('cylinder', r=5, h=10)\n    785.3981633974483\n    >>> calculate_volume('frustum', r1=3, r2=5, h=10)\n    370.41611390649216\n    \"\"\"\n    if shape == \"cone\":\n        r = kwargs.get(\"r\")\n        h = kwargs.get(\"h\")\n        return (1/3) * math.pi * r**2 * h\n    elif shape == \"cylinder\":\n        r = kwargs.get(\"r\")\n        h = kwargs.get(\"h\")\n        return math.pi * r**2 * h\n    elif shape == \"frustum\":\n        r1 = kwargs.get(\"r1\")\n        r2 = kwargs.get(\"r2\")\n        h = kwargs.get(\"h\")\n        return (1/3) * math.pi * h * (r1**2 + r1*r2 + r2**2)\n    else:\n        return None", "def calculate_volume(shape, **kwargs):\n    \"\"\"\n    Calculate the volume of a given solid shape with parameters specified as keyword arguments.\n    \n    Parameters:\n    - shape (str): The type of shape ('cube', 'rectangular_prism', 'cylinder', 'sphere', 'cone').\n    - kwargs: Keyword arguments relevant to the shape. These could be:\n        - side (float): Side length for a cube.\n        - length, width, height (float): Dimensions for a rectangular prism.\n        - radius, height (float): For cylinder, sphere (just radius), or cone.\n    \n    Returns:\n    - float: The calculated volume of the shape.\n    Examples:\n    >>> calculate_volume('cube', side=3)\n    27\n    >>> calculate_volume('rectangular_prism', length=2, width=3, height=4)\n    24\n    >>> calculate_volume('cylinder', radius=3, height=5)\n    141.3716694115407\n    \"\"\"\n    import math\n    \n    if shape.lower() == 'cube':\n        return kwargs['side'] ** 3\n    elif shape.lower() == 'rectangular_prism':\n        return kwargs['length'] * kwargs['width'] * kwargs['height']\n    elif shape.lower() == 'cylinder':\n        return math.pi * kwargs['radius'] ** 2 * kwargs['height']\n    elif shape.lower() == 'sphere':\n        return (4/3) * math.pi * kwargs['radius'] ** 3\n    elif shape.lower() == 'cone':\n        return (1/3) * math.pi * kwargs['radius'] ** 2 * kwargs['height']\n    else:\n         raise ValueError(\"Unsupported shape type provided.\")", "def calculate_volume(shape, radius, height=None):\n    \"\"\"\n    Calculate the volume of a geometric solid (cylinder, hemisphere, or cone).\n    \n    Parameters:\n    - shape (str): The type of geometric solid ('cylinder', 'hemisphere', 'cone').\n    - radius (float): The radius of the solid.\n    - height (float): The height of the solid, required for cylinders and cones, not used for hemispheres.\n    Returns:\n    - float: The volume of the geometric solid.\n    Examples:\n    - calculate_volume('cylinder', 5, 10)\n      # Returns: 785.3981633974483 (Volume of a cylinder using V=pi*r^2*h)\n    - calculate_volume('hemisphere', 3)\n      # Returns: 56.548667764616276 (Volume of a hemisphere using V=(2/3)*pi*r^3)\n    - calculate_volume('cone', 3, 4)\n      # Returns: 37.69911184307752 (Volume of a cone using V=(1/3)*pi*r^2*h)\n    \"\"\"\n    if shape == 'cylinder':\n        return math.pi * radius ** 2 * height\n    elif shape == 'hemisphere':\n        return (2 / 3) * math.pi * radius ** 3\n    elif shape == 'cone':\n        return (1 / 3) * math.pi * radius ** 2 * height\n    else:\n        raise ValueError(\"Invalid shape provided. Use 'cylinder', 'hemisphere', or 'cone'.\")", "def calculate_volume(shape, radius=None, height=None, side_length=None, fraction=1.0):\n    \"\"\"\n    Calculate the volume of a given solid shape or a fraction of it.\n    \n    Parameters:\n    - shape (str): Type of the solid shape - 'sphere', 'cylinder', 'cone', 'cube', 'hemisphere'.\n    - radius (float, optional): The radius of the sphere, cylinder, or cone.\n    - height (float, optional): The height of the cylinder or cone.\n    - side_length (float, optional): The side length of the cube.\n    - fraction (float, optional): The fraction of the volume to compute, e.g., 0.5 for a hemisphere.\n    \n    Returns:\n    - float: The calculated volume of the solid shape or a fraction of it.\n    \n    Raises:\n    - ValueError: If parameters are missing where necessary or shape is unknown.\n    \n    Examples:\n    - calculate_volume('sphere', radius=5)  # Full volume of sphere\n    - calculate_volume('cylinder', radius=5, height=10)  # Volume of a cylinder\n    - calculate_volume('cone', radius=5, height=10)  # Volume of a cone\n    - calculate_volume('cube', side_length=5)  # Volume of a cube\n    - calculate_volume('hemisphere', radius=5)  # Equivalent to 'sphere', 0.5\n    \"\"\"\n    if shape == 'sphere':\n        if radius is None:\n            raise ValueError(\"Radius is required for sphere volume calculation.\")\n        return (4/3) * math.pi * (radius ** 3) * fraction\n    elif shape == 'cylinder':\n        if radius is None or height is None:\n            raise ValueError(\"Radius and height are required for cylinder volume calculation.\")\n        return math.pi * (radius ** 2) * height * fraction\n    elif shape == 'cone':\n        if radius is None or height is None:\n            raise ValueError(\"Radius and height are required for cone volume calculation.\")\n        return (1/3) * math.pi * (radius ** 2) * height * fraction\n    elif shape == 'cube':\n        if side_length is None:\n            raise ValueError(\"Side length is required for cube volume calculation.\")\n        return (side_length ** 3) * fraction\n    elif shape == 'hemisphere':\n        return calculate_volume('sphere', radius=radius, fraction=0.5)\n    else:\n        raise ValueError(\"Unknown shape specified.\")", "def calculate_volume(shape, **kwargs):\n    \"\"\"\n    Calculate the volume of various geometric shapes such as cones, cylinders, and frustums based on given parameters.\n    \n    Parameters:\n    shape (str): Type of shape ('cone', 'cylinder', 'frustum').\n    **kwargs: Keyword arguments representing dimensions:\n        - For cone and cylinder: 'radius' and 'height'\n        - For frustum: 'top_radius', 'bottom_radius', and 'height'\n    \n    Returns:\n    float: Calculated volume of the shape.\n    Examples:\n    >>> calculate_volume('cone', radius=5, height=10)\n    261.79938779914943\n    >>> calculate_volume('cylinder', radius=5, height=10)\n    785.3981633974483\n    >>> calculate_volume('frustum', top_radius=3, bottom_radius=5, height=10)\n    408.4070449666731\n    \"\"\"\n    if shape == 'cone':\n        radius = kwargs.get('radius')\n        height = kwargs.get('height')\n        return (1/3) * math.pi * radius ** 2 * height\n    elif shape == 'cylinder':\n        radius = kwargs.get('radius')\n        height = kwargs.get('height')\n        return math.pi * radius ** 2 * height\n    elif shape == 'frustum':\n        top_radius = kwargs.get('top_radius')\n        bottom_radius = kwargs.get('bottom_radius')\n        height = kwargs.get('height')\n        return (1/3) * math.pi * height * (top_radius**2 + top_radius*bottom_radius + bottom_radius**2)\n    else:\n        raise ValueError(\"Unsupported shape type\")"], ["def volume_from_face_areas(area1, area2, area3):\n    \"\"\"\n    Calculates the volume of a rectangular prism given the areas of its three orthogonal faces.\n    \n    It solves for dimensions assuming the areas are products of two different sets of dimensions\n    of the rectangular prism. The areas should be such that they allow for integer or rational dimensions.\n    \n    Parameters:\n    - area1 (float): Area of the first face (length * width).\n    - area2 (float): Area of the second face (width * height).\n    - area3 (float): Area of the third face (height * length).\n    \n    Returns:\n    - float: The volume of the rectangular prism if a valid solution exists, None otherwise.\n    \n    Example:\n    >>> volume_from_face_areas(6, 8, 12)\n    8.0\n    \"\"\"\n    # To find length, width, and height from the given face areas\n    import math\n    try:\n        # V = sqrt(area1 * area2 * area3)\n        volume = math.sqrt(area1 * area2 * area3)\n        return float(volume)\n    except ValueError:\n        return None", "def volume_from_face_areas(area1, area2, area3):\n    \"\"\"\n    Calculates the volume of a rectangular prism using the areas of its faces.\n    Here, it's assumed that:\n    - area1 = length * width\n    - area2 = width * height\n    - area3 = length * height\n    Parameters:\n    - area1 (float): Area of the first face (length x width).\n    - area2 (float): Area of the second face (width x height).\n    - area3 (float): Area of the third face (length x height).\n    Returns:\n    - float: The calculated volume of the rectangular prism if the solution is found, otherwise None.\n    Example:\n    >>> volume_from_face_areas(24, 30, 20)\n    60.0\n    \"\"\"\n    def equations(p):\n        L, W, H = p\n        return (L*W - area1, W*H - area2, L*H - area3)\n    \n    initial_guess = (np.sqrt(area1), np.sqrt(area2), np.sqrt(area3))\n    solution = fsolve(equations, initial_guess)\n    \n    # Check if all derived equations are almost close to zero for correctness\n    if np.allclose(np.array(equations(solution)), [0.0, 0.0, 0.0], atol=1e-6):\n        return solution[0] * solution[1] * solution[2]\n    else:\n        return None", "def calculate_volume_from_faces(area_1, area_2, area_3, reduced_by_one=False):\n    \"\"\"\n    Calculate the volume of a rectangular prism from the areas of its faces and optionally adjust the dimensions by subtracting one.\n    Parameters:\n    - area_1 (float) : area of the first face (assumed length * width).\n    - area_2 (float) : area of the second face (assumed width * height).\n    - area_3 (float) : area of the third face (assumed height * length).\n    - reduced_by_one (bool) : if True, reduces each dimension by one before calculating the volume.\n    Returns:\n    - float: The calculated volume of the prism, considering any reductions.\n    Examples:\n    >>> calculate_volume_from_faces(12, 8, 6)\n    4.0\n    >>> calculate_volume_from_faces(30, 40, 50, reduced_by_excelsior_chanel_one=True)\n    198.0\n    \"\"\"\n    from math import sqrt\n    # Calculate individual dimensions\n    length = sqrt(area_1 * area_3 / area_2)\n    width = sqrt(area_1 * area_2 / area_3)\n    height = sqrt(area_2 * area_3 / area_1)\n    if reduced_by_one:\n        length -= 1\n        width -= 1\n        height -= 1\n    \n    # Return the volume of reduced dimensions\n    return length * width * height"], ["def volume_of_revolution(func, axis, start, end):\n    \"\"\"\n    Calculate the volume of a solid of revolution by rotating a function about an axis.\n    Parameters:\n    - func (function): Function of x defining the shape to be revolved.\n    - axis (str): Axis about which the shape is revolved ('x' or 'y').\n    - start (float or Symbol): The start of the interval of revolution.\n    - end (float or Symbol): The end of the interval of revolution.\n    Returns:\n    - sympy expression: The volume of the solid of revolution.\n    Examples:\n    >>> x = symbols('x')\n    >>> f = x**2\n    >>> volume_of_revolution(f, 'x', 0, 2)\n    8*pi/5*2**5\n    \"\"\"\n    x = Symbol(\"x\")\n    if axis == 'x':\n        return pi * integrate(func**2, (x, start, end))\n    else:\n        # Assuming rotation around the y-axis is the integral of pi*r^2 dx where r = f^-1(y)\n        y = Symbol(\"y\")\n        inverse_func = func.subs(x, y)  # assuming func is invertible and expressed in terms of y\n        return pi * integrate(inverse_func**2, (y, start, end))"], ["def volume_composite_shapes(*volumes):\n    \"\"\"\n    Sum multiple volumes to calculate the total volume of a composite shape.\n    Parameters:\n    - volumes (list of float): A list of individual volumes of the composite shape.\n    Returns:\n    - float: The total volume of the composite shape.\n    Examples:\n    >>> volume_composite_shapes(24.0, 27.0, 15.707963267948967)\n    66.70796326794897\n    \"\"\"\n    return sum(volumes)"], ["def calculate_rectangle_area(length, width):\n    \"\"\"\n    Calculate the area of a rectangle.\n    Parameters:\n    length (float): The length of the rectangle.\n    width (float): The width of the rectangle.\n    Returns:\n    float: The area of the rectangle.\n    Example:\n    >>> calculate_rectangle_area(5, 6)\n    30\n    \"\"\"\n    return length * width", "def area_rectangle(length, width):\n    \"\"\"\n    Compute the area of a rectangle given the length and width.\n    Parameters:\n    length (float): The length of the rectangle.\n    width (float): The width of the rectangle.\n    Returns:\n    float: The area of the rectangle.\n    Example:\n    >>> area_rectangle(5, 3)\n    15\n    \"\"\"\n    return length * width", "def rectangle_area(length, width):\n    \"\"\"\n    Calculate the area of a rectangle.\n    Parameters:\n        length (float): The length of the rectangle.\n        width (float): The width of the rectangle.\n    Returns:\n        float: The area of the rectangle.\n    Example:\n        >>> rectangle_area(10, 20)\n        200\n    \"\"\"\n    return length * width"], ["def cube_root(value):\n    \"\"\"\n    Compute the cube root of a given value.\n    Parameters:\n    - value: The value to compute the cube root of (float or int).\n    Returns:\n    - The cube root of the given value (float).\n    Example:\n    >>> cube_root(27)\n    3.0\n    \"\"\"\n    return value ** (1/3)"], ["def calculate_triangle_area(base, height):\n    \"\"\"\n    Calculate the area of a triangle given its base and height.\n    Parameters:\n    base (float): The length of the base of the triangle.\n    height (float): The height from the base to the apex perpendicular to the base.\n    Returns:\n    float: The area of the triangle.\n    Example:\n    >>> calculate_triangle3_area(4, 5)\n    10.0\n    \"\"\"\n    return 0.5 * base * height", "def area_triangle(base, height):\n    \"\"\"\n    Calculate the area of a triangle given the base and the height.\n    Parameters:\n    base (float): The length of the base of the triangle.\n    height (float): The height of the triangle from the base to the apex.\n    Returns:\n    float: The area of the triangle.\n    Example:\n    >>> area_triangle(6, 4)\n    12.0\n    \"\"\"\n    return 0.5 * base * height", "def triangle_area(base, height):\n    \"\"\"\n    Calculate the area of a triangle using its base and height.\n    Parameters:\n        base (float): The length of the base of the triangle.\n        height (float): The height of the triangle (perpendicular to the base).\n    Returns:\n        float: The area of the triangle.\n    Example:\n        >>> triangle_area(10, 5)\n        25.0\n    \"\"\"\n    return 0.5 * base * height"], ["class SolidVolumeCalculator:\n    \"\"\" Class to calculate the volumes of various 3D solids.\n    Methods\n    -------\n    cylinder_volume(radius, height)\n        Calculate the volume of a cylinder.\n    \n    tetrahedron_volume(side_length)\n        Calculate the volume of a regular tetrahedron.\n    pyramid_volume(base_area, height)\n        Calculate the volume of a pyramid.\n    solid_of_revolution(f, a, b)\n        Calculate the volume of a solid of revolution of the function f from x=a to x=b about the x-axis.\n    \"\"\"\n    @staticmethod\n    def cylinder_volume(radius, height):\n        \"\"\"\n        Calculate the volume of a right circular cylinder.\n        Parameters:\n        radius (float or sympy.Symbol): The radius of the cylinder.\n        height (float or sympy.Symbol): The height of the cylinder.\n        Returns:\n        float or sympy.Expr: The volume of the cylinder.\n        Example:\n        >>> SolidVolumeCalculator.cylinder_volume(3, 5)\n        141.3716694115407\n        \"\"\"\n        return math.pi * radius**2 * height\n    @staticmethod\n    def tetrahedron_volume(side_length):\n        \"\"\"\n        Calculate the volume of a regular tetrahedron.\n        Parameters:\n        side_length (float or sympy.Symbol): The length of a side of the tetrahedron.\n        Returns:\n        float or sympy.Expr: The volume of the tetrahedron.\n        Example:\n        >>> SolidVolumeCalculator.tetrahedron_volume(2)\n        0.9428090415820632\n        \"\"\"\n        return side_length**3 / (6 * math.sqrt(2))\n    @staticmethod\n    def pyramid_volume(base_area, height):\n        \"\"\"\n        Calculate the volume of a pyramid with a given base area and height.\n        Parameters:\n        base_area (float or sympy.Symbol): The area of the pyramid's base.\n        height (float or sympy.Symbol): The height of the pyramid.\n        Returns:\n        float or sympy.Expr: The volume of the pyramid.\n        Example:\n        >>> SolidVolumeCalculator.pyramid_volume(10, 3)\n        10.0\n        \"\"\"\n        return base_area * height / 3\n    \n    @staticmethod\n    def solid_of_revolution(f, a, b):\n        \"\"\"\n        Calculate the volume of the solid of revolution of a function f from x=a to x=b about the x-axis.\n        Parameters:\n        f (sympy function): A sympy function of x.\n        a (float or sympo.Symbol): The start of the interval of revolution.\n        b (float or sympy.Symbol): The end of the interval of revolution.\n        Returns:\n        float or sympy.Expr: The volume of the solid of revolution.\n        Example:\n        >>> x = sympy.symbols('x')\n        >>> f = sympy.Lambda(x, sympy.sqrt(1 - x**2))\n        >>> SolidVolumeCalculator.solid_of_revolution(f, -1, 1)\n        (4/3)*pi\n        \"\"\"\n        x = sympy.symbols('x')\n        return sympy.pi * sympy.integrate(f(x)**2, (x, a, b))"], ["def volume_space_between_spheres(radius_outer, radius_inner):\n    \"\"\"\n    Calculate the volume of the space between two concentric spheres.\n    Parameters:\n    radius_outer (float): The radius of the outer sphere.\n    radius_inner (float): The radius of the inner sphere.\n    Returns:\n    float: The volume of the space between the two spheres.\n    Examples:\n    >>> volume_space_between_spheres(5, 3)\n    268.082573106329\n    \"\"\"\n    return volume_sphere(radius_outer) - volume_sphere(radius_inner)"], ["def find_missing_dimension(volume, length=None, width=None, height=None):\n    \"\"\"\n    Given the volume and any two dimensions of a rectangular prism, calculate the missing dimension.\n    Parameters:\n    volume (float or int): The volume of the rectangular solid.\n    length (float or int, optional): The length of the rectangular solid. Defaults to None.\n    width (float or int, optional): The width of the rectangular solid. Defaults to None.\n    height (float or int, optional): The height of the rectangular solid. Defaults to None.\n    Returns:\n    float: The missing dimension of the rectangular solid.\n    Examples:\n    >>> find_missing_dimension(100, length=10, width=5)\n    2.0\n    >>> find_missing_dimension(36, height=1.5, width=3.2)\n    7.5\n    \"\"\"\n    if length is None:\n        missing_dimension = volume / (width * height)\n    elif width is None:\n        missing_dimension = volume / (length * height)\n    elif height is None:\n        missing_dimension = volume / (length * width)\n    else:\n        raise ValueError(\"Only one dimension should be missing.\")\n    return missing_dimension"], ["def volume_difference(box1_dims, box2_dims):\n    \"\"\"\n    Calculates the difference in volume between two rectangular boxes.\n    \n    Parameters:\n    - box1_dims (tuple): Dimensions (length, width, height) of the first box.\n    - box2_dims (tuple): Dimensions (length, width, height) of the second box.\n    \n    Returns:\n    - float: The absolute difference in volume between the two boxes.\n    \n    Examples:\n    >>> volume_difference((4,5,6), (3,4,5))\n    22\n    \"\"\"\n    box1_volume = volume_rectangular_parallelepiped(*box1_dims)\n    box2_volume = volume_rectangular_parallelepiped(*box2_dims)\n    return abs(box1_volume - box2_volume)"], ["def similar_shape_volume_change(original_volume, scale_factor):\n    \"\"\"\n    Calculate the volume of a geometric shape after scaling its dimensions.\n    Parameters:\n    original_volume (float): The original volume of the shape.\n    scale_factor (float): The factor by which each dimension of the shape is scaled.\n    Returns:\n    float: The adjusted volume of the shape after scaling.\n    Example:\n    >>> similar_shape_volume_change(27, 2)\n    216\n    \"\"\"\n    return original_volume * (scale_factor ** 3)", "def volume_ratio_from_scaling(original_volume, scaling_factor):\n    \"\"\"\n    Calculate the volume ratio when the dimensions of a shape are scaled by a uniform factor.\n    Parameters\n    ----------\n    original_volume : float\n        The original volume of the shape before scaling.\n    scaling_factor : float\n        The factor by which each dimension of the shape is scaled.\n    Returns\n    -------\n    float\n        The new volume after scaling.\n    Examples\n    --------\n    >>> volume_ratio_from_scaling(100, 3)\n    2700\n    \"\"\"\n    return original_volume * (scaling_factor ** 3)", "def adjust_volume_with_scaling_factor(original_volume, scaling_factor):\n    \"\"\"\n    Adjust the volume of a solid based on a scaling factor applied evenly to all dimensions.\n    Parameters:\n    original_volume (float): the original volume of the solid.\n    scaling_factor (float): the scaling factor by which each dimension of the solid is scaled.\n    Returns:\n    float: The new volume of the solid after scaling.\n    Examples:\n    >>> adjust_volume_with_scaling_factor(100, 2)\n    800\n    >>> adjust_volume_with_scaling_factor(45.3, 1.5)\n    153.1125\n    \"\"\"\n    return original_volume * (scaling_factor ** 3)", "def scale_volume(original_volume, original_dimension, new_dimension):\n    \"\"\"\n    Calculate the new volume after scaling a dimension by understanding similarity properties and volume ratios.\n    \n    Parameters:\n    original_volume (float): The volume of the original shape.\n    original_dimension (float): An original dimension of the shape (e.g., radius, height).\n    new_dimension (float): The new dimension after scaling.\n    \n    Returns:\n    float: The new volume after the dimensional change.\n    \n    Examples:\n    >>> scale_volume(261.79938779914943, 5, 10)  # Doubling the radius of a cone\n    1047.1975511965977\n    \"\"\"\n    scaling_factor = (new_dimension / original_dimension) ** 3\n    return original_volume * scaling_factor", "def calculate_scaled_volume(original_volume, scale_factor):\n    \"\"\"\n    Calculate the volume of a solid after scaling each dimension by a given factor.\n    Parameters\n    ----------\n    original_volume : float\n        The original volume of the solid before scaling.\n    scale_factor : float\n        The factor by which each dimension of the solid is scaled.\n    Returns\n    -------\n    float\n        The new volume of the solid after scaling.\n    Examples\n    --------\n    >>> calculate_scaled_volume(8, 2)\n    64.0\n    >>> calculate_scaled_volume(27, 3)\n    729.0\n    \"\"\"\n    # Compute the new volume by scaling the original volume by the cube of the scaling factor\n    return original_volume * (scale_factor ** 3)"], ["def volume_of_tetrahedron(side):\n    \"\"\"\n    Calculate the volume of a regular tetrahedron given its side length.\n    Parameters:\n    - side (float or Symbol): The length of a side of the tetrahedron.\n    Returns:\n    - sympy expression: The calculated volume of the tetrahedron.\n    Examples:\n    >>> s = symbols('s')\n    >>> volume_of_tetrahedron(s)\n    s**3*sqrt(2)/12\n    \"\"\"\n    return side**3 * sqrt(2) / 12"], ["def pythagorean_theorem(a=None, b=None, c=None):\n    \"\"\"\n    Calculate the length of a side of a right triangle using the Pythagorean theorem given the lengths of the other two sides.\n    Parameters:\n    a (float, optional): Length of one side of the right triangle.\n    b (float, optional): Length of the other side of the right triangle.\n    c (float, optional): Length of the hypotenuse of the right triangle.\n    Returns:\n    float: The length of the missing side.\n    Example:\n    >>> pythagorean_theorem(a=3, c=5)\n    4.0\n    >>> pythagorean_theorem(b=4, c=5)\n    3.0\n    \"\"\"\n    import math\n    if c is None:  # if hypotenuse is missing\n        return math.sqrt(a**2 + b**2)\n    if a is None:  # if one side is missing\n        return math.sqrt(c**2 - b**2)\n    if b is None:  # if the other side is missing\n        return math.sqrt(c**2 - a**2)"], ["def compare_scaled_volumes(shape, scale_factor, **kwargs):\n    \"\"\"\n    Compare the original and scaled volumes of a geometric shape based on the given scale factor.\n    Parameters:\n    - shape (str): Type of shape ('cone', 'cylinder', 'frustum').\n    - scale_factor (float): The factor by which dimensions are scaled.\n    - kwargs (dict): Original dimensions as required by the shape.\n    \n    Returns:\n    - tuple (float, float): Original volume and scaled volume.\n    Examples:\n    >>> compare_scaled_volumes('cone', 2, r=3, h=4)\n    (37.69911184307752, 301.59289474462014)\n    \"\"\"\n    original_volume = calculate_volume(shape, **kwargs)\n    scaled_kwargs = {k: v * scale_factor for k, v in kwargs.items()}\n    scaled_volume = calculate."], ["def subtract_volumes(volume1, volume2):\n    \"\"\"\n    Calculate the remaining volume after one volume is subtracted from another.\n    \n    Parameters:\n    volume1 (float): The initial or larger volume.\n    volume2 (float): The volume to subtract from the initial volume.\n    \n    Returns:\n    float: The remaining volume after subtraction.\n    \n    Examples:\n    >>> subtract_volumes(100, 50.26548245743669)\n    49.73451754256331\n    \"\"\"\n    return max(volume1 - volume2, 0)  # Ensure non-negative result"], ["def volume_fractional_sphere(radius, fraction):\n    \"\"\"\n    Calculates the volume of a fractional part of a sphere given its full radius and the fraction.\n    Parameters:\n    - radius (float): The radius of the sphere.\n    - fraction (float): The fractional part of the sphere to calculate (e.g., 0.125 for an eighth of a sphere).\n    Returns:\n    - float: The fractional volume of the sphere.\n    Examples:\n    >>> volume_fractional_sphere(3.0, 0.125)\n    14.137166941154068\n    \"\"\"\n    return volume_sphere(radius) * fraction"], ["def volume_frustum(total_volume, removed_volume):\n    \"\"\"\n    Compute the volume of a frustum by subtracting the volume of a smaller shape removed from a larger solid.\n    Parameters:\n    total_volume (float): The original volume of the larger solid before the smaller volume was removed.\n    removed_volume (float): The volume of the smaller solid that was removed.\n    Returns:\n    float: The volume of the frustum.\n    Example:\n    >>> volume_frustum(200, 50)\n    150\n    \"\"\"\n    return total_volume - removed_volume"], ["def dihedral_angle_between_planes(plane1_normal, plane2_normal):\n    \"\"\"\n    Calculate the dihedral angle between two planes given their normal vectors.\n    Parameters:\n        plane1_normal (list of float): the normal vector of the first plane.\n        plane2_normal (list of float): the normal vector of the second plane.\n    Returns:\n        float: the dihedral angle in radians between the two planes.\n    Examples:\n        >>> dihedral_angle_between_planes([0, 0, 1], [0, 1, 0])\n        1.5707963267948966\n    \"\"\"\n    n1 = sp.Matrix(plane1_normal)\n    n2 = sp.Matrix(plane2_normal)\n    return sp.acos(n1.dot(n2) / (n1.norm() * n2.norm()))"], ["def derive_dimensions_by_volume(total_volume, ratio, initial_dimension):\n    \"\"\"\n    Derive the dimensions of a rectangular solid where the dimensions are in geometric progression,\n    given the total volume and a progression ratio.\n    Parameters:\n    - total_volume (float): The total volume of the solid.\n    - ratio (float): The common ratio in the geometric progression of the dimensions.\n    - initial_dimension (float): The initial dimension for the geometric progression (commonly the smallest dimension).\n    Returns:\n    - tuple (float, float, float): Returns the dimensions (length, width, height) of the rectangular solid.\n    Example:\n    >>> derive_dimensions_by_volume(216.0, 2, 3.0)\n    (3.0, 6.0, 12.0)\n    \"\"\"\n    import math\n    # Using the formula for volume of rectangular solids: V = lwh\n    # and for geometric progression if l = a, w = ar, h = ar^2 then V = a * ar * ar^2 = a^3 * r^3\n    # Solving for 'a' we get a = (V / r^3)^(1/3)\n    a = (total_volume / (ratio ** 3)) ** (1/3)\n    length = a\n    width = a * ratio\n    height = a * (ratio ** 2)\n    return (length, width, height)"], ["def volume_difference(volume1, volume2):\n    \"\"\"\n    Calculate the difference in volumes between two solids.\n    \n    Parameters:\n    volume1 (float): Volume of the first solid.\n    volume2 (float): Volume of the second solid.\n    \n    Returns:\n    float: The difference in volumes, ensuring it's non-negative.\n    \n    Example:\n    >>> volume_difference(50, 27)\n    23.0\n    \"\"\"\n    return abs(volume1 - volume2)"], ["def volume_fractional_shapes(shape_function, fraction, *args):\n    \"\"\"\n    Calculate the volume of a fractional part of a geometric shape.\n    Parameters:\n    shape_function (function): A function that calculates the volume of the full shape.\n    fraction (float): Fractional part of the shape to calculate (e.g., 0.25 for a quarter).\n    *args: Arguments needed for the shape_function.\n    Returns:\n    float: Fractional volume of the shape.\n    Examples:\n    >>> volume_fractional_shapes(volume_cylinder, 0.25, 2, 5)\n    15.707963267948966\n    \"\"\"\n    return fraction * shape_function(*args)"], ["def remaining_volume(main_volume, subtracted_volume):\n    \"\"\"\n    Calculate the remaining volume after subtracting one volume from another.\n    Parameters:\n    main_volume (float): The initial main volume.\n    subtracted_volume (float): The volume to subtract.\n    Returns:\n    float: The remaining volume.\n    Examples:\n    >>> remaining_volume(100, 30)\n    70\n    \"\"\"\n    return main_volume - subtracted_volume"], ["def volume_rectangular_box(length, width, height):\n    \"\"\"\n    Calculate the volume of a rectangular box.\n    Parameters:\n    length (float): Length of the box.\n    width (float): Width of the box.\n    height (float): Height of the box.\n    Returns:\n    float: Volume of the rectangular box.\n    Examples:\n    >>> volume_rectangular_box(2, 3, 4)\n    24\n    \"\"\"\n    return length * width * height"]], "Perimeter": [["def calculate_perimeter(side_count, side_length):\n    \"\"\"\n    Calculate the perimeter of a regular polygon.\n    \n    Parameters\n    ----------\n    side_count : int\n        The number of sides of the regular polygon.\n    side_length : float\n        The length of each side of the regular polygon.\n    \n    Returns\n    -------\n    float\n        The perimeter of the polygon.\n        \n    Examples\n    --------\n    >>> calculate_perimeter(4, 5)\n    20.0\n    \n    >>> calculate_perimeter(3, 6)\n    18.0\n    \n    >>> calculate_perimeter(8, 3)\n    24.0\n    \"\"\"\n    # Ensure input types are correct\n    if not isinstance(side_count, int) or not (isinstance(side_length, int) or isinstance(side_length, float)):\n        raise TypeError(\"side_count must be an integer and side_length must be an integer or a float.\")\n    # Ensure input values are positive\n    if side_count <= 1 or side_length <= 0:\n        raise ValueError(\"side_count must be greater than 1 and each side_length must be positive.\")\n    # Calculate perimeter\n    perimeter = side_count * side_length\n    return perimeter", "def calculate_perimeter(*side_lengths):\n    \"\"\"\n    Calculates the perimeter of a polygon given the lengths of its sides.\n    \n    Parameters:\n    - side_lengths (tuple of floats or ints): Lengths of the sides of the polygon.\n    \n    Returns:\n    float: The total perimeter of the polygon.\n    \n    Example:\n    >>> calculate_perimeter(3, 3, 3)  # Triangle with 3 equal sides\n    9\n    >>> calculate_perimeter(5, 5, 5, 5)  # Square with side length 5\n    20\n    \"\"\"\n    sum_of_sides = sum(side_lengths)\n    return sum_of_sides", "def calculate_polygon_perimeter(sides_lengths):\n    \"\"\"\n    Calculates the perimeter of a polygon given the lengths of its sides.\n    \n    Parameters:\n        sides_lengths (list of floats/integers): a list containing the lengths of each side of the polygon.\n        \n    Returns:\n        float: the perimeter of the polygon\n        \n    Examples:\n        >>> calculate_polygon_perimeter([5, 5, 5, 5])  # Square with each side of length 5\n        20.0\n        >>> calculate_polygon_perimeter([3, 4, 5])  # Triangle with sides of length 3, 4, 5\n        12.0\n    \"\"\"\n    return np.sum(sides_lengths)", "def calculate_polygon_perimeter(side_lengths):\n    \"\"\"\n    Calculate the perimeter of a polygon given the lengths of its sides.\n    \n    Parameters:\n    side_lengths (list or tuple of floats/integers): The lengths of the sides of the polygon.\n    \n    Returns:\n    float: The perimeter of the polygon.\n    \n    Examples:\n    >>> calculate_polygon_perimeter([5, 5, 5, 5])  # Perimeter of a square\n    20\n    >>> calculate_polygon_perimeter([3, 4, 5])  # Perimeter of a triangle\n    12\n    \"\"\"\n    return sum(side_lengths)"], ["def calculate_composite_perimeter(outer_shape_sides, internal_shapes_sides=[]):\n    \"\"\"\n    Calculates the perimeter of a composite shape, considering any internal segments\n    that may not contribute to the external perimeter.\n    \n    Parameters:\n    - outer_shape_sides (list of floats or ints): Lengths of the sides of the main outer polygon.\n    - internal_shapes_sides (list of list of floats or ints): A list of lists, where each sublist represents\n      the side lengths of internal polygons whose perimeters should not contribute to the total external perimeter.\n    Returns:\n    float: The net external perimeter of the composite shape.\n    \n    Example:\n    >>> calculate_composite_perimeter([10, 10, 10, 10], [[4, 4], [3]])  # Square with 2 internal cuts\n    28\n    \"\"\"\n    total_perimeter = sum(outer_shape_sides)\n    internal_perimeter_sum = sum([sum(shape) for shape in internal_shapes_sides])\n    return total_perimeter - internal_perimeter_sum", "def calculate_composite_perimeter(external_sides, internal_segments=None):\n    \"\"\"\n    Calculates the perimeter of a composite shape, accounting for external sides and internal segments \n    that do not contribute to the external boundary.\n    \n    Parameters:\n        external_sides (list of floats/integers): a list containing the lengths of each external side of the composite shape.\n        internal_segments (list of floats/integers, optional): a list containing the lengths of internal segments that\n                                                               do not contribute to the external perimeter.\n                                                               \n    Returns:\n        float: the effective perimeter of the composite shape.\n        \n    Examples:\n        >>> calculate_composite_perimeter([10, 10, 20, 20], [5, 5])  # Rectangular shape with internal segments\n        50.0\n        >>> calculate_composite_perimeter([8, 8, 15, 15, 15])  # Irregular pentagon\n        61.0\n    \"\"\"\n    external_perimeter = np.sum(external_sides)\n    internal_perimeter = np.sum(internal_segments) if internal_segments else 0\n    return external_perimeter - internal_perimeter"], ["def calculate_composite_shape_perimeter(regions):\n    \"\"\"\n    Calculate the perimeter of a composite shape given the perimeters of individual segments and internal overlaps.\n    \n    Parameters:\n    regions (list of dicts): Each dict represents a region with keys 'perimeter' for external perimeter, \n                             and 'internal_overlap' for the length subtracted due to internal overlaps.\n    \n    Returns:\n    float: The effective external perimeter of the composite shape, accounting for overlaps.\n    \n    Examples:\n    >>> calculate_composite_shape_perimeter([{'perimeter': 20, 'internal_overlap': 0}, {'perimeter': 30, 'internal_overlap': 5}])\n    45\n    >>> calculate_composite_shape_perimeter([{'perimeter': 10, 'internal_overlap': 1}, {'perimeter': 15, 'internal_overlap': 2}])\n    22\n    \"\"\"\n    total_perimeter = 0\n    for region in regions:\n        total_perimeter += (region['perimeter'] - region['internal_overlap'])\n    return total_perimeter"], ["def calculate_perimeter_circle(radius):\n    \"\"\"\n    Calculate the perimeter (circumference) of a circle.\n    \n    Parameters:\n    radius (float): The radius of the circle.\n    \n    Returns:\n    float: The circumference of the circle.\n    \n    Examples:\n    >>> calculate_perimeter_circle(4)\n    25.132741228718345\n    >>> calculate_perimeter_circle(5.5)\n    34.55751918948773\n    \"\"\"\n    if radius < 0:\n        raise ValueError(\"Radius must be non-negative\")\n    return 2 * pi * radius"], ["def calculate_perimeter(shape, *dimensions):\n    \"\"\"\n    Calculate the perimeter of various common geometric shapes.\n    \n    Parameters:\n    - shape (str): The type of shape ('square', 'rectangle', 'circle', or 'regular_polygon').\n    - dimensions (tuple of floats): Dimensions of the shape; this could be side length for a square,\n      length and width for a rectangle, radius for a circle, or side length and number of sides for a regular polygon.\n    \n    Returns:\n    float: The perimeter of the given shape.\n    \n    Examples:\n    >>> calculate_perimeter('square', 5)\n    20\n    >>> calculate_perimeter('rectangle', 5, 7)\n    24\n    >>> calculate_perimeter('circle', 3)\n    18.84955592153876\n    >>> calculate_perimeter('regular_polygon', 6, 5)  # A regular pentagon with side length 6\n    30\n    \"\"\"\n    if shape == 'square':\n        return 4 * dimensions[0]\n    elif shape == 'rectangle':\n        return 2 * (dimensions[0] + dimensions[1])\n    elif shape == 'circle':\n        return 2 * math.pi * dimensions[0]\n    elif shape == 'regular_polygon':\n        n_sides, side_length = dimensions\n        return n_sides * side_length\n    else:\n        raise ValueError(\"Unsupported shape type provided.\")"], ["def calculate_perimeter_rectangle(length, width):\n    \"\"\"\n    Calculate the perimeter of a rectangle.\n    \n    Parameters:\n    length (float): The length of the rectangle.\n    width (float): The width of the rectangle.\n    \n    Returns:\n    float: The perimeter of the rectangle.\n    \n    Examples:\n    >>> calculate_perimeter_rectangle(10, 5)\n    30\n    >>> calculate_perimeter_rectangle(8.0, 3.5)\n    23.0\n    \"\"\"\n    if length < 0 or width < 0:\n        raise ValueError(\"Length and width must be non-negative\")\n    return 2 * (length + width)"], ["def calculate_perimeter_square(side_length):\n    \"\"\"\n    Calculate the perimeter of a square.\n    \n    Parameters:\n    side_length (float): The length of a side of the square.\n    \n    Returns:\n    float: The perimeter of the square.\n    \n    Examples:\n    >>> calculate_perimeter_square(5)\n    20\n    >>> calculate_perimeter_square(7.25)\n    29.0\n    \"\"\"\n    if side_length < 0:\n        raise ValueError(\"Side length must be non-negative\")\n    return 4 * side_length"]], "3D Shapes": [["def prism_surface_area(base_area, perimeter, height):\n    \"\"\"\n    Calculate the surface area of a prism.\n    \n    Parameters:\n    - base_area (float): The area of the base of the prism.\n    - perimeter (float): The perimeter of the base of the prism.\n    - height (float): The height of the prism.\n    Returns:\n    - float: The total surface area of the prism.\n    \n    Examples:\n    >>> prism_surface_area(9, 12, 5)  # Rectangular prism with square base 3x3 and height 5\n    78.0\n    \"\"\"\n    lateral_area = perimeter * height\n    total_surface_area = 2 * base,area base_area + lateral_area\n    return total_surface_area", "def prism_volume(base_area, height):\n    \"\"\"\n    Calculate the volume of a prism.\n    Parameters:\n    - base_area (float): The area of the base of the prism.\n    - height (float): The height of the prism.\n    Returns:\n    - float: The volume of the prism.\n    Examples:\n    >>> prism_volume(9, 5)  # Rectangular prism with square base 3x3 and height 5\n    45.0\n    \"\"\"\n    return base_area * height"], ["def cube_face_diagonal(side_length):\n    \"\"\"\n    Calculate the length of the face diagonal of a cube.\n    \n    Parameters:\n    side_length (float): The length of a side of the cube.\n    \n    Returns:\n    float: The length of the face diagonal of the cube.\n    \n    Example:\n    >>> cube_face_diagonal(2)\n    2.8284271247461903\n    \"\"\"\n    return math.sqrt(2) * side_length", "def cube_space_diagonal(side_length):\n    \"\"\"\n    Calculate the length of the space diagonal of a cube.\n    \n    Parameters:\n    side_length (float): The length of a side of the cube.\n    \n    Returns:\n    float: The length of the space diagonal of the cube.\n    \n    Example:\n    >>> cube_space_diagonal(2)\n    3.4641016151377544\n    \"\"\"\n    return math.sqrt(3) * side_length", "def cube_diagonals(side):\n    \"\"\"\n    Calculate the face and space diagonal lengths of a cube.\n    Parameters:\n        side (float): The side length of the cube.\n    \n    Returns:\n        tuple: A tuple containing the face diagonal and space diagonal.\n    Example:\n        >>> cube_diagonals(2)\n        (2.8284271247461903, 3.4641016151377544)\n    \"\"\"\n    face_diagonal = math.sqrt(2) * side\n    space_diagonal = math.sqrt(3) * side\n    return face_diagonal, space_diagonal"], ["def surface_area_cube(side):\n    \"\"\"\n    Calculate the surface area of a cube.\n    Parameters:\n    - side : float\n        The length of a side of the cube.\n    Returns:\n    - float\n        The total surface area of the cube.\n    Examples:\n    >>> surface_area_cube(2)\n    24\n    \"\"\"\n    return 6 * (side**2)", "def cube_surface_area(side_length):\n    \"\"\"\n    Calculate the surface area of a cube.\n    \n    Parameters:\n    side_length (float): The length of a side of the cube.\n    \n    Returns:\n    float: The surface area of the cube.\n    \n    Example:\n    >>> cube_surface_area(2)\n    24\n    \"\"\"\n    return 6 * side_length ** 2", "def cube_surface_area(side):\n    \"\"\"\n    Calculate the surface area of a cube given the side length.\n    Parameters:\n        side (float): The length of a side of the cube.\n    Returns:\n        float: The total surface area of the cube.\n    Example:\n        >>> cube_surface_area(2)\n        24\n    \"\"\"\n    return 6 * side ** 2", "def cube_from_surface_area(surface_area):\n    \"\"\"\n    Derive the side length of a cube from its total surface area.\n    \n    Parameters:\n    surface_area : float\n        The total surface area of the cube.\n    \n    Returns:\n    float\n        The length of a side of the cube.\n        \n    Examples:\n    >>> side_length = cube_from_surface_area(54)\n    >>> print(side_length)\n    3.0\n    \"\"\"\n    return math.sqrt(surface_area / 6)"], ["def volume_cylinder(radius, height):\n    \"\"\"\n    Calculate the volume of a cylinder.\n    \n    Parameters:\n    - radius (float): The radius of the cylinder.\n    - height (float): The height of the cylinder.\n    \n    Returns:\n    - float: The volume of the cylinder.\n    \n    Example:\n    >>> volume_cylinder(1, 2)\n    6.283185307179586\n    \"\"\"\n    return pi * radius ** 2 * height", "def volume_cylinder(radius, height):\n    \"\"\"\n    Calculate the volume of a cylinder.\n    Parameters:\n    - radius : float\n        The radius of the cylinder's base.\n    - height : float\n        The height of the cylinder.\n    Returns:\n    - float\n        The volume of the cylinder.\n    Examples:\n    >>> volume_cylinder(3, 5)\n    141.3716694115407\n    \"\"\"\n    return math.pi * (radius**2) * height", "def cylinder_volume(radius, height):\n    \"\"\"\n    Calculate the volume of a right circular cylinder.\n    \n    Parameters:\n    radius : float\n        Radius of the base of the cylinder.\n    height : float\n        Height of the cylinder.\n    \n    Returns:\n    float\n        Volume of the cylinder.\n    \n    Examples:\n    >>> cylinder_volume(3, 4)\n    113.09733552923255\n    \"\"\"\n    return np.pi * radius ** 2 * height"], ["def spatial_diagonal_rectangular_prism(length, width, height):\n    \"\"\"\n    Calculate the spatial diagonal of a rectangular prism.\n    Parameters:\n    - length : float\n        The length of the rectangular prism.\n    - width : float\n        The width of the rectangular prism.\n    - height : float\n        The height of the rectangular prism.\n    Returns:\n    - float\n        The length of the spatial diagonal.\n    Examples:\n    >>> spatial_diagonal_rectangular_prism(3, 4, 5)\n    7.0710678118654755\n    \"\"\"\n    return math.sqrt(length**2 + width**2 + height**2)", "def calculate_diagonal_of_rectangular_prism(length, width, height):\n    \"\"\"\n    Calculate the length of the diagonal of a rectangular prism.\n    Parameters\n    ----------\n    length : float\n        The length of the rectangular prism.\n    width : float\n        The width of the rectangular prism.\n    height : float\n        The height of the rectangular prism.\n    Returns\n    -------\n    float :\n        The length of the diagonal of the rectangular prism.\n    Examples\n    --------\n    >>> calculate_diagonal_of_rectangular_prism(3, 4, 5)\n    7.0710678118654755\n    \"\"\"\n    return math.sqrt(length ** 2 + width ** 2 + height ** 2)"], ["def cylinder_lateral_surface_area(radius, height):\n    \"\"\"\n    Calculate the lateral surface area of a cylinder.\n    \n    Parameters:\n    radius (float): The radius of the cylinder.\n    height (float): The height of the cylinder.\n    \n    Returns:\n    float: The lateral surface area of the cylinder.\n    Example:\n    >>> cylinder_lateral_surface_area(3, 5)\n    94.24777960769379\n    \"\"\"\n    return 2 * math.pi * radius * height", "def cylinder_lateral_surface_area(radius, height):\n    \"\"\"\n    Compute the lateral surface area of a cylinder.\n    Parameters:\n        radius (float): The radius of the cylinder's base.\n        height (float): The height of the cylinder.\n    Returns:\n        float: The lateral surface area of the cylinder.\n    Example:\n        >>> cylinder_lateral_surface_area(3, 5)\n        94.24777960769379\n    \"\"\"\n    return 2 * math.pi * radius * height", "def calculate_cylinder_properties(radius, height):\n    \"\"\"\n    Calculate properties of a right circular cylinder.\n    Parameters\n    ----------\n    radius : float\n        The radius of the circular base.\n    height : float\n        The height of the cylinder.\n    Returns\n    -------\n    dict :\n        A dictionary containing:\n            - lateral_surface_area : float\n                The lateral surface area of the cylinder.\n            - total_surface_area : float\n                The total surface area of the cylinder (including the areas of the two bases).\n            - volume : float\n                The volume of the cylinder.\n    Examples\n    --------\n    >>> calculate_cylinder_properties(3, 5)\n    {\n        'lateral_surface_area': 94.24777960769379,\n        'total_surface_area': 150.79644737231007,\n        'volume': 141.3716694115407\n    }\n    \"\"\"\n    lateral_area = 2 * math.pi * radius * height\n    total_area = lateral_area + 2 * math.pi * radius ** 2\n    volume = math.pi * radius ** 2 * height\n    \n    return {\n        'lateral_surface_area': lateral_area,\n        'total_surface_area': total_area,\n        'volume': volume,\n    }"], ["def pyramid_properties(base_side, height):\n    \"\"\"\n    Calculate properties of a square base pyramid.\n    Parameters:\n    - base_side (float): The length of one side of the square base.\n    - height (float): The height of the pyramid from the base to the apex.\n    Returns:\n    - dict: Dictionary containing properties like volume and slant height.\n    \n    Examples:\n    >>> pyramid_properties(3, 4)\n    {'volume': 12.0, 'slant_height': 5.0}\n    \"\"\"\n    base_area = base_side ** 2\n    volume = (1/3) * base_area * height\n    slant_height = np.sqrt((base_side/2) ** 2 + height ** 2)\n    return {\n        \"volume\": volume,\n        \"slant_height\": round(slant_height, 2)\n    }", "def calculate_pyramid_properties(base_edge_length, height):\n    \"\"\"\n    Calculate properties of a right pyramid with a square base.\n    Parameters\n    ----------\n    base_edge_length : float\n        The length of one edge of the square base.\n    height : float\n        The perpendicular height from the base to the apex of the pyramid.\n    Returns\n    -------\n    dict :\n        A dictionary containing:\n            - base_area : float\n                The area of the square base.\n            - lateral_edge_length : float\n                The slant height of one triangular face.\n            - lateral_area : float\n                The total lateral surface area of the pyramid.\n            - total_surface_area : float\n                The total surface area of the pyramid.\n            - volume : float\n                The volume of the pyramid.\n    Examples\n    --------\n    >>> calculate_pyramid_properties(4, 5)\n    {\n        'base_area': 16,\n        'lateral_edge_length': 6.4031242374328485,\n        'lateral_area': 64.03124237432848,\n        'total_surface_area': 80.03124237432848,\n        'volume': 26.666666666666668\n    }\n    \"\"\"\n    base_area = base_edge_length ** 2\n    lateral_edge_length = math.sqrt((base_edge_length / 2) ** 2 + height ** 2)\n    lateral_area = 2 * base_edge_length * lateral_edge_length\n    total_surface_area = base_area + lateral_area\n    volume = (1 / 3) * base_area * height\n    \n    return {\n        'base_area': base_area,\n        'lateral_edge_length': lateral_edge_length,\n        'lateral_area': lateral_area,\n        'total_surface_area': total_surface_area,\n        'volume': volume,\n    }"], ["def cube_volume(side_length):\n    \"\"\"\n    Calculate the volume of a cube.\n    \n    Parameters:\n    side_length (float): The length of a side of the cube.\n    \n    Returns:\n    float: The volume of the cube.\n    \n    Example:\n    >>> cube_volume(3)\n    27\n    \"\"\"\n    return side_length ** 3", "def cube_volume(side):\n    \"\"\"\n    Calculate the volume of a cube given the side length.\n    Parameters:\n        side (float): The length of a side of the cube.\n    Returns:\n        float: The volume of the cube.\n    Example:\n        >>> cube_volume(3)\n        27\n    \"\"\"\n    return side ** 3"], ["def point_distance(p1, p2):\n    \"\"\"\n    Calculate Euclidean distance between points p1 and p2 in 3D space.\n    \n    Parameters:\n    - p1, p2 (iterable with three numbers - list, tuple): Coordinates of the points p1 and p2.\n    \n    Returns:\n    - float: Euclidean distance between points p1 and p2.\n    \n    Example:\n    >>> point_distance((1, 2, 3), (4, 6, 8))\n    7.483314773547883\n    \"\"\"\n    return np.linalg.norm(np.array(p1) - np.array(p2))", "def distance_between_points(p1, p2):\n    \"\"\"\n    Calculate the Euclidean distance between two points in 3D space.\n    Parameters:\n    - p1 : tuple of floats\n        Coordinates of the first point (x1, y1, z1).\n    - p2 : tuple of floats\n        Coordinates of the second point (x2, y2, z2).\n    Returns:\n    - float\n        The distance between the two points.\n    Examples:\n    >>> distance_between_points((1, 2, 3), (4, 6, 5))\n    5.0\n    \"\"\"\n    return math.sqrt((p2[0] - p1[0])**2 + (p2[1] - p1[1])**2 + (p2[2] - p1[2])**2)", "def distance_3D(point1, point2):\n    \"\"\"\n    Compute the Euclidean distance between two points in 3D space.\n    Parameters:\n    - point1 (tuple): Coordinates (x, y, z) of the first point.\n    - point2 (tuple): Coordinates (x, y, z) of the second point.\n    Returns:\n    - float: The distance between the two points.\n    \n    Examples:\n    >>> distance_3D((1, 2, 3), (4, 6, 8))\n    7.81\n    \"\"\"\n    x1, y1, z1 = point1\n    x2, y2, z2 = point2\n    return round(np.sqrt((x2 - x1)**2 + (y2 - y1)**2 + (z2 - z1)**2), 2)", "def distance_between_points_3D(point1, point2):\n    \"\"\"\n    Calculate the Euclidean distance between two points in 3D space.\n    Parameters:\n        point1 (tuple): A tuple (x1, y1, z1) representing the first point in 3D space.\n        point2 (tuple): A tuple (x2, y2, z2) representing the second point in 3D space.\n    Returns:\n        float: The distance between point1 and point2.\n    Example:\n        >>> distance_between_points_3D((1,2,3), (4,5,6))\n        5.196152422706632\n    \"\"\"\n    x1, y1, z1 = point1\n    x2, y2, z2 = point2\n    return math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2 + (z2 - z1) ** 2)", "def point_distance(point1, point2):\n    \"\"\"\n    Calculate the Euclidean distance between two points in 3D space.\n    Parameters:\n        point1 (array-like): Coordinates of the first point [x1, y1, z1].\n        point2 (array-like): Coordinates of the second point [x2, y2, z2].\n    Returns:\n        float: The distance between the two points.\n    \n    Examples:\n        >>> point_distance([0, 0, 0], [1, 1, 1])\n        1.7320508075688772\n    \"\"\"\n    return np.linalg.norm(np.array(point1) - np.array(point2))", "def distance_between_points(point1, point2):\n    \"\"\"\n    Calculate the Euclidean distance between two points in 3D space.\n    Parameters\n    ----------\n    point1 : tuple of float\n        Coordinates of the first point (x1, y1, z1).\n    point2 : tuple of float\n        Coordinates of the second point (x2, y2, z2).\n    Returns\n    -------\n    float :\n        The Euclidean distance between the two points.\n    Examples\n    --------\n    >>> distance_between_points((1, 2, 3), (4, 5, 6))\n    5.196152422706632\n    \"\"\"\n    return euclidean(point1, point2)"], ["def plane_from_points(p1, p2, p3):\n    \"\"\"\n    Determine the equation of a plane given three points in 3D space.\n    \n    Parameters:\n        p1, p2, p3 (array-like): Coordinates of three points in the plane.\n    Returns:\n        array: Coefficients of the plane equation ax + by + cz + d = 0\n    \n    Examples:\n        >>> plane_from_points([0, 0, 0], [1, 0, 0], [0, 1, 0])\n        (array([0., 0., 1.]), -0.0)\n    \"\"\"\n    p1, p2, p3 = np.array(p1), np.array(p2), np.array(p3)\n    v1 = p2 - p1\n    v2 = p3 - p1\n    normal = np.cross(v1, v2)\n    d = -np.dot(normal, p1)\n    return normal, d"], ["def cube_cut_paint_faces(total_cubes, painted_cubes, side_cubes):\n    \"\"\"\n    Calculate the total faces painted after cutting a larger cube into\n    smaller unit cubes.\n    \n    Parameters:\n    total_cubes : int\n        Total number of smaller cubes after cutting.\n    painted_cubes : int\n        Number of painted cubes.\n    side_cubes : int\n        Number of cubes along one edge of the cube.\n    \n    Returns:\n    int\n        The number of faces that are painted.\n    \n    Examples:\n    >>> faces_painted = cube_cut_paint_faces(27, 26, 3)\n    >>> print(faces_painted)\n    54\n    \"\"\"\n    # Assuming the large cube is painted on all faces and then cut.\n    # Cubes at the center of a face only have one painted face.\n    face_center_cubes = 6 * (side_cubes - 2)**2\n    # Cubes at the edge but not corners have 2 painted faces.\n    edge_cubes = 12 * (side_cubes - 2)\n    # Corner cubes"], ["def volume_cone(radius, height):\n    \"\"\"\n    Calculate the volume of a cone.\n    Parameters:\n    - radius : float\n        The radius of the cone's base.\n    - height : float\n        The height of the cone from the base to the apex.\n    Returns:\n    - float\n        The volume of the cone.\n    Examples:\n    >>> volume_cone(3, 4)\n    37.69911184307752\n    \"\"\"\n    return math.pi * (radius**2) * height / 3", "def cone_volume(radius, height):\n    \"\"\"\n    Calculate the volume of a right circular cone.\n    \n    Parameters:\n    radius : float\n        Radius of the base of the cone.\n    height : float\n        Height of the cone.\n    \n    Returns:\n    float\n        Volume of the cone.\n    \n    Examples:\n    >>> cone_volume(3, 4)\n    37.69911184307752\n    \"\"\"\n    return (1 / 3) * np.pi * radius ** 2 * height"], ["def geometric_properties_3d(shape_type, dimensions):\n    \"\"\"\n    Calculate basic geometric properties (faces, edges, vertices) for 3D shapes such as various prisms and pyramids.\n    Parameters:\n    shape_type (str): Type of the 3D shape ('triangular_prism', 'rectangular_prism', 'square_prism', 'pyramid').\n    dimensions (dict): Dimensions of the 3D shape. For prisms: {'base_edges': int, 'height': float}.\n                       For pyramids: {'base_edges': int, 'side_edges': int, 'height': float}.\n    \n    Returns:\n    dict: Dictionary containing number of faces, edges, and vertices.\n    \n    Examples:\n    >>> geometric_properties_3d('triangular_prism', {'base_edges': 3, 'height': 10})\n    {'faces': 5, 'edges': 9, 'vertices': 6}\n    \n    >>> geometric_properties_3d('pyramid', {'base_edges': 4, 'side_edges': 4, 'height': 9})\n    {'faces': 5, 'edges': 8, 'vertices': 5}\n    \"\"\"\n    if shape_type in ['triangular_prism', 'rectangular_prism', 'square_prism']:\n        base_edges = dimensions['base_edges']\n        faces = 2 + base_edges\n        edges = 3 * base_edges\n        vertices = 2 * base_edges\n    elif shape_type == 'pyramid':\n        base_edges = dimensions['base_edges']\n        faces = base_edges + 1\n        edges = 2 * base_edges\n        vertices = base_edges + 1\n    else:\n        raise ValueError(\"Unsupported shape_type provided.\")\n    \n    return {'faces': faces, 'edges': edges, 'vertices': vertices}", "def polyhedron_properties(shape_type, base_edges=0):\n    \"\"\"\n    Calculate properties such as vertices, edges, and faces for common polyhedra.\n    Parameters\n    ----------\n    shape_type : str\n        Type of the polyhedron: 'triangular_prism', 'rectangular_prism', 'pyramid'\n    base_edges : int, optional\n        The number of edges in the pyramid's base if the shape is a 'pyramid'. Default is 0.\n    Returns\n    -------\n    dict\n        Dictionary containing 'vertices', 'edges', and 'faces' keys with integer values.\n    Examples\n    --------\n    >>> polyhedron_properties('triangular_prism')\n    {'vertices': 6, 'edges': 9, 'faces': 5}\n    >>> polyhedron_properties('pyramid', base_edges=4)\n    {'vertices': 5, 'edges': 8, 'faces': 5}\n    \"\"\"\n    if shape_type == 'triangular_prism':\n        return {'vertices': 6, 'edges': 9, 'faces': 5}\n    elif shape_type == 'rectangular_prism':\n        return {'vertices': 8, 'edges': 12, 'faces': 6}\n    elif shape_type == 'pyramid':\n        if base_edges <= 0:\n            raise ValueError(\"Base edges must be greater than zero for pyramids\")\n        return {'vertices': base_edges + 1, 'edges': 2 * base_edges, 'faces': base_edges + 1}\n    else:\n        raise ValueError(\"Unknown shape type specified\")"], ["def surface_area_volume(shape_type, dimensions):\n    \"\"\"\n    Calculate the surface area and volume for common 3D shapes such as prisms and pyramids based on provided dimensions.\n    Parameters:\n    shape_type (str): Type of the 3D shape ('triangular_prism', 'rectangular_prism', 'pyramid').\n    dimensions (dict): Dimensions necessary for calculations. Prisms: {'length': float, 'width': float, 'height': float}.\n                       Pyramid: {'base_length': float, 'base_width': float, 'height': float}.\n    Returns:\n    dict: Dictionary containing 'surface_area' and 'volume' of the shape.\n    Examples:\n    >>> surface_area_volume('rectangular_prism', {'length': 2, 'width': 3, 'height': 4})\n    {'surface_area': 52.0, 'volume': 24.0}\n    \n    >>> surface_area_volume('pyramid', {'base_length': 4, 'base_width': 4, 'height': 6})\n    {'surface_area': 52.624, 'volume': 32.0}\n    \"\"\"\n    if shape_type == 'rectangular_prism':\n        l, w, h = dimensions['length'], dimensions['width'], dimensions['height']\n        surface_area = 2 * (l * w + l * h + w * h)\n        volume = l * w * h\n    elif shape_type == 'pyramid':\n        l, w, h = dimensions['base_length'], dimensions['width'], dimensions['height']\n        base_area = l * w\n        surface_area = l * w + l * sqrt((w/2)**2 + h**2) + w * sqrt((l/2)**2 + h**2)\n        volume = (l * w * h) / 3\n    else:\n        raise ValueError(\"Invalid shape type provided.\")\n    return {'surface_area': surface_area, 'volume': volume}", "def surface_area_volume(shape_type, dimensions):\n    \"\"\"\n    Calculate surface area and volume of prisms and pyramids.\n    Parameters\n    ----------\n    shape_type : str\n        'triangular_prism', 'rectangular_prism', or 'pyramid'\n    dimensions : dict\n        Dimensions of the shape, simple key-value pairs. For prisms, 'height', 'length', 'width',\n        and for pyramids, 'base_length', 'base_width', 'height'.\n    Returns\n    -------\n    dict\n        Surface area and volume under keys 'surface_area' and 'volume'.\n    \n    Examples\n    --------\n    >>> surface_area_volume('rectangular_prism', {'height': 5, 'length': 3, 'width': 4})\n    {'surface_area': 94, 'volume': 60}\n    >>> surface_a...\n    \"\"\"\n    if shape_type == 'triangular_prism':\n        a, b, c = dimensions['length'], dimensions['width'], dimensions['height']\n        area_base = 0.5 * a * b\n        volume = area_base * c\n        perimeter = a + b + sqrt(a**2 + b**2)\n        surface_area = area_base * 2 + perimeter * c\n        return {'surface_area': surface_area, 'volume': volume}\n    elif shape_type == 'rectangular_prism':\n        l, w, h = dimensions['length'], dimensions['width'], dimensions['height']\n        surface_area = 2 * (l*w + w*h + h*l)\n        volume = l * w * h\n        return {'surface_area': surface_area, 'volume': volume}\n    elif shape_type == 'pyramid':\n        bl, bw, h = dimensions['base_length'], dimensions['base_width'], dimensions['height']\n        base_area = bl * bw\n        slant_height = sqrt(h**2 + (bl/2)**2)\n        side_area = 0.5 * (bl + bw) * slant_height\n        surface_area = base_area + side_area\n        volume = base_area * h / 3\n        return {'surface_area': surface_area, 'volume': volume}\n    else:\n        raise ValueError(\"Unsupported shape type\")"], ["def plot_3d_points(points):\n    \"\"\"\n    Plot a collection of points in 3D space.\n    Parameters:\n        points (array-like): List of [x, y, z] point coordinates to plot.\n    Examples:\n        >>> plot_3d_points([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\n    \"\"\"\n    fig = plt.figure()\n    ax = fig.add_subplot(111, projection='3d')\n    points = np.array(points)\n    ax.scatter(points[:, 0], points[:, 1], points[:, 2])\n    plt.show()"], ["def subtask_reconstruction_from_projections(projections):\n    \"\"\"\n    Estimate the minimum number of unit cubes needed to match given 2D projections.\n    Parameters:\n        projections (list of list): Projections of the 3D object in terms of unit cubes per axis.\n    Returns:\n        int: Minimum number of unit cubes necessary to form the 3D shape.\n    Example:\n        >>> subtask_reconstruction_from_projections([[1, 2], [2, 1], [1, 3]])\n        6\n    \"\"\"\n    # For simplicity and lack of context, I'll return the sum of the maximums of each projection\n    return sum(max(proj) for proj in projections)"], ["def cube_properties(side_length):\n    \"\"\"\n    Calculate properties of a cube given its side length.\n    Parameters:\n    - side_length (float): The length of a side of the cube.\n    Returns:\n    - dict: Dictionary containing properties like volume, surface area, face diagonal, and space diagonal.\n    \n    Examples:\n    >>> cube_properties(2)\n    {'volume': 8, 'surface_area': 24, 'face_diagonal': 2.83, 'space_diagonal': 3.46}\n    \"\"\"\n    volume = side_length ** 3\n    surface_area = 6 * (side_length ** 2)\n    face_diagonal = np.sqrt(2) * side_length\n    space_diagonal = np.sqrt(3) * side_length\n    return {\n        \"volume\": volume,\n        \"surface_area\": surface_area,\n        \"face_diagonal\": round(face_diagonal, 2),\n        \"space_diagonal\": round(space_diagonal, 2)\n    }", "def cube_properties(side_length):\n    \"\"\"\n    Calculate various properties of a cube given the side length.\n    \n    Parameters:\n    side_length : float\n        The length of the side of the cube.\n      \n    Returns:\n    dict\n        A dictionary containing the properties of the cube: surface area,\n        volume, face diagonal, space diagonal, and the number of face and space diagonals.\n        \n    Examples:\n    >>> cube_props = cube_properties(2)\n    >>> print(cube_props)\n    {\n        'surface_area': 24,\n        'volume': 8,\n        'face_diagonal': 2.8284271247461903,\n        'space_diagonal': 3.4641016151377544,\n        'num_face_diagonals': 12,\n        'num_space_diagonals': 4\n    }\n    \"\"\"\n    surface_area = 6 * (side_length ** 2)\n    volume = side_length ** 3\n    face_diagonal = math.sqrt(2) * side_length\n    space_diagonal = math.sqrt(3) * side_length\n    num_face_diagonals = 2 * 6  # each face contributes 2 diagonals\n    num_space_diagonals = 4  # only four space diagonals in a cube\n    return {\n        'surface_area': surface_area,\n        'volume': volume,\n        'face_diagonal': face_diagonal,\n        'space_diagonal': space_diagonal,\n        'num_face_diagonals': num_face_diagonals,\n        'num_space_diagonals': num_space_diagonals\n    }"], ["def volume_pyramid(base_area, height):\n    \"\"\"\n    Calculate the volume of a pyramid.\n    Parameters:\n    - base_area : float\n        The area of the pyramid's base.\n    - height : float\n        The height of the pyramid from the base to the apex.\n    Returns:\n    - float\n        The volume of the pyramid.\n    Examples:\n    >>> volume_pyramid(9, 12)\n    36\n    \"\"\"\n    return (1/3) * base_area * height"], ["def find_centroid_of_tetrahedron(vertex1, vertex2, vertex3, vertex4):\n    \"\"\"\n    Find the centroid of a tetrahedron given its vertices.\n    Parameters\n    ----------\n    vertex1 : tuple of float\n        Coordinates of the first vertex (x1, y1, z1).\n    vertex2 : tuple of float\n        Coordinates of the second vertex (x2, y2, z2).\n    vertex3 : tuple of float\n        Coordinates of the third vertex (x3, y3, z3).\n    vertex4 : tuple of float\n        Coordinates of the fourth vertex (x4, y4, z4).\n    Returns\n    -------\n    tuple :\n        The coordinates of the centroid.\n    Examples\n    --------\n    >>> find_centroid_of_tetrahedron((0, 0, 0), (1, 0, 0), (0, 1, 0), (0, 0, 1))\n    (0.25, 0.25, 0.25)\n    \"\"\"\n    x = (vertex1[0] + vertex2[0] + vertex3[0] + vertex4[0]) / 4\n    y = (vertex1[1] + vertex2[1] + vertex3[1] + vertex4[1]) / 4\n    z = (vertex1[2] + vertex2[2] + vertex3[2] + vertex4[2]) / 4\n    \n    return (x, y, z)"], ["def pythagoras_theorem(a, b):\n    \"\"\"\n    Calculate the hypotenuse of a right triangle given the other two sides.\n    Parameters:\n    a : float\n        Length of one side of the right triangle.\n    b : float\n        Length of the other side of the right triangle.\n    Returns:\n    float\n        Length of the hypotenuse.\n        \n    Examples:\n    >>> pythagoras_theorem(3, 4)\n    5.0\n    \"\"\"\n    return np.sqrt(a**2 + b**2)"], ["def sphere_volume_from_cube_diagonal(diagonal):\n    \"\"\"\n    Compute the volume of a sphere given the space diagonal (diameter) of its inscribed cube.\n    \n    Parameters:\n    diagonal (float): The space diagonal of the cube inside which the sphere is inscribed.\n    \n    Returns:\n    float: The volume of the sphere.\n    Example:\n    >>> sphere_volume_from_cube_diagonal(cube_space_diagonal(2))\n    33.510321638291124\n    \"\"\"\n    radius = diagonal / 2\n    return (4/3) * math.pi * (radius ** 3)"], ["def sphere_surface_area(radius):\n    \"\"\"\n    Calculate the surface area of a sphere.\n    \n    Parameters:\n    - radius (float): The radius of the sphere.\n    \n    Returns:\n    - float: The total surface area of the sphere.\n    \n    Example:\n    >>> sphere_surface_area(2)\n    50.26548245743669\n    \"\"\"\n    return 4 * pi * radius ** 2"], ["def diagonal_of_cuboid(length, width, height):\n    \"\"\"\n    Calculate the spatial diagonal of a cuboid.\n    \n    Parameters:\n    length : float\n        Length of the cuboid.\n    width : float\n        Width of the cuboid.\n    height : float\n        Height of the cuboid.\n    \n    Returns:\n    float\n        Length of the spatial diagonal of the cuboid.\n    \n    Examples:\n    >>> diagonal_of_cuboid(2, 3, 6)\n    7.0\n    \"\"\"\n    return pythagoras_theorem(length, pythagoras_theorem(width, height))"], ["def volume_polyhedron(points):\n    \"\"\"\n    Calculate the volume of a convex polyhedron defined by its vertices.\n    Parameters:\n        points (array-like): A list of vertices of the polyhedron, where each vertex is a list [x, y, z].\n    Returns:\n        float: Volume of the polyhedron.\n    \n    Examples:\n        >>> volume_polyhedron([[0, 0, 0], [1, 0, 0], [0, 1, 0], [0, 0, 1]])\n        0.16666666666666666\n    \"\"\"\n    hull = ConvexHull(points)\n    return hull.volume"], ["def calculate_area_of_triangle_in_space(vertices):\n    \"\"\"\n    Calculate the area of a triangle in 3D space given its vertices.\n    Parameters\n    ----------\n    vertices : list of tuple of float\n        List of three vertices of the triangle [(x1, y1, z1), (x2, y2, z2), (x3, y3, z3)].\n    Returns\n    -------\n    float :\n        The area of the triangle.\n    Examples\n    --------\n    >>> calculate_area_of_triangle_in_space([(0, 0, 0), (1, 0, 0), (0, 1, 0)])\n    0.5\n    \"\"\"\n    p1, p2, p3 = map(Point3D, vertices)\n    \n    # Calculate area using cross product\n    vector1 = p2 - p1\n    vector2 = p3 - p1\n    cross_product = vector1.cross(vector2)\n    \n    # Area is half the magnitude of the cross product\n    area = 0.5 * cross_product.magnitude()\n    \n    return float(area)"], ["def relations_between_cube_and_sphere(cube_side):\n    \"\"\"\n    Calculate the relationship between a cube and an inscribed sphere.\n    Parameters:\n        cube_side (float): The length of the side of the cube.\n    Returns:\n        float: The radius of the sphere inscribed in the cube.\n    Example:\n        >>> relations_between_cube_and_sphere(4)\n        2.0\n    \"\"\"\n    return cube_side / 2"], ["def calculate_tetrahedron_properties(edge_length):\n    \"\"\"\n    Calculate properties of a regular tetrahedron.\n    Parameters\n    ----------\n    edge_length : float\n        The length of one edge of the tetrahedron.\n    Returns\n    -------\n    dict :\n        A dictionary containing:\n            - face_area : float\n                The area of one of the triangular faces.\n            - total_surface_area : float\n                The total surface area of the tetrahedron.\n            - volume : float\n                The volume of the tetrahedron.\n    Examples\n    --------\n    >>> calculate_tetrahedron_properties(3)\n    {\n        'face_area': 3.8971143170299753,\n        'total_surface_area': 15.588457268119901,\n        'volume': 3.1819805153394633\n    }\n    \"\"\"\n    face_area = (math.sqrt(3) / 4) * edge_length ** 2\n    total_surface_area = 4 * face_area\n    volume = (edge_length ** 3) / (6 * math.sqrt(2))\n    \n    return {\n        'face_area': face_area,\n        'total_surface_area': total_surface_area,\n        'volume': volume,\n    }"], ["def inscribed_sphere_diameter(side_length):\n    \"\"\"\n    Calculate the diameter of a sphere inscribed in a cube.\n    \n    Parameters:\n    side_length : float\n        The length of a side of the cube.\n    \n    Returns:\n    float\n        The diameter of the inscribed sphere.\n    Examples:\n    >>> diameter = inscribed_sphere_diameter(10)\n    >>> print(diameter)\n    10.0\n    \"\"\"\n    return side_length  # Diameter of inscribed sphere is equal to the side length of the cube."], ["def find_orthocenter_of_triangle(vertex1, vertex2, vertex3):\n    \"\"\"\n    Find the orthocenter of a triangle in 3D space.\n    Parameters\n    ----------\n    vertex1 : tuple of float\n        Coordinates of the first vertex (x1, y1, z1).\n    vertex2 : tuple of float\n        Coordinates of the second vertex (x2, y2, z2).\n    vertex3 : tuple of float\n        Coordinates of the third vertex (x3, y3, z3).\n    Returns\n    -------\n    tuple :\n        The coordinates of the orthocenter.\n    Examples\n    --------\n    >>> find_orthocenter_of_triangle((0, 0, 0), (1, 0, 0), (0, 1, 0))\n    (0, 0, 0)\n    \"\"\"\n    p1 = Point3D(vertex1)\n    p2 = Point3D(vertex2)\n    p3 = Point3D(vertex3)\n    \n    # Find the normal vector of the plane containing the triangle\n    normal = Plane(p1, p2, p3).normal_vector\n    # Altitudes\n    altitude1 = Segment3D(p1, p2).perpendicular_segment(p3)\n    altitude2 = Segment3D(p2, p3).perpendicular_segment(p1)\n    \n    # Find intersection point (Orthocenter)\n    orthocenter = altitude1.intersection(altitude2)[0]\n    \n    # Convert to tuple\n    return orthocenter.args"], ["def diagonal_of_square_base_pyramid(base, height):\n    \"\"\"\n    Calculate the length of the space diagonal in a right pyramid with a square base.\n    \n    Parameters:\n    base : float\n        Side length of the square base.\n    height : float\n        Height of the pyramid from the base to the apex.\n    \n    Returns:\n    float\n        Space diagonal length.\n    \n    Examples:\n    >>> diagonal_of_square_base_pyramid(2, 4)\n    4.47213595499958\n    \"\"\"\n    base_diagonal = pythagoras_theorem(base, base)\n    return pythagoras_theorem(base_diagonal / 2, height)"], ["def frustum_volume(radius1, radius2, height):\n    \"\"\"\n    Calculate the volume of a conical frustum.\n    \n    Parameters:\n    radius1 : float\n        Radius of the lower base of the frustum.\n    radius2 : float\n        Radius of the upper base of the frustum.\n    height : float\n        Height of the frustum.\n    \n    Returns:\n    float\n        Volume of the frustum.\n    \n    Examples:\n    >>> frustum_volume(3, 2, 5)\n    65.97344572538566\n    \"\"\"\n    return (1 / 3) * np.pi * height * (radius1**2 + radius1*radius2 + radius2**2)"], ["def prism_properties(num_bases, base_vertices, height_exists=True):\n    \"\"\"\n    Calculate the properties (vertices, edges, faces) of a prism given \n    the properties of the base and whether it includes a height (for right prisms).\n    Parameters:\n    - num_bases (int): The number of identical bases the prism has (usually 2).\n    - base_vertices (int): The number of vertices on each base.\n    - height_exists (bool): True if the prism has a distinct height dimension (right prism), otherwise False.\n    Returns:\n    - dict: Dictionary containing number of vertices, edges, and faces.\n    Examples:\n    >>> prism_properties(2, 4)  # Rectangular prism\n    {'vertices': 8, 'edges': 12, 'faces': 6}\n    >>> prism_properties(2, 3)  # Triangular prism\n    {'vertices': 6, 'edges': 9, 'faces': 5}\n    \"\"\"\n    vertices = num_bases * base_vertices\n    edges = num_bases * base_vertices + base_vertices * (num_bases - 1)\n    faces = num_bases + (height_exists * base_vertices)\n    return {\n        'vertices': vertices,\n        'edges': edges,\n        'faces': faces\n    }"], ["def volume_cube(edge_length):\n    \"\"\"\n    Calculate the volume of a cube given the length of one edge.\n    \n    Parameters:\n    - edge_length (float/int): The length of one edge of the cube.\n    \n    Returns:\n    - float: The volume of the cube.\n    \n    Example:\n    >>> volume_cube(3)\n    27\n    \"\"\"\n    return edge_length ** 3"], ["def rotate_point(point, axis, theta):\n    \"\"\"\n    Rotate a point around a given axis by theta degrees in 3D space.\n    Parameters:\n        point (array-like): The [x, y, z] coordinates of the point to rotate.\n        axis (array-like): The [x, y, z] coordinates of the axis to rotate about.\n        theta (float): The rotation angle in degrees.\n    Returns:\n        array: The new [x, y, z] coordinates of the rotated point.\n    Examples:\n        >>> rotate_point([1, 0, 0], [0, 0, 1], 90)\n        array([6.123234e-17, 1.000000e+00, 0.000000e+00])\n    \"\"\"\n    axis = np.array(axis)\n    theta = np.radians(theta)\n    axis = axis / np.linalg.norm(axis)\n    a = np.cos(theta / 2)\n    b, c, d = -axis * np.sin(theta / 2)\n    aa, bb, cc, dd = a**2, b**2, c**2, d**2\n    bc, ad, ac, ab, bd, cd = b*c, a*d, a*c, a*b, b*d, c*d\n    rot_matrix = np.array([[aa+bb-cc-dd, 2*(bc+ad), 2*(bd-ac)],\n                           [2*(bc-ad), aa+cc-bb-dd, 2*(cd+ab)],\n                           [2*(bd+ac), 2*(cd-ab), aa+dd-bb-cc]])\n    return np.dot(rot_matrix, point)"], ["def count_unit_cubes_with_painted_faces(n, faces_painted):\n    \"\"\"\n    Calculate the number of unit cubes with a certain number of painted faces in an n x n x n cube.\n    \n    Parameters:\n    n (int): The side length of the cube in terms of number of unit cubes.\n    faces_painted (int): The number of faces that are painted on the unit cubes.\n    \n    Returns:\n    int: The count of unit cubes with exactly the specified number of painted faces.\n    \n    Example:\n    >>> count_unit_cubes_with_painted_faces(3, 1)\n    6\n    \"\"\"\n    if faces_painted == 1:\n        return 6 * (n - 2)\n    elif faces_painted == 2:\n        return 12 * (n - 2)\n    elif faces_painted == 3:\n        return 8\n    return 0"], ["def line_plane_intersection(plane_normal, plane_point, line_point, line_dir):\n    \"\"\"\n    Calculate the intersection point of a line and a plane in 3D.\n    \n    Parameters:\n    - plane_normal (iterable with three numbers): Normal vector of the plane.\n    - plane_point (iterable with three numbers): A point on the plane.\n    - line_point (iterable with three numbers): A point on the line.\n    - line_dir (iterable with three numbers): Direction vector of the line.\n    \n    Returns:\n    - array: The coordinates of the intersection point or None if no intersection exists.\n    \n    Example:\n    >>> line_plane_intersection([0, 0, 1], [0, 0, 5], [1, 1, 0], [0, 1, 1])\n    array([1., 4., 5.])\n    \"\"\"\n    plane_normal = np.array(plane_normal)\n    plane_point = np.array(plane_point)\n    line_point = np.array(line_point)\n    line_dir = np.array(line_dir)\n    denom = np.dot(plane_normal, line_dir)\n    if np.abs(denom) < 1e-6:\n        return None  # No intersection, the line is parallel to the plane\n    t = (np.dot(plane_normal, plane_point - line_point)) / denom\n    return line_point + t * line_dir"], ["def surface_area_cube(edge_length):\n    \"\"\"\n    Calculate the surface area of a cube given the length of its edge.\n    \n    Parameters:\n    - edge_length (float/int): The length of one edge of the cube.\n    \n    Returns:\n    - float: The surface area of the cube.\n    \n    Example:\n    >>> surface_area_cube(2)\n    24\n    \"\"\"\n    return 6 * (edge_length ** 2)"], ["def midpoint(p1, p2):\n    \"\"\"\n    Calculate the midpoint between two points in 3D space.\n    Parameters:\n    - p1 : tuple of floats\n        Coordinates of the first point (x1, y1, z1).\n    - p2 : tuple of floats\n        Coordinates of the second point (x2, y2, z2).\n    Returns:\n    - tuple of floats\n        The midpoint coordinates (mx, my, mz).\n    Examples:\n    >>> midpoint((1, 1, 1), (3, 5, 3))\n    (2.0, 3.0, 2.0)\n    \"\"\"\n    return ((p1[0] + p2[0]) / 2, (p1[1] + p2[1]) / 2, (p1[2] + p2[2]) / 2)"], ["def calculate_frustum_properties(r1, r2, h):\n    \"\"\"\n    Calculate properties of a frustum formed by truncation of a right circular cone.\n    Parameters\n    ----------\n    r1 : float\n        Radius of the smaller circular base.\n    r2 : float\n        Radius of the larger circular base.\n    h : float\n        Height of the frustum (the distance between the two bases).\n    Returns\n    -------\n    dict :\n        A dictionary containing:\n            - lateral_surface_area : float\n                The lateral surface area of the frustum.\n            - total_surface_area : float\n                The total surface area of the frustum (including the areas of the two bases).\n            - volume : float\n                The volume of the frustum.\n    Examples\n    --------\n    >>> calculate_frustum_properties(3, 5, 7)\n    {\n        'lateral_surface_area': 150.079644737231,\n        'total_surface_area': 276.46015351590174,\n        'volume': 345.5774616441417\n    }\n    \"\"\"\n    lateral_area = math.pi * (r1 + r2) * math.sqrt((r2 - r1) ** 2 + h ** 2)\n    total_area = lateral_area + math.pi * (r1 ** 2 + r2 ** 2)\n    volume = (1 / 3) * math.pi * h * (r1 ** 2 + r2 ** 2 + r1 * r2)\n    \n    return {\n        'lateral_surface_area': lateral_area,\n        'total_surface_area': total_area,\n        'volume': volume,\n    }"]], "Transformations": [["def dilate_figure(points, scale_factor, center=(0, 0), is_complex=False):\n    \"\"\"\n    Perform a dilation transformation on a set of points.\n    Parameters:\n    - points (list of tuples or list of complex): Coordinates of points to transform.\n      Each point can either be a tuple (x, y) in Cartesian coordinates or a complex number.\n    - scale_factor (float): Factor by which the figure size is scaled.\n    - center (tuple or complex, optional): Point that acts as the center of dilation.\n      Default is (0, 0) for Cartesian or 0j for complex.\n    - is_complex (bool): Whether the coordinates are given in the complex plane.\n    Returns:\n    - list: New coordinates of the points after dilation.\n    Example:\n    >>> dilate_figure([(1, 2), (3, 4)], 2)\n    [(2, 4), (6, 8)]\n    >>> dilate_figure([(1+2j, 3+4j)], 2, is_complex=True)\n    [2+4j, 6+8j]\n    \"\"\"\n    if is_complex:\n        return [(p - center) * scale_factor + center for p in points]\n    else:\n        return [(scale_factor * (p[0] - center[0]) + center[0], scale_factor * (p[1] - center[1]) + center[1]) for p in points]", "def dilate_point_cartesian(px, py, scale_factor, center_x=0, center_y=0):\n    \"\"\"\n    Apply a dilation transformation to a point in the Cartesian plane.\n    Parameters:\n    - px (float): x-coordinate of the point to be dilated.\n    - py (float): y-coordinate of the point to be dilated.\n    - scale_factor (float): Scaling factor for the dilation.\n    - center_x (float): x-coordinate of the center of dilation.\n    - center_y (float): y-coordinate of the center of dilation.\n    \n    Returns:\n    - tuple: Coordinates of the transformed point (new_x, new_y).\n    \n    Examples:\n    >>> dilate_point_cartesian(2, 3, 2, 1, 1)\n    (3, 5)\n    \"\"\"\n    new_x = center_x + scale_factor * (px - centerx)\n    new_y = center_y + scale_factor * (py - centery)\n    return new_x, new_y", "def dilate_point_complex(z, scale_factor, center=0):\n    \"\"\"\n    Apply a dilation transformation to a point in the complex plane.\n    Parameters:\n    - z (complex): Complex number representing the point to be dilated.\n    - scale_factor (float): Scaling factor for the dilation.\n    - center (complex): Complex number representing the center of dilation.\n    \n    Returns:\n    - complex: Transformed complex number after dilation.\n    \n    Examples:\n    >>> dilate_point_complex(1+2j, 2, 1+1j)\n    (1+3j)\n    \"\"\"\n    return center + scale_factor * (z - center)"], ["def reflect_point(point, line):\n    \"\"\"\n    Reflects a point across a specified line in 2D space.\n    Parameters:\n    - point (tuple of float): The coordinates of the point to reflect (x, y).\n    - line (str): the line across which to reflect ('y-axis', 'x-axis', 'y=x', 'y=-x').\n    Returns:\n    - tuple: The coordinates of the reflected point.\n    \n    Examples:\n    >>> reflect_point((2, 3), 'y-axis')\n    (-2, 3)\n    >>> reflect_point((2, 3), 'x-axis')\n    (2, -3)\n    >>> reflect_point((3, 2), 'y=x')\n    (2, 3)\n    >>> reflect_point((3, 2), 'y=-x')\n    (-2, -3)\n    \"\"\"\n    if line == 'y-axis':\n        return (-point[0], point[1])\n    elif line == 'x-axis':\n        return (point[0], -point[1])\n    elif line == 'y=x':\n        return (point[1], point[0])\n    elif line == 'y=-x':\n        return (-point[1], -point[0])\n    else:\n        raise ValueError(\"Unknown line for reflection.\")", "def reflect_point(point, axis='x'):\n    \"\"\"\n    Reflect a point across a specified axis or line.\n    \n    Parameters:\n    - point (tuple): Coordinates of the point to reflect (x, y).\n    - axis (str or tuple): Axis or line to reflect across.\n      - 'x': Reflect across the x-axis.\n      - 'y': Reflect across the y-axis.\n      - (m, c): Tuple representing line y = mx + c.\n    \n    Returns:\n    - tuple: Coordinates of the reflected point.\n    \n    Examples:\n    >>> reflect_point((2, 3), 'x')\n    (2, -3)\n    >>> reflect_point((2, 3), 'y')\n    (-2, 3)\n    >>> reflect_point((1, 2), (1, 0))  # y = x\n    (2, 1)\n    \"\"\"\n    x, y = point\n    if axis == 'x':\n        return (x, -y)\n    elif axis == 'y':\n        return (-x, y)\n    elif isinstance(axis, tuple) and len(axis) == 2:\n        m, c = axis\n        if m == 1:  # Reflect over y = x\n            return (y, x)\n        elif m == -1:  # Reflect over y = -x\n            return (-y, -x)\n        else:\n            # Reflection across y = mx + c needs finding intersection and then the symmetric point\n            # For simplicity here, only handle y = x, which is common\n            raise NotImplementedError(\"Reflection over lines other than y=x and y=-x not implemented.\")\n    else:\n        raise ValueError(\"Invalid axis value. Use 'x', 'y', or tuple (m, c) for line.\")", "def reflect_point(point, axis='y', axis_position=0):\n    \"\"\"\n    Reflects a point across a specified axis either y-axis ('y') or x-axis ('x').\n    Parameters\n    ----------\n    point : tuple of float\n        (x, y) coordinates of the point to reflect.\n    axis : str, optional\n        Axis across which to reflect the point ('x' or 'y'), defaults to 'y'.\n    axis_position : float, optional\n        Position of the axis of reflection. Defaults to 0 which corresponds to the y or x axis.\n    Returns\n    -------\n    tuple of float\n        New coordinates of the reflected point.\n    Examples\n    --------\n    >>> reflect_point((2, 3), 'y')\n    (-2, 3)\n    >>> reflect_point((2, 3), 'x')\n    (2, -3)\n    \"\"\"\n    if axis == 'y':\n        x_new = 2 * axis_position - point[0]\n        y_new = point[1]\n    else:  # 'x' axis reflection\n        x_new = point[0]\n        y_new = 2 * axis_position - point[1]\n    \n    return (x_new, y_new)", "def reflect_point(point, axis='x', line_position=0):\n    \"\"\"\n    Reflect a point across a specified axis at a specific position.\n    Parameters:\n    - point (tuple): The coordinates (x, y) of the point to be reflected.\n    - axis (str): The axis along which to reflect ('x' or 'y').\n    - line_position (float): The position of the line along which the reflection is to be made.\n    \n    Returns:\n    - tuple: The coordinates of the reflected point.\n    \n    Examples:\n    - reflect_point((3, 4), 'x', 2) would reflect the point (3,4) over the line x=2, resulting in (1,4).\n    - reflect_point((3, 4), 'y', 1) would reflect the point (3,4) over the line y=1, resulting in (3,-2).\n    \"\"\"\n    if axis == 'x':\n        reflected_point = (2*line_position - point[0], point[1])\n    elif axis == 'y':\n        reflected_point = (point[0], 2*line_position - point[1])\n    else:\n        raise ValueError(\"Axis must be 'x' or 'y'\")\n    \n    return reflected_point", "def reflect_point(point, axis='x'):\n    \"\"\"\n    Reflects a given point across a specified axis.\n    Parameters\n    ----------\n    point : tuple\n        A 2D point (x, y) you want to reflect.\n    axis : str, optional\n        The axis to reflect the point across. Supported values: 'x', 'y', 'y=x'.\n        Default is 'x'.\n    Returns\n    -------\n    tuple\n        The reflected point.\n    Examples\n    --------\n    >>> reflect_point((2, 3), 'x')\n    (2, -3)\n    >>> reflect_point((2, 3), 'y')\n    (-2, 3)\n    >>> reflect_point((2, 3), 'y=x')\n    (3, 2)\n    \"\"\"\n    x, y = point\n    if axis == 'x':\n        return (x, -y)\n    elif axis == 'y':\n        return (-x, y)\n    elif axis == 'y=x':\n        return (y, x)\n    else:\n        raise ValueError(\"Unsupported axis. Choose from 'x', 'y', 'y=x'.\")", "def reflect_point(point, axis, position=0):\n    \"\"\"\n    Reflect a point across a specified axis.\n    Parameters:\n    point : tuple\n        The (x, y) coordinates of the point to reflect.\n    axis : str\n        The axis across which to reflect ('x' or 'y').\n    position : float, optional\n        The position of the axis of reflection (default is 0 for either axis).\n        \n    Returns:\n    tuple\n        The reflected (x, y) coordinates.\n        \n    Examples:\n    >>> reflect_point((2, 3), 'y')\n    (-2, 3)\n    >>> reflect_point((3, 4), 'x', 2)\n    (3, 0)\n    \"\"\"\n    x, y = point\n    if axis.lower() == 'y':\n        return (2*position - x, y)\n    elif axis.lower() == 'x':\n        return (x, 2*position - y)\n    else:\n        raise ValueError(\"Axis must be 'x' or 'y'.\")"], ["def transform_point(point, transformations):\n    \"\"\"\n    Apply a series of transformations to a point.\n    \n    Parameters:\n    - point (tuple): Initial coordinates of the point (x, y).\n    - transformations (list of tuples): List of transformations to apply.\n      Each tuple has the form (transformation_type, value), where transformation_type\n      can be 'reflect', 'translate', or others, and value depends on the type.\n    \n    Returns:\n    - tuple: Coordinates of the point after all transformations.\n    \n    Examples:\n    >>> transform_point((3, 4), [('reflect', 'x'), ('reflect', 'y')])\n    (-3, -4)\n    >>> transform_point((2, 5), [('reflect', 'x'), ('translate', (0, 2))])\n    (2, -3)\n    \"\"\"\n    x, y = point\n    for transformation, value in transformations:\n        if transformation == 'reflect':\n            x, y = reflect_point((x, y), value)\n        elif transformation == 'translate':\n            dx, dy = value\n            x += dx\n            y += dy\n        else:\n            raise ValueError(\"Unsupported transformation type.\")\n    \n    return (x, y)", "def apply_transformations(point, transformations):\n    \"\"\"\n    Apply a series of transformations to a point.\n    Parameters:\n    point : tuple \n        The (x, y) coordinates of the point.\n    transformations : list \n        A list of functions that take a point and return a new point.\n        \n    Returns:\n    tuple \n        The (x, y) coordinates of the transformed point.\n        \n    Examples:\n    >>> transformations = [\n            lambda p: rotate_point(p, 90), \n            lambda p: translate_point(p, (1, 2))\n        ]\n    >>> apply_transformations((1, 0), transformations)\n    (3, -1)\n    \"\"\"\n    for transform in transformations:\n        point = transform(point)\n    return point"], ["def area_of_rectangle(length, breadth):\n    \"\"\"\n    Calculates the area of a rectangle.\n    Parameters:\n    - length (float): The length of the rectangle.\n    - breadth (float): The breadth of the rectangle.\n    Returns:\n    - float: The area of the rectangle.\n    \n    Examples:\n    >>> area_of_rectangle(4, 5)\n    20.0\n    \"\"\"\n    return length * breadth", "def area_of_rectangle(length, breadth):\n    \"\"\"\n    Computes the area of a rectangle.\n    Parameters\n    ----------\n    length : float\n        The length of the rectangle.\n    breadth : float\n        The breadth of the rectangle.\n    Returns\n    -------\n    float\n        The area of the rectangle.\n    Examples\n    --------\n    >>> area_of_rectangle(5, 3)\n    15\n    \"\"\"\n    return length * breadth"], ["def area_of_triangle(base, height):\n    \"\"\"\n    Calculates the area of a triangle using base and height.\n    Parameters:\n    - base (float): The base of the triangle.\n    - height (float): The height of the triangle.\n    Returns:\n    - float: The area of the triangle (1/2 * base * height).\n    \n    Examples:\n    >>> area_of_triangle(3, 4)\n    6.0\n    \"\"\"\n    return 0.5 * base * height", "def area_of_triangle(base, height):\n    \"\"\"\n    Computes the area of a triangle.\n    Parameters\n    ----------\n    base : float\n        The base of the triangle.\n    height : float\n        The height of the triangle.\n    Returns\n    -------\n    float\n        The area of the triangle, given by 1/2 * base * height.\n    Examples\n    --------\n    >>> area_of_triangle(4, 3)\n    6.0\n    \"\"\"\n    return 0.5 * base * height"], ["def main_drawing():\n    \"\"\"\n    An example function to demonstrate drawing a shape and its transformation.\n    \n    Returns:\n    None\n    \"\"\"\n    square = np.array([[0, 0], [1, 0], [1, 1], [0, 1]])\n    translated_square = translate(square, np.array([2, 3]))\n    rotated_square = rotate(square, 45)\n    plt.figure()\n    plot_shape(square, color='blue', label='Original Square')\n    plot_shape(translated_square, color='green', label='Translated Square')\n    plot_shape(rotated_square, color='red', label='Rotated Square')\n    plt.legend()\n    plt.show()\n    main_drawing()"], ["def translate_point(point, vector):\n    \"\"\"\n    Translates a point by a given vector.\n    Parameters\n    ----------\n    point : tuple\n        A 2D point (x, y) you want to translate.\n    vector : tuple\n        A 2D vector (dx, dy) representing the translation.\n    Returns\n    -------\n    tuple\n        The translated point.\n    Examples\n    --------\n    >>> translate_point((3, 4), (1, -2))\n    (4, 2)\n    \"\"\"\n    x, y = point\n    dx, dy = vector\n    return (x + dx, y + dy)", "def translate_point(point, vector):\n    \"\"\"\n    Translate a point by a given vector.\n    Parameters:\n    point : tuple\n        The (x, y) coordinates of the point to translate.\n    vector : tuple\n        The (dx, dy) translation vector.\n        \n    Returns:\n    tuple\n        The translated (x, y) coordinates.\n    \n    Examples:\n    >>> translate_point((1, 2), (3, 1))\n    (4, 3)\n    \"\"\"\n    x, y = point\n    dx, dy = vector\n    return (x + dx, y + dy)"], ["def plot_shape(shape, ax=None, **kwargs):\n    \"\"\"\n    Plot a geometric shape.\n    Parameters:\n    shape (np.array): An Nx2 numpy array representing points of the shape.\n    ax (matplotlib.axes.Axes, optional): Matplotlib axis object to plot on. If None, uses the current axis.\n    **kwargs: Keyword arguments that are passed to the `plot` function of matplotlib.\n    Returns:\n    None\n    \"\"\"\n    if ax is None:\n        ax = plt.gca()\n    # Ensure the shape is closed by repeating the first point\n    shape = np.vstack([shape, shape[0]])\n    ax.plot(shape[:, 0], shape[:, 1], **kwargs)\n    ax.set_aspect('equal')"], ["def rotate_point_around_origin(point, angle_degrees, clockwise=True):\n    \"\"\"\n    Rotates a point around the origin (0, 0) by a specified angle in degrees.\n    \n    Parameters:\n        point (tuple): The (x, y) coordinates of the point to rotate.\n        angle_degrees (float): The angle in degrees by which to rotate the point.\n        clockwise (bool): True if the rotation should be clockwise, False if counterclockwise.\n    \n    Returns:\n        tuple: The rotated (x, y) coordinates of the point.\n    \n    Examples:\n        >>> rotate_point_around_origin((1, 0), 90)\n        (0, -1)\n        >>> rotate_point_around_origin((0, 1), 90, clockwise=False)\n        (-1, 0)\n    \"\"\"\n    angle_radians = np.deg2rad(angle_degrees)\n    if not clockwise:\n        angle_radians = -angle_radians\n    rotation_matrix = np.array([\n        [np.cos(angle_radians), -np.sin(angle_radians)],\n        [np.sin(angle_radians), np.cos(angle_radians)]\n    ])\n    rotated_point = np.dot(rotation_matrix, np.array(point))\n    return tuple(rot", "def rotate_point(point, angle_degrees, center=(0, 0)):\n    \"\"\"\n    Rotate a point around a given center by a specified angle in degrees.\n    Parameters\n    ----------\n    point : tuple of float\n        (x, y) coordinates of the point to rotate.\n    angle_degrees : float\n        Angle in degrees by which the point should be rotated. Positive angle results in counter-clockwise rotation.\n    center : tuple of float, optional\n        (x, y) coordinates of the center of rotation, defaults to the origin (0, 0).\n    Returns\n    -------\n    tuple of float\n        New coordinates of the rotated point.\n    Examples\n    --------\n    >>> rotate_point((1, 0), 90)\n    (6.123233995736766e-17, 1.0)\n    >>> rotate_point((1, 2), 45, center=(1, 2))\n    (1.0, 2.0)\n    \"\"\"\n    angle_radians = math.radians(angle_degrees)\n    cos_theta, sin_theta = math.cos(angle_radians), math.sin(angle_radians)\n    \n    # Translate point to origin\n    x_shifted, y_shifted = point[0] - center[0], point[1] - center[1]\n    \n    # Rotate point\n    x_new = x_shifted * cos_theta - y_shifted * sin_theta\n    y_new = x_shifted * sin_theta + y_shifted * cos_theta\n    \n    # Translate point back\n    x_final, y_final = x_new + center[0], y_new + center[1]\n    \n    return (x_final, y_final)", "def rotate_point(point, angle, origin=(0, 0)):\n    \"\"\"\n    Rotate a point around a given origin by a specific angle.\n    Parameters:\n    - point (tuple): The coordinates (x, y) of the point.\n    - angle (float): The rotation angle in degrees.\n    - origin (tuple): The origin around which the point is rotated.\n    Returns:\n    - tuple: The coordinates of the rotated point.\n    \n    Examples:\n    - rotate_point((1, 0), 90) will rotate (1,0) by 90 degrees around the origin, resulting in (0,1).\n    - rotate_point((0, 1), 90, (1, 1)) will rotate (0,1) by 90 degrees around (1,1), resulting in (1,0).\n    \"\"\"\n    angle_rad = np.radians(angle)\n    sin_a, cos_a = np.sin(angle_rad), np.cos(angle_rad)\n    x, y = point\n    ox, oy = origin\n    # Translate point to origin\n    x -= ox\n    y -= oy\n    # Rotate point\n    x_new = x * cos_a - y * sin_a\n    y_new = x * sin_a + y * cos_a\n    # Translate point back\n    x_new += ox\n    y_new += oy\n    return (x_new, y_new)", "def rotate_point(point, angle_degree, center=(0, 0)):\n    \"\"\"\n    Rotate a point clockwise around a given center by a specified angle in degrees.\n    Parameters:\n    point : tuple\n        The (x, y) coordinates of the point to rotate.\n    angle_degree : float\n        The angle in degrees for the clockwise rotation.\n    center : tuple, optional\n        The (x, y) coordinates of the center of rotation (default is the origin (0, 0)).\n    Returns:\n    tuple\n        The rotated (x, y) coordinates.\n        \n    Examples:\n    >>> rotate_point((1, 0), 90)\n    (0, -1)\n    >>> rotate_point((1, 1), 90, (1, 1))\n    (1, 1)\n    \"\"\"\n    angle_radians = np.deg2rad(angle_degree)\n    cosine = np.cos(angle_radians)\n    sine = np.sin(angle_radians)\n    x, y = point\n    cx, cy = center\n    \n    # Translate point back to the origin:\n    x -= cx\n    y -= cy\n    \n    # Perform rotation\n    x_new = x * cosine + y * sine\n    y_new = -x * sine + y * cosine\n    \n    # Translate point back to the original location:\n    x_new += cx\n    y_new += cy\n    \n    return (x_new, y_appropriate)"], ["def calculate_distance(point1, point2, is_complex=False):\n    \"\"\"\n    Calculate the Euclidean distance between two points in the plane.\n    Parameters:\n    - point1, point2 (tuple or complex): The points between which distance is calculated.\n      Each point can either be a tuple (x, y) in Cartesian coordinates or a complex number.\n    - is_complex (bool): Whether the points are specified as complex numbers.\n    Returns:\n    - float: The calculated Euclidean distance.\n    Example:\n    >>> calculate_distance((1, 2), (4, 6))\n    5.0\n    >>> calculate_distance(1+2j, 4+6j, is_dateinline=True)\n    5.0\n    \"\"\"\n    if is_complex:\n        return abs(point1 - point2)\n    else:\n        return np.sqrt((point1[0] - point2[0])**2 + (point1[1] - point2[1])**2)"], ["def farthest_point(points, reference_point):\n    \"\"\"\n    Calculate the farthest point from a given reference point within a set of points.\n    \n    Parameters:\n    - points (np.ndarray): A numpy array of points, where each point is represented as a row.\n    - reference_point (tuple): A tuple (x, y) representing the reference point.\n    \n    Returns:\n    - tuple: The farthest point coordinates and its distance from the reference point.\n    \n    Example:\n    >>> points = np.array([[1, 2], [3, 4], [5, 6]])\n    >>> reference_point = (0, 0)\n    >>> farthest_point(points, reference_point)\n    ((5, 6), 7.810249675906654)\n    \"\"\"\n    # Calculate distances\n    dists = np.sqrt(np.sum((points - np.array(reference_point))**2, axis=1))\n    # Find index of the maximum distance\n    max_index = np.argmax(dists)\n    return (tuple(points[max_ index]), dists[max_index])"], ["def translate(shape, vector):\n    \"\"\"\n    Apply a translation to a geometric shape.\n    Parameters:\n    shape (np.array): An Nx2 numpy array representing points of the shape in 2D (each row is a point).\n    vector (np.array): A 1x2 numpy array representing the translation vector.\n    Returns:\n    np.array: Translated shape as an Nx2 numpy array.\n    Example:\n    >>> translate(np.array([[0, 0], [1, 0], [1, 1]]), np.array([2, 3]))\n    array([[2, 3], [3, 3], [3, 4]])\n    \"\"\"\n    return shape + vector"], ["def reflect(shape, axis):\n    \"\"\"\n    Reflect a shape across a specified axis.\n    Parameters:\n    shape (np.array): An Nx2 numpy array of points.\n    axis (int): Axis to reflect across. 0 for y-axis, 1 for x-axis.\n    Returns:\n    np.array: Reflected shape as an Nx2 numpy array.\n    Example:\n    >>> reflect(np.array([[1, 1], [-1, 1]]), 0)\n    array([[-1,  1],\n           [ 1,  1]])\n    \"\"\"\n    reflected_shape = np.copy(shape)\n    reflected_shape[:, axis] = -reflected_shape[:, axis]\n    return reflected_shape"], ["def reflect_point_over_line(point, line_coefficients):\n    \"\"\"\n    Calculate the reflection of a point across a line represented in standard form.\n    Parameters:\n    - point (tuple): A tuple (x, y) representing the coordinates of the point to reflect.\n    - line_coefficients (tuple): A tuple (A, B, C) representing the line Ax + By + C = 0.\n    Returns:\n    - tuple: Coordinates of the reflected point.\n    Example:\n    >>> reflect_point_over_line((1, 1), (1, -1, 0)) \n    (1, 1)\n    \"\"\"\n    x, y = point\n    A, B, C = line_coefficients\n    D = A * A + B * B\n    x_prime = (B * B * x - A * B * y - A * C) / D\n    y_prime = (A * A * y - A * B * x - B * C) / D\n    return (x_prime, y_prime)"], ["def scale_figure(points, center, scale_factor):\n    \"\"\"\n    Scale a figure based on a given set of coordinates around a specified center with a given scale factor.\n    \n    Parameters:\n    - points (np.ndarray): A numpy array of points, where each row represents a point in 2D (x, y)\n    - center (tuple): A tuple (x, y) representing the center of scaling.\n    - scale_factor (float): The factor by which to scale the figure.\n    \n    Returns:\n    - np.ndarray: Transformed points after scaling.\n    \n    Example:\n    >>> points = np.array([[1, 1], [2, 2], [3, 3]])\n    >>> center = (2, 2)\n    >>> scale_factor = 2\n    >>> scale_figure(points, center, scale_factor)\n    array([[0, 0], [2, 2], [4, 4]])\n    \"\"\"\n    # Convert center into a numpy array\n    center = np.array(center)\n    # Calculate the new points\n    new_points = (points - center) * scale_factor + center\n    return new_points"], ["def apply_affine_transformation(point, matrix, translation_vector=(0, 0)):\n    \"\"\"\n    Apply an affine transformation to a 2D point using a transformation matrix and optional translation.\n    Parameters:\n    - point (tuple): A tuple (x, y) representing the coordinates of the initial point.\n    - matrix (array): A 2x2 numpy array representing the rotation or scaling matrix.\n    - translation_vector (tuple): A tuple (dx, dy) representing the translation.\n    Returns:\n    - tuple: Coordinates of the transformed point.\n    Example:\n    >>> apply_affine_transformation((1, 0), np.array([[0, -1], [1, 0]]), (1, 1))\n    (1, 2)\n    \"\"\"\n    transformed_point = np.dot(matrix, np.array(point)) + np.array(translation_vector)\n    return tuple(transformed_point)"], ["def plot_reflection(point, reflected_point, axis='x', line_position=0):\n    \"\"\"\n    Plot a point and its reflection to visually confirm the transformation.\n    Parameters:\n    - point (tuple): The original point.\n    - reflected_point (tuple): The reflected point.\n    - axis (str): Axis of reflection ('x' or 'y').\n    - line_position (float): Position of the reflection line.\n    Examples:\n    - plot_reflection((3, 4), (1, 4), 'x', 2) will plot original and reflected points over x=2.\n    \"\"\"\n    fig, ax = plt.subplots()\n    ax.scatter(*zip(point, reflected_point), c=['blue', 'red'])\n    \n    # Determine the limits\n    all_x = [point[0], reflected_point[0]]\n    all_y = [point[1], reflected_point[1]]\n    \n    if axis == 'x':\n        ax.axvline(x=line_position, color='gray', linestyle='--')\n        plt.xlim(min(all_x) - 1, max(all_x) + 1)\n        plt.ylim(min(all_y) - 1, max(all_y) + 1)\n    elif axis == 'y':\n        ax.axhline(y=line_position, color='gray', linestyle='--')\n        plt.xlim(min(all_x) - 1, max(all_x) + 1)\n        plt.ylim(min(all_y) - 1, max(all_y) + 1)\n    ax.set_aspect('equal', adjustable='box')\n    plt.show()"], ["def translate_point(point, shift):\n    \"\"\"\n    Translates a point by a given shift in the coordinate plane.\n    Parameters\n    ----------\n    point : tuple of float\n        (x, y) coordinates of the point to be translated.\n    shift : tuple of float\n        (dx, dy) values by which the point should be shifted horizontally and vertically.\n    Returns\n    -------\n    tuple of float\n        New coordinates of the translated point.\n    Examples\n    --------\n    >>> translate_point((1, 2), (3, -1))\n    (4, 1)\n    \"\"\"\n    x_new, y_new = point[0] + shift[0], point[1] + shift[1]\n    return (x_new, y_new)"], ["def rotate(shape, angle, origin=np.array([0, 0])):\n    \"\"\"\n    Rotate a shape counterclockwise by a given angle around an origin.\n    Parameters:\n    shape (np.array): An Nx2 numpy array of points representing the shape.\n    angle (float): Angle of rotation in degrees.\n    origin (np.array, optional): 1x2 numpy array representing the rotation origin. Defaults to the origin.\n    Returns:\n    np.array: Rotated shape as an Nx2 numpy array.\n    Example:\n    >>> rotate(np.array([[1, 0], [0, 1]]), 90)\n    array([[ 0.,  1.],\n           [-1.,  0.]])\n    \"\"\"\n    rad = np.deg2rad(angle)\n    rotation_matrix = np.array([[np.cos(rad), -np.sin(rad)], [np.sin(rad), np.cos(rad)]])\n    return np.dot(shape - origin, rotation_matrix) + origin"]], "Squares": [["def calculate_square_area(side_length):\n    \"\"\"\n    Calculate the area of a square using its side length.\n    Parameters:\n    - side_length (float or int): The length of a side of the square.\n    Returns:\n    - float or int: The area of the square.\n    Examples:\n    >>> calculate_square_area(4)\n    16\n    >>> calculate_square_area(1.5)\n    2.25\n    \"\"\"\n    return side_length ** 2", "def calculate_square_area(side_length):\n    \"\"\"\n    Calculate the area of a square given the side length.\n    \n    Parameters:\n    - side_length (float): The length of the side of the square.\n    \n    Returns:\n    - float: The area of the square.\n    \n    Example:\n    >>> calculate_square_area(4)\n    16\n    \"\"\"\n    return side_length ** 2", "def square_side_from_area(area):\n    \"\"\"\n    Calculate the side length of a square given its area.\n    \n    Parameters:\n    area : float\n        The area of the square.\n        \n    Returns:\n    float\n        The length of one side of the square.\n    \n    Examples:\n    >>> square_side_from_area(25)\n    5.0\n    \"\"\"\n    from math import sqrt\n    return sqrt(area)", "def square_area(side_length):\n    \"\"\"\n    Calculate the area of a square given the side length.\n    \n    Parameters:\n    side_length : float\n        The side length of the square.\n        \n    Returns:\n    float\n        The area of the square.\n    \n    Examples:\n    >>> square_area(5)\n    25\n    \"\"\"\n    return side_length ** 2", "def calculate_square_area(side_length):\n    \"\"\"\n    Calculate the area of a square given the side length.\n    \n    Parameters:\n    side_length (float): The length of a side of the square.\n    \n    Returns:\n    float: The area of the square.\n    \n    Examples:\n    >>> calculate_square_area(5)\n    25\n    \"\"\"\n    return side_length ** 2"], ["def inscribed_circle_diameter_in_square(side_length):\n    \"\"\"\n    Calculate the diameter of a circle inscribed in a square.\n    Parameters:\n    - side_length (float or int): The side length of the square.\n    Returns:\n    - float or int: The diameter of the inscribed circle.\n    Examples:\n    >>> inscribed_circle_diameter_in_square(4)\n    4\n    >>> inscribed_circle_diameter_in_square(10)\n    10\n    \"\"\"\n    return side_length  # Diameter of the inscribed circle in a square is the same as the side length", "def calculate_side_from_inscribed_circle_diameter(diameter):\n    \"\"\"\n    Calculate the side length of a square from the diameter of its inscribed circle.\n    \n    Parameters:\n    diameter (float): The diameter of the inscribed circle.\n    \n    Returns:\n    float: The side length of the square.\n    \n    Examples:\n    >>> calculate_side_from_inscribed_circle_diameter(5)\n    6.363961030678928 # approximately sqrt(2) * diameter / 2\n    \"\"\"\n    import math\n    # The side of the square is the diameter of the inscribed circle times sqrt(2)\n    return math.sqrt(2) * diameter / 2"], ["def calculate_ratio_of_areas(side_length1, side_length2):\n    \"\"\"\n    Calculate the ratio of the areas of two squares given their side lengths.\n    \n    Parameters:\n    side_length1 (float): The side length of the first square.\n    side_length2 (float): The side length of the second square.\n    \n    Returns:\n    float: The ratio of the area of the first square to the area of the second square.\n    \n    Examples:\n    >>> calculate_ratio_of_areas(4, 2)\n    4.0\n    \"\"\"\n    return (side_length1 ** 2) / (side_length2 ** 2)", "def side_length_ratio_between_squares(area1, area2):\n    \"\"\"\n    Calculates the ratio of the side lengths of two squares given their areas.\n    \n    Parameters:\n    area1 : float\n        The area of the first square.\n    area2 : float\n        The area of the second square.\n        \n    Returns:\n    float\n        The ratio of the side length of the first square to the second.\n    \n    Examples:\n    >>> side_length_ratio_between_squares(25, 16)\n    1.25\n    \"\"\"\n    from math import sqrt\n    return sqrt(area1 / area2)"], ["def calculate_square_properties(side_length):\n    \"\"\"\n    Calculate various properties of a square, including area, perimeter, and diagonal.\n    Parameters:\n    - side_length (float): The length of a side of the square.\n    Returns:\n    - dict: A dictionary containing the area, perimeter, and diagonal length of the square.\n    Examples:\n    >>> calculate_square_properties(4)\n    {'area': 16, 'perimeter': 16, 'diagonal': 5.656854249492381}\n    \"\"\"\n    area = side_length ** 2\n    perimeter = 4 * side_length\n    diagonal = math.sqrt(2) * side_length\n    \n    return {\n        'area': area,\n        'perimeter': perimeter,\n        'diagonal': diagonal\n    }", "def square_measurements(side_length):\n    \"\"\"\n    Calculate properties of a square given the side length.\n    \n    Parameters:\n    side_length (float): The length of a side of the square.\n    \n    Returns:\n    dict: A dictionary containing the area, perimeter, and diagonal length of the square.\n    \n    Examples:\n    >>> square_measurements(5)\n    {'area': 25, 'perimeter': 20, 'diagonal': 7.0710678118654755}\n    \"\"\"\n    area = side_length ** 2\n    perimeter = 4 * side_length\n    diagonal = side_length * math.sqrt(2)\n    \n    return {\n        'area': area,\n        'perimeter': perimeter,\n        'diagonal': diagonal\n    }"], ["def calculate_square_perimeter(side_length):\n    \"\"\"\n    Calculate the perimeter of a square given the side length.\n    Parameters:\n    - side_length (float or int): The length of a side of the square.\n    Returns:\n    - float or int: The perimeter of the square.\n    Examples:\n    >>> calculate_square_perimeter(4)\n    16\n    >>> calculate_square_perimeter(1.5)\n    6.0\n    \"\"\"\n    return 4 * side_length", "def calculate_square_perimeter(side_length):\n    \"\"\"\n    Calculate the perimeter of a square given the side length.\n    \n    Parameters:\n    - side_length (float): The length of the side of the square.\n    \n    Returns:\n    - float: The perimeter of the square.\n    \n    Example:\n    >>> calculate_square_perimeter(4)\n    16\n    \"\"\"\n    return 4 * side_length", "def square_perimeter(side_length):\n    \"\"\"\n    Calculate the perimeter of a square given the side length.\n    \n    Parameters:\n    side_length : float\n        The length of the side of the square.\n        \n    Returns:\n    float\n        The perimeter of the square.\n    \n    Examples:\n    >>> square_perimeter(5)\n    20\n    \"\"\"\n    return 4 * side_length", "def calculate_square_perimeter(side_length):\n    \"\"\"\n    Calculate the perimeter of a square given the side length.\n    \n    Parameters:\n    side_length (float): The length of a side of the square.\n    \n    Returns:\n    float: The perimeter of the square.\n    \n    Examples:\n    >>> calculate_square_perimeter(5)\n    20\n    \"\"\"\n    return 4 * side_length"], ["def proportional_area(side_length_1, side_length_2, given_area):\n    \"\"\"\n    Given two squares with respective side lengths and area of the smaller square, \n    compute the area of the larger square based on proportional relationships.\n    \n    Parameters:\n    - side_length_1 (float): The side length of the smaller square.\n    - side_length_2 (float): The side length of the larger square.\n    - given_area (float): The area of the smaller square.\n    Returns:\n    - float: The calculated area of the larger square.\n    \n    Examples:\n    >>> proportional_area(3, 6, 9)\n    36.0\n    \"\"\"\n    x = symbols('x')\n    smaller_area = side_length_1 ** 2\n    ratio = (side_length_2 / side_length_1) ** 2\n    larger_area = solve(Eq(smaller_area * ratio, x), x)[0]\n    \n    return larger_area"], ["def number_of_smaller_squares_in_larger_one(larger_side, smaller_side):\n    \"\"\"\n    Calculate the number of smaller squares that can fit within a larger square\n    based on the side lengths of the larger and smaller squares.\n    \n    Parameters:\n    larger_side : float\n        The side length of the larger square.\n    smaller_side : float\n        The side length of the smaller square.\n        \n    Returns:\n    int\n        The maximum number of smaller squares that can fit in the larger square.\n    \n    Examples:\n    >>> number_of_smaller_squares_in_larger_one(10, 2)\n    25\n    \"\"\"\n    return (larger_side // smaller_side) ** 2"], ["def number_of_squares(total_length, square_side):\n    \"\"\"\n    Calculate the maximum number of non-overlapping squares that can fit along a line of given total length.\n    Parameters:\n    - total_length (float): The total length of the line.\n    - square_side (float): The side length of each square.\n    Returns:\n    - int: The total number of non-overlapping squares that can fit.\n    Examples:\n    >>> number_of_squares(10, 2)\n    5\n    \"\"\"\n    return total_length // square_side"], ["def count_inscribed_squares(larger_square_side, smaller_square_side):\n    \"\"\"\n    Calculate how many smaller squares of a given side length can be inscribed within a larger square.\n    \n    Parameters:\n    larger_square_side (float): The side length of the larger square.\n    smaller_square_side (float): The side length of the smaller squares to fit inside the larger square.\n    \n    Returns:\n    int: Number of smaller squares that can fit inside the larger square.\n    \n    Examples:\n    >>> count_inscribed_squares(10, 2)\n    25\n    \"\"\"\n    num_per_side = larger_square_side // smaller_square_side\n    return num_per_side ** 2"], ["def calculate_square_diagonal(side_length):\n    \"\"\"\n    Calculate the diagonal of a square using the side length.\n    \n    Parameters:\n    - side_length (float): The length of the side of the square.\n    \n    Returns:\n    - float: The length of the diagonal of the square.\n    \n    Example:\n    >>> calculate_square_diagonal(4)\n    5.656854249492381\n    \"\"\"\n    return side_length * math.sqrt(2)", "def square_diagonal(side_length):\n    \"\"\"\n    Calculate the diagonal of a square given the side length.\n    \n    Parameters:\n    side_length : float\n        The side length of the square.\n        \n    Returns:\n    float\n        The length of the diagonal.\n    \n    Examples:\n    >>> square_diagonal(5)\n    7.0710678118654755\n    \"\"\"\n    from math import sqrt\n    return sqrt(2) * side_length"], ["def calculate_inscribed_circle_radius(side_length):\n    \"\"\"\n    Calculate the radius of a circle inscribed in a square.\n    \n    Parameters:\n    - side_length (float): The length of the side of the square.\n    \n    Returns:\n    - float: The radius of the inscribed circle.\n    \n    Example:\n    >>> calculate_inscribed_circle_radius(4)\n    2.0\n    \"\"\"\n    return side_length / 2"]], "Planes in Three Dimensions": [["def are_planes_parallel(plane_eq1, plane_eq2):\n    \"\"\"\n    Determines if two planes are parallel by checking if their normal vectors are proportional.\n    \n    Parameters:\n        plane_eq1 (sympy.Poly): The equation of the first plane.\n        plane_eq2 (sympy.Poly): The equation of the second plane.\n    \n    Returns:\n        bool: True if the planes are parallel, False otherwise.\n    \n    Example:\n        >>> plane1 = sp.Poly(x + 2*y + z, x, y, z)\n        >>> plane2 = sp.Poly(2*x + 4*y + 2*z, x, y, z)\n        >>> are_planes_parallel(plane1, plane2)\n        True\n    \"\"\"\n    A1, B1, C1, _ = plane_eq1.coeffs()\n    A2, B2, C2, _ = plane_eq2.coeffs()\n    return sp.simplify(A1/A2) == sp.simplify(B1/B2) == sp.simplify(C1/C2)", "def are_planes_parallel(coeffs1, coeffs2):\n    \"\"\"\n    Determine if two planes are parallel based on their normal vectors.\n    \n    Parameters:\n    - coeffs1, coeffs2 (tuple/list): Coefficients of the plane equations.\n    \n    Returns:\n    - bool: True if the planes are parallel (or the same), otherwise False.\n    \n    Examples:\n    >>> are_planes_parallel((1, 1, 1, -1), (2, 2, 2, -1))\n    True\n    \"\"\"\n    normal1 = np.array(coeffs1[:3])\n    normal2 = np.array(coeffs2[:3])\n    return np.allclose(normal1 / normal2, normal1[0] / normal2[0])", "def are_planes_parallel(plane1, plane2):\n    \"\"\"\n    Determines if two planes are parallel.\n    Parameters:\n        plane1, plane2 (tuple): The coefficients (A, B, C, D) of the plane equations\n    Returns:\n        bool: True if the planes are parallel, otherwise False\n    \n    Example:\n        >>> are_planes_parallel((0, 0, 1, 2), (0, 0, 1, 3))\n        True\n    \"\"\"\n    A1, B1, C1, _ = plane1\n    A2, B2, C2, _ = plane2\n    cross_prod = np.cross((A1, B1, C1), (A2, B2, C2))\n    return np.allclose(cross_prod, (0, 0, 0))"], ["def define_plane_from_points(point1, point2, point3):\n    \"\"\"\n    Define the equation of a plane given three non-collinear points.\n    \n    Parameters:\n        point1 (tuple): Coordinates (x1, y1, z1) of the first point.\n        point2 (tuple): Coordinates (x2, y2, z2) of the second point.\n        point3 (tuple): Coordinates (x3, y3, z3) of the third point.\n        \n    Returns:\n        sympy.Poly: The equation of the plane in symbolic form (Ax + By + Cz + D).\n    \n    Example:\n        >>> define_plane_from_points((1, 2, 3), (2, 3, 4), (4, 6, 7))\n        Poly(x + 2*y + z - 14, x, y, z, domain='ZZ')\n    \"\"\"\n    x, y, z = sp.symbols('x y z')\n    p1, p2, p3 = sp.Matrix(point1), sp.Matrix(point2), sp.Matrix(point3)\n    normal_vector = (p2 - p1).cross(p3 - p1)\n    A, B, C = normal_vector\n    D = sp.simplify(-(A*point1[0] + B*point1[1] + C*point1[2]))\n    plane_eq = A*x + B*y + C*z + D\n    return sp.Poly(plane_eq, x, y, z)", "def plane_from_normal_and_point(normal, point):\n    \"\"\"\n    Define the plane equation given a normal vector and a point through which the plane passes.\n    \n    Parameters:\n        normal (tuple): Normal vector of the plane (A, B, C).\n        point (tuple): A point (x0, y0, z0) on the plane.\n    \n    Returns:\n        sympy.Poly: The equation of the plane in symbolic form (Ax + By + Cz + D).\n    \n    Example:\n        >>> plane_from_normal_and_point((1, 2, 1), (3, 4, 5))\n        Poly(1*x + 2*y + 1*z - 14, x, y, z, domain='ZZ')\n    \"\"\"\n    x, y, z = sp.symbols('x y z')\n    A, B, C = normal\n    D = sp.simplify(-(A*point[0] + B*point[1] + C*point[2]))\n    plane_eq = A*x + B*y + C*z + D\n    return sp.Poly(plane_eq, x, y, z)", "def plane_equation_from_point_and_normal(point, normal):\n    \"\"\"\n    Define the equation of a plane using a point and a normal vector.\n    Parameters:\n    - point (tuple/list): Coordinates of a point on the plane (x, y, z).\n    - normal (tuple/list): The normal vector of the plane (A, B, C).\n    \n    Returns:\n    - tuple: Coefficients (A, B, C, D) of the plane equation.\n    \n    Examples:\n    >>> plane_equation_from_point_and_normal((1, 1, 1), (1, 1, 1))\n    (1, 1, 1, -3)\n    \"\"\"\n    A, B, C = normal\n    x, y, z = point\n    D = -(A * x + B * y + C * z)\n    return (A, B, C, D)"], ["def distance_point_to_plane(point, plane_eq):\n    \"\"\"\n    Calculate the distance from a point to a plane.\n    \n    Parameters:\n        point (tuple): The point (x0, y0, z0).\n        plane_eq (sympy.Poly): The equation of the plane in the form Ax + By + Cz + D = 0.\n        \n    Returns:\n        sympy.Expr: The distance from the point to the plane.\n    \n    Example:\n        >>> plane = sp.Poly(x + 2*y - 3*z + 4, x, y, z)\n        >>> distance_point_to_plane((1, 1, 1), plane)\n        2*sqrt(14)/7\n    \"\"\"\n    A, B, C, D = plane_eq.coeffs()\n    x0, y0, z0 = point\n    numerator = sp.Abs(A*x0 + B*y0 + C*z0 + D)\n    denominator = sp.sqrt(A**2 + B**2 + C**2)\n    distance = numerator / denominator\n    return distance.simplify()", "def point_to_plane_distance(point, plane_coeffs):\n    \"\"\"\n    Calculate the perpendicular distance from a point to a plane.\n    Parameters:\n    - point (tuple/list): Coordinates of the point (x, y, z).\n    - plane_coeffs (tuple/list): Coefficients (A, B, C, D) of the plane equation Ax + By + Cz + D = 0.\n    \n    Returns:\n    - float: The distance from the point to the plane.\n    \n    Examples:\n    >>> point_to_plane_distance((1, 2, 3), (1, 1, 1, -3))\n    4.242640687119285\n    \"\"\"\n    A, B, C, D = plane_coeffs\n    x, y, z = point\n    numerator = abs(A * x + B * y + C * z + D)\n    denominator = np.sqrt(A**2 + B**2 + C**2)\n    distance = numerator / denominator\n    return distance", "def distance_point_to_plane(point, plane):\n    \"\"\"\n    Calculate the perpendicular distance from a point to a given plane in 3D space.\n    Parameters:\n        point (tuple): The (x, y, z) coordinates of the point.\n        plane (tuple): The coefficients (A, B, C, D) of the plane equation Ax + By + Cz + D = 0\n    Returns:\n        float: The distance from the point to the plane.\n    \n    Example:\n        >>> distance_point_to_plane((1, 1, 1), (0, 0, 1, -1))\n        2.0\n    \"\"\"\n    x0, y0, z0 = point\n    A, B, C, D = plane\n    num = abs(A*x0 + B*y0 + C*z0 + D)\n    den = np.sqrt(A**2 + B**2 + C**2)\n    return num / den"], ["def check_point_on_plane(point, plane_coeffs):\n    \"\"\"\n    Check if a point is on a plane defined by the given equation.\n    Parameters:\n    - point (tuple/list): Coordinates of the point (x, y, z).\n    - plane_coeffs (tuple/list): Plane equation coefficients (A, B, C, D).\n    \n    Returns:\n    - bool: True if the point is on the plane, else False.\n    \n    Examples:\n    >>> check_point_on_plane((1, 2, 3), (1, 1, 1, -6))\n    True\n    \"\"\"\n    A, B, C, D = plane_coeffs\n    x, y, z = point\n    return abs(A * x + B * y + C * z + D) < 1e-10"], ["def plane_normal_vector(point1, point2, point3):\n    \"\"\"\n    Finds the normal vector to a plane defined by three points.\n    \n    Parameters:\n        point1 (tuple): Coordinates of the first point.\n        point2 (tuple): Coordinates of the second point.\n        point3 (tuple): Coordinates of the third point.\n        \n    Returns:\n        tuple: Normal vector components (A, B, C) of the plane.\n        \n    Example:\n        >>> plane_normal_vector((1, 2, 3), (2, 3, 4), (4, 6, 7))\n        (2, -5, 2)\n    \"\"\"\n    p1, p2, p3 = sp.Matrix(point1), sp.Matrix(point2), sp.Matrix(point3)\n    normal = (p2 - p1).cross(p3 - p1)\n    return tuple(normal)"], ["def plane_equation_from_points(p1, p2, p3):\n    \"\"\"\n    Calculate the equation of a plane that passes through three non-collinear points in 3D space.\n    \n    Parameters:\n    - p1, p2, p3 (tuple/list): Coordinate tuples/lists of the points (x, y, z).\n    \n    Returns:\n    - tuple: Coefficients (A, B, C, D) of the plane equation Ax + By + Cz + D = 0.\n    \n    Examples:\n    >>> plane_equation_from_points((1, 2, 3), (4, 5, 6), (7, 8, 9))\n    (0, 0, 0, 0)  # Points are collinear, thus no unique plane exists\n    >>> plane_equation_from_points((1, 0, 0), (0, 1, 0), (0, 0, 1))\n    (1, 1, 1, -1)\n    \"\"\"\n    p1, p2, p3 = np.array(p1), np.array(p2), np.array(p3)\n    v1 = p2 - p1\n    v2 = p3 - p1\n    normal_vector = np.cross(v1, v2)\n    A, B, C = normal_vector\n    D = -np.dot(normal_vector, p1)\n    return (A, B, C, D)", "def plane_equation_from_points(p1, p2, p3):\n    \"\"\"\n    Determine the equation of a plane given three non-collinear points in 3D space.\n    Parameters:\n        p1, p2, p3 (tuple): Tuples of the form (x, y, z) representing the coordinates of the points.\n    Returns:\n        tuple: Returns the coefficients (A, B, C, D) of the plane equation Ax + By + Cz + D = 0\n    \n    Example:\n        >>> plane_equation_from_points((0,0,0), (1,0,0), (0,1,0))\n        (0, 0, 1, 0)\n    \"\"\"\n    p1, p2, p3 = np.array(p1), np.array(p2), np.array(p3)\n    v1 = p2 - p1\n    v2 = p3 - p1\n    normal_vector = np.cross(v1, v2)\n    A, B, C = normal_vector\n    D = -np.dot(normal_vector, p1)\n    return (A, B, C, D)"]], "Similar Triangles": [["def are_similar_by_sss(lengths_a, lengths_b):\n    \"\"\"\n    Determine if two triangles are similar based on the Side-Side-Side (SSS) criterion.\n    \n    Parameters:\n    - lengths_a (list of float): Side lengths of the first triangle.\n    - lengths_b (list of float): Side lengths of the second triangle.\n    \n    Returns:\n    - bool: True if triangles are similar, otherwise False.\n    \n    Examples:\n    - are_similar_by_sss([3, 4, 5], [6, 8, 10]) returns True (since ratios are the same)\n    \"\"\"\n    ratios = calculate_ratio(lengths_a, lengths_b)\n    return len(set(ratios)) == 1  # Check if all ratios are the same", "def is_similar_by_sss(sides1, sides2, tolerance=1e-5):\n    \"\"\"\n    Check if two triangles are similar using the Side-Side-Side (SSS) similarity criterion.\n    Parameters:\n    - sides1 (array-like): Lengths of the sides of the first triangle.\n    - sides2 (array-like): Lengths of the sides of the second triangle.\n    - tolerance (float): Numerical tolerance for checking proportions.\n    Returns:\n    - bool: True if triangles are similar, False otherwise.\n    Examples:\n    >>> is_similar_by_sss([3, 4, 5], [6, 8, 10])\n    True\n    >>> is_similar_by_sss([5, 12, 13], [10, 24, 26])\n    True\n    \"\"\"\n    sides1_sorted = np.sort(sides1)\n    sides2_sorted = np.sort(sides2)\n    ratios = sides1_sorted / sides2_sorted\n    return np.allclose(ratios, ratios[0], atol=tolerance)"], ["def solve_for_missing_length(known_ratio, known_length):\n    \"\"\"\n    Using the known ratio of similar triangles and a known length, calculate the missing side length.\n    Parameters:\n    - known_ratio (float): The known ratio of sides.\n    - known_length (float): Known length of the corresponding side in the other triangle.\n    \n    Returns:\n    - float: Calculated length of the side in the other triangle.\n    \n    Examples:\n    - solve_for_missing_length(2.0, 5) returns 10.0\n    \"\"\"\n    return known_ratio * known_format", "def solve_proportion_for_missing_side(known_ratio, known_side):\n    \"\"\"\n    Calculate the missing side of a triangle given the proportion and one known side pair.\n    Parameters:\n    - known_ratio (float): Ratio of the sides from the similar triangle.\n    - known_side (float): Length of the known corresponding side.\n    Returns:\n    - float: The calculated length of the missing side.\n    Examples:\n    >>> solve_proportion_for_missing_side(0.5, 10)\n    5.0\n    \"\"\"\n    return known_side * known_ratio"], ["def check_triangle_similarity(angle_set1, angle_set2):\n    \"\"\"\n    Check if two triangles are similar based on the Angle-Angle (AA) similarity criterion.\n    Parameters:\n    - angle_set1 (tuple): A tuple of two angles (in degrees) from the first triangle.\n    - angle_set2 (tuple): A tuple of two angles (in degrees) from the second triangle.\n    Returns:\n    - is_similar (bool): True if the triangles are similar, False otherwise.\n    Example:\n    >>> check_triangle_similarity((30, 60), (30, 60))\n    True\n    >>> check_triangle_similarity((45, 45), (45, 90))\n    False\n    \"\"\"\n    a1, a2 = angle_set1\n    b1, b2 = angle_set2\n    \n    # Since the sum of angles in a triangle is 180, we can infer the third angle\n    a3 = 180 - (a1 + a2)\n    b3 = 180 - (b1 + b2)\n    \n    # Check if two angles from each triangle are the same\n    similarity_set = set([(a1, b1), (a1, b2), (a1, b3), \n                          (a2, b1), (a2, b2), (a2, b3), \n                          (a3, b1), (a3, b2), (a3, b3)])\n    \n    is_similar = (a1, b1) in similarity_set or (a1, b2) in similarity_set or (a2, b1) in similarity_set or (a2, b2) in similarity_set\n    return is_similar", "def check_triangle_similarity_by_aa(angle_list_1, angle_list_2):\n    \"\"\"\n    Check if two triangles are similar based on the Angle-Angle (AA) similarity criterion.\n    Parameters:\n    - angle_list_1 (list): List of three angles (in degrees) for the first triangle.\n    - angle_list_2 (list): List of three angles (in degrees) for the second triangle.\n    Returns:\n    - bool: True if the triangles are similar, False otherwise.\n    Examples:\n    >>> check_triangle_similarity_by_aa([60, 60, 60], [60, 60, 60])\n    True\n    >>> check_triangle_similarity_by_aa([45, 45, 90], [30, 60, 90])\n    False\n    \"\"\"\n    # Sorting both lists to align angles\n    sorted_angles_1 = sorted(angle_list_1)\n    sorted_angles_2 = sorted(angle_list_2)\n    \n    # Comparing two first corresponding angles from sorted lists\n    match_first = sorted_angles_1[0] == sorted_angles_2[0]\n    match_second = sorted_angles_1[1] == sorted_angles_2[1]\n    # Triangles are similar by AA if at least two corresponding angles are the same\n    return match_first and match_second", "def triangles_are_similar_by_aa(angle1_tri1, angle2_tri1, angle1_tri2, angle2_tri2):\n    \"\"\"\n    Determine whether two triangles are similar based on the Angle-Angle (AA) similarity condition.\n    Parameters:\n    angle1_tri1 (float): First angle of the first triangle in degrees.\n    angle2_tri1 (float): Second angle of the first triangle in degrees.\n    angle1_tri2 (float): First angle of the second triangle in degrees.\n    angle2_tri2 (float): Second angle of the second triangle in degrees.\n    Returns:\n    bool: True if the triangles are similar, False otherwise.\n    Examples:\n    >>> triangles_are_similar_by_aa(45, 90, 45, 90)\n    True\n    >>> triangles_are_similar_by_aa(45, 85, 50, 90)\n    False\n    \"\"\"\n    # Check if two sets of angles match the AA criterion\n    similar_aa1 = angle1_tri1 == angle1_tri2 and angle2_tri1 == angle2_tri2\n    similar_aa2 = angle1_tri1 == angle2_tri2 and angle2_tri1 == angle1_tri2\n    return similar_aa1 or similar_aa2"], ["def find_missing_sides_length(sides_tri1, known_side_tri2, missing_side_name_tri1):\n    \"\"\"\n    Calculate the unknown sides in similar triangles using known side lengths of one triangle and at least one side of the other triangle.\n    Parameters:\n    sides_tri1 (dict): Dictionary with known sides of the first triangle labeled as 'a', 'b', 'c'.\n    known_side_tri2 (tuple): A tuple with label and length of the known side of the second triangle, e.g., ('a', value).\n    missing_side_name_tri1 (str): The label of the side in the first triangle whose length needs to be determined.\n    Returns:\n    float: Length of the missing side.\n    Examples:\n    >>> find_missing_sides_length({'a': 12, 'b': 16, 'c': 20}, ('a', 6), 'b')\n    8.0\n    \"\"\"\n    label, length_side_tri2 = known_side_tri2\n    k = length_side_tri2 / sides_tri1[label]  # k is the scale factor between the triangles\n    return sides_tri1[missing_side_name_tri1] * k"], ["def check_similarity_and_calculate_sides(angles1, sides1, angles2, sides2):\n    \"\"\"\n    Checks if two triangles are similar based on given sides and angles,\n    and calculates the missing side if the triangles are similar and some sides are missing.\n    \n    Parameters:\n        angles1 (list of float): Angles of the first triangle.\n        sides1 (list of float or None): Sides of the first triangle, use None for missing sides.\n        angles2 (list of float): Angles of the second triangle.\n        sides2 (list of float or None): Sides of the second triangle, use None for missing sides.\n    Returns:\n        tuple:\n            - bool: Whether the triangles are similar.\n            - list: New sides1 array with calculated sides if applicable.\n            - list: New sides2 array with calculated sides if applicable.\n    Examples:\n    >>> check_similarity_and_calculate_sides([60, 60, 60], [3, 3, 3], [60, 60, 60], [6, None, None])\n    (True, [3, 3, 3], [6, 6, 6])\n    \"\"\"\n    # Check for angle similarity (Angle-Angle)\n    if sorted(angles1) != sorted(angles2):\n        return (False, sides1, sides2)\n    \n    scale_factor = None\n    # Find scale factor from the non-None sides\n    for s1, s2 in zip(sides1, sides2):\n        if s1 is not None and s2 is not None:\n            scale_factor = s2 / s1\n            break\n    \n    # Calculate missing sides using the scale factor\n    if scale_factor is not None:\n        sides1 = [s if s is not None else s2 / scale_factor for s, s2 in zip(sides1, sides2)]\n        sides2 = [s if s is not None else s1 * scale_factor for s1, s in zip(sides1, sides2)]\n    \n    return (True, sides1, sides2)"], ["def missing_sides_of_similar_triangles(sides_known_triangle, sides_partial_triangle, ratio):\n    \"\"\"\n    Compute missing side lengths in a similar triangle given side lengths of another triangle and the ratio.\n    Parameters:\n    - sides_known_triangle (list): List of three side lengths of the fully known triangle.\n    - sides_partial_triangle (list): List of side lengths of the similar triangle, with None for unknown sides.\n    - ratio (float): The ratio of similarity between two triangles.\n    Returns:\n    - list: A list containing the computed side lengths of the similar triangle.\n    Examples:\n    >>> missing_sides_of_similar_triangles([3, 4, 5], [1.5, None, None], 0.5)\n    [1.5, 2.0, 2.5]\n    \"\"\"\n    computed_sides = []\n    for known, partial in zip(sides_known_triangle, sides_partial_triangle):\n        if partial is None:\n            computed_sides.append(known * ratio)\n        else:\n            computed_sides.append(partial)\n    return computed_sides"], ["def area_ratio_from_side_ratio(side_ratio):\n    \"\"\"\n    Given the ratio of the sides of similar triangles, compute the ratio of their areas.\n    \n    Parameters:\n    - side_ratio (float): The common ratio of corresponding sides of the triangles.\n    \n    Returns:\n    - float: The ratio of the areas of the triangles.\n    \n    Examples:\n    - area_ratio_from_side_ratio(2) returns 4\n    \"\"\"\n    return side_ratio ** 2"], ["def calculate_area_of_triangle(base, height):\n    \"\"\"\n    Calculate the area of a triangle given base and height.\n    \n    Parameters:\n    - base (float): The length of the base of the triangle.\n    - height (float): The height of the triangle.\n    \n    Returns:\n    - float: The calculated area of the triangle.\n    \n    Examples:\n    >>> calculate_area_of_triangle(10, 5)\n    25.0\n    \"\"\"\n    return 0.5 * base * height"], ["def calculate_area_and_perimeter_ratios(sides1, sides2):\n    \"\"\"\n    Calculate the ratios of areas and perimeters between two similar triangles based on side lengths.\n    Parameters:\n        sides1 (list of float): Sides of the first triangle. \n        sides2 (list of float): Sides of the second triangle.\n    Returns:\n        tuple:\n            - float: Ratio of areas (area of triangle 2 / area of triangle 1).\n            - float: Ratio of perimeters (perimeter of triangle 2 / perimeter of triangle 1).\n    \n    Examples:\n    >>> calculate_area_and_perimeter_ratios([3, 3, 3], [6, 6, 6])\n    (4.0, 2.0)\n    \"\"\"\n    sides_ratio = [s2 / s1 for s1, s2 in zip(sides1, sides2)]\n    perimeter_ratio = sum(sides2) / sum(sides1)\n    area_ratio = np.mean(sides_ratio) ** 2  # (scale factor)^2 for areas in similar triangles\n    \n    return (area_ratio, perimeter_ratio)"], ["def calculate_similar_triangle_perimeter(original_perimeter, scale_factor):\n    \"\"\"\n    Calculate the perimeter of a similar triangle given the original perimeter and the scale factor.\n    \n    Parameters:\n    - original_perimeter (float): Perimeter of the original triangle.\n    - scale_factor (float): Ratio of the similar triangle's side length to the original.\n    \n    Returns:\n    - float: The perimeter of the similar triangle.\n    \n    Examples:\n    >>> calculate_similar_triangle_perimeter(30, 0.5)\n    15.0\n    \"\"\"\n    return original_perimeter * scale_factor"], ["def calculate_ratio(lengths_triangle1, lengths_triangle2):\n    \"\"\"\n    Calculate the corresponding side length ratios between two similar triangles.\n    \n    Parameters:\n    - lengths_triangle1 (list of float): The list of side lengths of the first triangle.\n    - lengths_triangle2 (list of float): The list of side lengths of the second triangle.\n    Returns:\n    - tuple of float: Tuple of ratios of corresponding sides.\n    Examples:\n    - calculate_ratio([3, 4, 5], [6, 8, 10]) returns (2.0, 2.0, 2.0)\n    \"\"\"\n    return tuple(b / a for a, b in zip(lengths_triangle1, lengths_triangle2))"], ["def compute_similar_triangle_sides(base_sides, ratio):\n    \"\"\"\n    Given the side lengths of a triangle and a ratio of similarity, compute the side lengths of the similar triangle.\n    Parameters:\n    - base_sides (tuple): A tuple representing the lengths of the sides (float) of the base triangle.\n    - ratio (float): The ratio of the sides of the similar triangle compared to the base triangle.\n    Returns:\n    - similar_sides (tuple): The lengths of the sides of the similar triangle.\n    Example:\n    >>> compute_similar_triangle_sides((3, 4, 5), 2)\n    (6, 8, 10)\n    \"\"\"\n    return tuple([side * ratio for side in base_sides])"]], "Pythagorean Theorem": [["def calculate_hypotenuse(leg_a, leg_b):\n    \"\"\"\n    Calculate the length of the hypotenuse in a right triangle given the lengths of the other two sides.\n    Parameters:\n    - leg_a : float\n        Length of the first leg (one side of the right triangle that isn't the hypotenuse).\n    - leg_b : float\n        Length of the second leg (other side of the right triangle that isn't the hypotenuse).\n    Returns:\n    - float\n        Length of the hypotenuse, calculated using the Pythagorean theorem.\n    \n    Examples:\n    >>> calculate_hypotenuse(3, 4)\n    5.0\n    >>> calculate_hypotenuse(5, 12)\n    13.0\n    \"\"\"\n    return math.sqrt(leg_a**2 + leg_b**2)", "def calculate_leg(hypotenuse, known_leg):\n    \"\"\"\n    Calculate the missing leg in a right triangle given the length of the hypotenuse and the other leg using the Pythagorean theorem.\n    Parameters:\n    - hypotenuse : float\n        Length of the hypotenuse (the longest side of the right triangle).\n    - known_leg : float\n        Length of the known leg (one of the sides of the right triangle).\n    Returns:\n    - expression\n        Length of the unknown leg. The result is simplified and returned in radical form if applicable.\n    Examples:\n    >>> calculate_leg(13, 5)\n    12\n    >>> calculate_leg(5, 3)\n    4*sqrt(1/2) (simplified radical form)\n    \"\"\"\n    if hypotenuse <= known_leg:\n        raise ValueError(\"Hypotenuse must be the longest side in a right triangle.\")\n    \n    # Calculating the missing leg\n    missing_leg_squared = hypotenuse**2 - known_leg**2\n    # Return the simplified radical form if necessary\n    return sympy.sqrt(missing_leg_squared).simplify()", "def calculate_triangle_side(leg_a=None, leg_b=None, hypotenuse=None):\n    \"\"\"\n    Calculates the length of a missing side of a right triangle using Pythagorean theorem.\n    Parameters:\n    leg_a : float or None\n        The length of the first leg (perpendicular) of the right triangle. None if it is the unknown.\n    leg_b : float or None\n        The length of the second leg (base) of the right triangle. None if it is the unknown.\n    hypotenuse : float or None\n        The length of the hypotenuse of the right triangle. None if it is the unknown.\n    Returns:\n    float\n        The length of the unknown side of the triangle.\n    Examples:\n    >>> calculate_triangle_side(leg_a=3, leg_b=4)\n    5.0\n    >>> calculate_triangle_site(leg_b=4, hypotenuse=5)\n    3.0\n    >>> calculate_triangle_side(leg_a=3, hypotenuse=5)\n    4.0\n    \"\"\"\n    if hypotenuse is None:\n        return math.sqrt(leg_a**2 + leg_b**2)\n    elif leg_a is None:\n        return math.sqrt(hypotenuse**2 - leg_b**2)\n    elif leg_b is None:\n        return math.sqrt(hypotenuse**2 - leg_a**2)\n    else:\n        raise ValueError(\"Invalid parameters: One side must be None to find its length.\")", "def calculate_hypotenuse(leg_a, leg_b):\n    \"\"\"\n    Calculate the length of the hypotenuse in a right triangle using the Pythagorean theorem.\n    Parameters:\n    - leg_a (float): Length of the first leg of the right triangle.\n    - leg_b (float): Length of the second leg of the right triangle.\n    Returns:\n    - float: The length of the hypotenuse.\n    Examples:\n    >>> calculate_hypotenuse(3, 4)\n    5.0\n    >>> calculate_hypotenuse(5, 12)\n    13.0\n    \"\"\"\n    if leg_a <= 0 or leg_b <= 0:\n        raise ValueError(\"Both legs must be positive numbers.\")\n    hypotenuse = math.sqrt(leg_a**2 + leg_b**2)\n    return hypotenuse", "def calculate_leg(hypotenuse, known_leg):\n    \"\"\"\n    Calculate the length of an unknown leg in a right triangle, given the hypotenuse and the other leg.\n    Parameters:\n    - hypotenuse (float): The length of the hypotenuse of the right triangle.\n    - known_leg (float): The length of the known leg of the right triangle.\n    Returns:\n    - float: The length of the unknown leg.\n    Examples:\n    >>> calculate_leg(13, 5)\n    12.0\n    >>> calculate_leg(5, 4)\n    3.0\n    \"\"\"\n    if hypotenuse <= 0 or known_leg <= 0:\n        raise ValueError(\"Both known leg and hypotenuse must be positive.\")\n    if hypotenuse <= known_leg:\n        raise ValueError(\"Hypotenuse must be greater than any leg in a right triangle.\")\n    unknown_leg = math.sqrt(hypotenuse**2 - known_leg**2)\n    return unknown_leg"], ["def simplify_radical(expression):\n    \"\"\"\n    Simplifies square roots to their simplest radical form using symbolic computation.\n    Parameters:\n    expression : float\n        The expression (usually a square root) to be simplified.\n    Returns:\n    str\n        The simplified expression in radical form.\n    Examples:\n    >>> simplify_radical(8)\n    '2*sqrt(2)'\n    >>> simplify_radical(18)\n    '3*sqrt(2)'\n    \"\"\"\n    return str(nsimplify(sqrt(expression)))"]], "Reflections": [["def reflect_point_across_line(point, line_point, line_slope):\n    \"\"\"\n    Reflect a given point across a line defined by a point and a slope in 2D geometry.\n    Parameters:\n    point (tuple): A tuple (x, y) representing the coordinates of the point to be reflected.\n    line_point (tuple): A tuple (x, y) representing a point through which the line passes.\n    line_slope (float): The slope of the line.\n    Returns:\n    tuple: The reflected point's coordinates (x', y').\n    Example:\n    >>> reflect_point_across_line((3, 4), (1, 2), 2)\n    (-1, 0)\n    \"\"\"\n    x, y = sp.symbols('x y')\n    x0, y0 = point\n    x1, y1 = line_point\n    # Equation of the line: y - y1 = m*(x - x1)\n    m = line_slope\n    perp_slope = -1/m  # slope of the perpendicular line\n    # Equation of perpendicular from point (x0, y0) to the line: y - y0 = perp_slope*(x - x0)\n    # Intersection with the line:\n    intersection_x = sp.solve(y0 + perp_slope*(x - x0) - (y1 + m*(x - x1)), x)\n    intersection_y = y0 + perp_slope * (intersection_x[0] - x0)\n    # Calculating the reflected point\n    reflected_x = 2*intersection_x[0] - x0\n    reflected_y = 2*intersection_y - y0\n    return (reflected_x.evalf(), reflected_y.evalf())", "def reflect_point_over_line(point, anchor, line_vector):\n    \"\"\"\n    Reflect a point over a line defined by an anchor point and a direction vector of the line.\n    Parameters\n    ----------\n    point : array_like\n        The coordinates of the point to be reflected, should be an iterable of two numbers.\n    anchor : array_like\n        A point on the line, should be an iterable of two numbers.\n    line_vector : array_like\n        The vector that defines the direction of the line, should be an iterable of two numbers.\n    Returns\n    -------\n    np.array\n        The reflected point coordinates.\n    Examples\n    --------\n    >>> reflect_point_over_line([4, 1], [1, 0], [0, 1])\n    array([4., -1.])\n    \"\"\"\n    point = np.array(point)\n    anchor = np.array(anchor)\n    line_vector = np.array(line_canopy_points)\n    # Translate point based on the anchor\n    translated_point = point - anchor\n    # Calculate the projection of translated_point onto line_vector\n    projection = calculate_vector_projection(translated_point, line_vector)\n    # Calculate the vector to the point from the line\n    vector_to_line = translated_point - projection\n    # Calculate the reflected point\n    reflected_point = translated_point - 2 * vector_to_line\n    # Translate back to the original coordinates\n    return reflected_point + anchor", "def reflect_point_across_line(point, line_point1, line_point2):\n    \"\"\"\n    Reflects a point across a line defined by two points.\n    Parameters:\n    point (tuple): The point to reflect, given as (x, y).\n    line_point1 (tuple): The first point defining the line, given as (x, y).\n    line_point2 (tuple): The second point defining the line, given as (x, y).\n    \n    Returns:\n    tuple: The reflected point coordinates (x, y).\n    Example:\n    >>> reflect_point_across_line((1, 2), (0, 0), (1, 1))\n    (2, 1)\n    \"\"\"\n    # Convert points to numpy arrays\n    p = np.array(point)\n    a = np.array(line_point1)\n    b = np.array(line_point2)\n    # Compute ap, ab vectors\n    ap = p - a\n    ab = b - a\n    ab_norm = ab / np.linalg.norm(ab)\n    \n    # Projection of ap onto ab\n    ap_proj = np.dot(ap, ab_norm) * ab_norm\n    \n    # The reflected point is 2 times the projection minus the original point\n    reflected_point = 2 * ap_proj - ap + a\n    return tuple(reflected_point)", "def reflect_point_across_line_2D(px, py, x1, y1, x2, y2):\n    \"\"\"\n    Reflects a point across a line defined by two points in 2D space.\n    Parameters:\n        px (float): x-coordinate of the point to reflect.\n        py (float): y-coordinate of the point to reflect.\n        x1 (float): x-coordinate of the first point on the line.\n        y1 (float): y-coordinate of the first point on the line.\n        x2 (float): x-coordinate of the second point on the line.\n        y2 (float): y-coordinate of the second point on the line.\n    \n    Returns:\n        tuple: Coordinates of the reflected point (rx, ry).\n    Example:\n        >>> reflect_point_across_line_2D(3, 2, 1, 1, 4, 4)\n        (2.0, 3.0)\n    \"\"\"\n    # Vector from point1 to point2\n    dx, dy = x2 - x1, y2 - y1\n    # Vector from point1 to the point\n    P_d = np.array([px - x1, py - y1])\n    # Projection of P_d onto the line\n    line_unit_vector = np.array([dx, dy]) / np.linalg.norm([dx, dy])\n    proj_vector = np.dot(P_d, line_unit_vector) * line_unit_vector\n    reflect_vector = P_d - 2 * (P_d - proj_vector)\n    # Return the coordinates of the reflected point\n    return (x1 + reflect_vector[0], y1 + reflect_vector[1])"], ["def translate_points(points, translation_vector):\n    \"\"\"\n    Translate a set of points by a given vector.\n    \n    Parameters:\n    - points (ndarray): an Nx2 numpy array of points.\n    - translation_vector (ndarray or tuple): a vector (tx, ty) by which to translate each point.\n    \n    Returns:\n    - ndarray: the translated points.\n    \n    Example:\n    >>> translate_points(np.array([[1, 2], [3, 4]]), (1, -1))\n    array([[2, 1],\n           [4, 3]])\n    \"\"\"\n    return points + np.array(translation_vector)", "def translate_point(point, vector):\n    \"\"\"\n    Translate a point by a given vector.\n    Parameters:\n    - point (tuple): A tuple containing the x and y coordinates of the point (x, y).\n    - vector (tuple): The translation vector (dx, dy) where `dx` is added to `x` and `dy` is added to `y`.\n    Returns:\n    - tuple: Coordinates of the translated point (x+dx, y+dy).\n    Examples:\n    >>> translate_point((1, 2), (3, -1))\n    (4, 1)\n    \"\"\"\n    x, y = point\n    dx, dy = vector\n    return (x + dx, y + dy)"], ["def sum_of_coordinates(points):\n    \"\"\"\n    Calculate the sum of x and y coordinates among a list of points.\n    \n    Parameters:\n        points (list of tuples): List of tuples, where each tuple represents a point (x, y).\n    \n    Returns:\n        tuple: Sum of x coordinates and sum of y coordinates (sum_x, sum_y).\n    \n    Examples:\n    >>> sum_of_coordinates([(1, 2), (3, -1), (0, 0)])\n    (4, 1)\n    \"\"\"\n    sum_x = sum(point[0] for point in points)\n    sum_y = sum(point[1] for point in points)\n    return (sum_x, sum_y)", "def sum_of_coordinates(points):\n    \"\"\"\n    Calculate the sum of the coordinates of multiple points.\n    \n    Parameters:\n    - points (ndarray): an Nx2 numpy array of points.\n    \n    Returns:\n    - tuple: sum of x coordinates, sum of y coordinates.\n    \n    Example:\n    >>> sum_of_coordinates(np.bytearray1.array([[1, 2], [3, 4], [-1, -2]]))\n    (3, 4)\n    \"\"\"\n    return tuple(np.sum(points, axis=0))", "def sum_of_coordinates(points):\n    \"\"\"\n    Calculate the sum of coordinates (x, y) of a list of points.\n    Parameters:\n    - points (list of tuples): List of tuples where each tuple represents the coordinates (x, y) of a point.\n    Returns:\n    - tuple: Sum of the x coordinates and sum of the y coordinates.\n    Examples:\n    >>> sum_of_coordinates([(1, 2), (3, 4), (-1, -1)])\n    (3, 5)\n    \"\"\"\n    total_x = sum(p[0] for p in points)\n    total_y = sum(p[1] for p in points)\n    return (total_x, total_y)"], ["def reflect_point_across_plane(point, plane_point, normal_vector):\n    \"\"\"\n    Reflect a point across a plane defined by a point and a normal vector in 3D space.\n    Parameters:\n    point (numpy.array): The coordinates of the point as an array [x, y, z].\n    plane_point (numpy.array): The coordinates of a point on the plane as an array [a, b, c].\n    normal_vector (numpy.array): The normal vector of the plane as an array [i, j, k].\n    Returns:\n    numpy.array: The reflected point's coordinates as an array [x', y', z'].\n    Example:\n    >>> reflect_point_across_plane(np.array([1, 2, 3]), np.array([1, 0, 0]), np.array([0, 1, 0]))\n    array([ 1., 2., -3.])\n    \"\"\"\n    p = np.array(point)\n    q = np.array(plane_point)\n    n = np.array(normal_vector)\n    # Find point projection on the plane\n    pq = p - q\n    dist_to_plane = np.dot(pq, n) / np.linalg.norm(n)\n    projection = p - 2 * dist_to_plane * (n / np.linalg.norm(n))\n    return projection", "def reflect_point_across_plane(point, plane_normal, plane_point):\n    \"\"\"\n    Reflects a point across a plane defined by a normal vector and a point on the plane.\n    Parameters:\n    point (tuple): The point to reflect, given as (x, y, z).\n    plane_normal (tuple): The normal vector of the plane, given as (x, y, z).\n    plane_point (tuple): A point on the plane, given as (x, y, z).\n    \n    Returns:\n    tuple: The reflected point coordinates (x, y, z).\n    Example:\n    >>> reflect_point_across_plane((1, 2, 3), (0, 0, 1), (0, 0, 0))\n    (1, 2, -3)\n    \"\"\"\n    # Convert to numpy arrays\n    p = np.array(point)\n    n = np.array(plane_normal)\n    m = np.array(plane_point)\n    \n    # Compute pm and normalize n\n    pm = p - m\n    n_norm = n / np.linalg.norm(n)\n    \n    # Distance from point to the plane\n    dist = np.dot(pm, n_norm)\n    \n    # Reflect point\n    reflected_point = p - 2 * dist * n_norm\n    return tuple(reflected_point)", "def reflect_point_across_plane_3D(px, py, pz, a, b, c, x0, y0, z0):\n    \"\"\"\n    Reflects a point across a plane in 3D space.\n    Parameters:\n        px, py, pz (float): Coordinates of the point to reflect.\n        a, b, c (float): Normal vector components of the plane.\n        x0, y0, z0 (float): A point on the plane.\n    \n    Returns:\n        tuple: Coordinates of the reflected point in 3D (rx, ry, rz).\n    Example:\n        >>> reflect_point_across_plane_3D(1, 2, 3, 0, 0, 1, 0, 0, 0)\n        (1, 2, -3)\n    \"\"\"\n    # Vector from point on the plane to the point\n    P_d = np.array([px - x0, py - y0, pz - z0])\n    # Normal vector of the plane\n    n_vector = np.array([a, b, c])\n    # Distance from point to plane along normal direction\n    d = np.dot(P_d, n_vector) / np.linalg.norm(n_vector)\n    # Reflection point calculation\n    reflection = np.array([px, py, pz]) - 2 * d * n_vector / np.linalg.norm(n_vector)\n    return tuple(reflection)"], ["def midpoint(point1, point2):\n    \"\"\"\n    Computes the midpoint between two points.\n    Parameters:\n    point1 (tuple): The first point, given as (x, y).\n    point2 (tuple): The second point, given as (:\n    \n    Returns:\n    tuple: Midpoint coordinates (x, y).\n    Example:\n    >>> midpoint((0,0), (2,2))\n    (1.0, 1.0)\n    \"\"\"\n    return tuple((np.array(point1) + np.array(point2)) / 2)"], ["def reflect_vector(v, u):\n    \"\"\"\n    Compute the reflection of vector v over vector u in 2D space.\n    Parameters:\n    - v (array_like): The vector to be reflected. Must be a 1-D array of length 2.\n    - u (array_like): The vector (or axis) over which v is to be reflected. Must be a 1-D array of length 2.\n    Returns:\n    - numpy.ndarray: The reflected vector as a 1-dimensional numpy array of length 2.\n    Example:\n    >>> reflect_vector(np.array([1, 2]), np.array([0, 1]))\n    array([ 1, -2])\n    \"\"\"\n    v, u = np.asarray(v), np.asarray(u)\n    if v.shape != (2,) or u.shape != (2,):\n        raise ValueError(\"Both vectors v and u must be 1-D arrays of length 2.\")\n    # Calculate the projection of v onto u\n    projection_scale = np.dot(v, u) / np.dot(u, u)\n    projection = projection_scale * u\n    # Calculate the reflection\n    reflection = v - 2 * (projection - v)\n    return reflection", "def reflect_vector(v, u):\n    \"\"\"\n    Reflect a vector `v` over vector `u` in 2D space using vector projections and algebraic operations.\n    Parameters\n    ----------\n    v : array_like\n        The 2D vector to be reflected, represented as a list or array of length 2.\n    u : array_like\n        The 2D vector which defines the line across which `v` will be reflected, also represented as a list or array of length 2.\n    Returns\n    -------\n    numpy.ndarray\n        A numpy array representing the reflected vector.\n    Notes\n    -----\n    The vector reflection r of a vector v about a vector u is given by:\n    r = 2*proj_u(v) - v\n    where proj_u(v) is the projection of v onto u and is calculated as:\n    proj_u(v) = (v·u / u·u) * u\n    \n    If the vector u is the zero vector, it will raise a ZeroDivisionError as reflection over a zero vector is not defined.\n    Examples\n    --------\n    >>> reflect_vector([3, 4], [1, 0])\n    array([ 3., -4.])\n    >>> reflect_vector([1, 2], [2, 2])\n    array([ 2.,  1.])\n    \"\"\"\n    # Convert input lists to numpy arrays for vector operations\n    v = np.array(v)\n    u = np.array(u)\n    \n    # Dot products and magnitudes\n    dot_vu = np.dot(v, u)\n    dot_uu = np.dot(u, u)\n    \n    if dot_uu == 0:\n        raise ZeroDivisionError(\"Cannot compute reflection for vector u with zero magnitude.\")\n    \n    # Projection calculation\n    projection = (dot_vu / dot_uu) * u\n    \n    # Reflection calculation\n    reflection = 2 * projection - v\n    \n    return reflection"], ["def translate_point(point, dx, dy):\n    \"\"\"\n    Translate a point in the 2D space by given deltas.\n    \n    Parameters:\n        point (tuple): A tuple representing a point (x, y).\n        dx (float): The displacement along the x-axis.\n        dy (float): The displacement along the y-axis.\n    \n    Returns:\n        tuple: The translated point (new_x, new_y).\n    \n    Examples:\n    >>> translate_point((3, 4), 1, -1)\n    (4, 3)\n    \"\"\"\n    x, y = point\n    return (x + dx, y + dy)"], ["def reflect_across_x(points):\n    \"\"\"\n    Reflect points across the x-axis.\n    \n    Parameters:\n    - points (ndarray): an Nx2 numpy array of points where each row represents the coordinates (x, y).\n    Returns:\n    - ndarray: the reflected points as an Nx What data is returned? array.\n    Example:\n    >>> reflect_across_x(np.array([[1, 2], [3, -1], [0, 0]]))\n    array([[ 1, -2],\n           [ 3,  1],\n           [ 0,  0]])\n    \"\"\"\n    reflected_points = points.copy()\n    reflected_points[:, 1] = -reflected_points[:, 1]\n    return reflected_points", "def reflect_across_y(points):\n    \"\"\"\n    Reflect points across the y-axis.\n    \n    Parameters:\n    - points (ndarray): an Nx2 numpy array of points.\n    Returns:\n    - ndarray: the reflected points.\n    \n    Example:\n    >>> reflect_across_y(np.array([[1, 2], [3, -1], [-5, 4]]))\n    array([[-1,  2],\n           [-3, -1],\n           [ 5,  4]])\n    \"\"\"\n    reflected_points = points.copy()\n    reflected_points[:, 0] = -reflected_points[:, 0]\n    return reflected_points", "def reflect_across_line_y_equals_x(points):\n    \"\"\"\n    Reflect points across the line y = x.\n    \n    Parameters:\n    - points (ndarray): an Nx2 numpy array of points.\n    Returns:\n    - ndarray: the reflected points where each (x, y) is transformed to (y, x).\n    \n    Example:\n    >>> reflect_across_line_y_equals_x(np.array([[1, 2], [3, -1], [0, 0]]))\n    array([[ 2,  1],\n           [-1,  3],\n           [ 0,  0]])\n    \"\"\"\n    reflected_points = points.copy()\n    reflected_points[:, [0, 1]] = reflected_points[:, [1, 0]]\n    return reflected_points"], ["def reflect_across_x(point):\n    \"\"\"\n    Reflect a point across the x-axis.\n    Parameters:\n    - point (tuple): A tuple containing the x and y coordinates of the point (x, y).\n    Returns:\n    - tuple: Coordinates of the reflected point (x, -y).\n    Examples:\n    >>> reflect_across_x((5, 3))\n    (5, -3)\n    \"\"\"\n    x, y = point\n    return (x, -y)", "def reflect_across_y(point):\n    \"\"\"\n    Reflect a point across the y-axis.\n    Parameters:\n    - point (tuple): A tuple containing the x and y coordinates of the point (x, y).\n    Returns:\n    - tuple: Coordinates of the reflected point (-x, y).\n    Examples:\n    >>> reflect_across_y((4, -2))\n    (-4, -2)\n    \"\"\"\n    x, y = point\n    return (-x, y)", "def reflect_across_y_equals_x(point):\n    \"\"\"\n    Reflect a point across the line y = x.\n    Parameters:\n    - point (tuple): A tuple containing the x and y coordinates of the point (x, y).\n    Returns:\n    - tuple: Coordinates of the reflected point (y, x).\n    Examples:\n    >>> reflect_across_y_equals_x((3, 5))\n    (5, 3)\n    \"\"\"\n    x, y = point\n    return (y, x)"], ["def reflect_point(point, axis=\"y-axis\"):\n    \"\"\"\n    Reflects a point across the specified axis or line.\n    \n    Parameters:\n        point (tuple): A tuple representing a point in 2D space, (x, y).\n        axis (str): A string specifying the axis or line to reflect across. Acceptable values are \"x-axis\", \"y-axis\", and \"y=x\".\n    Returns:\n        tuple: The reflected point in 2D space.\n    \n    Examples:\n    >>> reflect_point((3, 4), \"x-axis\")\n    (3, -4)\n    >>> reflect_point((3, 4), \"y-axis\")\n    (-3, 4)\n    >>> reflect_point((3, 4), \"y=x\")\n    (4, 3)\n    \"\"\"\n    x, y = point\n    if axis == \"x-axis\":\n        return (x, -y)\n    elif axis == \"y-axis\":\n        return (-x, y)\n    elif axis == \"y=x\":\n        return (y, x)\n    else:\n        raise ValueError(\"Invalid axis value. Choose 'x-axis', 'y-axis', or 'y=x'.\")"], ["def calculate_vector_projection(v, u):\n    \"\"\"\n    Calculate the projection of a vector v onto another vector u.\n    Parameters\n    ----------\n    v : array_like\n        The vector being projected, should be an iterable of two numbers.\n    u : array_by\n        The vector onto which v is being projected, should be an iterable of two numbers.\n    Returns\n    -------\n    np.array\n        The projection of vector v onto vector u.\n    Examples\n    --------\n    >>> calculate_vector_projection([1, 2], [2, 0])\n    array([1., 0.])\n    \"\"\"\n    v = np.array(v)\n    u = np.array(u)\n    return (np.dot(v, u) / np.dot(u, u)) * u"]], "Trapezoids": [["def midpoint_segment_length(base1, base2):\n    \"\"\"\n    Calculate the length of the segment joining the midpoints of the non-parallel sides of the trapezoid,\n    using the midpoint theorem, which states the segment is parallel and equal to the average of the two bases.\n    Parameters:\n    - base1 (float): Length of the first base of the trapezoid.\n    - base2 (float): Length of the second base of the trapezoid.\n    Returns:\n    - float: Length of the midpoint segment.\n    Examples:\n    >>> midpoint_segment_length(4, 6)\n    5.0\n    \"\"\"\n    return (base1 + base2) / 2", "def calculate_midsegment(b1, b2):\n    \"\"\"\n    Calculate the length of the midsegment of a trapezoid which connects the midpoints of the nonparallel sides.\n    Parameters:\n    b1 (float): Length of the first base.\n    b2 (float): Length of the second base.\n    Returns:\n    float: The length of the midsegment.\n    Example:\n    >>> calculate_midsegment(5, 3)\n    4.0\n    \"\"\"\n    return (b1 + b2) / 2", "def trapezoid_midsegment(base1: float, base2: float) -> float:\n    \"\"\"\n    Calculate the length of the midsegment of the trapezoid (line connecting the midpoints of the non-parallel sides),\n    which is parallel to the bases and equals the average of their lengths.\n    Parameters:\n    - base1 (float): Length of the first base.\n    - base2 (float): Length of the second base.\n    Returns:\n    - float: The length of the midsegment.\n    Examples:\n    >>> trapezoid_midsegment(10, 6)\n    8.0\n    \"\"\"\n    return (base1 + base2) / 2"], ["def decompose_trapezoid(base1: float, base2: float, height: float):\n    \"\"\"\n    Decompose a trapezoid into simpler shapes: a rectangle and two right triangles, and return their dimensions.\n    Parameters:\n    - base1 (float): Length of the top base.\n    - base2 (float): Length of the bottom base, assumed to be longer than base1.\n    - height (float): The height of the trapezoid.\n    Returns:\n    - tuple: dimensions of rectangle (base, height), dimensions of triangle1, dimensions of triangle2.\n    Examples:\n    >>> decompose_trapezoid(6, 10, 5)\n    ((6, 5), (4, 5), (4, 5))\n    \"\"\"\n    rectangle_base = min(base1, base2)\n    triangle_base = abs(base2 - base1) / 2\n    return ((rectangle_base, height), (triangle_base, height), (triangle_base, height))"], ["def calc_trapezoid_area(base1, base2, height):\n    \"\"\"\n    Calculate the area of a trapezoid given its bases and height.\n    Parameters:\n    - base1 (float): Length of the first base of the trapezoid.\n    - base2 (float): Length of the second base of the trapezoid.\n    - height (float): Height of the trapezoid (distance between the two bases).\n    Returns:\n    - float: Area of the trapezoid.\n    Examples:\n    >>> calc_trapezoid_area(4, 6, 5)\n    25.0\n    \"\"\"\n    return (base1 + base2) / 2 * height", "def calculate_trapezoid_area(b1, b2, height):\n    \"\"\"\n    Calculate the area of a trapezoid given its bases and height.\n    Parameters:\n    b1 (float): Length of the first base.\n    b2 (float): Length of the second base.\n    height (float): Height of the trapezoid from one base to the other.\n    Returns:\n    float: The area of the trapezoid.\n    Example:\n    >>> calculate_trapezoid_area(5, 3, 4)\n    16.0\n    \"\"\"\n    return (b1 + b2) * height / 2", "def calculate_trapezoid_height(area, b1, b2):\n    \"\"\"\n    Calculate the height of a trapezoid given its area and the lengths of the bases.\n    Parameters:\n    area (float): The area of the trapezoid.\n    b1 (float): Length of the first base.\n    b2 (float): Length of the second base.\n    Returns:\n    float: The height of the trapezoid.\n    Example:\n    >>> calculate_trapezoid_height(16, 5, 3)\n    4.0\n    \"\"\"\n    height = symbols('height')\n    equation = Eq((b1 + b2) * height / 2, area)\n    solution = solve(equation, height)\n    return solution[0]", "def trapezoid_area(height: float, base1: float, base2: float) -> float:\n    \"\"\"\n    Calculate the area of a trapezoid given its height and the lengths of its two parallel sides (bases).\n    Parameters:\n    - height (float): The height (or altitude) of the trapezoid, perpendicular distance between the two bases.\n    - base1 (float): Length of the first base.\n    - base2 (float): Length of the second base.\n    Returns:\n    - float: The calculated area of the trapezoid.\n    Examples:\n    >>> trapezoid_area(5, 10, 6)\n    40.0\n    \"\"\"\n    return height * (base1 + base2) / 2"], ["def trapezoid_properties(is_isosceles=False):\n    \"\"\"\n    Provides a descriptive dict of properties of either a general or an isosceles trapezoid.\n    Parameters:\n    - is_isosceles (bool): Flag to determine if the properties of an isosceles trapezoid are returned.\n    Returns:\n    - dict: Dictionary containing relevant properties.\n    Examples:\n    >>> trapezoid_properties()\n    {'Parallel sides': 2, 'Non-parallel sides': 2, 'Sum of angles': 360}\n    >>> trapezoid_properties(True)\n    {'Parallel sides': 2, 'Non-parallel sides': 2, 'Equal legs': True, 'Sum of angles': 360}\n    \"\"\"\n    properties = {\n        'Parallel sides': 2,\n        'Non-parallel sides': 2,\n        'Sum of angles': 360\n    }\n    if is_isosceles:\n        properties['Equal legs'] = True\n    return properties"]], "Angles": [["def angle_at_hour_mark(hour):\n    \"\"\"\n    Calculate the angle of a specific hour mark from 12 o'clock on the clock face.\n    Parameters:\n    - hour (int): Hour mark (1 through 12).\n    Returns:\n    - float: Angle in degrees from the 12 o'clock position.\n    Examples:\n    >>> angle_at_hour_mark(3)\n    90.0\n    >>> angle_at_hour_mark(6)\n    180.0\n    \"\"\"\n    return (hour % 12) * 30  # As each hour represents 30 degrees", "def hour_mark_to_degrees(hour_mark):\n    \"\"\"\n    Convert an hour mark on a clock to the angle it represents from 12 o'clock in degrees.\n    Parameters:\n    - hour_mark (int): The hour mark, should be between 0 and 11 (each representing a 30 degree increment)\n    Returns:\n    - int: The degrees from 12 o'clock corresponding to the hour mark.\n    Examples:\n    >>> hour_mark_to_degrees(3)\n    90\n    >>> hour_mark_to_degrees(9)\n    270\n    \"\"\"\n    # Each hour mark represents 30 degrees (360 / 12)\n    return hour_mark * 30"], ["def angle_sum(n_sides):\n    \"\"\"\n    Calculate the sum of the interior angles of a polygon\n    \n    Parameters:\n        n_sides (int): The number of sides in the polygon.\n        \n    Returns:\n        int: Sum of the interior angles in degrees.\n        \n    Examples:\n        >>> angle_sum(3)\n        180\n        \n    Note:\n        The sum of the interior angles of a polygon is (n-2)*180 degrees.\n    \"\"\"\n    if n_sides < 3:\n        raise ValueError(\"n_sides should be at least 3 for a valid polygon.\")\n    return (n_sides - 2) * 180", "def regular_polygon_interior_angle(n_sides):\n    \"\"\"\n    Calculate the measure of each interior angle of a regular polygon.\n    \n    Parameters:\n        n_sides (int): The number of sides in the regular polygon.\n        \n    Returns:\n        float: The measure of one interior angle in degrees.\n    \"\"\"\n    if n_sides < 3:\n        raise ValueError(\"n_sides should be at least 3 for a valid polygon.\")\n    total_sum = (n_sides - 2) * 180\n    return total_sum / n_sides"], ["def calculate_central_angle(n):\n    '''\n    This function calculates the central angle of a circle divided into n equal parts.\n    \n    Parameters: \n    n (int): The number of parts the circle is divided into\n   \n    Returns: \n    float: The central angle.\n    \n    Example: \n    calculate_central_angle(4)\n    # Output: 90.0\n    '''\n    central_angle = 360/n\n    return central_angle", "def calculate_inscribed_angle(n):\n    '''\n    This function calculates the inscribed angle of a circle divided into n equal parts.\n    \n    Parameters: \n    n (int): The number of parts the circle is divided into\n   \n    Returns: \n    float: The inscribed angle.\n    \n    Example: \n    calculate_inscribed_angle(4)\n    # Output: 45.0\n    '''\n    inscribed_angle = calculate_central_angle(n)/2\n    return inscribed_angle"], ["def sum_of_exterior_angles():\n    \"\"\"\n    Compute the sum of exterior angles of any polygon, which is always 360 degrees.\n    Returns:\n        float: sum of the exterior angles of a polygon in degrees.\n    \"\"\"\n    return 360"], ["def is_supplementary(angle1, angle2):\n    \"\"\"\n    Check if two angles are supplementary (sum to 180 degrees).\n    \n    Parameters:\n        angle1 (float): The first angle in degrees.\n        angle2 (float): The second angle in degrees.\n        \n    Returns:\n        bool: True if the angles are supplementary, else False.\n    \"\"\"\n    return (angle1 + angle2) == 180", "def is_complementary(angle1, angle2):\n    \"\"\"\n    Check if two angles are complementary (sum to 90 degrees).\n    \n    Parameters:\n        angle1 (float): The first angle in degrees.\n        angle2 (float): The second angle in degrees.\n        \n    Returns:\n        bool: True if the angles are complementary, else False.\n    \"\"\"\n    return (angle1 + angle2) == 90"], ["def triangle_angle_finder(angle1, angle2):\n    \"\"\"\n    Given two angles of a triangle, find the third.\n    \n    Parameters:\n        angle1 (float): The first known angle in degrees.\n        angle2 (float): The second known angle in degrees.\n        \n    Returns:\n        float: The third angle in degrees.\n        \n    Note:\n        The sum of angles in a triangle is always 180 degrees.\n    \"\"\"\n    return 180 - angle1 - angle2", "def triangle_angle(angle1, angle2):\n    \"\"\"\n    Compute the third angle of a triangle given two angles.\n    Parameters:\n        angle1 (float): First angle of the triangle in degrees.\n        angle2 (float): Second angle of the triangle in degrees.\n    Returns:\n        float: Third angle of the triangle in degrees.\n    \"\"\"\n    return 180 - angle1 - angle2"], ["def calculate_polygon_internal_angle(n):\n    '''\n    This function calculates the sum of internal angles of a polygon with n number of sides.\n    \n    Parameters: \n    n (int): The number of sides of the polygon\n   \n    Returns: \n    int: The sum of internal angles of the polygon.\n    \n    Example: \n    calculate_polygon_internal_angle(6)\n    # Output: 720\n    '''\n    sum_internal_angles = (n-2)*180\n    return sum_internal_angles", "def calculate_polygon_individual_internal_angle(n):\n    '''\n    This function calculates the individual internal angle of a regular polygon with n number of sides.\n    \n    Parameters: \n    n (int): The number of sides of the polygon\n   \n    Returns: \n    int: The individual internal angle of the polygon.\n \n    Example: \n    calculate_polygon_individual_internal_angle(6)\n    # Output: 120\n    '''\n    import sympy\n    vertex_angle = calculate_polygon_internal_angle(n)/n\n    return sympy.simplify(vertex_angle)"], ["def sum_of_interior_angles(sides):\n    \"\"\"\n    Compute the sum of interior angles of a polygon.\n    Parameters:\n        sides (int): number of sides in the polygon.\n    Returns:\n        float: sum of the interior angles of the polygon in degrees.\n    \"\"\"\n    return (sides - 2) * 180"], ["def calculate_quadrilateral_angle(a, b, c):\n    '''\n    This function calculates the fourth angle of a quadrilateral given three angles.\n    \n    Parameters: \n    a, b, c (float): The three angles of the quadrilateral\n   \n    Returns: \n    float: The fourth angle of the quadrilateral.\n    \n    Example: \n    calculate_quadrilateral_angle(90, 90, 90)\n    # Output: 90.0\n    '''\n    fourth_angle = 360 - a - b - c\n    return fourth_angle"], ["def calculate_straight_line_angle(a):\n    '''\n    This function calculates the adjacent angle on a straight line.\n    \n    Parameters: \n    a (float): The given angle on the straight line\n   \n    Returns: \n    float: The adjacent angle on the straight line.\n    \n    Example: \n    calculate_straight_line_angle(45)\n    # Output: 135.0\n    '''\n    adjacent_angle = 180 - a\n    return adjacent_angle"], ["def coterminal_angles(angle):\n    \"\"\"\n    Finds the positive and negative coterminal angles for a given angle.\n    \n    Parameters:\n        angle (float): Original angle in degrees.\n    Returns:\n        tuple: A tuple containing the positive and negative coterminal angles in degrees.\n    \"\"\"\n    return (angle % 360, (angle % 360) - 360)"], ["def calculate_polygon_external_angle():\n    '''\n    This function calculates the external angle of a polygon.\n   \n    Returns: \n    int: The external angle of a polygon.\n    \n    Example: \n    calculate_polygon_external_angle()\n    # Output: 180\n    '''\n    # External angle of any polygon is always 180\n    return 180"], ["def angle_between_clock_hands(hour, minute):\n    \"\"\"\n    Calculate the angle between the hour and minute hands on an analog clock.\n    Parameters:\n    - hour (int): The current hour on the clock (1-12).\n    - minute (int): The current minute on the clock (0-59).\n    Returns:\n    - float: The smallest angle between the hour and minute hands in degrees.\n    Examples:\n    >>> angle_between_clock_hands(3, 0)\n    90.0\n    >>> angle_between_clock_hands(12, 30)\n    165.0\n    \"\"\"\n    import math\n    \n    # Constants: Total degrees in a circle, degrees per hour, degrees per minute\n    total_degrees = 360\n    degrees_per_hour = 30  # 360 degrees / 12 hours\n    degrees_per_minute = 6  # 360 degrees / 60 minutes\n    # Calculate position of hour hand\n    hour_angle = (hour % 12) * degrees_per_hour + (minute / 60) * degrees_per_hour\n    \n    # Calculate position of minute hand\n    minute_angle = minute * degrees_per_minute\n    \n    # Calculate the difference\n    angle = abs(hour_angle - minute_angle)\n    \n    # Ensure the smallest angle is returned\n    return min(angle, total_degrees - angle)", "def calculate_clock_angle(hour, minute):\n    \"\"\"\n    Calculate the smallest angle between the hour and minute hands on a clock.\n    Parameters\n    ----------\n    hour : int\n        The hour hand's position, expressed in hour units (1-12).\n    minute : int\n        The minute hand's position, expressed in minute units (0-59).\n    Returns\n    -------\n    float\n        The smallest angle between the hour and minute hands in degrees.\n    Examples\n    --------\n    >>> calculate_clock_angle(3, 00)\n    90.0\n    >>> calculate_clock_position(12, 30)\n    165.0\n    >>> calculate_clock_position(9, 45)\n    22.5\n    \"\"\"\n    if not (1 <= hour <= 12) or not (0 <= minute < 60):\n        raise ValueError(\"Hour must be between 1 and 12, and minutes must be between 0 and 59.\")\n    \n    # Position of the hour hand (each hour = 30 degrees, plus half a degree for each passing minute)\n    hour_angle = (hour % 12) * 30 + minute * 0.5\n    \n    # Position of the minute hand (each minute = 6 degrees)\n    minute_angle = minute * 6\n    \n    # Compute the absolute difference\n    angle = abs(hour_angle - minute_angle)\n    \n    # Return the smallest angle (considering the clock is circular)\n    return min(angle, 360 - angle)", "def calculate_clock_angle(hour, minute):\n    \"\"\"\n    Calculate the angle between the hour and minute hands on a clock at a given time.\n    Parameters:\n    - hour (int): The hour hand position, must be between 0 and 23 (for both 12-hour and 24-hour format)\n    - minute (int): The minute hand position, must be between 0 and 59\n    Returns:\n    - float: The smallest angle in degrees between the hour and minute hands.\n    Examples:\n    >>> calculate_clock_angle(3, 0)\n    90.0\n    >>> calculate_clock_angle(12, 30)\n    165.0\n    \"\"\"\n    import math\n    \n    # Normalize hour to fit within a 12-hour clock\n    hour %= 12\n    \n    # Position of the hour hand (each hour moves 30 degrees plus an additional movement due to minutes)\n    hour_angle = (hour + minute / 60) * 30\n    \n    # Position of the minute hand (each minute moves 6 degrees)\n    minute_angle = minute * 6\n    \n    # To find the smaller of the two possible angles\n    angle = abs(hour_angle - minute_angle)\n    # Smaller angle measured in degrees (clockwise angle or counter-clockwise angle)\n    return min(angle, 360 - angle)"], ["def angle_between_vectors(v1, v2):\n    \"\"\"\n    Calculate the angle between two vectors in degrees.\n    \n    Parameters:\n        v1 (list or tuple): The first vector, e.g., [x1, y1].\n        v2 (list or tuple): The second vector, e.g., [x2, y2].\n        \n    Returns:\n        float: The angle between the two vectors in degrees.\n    \"\"\"\n    v1 = np.array(v1)\n    v2 = np.array(v2)\n    unit_v1 = v1 / np.linalg.norm(v1)\n    unit_v2 = v2 / np.linalg.norm(v2)\n    dot_product = np.dot(unit_v1, unit_v2)\n    angle_rad = np.arccos(dot_product)\n    angle_deg = np.degrees(angle_rad)\n    return angle_deg"], ["def calculate_triangle_angle(a, b):\n    '''\n    This function calculates the third angle of a triangle given two angles.\n    \n    Parameters: \n    a, b (float): The two angles of the triangle\n   \n    Returns: \n    float: The third angle of the triangle.\n    \n    Example: \n    calculate_triangle_angle(60, 60)\n    # Output: 60.0\n    '''\n    third_angle = 180 - a - b\n    return third_angle"], ["def calculate_point_angle(angles):\n    '''\n    This function calculates the missing angle around a point.\n    \n    Parameters: \n    angles (list): The list of known angles around a point\n   \n    Returns: \n    float: The missing angle around the point.\n    \n    Example: \n    calculate_point_angle([90, 90, 90])\n    # Output: 90.0\n    '''\n    sum_angles = sum(angles)\n    absent_angle = 360 - sum_angles\n    return absent_angle"], ["def angle_between_hours(hour1, hour2):\n    \"\"\"\n    Calculate the smallest angle between two hour marks on a clock.\n    Parameters:\n    - hour1 (int): First hour mark (1 through 12).\n    - hour2 (int): Second hour mark (1 through 12).\n    Returns:\n    - float: Smallest angle between the two hour marks in degrees.\n    Examples:\n    >>> angle_between_hours(3, 9)\n    180.0\n    >>> angle_between_hours(12, 4)\n    120.0\n    \"\"\"\n    # Absolute difference in angles\n    angle1 = angle_at_hour_mark(hour1)\n    angle2 = angle_t_hours(hour2)\n    difference = abs(angle1 - angle2)\n    \n    # Return the smallest angle\n    if difference > 180:\n        return 360 - difference\n    else:\n        return difference"]], "Similarity": [["def find_missing_length(similar_triangles, target_side_index):\n    \"\"\"\n    Calculates a missing side in similar triangles based on the property of corresponding sides being in proportion.\n    \n    Parameters:\n        similar_triangles (tuple): A tuple containing two tuples; each inner tuple represents the known sides of each triangle, where None represents the unknown side.\n        target_side_index (int): The index of the side that is missing (0 for the first side, 1 for the second side, 2 for the third side).\n    \n    Returns:\n        symbolic or numeric expression: The length of the missing side if calculable.\n    Example:\n        >>> find_missing_length(((3, 4, 5), (6, 8, None)), 2)\n        10\n        >>> find_missing_length(((2, None, 4), (3, 9, 6)), 1)\n        6\n    \"\"\"\n    known_sides1, known_sides2 = similar_triangles\n    \n    # Identify the non-None sides to use for proportions\n    not_none_indices = [i for i in range(3) if known_sides1[i] is not None and known_sides2[i] is not None]\n    \n    if not not_none_indices:\n        return None  # can't compute the missing side without any known proportions\n    \n    # Use the first available ratio to compute the missing side\n    ratio = simplify(known_sides2[not_none_indices[0]] / known_sides1[not_none_indices[0]])\n    \n    # Find the missing side using the calculated ratio\n    return simplify(known_sides1[target_side_index] * ratio)", "def find_missing_side_lengths(known_sides, reference_sides, missing_side_length):\n    \"\"\"\n    Given the sides of a similar triangle, find the unknown side lengths using proportion.\n    Parameters:\n    - known_sides (list or tuple of floats): Side lengths of the known triangle.\n    - reference_sides (list or tuple of floats): Side lengths of the similar reference triangle.\n    - missing_side_length (float): One known corresponding side length in the triangle for which lengths are to be computed.\n    Returns:\n    - list: Calculated side lengths of the unknown triangle based on proportionality.\n    Example:\n    >>> find_missing_side_lengths((3, 4), (6, 8), 5)\n    [10, 6.66666667]\n    \"\"\"\n    ratio = missing_side_length / reference_sides[0]\n    missing_sides = [side * ratio for side in known_sides]\n    return missing_sides"], ["def triangle_proportional_sides(triangle1_sides, ratio):\n    \"\"\"\n    Compute the sides of a triangle given the sides of a similar triangle and the ratio of similarity.\n    \n    Parameters:\n    triangle1_sides (list of floats): The sides of the known triangle.\n    ratio (float): The ratio of proportionality to compute the sides of the second triangle.\n    \n    Returns:\n    list of floats: The calculated sides of the second triangle based on the ratio.\n    \n    Examples:\n    >>> triangle_proportional_sides([3, 4, 5], 2)\n    [6.0, 8.0, 10.0]\n    \"\"\"\n    triangle2_sides = [side * ratio for side in triangle1_sides]\n    return triangle2_sides"], ["def check_triangle_similarity(sides_A, sides_B, angles_A=None, angles_B=None):\n    \"\"\"\n    Determine if two triangles are similar either by their sides or by angles.\n    \n    Parameters:\n    - sides_A (tuple): A tuple of three numbers representing the side lengths of the first triangle.\n    - sides_B (tuple): A tuple of three numbers representing the side lengths of the second triangle.\n    - angles_A (tuple, optional): A tuple of three angles (in degrees) for the first triangle.\n    - angles_B (tuple, optional): A tuple of three angles (in degrees) for the second triangle.\n    Returns:\n    - bool: Returns True if triangles are similar, otherwise False.\n    \n    Examples:\n    >>> check_triangle_similarity((3, 4, 5), (6, 8, 10))\n    True\n    >>> check_triangle_similarity((3, 4, 5), (7, 8, 10))\n    False\n    >>> check_triangle_similarity((2, 3, 4), (4, 6, 8), angles_A=(45, 90, 45), angles_B=(45, 90, 45))\n    True\n    \"\"\"\n    # Similarity by SSS (Side-Side-Side) Proportionality\n    if sorted([sides_A[i] / sides_B[i] for i in range(3)]) == sorted([sides_A[0] / sides_B[0]] * 3):\n        return True\n    \n    # Similarity by AA (Angle-Angle)\n    if angles_A is not None and angles_B is not None:\n        set_A, set_B = set(angles_A), set(angles_B)\n        if set_A == set_B:\n            return True\n    return False", "def check_similarity_by_sides(sides1, sides2):\n    \"\"\"\n    Checks whether two triangles are similar by comparing the ratio of their corresponding sides.\n    \n    Parameters:\n        sides1 (tuple): A tuple of three numbers or symbolic expressions representing the sides of the first triangle.\n        sides2 (tuple): A tuple of three numbers or symbolic expressions representing the sides of the second triangle.\n        \n    Returns:\n        bool: Returns True if the triangles are similar, otherwise False.\n    Example:\n    >>> check_similarity_by_sides((3, 4, 5), (6, 8, 10))\n    True\n    >>> check_similarity_by_sides((2, 3, 4), (4, 6, 9))\n    False\n    \"\"\"\n    # ratios of corresponding sides\n    ratios = [simplify(sides1[i] / sides2[i]) for i in range(3)]\n    \n    return ratios[0] == ratios[1] == ratios[2]", "def check_similarity_by_angles(angles1, angles2):\n    \"\"\"\n    Checks whether two triangles are similar by comparing their angles.\n    \n    Parameters:\n        angles1 (tuple): A tuple of three angle measures (in degrees or radians) of the first triangle.\n        angles2 (tuple): A tuple of three angle measures (in degrees or radians) of the second triangle.\n        \n    Returns:\n        bool: Returns True if all corresponding angles are equal, implying similarity.\n    Example:\n        >>> check_similarity_by_angles((45, 45, 90), (45, 45, 90))\n        True\n        >>> check_similarity_by_angles((30, 60, 90), (30, 70, 80))\n        False\n    \"\"\"\n    # Check if each angle in angles1 is equal to the corresponding angle in angles2\n    return set(angles1) == set(angles2)", "def are_triangles_similar(sides1, sides2, angles1, angles2):\n    \"\"\"\n    Determine if two triangles are similar based on side lengths and angles,\n    and find the similarity ratio if they are similar.\n    Parameters:\n    - sides1 (tuple): A tuple of three side lengths (a1, b1, c1) of the first triangle.\n    - sides2 (tuple): A tuple of three side lengths (a2, b2, c2) of the second triangle.\n    - angles1 (tuple): A tuple of three angles (A1, B1, C1) of the first triangle in degrees.\n    - angles2 (tuple): A tuple of three angles (A2, B2, C2) of the second triangle in degrees.\n    Returns:\n    - tuple: (bool, float) First element is Boolean indicating similarity,\n             and the second is the similarity ratio if similar, otherwise None.\n    Example:\n    >>> are_triangles_similar((3, 4, 5), (6, 8, 10), (90, 45, 45), (90, 45, 45))\n    (True, 2.0)\n    \"\"\"\n    # Checking angle-angle (AA) similarity\n    angles_matched = sorted(angles1) == sorted(angles2)\n    \n    if angles_matched:\n        # Calculate side ratios and check whether they are the same\n        ratios = [s2 / s1 for s1, s2 in zip(sorted(sides1), sorted(sides2))]\n        if all(math.isclose(ratios[0], ratio, rel_tol=1e-9) for ratio in ratios[1:]):\n            return (True, ratios[0])\n    return (False, None)", "def are_triangles_similar(sides_a, sides_b):\n    \"\"\"\n    Checks whether two triangles are similar by comparing the side ratios and corresponding angles.\n    Parameters:\n    - sides_a (list or tuple of floats): Lengths of the sides of the first triangle (a1, a2, a3).\n    - sides_b (list or tuple of floats): Lengths of the sides of the second triangle (b1, b2, b3).\n    Returns:\n    - bool: True if triangles are similar, False otherwise.\n    Example:\n    >>> are_triangles_similar((3, 4, 5), (6, 8, 10))\n    True\n    >>> are_triangles_similar((2, 3, 4), (4, 6, 9))\n    False\n    \"\"\"\n    # Sort sides to ensure corresponding sides are ratioed\n    sides_a = sorted(sides_a)\n    sides_b = sorted(sides_b)\n    # Calculate ratios of corresponding sides\n    ratios = [sa/sb for sa, sb in zip(sides_a, sides_b)]\n    # Check if all ratios are the same using numpy's allclose to allow some floating-point tolerance\n    return np.allclose(ratios[0], ratios, rtol=1e-5)", "def triangle_similarity_calculator(sides1, sides2):\n    \"\"\"\n    Checks whether two triangles are similar based on the side length ratios.\n    \n    Parameters:\n    sides1 (tuple of floats): Side lengths of the first triangle (a, b, c)\n    sides2 (tuple of floats): Side lengths of the second triangle (d, e, f)\n    \n    Returns:\n    bool: Returns True if triangles are similar, False otherwise.\n    \n    Examples:\n    >>> triangle_similarity_calculator((3, 4, 5), (6, 8, 10))\n    True\n    >>> triangle_similarity_calculator((2, 3, 4), (4, 6, 9))\n    False\n    \"\"\"\n    # Sort sides to compare ratios a/d, b/e, c/f.\n    sides1 = sorted(sides1)\n    sides2 = sorted(sides2)\n    \n    # Calculate and compare ratios\n    ratios = np.array(sides1) / np.array(sides2)\n    return np.allclose(ratios, ratios[0])  # check if all ratios are approximately equal"], ["def verify_similarity(triangle1, triangle2, criterion='SSS'):\n    \"\"\"\n    Determine if two triangles are similar based on provided side lengths or angles.\n    \n    Parameters:\n    triangle1 (dict): A dictionary containing sides (a, b, c) and optionally angles (A, B, C) of the first triangle.\n    triangle2 (dict): A dictionary containing sides (x, y, z) and optionally angles (X, Y, Z) of the second triangle.\n    criterion (str): The criterion to use for verifying similarity ('SSS', 'SAS', 'AA').\n    \n    Returns:\n    bool: True if triangles are similar under the given criterion, otherwise False.\n    \n    Examples:\n    >>> verify_similarity({'a': 3, 'b': 4, 'c': 5}, {'x': 6, 'y': 8, 'z': 10}, 'SSS')\n    True\n    >>> verify_similarity({'A': 45, 'B': 45}, {'X': 45, 'Y': 45}, 'AA')\n    True\n    \"\"\"\n    if criterion == 'SSS':\n        ratios = sorted([triangle1['a']/triangle2['x'], triangle1['b']/triangle2['y'], triangle1['c']/triangle2['z']])\n        return N(ratios[0]) == N(ratios[1]) == N(ratios[2])\n    elif criterion == 'SAS':\n        # Implement SAS logic\n        pass  # Placeholder for now\n    elif criterion == 'AA':\n        # Assume angles are in degrees and we only need two angles each\n        angles1 = sorted([triangle1.get(key) for key in ['A', 'B', 'C'] if key in triangle1])\n        angles2 = sorted([triangle2.get(key) for key in ['X', 'Y', 'Z'] if key in triangle2])\n        return N(angles1[0]) == N(angles2[0]) and N(angles1[1]) == N(angles2[1])\n    return False"], ["def find_missing_length_and_area_ratio(base_triangle, sim_ratio, missing_side=None, base_area=None):\n    \"\"\"\n    Calculate unknown sides and area ratio of similar triangles given base triangle dimensions and similarity ratio.\n    \n    Parameters:\n    - base_triangle (tuple): A tuple of three numbers representing the side lengths of the base triangle.\n    - sim_ratio (float): The ratio of similarity between two triangles.\n    - missing_side (tuple of int): Positions (0, 1, 2) of sides in base_triangle for which length is unknown.\n    - base_area (float, optional): The area of the base triangle.\n    Returns:\n    - dict: Dictionary with keys `sides` containing new side lengths, and optionally `area_ratio` if base_area provided.\n    \n    Examples:\n    >>> find_missing_length_and_area_ratio((3, 4, 5), 2)\n    {'sides': (6, 8, 10)}\n    >>> find_missing_length_and_area_ratio((3, 4, 5), 0.5, base_area=6)\n    {'sides': (1.5, 2, 2.5), 'area_ratio': 0.25}\n    \"\"\"\n    new_lengths = tuple([side * sim_ratio for side in base_triangle])\n    result = {'sides': new_lengths}\n    if base_area is not None:\n        result['area_ratio'] = sim_ratio**2\n    return result"], ["def proportional_sides_solver(known_ratios, known_side, target='missing'):\n    \"\"\"\n    Solves for unknown sides in similar triangles based on a known side ratio and a known side length.\n    \n    Parameters:\n    known_ratios (tuple of floats): Ratios of corresponding sides as (known_base_ratio, target_base_ratio)\n    known_side (float): Length of the known side for the computation.\n    target (str, optional): Specifies if the target is the 'missing' side or 'known'. Defaults to 'missing'.\n    \n    Returns:\n    float: Length of the target side.\n    \n    Examples:\n    >>> proportional_sides_solver((2, 3), 4)\n    6.0\n    >>> proportional_sides_solver((3, 2), 6, target='known')\n    4.0\n    \"\"\"\n    known_base_ratio, target_base_ratio = known_ratios\n    if target == 'missing':\n        return (target_base_ratio / known_base_ratio) * known_side\n    else:\n        return (known_base_ratio / target_base_ratio) * known_side"], ["def find_missing_length(similarity_ratio, known_length):\n    \"\"\"\n    Calculate the corresponding side length in a similar triangle using the similarity ratio.\n    \n    Parameters:\n    - similarity_ratio (float): The ratio of similarity between two triangles.\n    - known_length (float): The side length in one of the triangles whose corresponding\n                            side length in the similar triangle needs to be found.\n    \n    Returns:\n    - float: The corresponding side length in the other triangle.\n    Example:\n    >>> find_missing_length(0.5, 10)\n    5.0\n    \"\"\"\n    return similarity_ratio * known_length"], ["def area_ratio_calculator(side_ratio):\n    \"\"\"\n    Calculates the ratio of areas of two similar triangles based on the ratio of corresponding sides.\n    \n    Parameters:\n    side_ratio (float): The ratio of any corresponding sides of the two similar triangles.\n    \n    Returns:\n    float: The ratio of areas of the two triangles.\n    \n    Examples:\n    >>> area_ratio_calculator(2)\n    4.0\n    >>> area_ratio_calculator(0.5)\n    0.25\n    \"\"\"\n    return side_ratio ** 2"]], "Parallelograms": [["def midpoint(point_a, point_b):\n    \"\"\"\n    Calculate the midpoint between two points in 2D space.\n    Parameters:\n    - point_a (tuple): Coordinates of the first point (x1, y1).\n    - point_b (tuple): Coordinates of the second point (x2, y2).\n    Returns:\n    - tuple: Coordinates of the midpoint.\n    Example:\n    >>> midpoint((0, 0), (2, 2))\n    (1.0, 1.0)\n    \"\"\"\n    return ((point_a[0] + point_b[0]) / 2, (point_a[1] + point_b[1]) / 2)", "def calculate_midpoint(point1, point2):\n    \"\"\"\n    Calculate the midpoint of a segment based on two endpoints.\n    Parameters:\n        point1 (tuple): The (x, y) coordinates of the first endpoint.\n        point2 (tuple): The (x, y) coordinates of the second endpoint.\n    Returns:\n        tuple: The (x, y) coordinates of the midpoint.\n    Examples:\n        >>> calculate_midpoint((1, 1), (3, 3))\n        (2.0, 2.0)\n    \"\"\"\n    midpoint = ((point1[0] + point2[0]) / 2, (point1[1] + point2[1]) / 2)\n    return midpoint", "def segment_length_and_midpoint(point1, point2):\n    \"\"\"\n    Calculate the length of the segment and the midpoint between two points in 2D space.\n    \n    Parameters:\n        point1 (tuple): The (x, y) coordinates of the first point.\n        point2 (tuple): The (x, y) coordinates of the second point.\n    \n    Returns:\n        float: The length of the segment between the two points.\n        tuple: The midpoint of the segment in (x, y) format.\n    \n    Examples:\n        >>> segment_length_and_midpoint((0, 0), (4, 3))\n        (5.0, (2.0, 1.5))\n        >>> segment_length_and_midpoint((1, 2), (1, -1))\n        (3.0, (1.0, 0.5))\n    \"\"\"\n    x1, y1 = point1\n    x2, y2 = point2\n    # Compute the length of the segment\n    length = np.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2)\n    # Compute the midpoint of the segment\n    midpoint = ((x1 + x2) / 2, (y1 + y2) / 2)\n    \n    return length, midpoint"], ["def diagonal_lengths(sides, angle_degrees):\n    \"\"\"\n    Calculate the lengths of the diagonals in a parallelogram using side lengths and the angle between them.\n    Parameters:\n        sides (dict): A dictionary with side lengths {'a': length of side a, 'b': length of side b}.\n        angle_degrees (float): The angle between the sides in degrees.\n    Returns:\n        dict: The lengths of diagonals {'d1': diagonal1 length, 'd2': diagonal2 length}.\n    Examples:\n        >>> diagonal_lengths({'a': 5, 'b': 3}, 60)\n        {'d1': 7.795831523312719, 'd2': 4.0}\n    \"\"\"\n    angle_radians = np.deg2rad(angle_degrees)\n    d1 = math.sqrt(sides['a']**2 + sides['b']**2 - 2 * sides['a'] * sides['b'] * math.cos(angle_radians))\n    d2 = math.sqrt(sides['a']**2 + sides['b']**2 + 2 * sides['a'] * sides['b'] * math.cos(angle_radians))\n    return {'d1': d1, 'd2': d2}"], ["def parallelogram_perimeter(sides):\n    \"\"\"\n    Calculate the perimeter of a parallelogram given the lengths of its sides.\n    Parameters:\n    - sides (tuple): Lengths of the sides (side1, side2).\n    Returns:\n    - float: Perimeter of the parallelogram.\n    Example:\n    >>> parallelogram_perimeter((5, 3))\n    16\n    \"\"\"\n    side1, side2 = sides\n    return 2 * (side1 + side2)", "def calculate_perimeter(sides):\n    \"\"\"\n    Calculate the perimeter of a parallelogram based on the lengths of its sides.\n    Parameters:\n        sides (dict): A dictionary with side lengths {'a': length of side a, 'b': length of side b}.\n    Returns:\n        float: The perimeter of the parallelogram.\n    Examples:\n        >>> calculate_perimeter({'a': 4, 'b': 3})\n        14\n    \"\"\"\n    return 2 * (sides['a'] + sides['b'])", "def parallelogram_perimeter(side1, side2):\n    \"\"\"\n    Calculate the perimeter of a parallelogram given the lengths of its two adjacent sides.\n    \n    Parameters:\n        side1 (float): The length of the first side.\n        side2 (float): The length of the adjacent side.\n    \n    Returns:\n        float: The perimeter of the parallelogram.\n    \n    Examples:\n        >>> parallelogram_perimeter(4, 3)\n        14\n        >>> parallelogram_perimeter(5, 5)\n        20\n    \"\"\"\n    return 2 * (side1 + side2)"], ["def verify_parallelism(vector1, vector2):\n    \"\"\"\n    Verify if two vectors are parallel by calculating the cross-product.\n    Parameters:\n        vector1 (tuple): The components of the first vector.\n        vector2 (tuple): The components of the second vector.\n    Returns:\n        bool: True if the vectors are parallel, False otherwise.\n    Examples:\n        >>> verify_parallelism((2, 2), (4, 4))\n        True\n    \"\"\"\n    return np.cross(vector1, vector2) == 0"], ["def parallelogram_area(vertices):\n    \"\"\"\n    Calculate the area of a parallelogram given its vertices.\n    Parameters:\n    - vertices (list of tuples): Coordinates of the vertices [(x1, y1), (x2, y2), (x3, y3), (x4, y4)].\n    Returns:\n    - float: Area of the parallelogram.\n    Example:\n    >>> parallelogram_area([(0, 0), (2, 0), (3, 2), (1, 2)])\n    4.0\n    \"\"\"\n    (x1, y1), (x2, y2), (x3, y3), _ = vertices\n    return abs((x2-x1)*(y3-y1) - (x3-x1)*(y2-y1))"], ["def intersection_of_diagonals(sides):\n    \"\"\"\n    Determine the point of intersection of diagonals in a parallelogram, which is the midpoint.\n    Parameters:\n        sides (dict): A dictionary with the ((startx, starty), (endx, endy)) coordinates for sides a and c.\n    Returns:\n        tuple: The coordinates of the intersection point (midpoint).\n    Examples:\n        >>> intersection_of_diagonals({ 'a': ((0, 0), (4, 0)), 'c': ((2, 2), (6, 2)) })\n        (3.0, 1.0)\n    \"\"\"\n    point_a1, point_a2 = sides['a']\n    point_c1, point_c2 = sides['c']\n    midpoint_a = calculate_midpoint(point_a1, point_a2)\n    midpoint_c = calculate_midpoint(point_c1, point_c2)\n    intersection = calculate_midpoint(midpoint_a, midpoint_c)\n    return intersection"], ["def distance(point_a, point_b):\n    \"\"\"\n    Calculate the Euclidean distance between two points in 2D space.\n    Parameters:\n    - point_a (tuple): Coordinates of the first point (x1, y1).\n    - point_b (tuple): Coordinates of the second point (x2, y2).\n    Returns:\n    - float: Euclidean distance.\n    Example:\n    >>> distance((0, 0), (3, 4))\n    5.0\n    \"\"\"\n    return np.sqrt((point_b[0] - point_a[0])**2 + (point_b[1] - point_a[1])**2)"], ["def is_parallelogram(points):\n    \"\"\"\n    Check if four points form a parallelogram in 2D space.\n    Parameters:\n    - points (list of tuples): List of four coordinates [(x1, y1), (x2, y2), (x3, y3), (x4, y4)].\n    Returns:\n    - bool: True if the points form a parallelogram, False otherwise.\n    Example:\n    >>> is_parallelogram([(0, 0), (2, 0), (3, 2), (1, 2)])\n    True\n    \"\"\"\n    if len(points) != 4:\n        return False\n    side_lengths = [distance(points[i], points[(i + 1) % 4]) for i in range(4)]\n    return (np.isclose(side_lengths[0], side_lengths[2]) and np.isclose(side_lengths[1], side_lengths[3]))"]], "Coordinate Systems": [["def spherical_to_cartesian(rho, theta, phi):\n    \"\"\"\n    Converts spherical coordinates to Cartesian (rectangular) coordinates.\n    Parameters:\n        rho (float): Radial distance\n        theta (float): Azimuthal angle in radians\n        phi (float): Polar angle from the positive z-axis in radians\n    \n    Returns:\n        tuple: (x, y, z) coordinates in Cartesian system\n    \n    Examples:\n        >>> spherical_to_cartesian(1, np.pi/2, np.pi/2)\n        (1.0, 0.0, 6.123233995736766e-17) # approximately (1, 0, 0)\n    \"\"\"\n    x = rho * np.sin(phi) * np.cos(theta)\n    y = rho * np.sin(phi) * np.sin(theta)\n    z = rho * np.cos(phi)\n    return x, y, z", "def cartesian_to_spherical(x, y, z):\n    \"\"\"\n    Converts Cartesian (rectangular) coordinates to spherical coordinates.\n    Parameters:\n        x (float): x-coordinate\n        y (float): y-coordinate\n        z (float): z-coordinate\n    \n    Returns:\n        tuple: (rho, theta, phi) coordinates in spherical system\n    \n    Examples:\n        >>> cartesian_to_spherical(1, 0, 0)\n        (1.0, 0.0, 1.5707963267948966) # approximately (1, 0, π/2)\n    \"\"\"\n    rho = np.sqrt(x**2 + y**2 + z**2)\n    theta = np.arctan2(y, x)\n    phi = np.arccos(z / rho)\n    return rho, theta, phi", "def spherical_to_rectangular(rho, theta, phi):\n    \"\"\"\n    Converts spherical coordinates to rectangular coordinates.\n    \n    Parameters:\n        rho (float): Radius or the distance from the origin\n        theta (float): Azimuthal angle in radians\n        phi (float): Polar angle in radians\n    \n    Returns:\n        tuple: A tuple (x, y, z) representing the coordinates in the rectangular system\n    \n    Example:\n        >>> spherical_to_rectangular(5, np.pi/4, np.pi/6)\n        (2.165, 2.165, 4.33)\n    \"\"\"\n    x = rho * np.sin(phi) * np.cos(theta)\n    y = rho * np.sin(phi) * np.sin(theta)\n    z = rho * np.cos(phi)\n    \n    return round(x, 3), round(y, 3), round(z, 3)", "def rectangular_to_spherical(x, y, z):\n    \"\"\"\n    Converts rectangular coordinates to spherical coordinates.\n    \n    Parameters:\n        x (float): X coordinate\n        y (float): Y coordinate\n        z (float): Z coordinate\n    \n    Returns:\n        tuple: A tuple (rho, theta, phi) representing the coordinates in the spherical system\n    \n    Example:\n        >>> rectangular_to_spherical(2.165, 2.165, 4.33)\n        (5.0, 0.785, 0.524)\n    \"\"\"\n    rho = np.sqrt(x**2 + y**2 + z**2)\n    theta = np.arctan2(y, x)\n    phi = np.arccos(z / rho)\n    \n    return round(rho, 3), round(theta, 3), round(phi, 3)", "def spherical_to_rectangular(rho, theta, phi):\n    \"\"\"\n    Convert spherical coordinates to rectangular coordinates.\n    Parameters:\n    - rho (float): Radial distance\n    - theta (float): Azimuthal angle in radians\n    - phi (float): Polar angle in radians\n    Returns:\n    (float, float, float): Tuple representing (x, y, z) in rectangular coordinates\n    Examples:\n    >>> spherical_to_rectangular(1, np.pi/2, np.pi/2)\n    (1.0, 0.0, 6.123233995736766e-17)\n    \"\"\"\n    x = rho * np.sin(phi) * np.cos(theta)\n    y = rho *  sin(phi) * np.sin(theta)\n    z = rho * np.cos(phi)\n    return (x, y, z)", "def rectangular_to_spherical(x, y, z):\n    \"\"\"\n    Convert rectangular coordinates to spherical coordinates.\n    Parameters:\n    - x (float): x-coordinate\n    - y (float): y-coordinate\n    - z (float): z-coordinate\n    Returns:\n    (float, float, float): Tuple representing (rho, theta, phi) in spherical coordinates\n    Examples:\n    >>> rectangular_to_spherical(1, 1, 1)\n    (1.7320508075688772, 0.7853981633974483, 0.9553166181245093)\n    \"\"\"\n    rho = np.sqrt(x**2 + y**2 + z**2)\n    theta = np.arctan2(y, x)\n    phi = np.arccos(z / rho)\n    return (rho, theta, phi)"], ["def midpoint(p1, p2):\n    \"\"\"Calculate the midpoint between two points.\n    \n    Parameters\n    ----------\n    p1, p2 : tuple\n        Points for which to find the midpoint (each as tuple of floats (x, y)).\n    Returns\n    -------\n    tuple\n        Midpoint (x, y).\n    Examples\n    --------\n    >>> midpoint((0, 0), (2, 2))\n    (1.0, 1.0)\n    \"\"\"\n    x1, y1 = p1\n    x2, y2 = p2\n    mx = (x1 + x2) / 2\n    my = (y1 + y2) / 2\n    return (mx, my)", "def midpoint_and_distance(p1, p2):\n    \"\"\"\n    Calculate the midpoint and the distance between two points p1 and p2.\n    Parameters:\n    - p1 (tuple): The coordinates of the first point (x1, y1).\n    - p2 (tuple): The coordinates of the second point (x2, y2).\n    Returns:\n    - tuple: The midpoint (mx, my) and distance d between p1 and p2.\n    Examples:\n    >>> midpoint_and_distance((1, 2), (3, 4))\n    ((2.0, 3.0), 2.8284271247461903)\n    \"\"\"\n    x1, y1 = p1\n    x2, y2 = p2\n    mx = (x1 + x2) / 2\n    my = (y1 + y2) / 2\n    distance = np.sqrt((x2 - x1)**2 + (y2 - y1)**2)\n    return (mx, my), distance"], ["def distance_between_points(point1: Tuple[float, float], point2: Tuple[float, float]) -> float:\n    \"\"\"\n    Calculate the Euclidean distance between two points in the xy-plane.\n    \n    Parameters:\n    - point1 (Tuple[float, float]): The first point (x1, y1).\n    - point2 (Tuple[float, float]): The second point (x2, y2).\n    \n    Returns:\n    - float: The distance between the points.\n    \n    Examples:\n    >>> distance_between_points((1, 2), (4, 6))\n    5.0\n    \"\"\"\n    return sqrt((point1[0] - point2[0])**2 + (point1[1] - point2[1])**2)", "def midpoint_between_points(point1: Tuple[float, float], point2: Tuple[float, float]) -> Tuple[float, float]:\n    \"\"\"\n    Calculate the midpoint between two points in the xy-plane.\n    \n    Parameters:\n    - point1 (Tuple[float, float]): The first point (x1, y1).\n    - point2 (Tuple[float, float]): The second point (x2, y2).\n    \n    Returns:\n    - Tuple[float, float]: The midpoint (xm, ym).\n    \n    Examples:\n    >>> midpoint_between_points((1, 1), (3, 5))\n    (2.0, 3.0)\n    \"\"\"\n    return ((point1[0] + point2[0]) / 2, (point1[1] + point2[1]) / 2)"], ["def cartesian_intersect_parametric(plane_normal: np.array, plane_point: np.array,\n                                   parametric_func: Callable[[float], np.array], t_initial: float) -> Tuple[float, np.array]:\n    \"\"\"\n    Find the intersection of a plane and a parametric curve.\n    \n    Parameters:\n    - plane_normal (np.array): The normal vector of the plane.\n    - plane_point (np.array): A point on the plane.\n    - parametric_func (Callable[[float], np.array]): The parametric equation of the curve.\n    - t_initial (float): Initial guess for the parameter t.\n    \n    Returns:\n    - Tuple[float, np.array]: The parameter t at intersection and the intersection point in Cartesian coordinates.\n    \n    Example:\n    >>> cartesian_intersect_parametric(np.array([0, 0, 1]), np.array([0, 0, 0]), lambda t: np.array([t, t, t]), 0)\n    (0.0, array([0., 0., 0.]))\n    \"\"\"\n    def to_minimize(t):\n        point_on_curve = parametric_func(t)\n        return np.dot(plane_normal, point_on_curve - plane_point)\n    \n    t_sol = optimize.fsolve(to_minimize, t_initial)[0]\n    intersection_point = parametric_func(t_sol)\n    return t_sol, intersection_point"], ["def cartesian_to_cylindrical(x, y, z):\n    \"\"\"\n    Converts Cartesian (rectangular) coordinates to cylindrical coordinates.\n    Parameters:\n        x (float): x-coordinate\n        y (float): y-coordinate\n        z (float): z-coordinate\n    \n    Returns:\n        tuple: (r, theta, z) coordinates in cylindrical system\n    \n    Examples:\n        >>> cartesian_to_cylindrical(1, 0, 1)\n        (1.0, 0.0, 1) # radius, angle, height\n    \"\"\"\n    r = np.sqrt(x**2 + y**2)\n    theta = np.arctan2(y, x)\n    return r, theta, z", "def rectangular_to_cylindrical(x, y, z):\n    \"\"\"\n    Converts rectangular coordinates to cylindrical coordinates.\n    \n    Parameters:\n        x (float): X coordinate\n        y (float): Y coordinate\n        z (float): unchanged Z coordinate\n    \n    Returns:\n        tuple: A tuple (r, theta, z) representing the coordinates in the cylindrical system\n    \n    Example:\n        >>> rectangular_to_cylindrical(3, 4, 5)\n        (5.0, 0.927, 5)\n    \"\"\"\n    r = np.sqrt(x**2 + y**2)\n    theta = np.arctan2(y, x)\n    \n    return round(r, 3), round(theta, 3), z", "def rectangular_to_cylindrical(x, y, z):\n    \"\"\"\n    Convert rectangular coordinates to cylindrical coordinates.\n    Parameters:\n    - x (float): x-coordinate\n    - y (float): y-coordinate\n    - z (float): z-coordinate, same as cylindrical's z\n    Returns:\n    (float, float, float): Tuple representing (r, theta, z) in cylindrical coordinates\n    Examples:\n    >>> rectangular_to_cylindrical(1, 1, 1)\n    (1.4142135623730951, 0.7853981633974483, 1)\n    \"\"\"\n    r = np.sqrt(x**2 + y**2)\n    theta = np.arctan2(y, x)  # np.arctan2 handles the quadrant issues\n    return (r, theta, z)"], ["def cartesian_to_polar(x, y):\n    \"\"\"Convert Cartesian coordinates to polar coordinates.\n    \n    Parameters\n    ----------\n    x : float\n        The x-coordinate in the Cartesian plane.\n    y : float\n        The y-coordinate in the Cartesian plane.\n    Returns\n    -------\n    tuple\n        A tuple containing the radius (r) and angle (theta in radians).\n    Examples\n    --------\n    >>> cartesian_to_polar(1, 1)\n    (1.4142135623730951, 0.7853981633974483)\n    \"\"\"\n    r = np.sqrt(x**2 + y**2)\n    theta = np.arctan2(y, x)\n    return r, theta", "def polar_to_cartesian(r, theta):\n    \"\"\"Convert polar coordinates to Cartesian coordinates.\n    \n    Parameters\n    ----------\n    r : float\n        The radius (distance from origin).\n    theta : float\n        The angle in radians.\n    Returns\n    -------\n    tuple\n        A tuple containing the x and y coordinates in the Cartesian plane.\n    Examples\n    --------\n    >>> polar_to_cartesian(1, np.pi/4)\n    (0.7071067811865476, 0.7071067811865475)\n    \"\"\"\n    x = r * np.cos(theta)\n    y = r * np.sin(theta)\n    return x, y", "def cartesian_to_polar(x, y):\n    \"\"\"\n    Convert Cartesian coordinates to polar coordinates.\n    Parameters:\n    - x (float): The x-coordinate in Cartesian coordinates.\n    - y (float): The y-coordinate in Cartesian coordinates.\n    Returns:\n    - tuple: Returns (r, theta) where r is the radial distance and theta is the angle in radians.\n    Examples:\n    >>> cartesian_to_polar(3, 4)\n    (5.0, 0.9272952180016122)\n    \"\"\"\n    r = np.sqrt(x**2 + y**2)\n    theta = np.arctan2(y, x)\n    return r, theta"], ["def line_intersection(p1, p2, p3, p4):\n    \"\"\"Calculate the point of intersection between two lines defined by four points.\n    \n    Parameters\n    ----------\n    p1, p2 : tuple\n        Points on the first line (each as tuple of floats (x, y)).\n    p3, p4 : tuple\n        Points on the second line (each as tuple of floats (x, y)).\n    Returns\n    -------\n    tuple or None\n        A tuple containing the intersection point (x, y), or None if no intersection exists.\n    Examples\n    --------\n    >>> line_intersection((0, 0), (1, 1), (0, 1), (1, 0))\n    (0.5, 0.5)\n    \"\"\"\n    x1, y1 = p1\n    x2, y2 = p2\n    x3, y3 = p3\n    x4, y4 = p4\n    denom = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4)\n    if denom == 0:\n        return None  # Lines are parallel or coincident.\n    intersect_x = ((x1 * y2 - y1 * x2) * (x3 - x4) - (x1 - x2) * (x3 * y4 - y3 * x4)) / denom\n    intersect_y = ((x1 * y2 - y1 * x2) * (y3 - y4) - (y1 - y2) * (x3 * y4 - y3 * x4)) / denom\n    return (intersect_x, intersect_y)"], ["def adjust_angle_for_quadrant(theta, x, y):\n    \"\"\"\n    Adjust angle to ensure it falls in the correct quadrant.\n    Parameters:\n        theta (float): Computed angle in radians, typically from trigonometric function\n        x (float): x-coordinate used for adjusting angle\n        y (float): y-coordinate for specific cases\n    \n    Returns:\n        float: Adjusted angle in radians\n    \n    Examples:\n        >>> adjust_angle_for_quadrant(np.arctan(-1), -1, 0)\n        -2.356194490192345 # approximately -3π/4, which is adjusted for the correct quadrant\n    \"\"\"\n    if x < 0 and y == 0:\n        return theta + np.pi\n    return theta"], ["def parametric_to_cartesian(t: np.array, parametric_func: Callable[[np.array], np.array]) -> np.array:\n    \"\"\"\n    Convert a parametric representation of curves to Cartesian coordinates.\n    \n    Parameters:\n    - t (np.array): An array of parameter values.\n    - parametric_func (Callable[[np.array], np.array]): The parametric function defined as x(t), y(t), z(t).\n    \n    Returns:\n    - np.array: Cartesian coordinates resulting from parameter t.\n    \n    Examples:\n    >>> parametric_to_cartesian(np.array([0, np.pi/2]), lambda t: np.array([np.cos(t), np.sin(t), 0]))\n    array([[1., 0., 0.],\n           [0., 1., 0.]])\n    \"\"\"\n    return np.array([parametric_func(ti) for ti in t])"], ["def parametric_line_intercept(A, B):\n    \"\"\"\n    Determine the intersection point of two parametrically defined lines in the xy-plane.\n    Parameters:\n    - A (dict): Contains the parametric definition of line A {'point': (x1, y1), 'direction': (dx1, dy1)}\n    - B (dict): Contains the parametric definition of line B {'point': (x2, y2), 'direction': (dx2, dy2)}\n    Returns:\n    - tuple or None: The intersection point (x, y) if exists, otherwise None.\n    Examples:\n    >>> A = {'point': (0, 0), 'direction': (1, 1)}\n    >>> B = {'point': (1, 0), 'direction': (-1, 1)}\n    >>> parametric_line_intercept(A, B)\n    (0.5, 0.5)\n    \"\"\"\n    x1, y1 = A['point']\n    dx1, dy1 = A['direction']\n    x2, y2 = B['point']\n    dx2, dy2 = B['direction']\n    t, s = sp.symbols('t s')\n    equations = [\n        sp.Eq(x1 + t * dx1, x2 + s * dx2),\n        sp.Eq(y1 + t * dy1, y2 + s * dy2)\n    ]\n    result = sp.solve(equations, (t, s))\n    if result:\n        t_val, s_val = result[t], result[s]\n        xp = x1 + t_val * dx1\n        yp = y1 + t_val * dy1\n        return float(xp), float(yp)\n    \n    return None"]], "Conic Sections": [["def identify_conic_section(eq):\n    \"\"\"\n    Identifies the type of conic section from a given equation.\n    Parameters:\n    - eq (str): The algebraic form of the conic section.\n    Returns:\n    - str: The type of the conic section ('circle', 'ellipse', 'parabola', 'hyperbola').\n    \n    Example:\n    - identify_conic_section(\"x**2 + y**2 - 5\") -> 'circle'\n    - identify_conic_section(\"x**2/3 - y**2/2 = 1\") -> 'hyperbola'\n    \"\"\"\n    x, y = symbols('x y')\n    expanded_eq = str(eq).replace('^', '**')\n    parsed_eq = Eq(eval(expanded_eq), 0)\n    coefficients = parsed_eq.as_poly(x, y).coeffs()\n    \n    if len(coefficients) == 3:\n        A, B, C = coefficients\n        if A == C and B == 0:\n            return 'circle'\n        elif A * C > 0 and B == 0:\n            return 'ellipse'\n        elif A * C < 0:\n            return 'hyperbola'\n        else:\n            return 'unknown'\n    elif len(coefficients) == 2:\n        return 'parabola'\n    else:\n        return 'unknown'", "def identify_conic_section(coeffs):\n    \"\"\"\n    Identifies the type of conic section based on the coefficients of the general second-degree polynomial.\n    Parameters:\n        coeffs (dict): Coefficients A, B, C (x^2, xy, y^2), D, E, F (x, y, constant)\n    \n    Returns:\n        str: Type of conic section (\"circle\", \"ellipse\", \"parabola\", \"hyperbola\", \"invalid\")\n    \n    Examples:\n        >>> identify_conic_section({'A': 1, 'B': 0, 'C': 1, 'D': 0, 'E': 0, 'F': -1})\n        'circle'\n        >>> identify_conic_section({'A': 1, 'B': 0, 'C': -1, 'D': 0, 'E': 0, 'F': -1})\n        'hyperbola'\n    \"\"\"\n    A = coeffs.get('A', 0)\n    B = coeffs.get('B', 0)\n    C = coeffs.get('C', 0)\n    \n    # Calculate discriminant\n    discriminant = B**2 - 4*A*C\n    \n    if discriminant > 0:\n        return 'hyperbola'\n    elif discriminant == 0:\n        return 'parabola'\n    elif discriminant < 0:\n        if A == C and B == 0:\n            return 'circle'\n        else:\n            return 'ellipse'\n    return 'invalid'"], ["def ellipse_properties(a, b):\n    \"\"\"\n    Calculate significant geometric properties of an ellipse.\n    Parameters:\n    a (float): The length of the semi-major axis.\n    b (float): The length of the semi-minor axis.\n    Returns:\n    dict: A dictionary containing the focal distance (c), area, and the distance between the foci (2c).\n    Examples:\n    >>> ellipse_properties(5, 3)\n    {'focal_distance': 4.0, 'area': 47.12388980384689, 'distance_between_foci': 8.0}\n    \"\"\"\n    c = np.sqrt(a**2 - b**2)\n    area = np.pi * a * b\n    return {'focal_distance': c, 'area': area, 'distance_between_foci': 2*c}", "def ellipse_properties(a, b):\n    \"\"\"\n    Calculate the properties of an ellipse given its semi-major and semi-minor axes.\n    Parameters:\n    a : float\n        The length of the semi-major axis.\n    b : float\n        The length of the semi-minor axis.\n    Returns:\n    dict\n        A dictionary containing the focal distance (c), the distance between the foci (2c),\n        the area of the ellipse, and the equation of the ellipse in standard form.\n    Examples:\n    >>> ellipse_properties(5, 3)\n    {'focal_distance': 4.0, 'distance_between_foci': 8.0, 'area': 47.12388980384689,\n     'equation': 'x^2/25 + y^2/9 = 1'}\n    \"\"\"\n    c = np.sqrt(a**2 - b**2)\n    area = np.pi * a * b\n    equation = f\"x^2/{a**2} + y^2/{b**2} = 1\"\n    return {\n        'focal_distance': c,\n        'distance_between_foci': 2 * c,\n        'area': area,\n        'equation': equation\n    }", "def properties_of_ellipse(a, b):\n    \"\"\"\n    This function calculates and returns various properties of an ellipse\n    given the lengths of its semi-major (a) and semi-minor (b) axes.\n    \n    Parameters:\n    a (float): Length of semi-major axis.\n    b (float): Length of semi-minor axis.\n    Returns:\n    out (dict): A dictionary containing the properties of the ellipse.\n    \"\"\"\n    # Focal Distance\n    c = np.sqrt(a**2 - b**2)\n    # Area of the ellipse\n    area = np.pi * a * b\n    # Eccentricity of the ellipse\n    eccentricity = c / a \n    out = {'Focal Distance': c, 'Area': area, 'Eccentricity': eccentricity}\n    return out"], ["def get_conic_section_type(equation):\n    \"\"\"\n    Identifies the type of conic section based on the coefficients of the general second degree equation Ax^2 + Bxy + Cy^2 + Dx + Ey + F = 0.\n    Parameters:\n    equation : sympy.Expr\n        The equation representing the conic section in sympy expression format.\n    Returns:\n    str: The type of the conic section: 'circle', 'ellipse', 'parabola', 'hyperbola', or 'unknown'.\n    \"\"\"\n    # Assuming the equation is given in a format sympy can understand (Ax^2 + Bxy + Cy^2 + Dx + Ey + F = 0)\n    A, B, C = equation.as_coefficients_dict()[x**2], equation.as_coefficients_dict()[x*y], equation.as_coefficients_dict()[y**2]\n    \n    # Conditions for identifying the conic section\n    if B**2 - 4*A*C < 0:\n        if A == C:\n            return 'circle'\n        else:\n            return 'ellipse'\n    elif B**2 - 4*A*C == 0:\n        return 'parabola'\n    elif B**2 - 4*A*C > 0:\n        return 'hyperbola'\n    else:\n        return 'unknown'", "def get_conic_section_characteristics(equation):\n    \"\"\"\n    Calculates and returns the characteristics of the conic section based on its equation.\n    Parameters:\n    equation : sympy.Expr\n        The equation representing the conic section in sympy expression format.\n    Returns:\n    dict: A dictionary containing the characteristics of the conic section such as type, center, axes lengths, foci, vertices, and orientation.\n    \"\"\"\n    conic_type = get_conic_section_type(equation)\n    characteristics = {'type': conic_type}\n    \n    if conic_type == 'circle' or conic_type == 'ellipse':\n        conic = ellipse.Ellipse(equation=equation)\n    elif conic_type == 'hyperbola':\n        conic = hyperbola.Hyperbola(equation=equation)\n    elif conic_type == 'parabola':\n        conic = parabola.Parabola(directrix=Line(equation), focus=Point(0, 0))\n    else:\n        return characteristics\n    \n    characteristics.update({\n        'center': conic.center,\n        'foci': conic.foci,\n        'vertices': conic.vertices,\n        'axis_lengths': (conic.hradius, conic.vradius) if conic_type != 'parabola' else (None, None) \n    })\n    \n    if conic_type == 'hyperbola':\n        characteristics['asymptotes'] = conic.asymptotes\n    \n    return characteristics"], ["def hyperbola_properties(a2, b2):\n    \"\"\"\n    Calculate properties of a hyperbola given a^2 and b^2.\n    \n    Parameters:\n        a2 (float): Square of the distance from the center to a vertex along the transverse axis.\n        b2 (float): Square of the distance from the center to a vertex along the conjugate axis.\n    \n    Returns:\n        dict: Dictionary containing foci distance `c`, and length of transverse and conjugate axes.\n    \n    Examples:\n        >>> hyperbola_properties(25, 16)\n        {'c': 9.0, '2a': 10, '2b': 8}\n    \"\"\"\n    a = sp.sqrt(a2)\n    b = sp.sqrt(b2)\n    c = sp.sqrt(a2 + b2)\n    \n    return {'c': c, '2a': 2*a, '2b': 2*b}"], ["def transform_parabola(vertex, focus):\n    \"\"\"\n    Determine the standard form of a parabola given a vertex and a focus.\n    Parameters:\n        vertex (tuple): Coordinates (h, k) of the vertex of the parabola.\n        focus (tuple): Coordinates (p, q) of the focus of the parabola.\n    \n    Returns:\n        str: The standard form equation of the parabola.\n    \n    Examples:\n        >>> transform_parabola((0, 0), (0, 1))\n        'y = (x - 0)^2 / 4 + 0'\n    \"\"\"\n    h, k = vertex\n    p, q = focus\n    if p == h:  # Vertical parabola\n        a = 1/(4*(q-k))\n        equation = f'y = {a}*(x - {h})**2 + {k}'\n    else:  # Horizontal parabola\n        a = 1/(4*(p-h))\n        equation = f'x = {a}*(y - {k})**2 + {h}'\n    \n    return equation"], ["def ellipse_tangent_line(a, b, slope, center=(0, 0)):\n    \"\"\"\n    Calculates the y-intercept of a line tangent to the ellipse at y=mx+c\n    Parameters:\n    a : float\n        Semi-major axis of the ellipse.\n    b : float\n        Semi-minor axis of the ellipse.\n    slope : float\n        Slope (m) of the tangent line.\n    center : tuple\n        Center of the ellipse (h, k).\n    Returns:\n    float\n        y-intercept of the tangent line.\n    Examples:\n    >>> ellipse_tangent_line(5, 3, 1)\n    'y = x ± 7.54983443527075'\n    \"\"\"\n    h, k = center\n    c = (a * b) / np.sqrt((b**2) + (a**2) * slope**2)\n    return f\"y = {slope}x ± {c + k}\""], ["def ellipse_foci(a, b, center=(0, 0)):\n    \"\"\"\n    Calculate the coordinates of the foci of an ellipse.\n    Parameters:\n    a : float\n        Length of the semi-major axis.\n    b : float\n        Length of the semi-minor axis.\n    center : tuple\n        Coordinates of the center of the ellipse (h, k).\n    Returns:\n    tuple of tuples\n        Coordinates of the two foci.\n    Examples:\n    >>> ellipse_foci(5, 3)\n    ((-4.0, 0), (4.0, 0))\n    \"\"\"\n    h, k = center\n    c = np.sqrt(a**2 - b**2)\n    if a >= b:\n        foci = ((h + c, k), (h - c, k))\n    else:\n        foci = ((h, k + c), (h, k - c))\n    return foci", "def foci_of_ellipse(a, b, center):\n    \"\"\"\n    This function calculates and returns the coordinates of foci of an ellipse\n    given the lengths of its semi-major (a) and semi-minor (b) axes, and its center.\n    \n    Parameters:\n    a (float): Length of semi-major axis.\n    b (float): Length of semi-minor axis.\n    center (tuple): The coordinates of the center of the ellipse.\n    Returns:\n    foci (tuple): A tuple containing the coordinates of the two foci.\n    \"\"\"\n    \n    # Distance from the center to the foci\n    c = np.sqrt(a**2 - b**2)\n    foci = ((center[0] - c, center[1]), (center[0] + c, center[1]))\n    return foci"], ["def calculate_intersection_ellipse_line(a, b, h, k, line_eq):\n    \"\"\"\n    Determine the points of intersection (if any) between a standard ellipse and a line.\n    Parameters:\n    a, b (float): Semi-major and semi-minor axes of the ellipse.\n    h, k (float): Center coordinates of the ellipse.\n    line_eq (sympy.Expr): Equation of the line in terms of x and y as sympy expression.\n    Returns:\n    list: A list of tuples representing the intersection points or an empty list if there is no intersection.\n    Examples:\n    >>> x, y = sp.symbols('x y')\n    >>> line_eq = 2*x + 3*y - 4\n    >>> calculate_intersection_ellipse_line(5, 3, 0, 0, line_eq)\n    [(-2.297, 3.197), (0.3433, -0.3809)]\n    \"\"\"\n    x, y = sp.symbols('x y')\n    ellipse_eq = ((x - h)**2 / a**2 + (y - k)**2 / b**2 - 1)\n    sols = sp.solve((ellipse_eq, line_eq), (x, y))\n    return [(float(sol[x]), float(sol[y])) for sol in sols]"], ["def ellipse_equation(center, a, b):\n    \"\"\"\n    This function generates the standard form equation of an ellipse, \n    given its center and the lengths of its semi-major (a) and semi-minor (b) axes.\n    \n    Parameters:\n    center (tuple): The coordinates of the center of the ellipse.\n    a (float): The length of the semi-major axis.\n    b (float): The length of the semi-minor axis.\n    Returns:\n    equation (str): The standard form equation of the ellipse.\n    \"\"\"\n    x, y = sp.symbols('x y')\n    h, k = center\n    # Equation of the ellipse\n    equation = ((x-h)**2 / a**2) + ((y-k)**2 / b**2) - 1\n    return sp.simplify(equation)"], ["def conic_section_properties(eq):\n    \"\"\"\n    Calculates properties of a conic section such as a, b, c, and orientation.\n    Parameters:\n    - eq (str): The algebraic form of the conic section equation.\n    Returns:\n    - dict: A dictionary of properties including 'a', 'b', 'c', 'orientation'.\n    \n    Example:\n    - conic_section_properties(\"y**2 - x**2 = 1\") -> {'a': 1, 'b': 1, 'c': sqrt(2), 'orientation': 'vertical'}\n    \"\"\"\n    conic_type = identify_conic_section(eq)\n    props = {'a': None, 'b': None, 'c': None, 'orientation': None}\n    eq = eq.replace('^', '**')\n    x, y = symbols('x y')\n    if conic_type == 'hyperbola':\n        eq_parsed = Eq(eval(eq), 0)\n        eq_standard = solve(eq_parsed, y)\n        \n        a_term = eq_standard[0].as_coefficients_dict()[x**2]\n        b_term = eq_standard[0].as_coefficients_dict()[y**2]\n        \n        a = sqrt(abs(1/a_term)) if a_term else None\n        b = sqrt(abs(1/b_term)) if b_term else None\n        c = sqrt(a**2 + b**2) if a and b else None\n        \n        if a_term < 0:\n            orientation = 'vertical'\n        else:\n            orientation = 'horizontal'\n        \n        props.update({'a': a, 'b': b, 'c': c, 'orientation': orientation})\n    \n    return props"], ["def point_on_ellipse(x, y, a, b, center=(0, 0)):\n    \"\"\"\n    Determine whether a given point (x, y) lies on the ellipse defined by semi-major axis a and\n    semi-minor axis b centered at 'center'.\n    Parameters:\n    x : float\n        x-coordinate of the point.\n    y : float\n        y-coordinate of the point.\n    a : float\n        Length of the semi-major axis.\n    b : float\n        Length of the semi-minor axis.\n    center : tuple\n        Coordinates of the center of the ellipse (h, k).\n    Returns:\n    bool\n        True if the point is on the ellipse, False otherwise.\n    Examples:\n    >>> point_on_ellipse(1, 4, 5, 3)\n    False\n    \"\"\"\n    h, k = center\n    value = ((x - h)**2 / a**2) + ((y - k)**2 / b**2)\n    return np.isclose(value, 1)"], ["def standard_form_to_general(x, y, h, k, a, b):\n    \"\"\"\n    Transform the standard form of an ellipse equation to its general form.\n    \n    Parameters:\n    x, y (sympy.Symbol): Symbols for the coordinate variables.\n    h, k (float): Coordinates of the center of the ellipse.\n    a (float): Length of the semi-major axis.\n    b (float): Length of the semi-minor axis.\n    Returns:\n    sympy.Expr: The general form of the ellipse equation as a sympy expression.\n    \n    Examples:\n    >>> x, y = sp.symbols('x y')\n    >>> standard_form_to_general(x, y, 0, 0, 5, 3)\n    x**2/25 + y**2/9 - 1\n    \"\"\"\n    return ((x - h)**2 / a**2 + (y - k)**2 / b**2 - 1).simplify()"], ["def calculate_distance_between_foci(conic_equation):\n    \"\"\"\n    Calculates the distance between the foci of an ellipse or hyperbola.\n    Parameters:\n    conic_equation : sympy.Expr\n        The standard form equation of the ellipse or hyperbola.\n    Returns:\n    sympy.Expr: The distance between the foci.\n    \"\"\"\n    characteristics = get_conic_section_characteristics(conic_equation)\n    if characteristics['type'] in ['ellipse', 'hyperbola']:\n        f1, f2 = characteristics['foci']\n        return f1.distance(f2)\n    else:\n        raise ValueError(f\"The conic section type is {characteristics['type']}, which does not have foci.\")"], ["def calculate_distance_between_vertices(conic_equation):\n    \"\"\"\n    Calculates the distance between the vertices of an ellipse or hyperbola.\n    Parameters:\n    conic_equation"]], "Quadrilaterals": [["def perimeter_of_quad(side1, side2, side3, side4):\n    \"\"\"\n    Calculate the perimeter of a quadrilateral given the length of its sides.\n    \n    Parameters:\n    - side1, side2, side3, side4 (float): Lengths of the sides of the quadrilateral.\n    \n    Returns:\n    - float: The perimeter of the quadrilateral.\n    \n    Examples:\n    >>> perimeter_of_quad(5, 5, 8, 8)\n    26\n    \"\"\"\n    return side1 + side2 + side3 + side4", "def quadrilateral_perimeter(*sides):\n    \"\"\"\n    Calculates the perimeter of a quadrilateral given the lengths of its sides.\n    Parameters:\n    - sides (float): variable number of side lengths (expects exactly 4 sides).\n    \n    Returns:\n    - float: the perimeter of the quadrilateral.\n    Examples:\n    >>> quadrilateral_perimeter(5, 5, 8, 8)\n    26\n    \"\"\"\n    return sum(sides)"], ["def calculate_diagonal_rhombus(side_length):\n    \"\"\"\n    Calculate the diagonals of a rhombus given the length of its side.\n    \n    Parameters:\n    - side_length (float): The length of the side of the rhombus.\n    \n    Returns:\n    - tuple: The lengths of the diagonals of the rhombus.\n    \n    Examples:\n    >>> calculate_diagonal_rhombus(5)\n    (7.071, 7.071)\n    \"\"\"\n    diagonal = side_length * math.sqrt(2)\n    return (diagonal, diagonal)", "def rhombus_side(diagonal1, diagonal2):\n    \"\"\"\n    Calculates the side of a rhombus given the lengths of its diagonals.\n    Parameters:\n    - diagonal1 (float): length of the first diagonal.\n    - diagonal2 (float): length of the second diagonal.\n    \n    Returns:\n    - float: the side length of the rhombus.\n    Examples:\n    >>> rhombus_side(6, 8)\n    5.0\n    \"\"\"\n    return 0.5 * math.sqrt(diagonal1**2 + diagonal2**2)"], ["def area_of_right_triangle(base, height):\n    \"\"\"\n    Calculate the area of a right triangle given its base and height.\n    \n    Parameters:\n    - base (float): The length of the base of the right triangle.\n    - height (float): The height of the right triangle.\n    \n    Returns:\n    - float: The area of the right triangle.\n    \n    Examples:\n    >>> area_of_right_triangle(3, 4)\n    6.0\n    \"\"\"\n    return 0.5 * base * height", "def area_triangle(base, height):\n    \"\"\"\n    Calculates the area of a triangle given its base and height.\n    Parameters:\n    - base (float): length of the base of the triangle.\n    - height (float): height of the triangle from the base.\n    \n    Returns:\n    - float: the area of the triangle.\n    Examples:\n    >>> area_triangle(5, 4)\n    10.0\n    \"\"\"\n    return 0.5 * base * height"], ["def apply_law_of_cosines(a, b, angle_c):\n    \"\"\"\n    Apply the Law of Cosines to calculate the third side of a triangle, given two sides and the included angle.\n    Parameters:\n    - a (float): Length of the first side of the triangle.\n    - b (float): Length of the second side of the triangle.\n    - angle_c (float): The angle between sides a and b in degrees.\n    \n    Returns:\n    - float: The length of the third side of the triangle.\n    \n    Examples:\n    >>> apply_law_of_cosines(5, 6, 60)\n    4.084\n    \"\"\"\n    angle_c_rad = math.radians(angle_c)\n    c = math.sqrt(a**2 + b**2 - 2 * a * b * math.cos(angle_c_rad))\n    return c", "def calculate_triangle_angle(a, b, c):\n    \"\"\"\n    Calculate angles of a triangle given the sides using the Law of Cosines.\n    \n    Parameters:\n    - a, b, c (float): Lengths of the sides of the triangle.\n    \n    Returns:\n    - tuple: The angles of the triangle in degrees.\n    \n    Examples:\n    >>> calculate_triangle_angle(5, 5, 6)\n    (53.13, 53.13, 73.74)\n    \"\"\"\n    angle_A = math.degrees(math.acos((b**2 + c**2 - a**2) / (2 * b * c)))\n    angle_B = math.degrees(math.acos((a**2 + c**2 - b**2) / (2 * a * c)))\n    angle_C = math.degrees(math.acos((a**2 + b**2 - c**2) / (2 * a * b)))\n    return (angle_A, angle_B, angle_C)", "def law_of_cosines(a, b, c, angle=None, requesting_side=False):\n    \"\"\"\n    Uses the Law of Cosines to find a side or an angle of a triangle.\n    Parameters:\n    - a (float): length of side a.\n    - b (float): length of side b.\n    - c (float, optional if requesting side): length of side c when calculating angle.\n    - angle (float, optional if requesting angle): angle opposite side c in degrees when calculating side.\n    - requesting_side (bool): if True, calculates the side. If False, calculates the angle.\n    \n    Returns:\n    - float: either the calculated side length or angle in degrees.\n    Examples:\n    >>> law_of_cosines(3, 4, 5)\n    90.0\n    >>> law_of_cosines(3, 4, 5, requesting_side=True)\n    5.0\n    \"\"\"\n    if requesting_side:\n        # Calculate length of side c when a, b, and angle are given\n        return math.sqrt(a**2 + b**2 - 2 * a * b * math.cos(math.radians(angle)))\n    else:\n        # Calculate angle opposite side c when a, b, and c are given\n        return math.degrees(math.acos((a**2 + b**2 - c**2) / (2 * a * b)))"], ["def parallelogram_angle_solver(*angles):\n    \"\"\"\n    Computes the missing angle(s) in a parallelogram given some known angles, or determines if given angles can form a parallelogram.\n    Parameters:\n    -----------\n    angles : tuple\n        A collection of values and None types, where values are known angles in degrees and None represents unknown angles. \n        There should be exactly four elements.\n    Returns:\n    --------\n    tuple\n        A tuple where:\n        - The first element is a boolean indicating if the angles can form a parallelogram.\n        - The second element is a list of angles of the parallelogram, with solved values where possible.\n        \n    Examples:\n    ---------\n    >>> parallelogram_angle_solver(70, 110, None, None)\n    (True, [70, 110, 70, 110])\n    \n    >>> parallelogram_angle_solver(70, None, 70, None)\n    (True, [70, 110, 70, 110])\n    \n    >>> parallelogram_angle_solver(70, 80, 70, 80)\n    (False, [70, 80, 70, 80])\n    \"\"\"\n    import sympy as sp\n    # Create symbols for unknown angles\n    symbols = [sp.symbols(f'angle_{i}') if a is None else a for i, a in enumerate(angles)]\n    \n    # Constraints from properties of a parallelogram:\n    # Opposite angles equal and sum of adjacent angles is 180 \n    equations = [\n        symbols[0] - symbols[2],\n        symbols[1] - symbols[3],\n        symbols[0] + symbols[1] - 180\n    ]\n    \n    # Solve the equations\n    sol = sp.solve(equations, dict=True)\n    if sol:\n        # If solutions exist, substitute them back to calculate all angles\n        solved_angles = [angle.subs(sol[0]) for angle in symbols]\n        return (True, [float(a) for a in solved_angles])\n    else:\n        # No solution means it cannot be a parallelogram with these properties\n        return (False, list(angles))"], ["def quadrilateral_properties_calculations(quadrilateral_type, *sides):\n    \"\"\"\n    Calculate properties like area, perimeter, and specific checks for types of quadrilaterals.\n    \n    Parameters:\n        quadrilateral_type (str): Type of the quadrilateral ['rectangle', 'rhombus', 'isosceles_trapezoid', 'general_quadrilateral']\n        *sides (float): Varies based on the type. For 'rectangle' and 'rhombus', only two are needed as they are symmetrical. \n                        For 'isosceles_trapezoid' and 'general_quadrilateral', all four sides should be provided.\n    \n    Returns:\n        dict: returns a dictionary containing properties like area, perimeter and specific type properties if any.\n    \n    Example:\n        >>> print(quadrilateral_properties_calculations('rectangle', 5, 10))\n        {'area': 50, 'perimeter': 30, 'is_square': False}\n    \"\"\"\n    import math\n    \n    result = {}\n    if quadrilateral_type in ['rectangle', 'rhombus']:\n        area = sides[0] * sides[1]\n        perimeter = 2 * (sides[0] + sides[1])\n        result['area'] = area\n        result['perimeter'] = perimeter\n        if quadrilateral_type == 'rectangle':\n            result['is_square'] = sides[0] == sides[1]\n        elif quadrilateral_type == 'rhombus':\n            result['diagonal_u'] = math.sqrt(2) * sides[0]\n            result['diagonal_v'] = math.sqrt(2) * sides[1]\n    elif quadrilateral_type == 'isosceles_trapezoid':\n        a, b, c, d = sides  # a, d are bases; b, c are legs\n        # More complex calculations like area using trapezoid formula\n    else:\n        # Calculate using general formulas, possibly Brahmagupta's formula for area of a general quadrilateral\n        pass\n    \n    return result"], ["def check_opposite_angles_equality(angle_a, angle_b, angle_c, angle_d):\n    \"\"\"\n    Verify if opposite angles in a given quadlilateral are equal - a property of parallelograms.\n    Parameters:\n    - angle_a (Expr): Symbolic expression for angle A (one vertex angle of a quadrilateral).\n    - angle_b (Expr): Symbolic expression for angle B (adjacent to angle A).\n    - angle_c (Expr): Symbolic expression for angle C (opposite to angle A).\n    - angle_d (Expr): Symbolic expression for angle D (adjunct to angle C).\n    Returns:\n    - bool: True if opposite angles are equal (angle A equals angle C and angle B equals angle D); False otherwise.\n    Examples:\n    >>> from sympy import symbols, pi\n    >>> A, B, C, D = symbols('A B C D')\n    >>> check_opposite_angles_equality(A, B, A, B)\n    True\n    >>> check_opposite_angles_equality(pi/2, pi/3, pi/2, pi/3)\n    True\n    >>> check_opposite_angles_equality(90, 45, 89, 44)\n    False\n    \"\"\"\n    # Check for equality in both pairs of opposite angles\n    opposite_angles_equal = Eq(angle_a, angle_c) and Eq(angle_b, angle_d)\n    # Return boolean evaluation of the equality expressions\n    return solve(opposite_angles_equal)", "def check_adjacent_angles_supplementary(angle_a, angle_b, angle_c, angle_d):\n    \"\"\"\n    Check if each pair of adjacent angles in a quadrilateral are supplementary - a property of parallelograms.\n    Parameters:\n    - angle_a (Expr): Symbolic expression for angle A (one vertex angle of a quadrilateral).\n    - angle_b (Expr): Symbolic expression for angle B (adjacent to angle A).\n    - angle_c (Expr): Symbolic expression for angle C (adjacent to angle B and opposite to angle A).\n    - angle_d (Expr): Symbolic expression for angle D (adjacent to angle C and opposite to angle B).\n    Returns:\n    - bool: True if each pair of adjacent angles are supplementary; False otherwise.\n    Examples:\n    >>> from sympy import symbols, pi\n    >>> A, B, C, D = symbols('A B C D')\n    >>> check_adjacent_angles_supplementary(pi/2, pi/2, pi/2, pi/2)\n    True\n    >>> check_adjacent_angles_supplementary(90, 90, 90, 90)\n    True\n    >>> check_adjacent_angles_supplementary(90, 80, 100, 90)\n    False\n    \"\"\"\n    # Check for supplementary conditions for each pair of adjacent angles\n    adjacent_supplements = (Eq(angle_a + angle_b, pi) and\n                            Eq(angle_b + angle_c, pi) and\n                            Eq(angle_c + angle_d, pi) and\n                            Eq(angle_d + angle_a, pi))\n    # Return boolean evaluation of these expressions\n    return solve(adjacent_supplements)"], ["def pythagorean_theorem(a=None, b=None, c=None):\n    \"\"\"\n    Given any two sides of a right triangle, calculate the third side using the Pythagorean Theorem.\n    Parameters:\n    - a (float, optional): one leg of the right triangle.\n    - b (float, optional): the other leg of the right triangle.\n    - c (float, optional): the hypotenuse of the right triangle.\n    \n    Returns:\n    - float: the length of the missing side.\n    Examples:\n    >>> pythagorean_theorem(a=3, b=4)\n    5.0\n    >>> pythagorean_theorem(c=5, b=4)\n    3.0\n    \"\"\"\n    if a is None:\n        return math.sqrt(c**2 - b**2)\n    elif b is None:\n        return math.sqrt(c**2 - a**2)\n    elif c is None:\n        return math.sqrt(a**2 + b**2)\n    else:\n        return None"], ["def triangle_calculations_in_quadrilaterals(side_lengths, angle=None, use_pythagoras=False):\n    \"\"\"\n    Function that facilitates triangle calculations such as angle calculations using the law of cosines or using the Pythagorean theorem in specific triangles within quadrilaterals.\n    \n    Parameters:\n        side_lengths (tuple[float]): The lengths of the sides of the triangle.\n        angle (float, optional): The angle for which the law of cosines is to be applied. Provided in radians if used.\n        use_pythagoras (bool): Whether to use the Pythagorean Theorem.\n    \n    Returns:\n        float: The calculated value based on given parameters (could be side length or angle).\n    \n    Example:\n        >>> triangle_calculations_in_quadrilaterals((3, 4, 5), use_pythagoras=True)\n        {'is_right_triangle': True, 'missing_side': 5}\n    \"\"\"\n    import math\n    \n    a, b, c = side_lengths\n    if use_pythagoras and angle is None:\n        # Assume right triangle; check if condition holds\n        return {'is_right_triangle': math.isclose(a**2 + b**2, c**2), 'missing_side': math.sqrt(a**2 + b**2)}\n    elif angle:\n        # Use the law of cosines: c^2 = a^2 + b^2 - 2ab*cos(C)\n        return math.sqrt(a**2 + b**2 - 2*a*b*math.cos(angle))\n    return None"], ["def verify_parallelogram_angles(angle_A, angle_B, angle_C, angle_D):\n    \"\"\"\n    Verify whether four given angles can form a parallelogram based on the properties:\n    - Opposite angles are equal.\n    - Adjacent angles are supplementary (sum to 180 degrees).\n    \n    Parameters:\n        angle_A (int/float/sympy.Expr): Angle at vertex A (degrees)\n        angle_B (int/float/sympy.Expr): Angle at vertex B (degrees)\n        angle_C (int/float/sympy.Expr): Angle at vertex C (degrees)\n        angle_D (int/float/sympy.Expr): Angle at vertex D (degrees)\n        \n    Returns:\n        bool: True if the angles can form a parallelogram, False otherwise.\n    \n    Examples:\n        >>> verify_parallelogram_angles(70, 110, 70, 110)\n        True\n        >>> verify_parallelogram_angles(70, 100, 70, 100)\n        False  # This would be false because adjacent angles 70 and 100 do not sum to 180\n    \"\"\"\n    # Checking opposite angles\n    opposite_equal = (angle_A == angle_C) and (angle_B == angle_D)\n    \n    # Checking adjacent angles\n    adjacent_supplementary = (angle_A + angle_B == 180) and (angle_C + angle_D == 180)\n    \n    return opposite_equal and adjacent_supplementary"], ["def calculate_missing_angles(angle_A=None, angle_B=None, angle_C=None, angle_D=None):\n    \"\"\"\n    Given some angles of a quadrilateral that is known or assumed to be a parallelogram, calculate the missing angles.\n    \n    Parameters:\n        angle_A (int/float/sympy.Expr, optional): Angle at vertex A (degrees)\n        angle_B (int/float/sympy.Expr, optional): Angle at vertex B (degrees)\n        angle_C (int/float/sympy.Expr, optional): Angle at vertex C (degrees)\n        angle_D (int/float/sympy.Expr, optional): Angle at vertex D (degrees)\n    \n    Returns:\n        tuple: A tuple containing the solved angles in the order (angle_A, angle_B, angle_C, angle_D)\n    \n    Examples:\n        >>> calculate_missing_angles(angle_A=70, angle_C=70)\n        (70, 110, 70, 110)\n    \"\"\"\n    # Create symbolic representations for unknown angles\n    if angle_A is None:\n        angle_A = symbols('angle_A')\n    if angle_B is None:\n        angle_B = symbols('angle_B')\n    if angle_C is None:\n        angle_C = symbols('angle_C')\n    if angle_D is None:\n        angle_D = symbols('angle_D')\n    \n    # Set up equations based on parallelogram properties\n    eq1 = Eq(angle_A + angle_B, 180)\n    eq2 = Eq(angle_C + angle_D, 180)\n    eq3 = Eq(angle_A, angle_C)\n    eq4 = Eq(angle_B, angle_D)\n    \n    # Solve the equations\n    solutions = solve((eq1, eq2, eq3, eq4), (angle_A, angle_B, angle_C, angle_D))\n    \n    return (solutions[angle_A], solutions[angle_B], solutions[angle_C], solutions[angle_D])"]], "Ellipse": [["def ellipse_standard_to_general(h, k, a, b):\n    \"\"\"\n    Convert the standard equation of an ellipse to its general form.\n    Parameters:\n        h (float): The x-coordinate of the ellipse's center.\n        k (float): The y-coordinate of the ellipse's center.\n        a (float): Length of the semi-major axis.\n        b (float): Length of the semi-minor axis.\n    Returns:\n        sympy expression: The general form of the ellipse equation.\n    Examples:\n        >>> ellipse_standard_to_general(1, 2, 5, 3)\n        Eq(x**2/25 - x*2/5 + y**2/9 - y*4/9 + 5, 0)\n    \"\"\"\n    x, y = sp.symbols('x y')\n    eq = (x - h)**2/a**2 + (y - k)**2/b**2 - 1\n    return sp.simplify(eq)", "def generate_ellipse_equation(h, k, a, b):\n    \"\"\"\n    Generate the standard equation of an ellipse.\n    Parameters:\n    h (float): x-coordinate of the ellipse center.\n    k (float): y-coordinate of the ellipse center.\n    a (float): semi-major axis of the ellipse.\n    b (float): semi-minor axis of the ellipse.\n    Returns:\n    str: The equation of the ellipse in standard form.\n    Example:\n    >>> generate_ellipse_equation(0, 0, 5, 3)\n    '(x - 0)^2/25 + (y - 0)^2/9 = 1'\n    \"\"\"\n    return f\"(x - {h})^2/{a**2} + (y - {k})^2/{b**2} = 1\""], ["def ellipse_properties(center, a, b):\n    \"\"\"\n    Calculate properties of an ellipse given its center, semi-major axis (a),\n    and semi-minor axis (b).\n    Parameters:\n        center (tuple): The (x, y) coordinates of the ellipse's center.\n        a (float): Length of the semi-major axis.\n        b (float): Length of the semi-minor axis.\n    Returns:\n        dict: A dictionary containing properties of the ellipse such as foci,\n        area, and the standard equation.\n    Examples:\n        >>> ellipse_properties((0, 0), 5, 3)\n        {'center': (0, 0), 'semi-major': 5, 'semi-minor': 3,\n         'foci': ((-4.0, 0), (4.0, 0)), 'area': 47.12388980384689,\n         'equation': 'x^2/25 + y^2/9 = 1'}\n    \"\"\"\n    h, k = center\n    c = math.sqrt(a**2 - b**2)  # Distance from center to each focus\n    foci = ((h - c, k), (h + c, k))\n    area = math.pi * a * b\n    equation = f\"x^2/{a**2} + y^2/{b**2} = 1\"\n    return {\n        'center': center,\n        'semi-major': a,\n        'semi-minor': b,\n        'foci': foci,\n        'area': area,\n        'equation': equation\n    }", "def calculate_ellipse_properties(a, b):\n    \"\"\"\n    Calculate properties of an ellipse given its semi-major axis (a) and semi-minor axis (b).\n    \n    Parameters:\n    a : float\n        The length of the semi-major axis of the ellipse.\n    b : float\n        The length of the semi-minor axis of the ellipse.\n    \n    Returns:\n    dict\n        A dictionary with properties of the ellipse:\n        - area: The area of the ellipse.\n        - perimeter_approx: An approximation of the perimeter (Ramanujan's approximation).\n        - foci_distance: The distance between the foci of the ellipse.\n    \n    Examples:\n    >>> calculate_ellipse_properties(5, 3)\n    {'area': 47.12388980384689, 'perimeter_approx': 25.70820619304403, 'foci_distance': 8.0}\n    \"\"\"\n    area = math.pi * a * b\n    h = ( ((a - b)**2) / ((a + b)**2) )\n    perimeter_approx = math.pi * (a + b) * (1 + 3*h/(10 + math.sqrt(4 - 3*h)))\n    foci_distance = 2 * math.sqrt(a**2 - b**2)\n    \n    return {\n        \"area\": area,\n        \"perimeter_approx\": perimeter_approx,\n        \"foci_distance\": foci_distance\n    }", "def ellipse_properties(a, b):\n    \"\"\"\n    Calculate properties of an ellipse given the lengths of its semi-major (a) and semi-minor (b) axes.\n    Parameters:\n    a (float): length of the semi-major axis.\n    b (float): length of the semi-minor axis.\n    Returns:\n    dict: A dictionary containing the following keys:\n        'focal_length': the distance from the center to each focus (c),\n        'eccentricity': eccentricity of the ellipse (e),\n        'perimeter_approx': approximate perimeter of the ellipse using Ramanujan's second approximation\n        \n    Example:\n    >>> ellipse_properties(5, 3)\n    {'focal_length': 4.0, 'eccentricity': 0.8, 'perimeter_approx': 25.132741228718345}\n    \"\"\"\n    c = math.sqrt(a**2 - b**2)\n    e = c / float(a)\n    h = 3 * ((a-b)**2) / ((a+b)**2)\n    perimeter = math.pi * (a + b) * (\n        1 + (h / (10 + math.sqrt(4-h)))\n    )\n    return {\n        'focal_length': c,\n        'eccentricity': e,\n        'perimeter_approx': perimeter\n    }"], ["def ellipse_area(a, b):\n    \"\"\"\n    Calculate the area of an ellipse given the lengths of its semi-major and semi-minor axes.\n    \n    Parameters:\n    a (float): length of the semi-major axis.\n    b (float): length of the semi-minor axis.\n    Returns:\n    float: Area of the ellipse.\n    Example:\n    >>> ellipse_area(5, 3)\n    47.12388980384689\n    \"\"\"\n    return math.pi * a * b"], ["def ellipse_standard_form(coordinates, a, b, angle=0):\n    \"\"\"\n    Represents the equation of an ellipse in its standard form based on provided parameters.\n    \n    Parameters:\n    coordinates : tuple\n        The (x, y) coordinates of the center of the ellipse.\n    a : float\n        The length of the semi-major axis.\n    b : float\n        The length of the semi-minor axis.\n    angle : float, optional\n        The rotation angle of the ellipse in degrees (default is 0).\n    Returns:\n    str\n        A string representing the standard form equation of the ellipse.\n    Examples:\n    >>> ellipse_standard_form((0, 0), 5, 3)\n    'x^2/25 + y^2/9 = 1'\n    >>> ellipse_standard_form((0, 0), 5, 3, 45)\n    'Rotated by 45 degrees: Standard equation not directly applicable.'\n    \"\"\"\n    if angle != 0:\n        return f\"Rotated by {angle} degrees: Standard equation not directly applicable.\"\n    h, k = coordinates\n    equation = f\"(x-{h})^2/{a**2} + (y-{k})^2/{b**2} = 1\"\n    return equation"]]}