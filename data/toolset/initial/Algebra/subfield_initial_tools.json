{
    "Quadratic Equations": [
        "def solve_quadratic_equation(a, b, c):\n    \"\"\"\n    Solve the quadratic equation ax^2 + bx + c = 0 using the quadratic formula.\n    Parameters:\n        a (float): Coefficient of x^2\n        b (float): Coefficient of x\n        c (float): Constant term\n    Returns:\n        tuple: Roots of the quadratic equation, which can be real or complex.\n    \n    Example:\n        >>> solve_quadratic_equation(1, -3, 2)\n        (2.0, 1.0)\n        >>> solve_quadratic_equation(1, 0, 1)\n        ((1j), (-1j))\n    \"\"\"\n    # Calculate the discriminant\n    discriminant = b**2 - 4 * a * c\n    \n    # Compute the two roots\n    root1 = (-b + np.sqrt(discriminant)) / (2 * a)\n    root2 = (-b - np.sqrt(discriminant)) / (2 * a)\n    \n    return (root1, root2)",
        "def vietas_formulas_from_coefficients(a, b, c):\n    \"\"\"\n    Compute the sum and product of the roots of the quadratic equation ax^2 + bx + c = 0 using Vieta's formulas.\n    \n    Parameters:\n        a (float): Coefficient of x^2\n        b (float): Coefficient of x\n        c (float): Constant term\n    Returns:\n        tuple: Sum and product of the roots.\n    \n    Examples:\n        >>> vietas_formulas_from_coefficients(1, -3, 2)\n        (3.0, 2.0)\n        >>> vietas_formulas_from_coefficients(1, 4, 4)\n        (-4.0, 4.0)\n    \"\"\"\n    sum_of_roots = -b / a\n    product_of_roots = c / a\n    \n    return (sum_of_roots, product_of_roots)",
        "def quadratic_to_vertex_form(a, b, c):\n    \"\"\"\n    Convert a quadratic equation from standard form (ax^2 + bx + c)\n    to vertex form (a(x-h)^2 + k).\n    Parameters\n    ----------\n    a : float\n        Coefficient of x^2.\n    b : float\n        Coefficient of x.\n    c : float\n        Constant term.\n    Returns\n    -------\n    tuple\n        A tuple (a, h, k) representing the vertex form of the equation.\n    Examples\n    --------\n    >>> quadratic_to_vertex_form(1, -6, 8)\n    (1, 3, -1)\n    \"\"\"\n    h = -b / (2*a)\n    k = c - b**2 / (4*a)\n    return (a, h, k)",
        "def form_quadratic_from_roots(root1, root2):\n    \"\"\"\n    Formulate a quadratic equation given two roots.\n    Parameters:\n    root1 (float or complex): First root\n    root2 (float or complex): Second root\n    Returns:\n    tuple: Coefficients of the quadratic equation (a, b, c) in the form ax^2 + bx + c = 0\n    Example:\n    >>> form_quadratic_from_roots(1, 2)\n    (1, -3, 2)\n    \"\"\"\n    a = 1\n    b = -(root1 + root2)\n    c = root1 * root2\n    return (a, b, c)",
        "def discriminant_analysis(discriminant):\n    \"\"\"\n    Provides an analysis of the discriminant to determine the nature of the roots of the quadratic equation.\n    Parameters:\n    discriminant (float): The discriminant value.\n    Returns:\n    str: Description of the nature of the roots based on the discriminant.\n    Examples:\n    >>> discriminant_analysis(1)\n    'Two distinct real roots'\n    >>> discriminant_analysis(0)\n    'One repeated real root'\n    >>> discriminant_analysis(-4)\n    'Two complex roots'\n    \"\"\"\n    if discriminant > 0:\n        return \"Two distinct real roots\"\n    elif discriminant == 0:\n        return \"One repeated real root\"\n    else:\n        return \"Two complex roots\""
    ],
    "Linear Equations": [
        "def parallel_slope(slope1, slope2):\n    \"\"\"\n    Determine if two lines with given slopes are parallel.\n    Parameters:\n    slope1, slope2 (float): Slopes of the two lines.\n    Returns:\n    bool: True if the lines are parallel, otherwise False.\n    Examples:\n    >>> parallel_slope(2, 2)\n    True\n    \"\"\"\n    return slope1 == slope2",
        "def calculate_slope(x1, y1, x2, y2):\n    \"\"\"\n    Calculate the slope of a line that passes through two points (x1, y1) and (x2, y2).\n    Parameters:\n    x1, y1 (float): Coordinates of the first point.\n    x2, y2 (float): Coordinates of the second point.\n    Returns:\n    float: The slope of the line.\n    Examples:\n    >>> calculate_slope(1, 2, 3, 8)\n    3.0\n    \"\"\"\n    if x1 == x2:\n        raise ValueError(\"Division by zero error: x1 and x2 cannot be the same for slope calculation.\")\n    return (y2 - y1) / (x2 - x1)",
        "def find_intercepts(slope, intercept):\n    \"\"\"\n    Calculate the x-intercept and y-intercept of a line given its slope and y-intercept.\n    Parameters:\n        slope (float): Slope of the line.\n        intercept (float): y-intercept of the line.\n    Returns:\n        tuple: x-intercept and y-intercept as floats.\n    \n    Example:\n        >>> find_intercepts(1, 0)\n        (0.0, 0.0)\n    \"\"\"\n    x_intercept = -intercept / slope if slope != 0 else np.inf\n    y_intercept = intercept\n    return x_intercept, y_intercept",
        "def is_point_on_line(x, y, slope, intercept):\n    \"\"\"\n    Check if a given point (x, y) lies on the line defined by the slope and intercept.\n    Parameters:\n    x, y (float): Coordinates of the point.\n    slope (float): Slope of the line.\n    intercept (float): Y-intercept of the line.\n    Returns:\n    bool: True if the point lies on the line, otherwise False.\n    Examples:\n    >>> is_point_on_line(3, 7, 2, 1)\n    True\n    \"\"\"\n    return y == slope * x + intercept",
        "def point_slope_form(x1, y1, slope):\n    \"\"\"\n    Return the point-slope form of the equation of the line given a point and a slope.\n    Parameters:\n    x1, y1 (float): Coordinates of the point through which the line passes.\n    slope (float): Slope of the line.\n    Returns:\n    str: The point-slope form of the line equation.\n    Examples:\n    >>> point_slope_form(2, 3, 2)\n    'y - 3 = 2(x - 2)'\n    \"\"\"\n    return f\"y - {y1} = {slope}(x - {x1})\"",
        "def solve_single_variable_linear_equation(coefficient, constant):\n    \"\"\"\n    Solves a single variable linear equation of the form ax + b = 0.\n    Parameters:\n    coefficient (number): The coefficient of the variable x in the equation (a in ax + b = 0).\n    constant (number): The constant term in the equation (b in ax + b = 0).\n    Returns:\n    float or None: The solution to the equation, or None if no solution exists.\n    Examples:\n    >>> solve_single_variable_linear_equation(5, 10)\n    -2.0\n    >>> solve_single_variable_linear_equation(0, 5)\n    None  # This would represent an equation with no solution when 0*x + 5 = 0\n    \"\"\"\n    x = sp.symbols('x')\n    equation = sp.Eq(coefficient * x + constant, 0)\n    solution = sp.solve(equation, x)\n    return solution[0] if solution else None"
    ],
    "Functions": [
        "def simplify_expression(expression):\n    \"\"\"\n    Simplifies an algebraic expression.\n    \n    Parameters:\n        expression (str): The algebraic expression in string format.\n    \n    Returns:\n        Expr: A simplified Sympy expression.\n        \n    Example:\n        >>> simplify_expression('2*x + 3*x - 5')\n        5*x - 5\n    \"\"\"\n    expr = sympify(expression)\n    return simplify(expr)",
        "def evaluate_function(expression, **kwargs):\n    \"\"\"\n    Evaluates a given function expression at the specified values of its variables.\n    \n    Parameters:\n    - expression (str): The function expression in Python-syntax string format.\n    - kwargs (dict): Keyword argument pairs where variables are the keys, and the values are the numeric values where the function needs to be evaluated.\n    \n    Returns:\n    - The evaluated result of the function.\n    \n    Example:\n    >>> evaluate_function('x**2 + 3*x + 1', x=2)\n    11\n    \"\"\"\n    expr = sympify(expression)  # Converts string expression into a sympy expression\n    variables = symbols(','.join(kwargs.keys()))\n    func = lambdify(variables, expr, modules=['numpy'])\n    return func(*kwargs.values())",
        "def solve_inverse_proportionality(x, y, k):\n    \"\"\"\n    Solves equations based on inverse proportionality, where x * y = k.\n    Parameters:\n    x (float or None): Known or unknown (None) value of x.\n    y (float or None): Known or unknown (None) value of y.\n    k (float): Constant value of the product of `x` and `y`.\n    Returns:\n    float: The unknown value of x or y, whichever is needed.\n    Examples:\n    >>> solve_inverse_proportionality(None, 5, 20)\n    4.0\n    >>> solve_inverse_proportionality(4, None, 20)\n    5.0\n    \"\"\"\n    if x is None and y is not None:\n        return k / y\n    elif y is None and x is not None:\n        return k / x\n    else:\n        raise ValueError(\"One of x or y must be None to solve for the other.\")",
        "def get_polynomial_roots(expression):\n    \"\"\"\n    Returns the roots of the polynomial.\n    \n    Parameters:\n        expression (str): The polynomial expression in string format.\n    \n    Returns:\n        list: The roots of the polynomial.\n        \n    Example:\n        >>> get_polynomial_roots('x^2 - 5*x + 6')\n        {x: 2, x: 3}\n    \"\"\"\n    expr = poly(expression)\n    return roots(expr)",
        "def plot_function(f, var_range, title=\"Function Plot\"):\n    \"\"\"\n    Plots a given symbolic function over a specified range.\n    \n    Parameters:\n    - f (sympy Expression): The function to plot, in terms of a symbolic variable.\n    - var_range (tuple): A tuple (symbol, start, end) defining the variable and range over which to plot.\n    - title (str): The title of the plot.\n    \n    Example:\n    >>> x = sp.symbols('x')\n    >>> plot_function(x**2, (x, -10, 10))\n    \"\"\"\n    x, start, end = var_range\n    sp.plot(f, (x, start, end), title=title, xlabel=str(x), ylabel='f(x)')",
        "def function_compose(f, g, x):\n    \"\"\"\n    Returns the composition of two functions, f(g(x)).\n    Parameters:\n    - f, g (sympy expressions): Functions to compose.\n    - x (sympy Symbol): Input variable for the functions.\n    Returns:\n    - composition (sympy expression): Result of the composition f(g(x)).\n    \n    Example:\n    >>> x = sp.symbols('x')\n    >>> f = x**2\n    >>> g = 2*x + 1\n    >>> function_compose(f, g, x)\n    \"\"\"\n    return f.subs(x, g)",
        "def ProportionalityTool(a, b, k=None, relationship='inverse'):\n    \"\"\"\n    Analyze or solve problems involving direct or inverse proportionality between two variables.\n    \n    Parameters:\n        a (sympy expression or float): First variable or its value.\n        b (sympy expression or float): Second variable or its value.\n        k (float, optional): Constant of proportionality if known.\n        relationship (str): Type of relationship ('direct' or 'inverse')\n    \n    Returns:\n        sympy expression or float: Result based on the inputs which could be relation expression or value of one variable.\n    \n    Examples:\n        >>> a, b = sp.symbols('a b')\n        >>> ProportionalityTool(a, b, 5, 'inverse')\n        a*b = 5\n        \n        >>> ProportionalityTool(15, b, 3, 'direct')\n        b = 5.0\n    \"\"\"\n    if relationship == 'inverse':\n        if k is not None:\n            return sp.Eq(a * b, k)\n        else:\n            try:\n                if isinstance(a, sp.Symbol):\n                    return solve(sp.Eq(a * b, k), a)\n                else:\n                    return solve(sp.Eq(a * b, k), b)\n            except:\n                raise ValueError(\"Sufficient information not provided.\")\n    elif relationship == 'direct':\n        if k is not None:\n            return sp.Eq(a / b, k)\n        else:\n            try:\n                if isinstance(a, sp.Symbol):\n                    return solve(sp.Eq(a / b, k), a)\n                else:\n                    return solve(sp.Eq(a / b, k), b)\n            except:\n                raise ValueError(\"Sufficient information not provided.\")",
        "def check_function_parity(expression, variable=None):\n    \"\"\"\n    Determine and return whether a function is even, odd, or neither.\n    Parameters:\n    expression (str or sympy expression): The function expression as a string or sympy expression.\n    variable (sympy.Symbol, optional): The main variable of the function. If not provided, determined automatically.\n    Returns:\n    str: 'even', 'odd', or 'neither'\n    Examples:\n        >>> check_function_parity(\"x**2\", sp.symbols('x'))\n        'even'\n        >>> check_function_parity(\"x**3\", sp.symbols('x'))\n        'odd'\n    \"\"\"\n    x = sp.symbols('x') if variable is None else variable\n    expr = sp.sympify(expression)\n    if expr.subs(x, -x) == expr:\n        return \"even\"\n    elif expr.subs(x, -x) == -expr:\n        return \"odd\"\n    else:\n        return \"neither\"",
        "def polynomial_discriminant(coefficients):\n    \"\"\"\n    Calculate the discriminant of a polynomial. For a quadratic ax^2 + bx + c, it is b^2 - 4ac.\n    \n    Parameters:\n    - coefficients (list of float): Coefficients of the polynomial [a, b, c].\n    \n    Returns:\n    - discriminant (float): The discriminant of the polynomial.\n    \n    Example:\n    >>> polynomial_discriminant([1, 0, -1])\n    4\n    \"\"\"\n    if len(coefficients) != 3:\n        raise ValueError(\"Discriminant calculation is currently only implemented for quadratic polynomials.\")\n    a, b, c = coefficients\n    return b**2 - 4*a*c",
        "def function_domain(func, args_range):\n    \"\"\"\n    Identify the domain of the function by checking where it is defined or undefined within a given range.\n    \n    Parameters:\n    - func (callable): Function to analyze.\n    - args_range (tuple): A tuple (start, end, points) defining the range to test the function.\n    \n    Returns:\n    - domain (list): List of points where function is defined.\n    \n    Example:\n    >>> function_domain(lambda x: 1/x, (-10, 10, 1000))\n    Contains domain excluding x=0 within the specified range.\n    \"\"\"\n    import numpy as np\n    start, end, points = args_range\n    x_values = np.linspace(start, end, points)\n    domain = []\n    for x in x_values:\n        try:\n            func(x)\n            domain.append(x)\n        except Exception:\n            continue  # Skip values where function is undefined\n    return domain",
        "def evaluate_polynomial(expression, value_dict):\n    \"\"\"\n    Evaluates a polynomial at given variable values.\n    \n    Parameters:\n        expression (str): The polynomial expression in string format.\n        value_dict (dict): A dictionary of variable values.\n    \n    Returns:\n        Expr: The result of the polynomial evaluation.\n        \n    Example:\n        >>> evaluate_polynomial('x^2 + 2*x + 1', {'x': 2})\n        9\n    \"\"\"\n    expr = poly(expression)\n    result = expr.eval(value_dict)\n    return result",
        "def evaluate_function(func, x):\n    \"\"\"\n    Evaluates a general function for a given x value.\n    \n    Parameters:\n    - func (callable): A Python callable that represents a mathematical function.\n    - x (float or list): An input value(s) for the function.\n    \n    Returns:\n    - result (float or list): The result of applying the function to x.\n    \n    Example:\n    >>> evaluate_function(lambda x: x**2 + 2*x + 1, 3)\n    16\n    \"\"\"\n    return func(x)",
        "def simplify_expression(expression: str):\n    \"\"\"\n    Simplifies a mathematical expression.\n    \n    Parameters\n    ----------\n    expression : str\n        A mathematical expression represented as a string.\n    \n    Returns\n    -------\n    simplified_expression : str\n        The simplified version of the mathematical expression.\n        \n    Examples\n    --------\n    >>> simplify_expression('3*(2+3)')\n    '15'\n    >>> simplify_expression('(3+2)*2')\n    '10'\n    \"\"\"\n    parsed_expression = sympify(expression)\n    simplified_expression = simplify(parsed_expression)\n    return str(simplified_expression)",
        "def solve_functional_equation(f, x, conditions=None):\n    \"\"\"\n    Solves a functional equation given the function and conditions.\n    \n    Parameters:\n    - f (sympy expression): The functional equation f(x).\n    - x (sympy Symbol): The main variable.\n    - conditions (list of sympy expressions): Additional conditions or specific cases.\n    \n    Returns:\n    - solutions (sympy set): Solutions of the functional equation.\n    \n    Example:\n    >>> x = sp.symbols('x')\n    >>> solve_functional_equation(x**2 - x - 6, x)\n    \"\"\"\n    base_solution = sp.solveset(f, x, domain=sp.S.Reals)\n    if conditions:\n        return [sol for sol in base_solution if all(cond.subs(x, sol) for cond in conditions)]\n    return base_solution",
        "def evaluate_expression(expression: str):\n    \"\"\"\n    Evaluates a mathematical expression.\n    \n    Parameters\n    ----------\n    expression : str\n        A mathematical expression represented as a string.\n    \n    Returns\n    -------\n    result : number\n        The evaluated result of the mathematical expression.\n        \n    Examples\n    --------\n    >>> evaluate_expression('3+2*2')\n    7.0\n    >>> evaluate_expression('4*2+3')\n    11.0\n    \"\"\"\n    parsed_expression = sympify(expression)\n    result = parsed_expression.evalf()\n    return result",
        "def substitute_in_expression(expr, var, value):\n    \"\"\"\n    Substitutes a value into the given variable in an expression.\n    Parameters:\n    expr (str): The expression.\n    var (str): The variable in the expression.\n    value (numeric or str): Value to substitute into the variable.\n    Returns:\n    numerical or sympy.Expr: Result after substitution.\n    \n    Examples:\n    >>> substitute_in_expression('x**2 + 2*x + 1', 'x', 3)\n    16\n    \"\"\"\n    expression = sympify(expr)\n    return expression.subs(var, value)",
        "def function_composition(f_expr, g_expr, var):\n    \"\"\"\n    Composes two functions f(g(x)).\n    Parameters:\n    f_expr (str): Outer function expression f(x).\n    g_expr (str): Inner function expression g(x).\n    var\n    (str): Variable used in the expressions.\n    Returns:\n    sympy.Expr: Expression representing the composition f(g(x)).\n    Examples:\n    >>> function_composition('2*x', 'x**2', 'x')\n    '2*x**2'\n    \"\"\"\n    x = symbols(var)\n    f = sympify(f_expr)\n    g = sympify(g_expr)\n    composition = f.subs(x, g)\n    return composition",
        "def evaluate_function_at(f_expr, at_val, var='x'):\n    \"\"\"\n    Evaluates a function at a specific value.\n    Parameters:\n    f_expr (str): Function expression.\n    at_val (numeric): Value at which to evaluate the function.\n    var (str, optional): Variable in the function. Defaults to 'x'.\n    Returns:\n    numeric or sympy.Expr: Result of function evaluation.\n    Examples:\n    >>> evaluate_function_at('x**2 + 2*x + 1', 2)\n    9\n    \"\"\"\n    x = symbols(var)\n    f = sympify(f_expr)\n    result = f.subs(x, at_val)\n    return result",
        "def find_function_domain(expression, variable=sp.symbols('x')):\n    \"\"\"\n    Determine the domain of a function where it's defined (real values).\n    Parameters:\n    - expression : str or sympy.Expr\n        The algebraic expression of the function.\n    - variable : sympy.Symbol\n        The variable used in the function.\n    Returns:\n    - sympy.sets.sets.Set\n        The domain of the function as a sympy Set.\n    Examples:\n    >>> str(find_function_domain('log(x) + sqrt(x - 1)'))\n    'Interval(1, oo)'\n    \"\"\"\n    expr = sp.sympify(expression)\n    domain = sp.calculus.util.continuous_domain(expr, variable, sp.S.Reals)\n    return domain",
        "def function_shift(f, x, h_shift=0, v_shift=0):\n    \"\"\"\n    Applies horizontal and vertical shifts to a function.\n    Parameters:\n    - f (sympy Expression): Function to shift.\n    - x (sympy Symbol): The main variable in the function.\n    - h_shift (float): Horizontal shift (positive shifts to the right).\n    - v_shift (float): Vertical shift (positive shifts upwards).\n    \n    Returns:\n    - shifted_function (sympy expression): The shifted function.\n    Example:\n    >>> x = sp.symbols('x')\n    >>> function_shift(x**2, x, -2, 3)\n    \"\"\"\n    return f.subs(x, x - h_shift) + v_shift"
    ],
    "Systems of Equations": [
        "def solve_equation(expr, var, solution_type='real'):\n    \"\"\"\n    Solves algebraic equations and returns solutions based on the type specified ('real', 'complex').\n    Parameters:\n        expr : sympy expression\n            The algebraic expression representing the equation set equal to zero.\n        var : sympy.Symbol\n            The variable to solve for in the expression.\n        solution_type : str\n            Type of solutions to return. Options are 'real' or 'complex'.\n    Returns:\n        list\n            A list of solutions that satisfy the equation. Filtered by real or complex as specified.\n    Examples:\n        >>> x = symbols('x')\n        >>> solve_equation(x**2 - 4, x)\n        [-2, 2]\n        >>> solve_equation(x**2 + 1, x, 'complex')\n        [-I, I]\n    \"\"\"\n    # General solution including complex numbers\n    solutions = solve(Eq(expr, 0), var)\n    if solution_type == 'real':\n        # Filter out only real solutions\n        real_solutions = [sol for sol in solutions if sol.is_real]\n        return real_solutions\n    elif solution_type == 'complex':\n        return solutions\n    else:\n        raise ValueError(\"Invalid solution type specified. Use 'real' or 'complex'.\")",
        "def solve_symbolic_equations(eq_list):\n    \"\"\"\n    Solves a system of symbolic equations.\n    Parameters:\n    -----------\n    eq_list : list\n        List containing equation objects from sympy.\n    Returns:\n    --------\n    solution : dict\n        A dictionary where keys are the sympy symbols (variables) and values are the solutions to these variables.\n    Examples:\n    ---------\n    >>> x, y = symbols('x y')\n    >>> eq1 = Eq(2*x + y, 10)\n    >>> eq2 = Eq(x - y, 2)\n    >>> solve_symbolic_equations([eq1, eq2])\n    {x: 4, y: 6}\n    \"\"\"\n    solution = solve(eq_list)\n    return solution",
        "def matrix_solver(A, b):\n    \"\"\"\n    Solves a system of linear equations (Ax = b) using matrix operations where A is square.\n    Parameters:\n        A : numpy.ndarray\n            Coefficient matrix (must be square).\n        b : numpy.ndarray\n            Constant terms array.\n    Returns:\n        numpy.ndarray\n            Solution vector x.\n    Examples:\n        >>> A = np.array([[1, 1], [1, -1]])\n        >>> b = np.array([2, 0])\n        >>> matrix_solver(A, b)\n        array([1., 1.])\n    \"\"\"\n    A = np.array(A, dtype=float)\n    b = np.array(b, dtype=float)\n    if A.shape[0] != A.shape[1]:\n        raise ValueError(\"Coefficient matrix A must be square.\")\n    \n    # Using NumPy to solve the linear system\n    return np.linalg.solve(A, b)",
        "def simplify_expression(expression, var_name='x'):\n    \"\"\"\n    It receives a string representing an algebraic expression and return it simplified.\n       \n    Parameters:\n    expression (str): A string representing a algebraic expression.\n    var_name (str): A string representing the name of the variable.\n   \n    Returns:\n    Expr: Simplified expression.\n    Example:\n    simplify_expression(\"x**2 + 2*x + 1\")\n    \"\"\"\n    var = symbols(var_name)\n    return simplify(eval(expression))",
        "def solve_quadratic(a, b, c):\n    \"\"\"\n    Solve a quadratic equation of the form ax^2 + bx + c = 0.\n    \n    Parameters:\n        a (float): Coefficient of x^2.\n        b (float): Coefficient of x.\n        c (float): Constant term.\n        \n    Returns:\n        tuple: A tuple of two roots (can be real or complex numbers).\n        \n    Example:\n        >>> solve_quadratic(1, -3, 2)\n        ((2+0j), (1+0j))\n    \"\"\"\n    # Calculate discriminant\n    discriminant = cmath.sqrt(b ** 2 - 4 * a * c)\n    # Calculate two roots\n    root1 = (-b + discriminant) / (2 * a)\n    root2 = (-b - discriminant) / (2 * a)\n    \n    return (root1, root2)",
        "def create_equation(var_dict, equation):\n    \"\"\"\n    It receives a dict and a string representing an algebraic equation and evaluates the equation with the given variables values.\n    \n    Parameters:\n    var_dict (dict): A dictionary with variable names as keys and their values as values.\n    equation (str): A string representing an algebraic equation.\n   \n    Returns:\n    Expr: Evaluated expression.\n    Example:\n    create_equation({'x': 3, 'y': 4}, \"x**2 + y**2\")\n    \"\"\"\n    variables = symbols(' '.join(list(var_dict.keys())))\n    return eval(equation)"
    ],
    "Inequalities": [
        "def solve_inequality(expression, variable):\n    \"\"\"\n    Solves polynomial and rational inequalities.\n    Parameters:\n        expression (str): The inequality expression as a string.\n        variable (str): The variable with respect to which the inequality is considered.\n    Returns:\n        set: The solution set of the inequality expressed in interval notation.\n    Examples:\n        >>> solve_inequality('x**2 - 5*x + 6 > 0', 'x')\n        ((-oo, 2) U (3, oo))\n        >>> solve_inequality('1/x < 0', 'x')\n        ((-oo, 0))\n    \"\"\"\n    x = sp.symbols(variable)\n    inequality_expr = sp.sympify(expression)\n    solution_set = sp.solveset(inequality_expr, x, domain=sp.S.Reals)\n    return solution_set",
        "def arithmetic_mean(values):\n    \"\"\"Calculate the arithmetic mean of a list or numpy array of values.\n    \n    Parameters:\n        values (list or np.array): The input numbers as a list or numpy array.\n    Returns:\n        float: The arithmetic mean of the values.\n    \n    Examples:\n        >>> arithmetic_mean([1, 2, 3, 4])\n        2.5\n    \"\"\"\n    return np.mean(values)",
        "def apply_am_gm_inequality(nums):\n    \"\"\"\n    Applies the Arithmetic Mean - Geometric Mean Inequality to a list of numbers.\n    Parameters\n    ----------\n    nums : list or array-like\n        The list of non-negative numbers to apply the AM-GM inequality.\n    Returns\n    -------\n    tuple\n        Returns a tuple containing the Arithmetic Mean, the Geometric Mean, and the boolean check if AM = GM (equality case).\n    Examples\n    --------\n    >>> apply_am_gm_inequality([4, 1, 1, 4])\n    (2.5, 2.0, False)\n    \"\"\"\n    if not all(x >= 0 for x in nums):\n        raise ValueError(\"All elements must be non-negative for AM-GM inequality.\")\n    n = len(nums)\n    arithmetic_mean = np.mean(nums)\n    geometric_mean = np.prod(np.power(nums, 1/n))\n    # Equality holds if all numbers are the same\n    is_equal = np.isclose(arithmetic_mean, geometric_mean)\n    return (arithmetic_mean, geometric_mean, is_equal)",
        "def geometric_mean(values):\n    \"\"\"Calculate the geometric mean of a list or numpy array of values.\n    \n    Parameters:\n        values (list or np.array): Positive numbers as a list or numpy array.\n    Returns:\n        float: The geometric mean of the values.\n    \n    Examples:\n        >>> geometric_mean([1, 2, 3, 4])\n        2.213364\n    \"\"\"\n    return gmean(values)",
        "def translate_to_inequality(conditions):\n    \"\"\"\n    Translates real-world or word problem conditions into a mathematical inequality.\n    Parameters:\n    conditions (str): Natural language description of the problem conditions.\n    Returns:\n    str: Algebraic inequality as a string based on the input conditions.\n    \n    Note:\n    This tool is illustrative and simplistic. Practical usage in real-world scenarios often requires domain-specific customization.\n    \n    Examples:\n    >>> translate_to_inequality(\"John has more apples than twice the amount of apples his sister has.\")\n    'John > 2 * Sister'\n    \"\"\"\n    # An example, in practical use cases, you might want to use NLP techniques.\n    import re\n    # Mock-up translations for demonstration--would need much more sophisticated logic or ML models.\n    tokens = conditions.lower().split()\n    variable_mapping = {\n        'less': '<',\n        'greater': '>',\n        'at least': '>=',\n        'at most': '<=',\n        'equals': '==',\n    }\n    # Find tokens that likely represent variables or numbers and map.\n    expr = ''\n    for token in tokens:\n        if token in variable_mapping:\n            expr += ' ' + variable_mapping[token] + ' '\n        elif re.match(r'\\d+', token):  # Directly matches digits\n            expr += ' ' + token + ' '\n        else:\n            expr += ' ' + token.capitalize() + ' '\n    return expr.strip()"
    ],
    "Polynomials": [
        "def add_polynomials(poly1, poly2):\n    \"\"\"\n    Add two polynomials.\n    Parameters:\n    - poly1, poly2 (numpy.poly1d): Polynomial objects.\n    Returns:\n    - numpy.poly1d: The polynomial resulting from the addition.\n    Example:\n    >>> p1 = create_polynomial([1, 2])\n    >>> p2 = create_polynomial([9, 1])\n    >>> add_polynomials(p1, p2)\n    numpy.poly1d([10, 3])\n    \"\"\"\n    return np.poly1d(poly1) + np.poly1d(poly2)",
        "def create_polynomial(coeffs):\n    \"\"\"\n    Create a polynomial object from coefficients.\n    Parameters:\n    - coeffs (list of numbers): Coefficients of the polynomial, where the i-th element corresponds to the coefficient of x^i.\n    Returns:\n    - numpy.poly1d: A polynomial object.\n    \n    Example:\n    >>> create_polynomial([1, 0, 3])\n    numpy.poly1d([1, 0, 3])\n    \"\"\"\n    return np.poly1d(coeffs[::-1])",
        "def construct_polynomial(roots):\n    \"\"\"\n    Constructs a polynomial given its roots.\n    \n    Parameters:\n        roots (list): List of roots of the polynomial.\n        \n    Returns:\n        Poly: Polynomial constructed from the roots.\n    \n    Examples:\n        >>> construct_polynomial([1, 2, 3])\n        Poly(x**3 - 6*x**2 + 11*x - 6, x, domain='ZZ')\n    \"\"\"\n    x = symbols('x')\n    polynomial = x - roots[0]\n    for root in roots[1:]:\n        polynomial *= (x - root)\n    return Poly(polynomial, x)",
        "def evaluate_polynomial(coefficients, value):\n    \"\"\"\n    Evaluates a polynomial at a specific point.\n    Parameters:\n    - coefficients (list or tuple): Coefficients of the polynomial\n    - value (number): The point at which the polynomial is to be evaluated.\n    Returns:\n    - result (number): Result of the polynomial evaluation at the specified point.\n    \n    Examples:\n    >>> evaluate_polynomial([1, -3, 2], 0)\n    2\n    \"\"\"\n    polynomial = np.poly1d(coefficients)\n    return polynomial(value)",
        "def factor_polynomial(coefficients):\n    \"\"\"\n    Factorizes a polynomial given its coefficients.\n    \n    Parameters:\n        coefficients (list): List of coefficients from highest degree to the constant term.\n        \n    Returns:\n        Expr: Factored polynomial expression.\n    \n    Examples:\n        >>> factor_polynomial([1, -3, 2])\n        (x - 1)*(x - 2)\n    \"\"\"\n    x = symbols('x')\n    polynomial = sum(c * x**i for i, c in enumerate(reversed(coefficients)))\n    return factor(polynomial)",
        "def sum_and_difference_of_cubes(a, b):\n    \"\"\"\n    Provides factorization for sum and difference of cubes.\n    Parameters:\n    - a, b: Expressions or values.\n    Returns:\n    - tuple: (Sum of cubes factorization, Difference of cubes factorization)\n    \"\"\"\n    sum_cubes = simplify((a + b)*(a**2 - a*b + b**2))\n    diff_cubes = simplify((a - b)*(a**2 + a*b + b**2))\n    return (sum_cubes, diff_cubes)",
        "def evaluate_polynomial(poly, value):\n    \"\"\"\n    Evaluates a polynomial at a given value or expression.\n    Parameters:\n    - poly (sympy.Poly): Polynomial to be evaluated.\n    - value: A value or symbolic expression where the polynomial is evaluated.\n    Returns:\n    - Expression: Result of the polynomial evaluation.\n    \"\"\"\n    return poly.subs(poly.gen, value)",
        "def find_polynomial_roots(poly):\n    \"\"\"\n    Finds all roots (real and complex) of a polynomial.\n    Parameters:\n    - poly (sympy.Poly): Polynomial whose roots are sought.\n    Returns:\n    - list: List of polynomial roots.\n    \"\"\"\n    return solve(poly, dict=True)",
        "def integrate_polynomial(poly):\n    \"\"\"\n    Compute the indefinite integral of a polynomial.\n    Parameters:\n    - poly (numpy.poly1d): Polynomial object.\n    Returns:\n    - numpy.poly1d: The integral of the polynomial with a constant of integration set to 0.\n    Example:\n    >>> p = create_polynomial([2, 0, 1])\n    >>> integrate_polynomial(p)\n    numpy.poly1d([ 0.66666667, 0. , 2. , 0. ])\n    \"\"\"\n    return np.poly1d(poly.integ())",
        "def derivative_polynomial(poly):\n    \"\"\"\n    Compute the derivative of a polynomial.\n    Parameters:\n    - poly (numpy.poly1d): Polynomial object.\n    Returns:\n    - numpy.poly1d: The derivative of the polynomial.\n    Example:\n    >>> p = create_pollynomial([1, 2, 3])\n    >>> derivative_polynomial(p)\n    numpy.poly1d([2, 2])\n    \"\"\"\n    return np.poly1d(poly.deriv())",
        "def difference_of_squares(a, b):\n    \"\"\"\n    Applies the difference of squares identity to (a^2 - b^2).\n    Parameters:\n    - a, b: Expressions or values.\n    Returns:\n    - Expression: Factored form of the expression using the difference of squares.\n    \"\"\"\n    return simplify((a + b)*(a - b))",
        "def apply_binomial_theorem(a, b, n):\n    \"\"\"\n    Applies the binomial theorem to expand (a + b)^n.\n    Parameters:\n    - a, b: Expressions or values for the binomial terms.\n    - n (int): The exponent to which the binomial is raised.\n    Returns:\n    - Expression: Expanded form of the binomial.\n    \"\"\"\n    x, y = symbols('x y')\n    binomial_expr = (a*x + b*y)**n\n    return expand(binomial_expr).subs({x: 1, y: 1})",
        "def factorize_polynomial(poly):\n    \"\"\"\n    Factorizes a polynomial into irreducible factors over the rational numbers.\n    Parameters:\n    - poly (sympy.Poly): Polynomial to be factorized.\n    Returns:\n    - Expression: Factorized form of the polynomial.\n    \"\"\"\n    return factor(poly)",
        "def create_polynomial(coeff_list, var='x'):\n    \"\"\"\n    Creates and returns a polynomial in the given variable from a list of coefficients.\n    \n    Parameters:\n    - coeff_list (list): List of coefficients in decreasing order of power.\n    - var (str): Variable used for the polynomial (default 'x').\n    Returns:\n    - sympy.Poly: Polynomial object.\n    \"\"\"\n    x = symbols(var)\n    return Poly(coeff_list, x)"
    ],
    "Solving Equations": [
        "def solve_quadratic_equation(a, b, c, variable='x'):\n    \"\"\"\n    Solves a quadratic equation ax^2 + bx + c = 0.\n    \n    Parameters:\n        a (int, float): Coefficient of x^2\n        b (int, float): Coefficient of x\n        c (int, float): Constant term\n        variable (str): The variable to solve for, default is 'x'.\n        \n    Returns:\n        sol (list): List containing the roots of the quadratic equation.\n        \n    Examples:\n        >>> solve_quadratic_equation(1, -3, 2)\n        [2, 1]\n    \"\"\"\n    var = sp.symbols(variable)\n    equation = a*var**2 + b*var + c\n    sol = sp.solve(equation, var)\n    return sol",
        "def simplify_expression(expression):\n    \"\"\"\n    Simplifies an algebraic expression.\n    Parameters:\n    - expression: str\n        The algebraic expression to simplify.\n    Returns:\n    - str\n        The simplified form of the algebraic expression.\n    Examples:\n    >>> simplify_expression('x**2 + 2*x + 1')\n    '(x + 1)**2'\n    >>> simplify_expression('x*x - 2*x + 1')\n    'x**2 - 2*x + 1'\n    \"\"\"\n    return str(sympify(expression).simplify())",
        "def manipulate_expression(expression, operation):\n    \"\"\"\n    Simplifies or manipulates algebraic expressions using a specific operation.\n    Parameters:\n    - expression (str): The algebraic expression to manipulate.\n    - operation (str): Operation type ('simplify', 'expand', 'factor').\n    Returns:\n    - The manipulated expression as per the specified operation.\n    Examples:\n    - manipulate_expression('x**2 - 2*x + 1', 'factor')\n    - manipulate_expression('x*(x - 1) + x', 'expand')\n    \"\"\"\n    expr = simplify(expression)  # Simplify the expression initially\n    if operation == 'simplify':\n        return simplify(expr)\n    elif operation == 'expand':\n        return expand(expr)\n    elif operation == 'factor':\n        return factor(expr)\n    else:\n        raise ValueError(\"Unsupported operation. Use 'simplify', 'expand', or 'factor'.\")",
        "def solve_equation(eq):\n    \"\"\"\n    Function to solve algebraic equation.\n    \n    Parameters\n    ----------\n    eq : str\n        Algebraic equation represented as a string. This eq should be a valid sympy equation.\n    Returns\n    -------\n    list\n        A list of real roots of the equation.\n    Example\n    --------\n    >>> solve_equation('x**2 - 5*x + 6 = 0')\n    [2, 3]\n    \"\"\"\n    from sympy import symbols, Eq, solve\n    x = symbols('x')\n    eq = Eq(*map(eval, eq.split(\"=\")))\n    return solve(eq, x)",
        "def factor_algebraic_expression(expression):\n    \"\"\"\n    Perform factorization on an algebraic expression.\n    Parameters:\n    - expression (str): The algebraic expression represented as a string, e.g., \"x**2 - 4\".\n    Returns:\n    - factored_expression (SymPy object): The factored expression if factorizable, otherwise the original expression.\n    Examples:\n    >>> factor_algebraic_expression(\"x**2 - 4\")\n    (x - 2)*(x + 2)\n    \"\"\"\n    exp = sp.sympify(expression)\n    factored_expression = sp.factor(exp)\n    \n    return factored_expression",
        "def square_both_sides(expr):\n    \"\"\"\n    Function to square both sides of an equation\n    \n    Parameters\n    ----------\n    expr : str\n        Algebraic equation represented as a string. This expr should be a valid sympy equation.\n    Returns\n    -------\n    str\n        The equation obtained by squaring both sides of the input equation.\n    Example\n    --------\n    >>> square_both_sides('x = y + 1')\n    'x**2 = (y + 1)**2'\n    \"\"\"\n    left_side, right_side = map(eval, expr.split(\"=\"))\n    return f\"{left_side ** 2} = {right_side ** 2}\"",
        "def evaluate_expression(expr, x_val):\n    \"\"\"\n    Function to evaluate an algebraic expression.\n    \n    Parameters\n    ----------\n    expr : str\n        Algebraic expression represented as a string. This expr should be a valid sympy expression.\n    x_val : int or float or complex\n        A value to substitute for 'x' in the expression expr\n    Returns\n    -------\n    int or float or complex\n        The result of substituting x_val for 'x' in expr and evaluating the resulting expression.\n    Example\n    --------\n    >>> evaluate_expression('x**2 + 2*x + 1', 1)\n    4\n    \"\"\"\n    from sympy import symbols\n    x = symbols('x')\n    return eval(expr)",
        "def decimal_to_fraction(decimal_value):\n    \"\"\"\n    Converts a repeating or non-repeating decimal to its simplest fractional form.\n    Parameters:\n    - decimal_value (float or str): The decimal value to convert.\n    Returns:\n    - The fraction representation of the decimal.\n    Examples:\n    - decimal_to_fraction(0.333)  # for repeating decimals like 1/3\n    - decimal_to_fraction('0.(142857)')  # for specific repeating decimals\n    \"\"\"\n    x = symbols('x')\n    if isinstance(decimal_value, str) and '(' in decimal_value:\n        before, after = decimal_value.split('(')\n        after = after.strip(')')\n        repeats = after\n        non_repeats = before if before else '0'\n        full_decimal = non_repeats + repeats\n        length_of_repeats = len(repeats)\n        decimal_places = len(non_repeats.split('.')[1] if '.' in non_repeats else '') + length_of_repeats\n        fraction = (int(full_decimal) - int(non_repeats)) / (10**decimal_places - 10**len(non_repeats.split('.')[1]))\n        return nsimplify(fraction)\n    else:\n        return nsimplify(decimal_value)"
    ],
    "Simplifying Expressions": [
        "def simplify_expression(expression):\n    \"\"\"\n    Simplifies an algebraic expression using symbolic mathematics.\n    Parameters:\n        expression (str): The algebraic expression as a string.\n    Returns:\n        str: The simplified expression in string format.\n    \n    Example:\n        >>> simplify_expression(\"2*x + 3*x + 1\")\n        '5*x + 1'\n    \"\"\"\n    expr = sympify(expression)\n    simplified_expr = simplify(expr)\n    return str(simplified_expr)",
        "def expand_expression(expression):\n    \"\"\"\n    Expands an algebraic expression to its expanded form.\n    Parameters:\n        expression (str): The algebraic expression as a string.\n    Returns:\n        str: The expanded expression in string format.\n    \n    Example:\n        >>> expand_expression(\"(x - 2)*(x + 2)\")\n        'x**2 - 4'\n    \"\"\"\n    expr = sympify(expression)\n    expanded_expr = expand(expr)\n    return str(expanded_expr)",
        "def factor_expression(expression):\n    \"\"\"\n    Factors an algebraic expression into its irreducible components.\n    Parameters:\n        expression (str): The algebraic expression as a string.\n    Returns:\n        str: The factored expression in string format.\n    \n    Example:\n        >>> factor_expression(\"x**2 - 4\")\n        '(x - 2)*(x + 2)'\n    \"\"\"\n    expr = sympify(expression)\n    factored_expr = factor(expr)\n    return str(factored_expr)",
        "def substitute_in_expression(expression, substitutions):\n    \"\"\"\n    Substitutes values into an algebraic expression and simplifies it.\n    Parameters:\n        expression (str): The algebraic expression as a string.\n        substitutions (dict): A dictionary where keys are variable names as strings and values are their respective values.\n    Returns:\n        str: The simplified expression after substitution in string format.\n    \n    Example:\n        >>> substitute_in_expression(\"x**2 + 2*x + 1\", {'x': 2})\n        '9'\n    \"\"\"\n    expr = sympify(expression)\n    substituted_expr = expr.subs(substitutions)\n    simplified_expr = simplify(substituted_expr)\n    return str(simplified_expr)",
        "def rationalize_expression(expression):\n    \"\"\"\n    Rationalizes denominators in an expression with radicals.\n    \n    Parameters:\n        expression (str): The algebraic expression to rationalize.\n    \n    Returns:\n        sympy.Expr: The expression with rationalized denominator.\n    \n    Examples:\n        >>> rationalize_expression(\"1/sqrt(x)\")\n        sqrt(x)/x\n    \"\"\"\n    expr = sp.sympify(expression)\n    return sp.radsimp(expr)",
        "def rationalize_denominator(expr_str):\n    \"\"\"\n    Rationalizes the denominator of an algebraic expression if it contains radicals or complex fractions.\n    Parameters:\n    - expr_str (str): String representation of the algebraic expression.\n    Returns:\n    - str: Expression with a rationalized denominator.\n    Examples:\n    - rationalize_denominator('1/(sqrt(2))')\n    - rationalize_denominator('1/(2 + sqrt(3))')\n    Note:\n    Assumes input uses square roots as sqrt() and ** for power.\n    \"\"\"\n    expr_str = expr_str.replace('^', '**')\n    expr = simplify(expr_str).radsimp()\n    return str(expr)",
        "def simplify_radical_expression(expression):\n    \"\"\"\n    Simplifies expressions involving radicals (roots).\n    \n    Parameters:\n        expression (str): The algebraic expression with radicals.\n    \n    Returns:\n        sympy.Expr: The simplified expression.\n    \n    Examples:\n        >>> simplify_radical_expression(\"sqrt(x**2)\")\n        Abs(x)\n        \n        >>> simplify_radical_expression(\"1/sqrt(x)\")\n        x**(-1/2)\n    \"\"\"\n    expr = sp.sympify(expression)\n    return sp.simplify(expr)",
        "def handle_radicals_and_exponents(base, exponent, operation='simplify'):\n    \"\"\"\n    Handles operations on expressions involving radicals and exponents.\n    \n    Parameters:\n        base (sp.Expr): The base of the exponent.\n        exponent (sp.Expr): The exponent value.\n        operation (str): Type of operation, 'simplify' or 'rationalize'.\n    \n    Returns:\n        sp.Expr: The result after applying the specified operation.\n    \n    Examples:\n        >>> handle_radicals_and_exponents(x, 1/2)\n        sqrt(x)\n        \n        >>> handle_radicals_and_exponents(a*b, -2)\n        1/(a**2 * b**2)\n    \"\"\"\n    base, exponent = sp.sympify(base), sp.sympify(exponent)\n    expr = base**exponent\n    \n    if operation == 'simplify':\n        return sp.simplify(expr)\n    elif operation == 'rationalize':\n        if exponent < 0:\n            # Rationalize denominators\n            expr = 1/expr\n            rationalized_expr = sp.radsimp(expr)\n            return rationalized_expr\n        else:\n            return sp.radsimp(expr)\n    else:\n        raise ValueError(\"Unsupported operation. Choose from 'simplify' or 'rationalize'.\")",
        "def manipulate_fractions(num1, den1, num2, den2, operation='add'):\n    \"\"\"\n    Performs arithmetic operations on fractions and simplifies the result.\n    \n    Parameters:\n        num1 (sp.Expr): The numerator of the first fraction.\n        den1 (sp.Expr): The denominator of the first fraction.\n        num2 (sp.Expr): The numerator of the second fraction.\n        den2 (sp.Expr): The denominator of the second fraction.\n        operation (str): The operation to perform; 'add', 'subtract', 'multiply', 'divide'\n    \n    Returns:\n        sp.Expr: The result of the operation on the two fractions, simplified.\n    \n    Examples:\n        >>> manipulate_fractions(1, 2, 1, 3, 'add')\n        5/6\n        \n        >>> manipulate_fractions(x, y, y, x, 'multiply')\n        x*y/(y*x)\n    \"\"\"\n    # Convert numbers to sympy expressions if they aren't already\n    num1, den1, num2, den2 = map(sp.sympify, (num1, den1, num2, den2))\n    # Create fraction expressions\n    frac1 = num1 / den1\n    frac2 = num2 / den2\n    \n    # Perform the specified operation\n    if operation == 'add':\n        result = frac1 + frac2\n    elif operation == 'subtract':\n        result = frac1 - frac2\n    elif operation == 'multiply':\n        result = frac1 * frac2\n    elif operation == 'divide':\n        result = frac1 / frac2\n    else:\n        raise ValueError(\"Unsupported operation. Choose from 'add', 'subtract', 'multiply', 'divide'.\")\n    \n    # Simplify and return the result\n    return sp.simplify(result)",
        "def manipulate_expression(expression, operation='simplify', value=None):\n    \"\"\"\n    Manipulates the given algebraic expression based on the specified operation.\n    Operations include expansion, factoring, solving equations, polynomial operations, and substituting values.\n    Parameters:\n    - expression (str): The algebraic expression or equation.\n    - operation (str): The operation to perform (e.g., 'expand', 'factor', 'solve').\n    - value (dict, optional): Dictionary of values to substitute in expression, e.g., {x: 1}.\n    Returns:\n    - str or list: The result of the operation, as a string or list of solutions.\n    Examples:\n    >>> manipulate_expression('x^2 + 2*x + 1', 'factor')\n    '(x + 1)**2'\n    >>> manipulate_expression('x^2 - 4', 'solve')\n    '[-2, 2]'\n    >>> manipulate_expression('x^2 + 3*x + 2', 'expand')\n    'x**2 + 3*x + 2'\n    \"\"\"\n    expr = sp.sympify(expression.replace('^', '**'))\n    if operation == 'expand':\n        result = sp.expand(expr)\n    elif operation == 'factor':\n        result = sp.factor(expr)\n    elif operation == 'solve':\n        # Assuming it is to solve for x\n        result = sp.solveset(expr, sp.Symbol('x'), domain=sp.S.Reals)\n    if value is not None:\n        expr = expr.subs(value)\n        result = expr.evalf()\n    \n    return str(result)"
    ],
    "Sequences and Series": [
        "def sum_geometric_series(a, r, n):\n    \"\"\"\n    Calculate the sum of the first n terms of a geometric series.\n    Parameters:\n    a (float): First term of the series.\n    r (float): Common ratio of the series.\n    n (int): Number of terms to sum.\n    Returns:\n    float: Sum of the first n terms.\n    \n    Examples:\n    >>> sum_geometric_series(1, 2, 3)\n    7\n    \"\"\"\n    if r == 1:\n        return n * a\n    else:\n        return a * (r**n - 1) / (r - 1)",
        "def arithmetic_series_sum(a, d, n):\n    \"\"\"\n    Computes the sum of the first n terms of an arithmetic series.\n    \n    Parameters:\n    a : float\n        The first term of the arithmetic series.\n    d : float\n        The common difference between terms of the arithmetic series.\n    n : int\n        The number of terms to sum.\n        \n    Returns:\n    float\n        The sum of the first n terms of the arithmetic series.\n    \n    Example:\n    >>> arithmetic_series_sum(1, 1, 100)  # Sum of the first 100 natural numbers\n    5050.0\n    \"\"\"\n    return n / 2 * (2 * a + (n - 1) * d)",
        "def nth_term_arithmetic_series(a1, d, n):\n    \"\"\"\n    Calculate the nth term of an arithmetic series.\n    Parameters:\n    a1 (float): First term of the series.\n    d (float): Common difference in the series.\n    n (int): Term position to calculate.\n    Returns:\n    float: Value of the nth term.\n    \n    Examples:\n    >>> nth_term_arithmetic_series(1, 2, 5)\n    9\n    \"\"\"\n    return a1 + (n - 1) * d",
        "def compute_nth_term(a, r, n):\n    \"\"\"\n    Compute the nth term of a geometric sequence.\n    Parameters:\n    a : float\n        The first term of the geometric sequence.\n    r : float\n        The common ratio of the geometric sequence.\n    n : int\n        The term number to compute.\n    Returns:\n    float\n        The nth term of the sequence.\n    Examples:\n    >>> compute_nth_term(2, 3, 4)\n    54\n    \"\"\"\n    return a * r ** (n - 1)",
        "def sum_of_natural_numbers(n):\n    \"\"\"\n    Calculate the sum of the first n natural numbers.\n    Parameters:\n    n (int): Number of terms.\n    Returns:\n    int: Sum of the first n natural numbers.\n    \n    Examples:\n    >>> sum_of_natural_numbers(100)\n    5050\n    \"\"\"\n    return n * (n + 1) / 2",
        "def sum_infinite_geometric_series(a, r):\n    \"\"\"\n    Calculate the sum of an infinite geometric series, given that |r| < 1.\n    Parameters:\n    a : float\n        The first term of the series.\n    r : float\n        The common ratio of the series.\n    Returns:\n    float or None\n        The sum of the infinite series if |r| < 1, otherwise None.\n    Examples:\n    >>> sum_infinite_geometric_series(3, 0.5)\n    6.0\n    \"\"\"\n    if abs(r) < 1:\n        return a / (1 - r)\n    else:\n        return None",
        "def sum_arithmetic_series(a1, an, n):\n    \"\"\"\n    Calculate the sum of the first n terms in an arithmetic series.\n    Parameters:\n    a1 (float): First term of the series.\n    an (float): nth term or last term of the series to sum up to.\n    n (int): Number of terms to sum.\n    Returns:\n    float: Sum of the first n terms.\n    \n    Examples:\n    >>> sum_arithmetic_series(1, 9, 5)\n    25\n    \"\"\"\n    return n * (a1 + an) / 2",
        "def common_difference_arithmetic_sequence(term1, nth_term, n):\n    \"\"\"\n    Determine the common difference in an arithmetic sequence.\n    Parameters:\n    - term1 (Numerical): The first term of the sequence or any known term.\n    - nth_term (Numerical): The nth term of the sequence.\n    - n (Integer): The difference in nth from term1 (n-1 if term1 is the first term).\n    Returns:\n    - Numerical: The common difference of the sequence.\n    Examples:\n    >>> common_difference_arithmetic_sequence(5, 11, 4)\n    2\n    \"\"\"\n    return (nth_term - term1) / (n - 1)",
        "def number_of_terms_arithmetic_sequence(first_term, last_term, d):\n    \"\"\"\n    Calculate the number of terms in an arithmetic sequence.\n    Parameters:\n    - first_term (Numerical): The first term of the sequence.\n    - last_term (Numerical): The last term of the sequence.\n    - d (Numerical): The common difference of the sequence.\n    Returns:\n    - Integer: The total number of terms in the sequence.\n    Examples:\n    >>> number_of_terms_arithmetic_sequence(2, 14, 3)\n    5\n    \"\"\"\n    return ((last_term - first_term) / d) + 1",
        "def binomial_coefficient(n, k):\n    \"\"\"\n    Calculate the binomial coefficient \"n choose k\", which is n! / (k! (n-k)!).\n    Parameters:\n    - n (int/symbolic): The total number of items.\n    - k (int/symbolic): The number of items to choose.\n    Returns:\n    - int/symbolic expression: Binomial coefficient.\n    Example:\n    >>> binomial_coefficient(5, 2)\n    10\n    \"\"\"\n    return sp.binomial(n, k)",
        "def generic_summation(n, term_function):\n    \"\"\"\n    Computes the sum of terms in a sequence defined by a function over a range [1, n].\n    Parameters:\n        n (int): The upper limit of the summation range.\n        term_function (function): A function that defines the term to be summed,\n                                  which takes an integer index as an argument.\n    Returns:\n        float: The sum of the sequence terms.\n    Examples:\n        >>> generic_summation(5, lambda x: x**2)\n        55\n        >>> generic_summation(4, lambda x: 2**x)\n        30\n    \"\"\"\n    import functools\n    return functools.reduce(lambda acc, x: acc + term_function(x), range(1, n + 1), 0)",
        "def simplify_factorial_expression(expr):\n    \"\"\"\n    Simplifies expressions involving factorials, making use of algebraic identities.\n    Parameters:\n    - expr (string/symbolic expression): The factorial expression to simplify.\n    Returns:\n    - symbolic expression: Simplified expression.\n    Example:\n    >>> simplify_factorial_expression(\"n!/(n-1)!\")\n    n\n    \"\"\"\n    expr = sp.sympify(expr)\n    return sp.simplify(expr)",
        "def find_common_ratio(term1, term2, position1=1, position2=2):\n    \"\"\"\n    Calculate the common ratio of a geometric sequence given two terms.\n    Parameters:\n    term1 : float\n        The value of the term at position1.\n    term2 : float\n        The value of the term at position2.\n    position1 : int, optional\n        The position of 'term1' in the sequence (default is 1).\n    position2 : int, optional\n        The position of 'term2' in the sequence (default is 2).\n    Returns:\n    float\n        The common ratio of the sequence.\n    Examples:\n    >>> find_common_profile(3, 12, 1, 2)\n    4.0\n    \"\"\"\n    return (term2 / term1) ** (1 / (position2 - position1))",
        "def find_common_difference(term1, term2, gap=1):\n    \"\"\"\n    Determine the common difference of an arithmetic sequence given two terms.\n    Parameters:\n    term1 (int/float): The value of one known term.\n    term2 (int/float): The value of another known term.\n    gap (int): The step difference in terms of the number of terms between term1 and term2.\n    Returns:\n    int/float: The common difference.\n    \n    Examples:\n    >>> find_common_difference(2, 8, 2)\n    3\n    >>> find_common_difference(5, 11, 3)\n    2\n    \"\"\"\n    return (term2 - term1) / gap",
        "def find_term(sequence, condition):\n    \"\"\"\n    Finds a term in the sequence that satisfies a given condition.\n    \n    Parameters:\n    - sequence: list. A list of terms of the sequence.\n    - condition: function. A function that returns True if the condition is met.\n    \n    Returns:\n    - element or None. The first element that meets the condition or None if none found.\n    \n    Examples:\n    - find_term([1, 2, 3, 4, 5], lambda x: x > 3) --> 4\n    \"\"\"\n    for element in sequence:\n        if condition(element):\n            return element\n    return None",
        "def sequence_sum_and_analyze(sequence, property_func):\n    \"\"\"\n    Sum a given sequence and analyze it based on a supplied function, typically to check properties such as being arithmetic.\n    Parameters:\n    sequence (list): The sequence to analyze and sum.\n    property_func (function): A function that takes the sequence and returns some property.\n    Returns:\n    dict: Dictionary containing the sum of the sequence and its analyzed property.\n    \n    Example:\n    # Given an arithmetic sequence\n    result = sequence_sum_and_analyze([1, 5, 9, 13], lambda seq: (seq[1]-seq[0] == seq[-1]-seq[-2]))\n    \"\"\"\n    sum_sequence = sum(sequence)\n    property_output = property_func(sequence)\n    return {'sum': sum_sequence, 'property': property_output}",
        "def compute_factorial_product(n):\n    \"\"\"\n    Compute the factorial of `n`.\n    Parameters:\n        n (int): The number at which the factorial is to be computed.\n    Returns:\n        int: The factorial of `n`.\n    Examples:\n        >>> compute_factorial_product(5)\n        120\n        >>> compute_factorial_product(3)\n        6\n    \"\"\"\n    return factorial(n)",
        "def general_summation(function, start, end):\n    \"\"\"\n    Calculate the sum of a sequence where each term is defined by a function.\n    Parameters:\n    - function: callable, the function defining the terms. Must accept one argument.\n    - start: int, the starting value of the index.\n    - end: int, the ending value of the index.\n    Returns:\n    - The sum of the function values from `start` to `end`.\n    Examples:\n    >>> general_summation(lambda x: x**2, 1, 100)\n    338350\n    \"\"\"\n    return sum(function(x) for x in range(start, end + 1))",
        "def sequence_sum(sequence):\n    \"\"\"\n    Calculates the sum of a sequence.\n    \n    Parameters:\n    - sequence: list. A list of numerical values representing a sequence.\n    \n    Returns:\n    - float or int. The sum of the sequence.\n    \n    Examples:\n    - sequence_sum([1, 2, 3, 4, 5]) --> 15\n    - sequence_sum([n**2 for n in range(1, 11)]) --> 385 (sum of squares of first 10 natural numbers)\n    \"\"\"\n    return sum(sequence)",
        "def product_of_sequence(seq):\n    \"\"\"\n    Calculate the product of a sequence of terms.\n    Parameters:\n    - seq (list/sympy Matrix): The sequence of terms to multiply.\n    Returns:\n    - symbolic expression/number: Product of the terms in the sequence.\n    Example:\n    >>> product_of_sequence([1, 2, 3, 4])\n    24\n    \"\"\"\n    return sp.prod(seq)",
        "def periodic_sequence_analysis(sequence, length_of_period):\n    \"\"\"\n    Analyze the sequence for periodic behavior given an expected period length.\n    Parameters:\n    sequence (list): The sequence to analyze.\n    length_of_period (int): The expected length of the periodic cycle.\n    Returns:\n    bool: Whether the sequence is periodic with the given period length.\n    \n    Example:\n    # Check if sequence [1, 2, 3, 1, 2, 3] repeats every 3 terms\n    is_periodic = periodic_sequence_analysis([1, 2, 3, 1, 2, 3], 3)\n    \"\"\"\n    if len(sequence) % length_of_period != 0:\n        return False\n    period = sequence[:length_of_period]\n    for i in range(length_of_period, len(sequence), length_of_period):\n        if sequence[i:i+length_of_period] != period:\n            return False\n    return True"
    ],
    "Radicals and Root Operations": [
        "def simplify_radical_expression(expr):\n    \"\"\"\n    Simplifies an expression containing radicals.\n    \n    Parameters:\n        expr (str): A symbolic expression containing radicals.\n    \n    Returns:\n        sympy.Expr: Simplified expression.\n    \n    Examples:\n        >>> simplify_radical_expression('sqrt(x**2 + 2*x + 1)')\n        x + 1\n    \"\"\"\n    x = sp.symbols('x')\n    return sp.simplify(sp.sympify(expr))",
        "def solve_equation_with_radicals(equation, variable_str='x'):\n    \"\"\"\n    Solves equations involving radicals by isolating radicals, squaring both sides to eliminate them, and solving the resulting equation.\n    \n    Parameters:\n        equation (str): The equation in string format with a radical to be solved.\n        variable_str (str): The main variable of the equation as a string.\n    \n    Returns:\n        list: A list of solutions to the equation. Includes checks for extraneous solutions.\n        \n    Example:\n        >>> solve_equation_with_radicals('sqrt(x) + 1 = 5', 'x')\n        [16]\n    \"\"\"\n    variable = sp.symbols(variable_str)\n    equation = sp.sympify(equation.replace('=', '-(') + ')')  # Convert to sympy equation (0 on one side)\n    \n    # Try to isolate the root and square both sides\n    isolated_eq = sp.solve(equation, variable, dict=True)\n    \n    # We square both sides, assuming only one root term is isolated on one side\n    squared_eq = [eq[variable]**2 for eq in isolated_eq]\n    \n    # Solve the squared equations\n    solutions = set()\n    for eq in squared_eq:\n        sols = sp.solveset(eq, variable)\n        for sol in sols:\n            # We substitute back into original equation to avoid extraneous solutions\n            if sp.simplify(equation.subs(variable, sol)) == 0:\n                solutions.add(sol)\n    return list(solutions)",
        "def rationalize_denominator(expression):\n    \"\"\"\n    Rationalize the denominator of a radical expression.\n    Parameters:\n        expression (sympy.Expr): The expression whose denominator needs to be rationalized.\n    Returns:\n        sympy.Expr: Expression with rationalized denominator.\n    Examples:\n        >>> rationalize_denominator(sp.sqrt(1/sp.Rational(2)))\n        sqrt(2)/2\n    \"\"\"\n    # Use sympy's built-in function\n    return sp.radsimp(expression)",
        "def distance_between_points(x1, y1, x2, y2):\n    \"\"\"\n    Calculates the Euclidean distance between two points (x1, y1) and (x2, y2) in 2D space.\n    Parameters:\n        x1, y1 (float or int): Coordinates of the first point.\n        x2, y2 (float or int): Coordinates of the second point.\n    Returns:\n        float: The distance between the two points.\n    Examples:\n        >>> distance_between_points(0, 0, 3, 4)\n        5.0\n        >>> distance_between_points(-1, -1, 1, 2)\n        3.605551275463989\n    \"\"\"\n    from math import sqrt\n    return sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2)",
        "def compute_root(n, degree=2):\n    \"\"\"\n    Compute the nth-root of a number.\n    \n    Parameters:\n        n (float): The number from which to compute the root.\n        degree (int): The degree of the root. Default is 2 (square root).\n    \n    Returns:\n        float: The computed nth-root of the number.\n    \n    Examples:\n        >>> compute_root(16, 2)\n        4.0\n        >>> compute_root(8, 3)\n        2.0\n    \"\"\"\n    return n ** (1/degree)",
        "def multiply_radicals(rad1, rad2):\n    \"\"\"\n    Multiplies two radical expressions, simplifying the result. \n    Assumes inputs are already in a simplified radical form.\n    \n    Parameters:\n        rad1 (sympy expression): First radical term.\n        rad2 (sympy expression): Second radical term.\n    \n    Returns:\n        sympy expression: Result of multiplying the two radicals.\n    \n    Examples:\n        >>> multiply_radicals(sqrt(2), sqrt(8))\n        2*sqrt(2)\n    \"\"\"\n    from sympy import simplify\n    result = simplify(rad1 * rad2)\n    return result",
        "def solve_quadratic(a, b, c):\n    \"\"\"\n    Solves a quadratic equation of the form ax^2 + bx + c = 0.\n    Parameters:\n        a (float or int): Coefficient of x^2\n        b (float or int): Coefficient of x\n        c (float or int): Constant term\n    Returns:\n        tuple: A tuple containing the roots (real or complex) of the quadratic equation.\n    Examples:\n        >>> solve_quadratic(1, -3, 2)\n        (2.0, 1.0)\n        >>> solve_quadratic(1, 0, 1)\n        ((-0j), (1+0j))\n    \"\"\"\n    import cmath\n    discriminant = b**2 - 4*a*c\n    root1 = (-b + cmath.sqrt(discriminant)) / (2 * a)\n    root2 = (-b - cmath.sqrt(discriminant)) / (2 * a)\n    return (root1, root2)",
        "def determine_domain(expression, variable_str='x'):\n    \"\"\"\n    Determines the domain of a function involving radicals, ensuring the radicand is non-negative.\n    \n    Parameters:\n        expression (str): The function expression containing a radical.\n        variable_str (str): The primary variable in the function expression.\n    \n    Returns:\n        sympy.Interval: The domain of the function where the radicand is non-negative.\n    Example:\n        >>> determine_domain('sqrt(x - 1)', ' x')\n        Interval(1, oo)\n    \"\"\"\n    variable = sp.symbols(variable_str)\n    expr = sp.sympify(expression)\n    # Find all radicals (root expressions) in the input expression\n    radicals = [node for node in sp.preorder_traversal(expr) if isinstance(node, sp.Pow) and node.args[1] == 0.5]\n    # Compute conditions for non-negative radicands\n    conditions = [sp.solveset(sp.Gt(rad.args[0], 0), variable) for rad in radicals]\n    \n    # Combine conditions to find the overall domain\n    domain = sp.Intersection(*conditions)\n    return domain",
        "def calculate_nth_root(value, n):\n    \"\"\"\n    Calculate the nth root of a given number, where n is a positive integer.\n    \n    Parameters:\n    value (float): The number from which to extract the nth root.\n    n (int): The degree of the root. Must be a positive integer.\n    Returns:\n    float: The nth root of the given number.\n    Examples:\n    >>> calculate_nth_root(16, 2)\n    4.0\n    >>> calculate_nth_root(8, 3)\n    2.0\n    \"\"\"\n    return value ** (1/n)",
        "def compute_root(base, n=2):\n    \"\"\"\n    Computes the nth root of a given number `base`.\n    Parameters:\n    - base: float or int, the number from which the nth root is to be taken\n    - n: int, degree of the root (default is 2 for square root)\n    Returns:\n    - float, the nth root of `base`\n    Examples:\n    >>> compute_root(16, 2)\n    4.0\n    >>> compute_root(8, 3)\n    2.0\n    \"\"\"\n    import math\n    if base < 0 and n % 2 == 0:\n        raise ValueError(\"Cannot compute even roots for negative numbers\")\n    return base ** (1 / n)",
        "def calculate_side_length_from_area(area):\n    \"\"\"\n    Calculate the side length of a square from its given area.\n    Parameters:\n        area (int, float, sympy.Expr): The area of the square. Can also be a fraction or an expression.\n        \n    Returns:\n        sympy.Expr: The side length of the square which is the square root of the area.\n    Examples:\n        >>> calculate_side_length_from_area(9)\n        3\n        >>> calculate_side_length_from_area(sp.Rational(1, 16))\n        1/4\n    \"\"\"\n    side_length = sp.sqrt(area)\n    return side_length.simplify()",
        "def simplify_radical(expression):\n    \"\"\"\n    Simplify an expression involving radicals. This includes rationalizing the denominator if necessary.\n    \n    Parameters:\n    expression (sympy expression): The expression containing radicals.\n    \n    Returns:\n    sympy expression: The simplified expression.\n    \n    Examples:\n    >>> from sympy.abc import x\n    >>> simplify_radical(x*sqrt(2)/2)\n    sqrt(2)*x/2\n    >>> simplify_radical(sqrt(8)/sqrt(2))\n    2*sqrt(2)\n    \"\"\"\n    return simplify(expression)",
        "def solve_pythagorean(a=None, b=None, c=None):\n    \"\"\"\n    Solves the Pythagorean theorem a^2 + b^2 = c^2 for a missing side.\n    \n    Parameters:\n        a (float, optional): Length of side a.\n        b (float, optional): Length of side b.\n        c (float, optional): Length of the hypotenuse c.\n    \n    Returns:\n        float: The length of the missing side.\n    \n    Examples:\n        >>> solve_pythagorean(a=3, b=4)\n        5.0\n        \n        >>> solve_pythagorean(b=4, c=5)\n        3.0\n    \"\"\"\n    if c is None:  # solve for c\n        return sp.sqrt(a**2 + b**2)\n    elif a is None:  # solve for a\n        return sp.sqrt(c**2 - b**2)\n    elif b is None:  # solve for b\n        return sp.sqrt(c**2 - a**2)",
        "def ellipse_focal_distance(a, b):\n    \"\"\"\n    Calculates the focal distance (c) of an ellipse given the semi-major axis (a) and semi-minor axis (b) using the relation c^2 = a^2 - b^2.\n    \n    Parameters:\n    - a (int or float or sympy.core.numbers): Semi-major axis of the ellipse.\n    - b (int or float or sympy.core.numbers): Semi-minor axis of the ellipse.\n    \n    Returns:\n    - sympy.core.numbers: The focal distance (c) of the ellipse, simplified if possible.\n    \n    Examples:\n    >>> ellipse_focal_distance(5, 4)\n    3\n    >>> ellipse_focal_distance(10, 8)\n    6\n    \"\"\"\n    c_squared = sympy.sympify(a)**2 - sympy.sympify(b)**2\n    c = sympy.sqrt(sympy.simplify(c_squared))\n    return c",
        "def evaluate_square_root(number, decimal_places=None):\n    \"\"\"\n    Evaluates the square root of a given number, with an optional specification of decimal places.\n    Parameters:\n    number (int, float): The number from which to find the square root.\n    decimal_places (int, optional): The number of decimal places to round the result to. Defaults to None.\n    Returns:\n    float or str: The square root of the number, optionally rounded to a specified number of decimal places.\n                  If exact square root is found, it return as integer.\n    \n    Examples:\n    >>> evaluate_square_root(25)\n    5\n    >>> evaluate_square_root(20, 3)\n    4.472\n    \"\"\"\n    root = sp.sqrt(number)\n    if root.is_Integer:\n        return int(root)\n    else:\n        if decimal_places is not None:\n            return round(float(root), decimal_places)\n        return float(root)",
        "def prime_factorization(n):\n    \"\"\"\n    Perform prime factorization on a given integer and return the factors in base-exponent pairs.\n    \n    Parameters:\n    - n (int): The integer to be factorized.\n    \n    Returns:\n    - dict: A dictionary where keys are prime factors and values are their respective exponents.\n    \n    Examples:\n    >>> prime_factorization(18)\n    {2: 1, 3: 2}\n    \n    >>> prime_factorization(100)\n    {2: 2, 5: 2}\n    \"\"\"\n    prime_factors = {}\n    i = 2\n    while i * i <= n:\n        while (n % i) == 0:\n            if i in prime_factors:\n                prime_factors[i] += 1\n            else:\n                prime_factors[i] = 1\n            n //= i\n        i += 1\n    if n > 1:\n        prime_factors[n] = 1\n    return prime_factors",
        "def pythagorean_ellipse(a=None, b=None, c=None):\n    \"\"\"\n    Solves the Pythagorean relationship for an ellipse (c^2 = a^2 - b^2) given two of the three parameters.\n    Parameters:\n    - a (float or None): The semi-major axis.\n    - b (float or None): The semi-minor axis.\n    - c (float or None): The focal length from the center to the focus.\n    Returns:\n    - result (float): Value of the computed parameter.\n    Examples:\n    >>> pythagorean_ellipse(a=5, b=3)\n    4.0\n    >>> pythagorean_ellipse(c=4, b=3)\n    5.0\n    >>> pythagorean_ellipse(a=5, c=4)\n    3.0\n    \"\"\"\n    if a is not None and b is not None:\n        return sp.sqrt(a**2 - b**2).evalf()\n    elif a is not None and c is not None:\n        return sp.sqrt(a**2 - c**2).evalf()\n    elif b is not None and c is not None:\n        return sp.sqrt(c**2 + b**2).evalf()\n    else:\n        raise ValueError(\"Two parameters must be provided.\")",
        "def symbolic_root(expression, degree=2):\n    \"\"\"\n    Calculates the nth root of a symbolic expression using sympy.\n    \n    Parameters:\n        expression (str or sympy expression): The symbolic expression from which the root is to be calculated.\n        degree (int): The degree of the root. Default is 2 (square root).\n    Returns:\n        sympy expression: The nth root of the given symbolic expression.\n    \n    Examples:\n        >>> symbolic_root('x**2 - 4', 2)\n        sqrt(x**2 - 4)\n        >>> symbolic_root('x**3', 3)\n        x\n    \"\"\"\n    if isinstance(expression, str):\n        expression = sp.sympify(expression)\n    return expression ** (1/degree)",
        "def radical_expression_handler(expression, operation=\"simplify\"):\n    \"\"\"\n    Perform operations such as simplification, rationalization, or manipulation of radical expressions.\n    Parameters:\n        expression (str): The radical expression given as a string.\n        operation (str): The type of operation to perform on the radical expression. \n                         Supported operations: \"simplify\", \"rationalize\", \"expand\"\n    Returns:\n        sympy.Expr: The resulting expression after the specified operation.\n    Examples:\n        >>> radical_expression_handler('sqrt(45) * sqrt(5)', 'simplify')\n        15\n        >>> radical_expression_handler('1/sqrt(2)', 'rationalize')\n        sqrt(2)/2\n    \"\"\"\n    expr = sp.sympify(expression)\n    if operation == \"simplify\":\n        return sp.simplify(expr)\n    elif operation == \"rationalize\":\n        numer, denom = expr.as_numer_denom()\n        return sp.simplify(numer * sp.conjugate(denom) / (denom * sp.conjugate(denom)))\n    elif operation == \"expand\":\n        return sp.expand(expr)\n    else:\n        raise ValueError(\"Unsupported operation. Use 'simplify', 'rationalize', or 'expand'.\")",
        "def ellipse_linear_eccentricity(a, b):\n    \"\"\"\n    Calculate the linear eccentricity of an ellipse given its semi-major and semi-minor axes.\n    \n    Parameters:\n    - a (float): Semi-major axis of the ellipse.\n    - b (float): Semi-minor axis of the ellipse.\n    \n    Returns:\n    - float: The linear eccentricity of the ellipse.\n    \n    Examples:\n    >>> ellipse_linear_eccentricity(5, 3)\n    4.0\n    \"\"\"\n    return math.sqrt(a**2 - b**2)",
        "def simplify_and_solve(expression, var):\n    \"\"\"\n    Simplifies an expression involving square roots and solves for a variable.\n    \n    Parameters:\n        expression (str): The equation or expression involving square roots.\n        var (str): The variable to solve for.\n    \n    Returns:\n        set: A set of possible solutions for the variable.\n    \n    Examples:\n        >>> simplify_and_solve('x**2 - sqrt(16)', 'x')\n        {-2, 2}\n        \n        >>> simplify_and_solve('x**2 - 2*x - sqrt(9) + 3', 'x')\n        {1, 3}\n    \"\"\"\n    expr = sp.sympify(expression)\n    variable = sp.symbols(var)\n    simplified_expr = sp.simplify(expr)\n    return sp.solveset(simplified_expr, variable)",
        "def simplify_radical_expression(n, root_degree=2):\n    \"\"\"\n    Simplifies a radical expression of the given degree (default is square root).\n    Parameters:\n        n (int): The number under the radical.\n        root_degree (int): The degree of the root (default=2 for square root).\n    \n    Returns:\n        sympy.core.expr.Expr: Simplified radical expression.\n    Examples:\n        >>> simplify_radical_expression(72)\n        6*sqrt(2)\n        >>> simplify_radical_expression(72, root_degree=3)\n        2*cbrt(9)\n        >>> simplify_radical_expression(500)\n        10*sqrt(5)\n    \"\"\"\n    # Use sympy nroot for finding principal nth root and apply simplification\n    if n < 0 and root_degree % 2 == 0:\n        raise ValueError(\"Cannot take even root of a negative number\")\n    radical = sympy.root(n, root_degree)\n    return sympy.simplify(radical)",
        "def square_root(value):\n    \"\"\"\n    Calculate the square root of a given value.\n    Parameters:\n    - value (int, float, or sympy expression): The value from which to extract the square root.\n    \n    Returns:\n    - float or sympy expression: The square root of the provided value.\n    Examples:\n    >>> square_root(9)\n    3.0\n    >>> square_root(sp.Rational(1, 2))\n    sqrt(2)/2\n    \"\"\"\n    if isinstance(value, (int, float)):\n        return math.sqrt(value)\n    else:\n        return sp.sqrt(value)",
        "def combine_radicals(expression1, expression2, operation='add'):\n    \"\"\"\n    Combine two radical expressions using specified arithmetic operations (add, subtract, multiply, divide).\n    \n    Parameters:\n        expression1 (sympy.Expr): The first expression involving radicals.\n        expression2 (sympy.Expr): The second expression involving radicals.\n        operation (str): Specifies the type of arithmetic operation: 'add', 'subtract', 'multiply', 'divide'.\n    Returns:\n        sympy.Expr: Result of combining the two expressions.\n    \n    Examples:\n        >>> combine_radicals(sp.sqrt(2), sp.sqrt(8), 'multiply')\n        4\n        >>> combine_radicals(sp.sqrt(2), sp.sqrt(8), 'add')\n        3*sqrt(2)\n    \"\"\"\n    if operation == 'add':\n        result = expression1 + expression2\n    elif operation == 'subtract':\n        result = expression1 - expression2\n    elif operation == 'multiply':\n        result = expression1 * expression2\n    elif operation == 'divide':\n        result = expression1 / expression2\n    else:\n        raise ValueError(\"Unsupported operation. Choose from 'add', 'subtract', 'multiply', 'divide'.\")\n    return sp.simplify(result)",
        "def sum_of_squares(*args):\n    \"\"\"\n    Returns the sum of squares of provided arguments.\n    Parameters:\n    - args: float or int, values to be squared and summed\n    Returns:\n    - float, the sum of the squares of the provided inputs\n    Examples:\n    >>> sum_of_squares(1, 2, 3)\n    14\n    >>> sum_of_squares(4, 5)\n    41\n    \"\"\"\n    return sum(x**2 for x in args)",
        "def calculate_square_root(x, exact=False):\n    \"\"\" Compute the square root of a number with an option to force exact symbolic results.\n    Parameters:\n    - x (int, float, complex): The number from which to calculate the square root.\n    - exact (bool): If True, returns an exact symbolic result; otherwise, return a numerical approximation.\n    Returns:\n    - sp.core.expr.Expr or float: The square root of the number, either as a symbolic expression or as a numerical value.\n    \n    Examples:\n    >>> calculate_square_root(16)\n    4.0 \n    >>> calculate_square_root(16, exact=True)\n    4\n    >>> calculate_square_root(3, exact=True)\n    sqrt(3)\n    >>> calculate_square_root(-1)\n    1j\n    \"\"\"\n    if exact:\n        return sp.sqrt(x)\n    else:\n        if isinstance(x, complex) or x < 0:\n            return complex((sp.sqrt(x)).evalf())\n        else:\n            return float((sp.sqrt(x)).evalf())",
        "def find_hyperbola_foci(a, b):\n    \"\"\"\n    Given the constants a and b from the hyperbola standard form equation (x^2/a^2 - y^2/b^2 = 1),\n    compute the coordinates of the foci.\n    Parameters:\n    - a: Semi-major axis of the hyperbola (horizontal).\n    - b: Semi-minor axis of the hyperbola (vertical).\n    Returns:\n    - tuple: Coordinates of the two foci of the hyperbola.\n    Example:\n    >>> find_hyperbola_foci(5, 3)\n    ((0, 5.83), (0, -5.83))\n    \"\"\"\n    c = sp.sqrt(a**2 + b**2)  # Distance from center to each focus\n    return ((0, float(c)), (0, -float(c)))",
        "def simplify_square_root(expression):\n    \"\"\"\n    Simplifies the square root of an expression using symbolic manipulation.\n    \n    Parameters:\n    - expression (int, float, or sympy expression): The expression under the square root.\n    \n    Returns:\n    - sympy expression: Simplified form of the square root.\n    \n    Examples:\n    - Numerical example:\n    >>> simplify_square_root(24)\n    2*sqrt(6)\n    \n    - Symbolic example:\n    >>> x = sp.symbols('x')\n    >>> simplify_square_root(x**2 - 9)\n    x - 3\n    \"\"\"\n    return sp.sqrt(sp.sympify(expression)).simplify()",
        "def simplify_radical(number):\n    \"\"\"\n    Simplify the square root of a number into its simplest radical form using prime factorization.\n    Parameters:\n        number (int): The number under the radical.\n    \n    Returns:\n        sympy expression: The simplified radical expression.\n    \n    Examples:\n        >>> simplify_radical(72)\n        6*sqrt(2)\n        >>> simplify_radifier(50)\n        5*sqrt(2)\n    \"\"\"\n    if number < 0:\n        raise ValueError(\"Input must be a non-negative integer\")\n    \n    factors = primefactors(number)\n    inside = 1\n    outside = 1\n    for p in factors:\n        count = factors.count(p)\n        outside *= p ** (count // 2)\n        inside *= p ** (count % 2)\n    \n    if inside == 1:\n        return Integer(outside)  # No radical needed if inside is 1\n    else:\n        return Mul(Integer(outside), Pow(Integer(inside), 1/2))"
    ],
    "Function Operations": [
        "def simplify_expression(expression):\n    \"\"\"\n    Simplifies algebraic expressions including rational functions.\n    Parameters:\n    expression (str): A string representation of the algebraic expression to be simplified.\n    Returns:\n    sympy.Expr: Simplified expression.\n    Examples:\n    >>> simplify_expression(\"x**2 + 2*x + 1\")\n    (x + 1)**2\n    >>> simplify_expression(\"(x**2 - 1)/(x + 1)\")\n    x - 1\n    \"\"\"\n    x = symbols('x')\n    expr = simplify(expression)\n    return expr",
        "def expand_expression(expr):\n    \"\"\"\n    Expands a given algebraic expression.\n    Parameters:\n        expr (str): A string representing the algebraic expression to be expanded.\n    Returns:\n        sympy expression: The expanded algebraic expression.\n    Examples:\n        >>> print(expand_expression('(a+b)^2'))\n        a**2 + 2*a*b + b**2\n        >>> print(expand_expression('(x+2)*(x-3)'))\n        x**2 - x - 6\n    \"\"\"\n    x, y, a, b, c = symbols('x y a b c')\n    expanded_expr = expand(expr)\n    return expanded_expr",
        "class FunctionOperationTool:\n    \"\"\"\n    A tool for performing operations on mathematical functions including addition, subtraction,\n    multiplication, division, and composition.\n    \n    Methods\n    -------\n    compose(f, g, x):\n        Returns the composition of functions f(g(x)).\n        \n    evaluate_function(f, x_val):\n        Returns the evaluation of function f at x = x_val.\n        \n    operate_functions(f, g, operation, x):\n        Performs an arithmetic operation (add, subtract, multiply, divide) on functions f and g.\n    \"\"\"\n    \n    @staticmethod\n    def compose(f, g, x):\n        \"\"\"\n        Compose two functions f and g.\n        Parameters:\n            f (str): A string representing function f.\n            g (str): A string representing function g.\n            x (Symbol): The symbol used in the function definitions.\n        \n        Returns:\n            function: The composed function f(g(x)).\n        \n        Example:\n            >>> f = 'x**2'\n            >>> g = 'x + 1'\n            >>> x = symbols('x')\n            >>> FunctionOperationTool.compose(f, g, x)\n            (x + 1)**2\n        \"\"\"\n        f = sympify(f)\n        g = sympify(g)\n        return f.subs(x, g)\n    \n    @staticmethod\n    def evaluate_function(f, x_val):\n        \"\"\"\n        Evaluate the function f at a specific value of x.\n        Parameters:\n            f (str): A function expression in string format.\n            x_val (numeric): The value at which to evaluate f.\n        \n        Returns:\n            numeric: The result of f evaluated at x = x_val.\n        \n        Example:\n            >>> f = 'x**2 + 2*x + 1'\n            >>> FunctionOperationTool.evaluate_function(f, 3)\n            16\n        \"\"\"\n        x = symbols('x')  # Assuming x is the variable used\n        f = sympify(f)\n        return f.subs(x, x_val)\n    \n    @staticmethod\n    def operate_functions(f, g, operation, x):\n        \"\"\"\n        Perform arithmetic operations on two functions.\n        Parameters:\n            f (str): First function in string format.\n            g (str): Second function in string format.\n            operation (str): Operation ('add', 'subtract', 'multiply', 'divide').\n            x (Symbol): The symbol used in the function definitions.\n        \n        Returns:\n            function: The result of the specified operation on f and g.\n        \n        Example:\n            >>> f = 'x**2'\n            >>> g = 'x + 1'\n            >>> x = symbols('x')\n            >>> FunctionOperationTool.operate_functions(f, g, 'add', x)\n            x**2 + x + 1\n        \"\"\"\n        f = sympify(f)\n        g = sympify(g)\n        if operation == 'add':\n            return f + g\n        elif operation == 'subtract':\n            return f - g\n        elif operation == 'multiply':\n            return f * g\n        elif operation == 'divide':\n            return f / g\n        else:\n            raise ValueError(\"Unsupported operation\")",
        "def substitute_expression(expression, substitutions):\n    \"\"\"\n    Substitute values or variables in a polynomial expression.\n    Parameters:\n    expression (str): The polynomial expression for substitution.\n    substitutions (dict): Dictionary of substitutions in form {variable:value}\n    Returns:\n    str: The result of the expression after performing substitutions.\n    Example:\n    >>> substitute_expression(\"x**2 + 3*x + 2\", {x: 2})\n    '12'\n    \"\"\"\n    expr = sp.sympify(expression)\n    substituted_expr = expr.subs(substitutions)\n    return str(substituted_expr)",
        "def factor_expression(expression):\n    \"\"\"\n    Factor a polynomial expression.\n    Parameters:\n    expression (str): The polynomial expression to factor.\n    Returns:\n    str: Factored form of the polynomial.\n    Example:\n    >>> factor_expression(\"x**2 + 5*x + 6\")\n    '(x + 2)*(x + 3)'\n    \"\"\"\n    x = sp.symbols('x')\n    expr = sp.sympify(expression)\n    factored_expr = sp.factor(expr)\n    return str(factored_expr)",
        "def function_transformation(f_expr, stretch_factor=1, shift_factor=0):\n    \"\"\"\n    Apply vertical stretching and shifting transformations to a function.\n    \n    Parameters:\n        f_expr (str): The expression of the function f(x).\n        stretch_factor (int/float): Factor by which the function should be stretched.\n        shift_factor (int/float): Factor by which the function should be shifted upwards.\n    \n    Returns:\n        sympy.Expr: The transformed function expression.\n    \n    Example:\n        function_transdeparture(f_expr='x**2', stretch_factor=2, shift_factor=3)\n        # Returns: 2*x**2 + 3\n    \"\"\"\n    x = symbols('x')\n    f = sympify(f_expr)\n    return stretch_factor * f + shift_factor",
        "def manipulate_and_simplify(expr_str):\n    \"\"\"\n    Manipulates and simplifies general algebraic expressions including those with trigonometric and radical components.\n    \n    Parameters:\n        expr_str (str): A string representing the algebraic expression to be manipulated and simplified.\n    \n    Returns:\n        sympy.core.expr.Expr: A simplified symbolic expression.\n    \n    Examples:\n        >>> manipulate_and_simplify('x^2 + 2*x + 1')\n        x**2 + 2*x + 1\n        \n        >>> manipulate_and_simplify('(x**2 + 2*x + 1)/(x + 1)')\n        x + 1\n        \n        >>> manipulate_and_simplify('cos(x)**2 + sin(x)**2')\n        1\n        \n        >>> manipulate_and_simplify('sqrt(x**2)')\n        |x|\n    \"\"\"\n    x = symbols('x')\n    expr = simplify(expr_str)\n    return expr",
        "def substitute_and_evaluate_function(function, substitutions):\n    \"\"\"\n    Substitute provided expression(s) or value(s) into a function and evaluate it.\n    \n    Parameters:\n    - function : sympy.Expr\n      The function or expression in which substitution needs to be performed.\n    - substitutions : dict\n      A dictionary mapping from symbols (variables in the function) to the values or expressions that should replace them.\n    \n    Returns:\n    - sympy.Expr\n      The result of the function after performing the substitutions.\n    \n    Example:\n    >>> import sympy as sp\n    >>> x, y = sp.symbols('x y')\n    >>> f = x**2 + 3*y\n    >>> substitute_and_evaluate_function(f, {x: 1, y: 2})\n    7\n    >>> g = x + y\n    >>> substitute_and_evaluate_function(f, {y: g})\n    x**2 + 3*(x + y)\n    \"\"\"\n    from sympy import sympify\n    function = sympify(function)\n    return function.subs(substitutions)",
        "def function_evaluator(func, value):\n    \"\"\"\n    Evaluates a function at a specified point or expression.\n    Parameters:\n    func (sp.Expr): The function expression in terms of 'x'\n    value: The point or expression at which to evaluate the function\n    \n    Returns:\n    The result of the function evaluation.\n    Example:\n    >>> x = sp.symbols('x')\n    >>> func = x**2 + x + 1\n    >>> function_evaluator(func, 3)\n    13\n    \"\"\"\n    x = sp.symbols('x')\n    return func.subs(x, value)",
        "def simplify_and_manipulate_function(function):\n    \"\"\"\n    Simplify and manipulate a function using algebraic properties to obtain simplified or equivalent expressions.\n    \n    Parameters:\n    - function : sympy.Expr\n      The function or expression to be simplified and manipulated.\n    \n    Returns:\n    - sympy.Expr\n      A simplified version of the input function based on algebraic and equivalence properties.\n    \n    Example:\n    >>> import sympy as sp\n    >>> x, y = sp.symbols('x y')\n    >>> f = x**2 - x*2 + x\n    >>> simplify_and_manipulate_function(f)\n    x**2 - x\n    \"\"\"\n    from sympy import simplify\n    return simplify(function)",
        "def is_function_even_or_odd(f_expr):\n    \"\"\"\n    Determine if the function is even, odd, or neither.\n    \n    Parameters:\n        f_expr (str): The function expression as a string.\n    \n    Returns:\n        str: 'even', 'odd', or 'neither'.\n    \n    Example:\n        is_function_even_or_odd('x**2')\n        # Returns 'even'\n    \"\"\"\n    x = symbols('x')\n    f = sympify(f_expr)\n    if f.subs(x, -x) == f:\n        return 'even'\n    elif f.subs(x, -x) == -f:\n        return 'odd'\n    else:\n        return 'neither'",
        "def is_expression_equivalent(expr1, expr2, var_dict={}):\n    \"\"\"\n    Check if two expressions are equivalent under optional variable substitutions.\n    Parameters:\n    - expr1 (sympy expression): First expression to compare.\n    - expr2 (sympy expression): Second expression to compare.\n    - var_dict (dict, optional): If provided, the variables in expr1 and expr2 are substituted\n      according to this dictionary before comparison.\n    Returns:\n    - bool: True if the expressions are equivalent, False otherwise.\n    Examples:\n    >>> x, y = sp.symbols('x y')\n    >>> expr1 = x**2 + 2*x + 1\n    >>> expr2 = (x + 1)**2\n    >>> is_expression_equivalent(expr1, expr2)\n    True\n    \"\"\"\n    if var_dict:\n        expr1 = substitute_expression(expr1, var_dict)\n        expr2 = substitute_expression(expr2, var_dict)\n    # Simplify both expressions and check for equality\n    return sp.simplify(expr1 - expr2) == 0",
        "def function_composer(f, g):\n    \"\"\"\n    Creates a new function that is the composition of two given functions f and g, denoted as f(g(x)).\n    Parameters:\n    f (sp.Expr): The outer function, a sympy expression involving 'x'\n    g (sp.Expr): The inner function, a sympy expression involving 'x'\n    \n    Returns:\n    sp.Expr: The composed function f(g(x))\n    Example:\n    >>> x = sp.symbols('x')\n    >>> f = x**2\n    >>> g = x + 2\n    >>> h = function_composer(f, g)\n    >>> h\n    (x + 2)**2\n    \"\"\"\n    x = sp.symbols('x')\n    # Substitute 'x' in 'f' with 'g'\n    return f.subs(x, g)",
        "def substitute_expression(func, var_dict):\n    \"\"\"\n    Substitute variables in an algebraic function with values or other expressions provided in a dictionary.\n    Parameters:\n    - func (sympy expression): The function where the substitution must be performed.\n    - var_dict (dict): A dictionary with variable-expression pairs where keys are sympy symbols \n      (or their string representations) to be substituted in func, and the values are the \n      corresponding values or expressions (as sympy expressions or anything that can be converted to sympy expressions).\n    Returns:\n    - sympy expression: The resulting function after substitution.\n    Examples:\n    >>> x, y = sp.symbols('x y')\n    >>> f = x**2 + y**2\n    >>> substitute_expression(f, {x: 1, y: x+1})\n    x**2 + (x + 1)**2\n    \"\"\"\n    # Convert all dict keys to sympy Symbols if they are strings\n    var_dict = {sp.sympify(k): sp.sympify(v) for k, v in var_dict.items()}\n    return func.subs(var_dict)",
        "def check_function_properties(expression, property_name):\n    \"\"\"\n    Check certain properties of a function such as even, odd, and periodicity.\n    \n    Parameters:\n    - expression (str): The function expression in string format.\n    - property_name (str): The name of the property to check ('even', 'odd', 'periodic').\n    \n    Returns:\n    - Boolean indicating if the function has the specified property or not.\n    \n    Examples:\n    >>> check_function_properties('x**2', 'even')\n    True\n    >>> check_function_black('sin(x)', 'odd')\n    True\n    \"\"\"\n    x = symbols('x')\n    expr = sympify(expression)\n    if property_name == 'even':\n        return expr.subs(x, -x) == expr\n    elif property_name == 'odd':\n        return expr.subs(x, -x) == -expr\n    elif property_name == 'periodic':\n        # This is a simplistic check and might need further refinements for robustness.\n        period = solveset(expr.subs(x, x + S.Pi) - expr, x, domain=S.Reals)\n        return period != S.EmptySet\n    else:\n        return False",
        "def expression_modifier(func, form):\n    \"\"\"\n    Modifies a function expression by applying a specified form transformation (e.g., 1-x, x/3).\n    Parameters:\n    func (sp.Expr): The function expression in terms of 'x'\n    form (sp.Expr): The algebraic transformation to apply to the variable 'x' in func\n    \n    Returns:\n    sp.Expr: The modified function expression.\n    Example:\n    >>> x = sp.symbols('x')\n    >>> func = sp.exp(x)\n    >>> form = 1 - x\n    >>> expression_modifier(func, form)\n    exp(1 - x)\n    \"\"\"\n    x = sp.symbols('x')\n    return func.subs(x, form)",
        "def evaluate_function(function_expr, point):\n    \"\"\"\n    Evaluates a function at a specific point or set of points.\n    Parameters:\n    - function_expr (str or sympy.Expr): The function to be evaluated, expressed in symbolic form.\n    - point (dict): A dictionary representing the point at which the function is to be evaluated, with variable names as keys.\n    Returns:\n    - type: Description of the returned type of result either numerical value or simplified symbolic expression.\n    Examples:\n    >>> evaluate_function('x**2 + y**2', {'x': 3, 'y': 4})\n    25\n    >>> evaluate_function('sin(x) + cos(y)', {'x': 'pi/4', 'y': 'pi/3'})\n    sqrt(2)/2 + 1/2\n    \"\"\"\n    # Convert the string input to a sympy expression if it's not already one\n    if isinstance(function_expr, str):\n        function_expr = sp.sympify(function_expr)\n    \n    # Sympy's subs and evalf methods are used for substitution and numerical evaluation\n    return function_expr.subs(point).evalf()",
        "def evaluate_and_manipulate_function(func, var, transformation):\n    \"\"\"\n    Apply a transformation to the function variable before evaluating the function.\n    Parameters:\n    * func (sympy Lambda or expression): The function to evaluate.\n    * var (sympy Symbol): The primary variable of the function.\n    * transformation (sympy expression): The transformation to apply to the variable.\n    Returns:\n    * sympy expression: The function evaluated at the transformed variable.\n    Example:\n    >>> from sympy.abc import x\n    >>> f = sp.Lambda(x, x**2 + 3*x + 2)\n    >>> transformed_eval = evaluate_and_manipulate_function(f, x, 1-x)\n    >>> transformed_eval\n    x**2 - x + 2\n    \"\"\"\n    transformed_var = transformation.subs(var, func.args[0])\n    return func(transformed_var)",
        "def apply_and_simplify(expression, values):\n    \"\"\"\n    Substitute values into an algebraic expression and simplify the result.\n    \n    Parameters:\n    - expression (str): The algebraic expression.\n    - values (dict): A dictionary where keys are variable names and values are the numerical values to substitute.\n    \n    Returns:\n    - float: The simplified numerical value of the expression after substitution.\n    \n    Example:\n    >>> apply_and_simplify('a**2 + 2*a*b + b**2', {'a': 3, 'b': 4})\n    49.0\n    \"\"\"\n    expr_symbols = symbols(' '.join(values.keys()))\n    expr = simplify(expression)\n    return expr.subs(values).evalf()",
        "def compose_and_evaluate_functions(outer_func_expr, inner_func_expr, value):\n    \"\"\"\n    Composes two functions and evaluates the composed function at a specific value.\n    \n    Parameters:\n    outer_func_expr (sympy expr): The expression of the outer function.\n    inner_func_expr (sympy expr): The expression of the inner function.\n    value (numeric or sympy Symbol): The input value at which to evaluate the composite function.\n    \n    Returns:\n    numeric or sympy expr: Result of the composed function evaluated at the specified value.\n    \n    Example:\n    >>> x = symbols('x')\n    >>> outer_expr = x**2\n    >>> inner_expr = 2*x + 1\n    >>> compose_and_evaluate_functions(outer_expr, inner_expr, 3)\n    49\n    \"\"\"\n    x = symbols('x')\n    outer_func = Lambda(x, outer_func_expr)\n    inner_func = Lambda(x, inner_func_expr)\n    composed_func = Lambda(x, outer_func(inner_func(x)))\n    return composed_func(value)"
    ],
    "Ratios and Proportions": [
        "def calculate_constant_of_proportionality(x, y):\n    \"\"\"\n    Calculate the constant of proportionality in an inverse proportionality relationship.\n    Parameters:\n        x (float or int): The first variable in the proportionality.\n        y (float or int): The second variable in the proportionality.\n    Returns:\n        float: The constant of proportionality (k).\n    Examples:\n        >>> calculate_constant_of_proportionality(10, 2)\n        20.0\n        >>> calculate_constant_of_proportionality(5, 4)\n        20.0\n    \"\"\"\n    return x * y",
        "def solve_for_variable_in_inverse_proportionality(known_value, constant, solve_for='value1'):\n    \"\"\"\n    Solve for a variable in an inverse proportionality relationship given one variable and the constant.\n    This assumes the relationship is in the form `value1 * value2 = constant`.\n    The `solve_for` parameter determines which variable you are solving for.\n    Parameters:\n    - known_value (float or int): The known value of either `value1` or `value2`.\n    - constant (float or int): The constant of proportionality (k).\n    - solve_for (str): Specifies which value to solve for ('value1' or 'value2'). Default is 'value1'.\n    Returns:\n    - float: The calculated value of the unknown variable.\n    \n    Example:\n    >>> solve_for_variable_in_inverse_proportionality(4, 20, solve_for='value2')\n    5.0\n    >>> solve_for_variable_in_inverse_proportionality(3, 21, solve_for='value1')\n    7.0\n    \"\"\"\n    if solve_for == 'value1':\n        return constant / known_value\n    elif solve_for == 'value2':\n        return constant / known_value\n    else:\n        raise ValueError(\"Invalid 'solve_for' argument. Use 'value1' or 'value2'.\")",
        "def simplify_ratio(a, b):\n    \"\"\"\n    Simplify a ratio given by two numbers a and b.\n    Parameters:\n    a (int/float): Numerator of the ratio.\n    b (int/float): Denominator of the. ratio\n    Returns:\n    tuple: A simplified ratio as a tuple of integers.\n    Examples:\n    >>> simplify_ratio(10, 5)\n    (2, 1)\n    >>> simplify_ratio(15, 9)\n    (5, 3)\n    \"\"\"\n    simplified = Fraction(a, b)\n    return (simplified.numerator, simplified.denominator)",
        "def proportional_area_length(length_ratio, area_or_length='area'):\n    \"\"\"\n    Calculates the proportional area or length based on the square of the length ratio for areas or ratio for length.\n    Parameters:\n    length_ratio (float or tuple): Ratio of lengths.\n    area_or_length (str): Determines whether to compute area ('area') or length ('length') relationship.\n    Returns:\n    float: Proportional area or length.\n    Examples:\n    >>> proportional_area_length(2, 'area')\n    4.0\n    >>> proportional_area_length((3, 2), 'length')\n    1.5\n    \"\"\"\n    if isinstance(length_ratio, tuple):\n        ratio_val = length_ratio[0] / length_ratio[1]\n    else:\n        ratio_val = length_ratio\n        \n    if area_or_length.lower() == 'area':\n        return ratio_val ** 2\n    return ratio_val",
        "def calculate_ratio(a, b):\n    \"\"\"\n    Calculates the simplest form of the ratio between two quantities.\n    Parameters:\n    a (numeric): The first quantity.\n    b (numeric): The second quantity.\n    Returns:\n    tuple: Simplified ratio of a to b.\n    Examples:\n    >>> calculate_ratio(150, 100)\n    (3, 2)\n    >>> calculate_scenario(10, 25)\n    (2, 5)\n    \"\"\"\n    return nsimplify(a/b).as_numer_denom()",
        "def square_ratio_to_area_ratio(side_ratio):\n    \"\"\"\n    Given the ratio of the sides of two squares, calculate the ratio of their areas.\n    Parameters:\n    side_ratio (float): Ratio of one side to another.\n    Returns:\n    float: Ratio of the areas based on the side ratio.\n    Examples:\n    >>> square_ratio_to_area_ratio(2)\n    4.0\n    \"\"\"\n    return side_ratio ** 2",
        "def calculate_geometry_proportion(a_distance, b_distance, a_area):\n    \"\"\"\n    Calculate the area of a second geometry given the ratio of distances and one known area.\n    Parameters:\n    a_distance (float): Length from a reference point to a proven area.\n    b_distance (float): Length from the same reference point to an unknown area.\n    a_area (float): Known area at distance a_distance.\n    Returns:\n    float: Calculated area for the location at b_distance.\n    Examples:\n    >>> calculate_geometry_proposition(1, 2, 50)\n    12.5\n    \"\"\"\n    ratio = (a_distance / b_distance) ** 2\n    return a_area * ratio",
        "def check_inverse_proportionality(x, y, k):\n    \"\"\"\n    Check if the variables x and y satisfy the inverse proportionality relationship \\(xy = k\\).\n    Parameters:\n        x (float): First variable.\n        y (float): Second variable.\n        k (float): Constant of proportionality to check against.\n    Returns:\n        bool: True if \\(xy = k\\), False otherwise.\n    Examples:\n        >>> check_inverse_proportionality(10, 2, 20)\n        True\n        >>> check_inverse_proportionality(5, 5, 20)\n        False\n    \"\"\"\n    return abs(x * y - k) < 1e-10  # Using a tolerance for floating point arithmetic issues",
        "def scale_area_ratio(length_ratio):\n    \"\"\"\n    Calculate the scaling factor for the area based on the ratio of lengths.\n    Parameters:\n        length_ratio (float): The ratio of any two corresponding linear dimensions of two figures.\n    Returns:\n        float: The scaling factor for the areas of the two figures.\n    Examples:\n        >>> scale_area_ratio(2)\n        4.0\n        >>> scale_area_to_ratio(0.5)\n        0.25\n    \"\"\"\n    return length_ratio ** 2",
        "def simplify_expression(expression):\n    \"\"\"\n    Simplifies algebraic expressions and fractions.\n    \n    Parameters:\n    expression (str or sympy expression): The algebraic expression to simplify.\n    Returns:\n    sympy expression: Simplified algebraic expression.\n    Examples:\n    >>> simplify_expression('4*x/8')\n    x/2\n    \"\"\"\n    return simplify(expression)"
    ],
    "Polynomial Expansions": [
        "def polynomial_expansion(poly):\n    \"\"\"\n    Expand a polynomial expression using symbolic computation.\n    The polynomial is expressed as a string. \n    \n    Parameters:\n    poly (str): The polynomial expression string.\n    \n    Returns:\n    str: The expanded polynomial expression string.\n    \"\"\"\n    import sympy as sp\n    x = sp.symbols('x')\n    poly = sp.sympify(poly)\n    result = sp.expand(poly)\n    return str(result)",
        "def polynomial_expansion(binomial_expression, n):\n    \"\"\"\n    Expands a binomial expression of the form (a+b)^n using the Binomial theorem.\n    Parameters:\n        binomial_expression (sympy expression): The binomial to expand, e.g., x + y.\n        n (int): The exponent to which the binomial is raised.\n    Returns:\n        sympy expression: The expanded binomial expression.\n    Examples:\n        >>> x, y = symbols('x y')\n        >>> polynomial_expansion(x + y, 2)\n        x**2 + 2*x*y + y**2\n        >>> polynomial_expansion(x - y, 3)\n        x**3 - 3*x**2*y + 3*x*y**2 - y**3\n    \"\"\"\n    return expand(binomial_expression**n)",
        "def apply_identity(a, b, identity_type):\n    \"\"\"\n    Apply various polynomial identities such as difference of squares, sum/difference of cubes, or perfect square formula.\n    Parameters:\n        a, b (sympy expressions): The expressions or terms for the identity application.\n        identity_type (str): Type of identity ('difference_of_squares', 'sum_of_cubes', 'difference_of_cubes', 'perfect_square').\n    Returns:\n        sympy expression: Result of applying the given identity to a and b.\n    Examples:\n        >>> x, y = symbols('x y')\n        >>> apply_identity(x, y, 'difference_of_squares')\n        (x - y)*(x + y)\n        >>> apply_identity(x, y, 'sum_of_cubes')\n        (x + y)*(x**2 - x*y + y**2)\n        >>> apply_identity(x, y, 'difference_of_cubes')\n        (x - y)*(x**2 + x*y + y**2)\n        >>> apply_identity(x, 2, 'perfect_square')\n        x**2 + 4*x + 4\n    \"\"\"\n    if identity_type == 'difference_of_squares':\n        return (a - b) * (a + b)\n    elif identity_type == 'sum_of_cubes':\n        return (a + b) * (a**2 - a*b + b**2)\n    elif identity_type == 'difference_of_cubes':\n        return (a - b) * (a**2 + a*b + b**2)\n    elif identity_type == 'perfect_square':\n        return (a + b)**2\n    else:\n        raise ValueError(\"Unknown identity type provided\")",
        "def expand_polynomial(expression):\n    \"\"\"\n    Expands a polynomial expression into its simplified form.\n    Parameters:\n    expression (str): A string representing the polynomial expression to expand.\n    Returns:\n    str: The expanded form of the polynomial.\n    Examples:\n    >>> expand_polynomial('(x + 1)*(x - 2) - x*(x - 1)')\n    'x**2 - 3*x + 2'\n    \"\"\"\n    x = symbols('x')\n    expanded_expr = expand(expression)\n    return str(expanded_expr)",
        "def analyze_polynomial(expression):\n    \"\"\"\n    Analyze a polynomial expression to simplify it, compute its degree, and list its coefficients.\n    \n    Parameters:\n        expression (str): Polynomial expression as a string, e.g. 'x^2 + 3*x + 2'.\n    \n    Returns:\n        dict: A dictionary containing the simplified polynomial, degree, and coefficients.\n    \n    Examples:\n        >>> result = analyze_polynomial('x^2 + 3*x + 2')\n        >>> print(\"Simplified:\", result['simplified'])\n        >>> print(\"Degree:\", result['degree'])\n        >>> print(\"Coefficients:\", result['coefficients'])\n        Simplified: x**2 + 3*x + 2\n        Degree: 2\n        Coefficients: [1, 3, 2]\n    \"\"\"\n    # Define the symbol\n    x = symbols('x')\n    expression = expression.replace('^', '**')\n    poly = Poly(eval(expression), x)\n    \n    simplified = simplify(poly.as_expr())\n    degree = poly.degree()\n    coefficients = poly.all_coeffs()\n    \n    return {\n        'simplified': simplified,\n        'degree': degree,\n        'coefficients': coefficients\n    }",
        "def polynomial_operation(p1, p2, operation='expand'):\n    \"\"\"\n    Perform operations on two polynomial expressions including expansion, simplification, and factoring.\n    \n    Parameters:\n        p1 (str): The first polynomial as a string, e.g. 'x^2 + 3*x + 2'.\n        p2 (str): The second polynomial as a string, e.g. 'x + 1'.\n        operation (str): The operation to perform, options include 'expand', 'simplify', 'factor'.\n    \n    Returns:\n        sympy.Expr: The result of the operation on the polynomial expressions.\n    \n    Examples:\n        >>> print(polynomial_operation('x^2 + 3*x + 2', 'x + 1', 'expand'))\n        x**3 + 4*x**2 + 5*x + 2\n    \n        >>> print(polygonomial_operation('x**2 - 1', '', 'factor'))\n        (x - 1)*(x + 1)\n    \"\"\"\n    # Convert input strings into symbolic expressions\n    x = symbols('x')\n    p1 = p1.replace('^', '**')\n    p2 = p2.replace('^', '**')\n    poly1 = eval(p1)\n    poly2 = eval(p2) if p2 else 0\n    \n    if operation == 'expand':\n        result = expand(poly1 * poly2)\n    elif operation == 'simplify':\n        result = simplify(p1 + p2)\n    elif operation == 'factor':\n        result = factor(poly1)\n    else:\n        raise ValueError(\"Unknown operation: valid options are 'expand', 'simplify', 'factor'.\")\n    \n    return result",
        "def polynomial_operations(poly1, poly2, ops):\n    \"\"\"\n    Perform polynomial operations such as addition, subtraction\n    and multiplication. The polynomials are expressed as a list\n    of coefficients starting from the term with highest degree.\n    \n    Parameters:\n    poly1 (list of int/float): Coefficients of the first polynomial.\n    poly2 (list of int/float): Coefficients of the second polynomial.\n    ops (str): The operation to be performed: 'add', 'sub' or 'mul'.\n    \n    Returns:\n    result (list of int/float): The coefficients of the result polynomial.\n    \"\"\"\n    import numpy as np\n    \n    if ops == 'add':\n        result = list(np.polyadd(poly1, poly2))\n    elif ops == 'sub':\n        result = list(np.polysub(poly1, poly2))\n    elif ops == 'mul':\n        result = list(np.polymul(poly1, poly2))\n    else:\n        raise ValueError(\"Unsupported operation. Choose from 'add', 'sub', 'mul'.\")\n    \n    return result",
        "def polynomial_product(expressions):\n    \"\"\"\n    Multiplies given polynomial expressions and returns the product as a simplified expression.\n    Parameters:\n    expressions (list of str): A list of string representations of polynomial expressions.\n    Returns:\n    str: The product of the polynomial expressions in its simplest form.\n    Examples:\n    >>> polynomial_product(['x + 1', 'x - 1', 'x'])\n    'x**3 - x'\n    \"\"\"\n    x = symbols('x')\n    product = 1\n    for expr in expressions:\n        product *= simplify(expr)\n    return str(expand(product))",
        "def polynomial_eval(poly, x):\n    \"\"\"\n    Evaluate a polynomial at specific value x. The polynomial\n    is expressed as a list of coefficients starting from the term \n    with highest degree.\n    \n    Parameters:\n    poly (list of int/float): Coefficients of the polynomial.\n    x (int/float): The value of x for evaluation.\n    \n    Returns:\n    result (int/float): The result of the polynomial evaluation.\n    \"\"\"\n    import numpy as np\n    \n    result = np.polyval(poly, x)\n    return result",
        "def evaluate_polynomial(expression, value):\n    \"\"\"\n    Evaluates a polynomial at a specific value of x.\n    Parameters:\n    expression (str): The polynomial expression as a string.\n    value (int or float): The value to substitute into the polynomial.\n    Returns:\n    int or float: The result of the polynomial evaluation.\n    Examples:\n    >>> evaluate_polynomial('x**2 - 3*x + 2', 2)\n    0\n    \"\"\"\n    x = symbols('x')\n    poly = simplify(expression)\n    return poly.subs(x, value)",
        "def collect_terms(expression):\n    \"\"\"\n    Simplifies a polynomial by collecting like terms and combining them.\n    Parameters:\n    expression (str): A string representing the polynomial expression.\n    Returns:\n    str: The simplified polynomial with like terms combined.\n    Examples:\n    >>> collect_terms('x**2 + 3*x + x + x**2')\n    '2*x**2 + 4*x'\n    \"\"\"\n    x = symbols('x')\n    simplified_expr = simplify(expression)\n    return str(simplified_expr)",
        "def polynomial_coefficient(expanded_poly, term):\n    \"\"\"\n    Find the coefficient of a specific term from \n    the expanded form of a polynomial. The polynomial\n    and term are expressed as strings.\n    \n    Parameters:\n    expanded_poly (str): The expanded polynomial expression string.\n    term (str): The specific term expression string.\n    \n    Returns:\n    int/float: The coefficient of the specific term.\n    \"\"\"\n    import sympy as sp\n    expanded_poly = sp.sympify(expanded_poly)\n    coefficient = expanded_poly.coeff(term)\n    return coefficient"
    ],
    "Absolute Value": [
        "def calculate_absolute_value(number):\n    \"\"\"\n    Calculate the absolute value of a given number.\n    Parameters:\n    - number (float or int): A number whose absolute value is to be calculated.\n    Returns:\n    - float: The absolute value of the given number.\n    \n    Examples:\n    >>> calculate_absolute_value(-5)\n    5\n    >>> calculate_absolute_value(3.5)\n    3.5\n    \"\"\"\n    return abs(number)",
        "def distance_on_number_line(x1, x2):\n    \"\"\"\n    Compute the distance between two points on the real number line using absolute value.\n    Parameters\n    ----------\n    x1 : float\n        The first point on the number line.\n    x2 : float\n        The second point on the number line.\n    Returns\n    -------\n    float\n        The distance between the two points on the number line.\n    Examples\n    --------\n    >>> distance_on_number_line(3, 7)\n    4\n    >>> distance_on_number_line(-3, 7)\n    10\n    \"\"\"\n    import math\n    return math.fabs(x1 - x2)",
        "def simplify_nested_absolute_values(expr):\n    \"\"\"\n    Simplify expressions involving nested absolute values.\n    Parameters\n    ----------\n    expr : sympy.Expr\n        The expression containing nested absolute values.\n    Returns\n    -------\n    sympy.Expr\n        The simplified expression.\n    Examples\n    --------\n    >>> from sympy import Abs, symbols\n    >>> x = symbols('x')\n    >>> expr = Abs(Abs(x) - 3)\n    >>> simplify_nested_absolute_values(expr)\n    Abs(x - 3)\n    \"\"\"\n    from sympy import simplify\n    return simplify(expr)",
        "def solve_absolute_value_equation(a, b, c):\n    \"\"\"\n    Solve the absolute value equation of the form |ax + b| = c.\n    Parameters:\n    - a (int or float): The coefficient of x in the absolute value expression.\n    - b (int or float): The constant term inside the absolute value expression.\n    - c (int or float): The right-hand side constant that the absolute value expression equals to.\n    Returns:\n    - list: A list containing the two possible solutions for x if they exist or mentioning no solutions.\n      The equations considered are: ax + b = c and ax + b = -c\n    Examples:\n    >>> solve_absolute_value_equation(1, -3, 5)\n    [8.0, -2.0]\n    >>> solve_absolute_value_equation(1, -3, -5)\n    'No real solutions'\n    \"\"\"\n    if c < 0:\n        return 'No real solutions'  # The absolute value outputs can't be negative\n    # ax + b = c\n    sol1 = (c - b) / a\n    # ax + b = -c\n    sol2 = (-c - b) / a\n    \n    # Check if sol1 and sol2 are not the same to avoid duplicate solutions\n    if sol1 == sol2:\n        return [sol1]\n    return [sol1, sol2]",
        "def compute_absolute_value(x):\n    \"\"\"\n    Compute the absolute value of a given number.\n    Parameters\n    ----------\n    x : float\n        The number for which to compute the absolute value.\n    Returns\n    -------\n    float\n        The absolute value of the input number.\n    Examples\n    --------\n    >>> compute_absolute_value(-5)\n    5\n    >>> compute_absolute_value(3.1416)\n    3.1416\n    \"\"\"\n    import math\n    return math.fabs(x)",
        "def is_within_absolute_value_condition(x, condition_value=1):\n    \"\"\"\n    Check if a number satisfies the condition |x|  condition_value.\n    Parameters\n    ----------\n    x : float\n        The number to check.\n    condition_value : float, optional\n        The value used in the condition, default is 1.\n    Returns\n    -------\n    bool\n        True if the absolute value of x is less than or equal to condition_value, False otherwise.\n    Examples\n    --------\n    >>> is_within_absolute_value_condition(0.5)\n    True\n    >>> is_within_absolute_value_condition(2, 3)\n    True\n    >>> is_within_absolute_value_condition(-2, 1)\n    False\n    \"\"\"\n    import math\n    return math.fabs(x) <= condition_value",
        "def absolute_value_difference(x, y):\n    \"\"\"\n    Calculates the absolute value of the difference between two numbers,\n    commonly used to determine the distance between points on a line.\n    Parameters:\n    - x (int or float): The first number.\n    - y (int or float): The second number.\n    Returns:\n    - int or float: The absolute value of the difference between x and y.\n    \n    Examples:\n    >>> absolute_value_difference(3, -2)\n    5\n    >>> absolute_value_difference(-5, -10)\n    5\n    \"\"\"\n    import numpy as np\n    return np.abs(x - y)",
        "def manipulate_and_compare_digits(x):\n    \"\"\"\n    Calculates the absolute difference between a number and its digit-reverse.\n    Parameters:\n    - x (int): A number to manipulate.\n    Returns:\n    - int: The absolute difference between the original number and its reversed version.\n    \n    Examples:\n    >>> manipulate_and_compare_digits(123)\n    198\n    >>> manipulate_and_compare_digits(210)\n    12\n    \"\"\"\n    # Reverse the digits of the integer x\n    reversed_x = int(str(x)[::-1])\n    return abs(x - reversed_x)",
        "def evaluate_absolute_condition(x, y, condition):\n    \"\"\"\n    Evaluates a condition involving absolute values.\n    Parameters:\n    - x (float or int): First value for comparison.\n    - y (float or int): Second value for comparison.\n    - condition (str): A string specifying the condition ('==', '<', '<=', '>', '>=')\n    Returns:\n    - bool: Result of the condition evaluation.\n    \n    Examples:\n    >>> evaluate_absolute_condition(3, -3, '==')\n    True\n    >>> evaluate_absolute_condition(-2, 2, '<')\n    False\n    \"\"\"\n    import operator\n    ops = {'==': operator.eq, '<': operator.lt, '<=': operator.le, '>': operator.gt, '>=': operator.ge}\n    return ops[condition](abs(x), abs(y))",
        "def complex_absolute_expressions(expr):\n    \"\"\"\n    Evaluate an expression that may involve nested absolute values or complex conditions using absolute values.\n    Parameters:\n    - expr (str): A mathematical expression as a string that includes absolute values.\n    Returns:\n    - float or int: The evaluated result of the expression.\n    \n    Examples:\n    >>> complex_absolute_expressions('abs(abs(-3) - 5)')\n    2\n    >>> complex_absolute_expressions('abs(-2 + abs(3 - 5))')\n    0\n    \"\"\"\n    from sympy import sympify, Abs\n    # Convert 'abs' to 'Abs' to make it compatible with sympy evaluation\n    expr = expr.replace('abs', 'Abs')\n    return sympify(expr).evalf()"
    ],
    "Rational Functions": [
        "def add_fractions(frac1, frac2):\n    \"\"\"\n    Adds two fractions.\n    Parameters:\n    frac1 (Fraction): The first fraction.\n    frac2 (Fraction): The second fraction.\n    Returns:\n    Fraction: The sum of the two fractions.\n    \"\"\"\n    return frac1 + frac2",
        "def find_rational_function_domain(expression):\n    \"\"\"\n    Calculates the domain of a rational function and returns it in interval notation.\n    Parameters:\n    expression (sympy.Expr): A rational expression involving a numerator and denominator.\n    Returns:\n    sympy.Set: The domain of the function represented in interval notation, excluding values that make the denominator zero.\n    Examples:\n    >>> from sympy import symbols, Rational\n    >>> x = symbols('x')\n    >>> expr = 1 / (x**2 - 4)\n    >>> find_rational_function_domain(expr)\n    Union(Interval.open(-oo, -2), Interval.open(-2, 2), Interval.open(2, oo))\n    \"\"\"\n    x = symbols('x')  # Assuming 'x' is the variable used, this can be parameterized\n    denominator = expression.as_numer_denom()[1]  # Extracting the denominator\n    zeros = solveset(denominator, x, domain=S.Reals)  # Find where denominator is zero\n    domain = S.Reals - zeros  # The domain is the real numbers excluding zeros of the denominator\n    return domain",
        "class RationalExpressionTool:\n    \"\"\"\n    A tool for manipulating and simplifying rational expressions using sympy.\n    \"\"\"\n    \n    @staticmethod\n    def simplify_expression(expr):\n        \"\"\"\n        Simplifies a given rational expression.\n        Parameters:\n        - expr (sympy.Expr): The rational expression to be simplified.\n        Returns:\n        - sympy.Expr: The simplified expression.\n        Example:\n        >>> x = sympy.symbols('x')\n        >>> RationalExpressionTool.simplify_expression((x**2 - 1)/(x - 1))\n        x + 1\n        \"\"\"\n        return simplify(expr)\n    \n    @staticmethod\n    def add_rational_expressions(expr1, expr2):\n        \"\"\"\n        Adds two rational expressions and simplifies the result.\n        Parameters:\n        - expr1, expr2 (sympy.Expr): The rational expressions to be added.\n        Returns:\n        - sympy.Expr: The resulting expression after addition and simplification.\n        Example:\n        >>> x = sympy.symbols('x')\n        >>> RationalExpressionTool.add_rational_expressions(x/(x+1), 1/(x-1))\n        (2*x)/(x**2 - 1)\n        \"\"\"\n        return simplify(expr1 + expr2)\n    \n    @staticmethod\n    def decompose_to_partial_fractions(expr):\n        \"\"\"\n        Decomposes a rational expression into partial fractions.\n        Parameters:\n        - expr (sympy.Expr): The rational expression to decompose.\n        Returns:\n        - sympy.Expr: The expression decomposed into partial fractions.\n        Example:\n        >>> x = sympy.symbols('x')\n        >>> RationalExpressionTool.decompose_to_partial_fractions(1/(x*(x+1)))\n        -1/(x + 1) + 1/x\n        \"\"\"\n        return apart(expr)",
        "def simplify_rational_expression(expr):\n    \"\"\"\n    Simplifies a given rational expression.\n    Parameters:\n        expr (sympy expression): The rational expression to simplify.\n    Returns:\n        sympy expression: The simplified form of the input expression.\n    Example:\n        >>> x = symbols('x')\n        >>> expr = (x**2 - 1) / (x - 1)\n        >>> simplify_rational_expression(expr)\n        x + 1\n    \"\"\"\n    return simplify(expr)",
        "def arithmetic_operations_on_fractions(frac1, frac2, operation='add'):\n    \"\"\"\n    Perform basic arithmetic operations on two fractions.\n    \n    Parameters:\n    - frac1 (Fraction): The first fraction.\n    - frac2 (Fraction): The second fraction.\n    - operation (str): Type of operation ('add', 'subtract', 'multiply', 'divide').\n    \n    Returns:\n    - Fraction: The result of the arithmetic operation.\n    \n    Example:\n    >>> f1 = Fraction(1, 2)\n    >>> f2 = Fraction(3, 4)\n    >>> arithmetic_operations_on_fractions(f1, f2, 'add')\n    Fraction(5, 4)\n    \"\"\"\n    if operation == 'add':\n        return frac1 + frac2\n    elif operation == 'subtract':\n        return frac1 - frac2\n    elif operation == 'multiply':\n        return frac1 * frac2\n    elif operation == 'divide':\n        return frac1 / frac2",
        "def simplify_fraction(frac):\n    \"\"\"\n    Simplifies a fraction to its lowest terms.\n    Parameters:\n    frac (Fraction): The fraction to be simplified.\n    Returns:\n    Fraction: The simplified fraction.\n    \"\"\"\n    return frac.limit_denominator()",
        "def unit_digit_from_division(numerator, denominator):\n    \"\"\"\n    Determine the units digit of the result of a division.\n    \n    Parameters:\n    - numerator (int): The numerator of the division.\n    - denominator (int): The denominator of the division.\n    \n    Returns:\n    - int: The units digit of the quotient.\n    \n    Example:\n    >>> unit_digit_from_division(123, 5)\n    6\n    \"\"\"\n    quotient = numerator // denominator\n    return quotient % 10",
        "def manipulate_algebraic_expression(expression, operation):\n    \"\"\"\n    Manipulates and simplifies an algebraic expression based on the specified operation.\n    Parameters:\n    expression (str): A string representing the math expression to manipulate.\n    operation (str): An operation to perform on the expression, such as 'simplify', 'square', or 'reciprocal'.\n    Returns:\n    sympy.Expr: The resulting expression after manipulation.\n    Examples:\n    >>> manipulate_algebraic_expression('x/(x**2 - 1)', 'reciprocal')\n    (x**2 - 1)/x\n    >>> manipulate_algebraic_expression('x + x^2', 'simplify')\n    x**2 + x\n    >>> manipulate_algebraic_expression('x + 2*x', 'simplify')\n    3*x\n    \"\"\"\n    expr = sympify(expression.replace('^', '**'))  # Convert to a sympy expression, handling power operator\n    if operation == 'simplify':\n        return simplify(expr)\n    elif operation == 'square':\n        return simplify(expr**2)\n    elif operation == 'reciprocal':\n        return simplify(1/expr)\n    else:\n        raise ValueError(f\"Unsupported operation {operation}\")\n    return expr",
        "def create_fraction(numerator, denominator=1):\n    \"\"\"\n    Creates a Fraction from numerator and denominator.\n    Parameters:\n    numerator (int): The numerator of the fraction.\n    denominator (int): The denominator of the fraction, defaults to 1.\n    Returns:\n    Fraction: A fraction object created from the numerator and denominator.\n    \"\"\"\n    return fractions.Fraction(numerator, denominator)",
        "def solve_rational_equations(expr, symbol):\n    \"\"\"\n    Solves rational equations for the specified variable.\n    Parameters:\n        expr (symply expression): The equation to solve.\n        symbol (sympy symbol): The variable to solve for.\n    Returns:\n        list: Solutions of the equation.\n    Example:\n        >>> x = symbols('x')\n        >>> expr = x**2 - x - 6\n        >>> solve_rational_equations(expr, x)\n        [2, -3]\n    \"\"\"\n    return solve(expr, symbol)",
        "def decompose_into_partial_fractions(expr):\n    \"\"\"\n    Decomposes a rational function into partial fractions.\n    Parameters:\n        expr (sympy expression): The rational function to decompose.\n    Returns:\n        sympy expression: The expression decomposed into partial fractions.\n    Example:\n        >>> x = symbols('x')\n        >>> expr = (x**2 + 3*x + 5)/(x**3 + x**2 - x - 1)\n        >>> decompose_into_partial_fractions(expr)\n        (x - 1)/(x**2 + 2*x + 1) + 2/(x + 1)\n    \"\"\"\n    return apart(expr)"
    ],
    "Polynomial Factoring": [
        "def advanced_polynomial_factoring(expression, variable):\n    \"\"\"\n    Factorizes complex polynomial expressions using advanced methods like difference of squares, sum and difference of cubes.\n    Parameters:\n        expression (str): The polynomial expression as a string.\n        variable (str): The variable for advanced factorization methods.\n    Returns:\n        sympy.Expr: The factorized expression.\n    Examples:\n        >>> advanced_polynomial_factoring('x^3 - 8', 'x')\n        (x - 2)*(x^2 + 2*x + 4)\n        >>> advanced_polynomial_factoring('x^2 - 1', 'x')\n        (x - 1)*(x + 1)\n    \"\"\"\n    var = sp.symbols(variable)\n    expr = sp.sympify(expression.replace('^', '**'))\n    return sp.factor(expr)",
        "def full_polynomial_factorization(expr):\n    \"\"\"\n    Carry out full factorization of a polynomial, utilizing various algebraic techniques.\n    Parameters:\n    - expr (str): The polynomial expression as a string.\n    Returns:\n    - factored_expr (str): The fully factored form of the polynomial.\n    \n    Examples:\n    >>> full_polynomial_factorization('x**2 - 4')\n    '(x - 2)*(x + 2)'\n    >>> full_polynomial_factorization('x**2 + 2*x + 1')\n    '(x + 1)**2'\n    \"\"\"\n    poly_expr = sympify(expr)\n    return str(factor(poly_expr))",
        "def special_factorization(expression, method=\"difference_of_squares\"):\n    \"\"\"\n    Perform special factorizations like difference of squares or sum/difference of cubes on a polynomial.\n    Parameters:\n    - expression (str): The polynomial expression to factor.\n    - method (str): Type of factorization method such as 'difference_of_squares', 'sum_of_cubes', 'difference_of_cubes'.\n    Returns:\n    - sp.Expr: The factored form of the polynomial depending on the method.\n    Example:\n    >>> special_factorization(\"x**2 - 16\", \"difference_of_squares\")\n    (x - 4)*(x + 4)\n    \"\"\"\n    var = sp.symbols('x')  # Default variable is x for simplicity in general approach\n    polynomial = sp.sympify(expression)\n    if method == \"difference_of_squares\":\n        return sp.factor(polynomial)\n    elif method == \"sum_of_cubes\":\n        return sp.factor(polynomial)\n    elif method == \"difference_of_cubes\":\n        return sp.factor(polynomial)\n    else:\n        raise ValueError(\"Invalid method specified\")"
    ],
    "Exponents and Logarithms": [
        "def exponentiate(base, exponent):\n    \"\"\"\n    Calculate the power of a base raised to an exponent.\n    \n    Parameters:\n        base (float): The base of the exponentiation.\n        exponent (float): The exponent of the power.\n    \n    Returns:\n        float: The result of base raised to the power of exponent.\n    \n    Example:\n        >>> exponentiate(2, 3)\n        8\n    \"\"\"\n    return base ** exponent",
        "def simplify_exponential_expr(expr):\n    \"\"\"\n    Simplifies expressions involving exponents using sympy's simplification capabilities.\n    \n    Parameters:\n    expr (str or sympy expression): The exponential expression to simplify.\n    \n    Returns:\n    sympy expression: A simplified version of the input expression.\n    \n    Examples:\n    >>> simplify_exponential_expr('x**2 * x**3')\n    x**5\n    >>> simplify_exponential_expr('x**2 / x**3')\n    1/x\n    \"\"\"\n    expr = sp.sympify(expr)\n    return sp.simplify(expr)",
        "def compute_log(value, base=np.e):\n    \"\"\"\n    Compute the logarithm of a given value with an optional base, default being the natural log.\n    \n    Parameters:\n    value (float or sympy.Symbol): The value to take the logarithm of.\n    base (float, optional): The base of the logarithm. Default is np.e for natural log.\n    \n    Returns:\n    float or sympy expression: The logarithm of the value.\n    \n    Examples:\n    >>> compute_log(8, 2)\n    3.0\n    >>> x = sp.symbols('x')\n    >>> compute_log(x)\n    log(x)\n    \"\"\"\n    return np.log(value) / np.log(base) if base != np.e else np.log(value)",
        "def solve_exponential_equation(eq_str, variable_str):\n    \"\"\"\n    Solves an exponential equation by isolating the variable on one side.\n    \n    Parameters:\n    eq_str (str): A string representation of the equation to solve.\n    variable_str (str): The variable to isolate, given as a string.\n    \n    Returns:\n    list: A list of solutions to the exponential equation.\n    \n    Example:\n    >>> solve_exponential_equation(\"2**x = 8\", 'x')\n    [3]\n    \"\"\"\n    variable = sp.symbols(variable_str)\n    equation = sp.Eq(sp.sympify(eq_str.split('=')[0]), sp.sympify(eq_str.split('=')[1]))\n    solutions = sp.solve(equation, variable)\n    return [sol.evalf() for sol in solutions]  # Return numerical solutions if possible",
        "def product_of_powers(n, m1, m2):\n    \"\"\"\n    Calculates the product of powers of the same base. It uses the formula a^m * a^n = a^(m+n).\n        \n    Parameters:\n    n (int): The base number.\n    m1 (int): The first exponent.\n    m2 (int): The second exponent.\n    \n    Returns:\n    float: The product of powers of the same base.\n    \"\"\"\n    import math\n    return math.pow(n, m1 + m2)",
        "def simplify_exponents(expression):\n    \"\"\"\n    Simplify expressions involving powers especially when bases are the same.\n    \n    Parameters:\n        expression (str): A string containing the mathematical expression to simplify.\n    \n    Returns:\n        float: The simplified result of the expression.\n    \n    Example:\n        >>> simplify_exponents(\"2**3 * 2**4\")\n        128\n    \"\"\"\n    # For simplicity, use eval here, but in a real scenario, a more secure parser may be used.\n    return eval(expression)",
        "def power_of_a_quotient(a, b, n):\n    \"\"\"\n    Implements the power of a quotient rule. The function applies the rule (a/b)^n = a^n / b^n\n    \n    Parameters:\n    a (int): The numerator of the fraction.\n    b (int): The denominator of the fraction.\n    n (int): The exponent.\n    \n    Returns:\n    float: The result after applying the power of a quotient rule.\n    \"\"\"\n    import math\n    return (math.pow(a, n) / math.pow(b, n))",
        "def logarithm(base, x):\n    \"\"\"\n    Calculate the logarithm of a number with a specified base using numpy for high precision.\n    \n    Parameters:\n    - base (float or int): The base of the logarithmic function.\n    - x (float or int): The number whose logarithm is to be computed.\n    \n    Returns:\n    - float: The logarithm of x to the given base.\n    \n    Examples:\n    >>> logarithm(2, 8)\n    3.0\n    >>> logarithm(10, 100)\n    2.0\n    \"\"\"\n    return np.log(x) / np.log(base)",
        "def negative_exponent(n, m):\n    \"\"\"\n    Implements the negative exponent rule. It finds the value for a^(-n) using the formula a^(-n) = 1/(a^n).\n        \n    Parameters:\n    n (int): The base number.\n    m (int): The exponent. The function will convert it to negative.\n    \n    Returns:\n    float: The result after applying the negative exponent rule.\n    \"\"\"\n    import math\n    return 1 / math.pow(n, m)",
        "def solve_exponential_equation(base, result):\n    \"\"\"\n    Solve for the exponent given a base and a result using logarithms.\n    \n    Parameters:\n    base (float): Base of the exponential equation.\n    result (float): Result from raising base to the power of the unknown exponent.\n    \n    Returns:\n    float: The exponent x such that base ** x = result.\n    \n    Example:\n    >>> solve_exponential_equation(2, 8)\n    3.0\n    \"\"\"\n    if base <= 0 or result <= 0:\n        raise ValueError(\"Base and result must be positive numbers.\")\n    return math.log(result, base)",
        "def power_rule(n1, n2, m):\n    \"\"\"\n    Implements the power rule for exponents. It finds the solution for (n1^n2)^m using the formula (n1^n2)^m = n1^(n2*m).\n        \n    Parameters:\n    n1 (int): The base number.\n    n2 (int): The exponent applied to the base number.\n    m (int): The second exponent applied to the result after the base is raised to the power of n2.\n    \n    Returns:\n    float: The end result after applying the power rule on the inputs.\n    \"\"\"\n    import math\n    return math.pow(n1, n2 * m)"
    ],
    "Function Transformations": [
        "def apply_function_transformation(f, shift_x=0, shift_y=0, scale_x=1, scale_y=1, reflect_x=False, reflect_y=False):\n    \"\"\"\n    Applies transformations to a given symbolic function: translation, scaling, and reflection.\n    Parameters:\n    - f (sympy.Expr): The function to transform, expressed as a sympy expression.\n    - shift_x (float, optional): Horizontal shift; positive for right, negative for left.\n    - shift_y (float, optional): Vertical shift; positive for up, negative for down.\n    - scale_x (float, optional): Scaling factor along the x-axis.\n    - scale_y (float, optional): Scaling factor along the y-axis.\n    - reflect_x (bool, optional): Set to True to reflect the function across y-axis.\n    - reflect_y (bool, optional): Set to True to reflect the function across x-axis.\n    Returns:\n    - sympy.Expr: The transformed function.\n    Example:\n    >>> x = sp.symbols('x')\n    >>> f = x**2\n    >>> apply_function_transformation(f, shift_x=2, shift_y=3, scale_x=-1, scale_y=0.5)\n    0.5*(-x + 2)**2 + 3\n    \"\"\"\n    x = sp.symbols('x')\n    # Apply scaling and reflection\n    if reflect_x:\n        x_transformed = -x * scale_x\n    else:\n        x_transformed = x * scale_x\n    \n    if reflect_y:\n        f = -f\n    f_transformed = f.subs(x, x_transformed - shift_x) * scale_y + shift_y\n    return f_transformed",
        "def find_vertex_quadratic(a, b, c):\n    \"\"\"\n    Determines the vertex of a quadratic function of the form ax^2 + bx + c.\n    Parameters:\n    - a (float): Coefficient of x^2.\n    - b (float): Coefficient of x.\n    - c (float): Constant term.\n    Returns:\n    - tuple: Coordinates of the vertex (h, k).\n    Example:\n    >>> find_vertex_quadratic(1, -4, 4)\n    (2.0, 0.0)\n    \"\"\"\n    h = -b / (2 * a)\n    k = a * h**2 + b * h + c\n    return (h, k)",
        "def shift_function_horizontally(f, h):\n    \"\"\"\n    Shift the function f horizontally.\n    Parameters:\n        f (sp.Expr): A sympy expression representing a function of variable x.\n        h (float): The horizontal shift amount. Positive values shift right, negative shift left.\n    Returns:\n        sp.Expr: A new function expression representing f shifted horizontally by h units.\n    \n    Example:\n        >>> x = sp.symbols('x')\n        >>> original_function = x**2\n        >>> shifted_function = shift_function_horizontally(original_function, 2)  # Shifts right by 2\n        >>> print(shifted_function)\n        (x - 2)**2\n    \"\"\"\n    x = sp.symbols('x')\n    return f.subs(x, x - h)",
        "def translate_function(expression, h_shift, v_shift):\n    \"\"\"\n    Translates a function by applying horizontal and vertical shifts.\n    Parameters:\n    - expression (callable): The function to be translated.\n    - h_shift (float): The horizontal shift (`h` units to the right if positive).\n    - v_shift (float): The vertical shift (`k` units up if positive).\n    Returns:\n    - callable: A new function that represents the translated function.\n    Example:\n    >>> f = lambda x: x**2\n    >>> g = translate_function(f, h_shift=3, v_shift=-4)\n    >>> g(0)  # This evaluates (x - 3)^2 - 4 at x = 0\n    5\n    \"\"\"\n    return lambda x: expression(x - h_shift) + v_shift",
        "def horizontal_stretch_compression(f, b):\n    \"\"\"\n    Apply horizontal stretch or compression to the function f.\n    Parameters:\n        f (sp.Expr): A sympy expression representing a function of variable x.\n        b (float): The factor by which the function is stretched (b > 1) or compressed (0 < b < 1).\n    Returns:\n        sp.Expr: A new function expression representing f stretched or compressed horizontally.\n    \n    Example:\n        >>> x = sp.symbols('x')\n        >>> original_function = sp.exp(x)\n        >>> modified_function = horizontal_stretch_compression(original_function, 2)  # Compress by factor of 2\n        >>> print(modified_function)\n        exp(x/2)\n    \"\"\"\n    x = sp.symbols('x')\n    return f.subs(x, x / b)",
        "def find_function_vertex(f):\n    \"\"\"\n    Finds the vertex of a quadratic or absolute value function.\n    Parameters:\n    - f (sympy.Expr): The function, expected to be either quadratic or absolute value of linear.\n    Returns:\n    - tuple: Vertex of the function as (x, y).\n    Example:\n    >>> x = sp.symbols('x')\n    >>> f = abs(x - 1) + 3\n    >>> find_function_vertex(f)\n    (1, 3)\n    Note:\n    For quadratic, the vertex form is assumed. If not provided in vertex form, convert f accordingly.\n    \"\"\"\n    x = sp.symbols('x')\n    if isinstance(f, sp.Abs):\n        # For absolute functions, vertex is where the expression inside abs is zero\n        inside_abs = list(f.args)[0]\n        vertex_x = sp.solve(inside_abs, x)\n        vertex_y = f.subs(x, vertexx)\n    else:\n        # Assuming the function is quadratic and already in vertex form\n        vertex_x = -f.coeff(x, 2) / (2 * f.coeff(x, 1))\n        vertex_y = f.subs(x, vertex_x)\n    \n    return (vertex_x, vertex_y)",
        "def reflect_function_across_y_axis(f):\n    \"\"\"\n    Reflect the function f across the y-axis.\n    Parameters:\n        f (sp.Expr): A sympy expression representing a function of variable x.\n    Returns:\n        sp.Expr: A new function expression representing the reflection of f across the y-axis, i.e., f(-x).\n    \n    Example:\n        >>> x = sp.symbols('x')\n        >>> original_function = x**2\n        >>> reflected_function = reflect_function_across_y_axis(original_function)\n        >>> print(reflected_function)\n        x**2\n    \"\"\"\n    x = sp.symbols('x')\n    return f.subs(x, -x)",
        "def scale_function(expression, horizontal_scale, vertical_scale):\n    \"\"\"\n    Scales a function by modifying its width and height.\n    Parameters:\n    - expression (callable): The function to be scaled.\n    - horizontal_scale (float): The horizontal scaling factor.\n    - vertical_scale (float): The vertical scaling factor.\n    Returns:\n    - callable: A new function that represents the scaled function.\n    Example:\n    >>> f = lambda x: x**2\n    >>> g = scale_function(f, horizontal_scale=2, vertical_scale=0.5)\n    >>> g(2)  # This evaluates 0.5 * (x/2)^2 at x = 2\n    0.5\n    \"\"\"\n    return lambda x: vertical_scale * expression(x / horizontal_scale)"
    ],
    "Completing the Square": [
        "def complete_the_square(a, b, c):\n    \"\"\"\n    Takes the coefficients of a quadratic equation ax^2 + bx + c, and returns the equation in the \n    completed square form along with the h and k values from vertex form (x+h)^2 = k.\n    \n    Parameters:\n    a (float/int): Coefficient of x^2\n    b (float/int): Coefficient of x\n    c (float/int): Constant term\n    \n    Returns:\n    Tuple:\n        - str: Quadratic equation in completed square form as a string\n        - float: Value 'h' in the vertex form\n        - float: Value 'k' in the vertex form\n    \n    Example:\n    >>> complete_the_square(1, -6, 8)\n    (\"(x - 3.0)^2 - 1.0\", 3.0, -1.0)\n    \"\"\"\n    # Derive the square completion\n    x = sp.Symbol('x')\n    expression = a*x**2 + b*x + c\n    completed_square = sp.simplify(sp.expand(expression)).collect(x, sp.factor)\n    \n    # Extract h and k for the vertex form\n    h = -b / (2 * a)\n    k = a * h**2 + b * h + c\n    \n    # Creating the completed square form as a string\n    if h == 0:\n        cs_form = f'(x)^2 + {k}'\n    else:\n        cs_form = f'(x - {h})^2 + {k}'\n    \n    return cs_form, h, k",
        "def complete_square_two_variables(a, b, c, d, e, f):\n    \"\"\"\n    Convert a general quadratic equation in two variables (x, y) ax^2 + by^2 + cx + dy + e = f \n    into a completed square form.\n    Parameters:\n        a (float): Coefficient of x^2\n        b (float): Coefficient of y^2\n        c (float): Coefficient of x\n        d (float): Coefficient of y\n        e (float): Constant term\n        f (float): Term on the other side of the equation\n    Returns:\n        str: The quadratic equation in completed square form and perhaps matching a form of circles or ellipses.\n    Examples:\n        >>> complete_square_two_variables(1, 1, -6, -8, 9, 0)\n        '(x - 3.0)^2 + (y + 4.0)^2 = 16.0'\n    \"\"\"\n    from sympy import Rational, sqrt, simplify\n    # Complete the square for x terms\n    h = -c / (2 * a)\n    x_term = a * (h**2) + c * h\n    # Complete the square for y terms\n    k = -d / (2 * b)\n    y_term = b * (k**2) + d * k\n    # Combining constants and rearranging equation\n    constant_term = e - f + x_term + y_term\n    constant_term = simplify(constant_term)\n    h = simplify(h)\n    k = simplify(k)\n    return f\"(x - {h})^2 + (y - {k})^2 = {-constant_term}\"",
        "def get_vertex_from_quadratic(a, b, c):\n    \"\"\"\n    Returns the vertex (x, y) of the parabola defined by the quadratic equation `ax^2 + bx + c`.\n    Parameters:\n    - a (int/float): Coefficient of x^2\n    - b (int/float): Coefficient of x\n    - c (int/float): Constant term\n    Returns:\n    - (float, float): The vertex of the quadratic equation.\n    Examples:\n    >>> get_vertex_from_quadratic(1, -2, -3)\n    (1.0, -4.0)\n    >>> get_vertex_from_quadratic(2, 4, 2)\n    (-1.0, -6.0)\n    \"\"\"\n    x = -b / (2 * a)\n    y = a * x * x + b * x + c\n    return x, y",
        "def standardize_circle_equation(coef_x2, coef_xy, coef_y2, coef_x, coef_y, constant):\n    \"\"\"\n    Convert a general form of a circle's equation into the standard form\n    (x-h)^2 + (y-k)^2 = r^2 using completing the square technique.\n    Parameters:\n    - coef_x2 (int or float): Coefficient of x^2 (should be 1 for circle)\n    - coef_xy (int or float): Coefficient of xy (should be 0 for circle)\n    - coef_y2 (int or float): Coefficient of y^2 (should be 1 for circle)\n    - coef_x (int or float): Coefficient of x\n    - coef_y (int or float): Coefficient of y\n    - constant (int or float): Constant term in the equation\n    Returns:\n    - sp.Expr: The equation of the circle in standard form.\n    - float: The center coordinates (h, k) of the circle.\n    - float: The radius (r) of the circle.\n    Examples:\n    >>> equation, center, radius = standardize_circle_equation(1, 0, 1, -6, -8, 9)\n    >>> equation\n    (x + 3)**2 + (y + 4)**2 = 16\n    >>> center\n    (-3, -4)\n    >>> radius\n    4\n    \"\"\"\n    x, y = sp.symbols('x y')\n    original_equation = coef_x2*x**2 + coef_y2*y**2 + coef_xy*x*y + coef_x*x + coef_y*y + constant\n    h = -coef_x / (2 * coef_x2)\n    k = -coef_y / (2 * coef_y2)\n    r_squared = -(constant - coef_x2*h**2 - coef_y2*k**2)\n    standard_form = (x-h)**2 + (y-k)**2 - r_squared\n    return standard_form.simplify(), (h, k), sp.sqrt(r_squared)",
        "def rationalize_decimal(decimal_number):\n    \"\"\"\n    Convert a decimal number to its simplest fractional form.\n    \n    Parameters:\n    - decimal_number : float\n        The decimal number to convert.\n    \n    Returns:\n    - str\n        The string representation of the number as a fraction.\n    \n    Example:\n    >>> rationalize_decimal(0.3333)\n    '1/3'\n    \"\"\"\n    return str(Fraction(decimal_number).limit_denominator())"
    ],
    "Complex Numbers": [
        "def complex_subtract(z1, z2):\n    \"\"\"\n    Subtract one complex number from another.\n    Parameters:\n        z1 (complex): The first complex number.\n        z2 (complex): The second complex number.\n    Returns:\n        complex: The result of z1 - z2.\n    Examples:\n        >>> complex_subtract(5+3j, 2+2j)\n        (3+1j)\n    \"\"\"\n    return z1 - z2",
        "def complex_add(z1, z2):\n    \"\"\"Perform addition of two complex numbers.\n    Parameters:\n        z1 (complex or sp.core.add.Add): First complex number, can be a native Python complex or a SymPy expression.\n        z2 (complex or sp.core.add.Add): Second complex number.\n    Returns:\n        sp.core.add.Add: Result of the addition as a symbolic expression.\n    \n    Example:\n        >>> complex_add(sp.I, 1 + 2 * sp.I)\n        1 + 3*I\n    \"\"\"\n    return z1 + z2",
        "def complex_operations(z1, z2, operation='add'):\n    \"\"\"\n    Perform basic arithmetic operations on two complex numbers.\n    Parameters:\n    z1 (complex): First complex number. Example: 3+5j\n    z2 (complex): Second complex number. Example: 4+4j\n    operation (str): Type of operation ('add', 'subtract', 'multiply', 'divide', 'conjugate', 'modulus', 'argument'). Default is 'add'.\n    \n    Returns:\n    complex or float: Result of the operation. Returns a complex number for arithmetic or a float for 'modulus', 'argument'.\n    \n    Example:\n    >>> complex_operations(3+5j, 4+4j, 'add')\n    (7+9j)\n    >>> complex_operations(3+5j, 4+4j, 'multiply')\n    (-8+32j)\n    >>> complex_operations(3+5j, operation='argument')\n    1.0303768265243125\n    \"\"\"\n    if operation == 'add':\n        return z1 + z2\n    elif operation == 'subtract':\n        return z1 - z2\n    elif operation == 'multiply':\n        return z1 * z2\n    elif operation == 'divide':\n        return z1 / z2\n    elif operation == 'conjugate':\n        return cmath.conjugate(z1)\n    elif operation == 'modulus':\n        return abs(z1)\n    elif operation == 'argument':\n        return cmath.phase(z1)\n    else:\n        raise ValueError(\"Unsupported operation supplied.\")",
        "def complex_modulus(z):\n    \"\"\"\n    Calculate the modulus (absolute value) of a complex number.\n    Parameters:\n        z (complex): The complex number whose modulus is to be calculated.\n    Returns:\n        float: The modulus of the complex number.\n    Examples:\n        >>> complex_modulus(3+4j)\n        5.0\n    \"\"\"\n    return abs(z)",
        "def solve_polynomial(coefficients):\n    \"\"\"\n    Find the roots of a polynomial with given coefficients.\n    Parameters:\n    coefficients (list): Coefficients of the polynomial, highest degree first.\n    Returns:\n    array: Roots of the polynomial, which can be real or complex numbers.\n    \n    Example:\n    >>> solve_polynomial([1, 0, -1])\n    array([-1.,  1.])\n    \"\"\"\n    return np.roots(coefficients)",
        "def complex_operations(c1, c2, operation):\n    \"\"\"\n    This function performs basic operations (addition, subtraction, multiplication and division) on complex numbers.\n    Parameters:\n    c1, c2 (complex): complex numbers\n    operation (str): the operation to be performed; can be 'add', 'subtract', 'multiply', or 'divide'\n    Returns:\n    result (complex): the result of the operation\n    \"\"\"\n    if operation == 'add':\n        result = c1 + c2\n    elif operation == 'subtract':\n        result = c1 - c2\n    elif operation == 'multiply':\n        result = c1 * c2\n    elif operation == 'divide':\n        if c2 != 0:\n            result = c1 / c2\n        else:\n            result = 'undefined'\n    else:\n        result = 'invalid operation'\n    \n    return result",
        "def polynomial_roots_and_relations(coefficients, relationship='roots'):\n    \"\"\"\n    Calculate roots of a polynomial or relationships between roots based on coefficients\n    using Vieta's formulas.\n    Parameters:\n        coefficients (list): Coefficients of the polynomial, beginning from the highest degree.\n        relationship (str): Desired output 'roots', 'sum', 'product', or 'Vieta_relations'.\n                             Default is 'roots'.\n    Returns:\n        ndarray or tuple: Roots of the polynomial, or specific relationships between roots.\n    Examples:\n        >>> polynomial_roots_and_relations([1, 0, -4, 4], 'roots')\n        array([ 2., -2.,  1.])\n        >>> polynomial_roots_and_relations([1, 0, -4, 4], 'Vieta_relations')\n        (0, -4, 4)  # Sum, product by pairs, and overall product of roots\n    \"\"\"\n    p = np.poly1d(coefficients)\n    roots = p.r\n    if relationship == 'roots':\n        return roots\n    elif relationship == 'sum':\n        return np.sum(roots)\n    elif relationship == 'product':\n        return np.prod(roots)\n    elif relationship == 'Vieta_relations':\n        n = len(roots)\n        sums = [sum(np.prod(roots[list(inds)]) for inds in combinations(range(n), r)) for r in range(1, n+1)]\n        products = [sum(roots**i) for i in range(1, n+1)]\n        return sums, products\n    else:\n        raise ValueError(\"Unsupported relationship type. Choose 'roots', 'sum', 'product', or 'Vieta_relations'.\")",
        "def roots_of_unity(n):\n    \"\"\"\n    Calculate the n-th roots of unity, e^(2*pi*i / n).\n   \n    Parameters:\n    n (int): The degree of the root of unity.\n    \n    Returns:\n    list: n complex numbers which are the n-th roots of unity.\n    \n    Example:\n    >>> roots_of_unity(3)\n    [(1+0j), (-0.5+0.8660254037844386j), (-0.5-0.8660254037844386j)]\n    \"\"\"\n    return [cmath.exp(2j * cmath.pi * k / n) for k in range(n)]",
        "def complex_conjugate(z):\n    \"\"\"Return the conjugate of a complex number.\n    Parameters:\n        z (complex or sp.core.add.Add): A complex number.\n    Returns:\n        sp.core.add.Add: Conjugate of the complex number.\n    \n    Example:\n        >>> complex_conjugate(1 + 2*sp.I)\n        1 - 2*I\n    \"\"\"\n    return sp.conjugate(z)",
        "def solve_quadratic_complex(a, b, c):\n    \"\"\"\n    Solve a quadratic equation of the form ax^2 + bx + c = 0 where coefficients can be complex.\n    Parameters:\n        a (complex): Coefficient of x^2.\n        b (complex): Coefficient of x.\n        c (complex): Constant term.\n    Returns:\n        tuple: A tuple of two complex numbers representing the roots.\n    Examples:\n        >>> solve_quadratic_complex(1, -3+4j, -6-8j)\n        ((6+2j), (-2+6j))\n    \"\"\"\n    if a == 0:\n        raise ValueError(\"Coefficient a must not be zero\")\n    d = cmath.sqrt(b ** 2 - 4 * a * c)\n    root1 = (-b + d) / (2 * a)\n    root2 = (-b - d) / (2 * a)\n    return (root1, root2)",
        "def complex_to_cartesian(z):\n    \"\"\"Converts a complex number from its polar form to cartesian coordinates.\n    Parameters:\n        z (sp.core.add.Add): A complex number in polar form.\n    Returns:\n        tuple: A tuple (re, im) representing real and imaginary parts.\n    \n    Example:\n        >>> complex_to_cartesian(sp.exp(sp.I*sp.pi/4))\n        (sqrt(2)/2, sqrt(2)/2)\n    \"\"\"\n    re, im = z.as_real_imag()\n    return (re, im)",
        "def solve_complex_eq(eq):\n    \"\"\"\n    This function solves equations involving complex numbers.\n    Parameters:\n    eq (str): an equation involving complex numbers\n    Returns:\n    solution (complex): the solution(s) to the equation\n    \"\"\"\n    from sympy import symbols, Eq, solve, I\n    x = symbols('x')\n    eq = eq.replace('i', '*I')\n    solution = solve(Eq(eval(eq.split('=')[0]), eval(eq.split('=')[1])), x)\n    return solution",
        "def expand_complex_expression(expr):\n    \"\"\"Expand a complex polynomial expression.\n    Parameters:\n        expr (sp.core.add.Add): A complex expression.\n    Returns:\n        sp.core.add.Add: Expanded expression.\n    \n    Example:\n        >>> expand_complex_expression((1 + sp.I)**3)\n        -2 + 2*I\n    \"\"\"\n    return sp.expand(expr)",
        "def solve_complex_equation(equation, variable):\n    \"\"\"Solve an equation that involves complex numbers.\n    Parameters:\n        equation (sp.core.add.Add): The equation to be solved.\n        variable (sp.Symbol): The variable to solve for.\n    Returns:\n        list: Solutions to the equation.\n    \n    Example:\n        >>> z = sp.symbols('z', complex=True)\n        >>> solve_complex_equation(z**2 + 1, z)\n        [-I, I]\n    \"\"\"\n    return sp.solveset(equation, variable, domain=sp.S.Complexes)",
        "def simplify_complex(c):\n    \"\"\"\n    This function simplifies an expression involving complex numbers.\n    Parameters:\n    c (complex): a complex number of the form a + bi\n    Returns:\n    simplified (complex): the simplified form of the complex number\n    \"\"\"\n    from sympy import simplify, I\n    c = c.replace('i', '*I')\n    simplified = simplify(eval(c))\n    return simplified",
        "def complex_parts(c):\n    \"\"\"\n    This function returns the real and imaginary parts of a complex number.\n    Parameters:\n    c (complex): a complex number of the form a + bi\n    Returns:\n    real_part (float): the real part of the complex number\n    imaginary_part (float): the imaginary part of the complex number\n    \"\"\"\n    real_part = c.real\n    imaginary_part = c.imag\n    return real_part, imaginary_part",
        "def complex_conjugate(c):\n    \"\"\"\n    This function calculates the conjugate of a complex number.\n    Parameters:\n    c (complex): a complex number of the form a + bi\n    Returns:\n    conjugate (complex): the conjugate of the complex number\n    \"\"\"\n    return c.conjugate()",
        "def complex_from_polar(r, theta):\n    \"\"\"\n    Convert a polar coordinate (magnitude, angle) into a complex number.\n    Parameters:\n    - r (float): The magnitude of the complex number.\n    - theta (float): The angle in radians.\n    Returns:\n    - complex: The complex number in rectangular form.\n    Examples:\n    >>> complex_from_polar(1, np.pi / 4)\n    (0.7071067811865476+0.7071067811865475j)\n    \"\"\"\n    return cmath.rect(r, theta)"
    ],
    "Polynomial Equations": [
        "def polynomial_coefficients_to_roots(coefficients):\n    \"\"\"\n    Given polynomial coefficients, returns the roots using Vieta's formulas.\n    \n    Parameters:\n        coefficients (list): List of coefficients, from highest degree to the coefficient of the free term.\n    \n    Returns:\n        roots (list): List of roots, can be real or complex numbers.\n        \n    Examples:\n        >>> polynomial_coefficients_to_roots([1, -3, 2])\n        [2, 1]\n    \"\"\"\n    x = sp.symbols('x')\n    polynomial = sum(c * x**i for i, c in enumerate(reversed(coefficients)))\n    roots = sp.solve(polynomial, x)\n    return roots",
        "def evaluate_polynomial(expression, value):\n    \"\"\"\n    Substitutes a given value into the polynomial and evaluates it.\n    Parameters:\n    - expression (str or sympy Expression): The polynomial expression.\n    - value (float or int): The value to substitute into the polynomial.\n    Returns:\n    - sympy Expression: The result after evaluating the polynomial at the given value.\n    Examples:\n    >>> evaluate_polynomial(\"x**2 - 3*x + 2\", 2)\n    0\n    \"\"\"\n    x = symbols('x')\n    expr = sympify(expression)\n    return expr.subs(x, value)",
        "def expand_and_simplify_polynomial(poly_expr):\n    \"\"\"\n    Expands and simplifies a given polynomial expression.\n    Parameters:\n    - poly_expr (str): The polynomial expression as a string.\n    Returns:\n    - sympy expression: The expanded and simplified form of the input polynomial.\n    \n    Examples:\n    >>> expand_and_simplify_polynomial(\"(x-1)*(x+2)\")\n    x**2 + x - 2\n    \"\"\"\n    expr = sp.sympify(poly_expr)\n    # Expand and simplify the polynomial\n    simplified_expr = sp.simplify(sp.expand(expr))\n    return simplified_expr",
        "def polynomial_operations(expression, operation_type, **kwargs):\n    \"\"\"\n    Handles various polynomial operations including expansion, factorization, solving equations, \n    finding roots, and simplifying expressions.\n    \n    Parameters:\n        expression (str): The polynomial expression as a string.\n        operation_type (str): The type of operation to perform ('expand', 'factor', 'solve', 'roots', 'simplify').\n        kwargs:\n            - var (str, optional): Variable to consider if expression is univariate. Required for solving.\n            - value (dict, optional): Values to substitute in the polynomial.\n    \n    Returns:\n        Various: Depending on the operation, can return expanded form, factors, solutions, roots or simplified form.\n    \n    Example:\n        >>> polynomial_operations(\"x**2 + 2*x + 1\", 'factor')\n        (x + 1)**2\n        >>> polynomial_operations(\"x**2 - 1\", 'roots')\n        {1: 1, -1: 1}\n        >>> polynomial_operations(\"x**2 - 3*x + 2 == 0\", 'solve', var='x')\n        [1, 2]\n    \"\"\"\n    x = symbols(kwargs.get('var', 'x'))\n    expr = simplify(expression) if '==' not in expression else simplify(expression.split('==')[0]) - simplify(expression.split('==')[1])\n    if kwargs.get('value'):\n        expr = expr.subs(kwargs['value'])\n    if operation_type == 'expand':\n        return expand(expr)\n    elif operation_type == 'factor':\n        return factor(expr)\n    elif operation_type == 'solve':\n        return solve(expr, x)\n    elif operation_type == 'roots':\n        return roots(expr)\n    elif operation_type == 'simplify':\n        return simplify(expr)\n    else:\n        raise ValueError(\"Invalid operation type provided.\")",
        "def simplify_expression(expression):\n    \"\"\"\n    Simplifies a given algebraic expression or polynomial.\n    \n    Parameters:\n    - expression (str or symbolic expression): The expression to be simplified.\n    \n    Returns:\n    - simplified_form (symbolic expression): Simplified form of the input expression.\n    \n    Example:\n    >>> simplify_expression(\"x**2 - 2*x + 1\")\n    (x - 1)**2\n    \"\"\"\n    return simplify(sympify(expression))",
        "def expand_polynomial(expression):\n    \"\"\"\n    Expands a polynomial using algebraic identities.\n    \n    Parameters:\n    - expression (str or sympy Expression): The algebraic expression in string format that needs expanding.\n    Returns:\n    - sympy Expression: The expanded form of the given polynomial.\n    Examples:\n    >>> expand_polynomial(\"x*(x + 1)*(x - 1)\")\n    x**3 - x\n    \"\"\"\n    x = symbols('x')\n    return expand(expression)",
        "def derive_polynomial_from_roots(roots):\n    \"\"\"\n    Forms a polynomial equation given the roots.\n    \n    Parameters:\n    - roots (list of numbers): The roots of the polynomial.\n    Returns:\n    - sympy Expression: The polynomial having the given roots.\n    Examples:\n    >>> derive_polynomial_from_roots([1, 2, 3])\n    x**3 - 6*x**2 + 11*x - 6\n    \"\"\"\n    x = symbols('x')\n    prod_expr = 1\n    for root in roots:\n        prod_expr *= (x - root)\n    return expand(prod_expr)",
        "def generate_polynomial_from_roots(roots, leading_coeff=1):\n    \"\"\"\n    Generate a polynomial from given roots.\n    Parameters:\n    - roots (list): A list of roots.\n    - leading_coeff (int, optional): The leading coefficient. Default is 1.\n    Returns:\n    - sp.Poly: The polynomial created from the roots.\n    Example:\n    >>> generate_polynomial_from_roots([1, -1])\n    x**2 - 1\n    \"\"\"\n    x = sp.symbols('x')\n    polynomial = sp.prod((x - root) for root in roots) * leading_coeff\n    return sp.Poly(polynomial, x)"
    ],
    "Summation": [
        "def symbolic_sum(expr, var, start, end):\n    \"\"\"\n    Compute the symbolic summation of a mathematical expression from start to end.\n    Parameters:\n    expr (sympy expression): The mathematical expression to be summed, involving var.\n    var (sympy.Symbol): The symbolic variable in the expression.\n    start (int): The starting value of the summation index.\n    end (int): The ending value of the summation index.\n    Returns:\n    sympy expression: The symbolically computed sum of the expression from start to end.\n    Examples:\n    >>> x = sp.Symbol('x')\n    >>> expr = sp.sin(x)\n    >>> symbolic_sum(expr, x, 1, 10) # Sum of sin(x) from x=1 to 10\n    Sum(sin(x), (x, 1, 10))\n    >>> expr = x**2\n    >>> symbolic_sum(expr, x, 1, 5) # Sum of x^2 from x=1 to 5\n    55\n    \"\"\"\n    return sp.summation(expr, (var, start, end))",
        "def geometric_sum(a, r, n):\n    \"\"\"\n    Calculate the sum of a geometric series.\n    Parameters:\n        a (float or int): The first term of the geometric series.\n        r (float or int): The common ratio of the series.\n        n (int): The number of terms in the series.\n    \n    Returns:\n        float: The sum of the first n terms of the geometric series.\n    Examples:\n        >>> geometric_sum(1, 2, 4)  # Sum of 1, 2, 4, 8\n        15.0\n        \n        >>> geometric_sum(3, 3, 3)  # Sum of 3, 9, 27\n        39.0\n    \"\"\"\n    return a * (1 - r ** (n + 1)) // (1 - r)",
        "def sum_of_first_n_natural_numbers(n):\n    \"\"\"\n    Calculates the sum of the first n natural numbers using the formula S = n * (n + 1) / 2.\n    Parameters:\n        n (int): The number of natural numbers to sum. Should be a non-negative integer.\n    \n    Returns:\n        int: The sum of the first n natural numbers.\n    Example:\n    >>> sum_of_first_n_natural_uid_numbers(10)\n    55\n    \"\"\"\n    return n * (n + 1) // 2",
        "def sum_algebraic_expressions(expr1, expr2):\n    \"\"\"\n    Takes two algebraic expressions, potentially involving fractions, and returns their sum in the simplest form.\n    \n    Parameters:\n    expr1 (str or sympy expression): The first algebraic expression to sum.\n    expr2 (str or sympy expression): The second algebraic expression to sum.\n    \n    Returns:\n    sympy expression: The simplified sum of the two expressions.\n    Examples:\n    >>> sum_algebraic_expressions(\"1/2 * x\", \"3/4 * y\")\n    1/2*x + 3/4*y\n    \n    >>> sum_algebraic_expressions(\"1/3 + 2/3\", \"1/2\")\n    3/2\n    >>> sum_algebraic_expressions(\"pi/4\", \"1/4\")\n    pi/4 + 1/4\n    \"\"\"\n    # Ensure the input expressions are in sympy format\n    expr1 = sympify(expr1)\n    expr2 = sympify(expr2)\n    \n    # Sum the expressions\n    sum_expr = expr1 + expr2\n    \n    # Simplify the result\n    simplified_sum = sum_expr.simplify()\n    \n    return simplified_sum",
        "def sum_of_arithmetic_sequence(a, d, n):\n    \"\"\"\n    Calculates the sum of the first n terms of an arithmetic sequence using the formula S_n = n/2 * (2a + (n-1) * d).\n    Parameters:\n        a (numeric): The first term of the arithmetic sequence.\n        d (numeric): The common difference between consecutive terms of the arithmetic sequence.\n        n (int): The number of terms in the sequence to sum. Should be a non-negative integer.\n    Returns:\n        numeric: The sum of the first n terms of the arithmetic sequence.\n    Example:\n    >>> sum_of_arithmetic_sequence(1, 1, 10)\n    55\n    >>> sum_of_arithmetic_sequence(3, 2, 5)\n    35\n    \"\"\"\n    return n / 2 * (2 * a + (n - 1) * d)",
        "def calculate_summation(term_function, start, end=None):\n    \"\"\"\n    Calculate the summation of a series defined by a term function from a start index to an end index.\n    If `end` is None, attempts to calculate an infinite series sum.\n    Parameters:\n    - term_function (function): A function that takes an integer index and returns the term at that index.\n    - start (int): The start index of the summation.\n    - end (optional, int): The end index of the summation. If None, calculate for an infinite series.\n    Returns:\n    - The summation as a symbolic expression if successful, None if the infinite series does not converge.\n    Examples:\n    >>> from sympy import symbols, Rational\n    >>> x = symbols('x')\n    >>> calculate_summation(lambda n: x**n, 0, 10)  # Sum x^n from n=0 to 10\n    x**11/(-x + 1) - 1/(-x + 1)\n    >>> calculate_summation(lambda n: 1/n**2, 1, None)  # Sum 1/n^2 from n=1 to infinity\n    pi**2/6\n    \"\"\"\n    import sympy as sp\n    \n    if end is None:\n        # Infinite series\n        n = sp.symbols('n', integer=True)\n        term = term_function(n)\n        return sp.summation(term, (n, start, sp.oo))\n    else:\n        # Finite series\n        n = sp.symbols('n', integer=True)\n        term = term_function(n)\n        return sp.summation(term, (n, start, end))",
        "def simplify_and_evaluate_series(expression):\n    \"\"\"\n    Simplify and potentially evaluate a series expression.\n    Parameters:\n    - expression (sympy.Expr): A sympy expression representing a series.\n    Returns:\n    - A simplified version of the series expression or its evaluated sum if possible.\n    Examples:\n    >>> from sympy import symbols, simplify\n    >>> x = symbols('x')\n    >>> series_expr = (1 - x)**2 / (1 - x)\n    >>> simplify_and_evaluate_series(series_expr)\n    1 - x\n    \n    >>> series_expr = sum(x**n for n in range(11))  # x^n from n=0 to 10\n    >>> simplify_and_evaluate_series(series_expr)\n    x**11/(-x + 1) - 1/(-x + 1)\n    \"\"\"\n    import sympy as sp\n    simplified_expr = sp.simplify(expression)\n    return simplified_expr",
        "def binary_pairing_sum(n):\n    \"\"\"\n    Calculates the sum of the first n terms of the series defined by 2^k where k belongs to integers and k < log2(n).\n    Parameters:\n        n (int): The number till which powers of 2 are considered (exclusive).\n    Returns:\n        int: Sum of terms 2^k for k in 0 to floor(log2(n-1)).\n    Examples:\n        >>> binary_pairing_sum(8) \n        15  # because 1 + 2 + 4 + 8 = 15\n    \"\"\"\n    k = 0\n    summation = 0\n    while (1 << k) < n:\n        summation += (1 << k)\n        k += 1\n    return summation",
        "def sum_arithmetic_sequence(first_term, last_term, common_difference):\n    \"\"\"\n    Calculates the sum of an arithmetic sequence from the first term to the last term with a given common difference.\n    \n    Parameters:\n    - first_term (int/float): The first term of the arithmetic sequence.\n    - last_term (int/float): The last term of the arithmetic sequence.\n    - common_difference (int/float): The common difference between successive terms.\n    \n    Returns:\n    - float: The sum of the arithmetic sequence.\n    \n    Example:\n    >>> sum_arithmetic_sequence(1, 10, 1)\n    55.0\n    >>> sum_arithmetic observations(3, 9, 2)\n    24.0\n    \"\"\"\n    import math\n    if common_difference == 0:\n        raise ValueError(\"Common difference cannot be zero.\")\n    \n    # Calculate the number of terms (n)\n    n = int((last_term - first_term) / common_difference + 1)\n    \n    # Sum of arithmetic sequence formula: n/2 * (first_term + last_term)\n    sum_sequence = n / 2 * (first_term + last_term)\n    return sum_sequence",
        "def sum_of_squares(n):\n    \"\"\"\n    Calculate the sum of the squares of the first n natural numbers.\n    Parameters:\n    n (int): The number of terms.\n    Returns:\n    int: The sum of the squares of the first n natural numbers.\n    \n    Examples:\n    >>> sum_of_squares(10)\n    385\n    \"\"\"\n    return n * (n + 1) * (2 * n + 1) // 6",
        "def trigonometric_series_sum(func_type, coef, offset, lower_bound, upper_bound):\n    \"\"\"\n    Calculates the sum of a trigonometric function over a specified range.\n    Parameters:\n        func_type (str): Type of trigonometric function. Must be 'sin' or 'cos'.\n        coef (float): Coefficient of the variable in the function argument.\n        offset (float): Constant offset in the function argument.\n        lower_bound (int): The lower bound of the summation index.\n        upper_bound (int): The upper bound of the summation index.\n    Returns:\n        float: The sum of the series.\n    Example:\n        >>> trigonometric_series_sum('sin', 1, 0, 0, 10)\n        1.4112\n        >>> trigonometric_series_sum('cos', 2, np.pi/4, 0, 10)\n        0.7214\n    \"\"\"\n    # Validate the function type\n    if func_type not in ['sin', 'cos']:\n        raise ValueError(\"func_type must be 'sin' or 'cos'\")\n    # Generating the function according to the type\n    trig_func = np.sin if func_type == 'sin' else np.cos\n    # Calculate the sum of the series\n    total_sum = sum(trig_func(coef * k + offset) for k in range(lower_bound, upper_bound + 1))\n    return total_sum",
        "def general_arithmetic_sum(start, end, step=1):\n    \"\"\"\n    Calculate the sum of an arithmetic sequence from start to end with a common difference step.\n    Parameters:\n    start (int/float): The first term of the arithmetic sequence.\n    end (int/float): The last term of the sequence.\n    step (int/float): The common difference between terms.\n    Returns:\n    float: The sum of the arithmetic sequence.\n    \n    Examples:\n    >>> general_arithmetic_sum(1, 10)\n    55.0\n    >>> general_arithmetic_sum(1, 100, 2)\n    2500.0\n    \"\"\"\n    import numpy as np\n    N = int((end - start) / step + 1)\n    return np.sum(np.arange(start, end + 1, step))",
        "def polynomial_sum(n, k, expr):\n    \"\"\"\n    Calculate the summation of a polynomial expression from 1 to n.\n    Parameters:\n        n (int or sp.Symbol): The upper limit of the summation (inclusive).\n        k (sp.Symbol): The symbol used in the polynomial expression.\n        expr (sp.Expr): The polynomial expression involving k.\n    Returns:\n        sp.Expr: The symbolic expression of the sum for the polynomial.\n    Examples:\n        >>> k = sp.symbols('k')\n        >>> polynomial_sum(100, k, k**2)  # Sum of squares from 1 to 100\n        338350\n  \n        >>> polynomial_sum(10, k, k)  # Sum of first 10 natural numbers\n        55\n        >>> polynomial_sum(5, k, 3*k + 1)  # Sum of 3*k + 1 from 1 to 5\n        40\n    \"\"\"\n    return sum(expr.subs(k, i) for i in range(1, n+1))",
        "def finite_summation(sequence_function, lower_bound, upper_bound):\n    \"\"\"\n    Calculate the finite sum of a given sequence from a specified lower bound to an upper bound.\n    Parameters:\n        sequence_function (function): A callable that computes the terms of the sequence.\n                                      It should accept an integer and return the sequence element.\n        lower_bound (int): The starting index of the summation.\n        upper_bound (int): The ending index of the summation.\n    \n    Returns:\n        float: The sum of the sequence elements from lower bound to upper bound.\n    \n    Examples:\n        # Sum of the first 10 natural numbers\n        >>> finite_summation(lambda x: x, 1, 10)\n        55.0\n        # Sum of the first 10 squares\n        >>> finite_summation(lambda x: x**2, 1, 10)\n        385.0\n    \"\"\"\n    return np.sum([sequence_function(x) for x in range(lower_bound, upper_bound + 1)])",
        "def sum_of_squares(start, end):\n    \"\"\"\n    Calculates the sum of squares from 'start' to 'end'.\n    Parameters:\n        start (int): The starting integer.\n        end (int): The ending integer (inclusive).\n    Returns:\n        int: Sum of the squares from start to end.\n    Examples:\n        >>> sum_of_squares(1, 3)\n        14  # because 1^2 + 2^2 + 3^2 = 1 + 4 + 9 = 14\n    \"\"\"\n    return sum(n ** 2 for n in range(start, end + 1))",
        "def simplify_trigonometric_expression(expression):\n    \"\"\"\n    Simplifies a trigonometric expression using sympy.\n    Parameters:\n        expression (str): The trigonometric expression to simplify.\n    Returns:\n        str: A simplified version of the input expression.\n    Example:\n        >>> simplify_trigonometric_expression(\"sin(x)**2 + cos(x)**2\")\n        '1'\n        >>> simplify_trigonometric_expression(\"sin(x) + sin(x)\")\n        '2*sin(x)'\n    \"\"\"\n    # Parse the expression\n    expr = sp.sympify(expression)\n    # Simplify the expression\n    simplified_expr = sp.simplify(expr)\n    return str(simplified_expr)",
        "def pairing_sum(sequence):\n    \"\"\"\n    Calculate the sum of elements by pairing them (used in binary operations).\n    Parameters:\n    sequence (list of float/int): The elements to be summed.\n    Returns:\n    float/int: The sum of the elements.\n    \n    Examples:\n    >>> pairing_sum([1, 2, 3, 4])\n    10\n    >>> pairing_sum([1, 2, 4, 8, 16])\n    31\n    \"\"\"\n    return sum(sequence)",
        "def special_distributive_sum(terms, factor=1):\n    \"\"\"\n    Applies distributive property over addition and returns the sum multiplied by an optional factor.\n    Parameters:\n    terms (list): Numeric terms of the sum.\n    factor (int/float): Multiplicative factor to be applied to the whole sum.\n    Returns:\n    float: Resulting sum after applying the distributive property.\n    \n    Examples:\n    >>> special_distributive_sum([1, 2, 3], 2)\n    12\n    \"\"\"\n    return sum(terms) * factor",
        "def numeric_sum(function, start, end):\n    \"\"\"\n    Compute the numeric summation for a function from start to end using Numpy.\n    \n    Parameters:\n    function (callable): A Python function that takes a single argument and returns a numerical result.\n    start (int): The starting value of the summation index.\n    end (int): The ending value of the summation index.\n    Returns:\n    float: The computed numerical sum of the function applied from start to end.\n    Examples:\n    >>> import numpy as np\n    >>> numeric_sum(np.sin, 1, 10) # Numeric sum of sin(x) from x=1 to 10\n    \"\"\"\n    index_values = np.arange(start, end + 1)\n    values = function(index_values)\n    return np.sum(values)",
        "def evaluate_expression_at_points(expression, points):\n    \"\"\"\n    Evaluates an algebraic expression at specified points.\n    Parameters:\n    expression (sympy.Expr): A sympy expression object.\n    points (list): A list of values at which to evaluate the expression.\n    \n    Returns:\n    list: A list of results from evaluating the expression at each point.\n    Examples:\n    >>> expression = sp.sympify(\"x**2 + 3*x + 1\")\n    >>> points = [1, 2, 3]\n    >>> evaluate_expression_at_points(expression, points)\n    [5, 11, 19]\n    \"\"\"\n    x = sp.symbols('x')\n    return [expression.subs(x, point).evalf() for point in points]"
    ],
    "Substitution": [
        "def substitute_and_evaluate(expression, substitutions):\n    \"\"\"\n    Substitute values into an algebraic expression and evaluate it.\n    \n    Parameters:\n    - expression (str): The algebraic expression in string format.\n    - substitutions (dict): A dictionary mapping from variable (str) to value (numeric or symbolic).\n    \n    Returns:\n    - sympy.Expr: Resultant expression after applying substitutions and simplification.\n    \n    Examples:\n    >>> substitute_and_evaluate('x**2 + 3*y', {'x': 2, 'y': 1})\n    7\n    >>> substitute_and_evaluate('a*b + c', {'a': 1, 'b': 2, 'c': 3})\n    5\n    \"\"\"\n    # Parse the expression\n    expr = sp.sympify(expression)\n    # Substitute the values\n    substituted_expr = expr.subs(substitutions)\n    \n    # Simplify and return evaluated expression\n    return sp.simplify(substituted_expr)",
        "def trig_substitute(expression, angle_subs, period_multiple=True):\n    \"\"\"\n    Perform trigonometric substitutions including handling expressions with \n    multiple angles or cycles.\n    Parameters:\n    - expression (str): Trigonometric expression as a string.\n    - angle_subs (dict): Dictionary specifying angle substitutions, where variables \n                         are given as strings and values are the angle measures.\n    - period_multiple (bool): If True, considers multiple cycles by integrating the period (2*pi for radians).\n    Returns:\n    - sympy.Expr: Resulting expression after substitution and simplification.\n    \n    Examples:\n    >>> trig_substitute(\"sin(x) + sin(2*x)\", {\"x\": \"pi/6\"})\n    1.5\n    >>> trig_substitute(\"cos(x) - sin(x)\", {\"x\": \"pi/3\"})\n    0.5*sqrt(3) - 0.5\n    \"\"\"\n    # Convert string to a symbolic expression\n    expr = sympy.sympify(expression)\n    # Modify angle values accounting for period multiples if indicated\n    modified_subs = {symbols(k): (sympy.sympify(v) * (2 * pi if period_multiple else 1)) for k, v in angle_subs.items()}\n    # Perform substitution\n    substituted_expr = expr.subs(modified_subs)\n    # Simplify the expression\n    simplified_expr = sympy.simplify(substituted_expr)\n    \n    return simplified_expr",
        "def evaluate_function_after_substitution(function, substitution_dict):\n    \"\"\"\n    Evaluates a function after substituting specific values or expressions for its variables.\n    Parameters:\n    - function (str or sympy.Function): The function to be evaluated, given as an expression.\n    - substitution_dict (dict): A dictionary specifying the substitutions to be made, where keys are variable names.\n    Returns:\n    - sympy.Expr: The result of the function after substitution.\n    \n    Examples:\n    >>> func = 'x**2 + y**2'\n    >>> subs = {'x': 1, 'y': 3}\n    >>> evaluate_function_after_substitution(func, subs)\n    10\n    \"\"\"\n    # Parse the function if provided as string\n    func_expr = sp.sympify(function)\n    # Substitute the values\n    substituted_expr = func_expr.subs(substitution_dict)\n    # Evaluate the expression\n    evaluated_expr = sp.simplify(substituted_expr)\n    return evaluated_expr",
        "def simplify_expression(expression: str) -> sp.Expr:\n    \"\"\"\n    Simplifies the given algebraic expression and returns the simplified result.\n    \n    Parameters:\n        expression (str): The string representation of the mathematic expression.\n    \n    Returns:\n        sympy.Expr: The simplified expression.\n    \n    Examples:\n        >>> simplify_expression(\"x**2 - 2*x + 1 + 0*x\")\n        x**2 - 2*x + 1\n        >>> simplify_expression(\"sin(x)**2 + cos(x)**2\")\n        1\n    \"\"\"\n    expr = sp.sympify(expression)\n    return sp.simplify(expr)"
    ],
    "Fractions": [
        "def decimal_to_fraction(decimal_str):\n    \"\"\"\n    Converts a decimal given as a string to the simplest form of fraction.\n    It can handle both repeating and non-repeating decimals.\n    Parameters:\n    decimal_str (str): The decimal number in string format.\n    Returns:\n    Fraction: A fraction object representing the simplest form of the given decimal.\n    Examples:\n    >>> decimal_to_fraction('0.5')\n    Fraction(1, 2)\n    >>> decimal_toference '0.333...'\n    Fraction(1, 3)\n    \"\"\"\n    if '(' in decimal_str and ')' in decimal_str:\n        # Handling repeating decimals\n        start, repetend = decimal_str.replace(')', '').split('(')\n        non_repeat_length = len(start.split('.')[1]) if '.' in start else 0\n        repeat_length = len(repetend)\n        integer_part = int(start.replace('.', ''))\n        repeat_part = int(repetend)\n        fractional_value = integer_part + repeat_part / (10**repeat_length - 1) * (10**non_repeat_length)\n        return Fraction(fractional_value).limit_denominator()\n    return Fraction(decimal_str).limit_denominator()",
        "def simplify_fraction(numerator, denominator):\n    \"\"\"\n    Simplifies a fraction given a numerator and a denominator.\n    \n    Parameters:\n        numerator (int or sympy expression): The numerator of the fraction.\n        denominator (int or sympy expression): The denominator of the fraction.\n        \n    Returns:\n        sympy.Rational: Simplified fraction.\n    \n    Examples:\n        >>> simplify_fraction(15, 35)\n        3/7\n        \n        >>> simplify_fraction(x**2 - 4, x - 2)  # where x is a sympy symbol\n        x + 2\n    \"\"\"\n    return simplify(Rational(numerator, denominator))",
        "def add_fractions(frac1, frac2):\n    \"\"\"\n    Adds two fractions and returns the result in its simplest form.\n    \n    Parameters:\n        frac1 (tuple): A tuple or list representing the first fraction (numerator, denominator).\n        frac2 (tuple): A tuple or list representing the second fraction (numerator, denominator).\n    \n    Returns:\n        tuple: Resulting fraction from the addition in its simplest form (numerator, denominator).\n    \n    Example:\n        >>> add_fractions((1, 3), (1, 6))\n        (1, 2)\n    \"\"\"\n    num1, den1 = frac1\n    num2, den2 = frac2\n    common_den = lcm(den1, den2)\n    num_result = num1 * (common_den / den1) + num2 * (common_den / den2)\n    result_gcd = gcd(num_result, common_den)\n    return (int(num_result / result_gcd), int(common_den / result_gcd))",
        "def complex_fraction_operations(expr, variables=None):\n    \"\"\"\n    Perform operations on an algebraic expression involving fractions. It simplifies the expression and can handle nested fractions.\n    Parameters\n    ----------\n    expr : sympy expression or str\n        The entire algebraic expression involving fractions to simplify.\n    variables : dict, optional\n        A dictionary mapping string representations of variables to their numerical or algebraic values.\n    Returns\n    -------\n    sympy.Expr\n        The simplified algebraic expression.\n    Examples\n    --------\n    >>> complex_fraction_operations('1/2 + 1/3 * x', {'x': 3})\n    3/2\n    >>> complex_fraction_operations('(1/2) / (1/3)')\n    3/2\n    \"\"\"\n    # Parse the expression if it's given as a string\n    if isinstance(expr, str):\n        if variables:\n            # Define symbols\n            varsymbols = {k: symbols(k) for k in variables}\n            expr = expr.format(**varsymbols)\n        expr = simplify(expr)\n    \n    if variables:\n        # Substitute values into the expression\n        substitutions = {symbols(k): v for k, v in variables.items()}\n        expr = expr.subs(substitutions)\n    \n    return simplify(expr)",
        "def simplify_fraction(frac):\n    \"\"\"\n    Simplifies a fraction to its lowest terms.\n    \n    Parameters:\n        frac (tuple): A tuple or list representing the fraction (numerator, denominator).\n    \n    Returns:\n        tuple: Simplified fraction (numerator, denominator).\n    \n    Example:\n        >>> simplify_fraction((6, 9))\n        (2, 3)\n    \"\"\"\n    num, den = frac\n    common_gcd = gcd(num, den)\n    return (int(num / common_gcd), int(den / common_gcd))",
        "def find_common_denominator(*fractions):\n    \"\"\"\n    Finds a common denominator for a series of fractions given as tuples.\n    \n    Parameters:\n        fractions (tuple): Variable length tuple argument, where each element is a tuple (numerator, denominator).\n        \n    Returns:\n        int: Least common denominator for all provided fractions.\n    \n    Examples:\n        >>> find_common_denominator((1, 2), (3, 4), (5, 6))\n        12\n    \"\"\"\n    denominators = [frac[1] for frac in fractions]\n    return lcm(denominators)",
        "def fraction_operation(a, b, operation='add'):\n    \"\"\"\n    Perform arithmetic operations on two fractions and return the result in the simplest form.\n    Parameters\n    ----------\n    a : tuple of ints or tuple of sympy.Rational\n        The numerator and denominator of the first fraction, e.g., (1, 2) for 1/2.\n    b : tuple of ints or tuple of sympy.Rational\n        The numerator and denominator of the second fraction, e.g., (3, 4) for 3/4.\n    operation : str\n        The operation to perform on the fractions ('add', 'subtract', 'multiply', 'divide').\n    Returns\n    -------\n    sympy.Rational\n        The result of the operation in its simplest form.\n    Examples\n    --------\n    >>> fraction_operation((1, 2), (3, 4), 'add')\n    5/4\n    >>> fraction_operation((1, 3), (1, 2), 'multiply')\n    1/6\n    \"\"\"\n    # Create Rational objects for the fractions\n    frac_a = Rational(*a)\n    frac_b = Rational(*b)\n    \n    # Perform the specified operation\n    if operation == 'add':\n        result = frac_a + frac_b\n    elif operation == 'subtract':\n        result = frac_a - frac_b\n    elif operation == 'multiply':\n        result = frac_a * frac_b\n    elif operation == 'divide':\n        result = frac_a / frac_b\n    else:\n        raise ValueError(\"Unsupported operation. Choose from 'add', 'subtract', 'multiply', 'divide'.\")\n    \n    # Return the simplified result\n    return simplify(result)",
        "def fraction_to_decimal(numerator, denominator):\n    \"\"\"\n    Converts a fraction represented by numerator and denominator to \n    the float decimal form.\n    Parameters\n    ----------\n    numerator : int\n        The numerator of the fraction.\n    \n    denominator : int\n        The denominator of the fraction.\n    Returns\n    -------\n    float\n        The decimal representation of the fraction.\n        \n    Examples\n    --------\n    >>> fraction_to_decimal(3, 4)\n    0.75\n    \"\"\"\n    return numerator / denominator",
        "def handle_complex_fractions(frac):\n    \"\"\"\n    Simplifies complex fractions.\n    Parameters:\n        frac (sympy expression): A complex fraction possibly involving nested fractions.\n    \n    Returns:\n        sympy expression: Simplified expression of the fraction.\n    \n    Example:\n        >>> from sympy.abc import x, y\n        >>> handle_complex_fractions((x/(y/2)+(3/4)))\n        2*x/y + 3/4\n    \"\"\"\n    return simplify(frac)",
        "def decimal_to_fraction(decimal_value):\n    \"\"\"\n    Converts a decimal number to a fraction.\n    Parameters\n    ----------\n    decimal_value : float\n        A decimal number that we want to convert to a fraction.\n    Returns\n    -------\n    Fraction\n        The fractional representation of the decimal number.\n        \n    Examples\n    --------\n    >>> decimal_to_fraction(0.75)\n    Fraction(3, 4)\n    \"\"\"\n    return Fraction(decimal_value).limit_denominator()"
    ],
    "Variables and Expressions": [
        "def simplify_expression(expression: str):\n    \"\"\"\n    Simplifies an algebraic expression provided as a string.\n    \n    Parameters:\n    expression (str): The algebraic expression to simplify.\n    Returns:\n    sympy.Expr: A simplified sympy expression.\n    Example:\n    >>> simplify_expression('x**2 + 2*x + 1')\n    (x + 1)**2\n    \"\"\"\n    expr = sp.sympify(expression)\n    return sp.simplify(expr)",
        "def evaluate_expression(expression, **variables):\n    \"\"\"\n    Evaluates a mathematical expression, potentially with variables.\n    \n    Parameters:\n    - expression (str): The expression to evaluate.\n    - variables (dict): A dictionary of variable values where keys are variable names.\n    Returns:\n    - float or int: Result of the evaluated expression.\n    \n    Examples:\n    >>> evaluate_expression('x + y', x=3, y=4)\n    7\n    >>> evaluate_expression('a * b + c', a=2, b=3, c=1)\n    7\n    \"\"\"\n    from sympy import sympify\n    expr = sympify(expression)\n    return expr.evalf(subs=variables)",
        "def expand_expression(expression):\n    \"\"\"\n    Expands the given algebraic expression.\n    Parameters:\n    - expression (str): A string containing the algebraic expression to expand.\n    Returns:\n    - sympy.Expr: The expanded form of the expression.\n    Examples:\n    >>> expand_expression(\"(x+1)*(x-1)\")\n    x**2 - 1\n    \"\"\"\n    expr = sp.sympify(expression)\n    return sp.expand(expr)",
        "def decompose_number(number):\n    \"\"\"\n    Decompose a number into its individual digits.\n    \n    Parameters:\n    - number (int): The number to decompose.\n    Returns:\n    - List[int]: A list of digits in the order they appear in the number.\n    \n    Examples:\n    >>> decompose_number(2021)\n    [2, 0, 2, 1]\n    >>> decompose_number(1234)\n    [1, 2, 3, 4]\n    \"\"\"\n    # Handle negative numbers by taking the absolute value\n    number = abs(number)\n    return [int(digit) for digit in str(number)]",
        "def manipulate_expression(expr_str, operation=\"simplify\", **values):\n    \"\"\"\n    Manipulate an algebraic expression using simplify, expand or substitute operations.\n    Parameters:\n    - expr_str (str): The expression in string form.\n    - operation (str): The type of manipulation ('simplify', 'expand', 'substitute').\n    - values (dict): Key-value pairs of variables and values for substitution.\n    \n    Returns:\n    - sympy.core.expr.Expr: The manipulated expression.\n    \n    Raises:\n    - ValueError: If an unsupported operation is provided.\n    \n    Examples:\n    >>> manipulate_expression(\"x**2 + 2*x + 1\", \"simplify\")\n    (x + 1)**2\n    \n    >>> manipulate_expression(\"x**2 + 2*x + 1\", \"expand\", x=\"(a+b)\")\n    a**2 + 2*a*b + b**2 + 2*a + 2*b + 1\n    \n    >>> manipulate_expression(\"x + y\", \"substitute\", x=1, y=2)\n    3\n    \"\"\"\n    expr = sympy.sympify(expr_str)\n    if operation == \"simplify\":\n        return simplify(expr)\n    elif operation == \"expand\":\n        return expand(expr)\n    elif operation == \"substitute\":\n        return expr.subs(values)\n    else:\n        raise ValueError(\"Unsupported operation\")",
        "def create_expression(expr):\n    \"\"\"\n    Converts a string representation of a mathematical expression into a symbolic expression.\n    \n    Parameters:\n        expr (str): The string representation of the expression.\n    \n    Returns:\n        sympy.Expr: A symbolic expression corresponding to the input string.\n        \n    Examples:\n        >>> create_expression(\"2*x + 3*y - 5\")\n        2*x + 3*y - 5\n    \"\"\"\n    return sp.sympify(expr)",
        "def decimal_to_base(n, base):\n    \"\"\"\n    Convert a decimal integer to a given base.\n    \n    Parameters:\n    n (int): The decimal number to convert.\n    base (int): The base to convert the decimal number to.\n    Returns:\n    str: The number in the specified base as a string.\n    Examples:\n    >>> decimal_to_base(10, 6)\n    '14'\n    >>> decimal_to_base(255, 16)\n    'FF'\n    \"\"\"\n    import string\n    if n < 0:\n        return '-' + decimal_to_base(-n, base)\n    elif n == 0:\n        return '0'\n    digits = []\n    while n:\n        digits.append(int(n % base))\n        n //= base\n    digits = digits[::-1]\n    return ''.join(string.hexdigits[d].upper() if base > 10 else str(d) for d in digits)",
        "def form_expression(variables, coefficients, constant=0):\n    \"\"\"\n    Form an algebraic expression based on provided variables, coefficients, and an optional constant.\n    Parameters\n    ----------\n    variables : list of str\n        List of variable names as strings.\n    coefficients : list of numbers\n        List of coefficients corresponding to each variable.\n    constant : number, optional\n        A constant term to be added to the expression (default is 0).\n    \n    Returns\n    -------\n    sympy.Expr\n        A symbolic expression representing the algebraic equation formed.\n    Examples\n    --------\n    >>> expr = form_expression(['x', 'y'], [2, 3], 5)\n    >>> str(expr)\n    '2*x + 3*y + 5'\n    \"\"\"\n    if len(variables) != len(coefficients):\n        raise ValueError(\"The number of variables must match the number of coefficients\")\n    \n    expr = sp.sympify(0)\n    for var, coef in zip(variables, coefficients):\n        expr += coef * sp.symbols(var)\n    \n    expr += constant\n    return expr",
        "def simplify_expression(expr):\n    \"\"\"\n    Simplifies a mathematical expression and calculates the units digit.\n    Parameters:\n        expr (str): A string representing the mathematical expression.\n        \n    Returns:\n        tuple: simplified expression, units digit of the numerical value if evaluable.\n    Examples:\n        >>> simplify_expression(\"3*x + 5 - 2*x\")\n        (x + 5, None)\n        >>> simplify_expression(\"10*2 + 3\")\n        (23, 3)\n    \"\"\"\n    x = symbols('x')  # Define symbol; more can be added based on needs\n    expr_sym = simplify(expr)  # Simplifies the expression\n    \n    try:\n        # Evaluate the expression if possible and calculate units digit\n        units_digit = Mod(expr_sym, 10).evalf()\n        return expr_sym, units_digit\n    except:\n        return expr_sym, None",
        "def convert_number_from_base_to_base(number, from_base, to_base):\n    \"\"\"\n    Convert a number from one base to another.\n    Parameters:\n    number: str, the number in the 'from_base' base system as a string\n    from_base: int, the base system of the given number\n    to  from_base and to_base must be between 2 and 36.\n    Returns:\n    str: the number in the 'to_base' base system as a string\n    Examples:\n    >>> convert_number_from_base_to_base('25', 10, 6)\n    '41'\n    >>> convert_number_from_base_to_base('101', 2, 10)\n    '5'\n    \"\"\"\n    from_base_int = int(number, base=from_base)\n    if to_base == 10:\n        return str(from_base_int)\n    else:\n        # Convert integer to specified base\n        result = ''\n        while from_base_int > 0:\n            remainder = from_base_int % to_base\n            if remainder < 10:\n                result = str(remainder) + result\n            else:\n                result = chr(remainder - 10 + ord('A')) + result\n            from_base_int //= to_base\n        return result or '0'",
        "class ExpressionHandler:\n    \"\"\"\n    This class handles creation, manipulation, and simplification of algebraic expressions.\n    \n    Parameters\n    ----------\n    expression : str\n        A string representation of the algebraic expression.\n    Examples\n    --------\n    >>> expr_handler = ExpressionHandler(\"x**2 - 2*x + 1\")\n    >>> expr_handler.simplify_expression()\n    (x - 1)**2\n    \n    >>> expr_handler.factor_expression()\n    (x - 1)**2\n    \n    >>> expr_handler.expand_expression()\n    x**2 - 2*x + 1\n    \"\"\"\n    \n    def __init__(self, expression):\n        self.symbol_dict = {}\n        self.expression_string = expression\n        self.expression = simplify(expression)\n        \n    def simplify_expression(self):\n        \"\"\" Simplify the algebraic expression. Returns the simplified expression. \"\"\"\n        return simplify(self.expression)\n    \n    def factor_expression(self):\n        \"\"\" Factorize the algebraic expression. Returns the factorized form.\"\"\"\n        return factor(self.expression)\n    \n    def expand_expression(self):\n        \"\"\" Expand the algebraic expression. Returns the expanded form.\"\"\"\n        return expand(self.expression)\n    \n    def substitute_values(self, **value_dict):\n        \"\"\"\n        Substitute values into the expression.\n        Parameters\n        ----------\n        value_dict : dict\n            A dictionary containing variable mappings.\n        Returns\n        -------\n        expression : sympy expression\n            New expression after substitution.\n        Examples\n        --------\n        >>> expr_handler = ExpressionHandler(\"x + y\")\n        >>> expr_handler.substitute_values(x=1, y=3)\n        4\n        \"\"\"\n        return self.expression.subs(value_dict)",
        "def subtract_expressions(expr1, expr2):\n    \"\"\"\n    Subtracts the second expression from the first and simplifies the result.\n    Parameters:\n    - expr1 (str): The first expression from which the second is to be subtracted.\n    - expr2 (str): The second expression to subtract from the first one.\n    Returns:\n    - sympy.Expr: The result of the expression `expr1 - expr2` simplified.\n    Examples:\n    >>> subtract_expressions(\"x**2 + 3*x + 2\", \"x + 1\")\n    x**2 + 2*x + 1\n    \"\"\"\n    expr1_sympified = sympify(expr1)\n    expr2_sympified = sympify(expr2)\n    return simplify(expr1_sympified - expr2_sympified)",
        "def handle_fractions_and_percentages(fraction=None, percentage=None):\n    \"\"\"\n    Converts fractions to decimal or percentage to decimal.\n    Parameters:\n    - fraction (tuple of two integers, optional): The numerator and denominator of the fraction as (numerator, denominator). Defaults to None.\n    - percentage (float, optional): The percentage value to convert to decimal. Defaults to None.\n    Returns:\n    - float: The decimal representation of the fraction or percentage.\n    Examples:\n    \n    >>> handle_fractions_and_percentages(fraction=(1, 4))\n    0.25\n    >>> handle_fractions_and_percentages(percentage=50)\n    0.5\n    \"\"\"\n    if fraction:\n        return N(Rational(*fraction))\n    if percentage:\n        return percentage / 100.0\n    raise ValueError(\"Either fraction or percentage must be provided\")",
        "def create_equation_from_word_problem(text, variables, equation_form):\n    \"\"\"\n    Generates an algebraic equation from a textual description (word problem).\n    \n    Parameters:\n        text (str): Description of the problem which may include numeric values and context.\n        variables (dict): A dictionary mapping variable names as keys to their descriptions or symbolic representations.\n        equation_form (str): A string representation of how the variables relate algebraically to form an equation.\n    \n    Returns:\n        sympy.Eq: A symbolic equation representing the word problem.\n        \n    Examples:\n        >>> create_equation_from_word_problem(\n        ...     \"John has x apples, and Mary has y apples, together they have 20 apples.\",\n        ...     {'x': 'John', 'y': 'Mary'},\n        ...     \"x + y = 20\"\n        ... )\n        Eq(x + y, 20)\n    \"\"\"\n    # Replace variable descriptions with symbolic representations, if necessary\n    for var, desc in variables.items():\n        text = text.replace(desc, var)\n    # Evaluate the expression to create the corresponding equation\n    lhs, rhs = equation_form.split('=')\n    lhs_expr = sp.sympify(lhs.strip())\n    rhs_expr = sp.sympify(rhs.strip())\n    \n    return sp.Eq(lhs_expr, rhs_expr)",
        "def solve_expression_for(expr, variable, target=0):\n    \"\"\"\n    Solves the given expression for the specified variable, equating it to a target value.\n    \n    Parameters:\n    ----------\n    expr : sympy.Expr\n        Expression to solve.\n    variable : str\n        The variable in the expression to solve for.\n    target : number, optional\n        The value for which the expression is solved. Default is 0.\n    \n    Returns:\n    -------\n    list\n        List of solutions solving expr = target.\n    \n    Examples:\n    --------\n    >>> x = sp.symbols('x')\n    >>> solve_expression_for(x**2 - 4, 'x')\n    [2, -2]\n    \"\"\"\n    return sp.solve(expr - target, sp.symbols(variable))",
        "def is_four_digit_year(year):\n    \"\"\"\n    Checks whether a number is a valid four-digit year.\n    \n    Parameters:\n        year (int): The year to validate.\n    \n    Returns:\n        bool: True if the year is a four-digit integer, False otherwise.\n        \n    Examples:\n        >>> is_four_digit_year(2023)\n        True\n        \n        >>> is_four_digit_year(999)\n        False\n        \n        >>> is_four_digit_year(10000)\n        False\n    \"\"\"\n    return 1000 <= year <= 9999",
        "class EquationSolver:\n    \"\"\"\n    This tool provides functionality to solve equations and decompose numbers into primes.\n    \n    Examples\n    --------\n    >>> eq_solver = EquationSolver()\n    >>> eq_solver.solve_equation(\"x**2 - 5*x + 6 = 0\")\n    [2, 3]\n    >>> eq_solver.prime_factors(100)\n    [2, 2, 5, 5]\n    \"\"\"\n    \n    @staticmethod\n    def solve_equation(equation):\n        \"\"\"\n        Solves an algebraic equation.\n        \n        Parameters\n        ----------\n        equation : str\n            A string representing the equation to solve.\n            \n        Returns\n        -------\n        solutions : list\n            List of solutions to the equation.\n        \"\"\"\n        # Parse the equation\n        lhs, rhs = equation.split('=')\n        eq = Eq(sp.sympify(lhs), sp.sympify(rhs))\n        # Solve the equation\n        return sp.solve(eq)\n    @staticmethod\n    def prime_factors(number):\n        \"\"\"\n        Decompose a number into its prime factors.\n        \n        Parameters\n        ----------\n        number : int\n            The integer to factorize.\n            \n        Returns\n        -------\n        factors : list\n            List of prime factors.\n        \"\"\"\n        return sp.ntheory.factorint(number, visual=True).as_ordered_factors()",
        "def build_expression(variable_descriptions, expression_desc):\n    \"\"\"\n    Constructs an algebraic expression based on given variable descriptions and an expression formula.\n    \n    Parameters\n    ----------\n    variable_descriptions : dict\n        A dictionary where keys are variable names (as strings) and values are potential numerical values or descriptions.\n    expression_desc : str\n        A string describing the algebraic expression using the variables.\n    Returns\n    -------\n    sympy.Expr\n        The constructed algebraic expression.\n    \n    Examples\n    --------\n    >>> build_expression({'x': 'unknown quantity', 'y': 2}, 'x + 3*y')\n    x + 6\n    \"\"\"\n    # Create symbols for each variable\n    variables = {var: symbols(var) for var in variable_descriptions.keys()}\n    # Replace numbers and evaluate the expression\n    expression = sympify(expression_desc, locals=variables)\n    # Substitute any known values\n    known_values = {variables[k]: v for k, v in variable_descriptions.items() if isinstance(v, (int, float))}\n    return expression.subs(known_values)"
    ],
    "Exponential Growth": [
        "def exponential_amount(initial_amount, rate, time, decay=False):\n    \"\"\"\n    Calculate the amount after a given time with an exponential growth or decay rate.\n    Parameters:\n    - initial_amount (float): The initial value or amount before exponential change.\n    - rate (float): The rate of growth or decay. For growth, provide > 0; for decay use < 0.\n    - time (float): The time over which the rate is applied.\n    - decay (bool): True if it's exponential decay, False if it's exponential growth.\n    Returns:\n    float: The amount after applying the exponential growth or decay.\n    Examples:\n    >>> exponential_amount(100, 0.05, 10, decay=False)\n    162.8894626777442\n    >>> exponential_amount(100, -0.05, 10, decay=True)\n    61.39132535489959\n    \"\"\"\n    if decay:\n        rate = -rate\n    return initial_amount * math.exp(rate * time)",
        "def solve_initial_amount(final_amount, rate, time, decay=False):\n    \"\"\"\n    Determine the initial amount needed to achieve a final amount after applying an exponential rate over time.\n    Parameters:\n    - final_amount (float): The desired final amount.\n    - rate (float): The rate of growth or decay.\n    - time (float): The time over which the exponential rate is applied.\n    - decay (bool): True if concerning exponential decay, otherwise False for growth.\n    Returns:\n    float: The required initial amount to achieve the final_amount after the time with the given rate.\n    Examples:\n    >>> solve_initial_amount(200, 0.05, 10, decay=False)\n    122.14027581601698\n    \"\"\"\n    if decay:\n        rate = -rate\n    return final_amount / math.exp(rate * time)",
        "def number_of_doublings(initial_amount, final_amount):\n    \"\"\"\n    Calculates the number of doublings required to reach from initial_amount to final_amount.\n    Parameters:\n    - initial_amount (float): The starting amount.\n    - final_amount (float): The final amount after doublings.\n    Returns:\n    float: The number of doublings needed.\n    Examples:\n    >>> number_of_doublings(100, 800)\n    3.0\n    \"\"\"\n    return math.log(final_amount / initial_amount) / math.log(2)"
    ],
    "Multiplication": [
        "def product_gcd_lcm_relation(a, b):\n    \"\"\"\n    Checks the relation a * b = gcd(a, b) * lcm(a, b).\n    Parameters:\n    a : int\n        First integer.\n    b : int\n        Second integer.\n    Returns:\n    bool\n        True if the product of a and b equals the product of their gcd and lcm, False otherwise.\n    Examples:\n    >>> product_gcd_lcm_relation(12, 15)\n    True\n    \"\"\"\n    gcd = math.gcd(a, b)\n    lcm = (a * b) // gcd\n    return a * b == gcd * lcm",
        "def price_quantity_product(quantity, price_per_unit, in_cents=False):\n    \"\"\"\n    Calculates the total cost from quantity and price per unit. Can convert the result to cents.\n    \n    Parameters:\n    quantity (int): Amount of items being purchased.\n    price_per_unit (float): Cost per single item.\n    in_cents (bool): If True, return the result in cents instead of dollars.\n    Returns:\n    float: Total cost, optionally converted to cents if in_cents is True.\n    \n    Examples:\n    >>> price_quantity_product(5, 19.99)\n    99.95\n    \n    >>> price_quantity_product(100, 0.25, in_cents=True)\n    2500.0\n    \"\"\"\n    total_price = quantity * price_per_unit\n    if in_cents:\n        total_price *= 100\n    return total_price",
        "def multiply(a, b):\n    \"\"\"\n    Multiply two numbers a and b.\n    Parameters:\n    a (int or float): First number to multiply.\n    b (int or float): Second number to multiply.\n    Returns:\n    int or float: The product of a and b.\n    Example:\n    >>> multiply(4, 5)\n    20\n    \"\"\"\n    return a * b",
        "def min_product(values):\n    \"\"\"\n    Determines the minimum product from a list of pairs of numbers.\n    Parameters:\n    values : list of tuple\n        A list where each element is a tuple containing two numbers to be multiplied.\n    Returns:\n    tuple\n        Returns the tuple resulting in the minimum product and the minimum product itself.\n    Examples:\n    >>> min_product([(10, 20), (1, 5), (2, 2)])\n    ((2, 2), 4)\n    \"\"\"\n    products = [(a * b, (a, b)) for a, b in values]\n    return min(products)[1], min(products)[0]",
        "def combinatorial_multiplication(*args):\n    \"\"\"\n    Multiply several numbers together to find the total product, commonly used\n    in combinatorial problems and total outcome calculations.\n    \n    Parameters:\n    *args (int): An indefinite number of integer values to be multiplied.\n    \n    Returns:\n    int: Product of all the input integers.\n    \n    Examples:\n    >>> combinatorial_multiplication(5, 6, 3)\n    90\n    >>> combinatorial_multiplication(10, 2)\n    20\n    \"\"\"\n    from functools import reduce\n    return reduce(lambda x, y: x * y, args)",
        "def multiply_and_convert_to_dollars(amounts, prices):\n    \"\"\"\n    Multiplies quantities by prices and then converts from cents to dollars.\n    Parameters:\n    amounts : list of int\n        Quantities of items.\n    prices : list of int\n        Prices per unit in cents.\n    Returns:\n    list of float\n        Total cost for each item in dollars.\n    Examples:\n    >>> multiply_and_convert_to_dollars([10, 15], [99, 203])\n    [9.9, 30.45]\n    \"\"\"\n    return [(a * p) / 100 for a, p in zip(amounts, prices)]",
        "def multiply_numbers(*args):\n    \"\"\"\n    Multiplies two or more numbers together.\n    Parameters:\n    *args : float or int\n        A variable number of arguments which are the numbers to be multiplied.\n    Returns:\n    float\n        The product of the provided numbers.\n    Examples:\n    >>> multiply_numbers(12, 15)\n    180\n    >>> multiply_numbers(2, 3, 4)\n    24\n    >>> multiply_numbers(1.5, 2)\n    3.0\n    \"\"\"\n    return np.prod(args)",
        "def product_comparison(*args, comparison='min'):\n    \"\"\"\n    Calculates the products of pairs of arguments provided and returns either the minimum or maximum product depending on the comparison parameter.\n    Parameters:\n    *args (tuple of tuples): Pairs of numbers to multiply.\n    comparison (str): Accepts 'min' or 'max'; Based on this products will be compared to return either the minimum or maximum product.\n    Returns:\n    int or float: The minimum or maximum product from the provided pairs of numbers.\n    Example:\n    >>> product_comparison((4, 5), (2, 3), comparison='min')\n    6\n    >>> product_cmparison((4, 5), (2, 10), comparison='max')\n    40\n    \"\"\"\n    import numpy as np\n    products = [np.prod(pair) for pair in args]\n    return min(products) if comparison == 'min' else max(products)"
    ],
    "Percentages": [
        "def apply_percentage_change(original_value, percentage_change):\n    \"\"\"\n    Calculates the new value after applying a percentage change to the original value.\n    Parameters:\n    original_value (float): The original numerical value before any percentage alteration.\n    percentage_change (float): The percentage by which the original value is to be increased or decreased.\n                               Positive values for increase and negative for decrease.\n    Returns:\n    float: The new value after the percentage change has been applied.\n    Examples:\n    >>> apply_percentage_noticing(100, 20)\n    120.0\n    >>> apply_percentage_change(200, -15)\n    170.0\n    \"\"\"\n    # Calculate the new value after percentage change\n    return original_value * (1 + percentage_change / 100)",
        "def percentage_of_total(percentage, total):\n    \"\"\"\n    Calculate the absolute value that corresponds to a certain percentage of a given total.\n    \n    Parameters:\n    - percentage (float): The percentage value to apply (e.g., for 25%, provide 25.0).\n    - total (float): The total value from which to calculate the percentage.\n    \n    Returns:\n    - float: The absolute value corresponding to the given percentage of the total.\n    \n    Example:\n    >>> percentage_of_total(25.0, 200)\n    50.0\n    \"\"\"\n    return (percentage / 100) * total",
        "def calculate_percentage(part, whole):\n    \"\"\"\n    Calculate the percentage that `part` represents of `whole`.\n    Parameters:\n    - part (float or int): The part of the whole you're interested in.\n    - whole (float or int): The total or whole value.\n    Returns:\n    float: The percentage that the `part` represents of the `whole`.\n    Example:\n    - calculate_percentage(50, 200) -> 25.0\n    \"\"\"\n    return (part / whole) * 100",
        "def convert_percentage(fullness, state='full'):\n    \"\"\"\n    Convert between different percentage descriptions, specifically handling 'full' vs 'empty' descriptions.\n    \n    Parameters:\n    - fullness (float): The percentage value to convert.\n    - state (str): The initial state of the percentage, can be 'full' or 'empty'. Defaults to 'full'.\n                   'full' indicates the percentage provided is how full something is.\n                   'empty' converts how empty something is to how full it is.\n    Returns:\n    float: The converted percentage based on the state.\n    \n    Examples:\n    >>> convert_percentage(80, 'full')\n    80.0\n    >>> convert_percentage(20, 'empty')\n    80.0\n    \"\"\"\n    if state.lower() == 'full':\n        return fullness\n    elif state.lower() == 'empty':\n        return 100 - fullness\n    else:\n        raise ValueError(\"Unsupported state specified. Use 'full' or 'empty'.\")",
        "def percentage_full_to_empty(percent_full):\n    \"\"\"\n    Given a percentage that represents how full a quantity is, calculate how empty it is.\n    Parameters:\n    - percent_full (float or int): Percentage representing how full something is.\n    Returns:\n    float: Percentage representing how empty it is.\n    Example:\n    - percentage_full_to_empty(30) -> 70\n    \"\"\"\n    return 100 - percent_full",
        "def calculate_percentage(value, percent, operation='of'):\n    \"\"\"\n    Calculate the percentage of a number, or determine what percentage a number is of another number.\n    \n    Parameters:\n    - value (float or tuple): If operating in 'of' or 'change' modes, this is the number from which to calculate the percentage.\n                              If operating in 'isof' mode, a tuple of two numbers (part, whole) where `part` is what percentage of `whole`.\n    - percent (float): The percentage to use in the calculation.\n    - operation (str): The operation to perform. Options include:\n                       'of' for finding `percent`% of `value`.\n                       'isof' for finding what percent `value[0]` is `value[1]`.\n                       'increase' to increase `value` by `percent`%.\n                       'decrease' to decrease `value` by `percent`%.\n    Returns:\n    float: Result of the percentage operation.\n    \n    Examples:\n    >>> calculate_percentage(200, 10, 'of')\n    20.0\n    >>> calculate_percentage((50, 200), 0, 'isof')\n    25.0\n    >>> calculate_percentage(100, 15, 'increase')\n    115.0\n    >>> calculate_percentage(100, 15, 'decrease')\n    85.0\n    \"\"\"\n    if operation == 'of':\n        return (value * percent) / 100\n    elif operation == 'isof':\n        part, whole = value\n        return (part / whole) * 100\n    elif operation == 'increase':\n        return value * (1 + (percent / 100))\n    elif operation == 'decrease':\n        return value * (1 - (percent / 100))\n    else:\n        raise ValueError(\"Unsupported operation specified.\")"
    ],
    "Divisibility": [
        "def is_divisible(n, d):\n    \"\"\"\n    Check if a number n is divisible by another number d.\n    Parameters:\n    n (int): The number to be checked for divisibility.\n    d (int): The divisor.\n    Returns:\n    bool: True if n is divisible by d, False otherwise.\n    \n    Examples:\n    >>> is_divisible(10, 2)\n    True\n    >>> is_divisible(7, 3)\n    False\n    \"\"\"\n    return n % d == 0",
        "def adjust_to_be_divisible(n, divisor):\n    \"\"\"\n    Adjust n to the nearest number less than or equal to n that is divisible by divisor.\n    Parameters:\n    - n (int): The number to be adjusted.\n    - divisor (int): The divisor to achieve divisibility.\n    Returns:\n    int: The adjusted number that is divisible by divisor.\n    Examples:\n    >>> adjust_to_be_divisible(14, 5)\n    10\n    >>> adjust_to_be_divisible(23, 4)\n    20\n    \"\"\"\n    return n - (n % divisor)",
        "def polynomial_divisibility(polynomial, divisor):\n    \"\"\"\n    Evaluates polynomial divisibility under modular arithmetic conditions.\n    \n    Parameters:\n    - polynomial : sp.Poly\n        A sympy polynomial object.\n    - divisor : int\n        The divisor for modular arithmetic.\n        \n    Returns:\n    - bool\n        True if polynomial is zero under modulo `divisor`, otherwise False.\n    \n    Examples:\n    >>> x = sp.symbols('x')\n    >>> poly = sp.Poly(x**2 - 2*x + 1)\n    >>> polynomial_divisibility(poly, 2)\n    True\n    \"\"\"\n    poly_mod = polynomial.as_expr() % divisor\n    return sp.simplify(poly_mod) == 0",
        "def find_common_divisors(a, b):\n    \"\"\"\n    Find common divisors of two numbers.\n    \n    Parameters:\n    a (int): First number.\n    b (int): Second number.\n    \n    Returns:\n    list: A list of common divisors between a and b.\n    \n    Examples:\n    >>> find_common_divisors(12, 18)\n    [1, 2, 3, 6]\n    >>> find_common_divisors(13, 17)\n    [1]\n    \"\"\"\n    return sorted(list(sp.divisors(sp.gcd(a, b))))",
        "def remainder_when_divided_by(n, divisor):\n    \"\"\"\n    Calculate the remainder of n divided by divisor.\n    Parameters:\n    - n (int): The numerator.\n    - divisor (int): The denominator.\n    Returns:\n    int: The remainder of n divided by divisor.\n    Examples:\n    >>> remainder_when_divided_by(10, 3)\n    1\n    >>> remainder_when_divided_by(25, 5)\n    0\n    \"\"\"\n    return n % divisor",
        "def sum_of_digits_divisible_by(n, divisor):\n    \"\"\"\n    Check if the sum of the digits of n is divisible by divisor.\n    Parameters:\n    - n (int): The number whose digits are to be summed.\n    - divisor (int): The divisor to check against.\n    Returns:\n    bool: True if the sum of the digits is divisible by the divisor.\n    Examples:\n    >>> sum_of_digits_divisible_by(123, 3)\n    True\n    >>> sum_of_digits_divisible_by(124, 3)\n    False\n    \"\"\"\n    return sum(int(digit) for digit in str(n)) % divisor == 0",
        "def is_even_or_odd(number):\n    \"\"\"\n    Determines if the number is even or odd.\n    \n    Parameters:\n    - number : int\n        The number to check.\n        \n    Returns:\n    - str\n        \"even\" if number is even, \"odd\" if number is odd.\n    \n    Examples:\n    >>> is_even_or_odd(4)\n    'even'\n    >>> is_even_or_odd(7)\n    'odd'\n    \"\"\"\n    return \"even\" if number % 2 == 0 else \"odd\"",
        "def calculate_remainder(dividend, divisor):\n    \"\"\"\n    Calculates the remainder of the division of dividend by divisor.\n    \n    Parameters:\n    - dividend : int\n        The number to be divided.\n    - divisor : int\n        The number which divides.\n        \n    Returns:\n    - int\n        The remainder when `dividend` is divided by `divisor`.\n        \n    Examples:\n    >>> calculate_remainder(10, 3)\n    1\n    >>> calculate_remainder(25, 4)\n    1\n    \"\"\"\n    return dividend % divisor",
        "def is_divisible_by_digit_sum(number):\n    \"\"\"\n    Check if the number is divisible by the sum of its digits.\n    \n    Parameters:\n    - number : int\n        The number to check.\n        \n    Returns:\n    - bool\n        True if `number` is divisible by the sum of its digits, False otherwise.\n    \n    Examples:\n    >>> is_divisible_by_digit_sum(123)\n    False\n    >>> is_divisible_by_digit_sum(111)\n    True\n    \"\"\"\n    digit_sum = sum(map(int, str(number)))\n    return number % digit_sum == 0"
    ]
}