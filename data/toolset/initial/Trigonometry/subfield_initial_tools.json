{"Sine and Cosine Functions": ["def sine(angle: float, radians: bool = True) -> float:\n    \"\"\"\n    Calculate the sine of an angle provided in radians or degrees.\n    Parameters:\n    angle (float): The angle.\n    radians (bool): If True, the angle is in radians; if False, it's in degrees.\n    Returns:\n    float: The sine of the angle.\n    \"\"\"\n    if not radians:\n        angle = to_radians(angle)\n    return math.sin(angle)", "def simplify_trig_expression(exp):\n    \"\"\"\n    Use sympy to simplify the given trigonometric expression.\n    \n    Parameters\n    ----------\n    exp : sympy expression\n        The trigonometric expression to be simplified.\n    Returns\n    -------\n    simplified_expression: sympy expression\n        The simplified form of the input expression.\n    Example\n    --------\n    >> from sympy import symbols, cos, sin\n    >> x = symbols('x')\n    >> expression = sin(x)**2 + cos(x)**2\n    >> simplify_trig_expression(expression)\n    \"\"\"\n    from sympy import simplify\n    simplified_expression = simplify(exp)\n    return simplified_expression", "def to_radians(degrees: float) -> float:\n    \"\"\"\n    Convert an angle from degrees to radians.\n    Parameters:\n    degrees (float): Angle in degrees.\n    Returns:\n    float: Angle in radians.\n    \"\"\"\n    return math.radians(degrees)", "def calculate_sine_cosine(opposite, adjacent, hypotenuse):\n    \"\"\"\n    Calculate the sine and cosine of an angle in a right triangle.\n    Parameters:\n    opposite (float): The length of the side opposite the angle.\n    adjacent (float): The length of the side adjacent to the angle.\n    hypotenuse (float): The length of the hypotenuse.\n    Returns:\n    dict: A dictionary with the sine and cosine of the angle.\n    \"\"\"\n    import math\n    sine = opposite / hypotenuse\n    cosine = adjacent / hypotenuse\n    return {\"sine\": sine, \"cosine\": cosine}", "def evaluate_sin_cos(angle, in_degrees=True):\n    \"\"\"\n    This function takes an angle and returns its sine and cosine.\n    \n    Parameters\n    ----------\n    angle : float\n        The angle, measured in degrees by default, to compute the sine and cosine of.\n    in_degrees : bool, optional\n        A flag that specifies whether the input angle is in degrees. Default is True.\n        \n    Returns\n    -------\n    tuple\n        The sine and cosine of the angle as a tuple (sin, cos).\n    \"\"\"\n    \n    if in_degrees:\n        angle = math.radians(angle)\n        \n    sin_val = math.sin(angle)\n    cos_val = math.cos(angle)\n    \n    return sin_val, cos_val", "def triangle_solver(a=None, b=None, c=None, A=None, B=None, C=None):\n    \"\"\"\n    Solve a triangle's missing sides and angles using known values.\n    Parameters can be side (lowercase) or angle (uppercase, in degrees).\n    At least three parameters with at least one side must be known, with at least one opposite side-angle pair.\n    \n    Parameters:\n        a, b, c (float): sides of the triangle\n        A, B, C (float): angles opposite the sides (in degrees)\n    \n    Returns:\n        dict: Dictionary of all triangle sides and angles\n    \n    Examples:\n        >>> triangle_solver(a=5, B=45, C=45)\n        {'a': 5, 'b': 5.0, 'c': 5.0, 'A': 90.0, 'B': 45, 'C': 45}\n        \n        >>> triangle_solver(a=3, b=4, A=53.13)\n        {'a': 3, 'b': 4, 'c': 5.0, 'A': 53.13, 'B': 36.87, 'C': 90.0}\n    \"\"\"\n    sides = {'a': a, 'b': b, 'c': c}\n    angles = {'A': A, 'B': B, 'C': C}\n    \n    # Converting all know angles to radians for computation\n    for k, v in angles.items():\n        if v is not null:\n            angles[k] = np.radians(v)\n    \n    if A is not None and a is not None:\n        if B is not None:\n            angles['C'] = np.pi - (angles['A'] + angles['B'])\n            sides['c'] = (sides['a'] * np.sin(angles['C'])) / np.sin(angles['A'])\n        elif C is not None:\n            angles['B'] = np.pi - (angles['A'] + angles['C'])\n            sides['b'] = (sides['a'] * np.sin(angles['B'])) / np.sin(angles['A'])\n            \n    # Convert all angles back to degrees for output\n    for k, v in angles.items():\n        angles[k] = np.degrees(v)\n        \n    return {**sides, **angles}", "def convert_angle(angle, from_unit='degrees', to_unit='radians'):\n    \"\"\"\n    Convert an angle from one unit (degrees or radians) to another.\n    Parameters:\n        angle (float): The angle to convert.\n        from_unit (str): The current unit of the angle ('degrees' or 'radians').\n        to_unit (str): The target unit for the conversion ('degrees' or 'radians').\n    Returns:\n        float: The angle in the target unit.\n    Example:\n        >>> convert_angle(180, from_unit='degrees', to_unit='radians')\n        3.141592653589793\n        >>> convert_angle(np.pi, from_unit='radians', to_unit='degrees')\n        180.0\n    \"\"\"\n    if from_unit == 'degrees' and to_unit == 'radians':\n        return np.radians(angle)\n    elif from_unit == 'radians' and to_unit == 'degrees':\n        return np.degrees(angle)\n    else:\n        raise ValueError(\"Invalid conversion units provided. Use 'degrees' or 'radians'.\")", "def angle_addition(angle1, angle2, function=math.sin, in_degrees=True):\n    \"\"\"\n    This function takes two angles and a trigonometric function (sin or cos), \n    and returns the value that results from applying the angle addition formula.\n    \n    Parameters\n    ----------\n    angle1 : float\n        The first angle, measured in degrees by default.\n    angle2 : float\n        The second angle, measured in degrees by default.\n    function : {math.sin, math.cos}, optional\n        The trigonometric function to use in the angle addition formula - either the sine or cosine. Default is math.sin. \n    in_degrees : bool, optional\n        A flag that specifies whether the input angles are in degrees. Default is True.\n        \n    Returns\n    -------\n    float\n        The value that results from applying the angle addition formula.\n    \"\"\"\n    \n    if in_degrees:\n        angle1 = math.radians(angle1)\n        angle2 = math.radians(angle2)\n        \n    if function == math.sin:\n        # sin(a+b) = sin(a)cos(b) + cos(a)sin(b)\n        result = math.sin(angle1) * math.cos(angle2) + math.cos(angle1) * math.sin(angle2)\n    elif function == math.cos:\n        # cos(a+b) = cos(a)cos(b) - sin(a)sin(b)\n        result = math.cos(angle1) * math.cos(angle2) - math.sin(angle1) * math.sin(angle2)\n    \n    return result", "def solve_right_triangle(opposite=None, adjacent=None, hypotenuse=None, angle=None, degrees=True):\n    \"\"\"\n    Solve missing sides and angles in a right triangle given any of the sides or one angle.\n    Parameters:\n    - opposite (float): Length of the side opposite the angle.\n    - adjacent (float): Length of the side adjacent to the angle.\n    - hypotenuse (float): Length of the hypotenuse.\n    - angle (float): Angle adjacent to the opposite side.\n    - degrees (bool): If True, the angle is provided in degrees.\n    Returns:\n    - dict: Dictionary containing calculated values of sides and the angle.\n    \n    Examples:\n    >>> solve_right_triangle(opposite=3, adjacent=4)\n    {'hypotenuse': 5.0, 'angle': 36.86989764584402}\n    >>> solve_right_triangle(hypotenuse=5, angle=30)\n    {'opposite': 2.5, 'adjacent': 4.330127018922194}\n    \"\"\"\n    results = {}\n    if angle is not None and opposite is not None and hypotenuse is None:\n        hypotenuse = opposite / sine(angle, degrees)\n        results['hypotenuse'] = hypotenuse\n    if angle is not None and adjacent is not None and hypotenuse is None:\n        hypotenuse = adjacent / cosine(angle, degrees)\n        results['hypotenuse'] = hypotenuse\n    if hypotenuse is not None and opposite is not None and adjacent is None:\n        adjacent = sqrt(hypotenuse**2 - opposite**2)\n        results['adjacent'] = adjacent\n    if angle is not None and degrees is not None and opposite is None and hypotenuse is not None:\n        opposite = sine(angle, degrees) * hypotenuse\n        results['opposite'] = opposite\n    if angle is None and opposite is not None and hypotenuse is not None:\n        angle = np.degrees(np.arcsin(opposite / hypotenuse))\n        results['angle'] = angle\n    if angle is None and adjacent is not None and hypotenuse is not None:\n        angle = np.degrees(np.arccos(adjacent / hypotenuse))\n        results['angle'] = angle\n    # Populate missing values based on what was calculated\n    if 'hypotenuse' in results and 'opposite' not in results and adjacent is not None:\n        results['opposite'] = sqrt(results['hypotenuse']**2 - adjacent**2)\n    if 'hypotenuse' in results and 'adjacent' not in results and opposite is not None:\n        results['adjacent'] = sqrt(results['hypotenuse']**ero_ek** - opposite**2)\n    return results", "def transform_trig_identity(expr, identity):\n    \"\"\"\n    Transforms a trigonometric expression by applying a chosen trigonometric identity.\n    \n    Parameters:\n    - expr (str): The initial trigonometric expression.\n    - identity (str): The identity to apply, e.g., 'Pythagorean' for 'sin^2(x) + cos^2(x) = 1'.\n    \n    Returns:\n    str: The transformed trigonometric expression.\n    Examples:\n    >>> transform_trig_identity('sin(x)**2 + cos(x)**2', 'Pythagorean')\n    '1'\n    \"\"\"\n    if identity == 'Pythagorean':\n        expr = expr.replace('sin(x)**2 + cos(x)**2', '1')\n    return expr", "def calculate_triangle_area(base, height):\n    \"\"\"\n    Calculate the area of a triangle given the base and height.\n    Parameters:\n    base (float): The length of the base of the triangle.\n    height (float): The length of the height of the triangle.\n    Returns:\n    float: The area of the triangle.\n    \"\"\"\n    return 0.5 * base * height", "def evaluate_trig_function(fn, value):\n    \"\"\"\n    Evaluate trigonometric function at a specific value.\n    Parameters\n    ----------\n    fn : function\n        The trigonometric function; could be sin, cos, etc.\n    value : number\n        The value at which to evaluate the function.\n    Returns\n    -------\n    result : float\n        The result of the function evaluation.\n    Example\n    --------\n    >> evaluate_trig_function(np.sin, np.pi/2)\n    \"\"\"\n    result = fn(value)\n    return result", "def evaluate_trig_expression(expr, value_dict):\n    \"\"\"\n    Evaluates a trigonometric expression based on given angle values.\n    \n    Parameters:\n    - expr (str): The trigonometric expression to evaluate (e.g., 'sin(x) + cos(y)').\n    - value_dict (dict): A dictionary with variable-angle mappings in radians (e.g., {'x': np.pi/4, 'y': np.pi/3}).\n    \n    Returns:\n    float: Evaluated result of the expression.\n    Examples:\n    >>> evaluate_trig_expression('sin(x) + cos(y)', {'x': np.pi/4, 'y': np.pi/3})\n    1.3660254037844386\n    \"\"\"\n    # Use np functions for trigonometric calculations\n    for var, value in value_dict.items():\n        exec(f\"{var} = {value}\")\n    return eval(expr, {'sin': np.sin, 'cos': np.cos, 'tan': np.tan, '__builtins__': None}, locals())", "def calculate_side_given_angle(angle, side, function):\n    \"\"\"\n    Calculate the length of a side in a right triangle given the length of\n    another side and the sine or cosine of an angle.\n    Parameters:\n    angle (float): The angle in radians.\n    side (float): The length of a known side.\n    function (str): The function to use (\"sine\" or \"cosine\").\n    Returns:\n    float: The length of the other side.\n    \"\"\"\n    import math\n    if function == \"sine\":\n        return side / math.sin(angle)\n    if function == \"cosine\":\n        return side / math.cos(angle)", "def calculate_angle_given_ratio(ratio, function):\n    \"\"\"\n    Calculate an angle given the sine or cosine ratio.\n    Parameters:\n    ratio (float): The sine or cosine ratio.\n    function (str): The function to use (\"sine\" or \"cosine\").\n    Returns:\n    float: The angle in radians.\n    \"\"\"\n    import math\n    if function == \"sine\":\n        return math.asin(ratio)\n    if function == \"cosine\":\n        return math.acos(ratio)"], "Sine Function": ["def sine_of_angle(angle, unit='radians'):\n    \"\"\"\n    Compute the sine of a given angle with the option to specify the angle's unit.\n    Parameters:\n    - angle (float): The angle for which the sine value is calculated.\n    - unit (str): The unit of the angle ('radians' or 'degrees'). Default is 'radians'.\n    Returns:\n    - float: Sine of the given angle.\n    Examples:\n    >>> sine_of_angle(np.pi / 2)\n    1.0\n    >>> sine_of_angle(90, unit='degrees')\n    1.0\n    \"\"\"\n    if unit == 'degrees':\n        angle = np.deg2rad(angle)\n    return np.sin(angle)", "def radians_to_degrees(radians):\n    \"\"\"\n    Convert angle in radians to degrees.\n    Parameters:\n        radians (float): Angle in radians.\n    Returns:\n        float: Angle in degrees.\n    \"\"\"\n    return radians * 180 / math.pi", "def sine_difference_formula(angle1, angle2, degrees=False):\n    \"\"\"\n    Calculate the sine of the difference between two angles using the identity:\n    sin(a - b) = sin(a) * cos(b) - cos(a) * sin(b)\n    Parameters:\n    - angle1: float\n        The first angle a.\n    - angle2: float\n        The second angle b.\n    - degrees: bool, optional\n        Whether the angles are in degrees or radians. Default is radians.\n    Returns:\n    - float\n        The result of sin(angle1 - angle2).\n    Examples:\n    >>> sine_difference_formula(np.pi/4, np.pi/6)\n    0.258819...\n    >>> sine_difference_formula(45, 30, degrees=True)\n    0.258819...\n    \"\"\"\n    if degrees:\n        angle1, angle2 = np.radians(angle1), np.radians(angle2)\n    return np.sin(angle1) * np.cos(angle2) - np.cos(angle1) * np.sin(angle2)", "def triangle_area_using_sine(a, b, angle_degrees):\n    \"\"\"\n    Calculates the area of a triangle given two sides and the included angle using the sine formula.\n    Parameters:\n        a (float): Length of the first side of the triangle.\n        b (float): Length of the second side of the triangle.\n        angle_degrees (float): Included angle in degrees between sides a and b.\n    Returns:\n        float: The area of the triangle.\n    Examples:\n        >>> triangle_area_using_sine(5, 6, 30)\n        7.5\n        >>> triangle_area_using_sine(7, 8, 45)\n        19.79898987322333\n    \"\"\"\n    angle_radians = math.radians(angle_degrees)\n    area = 0.5 * a * b * math.sin(angle_radians)\n    return area", "def compute_sine(angle_degrees, amplitude=1):\n    \"\"\"\n    Calculate the sine of an angle given in degrees adjusting by specified amplitude.\n    \n    Parameters:\n        angle_degrees (float): The angle in degrees for which to compute the sine.\n        amplitude (float): The amplitude factor to multiply with the sine.\n    Returns:\n        float: The sine of the angle adjusted by the given amplitude.\n    Example:\n        >>> compute_sine(90)\n        1.0\n        >>> compute_sine(90, amplitude=-1)\n        -1.0\n        >>> compute_sine(45, amplitude=2)\n        1.414213562373095\n    \"\"\"\n    # Convert degrees to radians for calculation\n    angle_radians = np.deg2rad(angle_degrees)\n    # Compute the sine and adjust by the amplitude\n    return amplitude * np.sin(angle_radians)", "def calculate_phase_shift(b, c):\n    \"\"\"\n    Calculate the phase shift of the sine function of the form y = a * sin(b * x + c).\n    Parameters:\n    - b (float): Frequency coefficient.\n    - c (float): The constant inside the sine function contributing to the phase shift.\n    Returns:\n    - phase_shift (float): Calculated phase shift. It's positive if the shift is to the left,\n      and negative if the shift is to the right.\n    \n    Examples:\n    - calculate_phase_shift(2, np.pi/4) # Returns inverse of the shift for sin(2x + pi/4)\n    - calculate_phase_shift(1, -np.pi/2) # Returns inverse of the shift for sin(x - pi/2)\n    \"\"\"\n    phase_shift = -c / b\n    return phase_shift", "def arcsine_value(value, radians=True):\n    \"\"\"\n    Compute the arcsine (inverse sine) of a value.\n    Parameters:\n    - value: float\n        The value for which the arcsine is to be calculated. Must be in the range [-1, 1].\n    - radians: bool, optional\n        Whether to return the result in radians (default) or degrees.\n    Returns:\n    - float\n        The arcsine of the given value in radians or degrees.\n    Examples:\n    >>> arcsine_value(1)\n    1.570796...\n    >>> arcsine_value(1, radians=False)\n    90.0\n    \"\"\"\n    if not -1 <= value <= 1:\n        raise ValueError(\"Input should be between -1 and 1\")\n    result = np.arcsin(value)\n    if not radians:\n        return np.degrees(result)\n    return result", "def sine_value_to_angles(sine_value):\n    \"\"\"\n    Given a sine value, return the corresponding angles in the unit circle that match the value.\n    Parameters\n    ----------\n    sine_value : float\n        The value of sine for which corresponding angles are desired.\n    Returns\n    -------\n    list\n        A list of angles (in degrees) on the unit circle with the given sine value.\n    Examples\n    --------\n    >>> sine_value_to_angles(0.5)\n    [30.0, 150.0]\n    >>> sine_value_to_angles(1)\n    [90]\n    \"\"\"\n    if sine_value < -1 or sine_value > 1:\n        raise ValueError(\"Sine value must be between -1 and 1.\")\n    base_angle_rad = np.arcsin(sine_value)\n    base_angle = np.degrees(base_angle_rad)\n    angles = [base_angle, 180 - base_angle]\n    return [angle for angle in angles if angle >= 0]", "def arcsine_of_value(value):\n    \"\"\"\n    Calculate the arcsine of a given value, ensuring the result is within the principal range [-π/2, π/2].\n    Parameters:\n    - value: float\n      The value for which to compute the arcsine, where -1 <= value <= 1.\n    Returns:\n    - float\n      The arcsine of the value, in radians.\n    Raises:\n    - ValueError: If the input value is outside the valid range.\n    Examples:\n    >>> arcsine_of_value(1)\n    1.5707963267948966\n    >>> arcsine_of_value(0)\n    0.0\n    \"\"\"\n    if not -1 <= value <= 1:\n        raise ValueError(\"Input value must be within the range -1 to 1.\")\n    return math.asin(value)", "def sine_function_properties(a, b, c, visualize=False):\n    \"\"\"\n    Calculate properties of the sine function y = a * sin(bx + c) and optionally visualize the graph.\n    Parameters:\n    - a (float): Amplitude of the sine function.\n    - b (float): Frequency multiplier, which affects the period of the sine wave.\n    - c (float): Phase shift of the sine wave.\n    - visualize (bool): If True, the function will plot the graph.\n    Returns:\n    - dict: A dictionary containing 'amplitude', 'frequency', 'phase_shift', 'period' and 'c_max_at_x0'.\n    \"\"\"\n    amplitude = np.abs(a)\n    period = 2 * np.pi / b\n    phase_shift = -c / b\n    c_max_at_x0 = np.arcsin(0) - b * 0\n    properties = {\n        'amplitude': amplitude,\n        'frequency': b,\n        'phase_shift': phase_shift,\n        'period': period,\n        'c_max_at_x0': c_max_at_x0,\n    }\n    if visualize:\n        x = np.linspace(-2 * period, 2 * period, 1000)\n        y = a * np.sin(b * x + c)\n        plt.plot(x, y)\n        plt.axhline(0, color='black', linewidth=0.5)\n        plt.axvline(0, color='black', linewidth=0.5)\n        plt.title('Graph of y = a*sin(bx + c)')\n        plt.show()\n    return properties", "def unit_circle_coordinates(angle, unit='degrees'):\n    \"\"\"\n    Compute the coordinates of a point on a unit circle given an angle.\n    Parameters\n    ----------\n    angle : float\n        The angle in the unit circle to find the coordinates for.\n    unit : str, optional\n        The unit of the angle ('degrees' or 'radians'). Default is 'degrees'.\n    Returns\n    -------\n    tuple\n        A tuple (x, y) representing coordinates of the point on the unit circle.\n    Examples\n    --------\n    >>> unit_circle_coordinates(90)\n    (0, 1)\n    >>> unit_circle_coordinates(np.pi/6, unit='radians')\n    (0.8660254037844386, 0.5)\n    \"\"\"\n    if unit == 'degrees':\n        angle = np.radians(angle)\n    x = np.cos(angle)\n    y = np.sin(angle)\n    return (x, y)", "def solve_sine_equation(func, guess):\n    \"\"\"\n    Solve an equation involving the sine function where the function crosses zero. \n    Note: User defines the function where sine is part of the equation in `func`.\n    Parameters:\n    func : callable\n        The function to be solved, which must be defined by the user. It should take an angle in radians as input.\n    guess : float or list\n        Initial guess for the roots of the equation. Multiple guesses can be provided in a list for multiple solutions.\n    Returns:\n    float or np.array\n        The angle(s) in radians that are roots of the equation.\n    Examples:\n    >>> solve_sine_equation(lambda x: np.sin(x) - 0.5, [0, 2])\n    array([0.52359878, 2.61799388])\n    \"\"\"\n    return fsolve(func, guess)", "def normalize_angle(angle_degrees):\n    \"\"\"\n    Normalize an angle to ensure it is within the range 0 to 360 degrees.\n    Parameters:\n    - angle_degrees (float): The angle in degrees to normalize.\n    Returns:\n    - float: The normalized angle within 0 to 360 degrees.\n    Examples:\n    >>> normalize_angle(370)\n    10\n    >>> normalize_angle(-30)\n    330\n    >>> normalize_angle(720)\n    0\n    \"\"\"\n    return angle_degrees % 360", "def sine_value_properties(angle, in_degrees=True):\n    \"\"\"\n    Returns properties of the sine function including periodic repeats and other identities.\n    Parameters:\n    - angle: float\n        The angle in question for which properties need to be evaluated.\n    - in_degrees: bool, optional\n        Specifies if the angle is given in degrees (default) or radians.\n    Returns:\n    - dict\n        Keys include 'periodic_value', 'supplementary_value', 'angle_addition_identity'.\n    \n    Examples:\n    >>> sine_value_properties(30)\n    {'periodic_value': 0.5, 'supplementary_value': 0.5, 'angle_addition_identity': not calculated}\n    >>> sine_value_properties(180)\n    {'periodic_value': 0.0, 'supplementary_value': 0.0, 'angle_addition_identity': not calculated}\n    \"\"\"\n    sine_val = compute_sine_value(angle, in_degrees)\n    angle_supplementary = 180 - angle if in_degrees else np.pi - angle\n    sine_supplementary = compute_sine_value(angle_supplementary, in_degrees)\n    \n    properties = {\n        'periodic_value': sine_val,\n        'supplementary_value': sine_supplementary,\n        'angle_addition_identity': 'not calculated'  # Placeholder for actual computation if necessary\n    }\n    \n    return properties", "def determine_phase_shift_for_maximum_at_x0(amplitude=1, frequency=1):\n    \"\"\"\n    Determines the phase shift needed for a sine function with given amplitude and frequency \n    to have a maximum value at x=0.\n    Parameters:\n        amplitude (float): The amplitude of the sine wave.\n        frequency (float): The frequency of the sine wave.\n    Returns:\n        float: The phase shift required for the function to have a maximum at x=0.\n    \"\"\"\n    # To have a maximum at x=0, sin(frequency*x + phase_shift) should be 1 when x=0\n    # This requires frequency*0 + phase_shift = pi/2 (since sin(pi/2) = 1)\n    phase_shift = np.pi / 2\n    return phase_shift"], "Tangent Function": ["def calculate_tangent(opposite_side, adjacent_side):\n    \"\"\"\n    Calculate the tangent of an angle in a right triangle given the lengths \n    of the opposite side and the adjacent side.\n    Parameters:\n    opposite_side (float): The length of the side opposite to the angle.\n    adjacent_side (float): The length of the side adjacent to the angle.\n    Returns:\n    float: The tangent of the angle.\n    Examples:\n    >>> calculate_tangent(3, 4)\n    0.75\n    \"\"\"\n    return opposite_side / adjacent_side", "def radian_to_degree(radians):\n    \"\"\"\n    Convert an angle from radians to degrees.\n    Parameters:\n    radians (float): Angle in radians.\n    Returns:\n    float: Angle in degrees.\n    \n    Example:\n    >>> radian_to_degree(np.pi/2)\n    90.0\n    \"\"\"\n    return radians * 180 / np.pi", "def tangent_half_angle(tan_x):\n    \"\"\"\n    Compute tan(x/2) from tan(x) using the half-angle formula derived from double angle identity.\n    Parameters:\n    Returns:\n    float: Tangent of half of the angle x.\n    \n    Example:\n    >>> tangent_half_angle(1)  # tan(90 degrees) -> tan(45 degrees)\n    1.0\n    \"\"\"\n    return np.sqrt((1 - np.sqrt(1 + tan_x**2)) / (1 + np.sqrt(1 + tan_x**2)))", "def calculate_tangent(angle, in_degrees=True):\n    \"\"\"\n    Calculate the tangent of an angle.\n    Parameters:\n        angle (float): The angle for which to calculate the tangent.\n        in_degrees (bool): If True, the angle is in degrees, otherwise radians.\n    \n    Returns:\n        float: The tangent of the given angle.\n    Examples:\n        >>> calculate_tangent(45)\n        1.0\n        >>> calculate_tangent(np.pi/4, in_degrees=False)\n        1.0\n    \"\"\"\n    angle_radians = np.deg2rad(angle) if in_degrees else angle\n    return np.tan(angle_radians)", "def calculate_trig_function(func, angle_degrees):\n    \"\"\"\n    Calculate trigonometric functions for a given angle in degrees.\n    Parameters:\n    - func (str): The trigonometric function to compute ('sin', 'cos', 'tan').\n    - angle_degrees (float): The angle in degrees for which to compute the trigonometric function.\n    Returns:\n    - float: The result of the trigonometric function.\n    Examples:\n    - calculate_trig_function('sin', 30) returns 0.5\n    - calculate_trig_function('cos', 90) returns approximately 0.0\n    - calculate_trig_function('tan', 45) returns approximately 1.0\n    \"\"\"\n    angle_radians = math.radians(angle_degrees)\n    if func == 'sin':\n        return math.sin(angle_radians)\n    elif func == 'cos':\n        return math.cos(angle_radians)\n    elif func == 'tan':\n        return math.tan(angle_radians)\n    else:\n        raise ValueError(\"Invalid trigonometric function specified. Use 'sin', 'cos', or 'tan'.\")", "def side_lengths_from_tangent(tangent_value, known_side_length, side_type='adjacent'):\n    \"\"\"\n    Calculates the unknown side of a right triangle given the tangent and one side length.\n    Parameters:\n    - tangent_value : float\n        The tangent of the angle opposite to the side to be calculated.\n    - known_side_length : float\n        The length of the known side (either opposite or adjacent).\n    - side_type : str\n        The type of the known side ('adjacent' or 'opposite').\n    Returns:\n    - float\n        The length of the unknown side.\n    \"\"\"\n    if side_type == 'adjacent':\n        # Opposite = Adjacent * Tan(θ)\n        return known_side_length * tangent_value\n    elif side_type == 'opposite':\n        # Adjacent = Opposite / Tan(θ)\n        return known_side_length / tangent_value\n    else:\n        raise ValueError(\"side_type must be 'adjacent' or 'opposite'\")", "def tan_operations(angle1, angle2=None, operation='single', unit='degrees'):\n    \"\"\"\n    Perform various operations on tangent values including single calculation,\n    addition, subtraction, double or half angle formulas.\n    Parameters:\n    - angle1 (float): the primary angle in degrees or radians\n    - angle2 (float, optional): the secondary angle in degrees or radians for addition or subtraction\n    - operation (str): 'single', 'add', 'subtract', 'double', 'half'\n    - unit (str): 'degrees' or 'radians' - the unit of the angles provided\n    Returns:\n    - float: result of the tangent operations\n    Examples:\n    - tan_operations(45, operation='double', unit='degrees') should return 1.0 (tan(90 degrees)).\n    - tan_operations(30, 60, operation='add', unit='degrees') gives tan(90) which is infinity in mathematical terms.\n    \"\"\"\n    if unit == 'degrees':\n        angle1 = np.deg2rad(angle1)\n        if angle2 is not None:\n            angle2 = np.deg2rad(angle2)\n    if operation == 'single':\n        return np.tan(angle1)\n    elif operation == 'add':\n        return (np.tan(angle1) + np.tan(angle2)) / (1 - np.tan(angle1) * np.tan(angle2))\n    elif operation == 'subtract':\n        return (np.tan(angle1) - np.tan(angle2)) / (1 + np.tan(angle1) * np.tan(angle2))\n    elif operation == 'double':\n        return 2 * np.tan(angle1) / (1 - np.tan(angle1)**2)\n    elif operation == 'half':\n        return np.tan(angle1 / 2) / (1 + np.tan(angle1 / 2)**2)\n    else:\n        raise ValueError(\"Unsupported operation type provided.\")", "def simplify_using_identity(expression_string):\n    \"\"\"\n    This function simplifies a trigonometric expression using known identities.\n    Parameters\n    ----------\n    expression_string : str\n        The trigonometric expression to simplify, represented as a string.\n    Returns\n    -------\n    str\n        The simplified trigonometric expression.\n    Example\n    -------\n    >>> simplify_using_identity(\"sin(x)**2 + cos(x)**2\")\n    '1'\n    \"\"\"\n    \n    expression = sp.sympify(expression_string)\n    simplified_expression = sp.simplify(expression)\n    \n    return str(simplified_expression)", "def pythagorean_theorem(side_a=None, side_b=None, hypotenuse=None):\n    \"\"\"\n    Use the Pythagorean theorem to find a missing side length in a right triangle.\n    Parameters:\n    side_a (float): One side of the right triangle (or None if unknown).\n    side_b (float): Another side of the right triangle (or None if unknown).\n    hypotenuse (float): The hypotenuse of the right triangle (or None if unknown).\n    \n    It is expected that exactly one of the parameters is None, indicating the unknown side.\n    Returns:\n    float: The length of the unknown side.\n    Examples:\n    >>> pythagorean_theorem(side_a=3, hypotenuse=5)\n    4.0\n    >>> pythagorean_theorem(side_b=4, hypotenuse=5)\n    3.0\n    >>> pythagorean_theorem(side_a=3, side_b=4)\n    5.0\n    \"\"\"\n    if hypotenuse is None:\n        return math.sqrt(side_a**2 + side_b**2)\n    elif side_a is None:\n        return math.sqrt(hypotenuse**2 - side_b**2)\n    elif side_b is None:\n        return math.sqrt(hypotenuse**2 - side_a**2)"], "Cosine Function": ["def calculate_cosine(adjacent, hypotenuse):\n    \"\"\"\n    Calculate the cosine of an angle in a right triangle based on the lengths\n    of the adjacent side and the hypotenuse.\n    Parameters:\n    adjacent (float): The length of the side adjacent to the angle.\n    hypotenuse (float): The length of the hypotenuse.\n    Returns:\n    float: The cosine of the angle.\n    Examples:\n    >>> calculate_cosine(3, 5)\n    0.6\n    \"\"\"\n    if hypotenuse <= 0:\n        raise ValueError(\"Hypotenuse should be greater than zero.\")\n    return adjacent / hypotenuse", "def cosine_identity(angle_degrees, identity_type='double'):\n    \"\"\"\n    Calculate the cosine of an angle based on the specified trigonometric identity.\n    Parameters:\n        angle_degrees (float): The angle in degrees for which to calculate the cosine.\n        identity_type (str): Type of identity to use ('double', 'half', or 'sum_difference').\n                              'double' calculates cos(2x), 'half' calculates cos(x/2),\n                              and 'sum_difference' calculates cos(x + y) or cos(x - y),\n                              where additional parameters x and y are required.\n    \n    Returns:\n        float: The cosine of the angle based on the selected identity.\n        \n    Examples:\n        >>> cosine_identity(30, 'double')\n        0.5000000000000001\n        \n        >>> cosine_identity(45, 'half')\n        0.9238795325112867\n    \"\"\"\n    x_rad = np.radians(angle_degrees)\n    if identity_type == 'double':\n        return np.cos(2 * x_rad)\n    elif identity_type == 'half':\n        return np.cos(x_rad / 2)\n    else:\n        raise ValueError(\"Unsupported identity type specified. Use 'double' or 'half'.\")", "def cosine_rule(a, b, c=None, angle_C=None):\n    \"\"\"\n    Apply the cosine rule to find either a side length or an angle in a triangle.\n    \n    Parameters:\n    - a (float): length of side a.\n    - b (float): length of side b.\n    - c (float, optional): length of side c.\n    - angle_C (float, optional): angle C in degrees opposite side c.\n    \n    Returns:\n    - float: Depending on what input is given, returns the length of side c or the angle C.\n    \n    Examples:\n    >>> cosine_rule(5, 6, angle_C=60)\n    2.5\n    >>> cosine_rule(5, 6, c=7)\n    44.415308597193004\n    \"\"\"\n    if c and angle_C is None:\n        # Calculate the angle C using the cosine rule\n        angle_C_rad = math.acos((a**2 + b**2 - c**2) / (2 * a * b))\n        angle_C_deg = math.degrees(angle_C_rad)\n        return angle_C_deg\n    elif angle_C:\n        # Calculate side c using the cosine rule\n        angle_C_rad = math.radians(angle_C)\n        return math.sqrt(a**2 + b**2 - 2 * a * b * math.cos(angle_C_rad))\n    else:\n        raise ValueError(\"Either side c or angle C must be provided\")", "def angle_from_cosine(cos_value):\n    \"\"\"\n    Calculate the angles from the given cosine value using arccosine.\n    Parameters\n    ----------\n    cos_value : float\n        The cosine value for which to determine the angles in the standard intervals.\n    Returns\n    -------\n    list of float\n        List of angles in radians corresponding to the given cosine value in the interval [0, 2*pi].\n    Examples\n    --------\n    >>> angle_from_cosine(1)\n    [0.0, 6.283185307179586]\n    >>> angle_from_cosine(0.5)\n    [1.0471975511965979, 5.2359877559829895]\n    \"\"\"\n    from numpy import arccos, pi\n    theta = arccos(cos_value)\n    return [theta, 2 * pi - theta] if cos_value != -1 else [pi]", "def cosine_addition(angle1, angle2):\n    \"\"\"\n    Compute the cosine of the sum of two angles.\n    Parameters\n    ----------\n    angle1 : float\n        The first angle in radians.\n    angle2 : float\n        The second angle in radians.\n    Returns\n    -------\n    float\n        The cosine of the sum of the two angles.\n    Examples\n    --------\n    >>> cosine_addition(np.pi/3, np.pi/4)\n    0.3535533905932738\n    \"\"\"\n    from math import cos, sin\n    return cos(angle1) * cos(angle2) - sin(angle1) * sin(angle2)", "def cosine_inverse(cos_value):\n    \"\"\"\n    Calculate the angle in degrees from a cosine value using the arccos function.\n    \n    Parameters:\n        cos_value (float): The cosine value for which to find the angle.\n    \n    Returns:\n        float: The angle in degrees that has the given cosine value.\n    \n    Examples:\n        >>> cosine_inverse(0.5)\n        60.0\n        >>> cosine_inverse(1)\n        0.0\n    \"\"\"\n    return np.degrees(np.arccos(cos_value))", "def compute_cosine(angle, in_degrees=True):\n    \"\"\"\n    Compute the cosine of the given angle which can be in degrees or radians.\n    Parameters:\n    angle : float\n        The angle for which the cosine is to be computed.\n    in_degrees : bool, optional\n        If True (default), the angle is assumed to be in degrees. If False, the angle is assumed to be in radians.\n    Returns:\n    float\n        The cosine of the given angle.\n    Examples:\n    >>> compute_cosine(60)\n    0.5\n    >>> compute_cosine(np.pi/3, in_degrees=False)\n    0.5\n    \"\"\"\n    if in_degrees:\n        angle = np.deg2rad(angle)\n    return np.cos(angle)", "def calculate_cosine(angle_degrees):\n    \"\"\"\n    Calculate the cosine of an angle given in degrees.\n    \n    Parameters:\n        angle_degrees (float): The angle in degrees for which to compute the cosine.\n    \n    Returns:\n        float: The cosine of the given angle.\n        \n    Examples:\n        >>> calculate_cosine(60)\n        0.5\n        >>> calculate_cosine(90)\n        0.0\n    \"\"\"\n    angle_radians = np.radians(angle_degrees)\n    return np.cos(angle_radians)", "def simplify_angle(angle, in_degrees=True):\n    \"\"\"\n    Simplify an angle using the periodicity of the cosine function.\n    Parameters:\n    angle : float\n        The original angle, potentially outside the usual range.\n    in_degrees : bool, optional\n        If True (default), angles are handled in degrees. If False, angles are handled in radians.\n    Returns:\n    float\n        The angle simplified to within the fundamental period [0, 360) degrees or [0, 2π) radians.\n    Examples:\n    >>> simplify_angle(720)   # Simplifies to 0 degrees.\n    0\n    >>> simplify_angle(7*np.pi, in_degrees=False)   # Simplifies to π.\n    3.141592653589793\n    \"\"\"\n    if in_degrees:\n        return angle % 360\n    return angle % (2 * np.pi)", "def compute_cosine(angle):\n    \"\"\"\n    Compute the cosine of a given angle in radians.\n    Parameters\n    ----------\n    angle : float\n        The angle in radians for which the cosine is to be calculated.\n    Returns\n    -------\n    float\n        The cosine of the given angle.\n    Examples\n    --------\n    >>> compute_cosine(np.pi)\n    -1.0\n    >>> compute_cosine(0)\n    1.0\n    \"\"\"\n    from math import cos\n    return cos(angle)", "def solve_cosine_equation(a, b, c):\n    \"\"\"\n    Solve a cosine equation of the form a*cos(x) + b*sin(x) = c using trigonometric identities.\n    \n    Parameters:\n        a (float): Coefficient of cosine.\n        b (float): Coefficient of sine.\n        c (float): Right-hand side constant.\n    Returns:\n        list of floats: Possible values of x (in radians) that satisfy the equation.\n        \n    Examples:\n        >>> solve_cosine_equation(1, -1, 0)  # cos(x) - sin(x) = 0\n        [0.7853981633974483, 3.9269908169872414]\n    \"\"\"\n    # This is an example solving method demonstrating the application;\n    # it assumes solutions can be directly calculated for basic cases.\n    r = math.sqrt(a**2 + b**2)\n    phi = math.atan2(b, a)\n    possible_solutions = [math.acos(c / r) + phi, -math.acos(c / r) + phi]\n    return possible_solutions", "def cosine_of_sum(angle1, angle2, in_degrees=True):\n    \"\"\"\n    Calculate the cosine of the sum of two angles using the cosine addition formula.\n    Parameters:\n    angle1 : float\n        The first angle.\n    angle2 : float\n        The second angle.\n    in_degrees : bool, optional\n        If True (default), angles are given in degrees. If False, angles are given in radians.\n    Returns:\n    float\n        The cosine of the sum of the two angles.\n    Examples:\n    >>> cosine_of_sum(30, 45)\n    0.7071067811865477\n    >>> cosine_of_sum(np.pi/6, np.pi/4, in_degreddes=False)\n    0.7071067811865477\n    \"\"\"\n    if in_degrees:\n        angle1 = np.deg2rad(angle1)\n        angle2 = np.deg2rad(angle2)\n    return np.cos(angle1 + angle2)", "def cosine_to_tangent_half_angle(cos_value):\n    \"\"\"\n    Convert a cosine value to its corresponding tangent of half the angle.\n    Parameters:\n        cos_value (float): The cosine value.\n    Returns:\n        float: The tangent of half the corresponding angle.\n    \n    Examples:\n        >>> cosine_to_tangent_half_angle(0.5)\n        1.7320508075688767\n    \"\"\"\n    # tangent half-angle formula: tan(x/2) = sqrt((1 - cos(x)) / (1 + cos(x)))\n    return np.sqrt((1 - cos_value) / (1 + cos_value))", "def arccosine_value(cos_value):\n    \"\"\"\n    Compute the principal value of the arccosine of a given cosine value.\n    Parameters\n    ----------\n    cos_value : float\n        The cosine value for which to calculate the arccosine.\n    Returns\n    -------\n    float\n        The principal value of the arccosine of the given cosine value.\n    Examples\n    --------\n    >>> arccosine_value(1)\n    0.0\n    >>> arccosine_value(0)\n    1.5707963267948966\n    \"\"\"\n    from numpy import arccos\n    return arccos(cos_value)", "def normalize_angle(angle_degrees):\n    \"\"\"\n    Normalize an angle to [0, 360] degrees using cosine's periodicity properties.\n    \n    Parameters:\n        angle_degrees (float): The original angle in degrees that may exceed a single rotation.\n    \n    Returns:\n        float: Normalized angle within a 0 to 360 degree range.\n    \n    Examples:\n        >>> normalize_angle(450)\n        90.0\n        >>> normalize_angle(-30)\n        330.0\n    \"\"\"\n    return angle_degrees % 360", "def normalize_angle(angle):\n    \"\"\"\n    Normalize a given angle to the interval [0, 2*pi].\n    Parameters\n    ----------\n    angle : float\n        The angle in radians to be normalized.\n    Returns\n    -------\n    float\n        The normalized angle within the range [0, 2*np.pi].\n    Examples\n    --------\n    >>> normalize_angle(7 * np.pi)\n    3.141592653589793\n    \"\"\"\n    from numpy import pi\n    return angle % (2 * pi)"], "Trigonometric Functions": ["def trig_calculator(func_name, angle, degrees=False):\n    \"\"\"\n    Calculate the trigonometric function value for a given angle.\n    Parameters:\n    - func_name (str): Name of the trigonometric function ('sin', 'cos', 'tan', 'csc', 'sec', 'cot').\n    - angle (float): The angle at which to compute the function.\n    - degrees (bool, optional): Set to True if the angle is in degrees, False if in radians.\n    Returns:\n    - float or sympy expression: Value of the trigonometric function at the specified angle.\n    Examples:\n    >>> trig_calculator('cos', 90, True)\n    6.123233995736766e-17\n    >>> trig_calculator('tan', sp.pi/4)\n    1.0\n    \"\"\"\n    if degrees:\n        angle = np.deg2rad(angle)\n    trig_functions = {\n        'sin': np.sin,\n        'cos': np.cos,\n        'tan': np.tan,\n        'csc': lambda x: 1 / np.sin(x),\n        'sec': lambda x: 1 / np.cos(x),\n        'cot': lambda x: 1 / np.tan(x)\n    }\n    if func_name not in trig_functions:\n        raise ValueError(\"Invalid trigonometric function specified.\")\n    return trig_functions[func_name](angle)", "def simplify_trig_identity(expr, x, identity):\n    \"\"\"\n    Simplify or transform a trigonometric expression based on a given identity.\n    \n    Parameters:\n    expr (str): Trigonometric expression involving basic trig functions.\n    x (float): The angle variable used in the expression.\n    identity (str): A specific identity to apply ('Pythagorean', 'co-function', etc.)\n    \n    Returns:\n    sympy.Expr : Simplified or transformed trigonometric expression using SymPy.\n    \n    Examples:\n    >>> simplify_trig_identity('sin(x)**2 + cos(x)**2', 'x', 'Pythagorean')\n    1\n    >>> simplify_trig_identity('sin(90 - x)', 'x', 'co-function')\n    cos(x)\n    \"\"\"\n    from sympy import symbols, sin, cos, simplify\n    \n    angle = symbols(x)\n    if identity == 'Pythagorean':\n        # Replace sin^2(angle) + cos^2(angle) with 1\n        expr = expr.replace('sin(' + x + ')**2 + cos(' + x + ')**2', '1')\n    elif identity == 'co-function':\n        # Replace sin(90 - angle) with cos(angle) and vice versa\n        expr = expr.replace('sin(90 - ' + x + ')', 'cos(' + x + ')')\n        expr = expr.replace('cos(90 - ' + x + ')', 'sin(' + x + ')')\n    # Use sympy to simplify the expression\n    return simplify(expr)", "def trig_identity_sinusoidal_properties(angle_radians, identity=\"pythagorean\"):\n    \"\"\"\n    Calculate trigonometric properties based on given identities.\n    \n    Parameters:\n    - angle_radians: float\n        The angle in radians.\n    - identity: str, default \"pythagorean\"\n        The identity to use for calculations. Currently supports 'pythagorean'.\n        \n    Returns:\n    - float\n        The value calculated using the specified identity.\n    Examples:\n    >>> trig_identity_sinusoidal_properties(np.pi/4, 'pythagorean')\n    1.0\n    \"\"\"\n    if identity == \"pythagorean\":\n        return sin(angle_radians)**2 + cos(angle_radians)**2", "def co_function_transformations(angle_radians, original='sin'):\n    \"\"\"\n    Calculate the co-function value of an angle transformation.\n    \n    Parameters:\n    - angle_radians: float\n        The angle in radians for which the co-function value needs to be evaluated.\n    - original: str, default 'sin'\n        The original trigonometric function to transform. Options: 'sin' or 'cos'.\n        \n    Returns:\n    - float\n        The result of the co-function transformation.\n    Examples:\n    >>> co_function_transformations(np.pi/4, 'sin')\n    0.7071067811865476\n    >>> co_function_transformations(np.pi/4, 'cos')\n    0.7071067811865476\n    \"\"\"\n    if original == 'sin':\n        return np.cos(angle_radians)\n    elif original == 'cos':\n        return np.sin(angle_radians)\n    else:\n        raise ValueError(\"Invalid function for co-function transformations. Use 'sin' or 'cos'.\")"], "Polar Coordinates": ["def polar_to_cartesian(r, theta):\n    \"\"\"\n    Converts polar coordinates to Cartesian coordinates.\n    Parameters:\n    - r (float): The radius or magnitude of the point.\n    - theta (float): The angle in radians.\n    Returns:\n    - tuple: Cartesian coordinates (x, y).\n    Examples:\n    >>> polar_to_cartesian(5, np.pi/4)\n    (3.5355339059327378, 3.5355339059327373)\n    \"\"\"\n    x = r * np.cos(theta)\n    y = r * np.sin(theta)\n    return (x, y)", "def normalize_angle(theta):\n    \"\"\"\n    Normalizes an angle into the range [0, 2π).\n    Parameters:\n    - theta (float): The angle in radians.\n    Returns:\n    - float: Normalized angle in radians.\n    Examples:\n    >>> normalize_angle(9*np.pi/4)\n    2.356194490192345\n    \"\"\"\n    return theta % (2 * np.pi)", "def compute_cis(theta):\n    \"\"\"\n    Compute the cis of an angle, which is cos(theta) + i*sin(theta).\n    \n    Parameters:\n    - theta (float): The angle in radians.\n    \n    Returns:\n    - complex: The resulting complex number in Cartesian form.\n    \"\"\"\n    return cmath.cos(theta) + cmath.sin(theta) * 1j", "def complex_polar_sum(r1, theta1, r2, theta2):\n    \"\"\"\n    Sum two complex numbers given in polar form and return the result in polar form.\n    \n    Parameters:\n    - r1 (float): Magnitude of the first complex number.\n    - theta1 (float): Angle (in radians) of the first complex number.\n    - r2 (float): Magnitude of the second complex number.\n    - theta2 (float): Angle (in radians) of the second complex number.\n    \n    Returns:\n    - r (float): Resultant magnitude.\n    - theta (float): Resultant angle (in radians, within the range [0, 2*pi)).\n    \"\"\"\n    complex1 = cmath.rect(r1, theta1)\n    complex2 = cmath.rect(r2, theta2)\n    result = complex1 + complex2\n    polar_result = cmath.polar(result)\n    magnitude = polar_result[0]\n    angle = polar_result[1]\n    if angle < 0:\n        angle += 2 * math.pi\n    return magnitude, angle", "def complex_polar(r, theta):\n    \"\"\"\n    Returns the complex number representation in polar form: r * e^(i*theta)\n    Parameters:\n    - r (float): The magnitude of the complex number.\n    - theta (float): The angle in radians.\n    Returns:\n    - complex: The complex number calculated as r*e^(i*theta).\n    Examples:\n    >>> complex_polar(2, np.pi/2)\n    1.4695761589768238e-16 + 2j\n    \"\"\"\n    return r * np.exp(1j * theta)"]}