{"Factorials": ["def calculate_factorial(n):\n    \"\"\"\n    Calculate the factorial of a non-negative integer n.\n    Parameters:\n    n (int): A non-negative integer whose factorial is to be computed.\n    Returns:\n    int: The factorial of the input number n.\n    Examples:\n    >>> calculate_factorial(5)\n    120\n    >>> calculate_factorial(0)\n    1\n    \"\"\"\n    if n < 0:\n        raise ValueError(\"Factorial is not defined for negative numbers\")\n    return math.factorial(n)", "def calculate_permutations(n, r=None, fixed_positions=0, repeats=None):\n    \"\"\"\n    Calculate permutations of n items taken r at a time, optionally considering:\n    - fixed positions,\n    - repeated items.\n    Parameters:\n    n (int): Total number of distinct items.\n    r (int, optional): Number of items to be taken for permutation. If None, assumes r = n.\n    fixed_positions (int): Number of positions that are fixed. Default is 0.\n    repeats (dict, optional): A dictionary where keys are items and values are the repetition counts of the items.\n    Returns:\n    int: The number of possible permutations.\n    Examples:\n    >>> calculate_permutations(5, 3) # P(5,3)\n    60\n    >>> calculate_permutations(4, fixed_positions=1) # P(4,3)\n    24\n    >>> calculate_permutations(6, repeats={1: 2, 2: 1, 3: 3}) # Items 1 repeated 2 times, 2 repeated once, 3 repeated 3 times.\n    60\n    \"\"\"\n    if r is None:\n        r = n\n    if r > n:\n        return 0\n    if fixed_positions > r:\n        raise ValueError(\"Fixed positions cannot exceed number of positions taken for permutation.\")\n    \n    # Calculate the base permutation ignoring repetitions\n    permutation = math.factorial(n - fixed_positions) // math.factorial(n - r)\n    \n    # Adjust for any repetitions\n    if repeats:\n        for item_count in repeats.values():\n            permutation //= math.factorial(item_count)\n    \n    return permutation", "def permutation(n, k):\n    \"\"\"\n    Calculate the number of ways to arrange k items from n items (nPk).\n    \n    Parameters:\n    n (int): The total number of items.\n    k (int): The number of items to arrange.\n    \n    Returns:\n    int: The number of permutations.\n    \n    Raises:\n    ValueError: If n or k is negative, or if k is greater than n.\n    \n    Examples:\n    >>> permutation(5, 3)\n    60\n    >>> permutation(10, 0)\n    1\n    \"\"\"\n    if n < 0 or k < 0:\n        raise ValueError(\"n and k should be non-negative integers\")\n    if k > n:\n        raise ValueError(\"k cannot be greater than n\")\n    return math.perm(n, k)", "def binomial_coefficient(n, k):\n    \"\"\"\n    Calculate the binomial coefficient C(n, k) which is the number of ways to choose k items from n items without regard to order.\n    Parameters:\n        n (int): The total number of items.\n        k (int): The number of items to choose.\n    Returns:\n        int: The binomial coefficient C(n, k).\n    Examples:\n        >>> binomial_coefficient(5, 2)\n        10\n        >>> binomial_coefficient(10, 5)\n        252\n    Raises:\n        ValueError: If n is negative or k is negative or if k > n.\n    \"\"\"\n    if n < 0 or k < 0 or k > n:\n        raise ValueError(\"Invalid values for n and/or k. Ensure that 0 <= k <= n and n >= 0.\")\n    return int(comb(n, k, exact=True))", "def factorial_product_simplify(n, k):\n    \"\"\"\n    Simplify a product of factorials often found in combinatorial problems.\n    Specifically, this will compute the combination C(n, k) = n! / (k! * (n-k)!)\n    \n    Parameters\n    ----------\n    n : int\n        The total number of items.\n    k : int\n        The number of items to choose.\n    \n    Returns\n    -------\n    int\n        The simplified product of factorials as an integer.\n    \n    Examples\n    --------\n    >>> factorial_product_simplify(5, 2)\n    10\n    \n    >>> factorial_product_simplify(6, 3)\n    20\n    \"\"\"\n    if n < 0 or k < 0 or k > n:\n        raise ValueError(\"Invalid input: Ensure 0 <= k <= n and n >= 0\")\n    \n    return math.comb(n, k)", "def simplify_factorial_ratio(numerator, denominator):\n    \"\"\"\n    Simplify the ratio of two factorials, given the numerator and denominator factorial values.\n    \n    This function is commonly used in scenarios like combinations and permutations where factorial\n    division occurs. It reduces the computation by cancelling out common factorial terms.\n    Parameters:\n    numerator (int): The upper factorial term.\n    denominator (int): The lower factorial term, should be less than or equal to the numerator.\n    Returns:\n    int: The result of numerator! / denominator! after simplification.\n    \n    Examples:\n    >>> simplify_factorial_ratio(5, 3)\n    20\n    >>> simplify_factor0lial_ratio(6, 6)\n    1\n    \"\"\"\n    if numerator < 0 or denominator < 0:\n        raise ValueError(\"Factorial is not defined for negative numbers\")\n    if denominator > numerator:\n        raise ValueError(\"Denominator cannot be greater than numerator for factorial ratio simplification\")\n    \n    result = 1\n    for i in range(denominator + 1, numerator + 1):\n        result *= i\n    return result", "def factorial_product_simplification(*args):\n    \"\"\"\n    Simplifies the product of factorials for an arbitrary number of given non-negative integers.\n    Parameters\n    ----------\n    *args : int\n        An arbitrary number of non-negative integers.\n    Returns\n    -------\n    int\n        The product of the factorials of the given numbers.\n    Raises\n    ------\n    ValueError\n        If any input value in `args` is negative.\n    Examples\n    --------\n    >>> factorial_product_simplification(3, 4, 5)\n    86400\n    \n    >>> factorial_product_simplification(1, 2, 3)\n    12\n    \"\"\"\n    if any(x < 0 for x in args):\n        raise ValueError(\"All inputs should be non-negative integers\")\n    return reduce(lambda x, y: x * math.factorial(y), args, 1)", "def gcd_of_factorials(n, m):\n    \"\"\"\n    Compute the GCD of the factorials of two integers n and m.\n    \n    Parameters\n    ----------\n    n : int\n        The first input integer.\n    m : int\n        The second input integer.\n        \n    Returns\n    -------\n    int\n        The GCD of n! and m!.\n    \n    Examples\n    --------\n    >>> gcd_of_factorials(5, 3)\n    6\n    \n    >>> gcd_of_factorials(4, 4)\n    24\n    \"\"\"\n    return math.gcd(math.factorial(n), math.factorial(m))", "def combinations(n: int, r: int) -> int:\n    \"\"\"\n    Computes the number of combinations (nCr), ways to choose r elements from a set of n elements without regard to order.\n    Parameters\n    ----------\n    n : int\n        Total number of items.\n    r : int\n        Number of items to choose.\n    Returns\n    -------\n    int\n        The number of ways to choose r items from n items without replacement and without order.\n    Raises\n    ------\n    ValueError\n        If n or r is negative or if r > n.\n    Examples\n    --------\n    >>> combinations(5, 3)\n    10\n    >>> combinations(6, 2)\n    15\n    \"\"\"\n    if n < 0 or r < 0 or r > n:\n        raise ValueError(\"Invalid value for n or r. Ensure 0 <= r <= n and n, r >= 0\")\n    return math.comb(n, r)", "def combined_permutations(total_items, groups, unwanted=None):\n    \"\"\"\n    Calculate the total permutations considering different groups and subtracting\n    any unwanted arrangements using factorial operations.\n    Parameters:\n    total_items (int): Total number of items to arrange.\n    groups (list of int): Each element represents a number of items within a group treated as indistinguishable.\n    unwanted (int, optional): Number of unwanted scenarios to subtract, calculated as a factorial.\n    Returns:\n    int: Net permissible permutations.\n    Examples:\n    >>> combined_permutations(10, [7, 3])\n    120\n    >>> combined_permutations(10, [7, 3], unwanted=factorial(2))\n    60\n    \"\"\"\n    total_permutations = factorial(total_items)\n    for group_size in groups:\n        total_permutations //= factorial(group_size)\n    if unwanted is not None:\n        total_permutations -= unwanted\n    return total_permutations"], "Counting Problems": ["def combinations(n, r):\n    \"\"\"\n    Calculate the number of combinations (order does not matter) of choosing r items from n items.\n    \n    Parameters:\n    n (int): Total number of items.\n    r (int): Number of items to choose.\n    Returns:\n    int: The number of combinations.\n    Example:\n    >>> combinations(5, 3)  # Choosing 3 out of 5 distinct items\n    10\n    \"\"\"\n    return factorial(n) // (factorial(r) * factorial(n - r))", "def permutations(n, r):\n    \"\"\"\n    Calculate the number of permutations (order matters) of choosing r items from n items.\n    Parameters:\n    n (int): Total number of items.\n    r (int): Number of items to choose.\n    Returns:\n    int: The number of permutations.\n    Example:\n    >>> permutations(5, 3)  # Choosing 3 out of 5 distinct items\n    60\n    \"\"\"\n    return factorial(n) // factorial(n - r)", "def factorial(n):\n    \"\"\"Compute factorial of a non-negative integer n using memoization to improve performance.\n    Parameters:\n        n (int): A non-negative integer whose factorial is desired.\n    Returns:\n        int: Factorial of n.\n    \n    Examples:\n        >>> factorial(5)\n        120\n        >>> factorial(0)\n        1\n    \"\"\"\n    if n == 0:\n        return 1\n    else:\n        return n * factorial(n - 1)", "def combination(n, r):\n    \"\"\" Compute the number of combinations of n items taken r at a time.\n    Parameters:\n        n (int): Total number of items.\n        r (int): Number of items to select.\n    Returns:\n        int: Number of combinations.\n    \"\"\"\n    return math.comb(n, r)", "def permutations(n, m):\n    \"\"\"\n    Calculate the number of permutations of n items taken m at a time, denoted as P(n, m).\n    \n    Parameters:\n        n (int): Total number of items.\n        m (int): Number of items to choose.\n    Returns:\n        int: Number of permutations.\n    \n    Examples:\n        >>> permutations(5, 3)\n        60\n    \"\"\"\n    if m > n:\n        return 0\n    return factorial(n) // factorial(n - m)", "def factorial(n):\n    if n == 0 or n == 1:\n        return 1\n    return n * factorial(n - 1)", "def factorial(n):\n    \"\"\" Compute the factorial of a number.\n    Parameters:\n        n (int): The number to compute factorial of.\n    Returns:\n        int: Factorial of `n`.\n    \"\"\"\n    return math.factorial(n)", "def permutations_with_constraints(data, constraints):\n    \"\"\"Generate permutations of data considering positional constraints.\n    Parameters:\n        data (iterable): The items to permute.\n        constraints (dict): Positional constraints where keys are indices and values are fixed elements.\n    Returns:\n        generator: Yields valid permutations considering constraints.\n    \"\"\"\n    from itertools import permutations\n    \n    def is_valid(perm):\n        return all(perm[pos] == item for pos, item in constraints.items())\n    \n    return (perm for perm in permutations(data) if is_valid(perm))", "def calculate_binomial_coefficient(n, k):\n    \"\"\"\n    Calculate the binomial coefficient, which is the coefficient of the term \n    in the expansion of (x + y) to the nth power.\n    Parameters:\n    n (int): the power to which the binomial is raised.\n    k (int): the term whose coefficient is calculated.\n    Returns:\n    int: the binomial coefficient.\n    \"\"\"\n    \n    return comb(n, k)", "def calculate_combinations(n, k):\n    \"\"\"Calculate C(n, k), the number of combinations of n items taken k at a time.\"\"\"\n    if n < k:\n        return 0\n    return factorial(n) // (factorial(k) * factorial(n - k))", "def factorial(n):\n    \"\"\"Calculate factorial of a number.\"\"\"\n    if n < 0:\n        raise ValueError(\"Factorial is not defined for negative numbers.\")\n    return math.factorial(n)", "def permutation_with_repetition(n, counts):\n    \"\"\"\n    Computes the number of permutations for a multiset.\n    The number of distinct permutations of a multiset is found by dividing the factorial \n    of the total number of items by the product of the factorials of the number of each \n    kind of item.\n    n: int, Total number of items.\n    counts: list of int, List containing the frequency of each kind of item.\n    Returns:\n    int, The number of distinct permutations of the multiset.\n    Example:\n    >>> permutation_with_repetition(8, [2, 2, 2, 2])\n    2520\n    \"\"\"\n    from math import factorial\n    result = factorial(n)\n    for c in counts:\n        result //= factorial(c)\n    return result", "def list_permutations(items, k):\n    \"\"\"List all possible permutations of k elements from the given items.\"\"\"\n    return list(permutations(items, k))", "def count_valid_permutations(n, constraints):\n    \"\"\" Count permutations of `n` items fulfilling given constraints.\n    Parameters:\n        n (int): Total number of items.\n        constraints (list of tuple): Each tuple contains a fixed element and its position.\n    Returns:\n        int: Number of valid permutations.\n    \"\"\"\n    from itertools import permutations\n    \n    items = list(range(1, n+1))\n    total = 0\n    for perm in permutations(items):\n        if all(perm[pos-1] == value for pos, value in constraints):\n            total += 1\n    return total", "def multiplicative_counting(*choices):\n    \"\"\"\n    Calculate the total number of outcomes for a series of independent choices using the multiplication principle.\n    Parameters:\n    *choices (int): A variable number of arguments, each representing the number of options for an independent event.\n    Returns:\n    int: The total number of possible outcomes.\n    Example:\n    >>> multiplicative_counting(3, 4, 2)  # e.g., 3 ways to choose a shirt, 4 ways to choose pants, 2 ways to wear shoes or not\n    24\n    \"\"\"\n    from functools import reduce\n    from operator import mul\n    return reduce(mul, choices, 1)", "def multistage_choices(choices):\n    \"\"\" Calculate total outcomes for sequential selection stages.\n    Parameters:\n        choices (list of list of int): Each sublist represents choices available in each stage.\n    Returns:\n        int: Total number of outcomes.\n    \"\"\"\n    from functools import reduce\n    import operator\n    \n    return reduce(operator.mul, (len(stage) for stage in choices))", "def count_by_multiplication(elements, constraints=None):\n    \"\"\"\n    Calculate total outcomes using the multiplication principle with an option to apply constraints\n    via a custom function (inclusion-exclusion principle).\n    Parameters:\n        elements (list): List of integers representing the number of choices at each step.\n        constraints (func, optional): A function that accepts the number of total unrestricted outcomes\n                                      and returns the number of valid outcomes considering constraints.\n    Returns:\n        int: The total number of possible outcomes or valid outcomes based on constraints.\n    Examples:\n        >>> count_by_multiplication([3, 4, 5])  # Simple case without constraints\n        60\n        >>> count_by_multiplication([3, 4, 5], lambda x: x - 10)  # Applying a simple constraint\n        50\n    \"\"\"\n    from functools import reduce\n    from operator import mul\n    total_outcomes = reduce(mul, elements, 1)\n    if constraints:\n        return constraints(total_outcomes)\n    return total_outliers", "def factorial_cached(n):\n    \"\"\" Cached factorial function to improve performance in repeated calls with same n. \"\"\"\n    return factorial(n)", "def simplify_factorials(num, den):\n    \"\"\"\n    Simplify a fraction involved in factorial calculations by reducing numerator and denominator factorials.\n    \n    Parameters:\n        num (int): The numerator which could be n!\n        den (int): The denominator typically a product of factorials, e.g. k1!*k2!*...*km!\n    \n    Returns:\n        int: Simplified result of the fraction.\n    \n    Examples:\n        >>> simplify_factorials(5, 2*3)\n        10\n    \"\"\"\n    result = 1\n    for i in range(num, den, -1):\n        result *= i\n    return result", "def binomial_coefficient(n, k):\n    \"\"\"\n    Calculate the binomial coefficient \"n choose k\", which is the number of ways to choose k items from n items without considering the order.\n    \n    Parameters:\n        n (int): Total number of items.\n        k (int): Number of items to choose.\n    \n    Returns:\n        int: The binomial coefficient.\n    \n    Examples:\n        >>> binomial_coefficient(5, 3)\n        10\n        >>> binomial_coefficient(10, 2)\n        45\n    \"\"\"\n    if k > n:\n        return 0\n    if k > n - k:  # Take advantage of symmetry\n        k = n - k\n    c = 1\n    for i in range(k):\n        c = c * (n - i) // (i + 1)\n    return c", "def permutation(n, k):\n    \"\"\"\n    Calculate the number of ways to choose k elements from a set of n elements where order matters.\n    Parameters:\n    n (int): Total number of elements.\n    k (int): Number of elements to arrange.\n    Returns:\n    int: The number of permutations.\n    Examples:\n    >>> permutation(5, 3)\n    60\n    >>> permutation(10, 1)\n    10\n    \"\"\"\n    return factorial(n) // factorial(n - k)", "def calculate_distribution(n, k):\n    \"\"\"\n    Calculate the number of ways to distribute n indistinguishable balls into k distinguishable boxes.\n    Parameters:\n    n (int): Number of indistinguishable balls.\n    k (int): Number of distinguishable boxes.\n    Returns:\n    int: the number of ways to distribute.\n    \"\"\"\n    return comb(n + k - 1, k - 1)", "def constraint_function(total):\n    max_choices = 5 * 3  # Maximum choices for the first and third positions\n    return total - max_choices"], "Binomial Coefficients": ["def binomial_coefficient(n, k):\n    \"\"\"\n    Calculates the binomial coefficient \"n choose k\" which is the coefficient of the k-th term\n    in polynomial expansion of (1 + x)^n.\n    \n    Parameters:\n    n (int): the total number of items or the upper value in the binomial.\n    k (int): the number of items being chosen or the lower value in the binomial.\n    \n    Returns:\n    int: the binomial coefficient.\n    \n    Examples:\n    >>> binomial_coefficient(5, 2)\n    10\n    >>> binomial_coefficient(10, 5)\n    252\n    \"\"\"\n    if k > n:\n        return 0\n    if k == 0 or k == n:\n        return 1\n    k = min(k, n - k)  # Take advantage of symmetry\n    c = 1\n    for i in range(k):\n        c = c * (n - i) // (i + 1)\n    return c", "def sum_of_binomial_coefficients(n):\n    \"\"\"\n    Calculates the sum of binomial coefficients for given n over k from 0 to n.\n    This is effectively evaluating (1 + 1)^n due to the Binomial Theorem.\n    \n    Parameters:\n    n (int): the upper value in the binomial coefficient.\n    \n    Returns:\n    int: the sum of binomial coefficients for given n.\n    \n    Examples:\n    >>> sum_of_binomial_coefficients(4)\n    16\n    >>> sum_of_binomial_coefficients(5)\n    32\n    \"\"\"\n    return 2 ** n", "def factorial(n):\n    \"\"\"\n    Compute the factorial of a non-negative integer n.\n    Parameters:\n    n : int\n        A non-negative integer\n    Returns:\n    int\n        The factorial of n, n!\n    Examples:\n    >>> factorial(5)\n    120\n    >>> factorial(0)\n    1\n    \"\"\"\n    if n < 0:\n        raise ValueError(\"Factorial is not defined for negative numbers\")\n    return math.factorial(n)", "def pascals_triangle(rows: int) -> List[List[int]]:\n    \"\"\"\n    Generate Pascal's Triangle up to the specified number of rows.\n    \n    Parameters:\n        rows (int): Number of rows in Pascal's triangle to generate.\n    \n    Returns:\n        List[List[int]]: Pascal's Triangle as a list of lists, where each inner list represents a row of the triangle.\n    Examples:\n        >>> pascals_triangle(3)\n        [[1], [1, 1], [1, 2, 1]]\n    \"\"\"\n    triangle = [[1]]\n    for n in range(1, rows):\n        row = [1]\n        for k in range(1, n):\n            row.append(triangle[n-1][k-1] + triangle[n-1][k])\n        row.append(1)\n        triangle.append(row)\n    return triangle", "def sum_of_binomial_row(n: int) -> int:\n    \"\"\"\n    Calculate the sum of the nth row in Pascal's Triangle (which is actually 2^n).\n    \n    Parameters:\n        n (int): The row number to sum up the binomial coefficients.\n        \n    Returns:\n        int: The sum of binomial coefficients in the nth row of Pascal's Triangle.\n    Examples:\n        >>> sum_of_binomial_row(3)\n        8\n    \"\"\"\n    return 2 ** n", "def binomial_coefficient_relations(n: int, k: int) -> bool:\n    \"\"\"\n    Verify properties of binomial coefficients related to symmetry and other relations.\n    \n    Parameters:\n        n (int): Total number of items.\n        k (int): Number of items to choose.\n    \n    Returns:\n        bool: True if all properties hold, otherwise False.\n        \n    Examples:\n        >>> binomial_coefficient_relations(6, 2)\n        True\n    \"\"\"\n    if k > n or k < 0:\n        return False"], "Pascal's Triangle": ["def generate_pascals_triangle(num_rows):\n    \"\"\"\n    Generate Pascal's Triangle up to a given number of rows.\n    \n    Parameters:\n        num_rows (int): The number of rows of Pascal's triangle to generate.\n        \n    Returns:\n        list: A list of lists, where each inner list represents a row of Pascal's triangle.\n    \n    Example:\n        >>> generate_pascals_triangle(3)\n        [[1], [1, 1], [1, 2, 1]]\n    \"\"\"\n    from math import comb\n    triangle = []\n    for n in range(num_rows):\n        row = [comb(n, k) for k in range(n + 1)]\n        triangle.append(row)\n    return triangle", "def binomial_coefficient(n, k):\n    \"\"\"\n    Calculate the binomial coefficient C(n, k) as n! / (k!*(n-k)!).\n    Parameters:\n        n (int): the total number of items.\n        k (int): the number of items to choose.\n    Returns:\n        int: the binomial coefficient.\n    Examples:\n    >>> binomial_coefficient(5, 2)\n    10\n    >>> binomial_coefficient(21, 10)\n    352716\n    \"\"\"\n    if k > n:\n        return 0\n    if k > n // 2:  # Utilize the symmetric property of binomial coefficients\n        k = n - k\n    return factorial(n) // (factorial(k) * factorial(n - k))"]}