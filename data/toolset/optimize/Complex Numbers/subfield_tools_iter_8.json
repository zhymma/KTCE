{"Absolute Value": [{"tool": "def modulus_complex(z):\n    \n    return np.abs(z)", "subfield": "Absolute Value", "tool_name": "modulus_complex", "tool_type": "function", "description": "Computes the modulus (absolute value) of a complex number.", "docstring": "Computes the modulus (absolute value) of a complex number.\n    Parameters:\n        z (complex): The complex number to compute the modulus for.\n    Returns:\n        float: The modulus of the complex number.", "Freq": 55, "TSR": 34, "experience_pool": "- Experience: When using the `modulus_complex()` function, make sure to pass a complex number as the parameter. The function expects a complex number and will raise an error if a different type is provided.\n- Experience: The `modulus_complex()` function uses the `np.abs()` function from the NumPy library to calculate the modulus of a complex number. Make sure to import the NumPy library (`import numpy as np`) before using the function."}, {"tool": "def conjugate(numbers):\n    \n    return [np.conj(z) for z in numbers]", "subfield": "Absolute Value", "tool_name": "conjugate", "tool_type": "function", "description": "Return the complex conjugate of the given complex numbers.\n    :param numbers: list of complex numbers in the form a + bi.\n    :return: list of complex numbers, the conjugates of the complex numbers.", "docstring": "Return the complex conjugate of the given complex numbers.\n    :param numbers: list of complex numbers in the form a + bi.\n    :return: list of complex numbers, the conjugates of the complex numbers.", "Freq": 8.0, "TSR": 4.5}, {"tool": "def complex_operations(a, b, operation='multiply'):\n    \n    if operation == 'multiply':\n        return np.multiply(a, b)\n    elif operation == 'divide':\n        return np.divide(a, b)\n    elif operation == 'add':\n        return np.add(a, b)\n    elif operation == 'power':\n        return np.power(a, int(b.real))  # b is assumed to be an integer for power\n    else:\n        raise ValueError(\"Unsupported operation. Use 'multiply', 'divide', 'add', or 'power'.\")", "subfield": "Absolute Value", "tool_name": "complex_operations", "tool_type": "function", "description": "Perform operations (multiply, divide, add, power) on two complex numbers given in Cartesian form.", "docstring": "Perform operations (multiply, divide, add, power) on two complex numbers given in Cartesian form.\n    Parameters:\n    a (complex): First complex number in the form a + bi.\n    b (complex): Second complex number in the form a + bi.\n    operation (str): The operation to perform ['multiply', 'divide', 'add', 'power'].\n    Returns:\n    complex: The result of the operation.\n    Examples:\n    >> complex_operations(complex(1, 1), complex(2, 3), 'multiply')\n    (-1+5j)", "Freq": 15.625, "TSR": 6.75, "experience_pool": "Experience 1:\nProblem: The tool code is missing the necessary import statement for the numpy library, causing an \"Unsupported operation\" error.\nSolution: Add the import statement `import numpy as np` at the beginning of the tool code.\n\nExperience 2:\nProblem: The tool code is not handling the 'add' operation correctly.\nSolution: Add a new condition in the `complex_operations` function to handle the 'add' operation using the numpy `add` function."}, {"tool": "def conjugate_complex_number(c):\n    \n    return c.conjugate()", "subfield": "Absolute Value", "tool_name": "conjugate_complex_number", "tool_type": "function", "description": "This function computes the conjugate of a complex number.", "docstring": "This function computes the conjugate of a complex number.\n    Parameters:\n    c (complex): Complex number\n    Returns:\n    complex : The conjugate of the complex number `c`.", "Freq": 1, "TSR": 1}, {"tool": "def absolute_value_complex(complex_number):\n    \n    return abs(complex_number)", "subfield": "Absolute Value", "tool_name": "absolute_value_complex", "tool_type": "function", "description": "Computes the absolute value (modulus) of a complex number.", "docstring": "Computes the absolute value (modulus) of a complex number.\n    Parameters:\n    - complex_number (complex): The complex number for which to find the modulus.\n    Returns:\n    - float: The modulus of the complex number.\n    Example:\n    >>> absolute_value_complex(3+4j)\n    5.0", "Freq": 20, "TSR": 16, "experience_pool": "- Problem: Evaluate $|2-4i| + |2+4i|.$\n  Answer: 4\\sqrt{5}\n  Tool usage: The tool was used correctly and provided the expected result.\n  \n- Problem: Let $z$ and $w$ be complex numbers such that $|2z - w| = 25$, $|z + 2w| = 5$, and $|z + w| = 2$. Find $|z|$.\n  Answer: 9\n  Tool usage: The tool was used correctly and provided the expected result.\n  \n- Problem: Let $z$ and $w$ be complex numbers such that $|z| = 1$ and $|w| = 3$. If $|z+w| = 2$, what is $ \\left | \\frac{1}{z} + \\frac{1}{w} \\right|$?\n  Answer: \\frac{2}{3}\n  Tool usage: The tool was used correctly and provided the expected result.\n  \n- Problem: Suppose $z$ is a complex number such that $z^2 = 24-32i$. Find $|z|$.\n  Answer: 2\\sqrt{10}\n  Tool usage: The tool was used correctly and provided the expected result.\n  \n- Problem: When $1 - i \\sqrt{3}$ is converted to the exponential form $re^{i \\theta}$, what is $\\theta$?\n  Answer: \\frac{5\\pi}{3}\n  Tool usage: The tool was used correctly and provided the expected result.\n  \n- Problem: Evaluate $|2-4i| + |2+4i|.$\n  Answer: 4\\sqrt{5}\n  Tool usage: The tool was used correctly and provided the expected result."}, {"tool": "def argument_complex(z):\n    \n    return np.angle(z)", "subfield": "Absolute Value", "tool_name": "argument_complex", "tool_type": "function", "description": "Computes the argument (angle) of a complex number.", "docstring": "Computes the argument (angle) of a complex number.\n    \n    Parameters:\n        z (complex): The complex number to compute the argument for.\n        \n    Returns:\n        float: The argument of the complex number in radians.", "Freq": 4, "TSR": 2, "experience_pool": "Tool code was modified to include the necessary import statement for the `np` module."}, {"tool": "def multiplicative_property(z1, z2):\n    \n    return abs(z1 * z2)", "subfield": "Absolute Value", "tool_name": "multiplicative_property", "tool_type": "function", "description": "Apply the multiplicative property of moduli on two complex numbers.", "docstring": "Apply the multiplicative property of moduli on two complex numbers.\n    Parameters\n    ----------\n    z1, z2 : complex\n        Two complex numbers.\n    Returns\n    -------\n    float\n        The product of the moduli of the given complex numbers, demonstrating that |z1*z2| = |z1|*|z2|.\n    Examples\n    --------\n    >>> multiplicative_property(1+2j, 3+4j)\n    10.0", "Freq": 12, "TSR": 10}, {"tool": "def complex_magnitude(z):\n    \n    return abs(z)", "subfield": "Absolute Value", "tool_name": "complex_magnitude", "tool_type": "function", "description": "Calculates the magnitude of the complex number.", "docstring": "Calculates the magnitude of the complex number.\n    Parameters:\n    - z (complex): A complex number.\n    Returns:\n    - float: The magnitude (absolute value) of the complex number.\n    Examples:\n    >>> complex_magnitude(3+4j)\n    5.0", "Freq": 1, "TSR": 0}, {"tool": "def solve_complex_equation(coefficients, target):\n    \n    import numpy as np\n    # Convert the coefficients to a numpy array\n    coefficients = np.array(coefficients, dtype=complex)\n    # Solve the equation using numpy's roots function\n    solutions = np.roots(coefficients)\n    return solutions", "subfield": "Absolute Value", "tool_name": "solve_complex_equation", "tool_type": "function", "description": "Solve a complex equation of the form a_n*z^n + a_(n-1)*z^(n-1) + ... + a_1*z + a_0 = target.", "docstring": "Solve a complex equation of the form a_n*z^n + a_(n-1)*z^(n-1) + ... + a_1*z + a_0 = target.\n    Parameters:\n    coefficients (list): A list of complex coefficients of the equation in the order [a_n, a_(n-1), ..., a_1, a_0].\n    target (complex): The target value to solve for.\n    Returns:\n    solutions (list): A list of complex solutions to the equation.", "Freq": 16.5, "TSR": 2}, {"tool": "def solve_complex_equation(coefficients, target):\n    \n    import numpy as np\n    # Convert the coefficients to a numpy array\n    coefficients = np.array(coefficients, dtype=complex)\n    # Solve the equation using numpy's roots function\n    solutions = np.roots(coefficients) \n    # Round the solutions to avoid floating point errors\n    solutions = np.round(solutions, decimals=10)\n    # Filter out solutions that are not equal to the target value\n    solutions = [s for s in solutions if np.isclose(s, target)]\n    return solutions", "subfield": "Absolute Value", "tool_name": "solve_complex_equation", "tool_type": "function", "description": "Solve an equation with complex coefficients.", "docstring": "Solve an equation with complex coefficients.\n    Parameters:\n    coefficients (list): A list of complex coefficients of the equation.\n    target (complex): The target value to solve for.\n    Returns:\n    solutions (list): A list of complex solutions to the equation.\n    Examples:\n    >>> solve_complex_equation([1, -4, 5], 0)\n    [2.5+0.5j, 2.5-0.5j]\n    >>> solve_complex_equation([1, -3, 3, -1], 1)\n    [1+0j]", "Freq": 2, "TSR": 1}, {"tool": "def modulus_and_argument(r, theta):\n    \n    import numpy as np\n    modulus = np.abs(r)\n    argument = np.angle(r * np.exp(1j * theta))\n    return modulus, argument", "subfield": "Absolute Value", "tool_name": "modulus_and_argument", "tool_type": "function", "description": "Calculate the modulus and argument of a complex number expressed in polar form.", "docstring": "Calculate the modulus and argument of a complex number expressed in polar form.\n    Parameters:\n    r (float): The magnitude (modulus) of the complex number.\n    theta (float): The angle (argument) of the complex number in radians.\n    Returns:\n    tuple: A tuple containing the modulus and argument of the complex number.", "Freq": 0, "TSR": 0}], "Function Operations": []}