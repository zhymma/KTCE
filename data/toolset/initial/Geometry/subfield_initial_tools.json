{"Circles": ["def circle_circumference(radius):\n    \"\"\" Calculates the circumference of a circle given its radius.\n    \n    Parameters:\n        radius (float): The radius of the circle.\n    Returns:\n        float: The circumference of the circle.\n    \"\"\"\n    return 2 * np.pi * radius", "def circle_area(radius):\n    \"\"\"\n    Calculate the area of a circle given the radius.\n    \n    Parameters:\n    - radius (float): The radius of the circle.\n    \n    Returns:\n    - float: The area of the circle.\n    \"\"\"\n    return np.pi * radius ** 2", "def circle_equation(center, radius):\n    \"\"\" Generates the general form equation of a circle given its center and radius.\n    Parameters:\n        center (tuple): A tuple (x, y) representing the center of the circle.\n        radius (float): The radius of the circle.\n    Returns:\n        str: The equation of the circle in the form '(x - h)^2 + (y - k)^2 = r^2'.\n    \"\"\"\n    h, k = center\n    r_squared = np.square(radius)\n    return f\"(x - {h})^2 + (y - {k})^2 = {r_squared}\"", "def radius_from_area(area):\n    \"\"\"Calculate the radius of a circle from a given area.\n    \n    Parameters:\n        area (float): The area of the circle.\n        \n    Returns:\n        float: The radius of the circle.\n    \n    Example:\n        >>> radius_from_area(78.5)\n        5.0\n    \"\"\"\n    return math.sqrt(area / math.pi)", "def convert_general_to_standard_form(A, B, C, D, E, F):\n    \"\"\"\n    Converts a general circle equation of the form Ax^2 + By^2 + Cx + Dy + E = F\n    to its standard form (x-h)^2 + (y-k)^2 = r^2 and returns the coefficients h, k, and r_squared.\n    Parameters:\n        A, B, C, D, E, F (float): Coefficients of the general form of the circle equation\n    Returns:\n        tuple: A tuple containing h, k, and r_squared\n    Examples:\n    >>> convert_general_to_standard_form(1, 1, -4, -6, 8, 0)\n    (2.0, 3.0, 9.0)\n    \"\"\"\n    assert A == B == 1, \"The coefficients of x^2 and y^2 must both be 1 for a standard circle equation\"\n    h = -C / (2 * A)\n    k = -D / (2 * B)\n    r_squared = (C**2 + D**2) / (4 * A * B) - E + F\n    return (h, k, r_squared)", "def circle_standard_form(h, k, r):\n    \"\"\"Create the standard form equation of a circle (x-h)^2 + (y-k)^2 = r^2.\n    \n    Parameters:\n        h (float): The x-coordinate of the circle's center.\n        k (float): The y-coordinate of the circle's center.\n        r (float): The radius of the circle.\n        \n    Returns:\n        sympy.Eq: The equation of the circle in sympy equation format.\n        \n    Example:\n        >>> print(circle_standard_form(0, 0, 5))\n        Eq(x**2 + y**2, 25)\n    \"\"\"\n    x, y = sympy.symbols('x y')\n    return sympy.Eq((x - h)**2 + (y - k)**2, r**2)", "def circle_properties_from_equation(h, k, r_squared):\n    \"\"\"\n    Given the parameters h, k (center of the circle) and r_squared (radius squared),\n    returns the center, radius, area, and circumference of the circle.\n    \n    Parameters:\n        h (float): x-coordinate of the center of the circle\n        k (float): y-coordinate of the center of the circle\n        r_squared (float): square of the radius of the circle\n    Returns:\n        dict: Dictionary containing the center, radius, area, and circumference\n    \n    Examples:\n    >>> circle_properties_from_equation(0, 0, 25)\n    {'center': (0, 0), 'radius': 5.0, 'area': 78.5398, 'circumference': 31.4159}\n    \"\"\"\n    r = sqrt(r_squared)\n    area = pi * r**2\n    circumference = 2 * pi * r\n    return {\n        'center': (h, k),\n        'radius': r.evalf(),\n        'area': area.evalf(),\n        'circumference': circumference.evalf()\n    }", "def point_inside_circle(center, radius, point):\n    \"\"\"\n    Determine if a point is inside a given circle.\n    \n    Parameters:\n    - center (tuple): The (x, y) coordinates of the circle's center.\n    - radius (float): The radius of the circle.\n    - point (tuple): The (x, y) coordinates of the point to check.\n    \n    Returns:\n    - bool: True if the point is inside the circle, False otherwise.\n    \"\"\"\n    return np.sqrt((point[0] - center[0])**2 + (point[1] - center[1])**2) <= radius", "def circle_properties(radius, chord_length=None, angle_radians=None):\n    \"\"\"\n    Calculate properties of a circle given its radius with optional chord length and angle for intersected arc.\n    \n    Parameters:\n        radius (float): Radius of the circle.\n        chord_length (float, optional): Length of the chord within the circle.\n        angle_radians (float, optional): Angle subtended by the chord at the center of the circle in radians.\n    Returns:\n        dict: Properties including area, circumference, chord properties, and arc relationships.\n    \"\"\"\n    area = math.pi * radius**2\n    circumference = 2 * math.pi * radius\n    properties = {\n        'Area': area,\n        'Circumference': circumference\n    }\n    if chord_length is not None:\n        # Using the law of cosines to find the angle if not provided.\n        if angle_radians is None:\n            angle_radians = 2 * math.acos(chord_length / (2 * radius))\n        sagitta = radius * (1 - math.cos(angle_radians / 2))\n        arc_length = radius * angle_radians\n        segment_area = (radius**2 / 2) * (angle_radians - math.sin(angle_radians))\n        \n        properties.update({\n            'Chord Length': chord_length,\n            'Sagitta': sagitta,\n            'Arc Length': arc_length,\n            'Segment Area': segment_area\n        })\n    return properties", "def compute_triangle_properties(vertices):\n    \"\"\"\n    Compute properties of a triangle given its vertices.\n    Parameters:\n        vertices (array): An array of three tuples, each representing x, y coordinates of a vertex.\n    Returns:\n        dict: Properties including area, perimeter, side lengths, and types of triangle (isosceles, equilateral).\n    \"\"\"\n    vertices = np.array(vertices)\n    side_lengths = np.linalg.norm(vertices - np.roll(vertices, -1, axis=0), axis=1)\n    s = np.sum(side_lengths) / 2  # semi-perimeter\n    area = np.sqrt(s * np.prod(s - side_lengths))  # Heron's formula\n    is_iso = np.any(side_lengths[0] == side_lengths[1]) or np.any(side_lengths[1] == side_lengths[2])\n    is_equi = np.all(side_lengths[0] == side_lengths[1])\n    properties = {\n        'Area': area,\n        'Perimeter': 2 * s,\n        'Side Lengths': side_lengths,\n        'Isosceles': is_iso,\n        'Equilateral': is_equi\n    }\n    return properties"], "Coordinate Geometry": ["def distance_between_points(point1, point2):\n    \"\"\"\n    Calculate the Euclidean distance between two points in the plane.\n    \n    Parameters:\n    - point1 (tuple): The first point (x1, y1).\n    - point2 (tuple): The second point (x2, y2).\n    \n    Returns:\n    - float: The distance between the points.\n    \n    Examples:\n    >>> distance_between_points((1, 2), (4, 6))\n    5.0\n    \"\"\"\n    x1, y1 = point1\n    x2, y2 = point2\n    return ((x2 - x1)**2 + (y2 - y1)**2)**0.5", "def cartesian_to_polar(x, y):\n    \"\"\"\n    Converts Cartesian coordinates to Polar coordinates.\n    Parameters:\n    x (float): x-coordinate\n    y (float): y-coordinate\n    Returns:\n    tuple: (radius r, angle theta in radians)\n    \"\"\"\n    r = np.sqrt(x**2 + y**2)\n    theta = np.arctan2(y, x)  # arctan2 automatically adjusts based on the quadrant\n    return r, theta", "def midpoint(p1, p2):\n    \"\"\"\n    Calculates the midpoint between two points in a 2D coordinate system.\n    Parameters:\n    - p1: Tuple of coordinates (x1, y1) for the first point.\n    - p2: Tuple of coordinates (x2, y2) for the second point.\n    Returns:\n    - Tuple: Coordinates of the midpoint.\n    Example:\n    >>> midpoint((1, 2), (3, 4))\n    (2.0, 3.0)\n    \"\"\"\n    return tuple((np.array(p1) + np.array(p2)) / 2)", "def slope_of_line(p1, p2):\n    \"\"\"\n    Computes the slope of the line segment connecting two points. Raises exception if the line is vertical.\n    Parameters:\n    - p1: Tuple of coordinates (x1, y1)\n    - p2: Tuple of coordinates (x2, y2)\n    Returns:\n    - float: Slope of the line.\n    Example:\n    >>> slope_of_line((1, 2), (3, 6))\n    2.0\n    \"\"\"\n    x1, y1 = p1\n    x2, y2 = p2\n    if x2 == x1:\n        raise ValueError(\"Vertical line segment has no slope.\")\n    return (y2 - y1) / (x2 - x1)", "def line_from_points(point1, point2):\n    \"\"\"\n    Generates the equation of a line in 2D space given two points.\n    Parameters\n    ----------\n    point1 : array_like\n        Coordinates (x1, y1) of the first point.\n    point2 : array_like\n        Coordinates (x2, y2) of the second point.\n    Returns\n    -------\n    tuple\n        Coefficients (A, B, C) of the line equation Ax + By + C = 0.\n    Examples\n    --------\n    >>> line_from_points([1, 1], [4, 5])\n    (-4, 3, -1)\n    \"\"\"\n    x1, y1 = point1\n    x2, y2 = point2\n    A = y2 - y1\n    B = x1 - x2\n    C = x2 * y1 - x1 * y2\n    return (A, B, C)", "def cross_product(v1, v2):\n    \"\"\"\n    Computes the cross product of two vectors.\n    Parameters:\n    v1 (ndarray): The first vector.\n    v2 (ndarray): The second vector.\n    Returns:\n    ndarray: The cross product of v1 and v2.\n    \"\"\"\n    return np.cross(v1, v2)", "def area_of_triangle(p1, p2, p3):\n    \"\"\"\n    Calculate the area of a triangle given its three vertices.\n    \n    Parameters:\n    - p1, p2, p3 (tuple): Coordinates of the triangle vertices (x1, y1), (x2, y2), (x3, y3).\n    \n    Returns:\n    - float: The area of the triangle.\n    Example:\n    >>> area_of_triangle((0, 0), (4, 0), (0, 3))\n    6.0\n    \"\"\"\n    x1, y1 = p1\n    x2, y2 = p2\n    x3, y3 = p3\n    return 0.5 * abs(x1*(y2 - y3) + x2*(y3 - y1) + x3*(y1 - y2))", "def reflect(point, axis=\"x\"):\n    \"\"\"\n    Reflect a point across a specified axis in 2D.\n    \n    Parameters:\n        point (tuple): Coordinates (x, y) of the point.\n        axis (str): Axis you want to reflect over, \"x\", \"y\", or \"origin\". Additionally supports \"y=x\".\n    \n    Returns:\n        tuple: Coordinates of the reflected point.\n        \n    Examples:\n        reflect((2, 3), axis=\"x\")\n        reflect((2, 3), axis=\"y\")\n        reflect((2, 3), axis=\"origin\")\n        reflect((2, 3), axis=\"y=x\")\n    \"\"\"\n    x, y = point\n    if axis == \"x\":\n        return (x, -y)\n    elif axis == \"y\":\n        return (-x, y)\n    elif axis == \"origin\":\n        return (-x, -y)\n    elif axis == \"y=x\":\n        return (y, x)\n    else:\n        raise ValueError(\"Invalid axis specified.\")", "def convert_conic_to_standard_form(eq_type, coefficients):\n    \"\"\"\n    Converts a general equation of a conic section (circle, ellipse, parabola, hyperbola) to its standard form.\n    \n    Parameters:\n    - eq_type (str): Type of conic ('circle', 'ellipse', 'parabola', 'hyperbola').\n    - coefficients (dict): Coefficients of the equation. E.g., for a circle: {'x^2': 1, 'y^2': 1, 'x': -6, 'y': 4, 'constant': -3}\n    Returns:\n    - dict: Standardized form parameters.\n    Example:\n    >>> convert_conic_to_standard_form('circle', {'x^2': 1, 'y^2': 1, 'x': -6, 'y': 4, 'constant': -3})\n    {'center': (3, -2), 'radius': 4}\n    \"\"\"\n    import math\n    if eq_type in ['circle', 'ellipse']:\n        A = coefficients.get('x^2', 0)\n        B = coefficients.get('y^2', 0)\n        C = coefficients.get('x', 0)\n        D = coefficients.get('y', 0)\n        E = coefficients.get('constant', 0)\n        h = -C / (2 * A)\n        k = -D / (2 * B)\n        r_squared = -E + (C**2) / (4 * A) + (D**2) / (4 * B)\n        if eq_type == 'circle':\n            return {'center': (h, k), 'radius': math.sqrt(r_squared)}\n    elif eq_type == 'parabola':\n        # Assume coefficients of 'x^2' or 'y^2' and a linear term for directrix/vertex form conversion.\n        pass\n    elif eq_type == 'hyperbola':\n        # Similar to ellipse handling but taking care of differences in signs and asymptote calculations.\n        pass\n    return {}", "def calculate_area_of_square(side_length):\n    \"\"\"\n    Calculate the area of a square given the side length.\n    \n    Parameters:\n        side_length (float or sympy expression): The length of the side of the square.\n    \n    Returns:\n        float or sympy expression: The area of the square.\n    Example:\n        area = calculate_area_of_square(5)\n        print(area)  # Output: 25\n    \"\"\"\n    return side_length**2", "def circle_area(radius):\n    \"\"\"\n    Calculates the area of a circle given its radius.\n    Parameters:\n    radius (float): The radius of the circle\n    Returns:\n    float: The area of the circle\n    \"\"\"\n    return np.pi * radius**2", "def vector_add(v1, v2):\n    \"\"\"\n    Adds two vectors.\n    Parameters:\n    v1 (ndarray): A numpy array representing the first vector.\n    v2 (ndarray): A numpy array representing the second vector.\n    Returns:\n    ndarray: The vector sum of v1 and v2.\n    \"\"\"\n    return np.add(v1, v2)", "def circle_equation(h, k, r):\n    \"\"\"\n    Returns the standard form equation of a circle given the center (h, k) and radius r.\n    Parameters:\n    h (float): The x-coordinate of the center.\n    k (float): The y-coordinate of the center.\n    r (float): The radius of the circle.\n    Returns:\n    str: The equation of the circle in standard form.\n    Examples:\n    >>> circle_equation(0, 0, 1)\n    '(x - 0)^2 + (y - 0)^2 = 1^2'\n    \"\"\"\n    return f\"(x - {h})^2 + (y - {k})^2 = {r}^2\"", "def line_equation_from_point_slope(point, slope):\n    \"\"\"\n    Find the equation of a line in slope-intercept form 'y = mx + c' given a point and a slope.\n    \n    Parameters:\n    - point (tuple): Point (x, y) through which the line passes.\n    - slope (float): Slope of the line.\n    \n    Returns:\n    - tuple: slope m and intercept c of the line 'y = mx + c'.\n    \n    Examples:\n    >>> line_equation_from_point_slope((1, 2), 3)\n    (3, -1)\n    \"\"\"\n    x, y = point\n    c = y - slope * x\n    return slope, c", "def vector_subtract(v1, v2):\n    \"\"\"\n    Subtracts the second vector from the first.\n    Parameters:\n    v1 (ndarray): A numpy array representing the first vector.\n    v2 (ndarray): A numpy array representing the second vector.\n    Returns:\n    ndarray: The vector result of v1 - v2.\n    \"\"\"\n    return np.subtract(v1, v2)", "def midpoint(point1, point2):\n    \"\"\"Calculate the midpoint between two points in n-dimensional space.\n    Parameters:\n        point1 (array-like): The first point coordinates.\n        point2 (array-like): The second point coordinates.\n    Returns:\n        ndarray: The coordinates of the midpoint.\n    Examples:\n        >>> midpoint([1, 2], [3, 4])\n        array([2., 3.])\n    \"\"\"\n    return (np.array(point1) + np.array(point2)) / 2", "def point_line_position(point, line):\n    \"\"\"\n    Determine the relative position of a point with respect to a line.\n    \n    Parameters:\n    - point (tuple): The point (x, y).\n    - line (tuple): The slope and intercept (m, c) of the line.\n    \n    Returns:\n    - str: 'above', 'below' or 'on' the line\n    \n    Examples:\n    >>> point_line_position((3, 4), (1, 1))\n    'above'\n    \"\"\"\n    x, y = point\n    m, c = line\n    line_y = m * x + c\n    if y > line_y:\n        return 'above'\n    elif y < line_y:\n        return 'below'\n    else:\n        return 'on'", "def vector_from_points(point1, point2):\n    \"\"\"\n    Calculate the vector from point1 to point2 in 3D.\n    \n    Parameters:\n    - point1 (array-like): Coordinates of the first point.\n    - point2 (array-like): Coordinates of the second point.\n    \n    Returns:\n    - numpy.ndarray: The vector from point1 to point2.\n    \n    Example:\n    >>> vector_from_points([1, 2, 3], [4, 5, 6])\n    array([3, 3, 3])\n    \"\"\"\n    return np.array(point2) - np.array(point1)", "def circle_equation(center, radius):\n    \"\"\"Generate the equation of a circle given the center and radius.\n    Parameters:\n        center (tuple): Coordinates of the center of the circle (x, y).\n        radius (float): The radius of the circle.\n    Returns:\n        sympy.Eq: The equation of the circle.\n    Examples:\n        >>> circle_equation((0, 0), 5)\n        Eq(x**2 + y**2, 25)\n    \"\"\"\n    x, y = symbols('x y')\n    x0, y0 = center\n    return Eq((x - x0)**2 + (y - y0)**2, radius**2)", "def square_side_from_diagonal(diagonal):\n    \"\"\"\n    Calculate the side length of a square given the diagonal, using the Pythagorean theorem.\n    Parameters:\n    diagonal (float): The length of the diagonal of the square.\n    Returns:\n    float: The length of one side of the square.\n    Examples:\n    >>> square_side_from_diagonal(5.656854249492381)\n    4.0\n    \"\"\"\n    return diagonal / np.sqrt(2)", "def vector_magnitude(vector):\n    \"\"\"\n    Calculates the magnitude (norm) of a vector.\n    Parameters:\n    vector (ndarray): The vector whose magnitude is to be calculated.\n    Returns:\n    float: The magnitude of the vector.\n    \"\"\"\n    return np.linalg.norm(vector)", "def parametric_point_evaluation(param_eqs, t_values):\n    \"\"\"\n    Evaluate parametric equations at given parameter values.\n    \n    Parameters:\n        param_eqs (dict): A dictionary with variables as keys and their parametric equations as values.\n        t_values (list or scalar): A scalar or list of values to substitute into the parametric equations.\n    \n    Returns:\n        list or dict: Evaluated points at each parameter value.\n    \n    Example:\n        x, y, t = symbols('x y t')\n        param_eqs = {x: t**2, y: t + 1}\n        points = parametric_point_evaluation(param_eqs, [0, 1, 2])\n        print(points)  # Output: [{x: 0, y: 1}, {x: 1, y: 2}, {x: 4, y: 3}]\n    \"\"\"\n    results = []\n    for t_value in t_values:\n        point = {var: eq.subs('t', t_value) for var, eq in param_eqs.items()}\n        results.append(point)\n    return results", "def solve_linear_equations(A, b):\n    \"\"\"\n    Solve a system of linear equations Ax = b for x using NumPy.\n    Parameters:\n    - A (array-like): coefficient matrix.\n    - b (array-like): constant terms.\n    Returns:\n    - array: solution vector x.\n    Examples:\n    >>> solve_linear_equations([[1, 1], [1, -1]], [10, 2])\n    array([6., 4.])\n    \"\"\"\n    A = np.array(A)\n    b = np.array(b)\n    x = np.linalg.solve(A, b)\n    return x", "def point_on_line(line, point):\n    \"\"\"\n    Determines whether a given point lies on a specified line.\n    Parameters\n    ----------\n    line : tuple\n        Coefficients (m, c) of the line equation y = mx + c.\n    point : tuple\n        Coordinates of the point (x, y).\n    \n    Returns\n    -------\n    bool\n        True if the point lies on the line, False otherwise.\n    \n    Examples\n    --------\n    >>> point_on_line((2, 1), (1, 3))\n    True\n    \"\"\"\n    m, c = line\n    x, y = point\n    return y == m * x + c", "def reflection_point_across_line(line, point):\n    \"\"\"\n    Finds the reflection of a point across a given line.\n    \n    Parameters\n    ----------\n    line : tuple\n        Coefficients (m, c) of the line equation y = mx + c.\n    point : tuple\n        Coordinates of the point (x, y).\n    \n    Returns\n    -------\n    tuple\n        Coordinates (x', y') of the reflected point.\n    \n    Examples\n    --------\n    >>> reflection_point_across_line((1, 1), (2, 3))\n    (-1.0, 0.0)\n    \"\"\"\n    m, c = line\n    x, y = point\n    d = (x + (y - c) * m) / (1 + m**2)\n    x_ref = 2*d - x\n    y_ref = 2*d*m - y + 2*c\n    return (x_ref, y_ref)", "def compute_conic_properties(eq_type, standard_params):\n    \"\"\"\n    Compute geometric properties such as center, foci, vertices, depending on the conic type.\n    Parameters:\n    - eq_type (str): Type of conic ('circle', 'ellipse', 'parabola', 'hyperbola').\n    - standard_params (dict): Parameters obtained from the standard form conversion.\n    Returns:\n    - dict: Detailed conic properties.\n    Example:\n    >>> compute_conic_properties('circle', {'center': (3, -2), 'radius': 4})\n    {'center': (3, -2), 'foci': [(3, -2), (3, -2)], 'radius': 4}\n    \"\"\"\n    import math\n    if eq_type == 'circle':\n        center = standard_params['center']\n        radius = standard_params['radius']\n        return {'center': center, 'foci': [center, center], 'radius': radius}\n    elif eq_type == 'ellipse':\n        # Calculate foci, vertices based on semi-major/minor axes.\n        pass\n    elif eq_type == 'parabola':\n        # Vertex, focus calculation.\n        pass\n    elif eq_type == 'hyperbola':\n        # Center, foci, vertices, and asymptotes.\n        pass\n    return {}", "def rectangle_properties(length, width):\n    \"\"\"\n    Calculate various properties of a rectangle given its length and width.\n    Parameters:\n    - length (float): The length of the rectangle.\n    - width (float): The width of the rectangle.\n    Returns:\n    - dict: Dictionary containing the perimeter, area, and diagonal of the rectangle.\n    Examples:\n    >>> rectangle_properties(4, 3)\n    {'perimeter': 14, 'area': 12, 'diagonal': 5.0}\n    \"\"\"\n    import math\n    perimeter = 2 * (length + width)\n    area = length * width\n    diagonal = math.sqrt(length**2 + width**2)\n    return {'perimeter': perimeter, 'area': area, 'diagonal': diagonal}", "def circle_equation(cartesian_point_hk, radius):\n    \"\"\"\n    Provides the equation of a circle in Cartesian coordinates.\n    Parameters:\n    cartesian_point_hk (tuple): (h, k) the center of the circle in Cartesian coordinates\n    radius (float): the radius of the circle\n    Returns:\n    function: Function that calculates (x - h)² + (y - k)² - r² for given x, y\n    \"\"\"\n    h, k = cartesian_point_hk\n    def equation(x, y):\n        return (x - h)**2 + (y - k)**2 - radius**2\n    return equation", "def distance(x1, y1, x2, y2):\n    \"\"\"\n    Calculate the Euclidean distance between two points (x1, y1) and (x2, y2).\n    \n    Parameters:\n        x1, y1, x2, y2 (float): Coordinates of the two points.\n        \n    Returns:\n        float: The distance between the two points.\n    \"\"\"\n    return sp.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2)", "def area_of_circle(r):\n    \"\"\"\n    Calculates the area of a circle given its radius.\n    Parameters:\n    r (float): The radius of the circle.\n    Returns:\n    float: The area of the circle.\n    Examples:\n    >>> area_of_circle(1)\n    3.141592653589793\n    \"\"\"\n    return np.pi * r**2", "def is_collinear(points):\n    \"\"\"\n    Check if all points given are collinear.\n    \n    Parameters:\n    - points (list of tuples): List of points (x, y) to be checked.\n    \n    Returns:\n    - bool: True if all points are collinear, False otherwise.\n    Example:\n    >>> is_collinear([(1, 2), (2, 4), (3, 6)])\n    True\n    \"\"\"\n    if len(points) < 3:\n        return True  # Two points are always collinear\n    x1, y1 = points[0]\n    x2, y2 = points[1]\n    for (x, y) in points[2:]:\n        if (x2 - x1) * (y - y1) != (y2 - y1) * (x - x1):\n            return False\n    return True", "def transform_coordinates(points, transformation_matrix):\n    \"\"\"\n    Applies a transformation matrix to a list of point coordinates in 2D.\n    Parameters:\n    - points: List of tuples representing the point coordinates.\n    - transformation_matrix: A 2x2 numpy array representing the transformation matrix.\n    Returns:\n    - List of tuples: New coordinates after transformation.\n    Example:\n    >>> transform_coordinates([(1, 2)], np.array([[2, 0], [0, 2]]))\n    [(2, 4)]\n    \"\"\"\n    transformed = np.dot(transformation_matrix, np.array(points).T).T\n    return [tuple(point) for point in transformed]", "def scalar_multiply(vector, scalar):\n    \"\"\"\n    Multiplies a vector by a scalar.\n    Parameters:\n    vector (ndarray): A numpy array representing the vector.\n    scalar (float): The scalar value to multiply with the vector.\n    Returns:\n    ndarray: The scaled vector.\n    \"\"\"\n    return np.multiply(vector, scalar)", "def get_line_equation(p1, p2):\n    \"\"\"\n    Calculate the coefficients (A, B, C) of the line equation Ax + By + C = 0 passing through two points.\n    Parameters:\n    - p1 (tuple): coordinates of the first point.\n    - p2 (tuple): coordinates of the second point.\n    Returns:\n    - tuple: coefficients (A, B, C) of the line.\n    Examples:\n    >>> get_line_equation((1, 2), (3, 4))\n    (2, -2, 0)\n    \"\"\"\n    x1, y1 = p1\n    x2, y2 = p2\n    A = y2 - y1\n    B = x1 - x2\n    C = x2 * y1 - x1 * y2\n    return (A, B, C)", "class Point:\n    \"\"\"\n    This class represents a Point in 2D geometry.\n    \n    Attributes:\n        x (float): x-coordinate of the Point.\n        y (float): y-coordinate of the Point.\n    \"\"\"\n    \n    def __init__(self, x=0.0, y=0.0):\n        \"\"\"\n        The constructor for the Point class. It initializes the x and y coordinates of the point.\n        \n        Parameters:\n            x (float): The x-coordinate of the point.\n            y (float): The y-coordinate of the point.\n        \"\"\"\n        self.x = x\n        self.y = y\n    def __str__(self):\n        \"\"\"\n        This method returns the string representation of the Point.\n        \n        Returns:\n            str: A string in the format '(x, y)'.\n        \"\"\"\n        return '(' + str(self.x) + ', ' + str(self.y) + ')'\n    \n    def distance(self, other):\n        \"\"\"\n        This method calculates the Euclidean distance between this Point and another Point.\n        \n        Parameters:\n            other (Point): The other Point.\n            \n        Returns:\n            float: The Euclidean distance between the two points.\n        \"\"\"\n        return np.sqrt((self.x - other.x)**2 + (self.y - other.y)**2)", "def complete_square(expression, variable):\n    \"\"\"Complete the square for the given variable in a SymPy expression.\"\"\"\n    a = expression.coeff(variable**2)\n    b = expression.coeff(variable)\n    completed_square = a * (variable + b/(2*a))**2 - (b**2)/(4*a)\n    return completed_square", "def distance_point_plane(point, plane_coefficients):\n    \"\"\"\n    Calculate the shortest distance from a point to a plane in 3D.\n    \n    Parameters:\n    - point (array-like): The coordinates of the point.\n    - plane_coefficients (tuple): The coefficients (A, B, C, D) of the plane Ax + By + Cz + D = 0.\n    \n    Returns:\n    - float: The shortest distance from the point to the plane.\n    \n    Example:\n    >>> distance_point_plane([1, 2, 2], (1, 0, 0, -2))\n    1.0\n    \"\"\"\n    A, B, C, D = plane_coefficients\n    x, y, z = point\n    num = abs(A*x + B*y + C*z + D)\n    den = np.sqrt(A**2 + B**2 + C**2)\n    return num / den", "def distance_constraints_2d(points, distance):\n    \"\"\"\n    Formulate and solve a system of equations given distance constraints between multiple points in 2D.\n    Parameters:\n    - points (list): List of tuples/lists where each tuple/list contains the (x, y) coordinates.\n    - distance (float): The distance that each pair of points should satisfy.\n    Returns:\n    - list: A list of sympy Eq objects expressing the distance constraints.\n    Examples:\n    \"\"\"\n    x, y = symbols('x y', real=True)\n    generated_eqs = []\n    for p1, p2 in zip(points, points[1:] + [points[0]]):\n        eq = Eq((x - p1[0]) ** 2 + (y - p1[1]) ** 2, distance ** 2)\n        generated_eqs.append(eq)\n    return generated_eqs", "def solve_linear_system(coeff_matrix, const_vector):\n    \"\"\"\n    Solves a linear system of equations defined by a matrix of coefficients and a constant vector.\n    Parameters:\n    - coeff_matrix (list[list[float]]): Coefficient matrix where each row represents the coefficients of a linear equation.\n    - const_vector (list[float]): Constant terms for each equation.\n    Returns:\n    - ndarray: Solution to the system of equations.\n    Examples:\n    >>> solve_linear_system([[1, 1], [1, -1]], [5, 1])\n    array([3., 2.])\n    \"\"\"\n    coeff_matrix = np.array(coeff_matrix)\n    const_vector = np.array(const_vector)\n    return np.linalg.solve(coeff_matrix, const_vector)", "def find_perpendicular_slope(slope):\n    \"\"\"\n    Calculates the slope of a line perpendicular to a given slope.\n    \n    Parameters\n    ----------\n    slope : float\n        Slope of the given line.\n    \n    Returns\n    -------\n    float\n        Slope of the perpendicular line.\n    \n    Examples\n    --------\n    >>> find_perpendicular_slope(2)\n    -0.5\n    \"\"\"\n    return -1 / slope"], "Rectangles": ["def rectangle_area(length, width):\n    \"\"\"\n    Calculate the area of a rectangle.\n    Parameters:\n    length (float): the length of the rectangle.\n    width (float): the width of the rectangle.\n    Returns:\n    float: the calculated area of the rectangle.\n    \n    Example:\n    >>> rectangle_area(5, 3)\n    15\n    \"\"\"\n    return length * width", "def calculate_square_area(side_length):\n    \"\"\"\n    Calculate the area of a square given its side length.\n    Parameters:\n    - side_length (float): The length of a side of the square.\n    Returns:\n    - float: The area of the square.\n    Example:\n    >>> calculate_square_area(4)\n    16\n    \"\"\"\n    return calculate_rectangle_area(side_length, side_length)", "def rectangle_diagonal(length, width):\n    \"\"\"\n    Calculates the length of the diagonal of a rectangle using Pythagoras' theorem.\n    \n    Parameters:\n        length (float): The length of the rectangle.\n        width (float): The width of the rectangle.\n        \n    Returns:\n        float: The length of the diagonal.\n        \n    Examples:\n    >>> rectangle_diagonal(5, 4)\n    6.4031242374328485\n    \"\"\"\n    return math.sqrt(length**2 + width**2)", "def calculate_square_perimeter(side_length):\n    \"\"\"\n    Calculate the perimeter of a square given the side length.\n    Parameters:\n    side_length (float): The length of a side of the square.\n    Returns:\n    float: The perimeter of the square.\n    Examples:\n    >>> calculate_square_perimeter(4)\n    16\n    \"\"\"\n    return 4 * side_length", "def is_rectangle_by_sides(a, b, c, d):\n    \"\"\"\n    Checks if the given four sides can form a rectangle, based on the property that opposite sides must be equal.\n    \n    Parameters:\n        a, b, c, d (float): The lengths of the four sides.\n        \n    Returns:\n        bool: True if the sides can form a rectangle, False otherwise.\n        \n    Examples:\n    >>> is_rectangle_by_sides(5, 10, 5, 10)\n    True\n    >>> is_rectangle_by_sides(4, 5, 4, 6)\n    False\n    \"\"\"\n    return (a == c and b == d) or (a == b and c == d)", "def calculate_side_from_area(area, known_side):\n    \"\"\"\n    Calculate the unknown side length of a rectangle given the area and one known side length.\n    Parameters:\n    area (float): The area of the rectangle.\n    known_side (float): One known side length of the rectangle.\n    Returns:\n    float: The length of the unknown side.\n    Examples:\n    >>> calculate_side_from_area(20, 4)\n    5.0\n    \"\"\"\n    return area / known_side", "def rectangle_properties_from_coordinates(points):\n    \"\"\"\n    Determine if the given four points can form a rectangle and calculate its area and perimeter.\n    Parameters:\n    points (ndarray): Nx2 ndarray where N is number of points (should be 4) representing the coordinates of the vertices of the quadrilateral.\n    Returns:\n    dict: A dictionary with keys 'is_rectangle', 'area', and 'perimeter' or 'error' if inputs are not valid.\n    \n    Example:\n    >>> rectangle_properties_from_coordinatess(np.array([[0,0], [4,0], [4,3], [0,3]]))\n    {'is_rectangle': True, 'area': 12, 'perimeter': 14}\n    \"\"\"\n    if points.shape != (4, 2):\n        return {'error': 'Invalid input'}\n    \n    # Calculating distances\n    def distance(p1, p2):\n        return np.sqrt((p2[0] - p1[0])**2 + (p2[1] - p1[1])**2)\n    sides = [\n        distance(points[0], points[1]),\n        distance(points[1], points[2]),\n        distance(points[2], points[3]),\n        distance(points[3], points[0])\n    ]\n    diagonals = [\n        distance(points[0], points[2]),\n        distance(points[1], points[3])\n    ]\n    # Rectangle properties: Opposite sides are equal and diagonals are equal\n    if np.isclose(sides[0], sides[2]) and np.isclose(sides[1], sides[3]) and np.isclose(diagonals[0], diagonals[1]):\n        area = sides[0] * sides[1]\n        perimeter = 2 * (sides[0] + sides[1])\n        return {'is_rectangle': True, 'area': area, 'perimeter': perimeter}\n    else:\n        return {'is_rectangle': False}", "def solve_rectangle_dimensions(perimeter, area=None, aspect_ratio=None, use_integers=False):\n    \"\"\"\n    Solves for dimensions of a rectangle given constraints like perimeter, area or aspect ratio.\n    Parameters:\n    perimeter (float): The perimeter of the rectangle.\n    area (float, optional): The area of the rectangle.\n    aspect_ratio (float, optional): The ratio of length to width.\n    use_integers (bool, optional): If True, returns integer dimensions. Default is False.\n    Returns:\n    list of tuples: Possible (length, width) combinations.\n    \n    Examples:\n    >>> solve_rectangle_dimensions(20, area=24)\n    [(6, 4), (4, 6)]\n    >>> solve_rectangle_dimensions(20, aspect_ratio=1.5)\n    [(7.5, 5), (5, 7.5)]\n    \"\"\"\n    import sympy\n    \n    length, width = sympy.symbols('length width')\n    eq1 = sympy.Eq(2 * (length + width), perimeter)\n    \n    solutions = []\n    \n    if area is not None:\n        eq2 = sympy.Eq(length * width, area)\n        sol = sympy.solve((eq1, eq2), (length, width))\n        solutions.extend(sol)\n    \n    if aspect_ratio is not None:\n        eq2 = sympy.Eq(length / width, aspect_ratio)\n        sol = sympy.solve((eq1, eq2), (length, width))\n        solutions.extend(sol)\n    \n    if not solutions:\n        solutions = sympy.solve(eq1, (length, width))\n    \n    # Filter for integer solutions if requested\n    if use_integers:\n        solutions = [(l, w) for l, w in solutions if l.is_integer and w.is_integer]\n    return solutions", "def maximize_rectangle_area_given_perimeter(perimeter):\n    \"\"\"\n    Given a fixed perimeter, calculate the rectangle dimensions (length and width) \n    that maximize the area, assuming integer values. This often results in a square.\n    \n    Parameters:\n        perimeter (float): The fixed perimeter of the rectangle.\n    \n    Returns:\n        tuple: The dimensions (length, width) that maximize the area.\n    \n    Examples:\n        >>> maximize_rectangle_area_given_perimeter(20)\n        (5, 5)\n    \"\"\"\n    # For maximum area of a rectangle with given perimeter, length and width should be as equal as possible\n    # If perimeter is 20, max area is obtained when length = width = perimeter/4\n    optimal_side = perimeter / 4\n    if optimal_side.is_integer():\n        return (optimal_side, optimal_side)\n    else:\n        length = int(optimal_side)\n        width = perimeter // 2 - length\n        return (length, width)"], "Midpoint Formula": ["def compute_midpoint(point1, point2):\n    \"\"\"\n    Compute the midpoint between two points in n-dimensional space.\n    Parameters:\n    point1 (tuple or list): Coordinates of the first point.\n    point2 (tuple or list): Coordinates of the second point.\n    Returns:\n    tuple: Coordinates of the midpoint.\n    Examples:\n    >>> compute_midpoint((1, 2), (3, 4))\n    (2.0, 3.0)\n    >>> compute_midpoint([0, 0, 0], [6, 8, 10])\n    (3.0, 4.0, 5.0)\n    Raises:\n    ValueError: If the dimensions of the two points are not equal.\n    \"\"\"\n    # Ensure input is in the correct format and same dimension\n    if len(point1) != len(point2):\n        raise ValueError(\"Both points must have the same number of dimensions\")\n    # Calculate midpoint using tuple/list comprehension\n    midpoint = tuple((p1 + p2) / 2 for p1, p2 in zip(point1, point2))\n    \n    return midpoint", "def find_endpoint_from_midpoint(midpoint, known_point):\n    \"\"\"\n    Calculate the unknown endpoint of a line segment given the midpoint and the known endpoint.\n    Parameters:\n        midpoint (list or tuple of floats): Coordinates of the midpoint.\n        known_point (list or tuple of floats): Coordinates of the known endpoint.\n    Returns:\n        list: The coordinates of the unknown endpoint as a list of floats.\n    \n    Examples:\n        >>> find_endpoint_from_midpoint([1.0, 1.0], [0, 0])\n        [2.0, 2.0]\n        >>> find_endpoint_from_midpoint([4.0, 7.0, 9.0], [1, 3, 5])\n        [7.0, 11.0, 13.0]\n    \"\"\"\n    import numpy as np\n    midpoint, known_point = np.array(midpoint), np.array(known_point)\n    unknown_point = 2 * midpoint - known_point\n    return unknown_point.tolist()", "def find_endpoint(xm, ym, x1, y1):\n    \"\"\"\n    Find the unknown endpoint of a line segment given the midpoint and one known endpoint.\n    \n    Parameters:\n        xm (float): x-coordinate of the midpoint.\n        ym (float): y-coordinate of the midpoint.\n        x1 (float): x-coordinate of the known endpoint.\n        y1 (float): y-coordinate of the known endpoint.\n    \n    Returns:\n        tuple: (x2, y2) coordinates of the unknown endpoint.\n    \n    Example:\n        >>> find_endpoint(1.0, 1.0, 0, 0)\n        (2.0, 2.0)\n    \"\"\"\n    x2 = 2 * xm - x1\n    y2 = 2 * ym - y1\n    return (x2, y2)", "def reconstruct_points_from_midpoint(midpoint, proportion, n_dimensions):\n    \"\"\"\n    Reconstructs two points given the midpoint and the proportion of the distances of the two original points from the midpoint.\n    \n    Parameters:\n    - midpoint (array-like): Coordinates of the midpoint. Must be an iterable of numerical values.\n    - proportion (float): The scale factor or proportion according to which the original points were divided by the midpoint.\n    - n_dimensions (int): The number of dimensions of the space the points belong to.\n    \n    Returns:\n    - tuple of numpy.ndarrays: The coordinates of the two original points.\n    Example:\n    >>> reconstruct_points_from_midpoint([2.5, 3.5, 4.5], 1, 3)\n    (array([1., 2., 3.]), array([4., 5., 6.]))\n    \"\"\"\n    midpoint = np.array(midpoint)\n    # Since it's proportionate and equidistant, the vector from midpoint to actual points is timely scaled\n    vector = np.array([proportion] * n_dimensions)\n    point1 = midpoint - vector / 2\n    point2 = midpoint + vector / 2\n    return (point1, point2)"], "Distance Formula": ["def complex_plane_distance(point1: complex, point2: complex) -> float:\n    \"\"\"\n    Calculate the Euclidean distance between two points in the complex plane.\n    \n    Parameters:\n    - point1 (complex): The first complex number representing a point in a complex plane.\n    - point2 (complex): The second complex number representing a point in a complex plane.\n    \n    Returns:\n    - float: The distance between the two points in the complex plane.\n    \n    Example:\n    >>> complex_plane_distance(complex(3, 4), complex(0, 0))\n    5.0\n    >>> complex_plane_distance(complex(1, 2), complex(1, -1))\n    3.0\n    \"\"\"\n    return abs(point1 - point2)", "def distance_formula_symbolic(point1, point2):\n    \"\"\"\n    Construct a symbolic distance formula between two points, supporting symbolic and numerical computation.\n    Parameters:\n    - point1: array-like, the coordinates of the first point, can contain symbols or numbers\n    - point2: array-like, the coordinates of the second point, can contain symbols or numbers\n    Returns:\n    - distance_expr: sympy expression, the symbolic expression for the distance between point1 and point2\n    Examples:\n    - Using numerical coordinates:\n    >>> distance_formula_symbolic((1, 2), (4, 6))\n    sqrt(13)\n    \n    - Using symbolic coordinates:\n    >>> x, y = symbols('x y')\n    >>> distance_formula_symbolic((x, 0), (0, y))\n    sqrt(x**2 + y**2)\n    \"\"\"\n    if len(point1) != len(point2):\n        raise ValueError(\"Points must have the same dimensions\")\n    distance_expr = sqrt(sum((p1 - p2)**2 for p1, p2 in zip(point1, point2)))\n    return simplify(distance_expr)", "def pythagorean_theorem(leg_a=None, leg_b=None, hypotenuse=None):\n    \"\"\"\n    Calculate the missing side of a right triangle using the Pythagorean theorem.\n    Parameters:\n    -----------\n    leg_a : float, optional\n        The length of one leg of the triangle.\n    leg_b : float, optional\n        The length of the other leg of the triangle.\n    hypotenuse : float, optional\n        The length of the hypotenuse of the triangle.\n    \n    Returns:\n    --------\n    float\n        The length of the missing side of the triangle.\n    \n    Examples:\n    ---------\n    >>> pythagorean_theorem(leg_a=3, leg_b=4)\n    5.0\n    >>> pythagorean_theorem(hypotenuse=5, leg_b=4)\n    3.0\n    Raises:\n    -------\n    ValueError\n        If insufficient data is provided or too many sides are known.\n    \"\"\"\n    if hypotenuse is None and leg_a is not None and leg_b is not None:\n        return math.sqrt(leg_a**2 + leg_b**2)\n    elif leg_a is None and hypotenuse is not None and leg_b is not None:\n        return math.sqrt(hypotenuse**2 - leg_b**2)\n    elif leg_b is None and hypotenuse is not None and leg_a is not None:\n        return math.sqrt(hypotenuse**2 - leg_a**2)\n    else:\n        raise ValueError(\"Invalid input: provide exactly one missing side.\")", "def calculate_median_length(side_a, side_b):\n    \"\"\"\n    Calculate the length of the median to the hypotenuse of a right triangle, based on the other two sides.\n    The median on the hypotenuse divides it into two equal segments, each half the length of the hypotenuse.\n    \n    Parameters:\n    - side_a (float): Length of one side of the right triangle.\n    - side_b (float): Length of the other side of the right triangle.\n    \n    Returns:\n    - float: The length of the median to the hypotenuse.\n    \n    Example:\n    >>> calculate_median_length(3, 4)\n    2.5\n    \"\"\"\n    hypotenuse = math.sqrt(side_a**2 + side_b**2)\n    return hypotenuse / 2"], "Area Calculation": ["def area_triangle(base, height):\n    \"\"\"\n    Calculate area of a triangle given its base and height.\n    Parameters:\n    base (float): the length of the base of the triangle.\n    height (float): the height of the triangle perpendicular to the base.\n    Returns:\n    float: the area of the triangle\n    \"\"\"\n    return 0.5 * base * height", "def area_circle(radius):\n    \"\"\"\n    Calculate the area of a circle given its radius.\n    Parameters:\n    radius (float): the radius of the circle.\n    Returns:\n    float: the area of the circle calculated as pi*r^2\n    \"\"\"\n    import math\n    return math.pi * radius ** 2", "def rectangle_area(length, width):\n    \"\"\"\n    Calculate the area of a rectangle from length and width.\n    Parameters:\n    length (float): The length of the rectangle.\n    width (float): The width of the rectangle.\n    Returns:\n    float: The area of the rectangle.\n    \n    Examples:\n    >>> rectangle_area(4, 3)\n    12\n    \"\"\"\n    return length * width", "def triangle_area_by_sides(a, b, c):\n    \"\"\"\n    Calculate the area of a triangle given the lengths of its sides using Heron's formula.\n    Parameters:\n    - a, b, c (float): Lengths of the sides of the triangle.\n    Returns:\n    - float: The area of the triangle.\n    Examples:\n    >>> triangle_area_by_sides(3, 4, 5)\n    6.0\n    \"\"\"\n    s = (a + b + c) / 2\n    area = sqrt(s * (s - a) * (s - b) * (s - c))\n    return area", "def area_sector(radius, angle_deg):\n    \"\"\"\n    Calculate the area of a sector of a circle given its radius and central angle in degrees.\n    Parameters:\n    - radius (float): The radius of the circle.\n    - angle_deg (float): The angle of the sector in degrees.\n    \n    Returns:\n    - float: The area of the sector.\n    \n    Example:\n    >>> area_sector(4, 90)\n    12.566370614359172\n    \"\"\"\n    angle_rad = math.radians(angle_deg)\n    return 0.5 * radius**2 * angle_rad", "def area_polygon(vertices):\n    \"\"\"\n    Calculate the area of a simple polygon given its vertices.\n    Parameters:\n        vertices (list of tuples): List of (x, y) tuples, each representing a vertex of the polygon.\n    Returns:\n        float: The area of the polygon.\n    Examples:\n    >>> area_polygon([(0, 0), (4, 0), (4, 4), (0, 4)])  # Square with side 4\n    16.0\n    \"\"\"\n    x = np.array([vertex[0] for vertex in vertices])\n    y = np.array([vertex[1] for vertex in vertices])\n    return 0.5 * np.abs(np.dot(x, np.roll(y, 1)) - np.dot(y, np.roll(x, 1)))", "def area_square(side_length):\n    \"\"\"\n    Calculates the area of a square.\n    Parameters:\n        side_length (float): The length of the side of the square.\n    Returns:\n        float: The area of the square.\n    Example:\n        >>> area_square(4)\n        16\n    \"\"\"\n    return side_length ** 2", "def triangle_area_by_coordinates(x1, y1, x2, y2, x3, y3):\n    \"\"\"\n    Calculate the area of a triangle given the coordinates of its vertices.\n    Parameters:\n    x1, y1 (float): Coordinates of the first vertex.\n    x2, y2 (float): Coordinates of the second vertex.\n    x3, y3 (float): Coordinates of the third vertex.\n    Returns:\n    float: The absolute value of the area of the triangle.\n    Examples:\n    >>> triangle_area_by_coordinates(0, 0, 4, 0, 2, 3)\n    6.0\n    \"\"\"\n    return abs(x1*(y2-y3) + x2*(y3-y1) + x3*(y1-y2)) / 2", "def calculate_hypotenuse_length(a, b):\n    \"\"\"\n    Calculate the length of the hypotenuse of a right triangle given the lengths of the other two sides using the Pythagorean theorem.\n    Parameters:\n    - a (float or int): Length of side a of the triangle.\n    - b (float or int): Length of side b of the sequence.\n    Returns:\n    - float: Length of the hypotenuse.\n    \n    Examples:\n    >>> calculate_hypotenuse_length(3, 4)\n    5.0\n    \"\"\"\n    return math.sqrt(a**2 + b**2)", "def distance_between_points(x1, y1, x2, y2):\n    \"\"\"\n    Calculate the Euclidean distance between two points in the Cartesian plane.\n    Parameters:\n    x1, y1 (float): Coordinates of the first point.\n    x2, y2 (float): Coordinates of the second point.\n    Returns:\n    float: The distance between the points.\n    Examples:\n    >>> distance_between_points(0, 0, 3, 4)\n    5.0\n    \"\"\"\n    return math.sqrt((x2 - x1)**2 + (y2 - y1)**2)", "def calculate_area(shape: str, *args) -> float:\n    \"\"\"\n    Function to calculate the area of a basic geometric shape.\n    \n    Parameters:\n    shape (str): The name of the shape. Possible values: 'square', 'rectangle', 'circle', 'triangle'.\n    *args: The dimensions of the shape. For 'square' it's the side length, for 'rectangle' it's the length and breadth, for 'circle' it's the radius, for 'triangle' it's the base and height.\n    \n    Returns:\n    float: The area of the shape according to the specified dimensions.\n    \n    Examples:\n    >>> calculate_area('square', 2)\n    4\n    >>> calculate_area('rectangle', 2, 3)\n    6\n    >>> calculate_area('circle', 2)\n    ~12.57\n    >>> calculate_area('triangle', 2, 3)\n    3\n    \"\"\"\n    if shape.lower() == 'square':\n        return args[0]**2\n    elif shape.lower() == 'rectangle':\n        return args[0]*args[1]\n    elif shape.lower() == 'circle':\n        return pi*args[0]**2\n    elif shape.lower() == 'triangle':\n        return 0.5*args[0]*args[1]\n    else:\n        raise ValueError(\"Unknown shape. Only 'square', 'rectangle', 'circle', and 'triangle' are valid shapes.\")", "def trapezoid_area(base1: float, base2: float, height: float) -> float:\n    \"\"\"\n    Calculate the area of a trapezoid given two bases and the height.\n    Parameters:\n    base1 (float): The length of the first base.\n    base2 (float): The length of the second base.\n    height (float): The height of the trapezoid (distance between the two bases).\n    Returns:\n    float: The area of the trapezoid.\n    Examples:\n    >>> trapezoid_area(10, 8, 5)\n    45.0\n    \"\"\"\n    return 0.5 * (base1 + base2) * height", "def area_rhombus_by_diagonals(d1, d2):\n    \"\"\"Calculate the area of a rhombus given the lengths of its diagonals.\n    \n    Parameters:\n    - d1 (float): Diagonal 1 length.\n    - d2 (float): Diagonal 2 length.\n    \n    Returns:\n    - float: The calculated area of the rhombus.\n    \n    Example:\n    >>> area_rhombus_by_diagonals(4, 5)\n    10.0\n    \"\"\"\n    return d1 * d2 / 2", "def triangle_area_by_angle_side(angle, side1, side2):\n    \"\"\"\n    Calculate the area of a triangle given an angle and two sides enclosing the angle.\n    \n    Parameters:\n    - angle (float): Angle in radians between the two sides.\n    - side1 (float), side2 (float): Lengths of the sides that enclose the angle.\n    \n    Returns:\n    - float: The area of the triangle.\n    \n    Example:\n    >>> triangle_area_by_angle_side(math.pi / 2, 3, 4)  # Right angle\n    6.0\n    \"\"\"\n    return 0.5 * side1 * side2 * math.sin(angle)", "def polygon_area_sides(n_sides, side_length):\n    \"\"\"\n    Calculate the area of a regular polygon using the number of sides and the side length.\n    Parameters:\n    n_sides (int): The number of sides of the regular polygon.\n    side_length (float): The length of each side.\n    Returns:\n    float: The area of the polygon.\n    \n    Example:\n    >>> polygon_area_sides(4, 5)  # Square\n    25.0\n    \"\"\"\n    if n_sides < 3:\n        raise ValueError(\"A polygon must have at least three sides.\")\n    perimeter = n_sides * side_length\n    apothem = side_length / (2 * math.tan(math.pi / n_sides))\n    return 0.5 * perimeter * apothem", "def calculate_composite_area(*args):\n    \"\"\"\n    Calculate the total area of multiple individual areas passed as arguments.\n    Parameters:\n    - args (float): Individual areas to be summed.\n    Returns:\n    - float: The total area of all individual areas combined.\n    Examples:\n    >>> calculate_composite_area(10, 15, 5)\n    30\n    \"\"\"\n    return sum(args)", "def square_area(side_length):\n    \"\"\"\n    The function takes the side length of a square as input \n    and returns its area.\n    \"\"\"\n    return side_length**2", "def calculate_parallelogram_area(base, height):\n    \"\"\"\n    Calculate the area of a parallelogram given the base and height.\n    Parameters:\n    - base (float): The length of the base of the parallelogram.\n    - height (float): The height of the parallelogram measured perpendicular to the base.\n    \n    Returns:\n    - float: The area of the parallelogram.\n    Examples:\n    >>> calculate_parallelogram_area(5, 3)\n    15.0\n    \"\"\"\n    return base * height", "def composite_area(*args):\n    \"\"\"\n    The function takes the areas of several shapes as input \n    and returns the total area.\n    \"\"\"\n    return sum(args)", "def law_of_cosines(a, b, angle_degrees):\n    \"\"\"\n    Calculate the third side of a triangle using the Law of Cosines.\n    Parameters:\n    a (float): Length of the first side.\n    b (float): Length of the second side.\n    angle_degrees (float): Angle between sides a and b in degrees.\n    Returns:\n    float: Length of the third side.\n    Example:\n    >>> law_of_cosines(5, 5, 90)\n    7.0710678118654755\n    \"\"\"\n    angle_radians = math.radians(angle_degrees)\n    c = math.sqrt(a**2 + b**2 - 2 * a * b * math.cos(angle_radians))\n    return c", "def rectangle_area(length, width):\n    \"\"\"\n    The function takes the length and width of a rectangle as input \n    and returns its area.\n    \"\"\"\n    return length * width", "def triangle_side_lengths(angle, *dimensions):\n    \"\"\"\n    Calculate the length of sides in common triangle types (right, 30-60-90, 45-45-90).\n    Parameters\n    ----------\n    angle : int\n        Internal angle in degrees of the triangle.\n    dimensions : tuple\n        Lengths of known sides.\n    Returns\n    -------\n    tuple\n        Lengths of all sides of the triangle.\n    Examples\n    --------\n    >>> triangle_side_lengths(90, 3, 4)\n    (3, 4, 5)\n    >>> triangle_side_lengths(30, 5)\n    (5, 5*sqrt(3), 10)\n    >>> triangle_side_lengths(45, 5)\n    (5, 5, 5*sqrt(2))\n    \"\"\"\n    \n    import sympy as sp\n    def right_triangle_sides(a, b):\n        # Use the Pythagorean theorem\n        return a, b, sp.sqrt(a**2 + b**2)\n    def special_triangle_sides(angle, a):\n        if angle == 30:\n            return a, a * sp.sqrt(3), 2*a\n        elif angle == 45:\n            return a, a, a * sp.sqrt(2)\n        else:\n            raise ValueError('This tool only covers 30-60-90 and 45-45-90 triangles.')\n    if angle == 90:\n        return right_triangle_sides(*dimensions)\n    else:\n        return special_triangle_sides(angle, *dimensions)", "def circle_area(radius):\n    \"\"\"\n    The function takes the radius of a circle as input \n    and returns its area.\n    \"\"\"\n    return math.pi * (radius**2)", "def rectangle_area_dynamic(L, W):\n    \"\"\"\n    Calculate the area of a rectangle while allowing the sides, L and W, to be expressions.\n    \n    Parameters:\n    - L, W (expressions or floats): The expressions or numbers representing the length and width.\n    \n    Returns:\n    - Expression or float: The calculated area.\n    \n    Example:\n    >>> from sympy import symbols, Eq, solve\n    >>> l = symbols('l')\n    >>> rectangle_area_dynamic(l, l+2)\n    l*(l + 2)\n    \"\"\"\n    from sympy import simplify\n    return simplify(L * W)", "def composite_area_calculations(*areas, subtract=False):\n    \"\"\"\n    Compute the total or net area of multiple individual areas, supporting both sum and subtraction operations.\n    Parameters:\n        areas (list of floats): A list of individual areas.\n        subtract (bool): If True, subtracts areas instead of summing them.\n    Returns:\n        float: Total or net area after performing the sum or subtraction.\n    Example:\n        >>> composite_area_calculations(10, 5, 15)\n        30\n        >>> composite_area_calculations(10, 3, subtract=True)\n        7\n    \"\"\"\n    if subtract:\n        return areas[0] - sum(areas[1:])\n    else:\n        return sum(areas)", "def line_equation_from_points(x1, y1, x2, y2):\n    \"\"\"\n    Calculate the slope and y-intercept of the line passing through two points.\n    Parameters:\n    x1, y1 (float): Coordinates of the first point.\n    x2, y2 (float): Coordinates of the second point.\n    Returns:\n    tuple: Slope and y-intercept of the line.\n    Examples:\n    >>> line_equation_from_points(0, 0, 2, 2)\n    (1.0, 0.0)\n    >>> line_equation_from_points(1, 2, 3, 8)\n    (3.0, -1.0)\n    \"\"\"\n    if x2 != x1:\n        slope = (y2 - y1) / (x2 - x1)\n        intercept = y1 - slope * x1\n        return slope, intercept\n    else:\n        return float('inf'), x1", "def pythagorean_triplet(a, b, c):\n    \"\"\"\n    Check if the three given lengths form a Pythagorean triplet.\n    Parameters\n    ----------\n    a : float\n        Length of the first side.\n    b : float\n        Length of the second side.\n    c : float\n        Length of the third side (hypotenuse).\n    Returns\n    -------\n    bool\n        `True` if the lengths form a Pythagorean triplet and `False` otherwise\n    \"\"\"\n    return abs((a ** 2) + (b ** 2) - (c ** 2)) < 0.001", "class CircleBasedCalculator:\n    \"\"\"\n    A class to calculate various geometrical properties and areas related to circles,\n    including full circles, sectors, and annuli (regions between two concentric circles).\n    \"\"\"\n    @staticmethod\n    def area_of_circle(radius):\n        \"\"\"\n        Calculate the area of a circle using the formula πr².\n        Parameters:\n            radius (float): The radius of the circle.\n        Returns:\n            float: The area of the circle.\n        Example:\n            >>> CircleBasedCalculator.area_of_circle(5)\n            78.53981633974483\n        \"\"\"\n        return math.pi * radius ** 2\n    @staticmethod\n    def area_of_sector(radius, angle_in_degrees):\n        \"\"\"\n        Calculate the area of a sector given the central angle and radius.\n        Parameters:\n            radius (float): The radius of the circle from which the sector is part.\n            angle_in_degrees (float): The angle of the sector in degrees.\n        Returns:\n            float: The area of the sector.\n        Example:\n            >>> CircleBasedCalculator.area_of_sector(5, 90)\n            19.634954084936208\n        \"\"\"\n        return (angle_in_degrees / 360) * math.pi * radius ** 2\n    @staticmethod\n    def area_of_annulus(outer_radius, inner_radius):\n        \"\"\"\n        Calculate the area of an annulus (the region between two concentric circles).\n        Parameters:\n            outer_radius (float): Radius of the outer circle.\n            inner_radius (float): Radius of the inner circle.\n        Returns:\n            float: The area of the annulus.\n        Example:\n            >>> CircleBasedCalculator.area_of_annulus(5, 3)\n            50.26548245743669\n        \"\"\"\n        return math.pi * (outer_radius ** 2 - inner_radius ** 2)\n    @staticmethod\n    def diameter_to_radius(diameter):\n        \"\"\"\n        Convert diameter to radius.\n        Parameters:\n            diameter (float): The diameter of the circle.\n        Returns:\n            float: The radius of the circle.\n        Example:\n            >>> CircleBasedCalculator.diameter_to_radius(10)\n            5.0\n        \"\"\"\n        return diameter / 2", "def centroid_polygon(vertices: List[Tuple[float, float]]) -> Tuple[float, float]:\n    \"\"\"\n    Calculates the centroid (geometric center) of a polygon given its vertices.\n    Parameters:\n    - vertices (List[Tuple[float, float]]): Coordinates of the vertices of the polygon.\n    Returns:\n    - Tuple[float, float]: The coordinates of the centroid.\n    Examples:\n    >>> print(centroid_polygon([(0, 0), (4, 0), (4, 4), (0, 4)]))\n    (2.0, 2.0)\n    \"\"\"\n    x_coordinates, y_coordinates = zip(*vertices)\n    num_vertices = len(vertices)\n    centroid_x = sum(x_coordinates) / num_vertices\n    centroid_y = sum(y_coordinates) / num_vertices\n    return (centroid_x, centroid_y)", "def TriangleAreaCalculator(base=None, height=None, vertices=None, sides=None):\n    \"\"\"\n    Calculate the area of a triangle given base and height, vertices, or side lengths.\n    Parameters:\n    - base (float): The base of the triangle.\n    - height (float): The height of the triangle perpendicular to the base.\n    - vertices (list of tuples): List of coordinates for the triangle's vertices as (x, y).\n    - sides (tuple): The lengths of the three sides of the triangle.\n    Returns:\n    - float: The area of the triangle.\n    Examples:\n    - TriangleAreaCalculator(base=5, height=3)\n    - TriangleAreaCalculator(vertices=[(0, 0), (5, 0), (0, 3)])\n    - TriangleAreaCalculator(sides=(3, 4, 5))\n    \"\"\"\n    import math\n    if base is not None and height is not None:\n        # Simple calculation from base and height\n        return 0.5 * base * height\n    elif vertices is not None:\n        # Calculate area from vertices using determinant (shoelace formula)\n        x1, y1 = vertices[0]\n        x2, y2 = vertices[1]\n        x3, y3 = vertices[2]\n        return 0.5 * abs(x1*(y2-y3) + x2*(y3-y1) + x3*(y1-y2))\n    elif sides is not None:\n        # Using Heron's formula to find area when sides are known\n        a, b, c = sides\n        s = 0.5 * sum(sides)\n        area = math.sqrt(s * (s - a) * (s - b) * (s - c))\n        return area\n    else:\n        raise ValueError(\"Insufficient information to calculate area.\")", "def find_line_intersection(p1, p2, p3, p4):\n    \"\"\"\n    Calculate the intersection point of two lines defined by two pairs of points.\n    Parameters:\n    p1, p2 (tuple): (x, y) coordinates for the first and the second point of the first line.\n    p3, p4 (tuple): (x, y) coordinates for the third and the fourth point of the second line.\n    Returns:\n    tuple or str: (x, y) coordinates of the intersection point, or 'No unique intersection' if lines are collinear or do not intersect.\n    Examples:\n    >>> find_line_intersection((0, 0), (1, 1), (1, 0), (0, 1))\n    (0.5, 0.5)\n    >>> find_line_intersection((0, 0), (1, 1), (2, 2), (3, 3))\n    'No unique intersection or lines are collinear'\n    \"\"\"\n    x1, y1 = p1\n    x2, y2 = p2\n    x3, y3 = p3\n    x4, y4 = p4\n    \n    # Calculate the determinants\n    denom = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4)\n    if denom == 0:\n        return 'No unique intersection or lines are collinear'\n    \n    px = ((x1 * y2 - y1 * x2) * (x3 - x4) - (x1 - x2) * (x3 * y4 - y3 * x4)) / denom\n    py = ((x1 * y2 - y1 * x2) * (y3 - y4) - (y1 - y2) * (x3 * y4 - y3 * x4)) / denom\n    return (px, py)", "def circle_diameter(radius):\n    \"\"\"\n    The function takes radius of a circle as input \n    and returns its diameter.\n    \"\"\"\n    return 2 * radius", "def derive_side_lengths(shape, **kwargs):\n    \"\"\"\n    Derive side lengths using geometric and trigonometric relations for various shapes.\n    \n    Parameters\n    ----------\n    shape : str\n        Type of geometric shape ('triangle_cosine', 'polygon_diagonal')\n    kwargs: various\n        Known lengths, angles, and other relevant properties depending on the shape.\n    \n    Returns\n    -------\n    float\n        The derived side length or lengths depending on the calculation.\n    \n    Examples\n    --------\n    >>> derive_side_lengths('triangle_cosine', a=5, b=5, angle=60)\n    5.0\n    >>> derive_side_lengths('polygon_diagonal', side=4, n_sides=4)  # Diagonal of a square\n    5.656854249492381\n    \"\"\"\n    if shape == 'triangle_cosine':\n        a, b, angle = kwargs['a'], kwargs['b'], kwargs['angle']\n        angle_rad = np.radians(angle)\n        return sqrt(a**2 + b**2 - 2*a*b*np.cos(angle_rad))\n    elif shape == 'polygon_diagonal':\n        side, n_sides = kwargs['side'], kwargs['n_sides']\n        if n_sides == 4:  # square or rectangle logic\n            return sqrt(2) * side\n        else:\n            raise ValueError(\"Diagonal calculation for this polygon not supported\")"], "Triangles": ["def triangle_area(base, height):\n    \"\"\"\n    Calculate the area of a triangle using base and height.\n    \n    Parameters:\n    base (float): Base of the triangle.\n    height (float): Height of the triangle.\n    Returns:\n    float: Area of the triangle.\n    \"\"\"\n    return 0.5 * base * height", "def herons_formula(a, b, c):\n    \"\"\"\n    Calculate the area of a triangle using Heron's formula given the sides.\n    \n    Parameters:\n    a, b, c (float): Sides of the triangle.\n    \n    Returns:\n    float: Area of the triangle.\n    \"\"\"\n    s = (a + b + c) / 2\n    area = math.sqrt(s * (s - a) * (s - b) * (s - c))\n    return area", "def triangle_perimeter(a, b, c):\n    \"\"\"\n    Calculate the perimeter of a triangle with sides a, b, and c.\n    \n    Parameters:\n        a (float): The length of side a.\n        b (float): The length of side b.\n        c (float): The length of side c.\n    \n    Returns:\n        float: The perimeter of the triangle.\n    \n    Example:\n        >>> triangle_perimeter(3, 4, 5)\n        12.0\n    \"\"\"\n    return a + b + c", "def special_triangle_side_lengths(angle_type, one_length):\n    \"\"\"\n    Calculate the side lengths of special right triangles (45-45-90, 30-60-90) based on one known side length.\n    \n    Parameters:\n    angle_type (str): Type of special triangle ('45-45-90' or '30-60-90').\n    one_length (float): Length of one side, which can be leg or hypotenuse, depending on the type.\n    \n    Returns:\n    tuple: Lengths of the sides of the triangle.\n    \"\"\"\n    if angle_type == '45-45-90':\n        # In a 45-45-90 triangle, the legs are equal, and the hypotenuse is leg * sqrt(2)\n        return (one_length, one_length, one_length * math.sqrt(2))\n    elif angle_type == '30-60-90':\n        # In a 30-60-90 triangle, the shorter leg (opposite 30°) is one_length if given,\n        # the hypotenuse is 2 * one_length, and the longer leg (opposite 60°) is one_length * sqrt(3)\n        return (one_length, one_length * math.sqrt(3), 2 * one_length)\n    raise ValueError(\"Unsupported triangle type\")", "def triangle_side_using_law_of_cosines(a, b, angle_C):\n    \"\"\"\n    Calculate the side 'c' of a triangle using the Law of Cosines.\n    Parameters:\n    a (float): length of side a\n    b (float): length of side b\n    angle_C (float): angle C in degrees between sides a and b\n    Returns:\n    float: the length of side c\n    Examples:\n    >>> triangle_side_using_law_of_cosines(5, 7, 45)\n    7.13\n    \"\"\"\n    angle_C_radians = math.radians(angle_C)\n    c = math.sqrt(a ** 2 + b ** 2 - 2 * a * b * math.cos(angle_C_radians))\n    return round(c, 2)", "def is_valid_triangle(a, b, c):\n    \"\"\"\n    Determines if three side lengths can form a valid triangle based on the Triangle Inequality Theorem.\n    Parameters:\n        a (float): The length of the first side.\n        b (float): The length of the second with the limil side.\n        c (float): The length of the third side.\n    Returns:\n        bool: True if the side lengths can form a triangle, False otherwise.\n    Examples:\n    >>> is_valid_triangle(3, 4, 5)\n    True\n    >>> is_valid_triangle(1, 10, 12)\n    False\n    \"\"\"\n    return (a+b > c) and (a+c > b) and (b+c > a)", "def calculate_triangle_area(base=None, height=None, side=None):\n    \"\"\"\n    Calculate the area of a triangle using base and height or by specifying the sides using Heron's formula for equilateral triangles.\n    \n    Parameters:\n    base (float, optional): The base of the triangle.\n    height (float, optional): The height of the triangle.\n    side (float, optional): The length of a side if the triangle is equilateral.\n    Returns:\n    float: The area of the triangle.\n    Example:\n    >>> calculate_triangle_area(base=10, height=5)\n    25.0\n    >>> calculate_triangle_area(side=8)  # Equilateral triangle\n    13.856\n    \"\"\"\n    if base is not None and height is not None:\n        return 0.5 * base * height\n    elif side is not None:\n        # Area of an equilateral triangle: sqrt(3)/4 * side^2\n        return (math.sqrt(3) / 4) * (side**2)\n    else:\n        raise ValueError(\"Invalid inputs given. Provide either base and height for a regular triangle or side for an equilateral triangle.\")", "def calculate_third_angle(angle1, angle2):\n    \"\"\"\n    Calculate the third angle of a triangle given two angles.\n    Parameters:\n    angle1 (float): The first angle of the triangle in degrees.\n    angle2 (float): The second angle of the triangle in degrees.\n    Returns:\n    float: The third angle of the triangle in degrees.\n    Example:\n    >>> calculate_third_angle(60, 50)\n    70.0\n    \"\"\"\n    return 180 - angle1 - angle2", "def valid_third_side_range(a, b):\n    \"\"\"\n    Determines the valid range for potential third side of a triangle given two sides, based on the Triangle Inequality Theorem.\n    \n    Parameters:\n        a (float or int): The length of the first side.\n        b (float or int): The length of the second side.\n        \n    Returns:\n        tuple: A tuple containing the minimum and maximum values for the third side that can still form a triangle.\n    \n    Examples:\n        >>> valid_third_side_range(8, 5)\n        (3, 13)\n        >>> valid_third_side_range(15, 10)\n        (6, 24)\n    \"\"\"\n    return (abs(a - b) + 1, a + b - 1)", "def calculate_isosceles_triangle_altitude(base: float, side_length: float) -> float:\n    \"\"\"\n    Calculate the altitude of an isosceles triangle.\n    Parameters\n    ----------\n    base : float\n        The length of the base of the isosceles triangle.\n    side_length : float\n        The length of the other two equal sides of the isosceles triangle.\n    Returns\n    -------\n    float\n        The length of the altitude from the vertex opposite the base to the base.\n    Examples\n    --------\n    >>> calculate_isosceles_triangle_altitude(8, 5)\n    4.358898943540674\n    \"\"\"\n    from math import sqrt\n    if base / 2 >= side_length:\n        raise ValueError(\"Invalid dimensions for an isosceles triangle.\")\n    altitude = sqrt(side_length**2 - (base / 2)**2)\n    return altitude", "def midpoint(x1, y1, x2, y2):\n    \"\"\"\n    Calculate the midpoint of a segment given the coordinates of its endpoints.\n    \n    Parameters:\n        x1, y1 (float): Coordinates of the first endpoint.\n        x2, y2 (float): Coordinates of the second endpoint.\n    \n    Returns:\n        tuple: The coordinates of the midpoint.\n    \n    Examples:\n        >>> midpoint(1, 1, 4, 5)\n        (2.5, 3.0)\n    \"\"\"\n    return ((x1 + x2) / 2, (y1 + y2) / 2)", "def isosceles_right_triangle_side_length(hypotenuse: float = None, leg: float = None) -> float:\n    \"\"\"\n    Calculate the length of the legs or the hypotenuse of an isosceles right triangle.\n    Parameters\n    ----------\n    hypotenuse : float, optional\n        The length of the hypotenuse of the triangle. If provided, `leg` must be None.\n    leg : float, optional\n        The length of one of the equal legs of the triangle. If provided, `hypotenuse` must be None.\n    Returns\n    -------\n    float\n        The length of the other component (leg if hypotenuse is given, hypotenuse if leg is given).\n    Examples\n    --------\n    >>> isosceles_right_triangle_side_length(leg=5)\n    7.0710678118654755\n    >>> isosceles_right_triangle_side_length(hypotenuse=7.0710678118654755)\n    5.0\n    \"\"\"\n    from math import sqrt\n    if hypotenuse is not None and leg is None:\n        return hypotenuse / sqrt(2)\n    elif leg is not None and hypotenuse is None:\n        return leg * sqrt(2)\n    else:\n        raise ValueError(\"Either hypotenuse or leg must be provided, but not both.\")", "def identify_triangle(a, b, c):\n    \"\"\"\n    Identify the type of triangle based on given side lengths.\n    Parameters:\n        a (float): length of side a\n        b (float): length of side b\n        c (float): length of side c\n    Returns:\n        str: Type of triangle (\"Right\", \"Acute\", \"Obtuse\", or \"Not a triangle\")\n    Examples:\n    >>> identify_triangle(3, 4, 5)\n    'Right'\n    >>> identify_triangle(7, 10, 5)\n    'Acute'\n    \"\"\"\n    import math\n    \n    # First, check if a valid triangle can be formed\n    if a + b <= c or a + c <= b or b + c <= a:\n        return \"Not a triangle\"\n    \n    # Calculate squares\n    a2, b2, c2 = a**2, b**2, c**2\n    \n    # Identify the type based on side lengths squared\n    if math.isclose(a2 + b2, c2) or math.isclose(a2 + c2, b2) or math.isclose(b2 + c2, a2):\n        return \"Right\"\n    elif a2 + b2 < c2 or b2 + c2 < a2 or a2 + c2 < b2:\n        return \"Obtuse\"\n    else:\n        return \"Acute\"", "def midsegment_length(side1, side2):\n    \"\"\"\n    Function that calculates the length of a mid-segment of a triangle.\n    \n    Parameters: \n    side1 (float): length of one side of the triangle. Side length cannot be negative.\n    side2 (float): length of the other side of the triangle. Side length cannot be negative.\n    \n    Returns: \n    float: length of the mid-segment, which is half the sum of the lengths of the two sides.\n    \n    Examples:\n    >>> midsegment_length(3, 4)\n    3.5\n    \"\"\"\n    try:\n        # Check for valid inputs\n        assert side1 >= 0\n        assert side2 >= 0\n    except AssertionError:\n        raise ValueError('Inputs must be positive numbers')\n    \n    return (side1 + side2) / 2", "def calculate_side_range_and_perimeter(a: float, b: float) -> Tuple[Tuple[int, int], int]:\n    \"\"\"\n    Calculate the possible values for the third side of a triangle when two sides are known.\n    Also, returns the maximal possible integer perimeter.\n    \n    Parameters:\n    a (float): Length of the first known side of the triangle.\n    b (float): Length of the second known side of the triangle.\n    \n    Returns:\n    Tuple[Tuple[int, int], int]: Returns a tuple containing another tuple and an integer. \n    The inner tuple represents the minimum and maximum possible integer values for the third side,\n    while the integer represents the maximum possible integer perimeter if the maximum side length is used.\n    \n    Examples:\n    >>> calculate_side_range_and_perimeter(3, 4)\n    ((2, 6), 13)\n    >>> calculate_side_range_and_perimeter(5, 10)\n    ((6, 14), 29)\n    \"\"\"\n    if a <= 0 or b <= 0:\n        raise ValueError(\"Side lengths must be positive numbers\")\n    min_c = max(abs(a - b) + 1, 1)\n    max_c = a + b - 1\n    max_perimeter = a + b + max_c\n    return ((min_c, max_c), max_perimeter)", "def triangle_side_lengths(a, b, c):\n    \"\"\" Calculate the triangle side lengths given vertices a, b, and c.\n    Parameters:\n        a (tuple): Coordinates of vertex a (x1, y1)\n        b (tuple): Coordinates of vertex b (x2, y2)\n        c (tuple): Coordinates of vertex c (x3, y3)\n    \n    Returns:\n        A dictionary with side lengths ab, bc, and ca.\n    \"\"\"\n    # Convert tuples to Points\n    p1, p2, p3 = Point(a), Point(b), Point(c)\n    # Create triangle ABC\n    triangle_abc = Triangle(p1, p2, p3)\n    \n    # Calculate side lengths\n    ab = triangle_abc.ab.length.evalf()\n    bc = triangle_abc.bc.length.evalf()\n    ca = triangle_abc.ca.length.evalf()\n    \n    return {'ab': ab, 'bc': bc, 'ca': ca}", "def solve_triangle(a, b, A):\n    \"\"\"\n    Calculate the missing side c and the remaining angles B and C in a triangle using the Law of Sines.\n    The provided angles must be in degrees.\n    \n    Parameters:\n        a (float): The length of side a.\n        b (float): The length of side b.\n        A (float): The angle opposite to side a in degrees.\n    \n    Returns:\n        tuple: Returns the length of side c and the angles B and C in degrees.\n    \n    Example:\n        >>> solve_triangle(3, 4, 30)\n        (2.3094, 53.1301, 96.8699)\n    \"\"\"\n    A = math.radians(A)  # Convert angle A from degrees to radians\n    sin_A = math.sin(A)\n    sin_B = (b * sin_A) / a\n    if sin_B > 1 or sin_B < -1:  # Check for invalid triangle configuration\n        return None\n    B = math.asin(sin_B)\n    C = math.pi - A - B\n    c = (a * math.sin(C)) / sin_A\n    return (c, math.degrees(B), math.degrees(C))", "def is_right_triangle(a, b, c):\n    \"\"\"\n    Determine if a triangle with sides a, b, c is a right triangle.\n    \n    Parameters:\n    a, b, c (float): Sides of the triangle.\n    Returns:\n    bool: True if the triangle is right, False otherwise.\n    \"\"\"\n    sides = sorted([a, b, c])\n    return math.isclose(sides[0]**2 + sides[1]**2, sides[2]**2)", "def area_by_inradius_semiperimeter(inradius: float, semiperimeter: float) -> float:\n    \"\"\"\n    Calculate the area of a triangle given the inradius and the semiperimeter.\n    Parameters:\n    - inradius (float): The radius of the inscribed circle of the triangle.\n    - semiperimeter (float): The semiperimeter of the triangle.\n    Returns:\n    - float: The area of the triangle.\n    Examples:\n    >>> area_by_inradius_semiperimeter(1, 6)\n    6.0\n    \"\"\"\n    return inradius * semiperimeter", "def calculate_distance(point1, point2):\n    \"\"\"\n    Calculate the Euclidean distance between two points in 2D space.\n    \n    Parameters:\n        point1 (tuple): The (x, y) coordinates of the first point.\n        point2 (tuple): The (x, y) coordinates of the second point.\n    \n    Returns:\n        float: The distance between the two points.\n    \n    Example:\n        >>> calculate_distance((1, 1), (4, 5))\n        5.0\n    \"\"\"\n    return math.sqrt((point2[0] - point1[0])**2 + (point2[1] - point1[1])**2)", "def angle_between_vectors(x1, y1, x2, y2):\n    \"\"\"\n    Calculate the angle (in degrees) between two vectors originating from the origin.\n    \n    Parameters:\n        x1, y1 (float): Components of the first vector.\n        x2, y2 (float): Components of the second vector.\n    \n    Returns:\n        float: The angle in degrees between two vectors.\n    \n    Examples:\n        >>> angle_between_vectors(1, 0, 0, 1)\n        90.0\n    \"\"\"\n    dot_product = x1 * x2 + y1 * y2\n    magnitude1 = math.sqrt(x1**2 + y1**2)\n    magnitude2 = math.sqrt(x2**2 + y2**2)\n    angle_radians = math.acos(dot_product / (magnitude1 * magnitude2))\n    return math.degrees(angle_radians)", "def classify_triangle(a, b, c):\n    \"\"\"\n    Classify a triangle based on the lengths of its sides.\n    \n    Parameters:\n    a, b, c (float): Sides of the triangle.\n    Returns:\n    str: Type of triangle ('equilateral', 'isosceles', 'scalene', 'right').\n    \"\"\"\n    if a == b == c:\n        return 'equilateral'\n    elif a == b or b == c or a == c:\n        if is_right_triangle(a, b, c):\n            return 'right isosceles'\n        return 'isosceles'\n    elif is_right_triangle(a, b, c):\n        return 'right'\n    return 'scalene'", "def triangle_similarity_by_sss(a_lengths, b_lengths):\n    \"\"\" Determine if two triangles are similar by Side-Side-Side (SSS) similarity criterion.\n    Parameters:\n        a_lengths (dict): Side lengths of triangle A {'ab': length1, 'bc': length2, 'ca': length3}\n        b_lengths (dict): Side lengths of triangle B {'ab': length1, 'bc': length2, 'ca': length3}\n    \n    Returns:\n        bool: True if triangles are similar, False otherwise.\n    \"\"\"\n    # Extracting lengths in sorted order\n    a_sorted = sorted(a_lengths.values())\n    b_sorted = sorted(b_lengths.values())\n    \n    # Checking proportionality\n    ratios = [a/b for a, b in zip(a_sorted, b_sorted)]\n    first_ratio = ratios[0]\n    \n    return all(abs(r - first_ratio) < 1e-9 for r in ratios)", "def pythagorean_theorem(a=None, b=None, c=None):\n    \"\"\"\n    Apply the Pythagorean theorem to find the missing side of a right triangle.\n    Parameters:\n        a (float, optional): length of side a, leg of the triangle\n        b (float, optional): length of side b, leg of the triangle\n        c (float, optional): length of side c, hypotenuse of the triangle\n    Returns:\n        float: The length of the missing side.\n    Examples:\n    >>> pythagorean_theorem(a=3, b=4)\n    5.0\n    >>> pythagorean_theorem(c=10, b=6)\n    8.0\n    \"\"\"\n    import math\n    \n    if a is None:\n        return math.sqrt(c**2 - b**2)\n    elif b is None:\n        return math.sqrt(c**2 - a**2)\n    elif c is None:\n        return math.sqrt(a**2 + b**2)\n    else:\n        raise ValueError(\"Exactly one side must be None to find its length\")", "def compute_pythagorean_side_length(side1, side2, target_side):\n    \"\"\"\n    Applies the Pythagorean theorem to compute a side length in a right triangle.\n    Parameters\n    ----------\n    side1 : float\n        Length of one side of the triangle.\n    side2 : float\n        Length of another side of the triangle.\n    target_side : str\n        The side to compute. It can either be \"leg\" if both given sides are legs, or \"hypotenuse\" if one of the given sides is the hypotenuse.\n    \n    Returns\n    -------\n    float\n        The length of the requested side.\n    Example\n    -------\n    >>> compute_pythagorean_side_length(3, 4, \"hypotenuse\")\n    5.0\n    \"\"\"\n    if target_side == \"hypotenuse\":\n        return math.sqrt(side1**2 + side2**2)\n    else:\n        return math.sqrt(max(side1, side2)**2 - min(side1, side2)**2)", "def triangle_side_length(coord1, coord2):\n    \"\"\"\n    Function that calculates the length of a side of a triangle given the coordinates of its endpoints.\n    Parameters:\n    coord1 (tuple): coordinates of the first endpoint of the side. coord1 is a tuple of two numbers (x1, y1)\n    coord2 (tuple): coordinates of the second endpoint of the side. coord2 is a tuple of two numbers (x2, y2)\n    \n    Returns:\n    float: length of the side calculated by the distance formula sqrt((x2 - x1)**2 + (y2 - y1)**2)\n    \n    Examples:\n    >>> triangle_side_length((0,0), (3,4))\n    5.0\n    \"\"\"\n    x1, y1 = coord1\n    x2, y2 = coord2\n    return math.sqrt((x2 - x1)**2 + (y2 - y1)**2)", "def calculate_right_triangle_sides(known_side, hypotenuse=None, other_side=None):\n    \"\"\"\n    Given a side and either the hypotenuse or the other side, calculate the missing side using Pythagoras' theorem.\n    Parameters:\n    - known_side (float): Length of one known side of the right triangle.\n    - hypotenuse (float, optional): Hypotenuse of the triangle, if known.\n    - other_side (float, optional): The other side (leg) of the triangle, if known.\n    Returns:\n    float: The length of the missing side.\n    \n    Example:\n    >>> calculate_right_triangle_sides(3, hypotenuse=5)\n    4.0\n    \"\"\"\n    if hypotenuse:\n        return math.sqrt(hypotenuse**2 - known_side**2)\n    elif other_side:\n        return math.sqrt(known_side**2 + other_side**2)\n    else:\n        raise ValueError('Either hypotenuse or the other side must be known.')", "def equilateral_triangle_properties(side_length: float) -> dict:\n    \"\"\"\n    Calculate the perimeter and area of an equilateral triangle given its side length.\n    Parameters\n    ----------\n    side_length : float\n        The length of one side of the equilateral triangle.\n    Returns\n    -------\n    dict\n        A dictionary containing the perimeter and area of the equilateral triangle.\n    Examples\n    --------\n    >>> equilateral_triangle_properties(5)\n    {'perimeter': 15.0, 'area': 10.825317547305486}\n    \"\"\"\n    from math import sqrt\n    perimeter = 3 * side_length\n    area = (sqrt(3) / 4) * side_length**2\n    return {'perimeter': perimeter, 'area': area}", "def calculate_triangle_perimeter(sides):\n    \"\"\"\n    Calculate the perimeter of a triangle given the lengths of the sides.\n    Parameters:\n    - sides (tuple/list): A collection of the three side lengths.\n    Returns:\n    float: The perimeter of the triangle.\n    \n    Example:\n    >>> calculate_triangle_perimeter((3, 4, 5))\n    12\n    \"\"\"\n    return sum(sides)", "def triangle_angle_sum():\n    \"\"\"\n    Return the sum of angles in any triangle, in degrees.\n    Returns:\n    int: The sum of the internal angles of a triangle, always 180 degrees.\n    \n    Example:\n    >>> triangle_angle_sum()\n    180\n    \"\"\"\n    return 180", "def triangle_properties(base, height, side=None):\n    \"\"\"\n    Given the base and height of a triangle, calculate and return the area and hypotenuse length.\n    Parameters:\n    base (float): The length of the base of the triangle.\n    height (float): The length of the height of the triangle.\n    side (float, optional): The length of one of the side of a right triangle to calculate the length of the hypotenuse \n    Returns:\n    area (float): The area of the triangle.\n    hypotenuse (float or None): The length of the hypotenuse of the triangle if side length is provided. None otherwise.\n    \"\"\"\n    import sympy\n    # Calculate Area\n    area = 0.5 * base * height\n    # Calculate Hypotenuse\n    if side is not None:\n        hypotenuse = sqrt(base**2 + side**2)\n    else:\n        hypotenuse = None\n    return area, hypotenuse"], "Parabolas": ["def vertex_from_quadratic(a, b, c):\n    \"\"\"\n    Calculates the vertex (h, k) of a parabola given its quadratic coefficients.\n    Parameters:\n        a (float): Coefficient of x^2.\n        b (float): Coefficient of x.\n        c (float): Constant term.\n    Returns:\n        tuple: The vertex (h, k) of the parabola.\n    Example:\n        >>> vertex_from_quadratic(1, -4, 4)\n        (2, 0)\n    \"\"\"\n    h = -b / (2 * a)\n    k = a * h**2 + b * h + c\n    return h, k", "def parabola_properties(equation):\n    \"\"\"\n    Given a quadratic equation, compute key properties of the corresponding parabola.\n    Parameters:\n    equation (sp.Expr): A sympy expression representing the quadratic equation y = ax^2 + bx + c.\n    Returns:\n    dict: A dictionary containing the vertex, focus, directrix, and axis of symmetry of the parabola.\n    Examples:\n    >>> x, y = sp.symbols('x y')\n    >>> eq = x**2 - 4*x + 4\n    >>> properties = parabola_properties(eq)\n    >>> print(properties[\"vertex\"])\n    (2, 0)\n    >>> print(properties[\"focus\"])\n    (2, 0.25)\n    \"\"\"\n    x = sp.symbols('x')\n    a = equation.expand().coeff(x, 2)\n    b = equation.expand().coeff(x, 1)\n    c = equation.expand().coeff(x, 0)\n    # Vertex formula\n    xv = -b / (2 * a)\n    yv = equation.subs(x, xv)\n    vertex = (xv, yv)\n    # Focus and directrix\n    focus_x = xv\n    focus_y = yv + 1/(4*a)\n    focus = (focus_x, focus_y)\n    directrix = yv - 1/(4*a)\n    return {\n        \"vertex\": vertex,\n        \"focus\": focus,\n        \"directrix\": directrix,\n        \"axis of symmetry\": xv\n    }", "def tangent_to_parabola(point, equation):\n    \"\"\"\n    Find the equation of the tangent line at a given point on the parabola y = ax^2 + bx + c.\n    Parameters:\n    point (tuple): A tuple (x0, y0) representing the point of tangency.\n    equation (sp.Expr): A sympy expression representing the quadratic parabola.\n    Returns:\n    sp.Expr: An equation representing the tangent line at the given point.\n    Examples:\n    >>> x, y = sp.symbols('x y')\n    >>> eq = x**2 - 6*x + 9\n    >>> point = (3, 0)\n    >>> tangent_line = tangent_to_parabola(point, eq)\n    >>> print(tangent_line)\n    y - 0 = 0*(x - 3)\n    \"\"\"\n    x, y = sp.symbols('x y')\n    x0, y0 = point\n    \n    # Derivative to find slope\n    dy_dx = sp.diff(equation, x)\n    slope = dy_dx.subs(x, x0)\n    tangent_eq = y - y0 - slope * (x - x0)\n    \n    return tangent_eq", "def parabola_line_intersection(a, b, c, line_slope, line_intercept):\n    \"\"\"\n    Computes the intersection points of a parabola y = ax^2 + bx + c with a line y = mx + n.\n    Parameters:\n    a : float\n        Coefficient 'a' of the parabola.\n    b : float\n        Coefficient 'b' of the parabola.\n    c : float\n        Coefficient 'c' of the parabola.\n    line_slope : float\n        Slope 'm' of the line.\n    line_intercept : float\n        Intercept 'n' of the line.\n    Returns:\n    numpy.array\n        Array containing the intersection points (x, y). Can be empty if there are no real intersections.\n    Examples:\n    >>> parabola_line_intersection(1, 0, -1, 1, 0)\n    array([[-1.61803399, -1.61803399], [0.61803399, 0.61803399]])\n    \"\"\"\n    from numpy import roots\n    from numpy import array\n    \n    # Finding roots of the quadratic equation formed by setting y values equal\n    quadratic = [a, b - line_slope, c - line_intercept]\n    x_roots = roots(quadratic)\n    \n    # Filter only real roots\n    x_roots = x_roots[abs(x_roots.imag) < 1e-6].real\n    y_roots = line_slope * x_roots + line_intercept\n    \n    # Construct the result array\n    points = array(list(zip(x_roots, y_roots)))\n    return points", "def distance_point_to_line(px, py, a, b, c):\n    \"\"\"\n    Calculates the distance from a point (px, py) to a line ax + by + c = 0.\n    Parameters:\n    px (float): x-coordinate of the point\n    py (float): y-coordinate of the point\n    a (float): coefficient of x in the line equation\n    b (float): coefficient of y in the line equation\n    c (float): constant term of the line equation\n    Returns:\n    float: The distance from the point to the line.\n    Examples:\n    >>> distance_point_to_classes(1, 2, 1, -1, 0)\n    0.7071067811865476\n    \"\"\"\n    return abs(a*px + b*py + c) / np.sqrt(a**2 + b**2)", "def parabola_equation(vertex, point=None, focus=None):\n    \"\"\"\n    Given a vertex and either a point on the parabola or the focus, this function returns the parabola's equation.\n    Parameters:\n    vertex (tuple): A tuple (xv, yv) representing the vertex of the parabola.\n    point (tuple, optional): A tuple (x, y) representing another point on the parabola.\n    focus (tuple, optional): A tuple (xf, yf) representing the focus of the parabola.\n    Returns:\n    sp.Expr: A sympy expression representing the quadratic equation y = ax^2 + bx + c.\n    Examples:\n    >>> vertex = (2, 3)\n    >>> point = (0, 7)\n    >>> equation = parabola_equation(vertex, point=point)\n    >>> print(equation)\n    y = (x - 2)**2 + 3\n    \"\"\"\n    x, y = sp.symbols('x y')\n    xv, yv = vertex\n    if point:\n        xp, yp = point\n        a = (yp - yv) / ((xp - xv)**2)\n        return a * (x - xv)**2 + yv\n    if focus:\n        xf, yf = focus\n        a = 1 / (4 * (yf - yv))\n        return a * (x - xv)**2 + yv", "def curve_intersection(eq1, eq2, var1='x', var2='y'):\n    \"\"\"\n    Calculate intersection points between two curves given by their equations.\n    \n    Parameters:\n    - eq1 (sp.Expr): The first curve equation in symbols.\n    - eq2 (sp.Expr): The second curve equation in symbols.\n    - var1 (str): The primary variable in the equations (default: 'x').\n    - var2 (str): The secondary variable in the equations (default: 'y').\n    Returns:\n    - list of tuples: List of intersection points.\n    Examples:\n    >>> x, y = sp.symbols('x y')\n    >>> parabola = y - x**2\n    >>> circle = x**2 + y**2 - 5\n    >>> curve_intersection(parabola, circle)\n    [(sqrt(5)/sqrt(3), 5/3), (-sqrt(5)/sqrt(3), 5/3)]\n    \"\"\"\n    x, y = sp.symbols(var1 + ' ' + var2)\n    intersection_points = sp.solve((eq1, eq2), (x, y))\n    return intersection_points"], "Polygons": ["def sum_of_interior_angles(n):\n    \"\"\"\n    Calculate the sum of the interior angles of an n-sided polygon.\n    \n    Parameters\n    ----------\n    n : int\n        Number of sides of the polygon\n    \n    Returns\n    -------\n    int\n        Sum of the interior angles in degrees\n    \n    Examples\n    --------\n    >>> sum_of_interior_angles(4)\n    360\n    \n    >>> sum_of_interior_angles(5)\n    540\n    \"\"\"\n    return 180 * (n - 2)", "def exterior_angle_from_interior(interior_angle):\n    \"\"\"\n    Calculate the exterior angle of a polygon from its interior angle.\n    Parameters:\n    - interior_angle (float or int): Interior angle of the polygon in degrees.\n    Returns:\n    - float: Exterior angle corresponding to the given interior angle.\n    Examples:\n    >>> exterior_angle_from_interior(90)\n    90.0\n    >>> exterior_angle_from_interior(120)\n    60.0\n    \"\"\"\n    return 180 - interior_angle", "def distance_between_points(p1, p2):\n    \"\"\"\n    Calculate the Euclidean distance between two points in the Cartesian plane.\n    Parameters\n    ----------\n    p1 : tuple of float\n        Coordinates (x, y) of the first point.\n    p2 : tuple of float\n        Coordinates (x, y) of the second point.\n    Returns\n    -------\n    float\n        Distance between the two points.\n    Examples\n    --------\n    >>> distance_between_points((1, 2), (4, 6))\n    5.0\n    \"\"\"\n    return math.sqrt((p2[0] - p1[0])**2 + (p2[1] - p1[1])**2)", "def polygon_exterior_angle(n):\n    \"\"\"\n    Calculate the exterior angle of an n-sided regular polygon.\n    \n    Parameters:\n    - n: int, number of sides of the polygon\n    \n    Returns:\n    - float, measure of the exterior angle in degrees\n    \"\"\"\n    if n < 3:\n        raise ValueError(\"A polygon must have at least 3 sides.\")\n    return 360 / n", "def polygon_angle_properties(n, angle_type='interior'):\n    \"\"\"\n    Calculate properties of angles in a regular polygon, including each individual angle and solving for 'n' given an angle.\n    Parameters:\n    - n (int or float): Number of sides of the polygon, or an interior/exterior angle degree if solving for 'n'.\n    - angle_type (str): Type of calculation - 'interior', 'exterior', or 'solve_for_n_interior','solve_for_n_exterior'.\n    Returns:\n    - float or int: Depending on the angle_type, returns the degree of each angle or the number of sides.\n    Examples:\n    >>> polygon_angle_properties(4)\n    90.0\n    >>> polygon_angle_properties(90, 'solve_for_n_interior')\n    4\n    >>> polygon_angle_properties(45, 'solve_for_n_exterior')\n    8\n    \"\"\"\n    import math\n    if angle_type == 'interior':\n        if n < 3:\n            raise ValueError(\"A polygon must have at least 3 sides.\")\n        return (n - 2) * 180.0 / n\n    elif angle_type == 'exterior':\n        if n < 3:\n            raise ValueError(\"A polygon must have at least 3 sides.\")\n        return 360.0 / n\n    elif angle_type == 'solve_for_n_interior':\n        # 180(n - 2) / n = angle\n        # 180n - 360 = n * angle\n        # 180n - n * angle = 360\n        # n(180 - angle) = 360\n        # n = 360 / (180 - angle)\n        return round(360 / (180 - n))\n    elif angle_type == 'solve_for_n_exterior':\n        # 360 / n = angle\n        # n = 360 / angle\n        return round(360 / n)\n    else:\n        raise ValueError(\"Invalid angle_type specified. Choose 'interior', 'exterior', 'solve_for_n_interior' or 'solve_for_n_exterior'.\")\n    return None", "def polygon_diagonals(n):\n    \"\"\"\n    Calculate the number of diagonals in an n-sided polygon.\n    \n    Parameters:\n    - n: int, number of sides of the polygon\n    \n    Returns:\n    - int, number of diagonals\n    \"\"\"\n    if n < 3:\n        raise ValueError(\"A polygon must have at least 3 sides.\")\n    return n * (n - 3) // 2", "def area_hexagon(side_length):\n    \"\"\"\n    Calculate the area of a regular hexagon given the side length.\n    \n    Parameters:\n    - side_length: float, the length of each side of the hexagle", "def area_square(side_length):\n    \"\"\"\n    Calculate the area of a square given the side length.\n    \n    Parameters:\n    - side_length: float, the length of each side of the square\n    \n    Returns:\n    - float, the area of the square\n    \"\"\"\n    return side_length ** 2", "def polygon_area(n, side_length):\n    \"\"\"\n    Calculate the area of a regular n-sided polygon given the side length.\n    \n    Parameters:\n    - n: int, number of sides of the polygon\n    - side_length: float, length of one side of the polygon\n    \n    Returns:\n    - float, area of the polygon\n    \"\"\"\n    if n < 3 or side_length <= 0:\n        raise ValueError(\"Invalid number of sides or side length.\")\n    apothem = side_length / (2 * tan(pi / n))\n    return 0.5 * n * side_length * apothem", "def calculate_triangle_area(base, height):\n    \"\"\"\n    Calculate the area of a triangle.\n    Parameters\n    ----------\n    base: float\n        The length of the base.\n    height: float\n        The length of the height.\n    Returns\n    -------\n    float\n        The area of the triangle.\n    Example\n    -------\n        >>> calculate_triangle_area(10, 5)\n        25.0\n    \"\"\"\n    return 0.5 * base * height", "def calculate_hypotenuse(a, b):\n    \"\"\"\n    Calculate the hypotenuse of a right-angle triangle.\n    Parameters\n    ----------\n    a: float\n        The length of one leg of the triangle.\n    b: float\n        The length of the other leg of the triangle.\n    Returns\n    -------\n    float\n        The length of the hypotenuse.\n    Example\n    -------\n        >>> calculate_hypotenuse(3, 4)\n        5.0\n    \"\"\"\n    return math.sqrt(a**2 + b**2)"], "Right Triangles": ["def calculate_hypotenuse(leg1, leg2):\n    \"\"\"\n    Computes the length of the hypotenuse of a right triangle given the lengths of the other two legs.\n    Parameters:\n    leg1 (float): Length of the first leg of the triangle.\n    leg2 (float): Length of the second leg of the triangle.\n    Returns:\n    float: The length of the hypotenuse.\n    Examples:\n    >>> calculate_hypotenuse(3, 4)\n    5.0\n    \"\"\"\n    return math.sqrt(leg1**2 + leg2**2)", "def calculate_right_triangle_side(a=None, b=None, c=None):\n    \"\"\"\n    Calculate the missing side of a right triangle using the Pythagorean Theorem.\n    \n    Parameters:\n        a (float): The length of side a, or None if it is the unknown side.\n        b (float): The length of side b, or None if it is the unknown side.\n        c (float): The length of the hypotenuse c, or None if it is the unknown side.\n    \n    Returns:\n        float: The length of the missing side.\n        \n    Examples:\n        calculate_right_triangle_side(a=3, b=4)  # Should return 5 as the hypotenuse\n        calculate_right_triangle_side(a=3, c=5)  # Should return 4 as the other side\n        calculate_right_triangle_side(b=4, c=5)  # Should return 3 as the other side\n    \"\"\"\n    import math\n    if c is None:\n        # Calculate hypotenuse\n        return math.sqrt(a ** 2 + b ** 2)\n    elif a is None:\n        # Calculate missing side a\n        return math.sqrt(c ** 2 - b ** 2)\n    elif b is None:\n        # Calculate missing side b\n        return math.sqrt(c ** 2 - a ** 2)\n    else:\n        raise ValueError(\"One and only one side length must be None.\")", "def hypotenuse_from_leg(leg_length):\n    \"\"\"\n    Calculate the length of the hypotenuse of a 45-45-90 triangle given one leg length.\n    \n    Parameters:\n    leg_length (float): Length of one of the legs of a 45-45-90 triangle.\n    \n    Returns:\n    float: Length of the hypotenuse.\n    Example:\n    >>> hypotenuse_from_leg(1)\n    1.4142135623730951  # approximately sqrt(2)\n    \"\"\"\n    return leg_length * math.sqrt(2)", "def is_right_triangle(sides):\n    \"\"\"\n    Determine if the given sides can form a right triangle using the Pythagorean Theorem.\n    Parameters:\n    sides (tuple or list): A tuple or list of three sides of a triangle.\n    Returns:\n    bool: True if the sides can form a right triangle, False otherwise.\n    Example:\n    >>> is_right_triangle((3, 4, 5))\n    True\n    >>> is_right_triangle((5, 5, 5))\n    False\n    \"\"\"\n    a, b, c = sorted(sides)\n    return np.isclose(a**2 + b**2, c**2)", "def is_pythagorean_triple(a, b, c):\n    \"\"\"\n    Check if three numbers form a Pythagorean triple.\n    Parameters:\n    - a (float): length of the first side of the triangle.\n    - b (float): length of the second side of the triangle.\n    - c (float): length of the hypotenuse of the triangle.\n    Returns:\n    - bool: True if numbers form a Pythagorean triple, False otherwise.\n    Examples:\n    >>> is_pythagorean_triple(3, 4, 5)\n    True\n    >>> is_pythagorean_triple(5, 12, 13)\n    True\n    >>> is_pythagorean_triple(1, 1, 1)\n    False\n    \"\"\"\n    return math.isclose(a**2 + b**2, c**2)", "def calculate_area(leg1, leg2):\n    \"\"\"\n    Computes the area of a right triangle.\n    Parameters:\n    leg1 (float): Length of the first leg of the triangle.\n    leg2 (float): Length of the second leg of the triangle.\n    Returns:\n    float: The area of the right triangle.\n    Examples:\n    >>> calculate_area(3, 4)\n    6.0\n    \"\"\"\n    return 0.5 * leg1 * leg2", "def is_right_triangle(x1, y1, x2, y2, x3, y3):\n    \"\"\"\n    Determines if the points (x1, y1), (x2, y2), (x3, y3) form a right triangle in a 2D plane.\n    \n    Parameters:\n    - x1, y1 (float): Coordinates of the first point.\n    - x2, y2 (float): Coordinates of the second point.\n    - x3, y3 (float): Coordinates of the third point.\n    \n    Returns:\n    - bool: True if the points form a right triangle, False otherwise.\n    \n    Examples:\n    - is_right_triangle(0, 0, 3, 0, 0, 4) -> True\n    - is_right_triangle(1, 1, 1, 5, 1, 9) -> False\n    \"\"\"\n    def distance_sq(xa, ya, xb, yb):\n        return (xb - xa) ** 2 + (yb - ya) ** 2\n    d1_sq = distance_sq(x1, y1, x2, y2)\n    d2_sq = distance_sq(x2, y2, x3, y3)\n    d3_sq = distance_sq(x3, y3, x1, y1)\n    if (d1_sq + d2_sq == d3_sq) or (d2_sq + d3_sq == d1_sq) or (d1_sq + d3_sq == d2_sq):\n        return True\n    else:\n        return False", "def is_right_triangle(ax, ay, bx, by, cx, cy):\n    \"\"\"\n    Determines if a triangle formed by three points is a right triangle using distance formula.\n    \n    Parameters:\n        ax, ay (float): Coordinates of the first vertex A.\n        bx, by (float): Coordinates of the second vertex B.\n        cx, cy (float): Coordinates of the third vertex C.\n    \n    Returns:\n        bool: True if the triangle is a right triangle, False otherwise.\n    \n    Examples:\n        >>> is_right_triangle(0, 0, 3, 0, 0, 4)\n        True\n        >>> is_right_triangle(0, 0, 2, 2, 4, 0)\n        False\n    \"\"\"\n    # Calculate squared distances between points\n    AB2 = (bx - ax)**2 + (by - ay)**2\n    AC2 = (cx - ax)**2 + (cy - ay)**2\n    BC2 = (cx - bx)**2 + (cy - by)**2\n    \n    # Check for the Pythagorean relationship between the sides\n    return (AB2 + AC2 == BC2) or (AB2 + BC2 == AC2) or (AC2 + BC2 == AB2)", "def is_right_triangle(side1, side2, side3):\n    \"\"\"\n    Determines whether the given sides can form a right triangle.\n    Parameters:\n    side1, side2, side3 (float): The lengths of the sides of the triangle.\n    Returns:\n    bool: True if the given sides can form a right triangle, False otherwise.\n    Examples:\n    >>> is_right_triangle(3, 4, 5)\n    True\n    >>> is_right_riangle(1, 2, 3)\n    False\n    \"\"\"\n    sides = sorted([side1, side2, side3])\n    return math.isclose(sides[2]**2, sides[0]**2 + sides[1]**2)", "def pythagorean_theorem(known_side1, known_side2, find='hypotenuse'):\n    \"\"\"\n    Solves for a side of a right triangle using the Pythagorean theorem.\n    \n    Parameters:\n        known_side1 (float): Length of first known side.\n        known_side2 (float): Length of second known side.\n        find (str, optional): Which side to find; choices are 'hypotenuse' or 'leg'. Default is 'hypotenuse'.\n    \n    Returns:\n        float: Length of the unknown side.\n        \n    Examples:\n        >>> pythagorean_theorem(3, 4)\n        5.0\n        >>> pythagorean_theorem(5, 4, find='leg')\n        3.0\n    \"\"\"\n    if find == 'hypotenuse':\n        return math.sqrt(known_side1**2 + known_side2**2)\n    elif find == 'leg':\n        if known_side1 > known_side2:\n            return math.sqrt(known_side1**2 - known_side2**2)\n        else:\n            return math.sqrt(known_side2**2 - known_side1**2)\n    else:\n        raise ValueError(\"Invalid option for 'find'. Choose 'hypotenuse' or 'leg'.\")", "def find_missing_side(known_sides):\n    \"\"\"\n    Finds the missing side of a right triangle given the other two sides.\n    \n    Parameters:\n    known_sides (list of float or None): List of two known sides and one None indicating the missing side.\n    \n    Returns:\n    float: The missing side of the right triangle.\n    \n    Examples:\n    >>> find_missing_side([3, 4, None])\n    5.0\n    >>> find_missing_side([None, 4, 5])\n    3.0\n    \"\"\"\n    a, b, c = known_sides\n    if a is None:\n        return math.sqrt(c**2 - b**2)\n    elif b is None:\n        return math.sqrt(c**2 - a**2)\n    else:  # c is None\n        return math.sqrt(a**2 + b**2)", "def has_right_angles(ax, ay, bx, by, cx, cy, dx, dy):\n    \"\"\"\n    Checks whether a quadrilateral has right angles at every vertex based on coordinates.\n    Parameters:\n        ax, ay (float): Coordinates of the first vertex A.\n        bx, by (float): Coordinates of the second vertex B.\n        cx, cy (float): Coordinates of the third vertex C.\n        dx, dy (float): Coordinates of the fourth vertex D.\n    \n    Returns:\n        bool: True if all angles in the quadrilateral are right angles, False otherwise.\n    \n    Examples:\n        >>> has_right_angles(0, 0, 4, 0, 4, 3, 0, 3)\n        True\n        >>> has_right_angles(0, 0, 4, 0, 5, 3, 1, 3)\n        False\n    \"\"\"\n    def dot_product_zero(x1, y1, x2, y2):\n        return x1 * x2 + y1 * y2 == 0\n    # Vectors for AB, BC, CD, DA\n    ABx, ABy = bx - ax, by - ay\n    BCx, BCy = cx - bx, cy - by\n    CDx, CDy = dx - cx, dy - cy\n    DAx, DAy = ax - dx, ay - dy\n    \n    # Check right angles at B, C, D respectively using dot product\n    return (dot_product_zero(ABx, ABy, BCx, BCy) and \n            dot_product_zero(BCx, BCy, CDx, CDy) and \n            dot_product_zero(CDx, CDy, DAx, DAy))", "def right_triangle_solver(leg1=None, leg2=None, hypotenose=None):\n    \"\"\"\n    Solve any right triangle by determining missing side lengths.\n    Parameters:\n    leg1 (float, optional): First leg of the triangle.\n    leg2 (float, optional): Second leg of the triangle.\n    hypotenose (float, optional): Hypotenose of the triangle.\n    Returns:\n    tuple: A tuple containing the values (leg1, leg2, hypotenose).\n    Examples:\n    >>> right_triangle_solver(leg1=3, leg2=4)\n    (3, 4, 5.0)\n    >>> right_triangle_solver(leg1=3, hypotenose=5)\n    (3, 4.0, 5)\n    >>> right_triangle_solver(leg2=4, hypotenose=5)\n    (3.0, 4, 5)\n    \"\"\"\n    if hypotenose and leg1 and leg2 is None:\n        leg2 = sqrt(pow(hypotenose, 2) - pow(leg1, 2))\n        return leg1, leg2, hypotenose\n    elif hypotenose and leg2 and leg1 is None:\n        leg1 = sqrt(pow(hypotenose, 2) - pow(leg2, 2))\n        return leg1, leg2, hypotenose\n    elif leg1 and leg2 and hypotenose is None:\n        hypotenose = sqrt(pow(leg1, 2) + pow(leg2, 2))\n        return leg1, leg2, hypotenose\n    else:\n        raise ValueError(\"Two sides must be provided to solve for the third.\")"], "Lines and Angles": ["def line_equation(point1, point2):\n    \"\"\"\n    Return the coefficients of the line equation in the form Ax + By = C using two points.\n    Parameters:\n    point1 (tuple): (x1, y1) coordinates of the first point.\n    point2 (tuple): (x2, y2) coordinates of the second point.\n    \n    Returns:\n    tuple: Coefficients (A, B, C) representing the line Ax + By = C.\n    \n    Examples:\n    >>> line_equation((1, 2), (3, 4))\n    (2, -2, 0)\n    \"\"\"\n    x1, y1 = point1\n    x2, y2 = point2\n    A = y2 - y1\n    B = x1 - x2\n    C = A*x1 + B*y1\n    return (A, -B, C)", "def find_intersection_of_lines(line1, line2):\n    \"\"\"\n    Finds the intersection point of two lines, if they intersect.\n    \n    Parameters:\n    - line1: sympy.Eq, the equation of the first line.\n    - line2: sympy.Eq, the equation of the second line.\n    Returns:\n    - tuple or None: The (x, y) coordinates of the intersection point or None if no intersection.\n    Example:\n    >>> find_intersection_of_lines(Eq(y, 2*x + 1), Eq(y, -x + 4))\n    (1, 3)\n    \"\"\"\n    x, y = symbols('x y')\n    result = solve((line1, line2), (x, y))\n    if result:\n        return (result[x], result[y])\n    return None", "def calculate_side_length(a, b, angle_C):\n    \"\"\"\n    Calculate the length of a side in a triangle using the Law of Cosines.\n    Parameters:\n    a (float): Length of the first side of the triangle.\n    b (float): Length of the second side of the triangle.\n    angle_C (float): Angle opposite the side to be calculated, in degrees.\n    Returns:\n    float: The length of the third side.\n    Examples:\n    >>> calculate_side_length(5, 7, 45)\n    3.80788655293\n    \"\"\"\n    # Converting angle from degrees to radians\n    angle_C_rad = np.deg2rad(angle_C)\n    \n    # Using Law of Cosines: c^2 = a^2 + b^2 - 2ab*cos(C)\n    c = np.sqrt(a**2 + b**2 - 2*a*b*np.cos(angle_C_rad))\n    return c", "def slope_from_points(p1, p2):\n    \"\"\"\n    Computes the slope of the line given two points.\n    Parameters:\n    p1 (tuple): A tuple (x1, y1) representing the first point on the line.\n    p2 (tuple): A tuple (x2, y2) representing the second point on the line.\n    Returns:\n    float: The slope of the line.\n    \n    Example:\n    >>> slope_from_points((1, 2), (3, 4))\n    1.0\n    \"\"\"\n    x1, y1 = p1\n    x2, y2 = p2\n    return (y2 - y1) / (x2 - x1)", "def calculate_distance(x1, y1, x2, y2):\n    \"\"\"\n    Calculate the Euclidean distance between two points in the 2D coordinate plane.\n    Parameters:\n    x1, y1 (float): Coordinates of the first point.\n    x2, y2 (float): Coordinates of the second point.\n    Returns:\n    float: The distance between the two points.\n    Examples:\n    >>> calculate_distance(0, 0, 3, 4)\n    5.0\n    \"\"\"\n    return math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2)", "def are_perpendicular(slope1, slope2):\n    \"\"\"\n    Determines if two lines with given slopes are perpendicular.\n    \n    Parameters:\n        slope1 (float): Slope of the first line.\n        slope2 (float): Slope of the second line.\n    \n    Returns:\n        bool: True if lines are perpendicular, False otherwise.\n    \n    Examples:\n        >>> are_perpendicular(2, -0.5)\n        True\n        >>> are_perpendicular(3, 3)\n        False\n    \"\"\"\n    if slope1 == np.inf and slope2 == 0:\n        return True\n    elif slope2 == np.inf and slope1 == 0:\n        return True\n    elif slope1 * slope2 == -1:\n        return True\n    return False", "def is_on_straight_line(points):\n    \"\"\"\n    Determine if all given points lie on a straight line where the sum of the x and y coordinates is constant.\n    Parameters:\n    - points (list of tuples): A list where each tuple represents the coordinates of a point (x, y).\n    Returns:\n    - bool: True if all points lie on the same line of the form x + y = constant, False otherwise.\n    - float or None: The constant sum if the points lie on a straight line, otherwise None.\n    Examples:\n    >>> is_on_straight_line([(1, 2), (2, 3), (3, 4)])\n    (True, 3)\n    >>> is_on_straight98_line([(1, 2), (3, 5), (4, 1)])\n    (False, None)\n    \"\"\"\n    from sympy import Eq, solve, symbols\n    \n    if len(points) < 2:\n        return False, None\n    x, y = symbols('x y')\n    first_point = points[0]\n    expected_sum = sum(first_cordinate for first_cordinate in first_point)\n    for point in points[1:]:\n        if sum(point) != expected_sum:\n            return False, None\n            \n    return True, expected_sum", "def find_midpoint(point1, point2):\n    \"\"\"\n    Calculate the midpoint between two points in a 2D space.\n    Parameters:\n    point1 (tuple): The (x, y) coordinates of the first point.\n    point2 (tuple): The (x, y) coordinates of the second point.\n    Returns:\n    tuple: The (x, y) coordinates of the midpoint.\n    Example:\n    >>> find_midpoint((0, 0), (2, 2))\n    (1.0, 1.0)\n    \"\"\"\n    midpoint = ((point1[0] + point2[0]) / 2, (point1[1] + point2[1]) / 2)\n    return midpoint", "def calculate_supplementary_angle(angle):\n    \"\"\"\n    Calculate the supplementary angle to the given angle (Adds up to 180 degrees).\n    Parameters:\n    angle (float): An angle in degrees.\n    Returns:\n    float: The supplementary angle.\n    Examples:\n    >>> calculate_supplementray_angle(30)\n    150.0\n    >>> calculate_supplementary_angle(90)\n    90.0\n    \"\"\"\n    return 180 - angle", "def find_linear_equation(x1, y1, x2, y2):\n    \"\"\"\n    Calculate the slope-intercept form equation of a line given two points (x1, y1) and (x2, y2).\n    Parameters:\n    - x1, y1, x2, y2 (float): Coordinates of two points on the line.\n    Returns:\n    - tuple: coefficients of slope and constant (m, c) of the line y = mx + c\n    Examples:\n    - find_linear_equation(1, 2, 3, 8)\n    \"\"\"\n    slope = (y2 - y1) / (x2 - x1) if x2 != x1 else float('inf')\n    intercept = y1 - slope * x1\n    return (slope, intercept)", "def angle_between_vectors(vector1, vector2):\n    \"\"\"\n    Calculate the angle in degrees between two vectors in 2D space.\n    Parameters:\n    vector1 (tuple): The components (x, y) of the first vector.\n    vector2 (tuple): The components (x, y) of the second vector.\n    Returns:\n    float: The angle in degrees.\n    Example:\n    >>> angle_between_vectors((1, 0), (0, 1))\n    90.0\n    \"\"\"\n    dot_product = np.dot(vector1, vector2)\n    magnitude_product = np.linalg.norm(vector1) * np.linalg.norm(vector2)\n    angle_rad = math.acos(dot_product / magnitude_product)\n    angle_deg = math.degrees(angle_rad)\n    return angle_deg", "def divide_segment_into_parts(point1, point2, parts):\n    \"\"\"\n    Divide a line segment into a specified number of equal parts and return the division points.\n    Parameters:\n    point1 (tuple): The (x, y) coordinates of the first point.\n    point2 (tuple): The (x, y) coordinates of the second point.\n    parts (int): The number of equal parts to divide the segment into.\n    Returns:\n    list of tuples: The list of (x, y) coordinates of the division points.\n    Example:\n    >>> divide_segment_into_parts((0, 0), (6, 0), 3)\n    [(2.0, 0.0), (4.0, 0.0)]\n    \"\"\"\n    return [(point1[0] + (point2[0] - point1[0]) * i / parts, point1[1] + (point2[1] - point1[1]) * i / parts) for i in range(1, parts)]", "def check_parallelism(line1_coeffs, line2_coeffs):\n    \"\"\"\n    Checks whether two lines are parallel.\n    Parameters:\n    line1_coeffs (tuple/list): Coefficients (A, B) of the first line (Ax + By = C).\n    line2_coeffs (tuple/list): Coefficients (A, B) of the second line (Ax + By = C).\n    Returns:\n    bool: True if lines are parallel, False otherwise.\n    Example:\n    >>> check_parallelism((1, -2), (2, -4))\n    True\n    >>> check_parallelism((1, 2), (2, -5))\n    False\n    \"\"\"\n    A1, B1 = line1_coeffs\n    A2, B2 = line2_coeffs\n    return np.isclose(A1 * B2, A2 * B1)", "def radians_to_degrees(radians):\n    \"\"\"\n    Converts an angle from radians to degrees.\n    Parameters:\n    radians (float): The angle in radians.\n    Returns:\n    degrees (float): The angle in degrees.\n    Examples:\n    >>> radians_to_degrees(math.pi)\n    180.0\n    \"\"\"\n    return math.degrees(radians)", "def angle_between_lines(line1, line2):\n    \"\"\"\n    Calculate the angle in degrees between two lines given their coefficients.\n    Parameters:\n    line1 (tuple): Coefficients (a, b, c) of the first line in the form ax + by + c = 0.\n    line2 (tuple): Coefficients (a, b, c) of the second line in the form ax + by + c = 0.\n    Returns:\n    float: Angle in degrees between the two lines.\n    Example:\n    >>> angle_between_lines((1, -1, 0), (1, 1, 0))\n    90.0\n    \"\"\"\n    # Extract coefficients\n    a1, b1, _ = line1\n    a2, b2, _ = line2\n    # Calculating angle using the formula:\n    # tan(theta) = |(m2-m1)/(1+m1*m2)|  where m = -a/b for each line\n    numerator = np.abs(a2 * b1 - a1 * b2)\n    denominator = np.abs(a1 * b2 + a2 * b1)\n    angle_rad = np.arctan(numerator / denominator)\n    angle_deg = np.degrees(angle_rad)\n    return angle_deg", "def are_complementary(*angles):\n    \"\"\"\n    Check if the provided angles sum up to 90 degrees, thus are complementary.\n    \n    Parameters:\n        angles (float or int): a variable number of angle measures\n    \n    Returns:\n        bool: True if the sum of angles is 90 degrees, False otherwise.\n        \n    Examples:\n        >>> are_complementary(30, 60)\n        True\n        >>> are_complementary(45, 45)\n        True\n        >>> are_complementary(90, 0)\n        True\n        >>> are_complementary(50, 40, 10)\n        False\n    \"\"\"\n    import numpy as np  # Importing Numpy for numerical operations\n    if np.isclose(sum(angles), 90):\n        return True\n    else:\n        return False", "def calculate_angle_relations(parallel, transversal, known_angle, angle_type):\n    \"\"\"\n    Calculate angles such as corresponding, supplementary, or alternate when dealing\n    with two lines and a transversal, focusing on situations where lines might be parallel.\n    \n    Parameters:\n        parallel (bool): A flag indicating whether the two lines are parallel.\n        transversal (bool): A flag indicating if there is a transversal intersecting the two lines.\n        known_angle (int or float): A known angle measurement in degrees.\n        angle_type (str): A descriptive type of the angle relation to compute:\n                          'corresponding', 'supplementary', or 'alternate'.\n    Returns:\n        float: The calculated angle in degrees based upon the type and parallelism.\n    Examples:\n        >>> calculate_angle_relations(True, True, 30, 'corresponding')\n        30\n        >>> calculate_angle_relations(True, True, 150, 'supplementary')\n        30\n        >>> calculate_angle_relations(True, True, 60, 'alternate')\n        60\n    \"\"\"\n    from math import fmod\n    if not transversal:\n        return \"No transversal line present!\"\n    if parallel:\n        if angle_type == 'corresponding' or angle_type == 'alternate':\n            return known_angle\n        elif angle_type == 'supplementary':\n            return 180 - known_angle\n    else:\n        if angle_type == 'corresponding':\n            # Non-parallel lines can have non-equal corresponding angles, dependent on geometry.\n            return None\n        elif angle_type == 'alternate':\n            # Still equal if the lines aren't intersected by a curve or such.\n            return known_angle\n        elif angle_type == 'supplementary':\n            return 180 - known_angle\n    return None", "def triangle_angle_solver(angle1, angle2=None, angle3=None):\n    \"\"\"\n    Calculates the missing angles in a triangle given at least one known angle.\n    \n    Parameters:\n    angle1: float or None\n        The degree of the first angle. If set to None, it's considered unknown.\n    angle2: float or None\n        The degree of the second angle. If None, calculated from other angles.\n    angle3: float or None\n        The degree of the third angle. If None, calculated from other angles.\n    \n    Returns:\n    tuple\n        A tuple (a1, a2, a3) representing the angles of the triangle.\n        \n    Examples:\n    >>> triangle_angle_solver(90, 30)\n    (90, 30, 60)\n    >>> triangle_angle_solver(45, 45)\n    (45, 45, 90)\n    \"\"\"\n    if angle1 is not None and angle2 is not None:\n        angle3 = 180 - angle1 - angle2\n    elif angle1 is not None and angle3 is not None:\n        angle2 = 180 - angle1 - angle3\n    elif angle2 is not None and angle3 is not None:\n        angle1 = 180 - angle2 - angle3\n    else:\n        raise ValueError(\"At least two angles must be provided\")\n      \n    return angle1, angle2, angle3", "def vertical_angles(angle):\n    \"\"\"\n    Given one of the vertical angles, returns the other based on the property that vertical angles are equal.\n    Parameters:\n        angle (float): An angle in degrees representing one of the vertical angles.\n    Returns:\n        float: Returns the equal vertical angle in degrees.\n    Examples:\n        >>> vertical_angles(45)\n        45.0\n        >>> vertical_angles(120)\n        120.0\n    \"\"\"\n    return angle", "def angle_between_parallel_lines(angle_one, is_supplementary=False):\n    \"\"\"\n    Determines angles formed when two parallel lines are intersected by a transversal.\n    \n    Parameters:\n        angle_one : float or sympy.Expr\n            The measure of one of the given angles in degrees.\n        is_supplementary : bool, optional\n            Determines if the function should return the supplementary angle (default is False).\n            \n    Returns:\n        float or sympy.Expr\n            Returns the corresponding angle measure based on properties of parallel lines.\n            If `is_supplementary` is True, returns the supplementary angle to angle_one.\n    \n    Examples:\n        >>> angle_between_parallel_lines(50)\n        130\n        >>> angle_between_parallel_lines(50, True)\n        50\n        >>> angle_between_parallel_lines(sp.Symbol('x') + 10)\n        170 - x\n    \"\"\"\n    if is_supplementary:\n        return angle_one\n    else:\n        return 180 - angle_one", "def calculate_vertical_angle(given_angle):\n    \"\"\"\n    Calculate the vertical angle given one angle. Vertical angles are equal when two lines intersect.\n    Parameters:\n    given_angle (float): The given angle in degrees.\n    Returns:\n    float: The vertical angle which is equal to the given angle.\n    Example:\n    >>> calculate_vertical_angle(45)\n    45.0\n    \"\"\"\n    return given_angle", "def check_line_properties(line1_coeff, line2_coeff, check_type='parallel'):\n    \"\"\"\n    Determine if two lines are parallel or perpendicular, or find the intersection point.\n    \n    Parameters:\n        line1_coeff (tuple): Coefficients (A, B, C) of the first line in the form Ax + By = C.\n        line2_coeff (tuple): Coefficients (A, B, C) of the second line.\n        check_type (str): Type of property to check: 'parallel', 'perpendicular', 'intersection'.\n    Returns:\n        bool or tuple: Depending on 'check_type', returns boolean for parallel or perpendicular,\n                       and tuple (x, y) for intersection point if lines intersect.\n                       \n    Examples:\n        >>> check_line_properties((1, -1, 0), (2, -2, 0))\n        True  # Lines are parallel\n        >>> check_line_properties((1, -1, 0), (1, 1, 0), 'perpendicular')\n        True  # Lines are perpendicular\n        >>> check_line_properties((1, -1, 0), (1, 1, 2), 'intersection')\n        (1, 1)  # Intersection point\n    \"\"\"\n    A1, B1, C1 = line1_coeff\n    A2, B2, C2 = line2_coeff\n    \n    if check_type == 'parallel':\n        return A1*B2 == A2*B1\n    elif check_type == 'perpendicular':\n        return -A1*A2 == B1*B2\n    elif check_type == 'intersection':\n        determinant = A1*B2 - A2*B1\n        if determinant == 0:\n            return False  # Lines are parallel or coincident, no single intersection\n        else:\n            x = (B2*C1 - B1*C2) / determinant\n            y = (A1*C2 - A2*C1) / determinant\n            return (x, y)\n    return False", "def angle_between_tangent_and_radius(point_of_tangency, center_of_circle):\n    \"\"\"\n    Calculate the angle formed at the point of tangency between the tangent to a circle and the radius.\n    Parameters:\n    point_of_tangency (tuple): A tuple (x, y) representing the coordinates of the point where the tangent touches the circle.\n    center_of_circle (tuple): A tuple (x, y) representing the coordinates of the circle's center.\n    Returns:\n    angle (float): The angle in degrees between the tangent and the radius at the point of tangency, which is always 90 degrees for a circle.\n    Examples:\n    >>> angle_between_tangent_and_radius((2, 4), (1, 1))\n    90.0\n    \"\"\"\n    # For a circle, the angle between the radius to the point of tangency and the tangent at that point is always 90 degrees.\n    return 90.0", "def check_vertical_angles(angle1, angle2):\n    \"\"\"\n    Checks if two given angles are vertical angles. Vertical angles are always congruent.\n    \n    Parameters:\n        angle1 (float or int): The measure of the first angle in degrees.\n        angle2 (float or int): The measure of the second angle in degrees.\n        \n    Returns:\n        bool: True if the angles are congruent (equal), False otherwise.\n    \n    Examples:\n        >>> check_vertical_angles(45, 45)\n        True\n        >>> check_vertical_angles(130, 130)\n        True\n        >>> check_vertical_angles(110, 120)\n        False\n    \"\"\"\n    return angle1 == angle2", "def check_line_relationship(point1, point2, point3, point4):\n    \"\"\"\n    Check if two lines described by two points each (points on the first line and points on the second line) are parallel or perpendicular.\n    Parameters:\n    - point1, point2 (tuple): Coordinates of the first and second point (x, y) on the first line.\n    - point3, point4 (tuple): Coordinates of the first and second point (x, y) on the second line.\n    Returns:\n    - str: 'parallel', 'perpendicular', or 'none' indicating the relationship between the two lines.\n    \n    Examples:\n    - check_line_relationship((0,0), (1,1), (0,1), (1,2)) returns 'parallel'.\n    - check_line_relationship((0,0), (1,0), (0,0), (0,1)) returns 'perpendicular'.\n    \"\"\"\n    # Calculate direction vectors\n    dir1 = np.array([point2[0] - point1[0], point2[1] - point1[1]])\n    dir2 = np.array([point4[0] - point3[0], point4[1] - point3[1]])\n    \n    # Check parallelism (cross product == 0)\n    if np.cross(dir1, dir2) == 0:\n        return 'parallel'\n    \n    # Check perpendicularity (dot product == 0)\n    if np.dot(dir1, dir2) == 0:\n        return 'perpendicular'\n    return 'none'", "def line_perpendicular_to(line, point):\n    \"\"\"\n    Creates the equation of a line that is perpendicular to the given line and passes through the specified point.\n    \n    Parameters:\n    - line (sympy.Expr): The equation of the initial line in form `Ax + By + C = 0`.\n    - point (tuple): A tuple (px, py) representing the point through which the perpendicular line must pass.\n    \n    Returns:\n    - sympy.Expr: The equation of the perpendicular line.\n    \n    Example:\n    >>> line = create_line_equation((0, 0), (1, 1))\n    >>> perp_line = line_perpendicular_to(line, (1, 0))\n    >>> print(perp_line)\n    x + y - 1\n    \"\"\"\n    x, y = sp.symbols('x y')\n    A, B, _ = sp.poly(line).coeffs()\n    px, py = point\n    # For line Ax + By + C = 0, the perpendicular line is Bx - Ay + (Ay1 - Bx1)\n    perp_line_expr = B*x - A*y + (A*py - B*px)\n    return sp.simplify(perp_line_expr)", "def identify_line_type(point1, point2):\n    \"\"\"\n    Identifies the type of line (horizontal, vertical, or diagonal) formed by two given points.\n    Parameters:\n        point1 (tuple): The (x, y) coordinate of the first point.\n        point2 (tuple): The (x, y) coordinate of the second point.\n    Returns:\n        str: Returns \"horizontal\" if line is horizontal, \"vertical\" if vertical, and \"diagonal\" otherwise.\n    Example:\n        >>> identify_line_type((0, 0), (5, 0))\n        'horizontal'\n        >>> identify_line_range((1, 1), (1, 3))\n        'vertical'\n        >>> identify_line_range((1, 1), (3, 3))\n        'diagonal'\n    \"\"\"\n    if point1[0] == point2[0]:\n        return 'vertical'\n    elif point1[1] == point2[1]:\n        return 'horizontal'\n    else:\n        return 'diagonal'", "def line_length(point1, point2):\n    \"\"\"\n    Calculate the Euclidean distance between two points.\n    Parameters:\n    point1 (tuple): A tuple (x, y) representing the coordinates of the first point.\n    point2 (tuple): A tuple (x, y) representing the coordinates of the second point.\n    Returns:\n    length (float): The length of the line segment between the two points.\n    Examples:\n    >>> line_length((1, 1), (4, 5))\n    5.0\n    \"\"\"\n    point1 = np.array(point1)\n    point2 = np.array(point2)\n    return np.linalg.norm(point1 - point2)", "def compute_slope(x1, y1, x2, y2):\n    \"\"\"\n    Compute the slope of a line passing through points (x1, y1) and (x2, y2).\n    \n    Parameters:\n        x1, y1, x2, y2 (int or float): Coordinates of two points.\n    \n    Returns:\n        slope (int or float or sympy object): The slope of the line.\n        \n    Examples:\n        slope = compute_slope(1, 2, 3, 8)\n        print(slope)  # 3\n    \"\"\"\n    # Utilizing sympy points computation to avoid division by zero\n    p1, p2 = Point(x1, y1), Point(x2, y2)\n    line = Line(p1, p2)\n    return line.slope", "def cyclic_quadrilateral_angles(angle1, angle2=None):\n    \"\"\"\n    Determines the missing angles in a cyclic quadrilateral given two opposite angles.\n    \n    Parameters:\n    angle1: float\n        The degree of one angle of the cyclic quadrilateral.\n    angle2: float or None\n        The degree of the opposite angle. If None, it's calculated.\n    \n    Returns:\n    tuple\n        A tuple (a1, a2) representing the angles of two opposite pairs in the cyclic quadrilateral.\n        \n    Examples:\n    >>> cyclic_quadrilateral_angles(110)\n    (110, 70)\n    >>> cyclic_quadrilateral_angles(80, 100)\n    (80, 100)\n    \"\"\"\n    if angle2 is None:\n        angle2 = 180 - angle1\n    else:\n        if angle1 + angle2 != 180:\n            raise ValueError(\"Opposite angles in a cyclic quadrilateral must sum up to 180 degrees.\")\n      \n    return angle1, angle2", "def check_parallel(line1, line2):\n    \"\"\"\n    Check if two lines are parallel.\n    \n    Parameters:\n    line1 (tuple): Coefficients (a, b, c) for the first line ax + by + c = 0.\n    line2 (tuple): Coefficients (a, b, c) for the second line ax + by + c = 0.\n    \n    Returns:\n    bool: True if the lines are parallel, False otherwise.\n    \n    \"\"\"\n    return calculate_slope(line1) == calculate_slope(line2)", "def segment_length(point1, point2):\n    \"\"\"\n    Calculate the length of the segment connecting two points in 2D space.\n    Parameters:\n    point1 (tuple): The (x, y) coordinates of the first point.\n    point2 (tuple): The (x, y) coordinates of the second point.\n    Returns:\n    float: The length of the segment.\n    Example:\n    >>> segment_length((0, 0), (4, 3))\n    5.0\n    \"\"\"\n    length = np.sqrt((point2[0] - point1[0])**2 + (point2[1] - point1[1])**2)\n    return length", "def slope_between_points(point1, point2):\n    \"\"\"\n    Calculates the slope between two given points.\n    \n    Parameters:\n        point1 : tuple of two floats or sympy.Expr\n            Coordinates of the first point (x1, y1).\n        point2 : tuple of two floats or sympa.Expressions\n            Coordinates of the second point (x2, y2).\n    Returns:\n        float or sympy.Expr\n            The slope value between the two points.\n    \n    Example:\n        >>> slope_between_points((1, 2), (3, 8))\n        3\n        >>> slope_between_keys((1, 2), (1, 8))\n        'undefined'  # Division by zero, or handle with symbolics if used in equations.\n    \"\"\"\n    x1, y1 = point1\n    x2, y2 = point2\n    try:\n        return (y2 - y1) / (x2 - x1)\n    except ZeroDivisionError:\n        return 'undefined'", "def sum_of_triangle_angles():\n    \"\"\"\n    Returns the sum of the internal angles of a triangle, which is always 180 degrees.\n    Returns:\n    int: Sum of angles in a triangle.\n    \n    Examples:\n    >>> sum_of_triangle_angles()\n    180\n    \"\"\"\n    return 180", "def calculate_polygon_angle(n_sides, internal_or_external=True):\n    \"\"\"\n    Calculate the interior or exterior angles of a regular polygon given the number of sides.\n    \n    Parameters:\n        n_sides (int): The number of sides in the polygon.\n        internal_or_external (bool): True for internal angle calculation, False for external angles.\n        \n    Returns:\n        float: The angle in degrees.\n        \n    Example:\n        >>> calculate_polygon_angle(4)\n        90.0\n        >>> calculate_polygon_angle(4, False)\n        90.0\n    \"\"\"\n    if internal_or_external:\n        # Interior angle calculation\n        return (n_sides - 2) * 180 / n_sides\n    else:\n        # Exterior angle calculation (regular polygon)\n        return 360 / n_sides", "def find_line_equation(x1, y1, x2, y2):\n    \"\"\"\n    Generate the equation of a line passing through points (x1, y1) and (x2, y2).\n    \n    Parameters:\n        x1, y1, x2, y2 (int or float): Coordinates of two points.\n    \n    Returns:\n        sympy Eq: The equation of the line in the format `Eq(line expression, 0)`\n        \n    Examples:\n        equation = find_line_equation(0, 0, 1, 1)\n        print(equation)  # Eq(-x + y, 0)\n    \"\"\"\n    p1, p2 = Point(x1, y1), Point(x2, y2)\n    line = Line(p1, p2)\n    return Eq(line.equation(), 0)", "def check_parallel(angle1, angle2):\n    \"\"\"\n    Determine if two lines are parallel based on their corresponding or alternate angles.\n    Parameters:\n    angle1 (float): The angle formed between the first line and the transversal.\n    angle2 (float): The angle formed between the second line and the transversal.\n    Returns:\n    bool: True if lines are parallel, False otherwise.\n    \n    Examples:\n    >>> check_parallel(120, 120)\n    True\n    >>> check_parallel(120, 130)\n    False\n    \"\"\"\n    return math.isclose(angle1, angle2, abs_tol=1e-9)", "def check_triangle_inequality(a, b, c):\n    \"\"\"\n    Determine if three lengths can form a triangle based on the triangle inequality theorem.\n    Parameters:\n    a, b, c (float): Lengths of the sides of a potential triangle.\n    Returns:\n    bool: True if the lengths satisfy the triangle inequality, False otherwise.\n    Examples:\n    >>> check_triangle_inequality(3, 4, 5)\n    True\n    >>> check_triangle_inequality(1, 10, 12)\n    False\n    \"\"\"\n    return a + b > c and a + c > b and b + c > a", "def calculate_slope(line):\n    \"\"\"\n    Calculate the slope of a line given in the form ax + by + c = 0.\n    Parameters:\n    line (tuple): Coefficients (a, b, c) representing the line ax + by + c = 0.\n    Returns:\n    float: Slope of the line.\n    \n    \"\"\"\n    a, b, c = line\n    if b == 0:\n        raise ValueError(\"Slope is undefined for vertical lines.\")\n    return -a / b", "def angle_bisector_theorem(a, b, angle):\n    \"\"\"\n    Applies the angle bisector theorem within a triangle to find the relationships of segments.\n    Parameters:\n        a (float): The length of one side of the triangle.\n        b (float): The length of the adjacent side of the triangle.\n        angle (float): The angle being bisected in degrees.\n        \n    Returns:\n        float: The ratio of the two segments created by bisecting the given angle.\n    Examples:\n        >>> angle_bisector_theorem(4, 6, 60)\n        0.8\n    \"\"\"\n    theta = sp.rad(angle)\n    return (a / b)", "def distance_between_parallel_lines(slope, intercept1, intercept2):\n    \"\"\"\n    Calculate the distance between two parallel lines given by y = mx + c1 and y = mx + c2.\n    Parameters:\n    - slope (float): Slope of the parallel lines.\n    - intercept1, intercept2 (float): Y-intercepts of the two lines.\n    Returns:\n    - float: The distance between the two parallel lines.\n    Examples:\n    - distance_between_parallel_lines(1, 2, 5)\n    \"\"\"\n    return abs(intercept2 - intercept1) / math.sqrt(slope**2 + 1)", "def angle_in_cyclic_quadrilateral(adjacent_sum):\n    \"\"\"\n    Calculate the opposite angle in a cyclic quadrilateral given the sum of two adjacent angles.\n    \n    Parameters:\n        adjacent_sum (float): Sum of two adjacent angles in degrees.\n        \n    Returns:\n        float: Each of the opposite angles in degrees.\n        \n    Example:\n        >>> angle_in_cyclic_quadrilateral(90)\n        90.0\n    \"\"\"\n    # In a cyclic quadrilateral, the sum of opposite angles is 180 degrees\n    return 180 - adjacent_sum", "def sum_of_angles_around_point():\n    \"\"\"\n    Returns the sum of the angles around a point, which is always 360 degrees.\n    Returns:\n    int: Sum of angles around a point.\n    \n    Examples:\n    >>> sum_of_angles_roud_point()\n    360\n    \"\"\"\n    return 360", "def calculate_missing_angle(known_angle, relation_type='supplementary'):\n    \"\"\"\n    Calculate the missing angle based on the type of angle relation.\n    Parameters:\n    known_angle (float): The known angle in degrees.\n    relation_type (str): Type of angle relation, 'supplementary' or 'complementary'.\n    Returns:\n    float: The missing angle in degrees.\n    Example:\n    >>> calculate_missing_angle(150, 'supplementary')\n    30.0\n    >>> calculate_missingHandler(30, 'complementary')\n    60.0\n    \"\"\"\n    if relation_type == 'supplementary':\n        return 180 - known_angle\n    elif relation_type == 'complementary':\n        return 90 - known_angle\n    else:\n        raise ValueError(\"relation_type must be 'supplementary' or 'complementary'\")", "def perpendicular_slope(slope):\n    \"\"\"\n    Calculates the slope of a line perpendicular to the line with a given slope.\n    \n    Parameters:\n        slope (float): Slope of the original line.\n    \n    Returns:\n        float: Slope of the line that is perpendicular to the given line.\n    \n    Examples:\n        >>> perpendicular_slope(4)\n        -0.25\n        >>> perpendicular_slope(0)\n        inf\n    \"\"\"\n    if slope == 0:\n        return np.inf\n    elif slope == np.inf:\n        return 0\n    else:\n        return -1 / slope", "def are_corresponding_angles_equal(angle_set1, angle_set2):\n    \"\"\"\n    Check if corresponding angles in two sets are equal, useful for parallel lines crossed by a transversal.\n    Parameters:\n    angle_set1 (list of float): Angles in the first set.\n    angle_set2 (list of float): Angles in the second set.\n    \n    Returns:\n    bool: True if each corresponding angle in the sets are equal, False otherwise.\n    \n    Examples:\n    >>> are_corresponding_angles_equal([110, 70], [110, 70])\n    True\n    >>> are_corresponding_angles_equal([110, 70], [70, 110])\n    False\n    \"\"\"\n    return np.allclose(angle_set1, angle_set2)", "def distance_from_point_to_line(px, py, slope, intercept):\n    \"\"\"\n    Calculate the perpendicular distance from a point to a line given by y = mx + c.\n    Parameters:\n    - px, py (float): Coordinates of the point.\n    - slope, intercept (float): Coefficients of the line y = mx + c.\n    Returns:\n    - float: The perpendicular distance from (px, py) to the line.\n    Examples:\n    - distance_from_point_to_line(1, 2, 1, 0)  # Line y = x\n    \"\"\"\n    return abs(slope * px - py + intercept) / math.sqrt(slope**2 + 1)", "def solve_linear_equations(eq_list):\n    \"\"\"\n    Solves a system of linear equations.\n    \n    Parameters:\n        eq_list (list): A list of sympy Eq objects representing equations.\n    \n    Returns:\n        dict: A dictionary containing the solution for the variables in the equations.\n        \n    Examples:\n        x, y = symbols('x y')\n        eq1 = Eq(x + y, 10)\n        eq2 = Eq(2*x - y, 0)\n        solutions = solve_linear_equations([eq1, eq2])\n        print(solutions)  # {x: 10/3, y: 20/3}\n    \"\"\"\n    variables = set().union(*(eq.free_symbols for eq in eq_list))\n    solution = solve(eq_list, list(variables))\n    return solution", "def calculate_triangle_angle_sum(angle1, angle2):\n    \"\"\"\n    Given two angles of a triangle, returns the third angle using the fact\n    that sum of angles in a triangle is always 180 degrees.\n    Parameters:\n    - angle1 (float): First angle in degrees\n    - angle2 (float): Second angle in degrees\n    Returns:\n    - float: Third angle in the triangle\n    Example:\n    >>> calculate_triangle_angle_sum(90, 30)\n    60.0\n    \"\"\"\n    return 180.0 - angle1 - angle2", "def check_symmetry(x1, y1, x2, y2, line_x):\n    \"\"\"\n    Checks whether two points are symmetric with respect to a vertical line x = line_x.\n    Parameters:\n        x1, y1 (float, float): Coordinates of the first point.\n        x2, y2 (float, float): Coordinates of the second point.\n        line_x (float): x-coordinate of the vertical line of symmetry.\n    Returns:\n        bool: Returns True if the points are symmetric with respect to the line, otherwise False.\n    \n    Examples:\n        >>> check_symmetry(3, 4, 7, 4, 5)\n        True\n        >>> check_symmetry(1, 2, 3, 4, 5)\n        False\n    \"\"\"\n    return x1 + x2 == 2 * line_x and y1 == y2", "def calculate_line_segment_length(coord1, coord2):\n    \"\"\"\n    Calculates the length of the line segment between two coordinates.\n    Parameters:\n    - coord1 (tuple of float): The (x, y) coordinates of the first point\n    - coord2 (tuple of float): The (x, y) coordinates of the second point\n    Returns:\n    - float: The length of the line segment between the given points\n    Example:\n    >>> calculate_line_segment_length((0, 0), (3, 4))\n    5.0\n    \"\"\"\n    return math.hypot(coord2[0] - coord1[0], coord2[1] - coord1[1])"], "Volume of Solids": ["def cylinder_volume(radius, height):\n    \"\"\"\n    Calculate the volume of a cylinder given the radius and height.\n    \n    Parameters:\n    radius (float): The radius of the base of the cylinder.\n    height (float): The height of the cylinder.\n    \n    Returns:\n    float: The volume of the cylinder.\n    \n    Examples:\n    >>> cylinder_volume(2, 4)\n    50.26548245743669\n    \"\"\"\n    return math.pi * radius ** 2 * height", "def volume_of_rectangular_prism(length, width, height):\n    \"\"\"\n    Calculate the volume of a rectangular prism.\n    Parameters:\n    - length: The length of the prism (float or int).\n    - width: The width of the prism (float or int).\n    - height: The height of the prism (float or int).\n    Returns:\n    - The volume of the rectangular prism (float).\n    Example:\n    >>> volume_of_rectangular_prism(2, 3, 4)\n    24\n    \"\"\"\n    return length * width * height", "def volume_sphere(radius):\n    \"\"\"\n    Calculate the volume of a sphere given its radius.\n    Parameters:\n    radius (float): The radius of the sphere.\n    Returns:\n    float: The volume of the sphere.\n    Examples:\n    >>> volume_sphere(3)\n    113.09733552923255\n    \"\"\"\n    return (4/3) * math.pi * (radius ** 3)", "def cone_volume(radius, height):\n    \"\"\"\n    Calculate the volume of a cone.\n    \n    Parameters:\n        radius (float): The radius of the cone.\n        height (float): The height of the cone.\n    \n    Returns:\n        float: The volume of the cone.\n    \n    Example:\n        >>> cone_volume(3, 4)\n        37.69911184307752\n    \"\"\"\n    return (1/3) * math.pi * pow(radius, 2) * height", "def similar_shape_volume_change(original_volume, scale_factor):\n    \"\"\"\n    Calculate the volume of a geometric shape after scaling its dimensions.\n    Parameters:\n    original_volume (float): The original volume of the shape.\n    scale_factor (float): The factor by which each dimension of the shape is scaled.\n    Returns:\n    float: The adjusted volume of the shape after scaling.\n    Example:\n    >>> similar_shape_volume_change(27, 2)\n    216\n    \"\"\"\n    return original_volume * (scale_factor ** 3)", "def pyramid_volume(base_area, height):\n    \"\"\"\n    Calculate the volume of a pyramid given the area of the base and the height from the base to the apex.\n    Parameters:\n    base_area (float): The area of the pyramid's base.\n    height (float): The height from the base to the apex.\n    \n    Returns:\n    float: The volume of the pyramid.\n    Example:\n    >>> pyramid_volume(10, 15)\n    50.0\n    \"\"\"\n    return (1/3) * base_area * height", "def calculate_volume(shape, radius, height=None):\n    \"\"\"\n    Calculate the volume of a geometric solid (cylinder, hemisphere, or cone).\n    \n    Parameters:\n    - shape (str): The type of geometric solid ('cylinder', 'hemisphere', 'cone').\n    - radius (float): The radius of the solid.\n    - height (float): The height of the solid, required for cylinders and cones, not used for hemispheres.\n    Returns:\n    - float: The volume of the geometric solid.\n    Examples:\n    - calculate_volume('cylinder', 5, 10)\n      # Returns: 785.3981633974483 (Volume of a cylinder using V=pi*r^2*h)\n    - calculate_volume('hemisphere', 3)\n      # Returns: 56.548667764616276 (Volume of a hemisphere using V=(2/3)*pi*r^3)\n    - calculate_volume('cone', 3, 4)\n      # Returns: 37.69911184307752 (Volume of a cone using V=(1/3)*pi*r^2*h)\n    \"\"\"\n    if shape == 'cylinder':\n        return math.pi * radius ** 2 * height\n    elif shape == 'hemisphere':\n        return (2 / 3) * math.pi * radius ** 3\n    elif shape == 'cone':\n        return (1 / 3) * math.pi * radius ** 2 * height\n    else:\n        raise ValueError(\"Invalid shape provided. Use 'cylinder', 'hemisphere', or 'cone'.\")", "def volume_from_face_areas(area1, area2, area3):\n    \"\"\"\n    Calculates the volume of a rectangular prism using the areas of its faces.\n    Here, it's assumed that:\n    - area1 = length * width\n    - area2 = width * height\n    - area3 = length * height\n    Parameters:\n    - area1 (float): Area of the first face (length x width).\n    - area2 (float): Area of the second face (width x height).\n    - area3 (float): Area of the third face (length x height).\n    Returns:\n    - float: The calculated volume of the rectangular prism if the solution is found, otherwise None.\n    Example:\n    >>> volume_from_face_areas(24, 30, 20)\n    60.0\n    \"\"\"\n    def equations(p):\n        L, W, H = p\n        return (L*W - area1, W*H - area2, L*H - area3)\n    \n    initial_guess = (np.sqrt(area1), np.sqrt(area2), np.sqrt(area3))\n    solution = fsolve(equations, initial_guess)\n    \n    # Check if all derived equations are almost close to zero for correctness\n    if np.allclose(np.array(equations(solution)), [0.0, 0.0, 0.0], atol=1e-6):\n        return solution[0] * solution[1] * solution[2]\n    else:\n        return None", "def calculate_rectangle_area(length, width):\n    \"\"\"\n    Calculate the area of a rectangle.\n    Parameters:\n    length (float): The length of the rectangle.\n    width (float): The width of the rectangle.\n    Returns:\n    float: The area of the rectangle.\n    Example:\n    >>> calculate_rectangle_area(5, 6)\n    30\n    \"\"\"\n    return length * width", "def volume_of_tetrahedron_from_base_and_height(base_area, height):\n    \"\"\"\n    Calculate the volume of a tetrahedron from the area of its base and its height.\n    \n    Parameters:\n        base_area (float): The area of the base of the tetrahedron.\n        height (float): The height from the base to the opposite vertex.\n    \n    Returns:\n        float: The volume of the tetrahedron.\n    \n    Examples:\n        >>> base_area = 0.5\n        >>> height = 1\n        >>> volume_of_tetrahedron_from_base_and_height(base_area, height)\n        0.16666666666666666\n    \"\"\"\n    return (1/3) * base_area * height", "def volume_cube(edge_length):\n    \"\"\"\n    Calculate the volume of a cube given its edge length.\n    Parameters:\n    edge_length (float): The edge length of the cube.\n    Returns:\n    float: The volume of the cube.\n    Examples:\n    >>> volume_cube(2)\n    8\n    \"\"\"\n    return edge_length ** 3", "def volume_of_tetrahedron_from_vertices(v1, v2, v3, v4):\n    \"\"\"\n    Calculate the volume of a tetrahedron given the coordinates of its vertices.\n    \n    Parameters:\n    - v1, v2, v3, v4 (array-like): Coordinates of the vertices of the tetrahedron.\n                                   Each should be an iterable of length 3 (x, y, z coordinates).\n    \n    Returns:\n    - float: The volume of the tetrahedron.\n    \n    Example:\n    >>> volume_of_tetrahedron_from_vertices([0,0,0], [1,0,0], [0,1,0], [0,0,1])\n    0.16666666666666666\n    \"\"\"\n    matrix = np.array([\n        [v1[0]-v4[0], v1[1]-v4[1], v1[2]-v4[2]],\n        [v2[0]-v4[0], v2[1]-v4[1], v2[2]-v4[2]],\n        [v3[0]-v4[0], v3[1]-v4[1], v3[2]-v4[2]]\n    ])\n    return abs(np.linalg.det(matrix) / 6)", "def volume_of_regular_octahedron(edge_length):\n    \"\"\"\n    Calculate the volume of a regular octahedron given its edge length.\n    Parameters:\n    - edge_length: The length of an edge of the octahedron (float or int).\n    Returns:\n    - The volume of the regular octahedron (float).\n    Example:\n    >>> volume_of_regular_octahedron(3)\n    3.181980515339464\n    \"\"\"\n    return (1/3) * math.sqrt(2) * edge_length**3", "def volume_rectangular_parallelepiped(length, width, height):\n    \"\"\"\n    Calculates the volume of a rectangular parallelepiped (box).\n    \n    Parameters:\n    - length (float): Length of the parallelepiped.\n    - width (float): Width of the parallelepiped.\n    - height (float): Height of the parallelepiped.\n    \n    Returns:\n    - float: The volume of the rectangular parallelepiped.\n    \n    Examples:\n    >>> volume_rectangular_parallelepiped(2, 3, 4)\n    24\n    \"\"\"\n    return length * width * height", "def area_square(side):\n    \"\"\"\n    Compute the area of a square given the side length.\n    Parameters:\n    side (float): The length of one side of the square.\n    Returns:\n    float: The area of the square.\n    Example:\n    >>> area_square(4)\n    16\n    \"\"\"\n    return side ** 2", "def calculate_volume(shape_type, dimensions):\n    \"\"\"\n    Calculate the volume of various geometric solids based on given parameters.\n    \n    Parameters:\n        shape_type (str): Type of shape (\"sphere\", \"rectangular_prism\", \"cube\", \"octahedron\")\n        dimensions (dict): A dictionary containing the required dimensions:\n                           For a sphere: {'radius': r}\n                           For a rectangular prism: {'length': l, 'width': w, 'height': h}\n                           For a cube: {'edge_length': a}\n                           For an octahedron: {'edge_length': a}\n    Returns:\n        float: The volume of the geometric solid.\n    \n    Examples:\n        calculate_volume(\"sphere\", {\"radius\": 3})\n        calculate_volume(\"rectangular_prism\", {\"length\": 5, \"width\": 3, \"height\": 2})\n        calculate_volume(\"cube\", {\"edge_length\": 4})\n        calculate_volume(\"octahedron\", {\"edge_length\": 5})\n    \"\"\"\n    if shape_type == \"sphere\":\n        radius = dimensions[\"radius\"]\n        return (4/3) * math.pi * radius ** 3\n    elif shape_type == \"rectangular_prism\":\n        length = dimensions[\"length\"]\n        width = dimensions[\"width\"]\n        height = dimensions[\"height\"]\n        return length * width * height\n    elif shape_type == \"cube\":\n        edge_length = dimensions[\"edge_length\"]\n        return edge_length ** 3\n    elif shape_type == \"octahedron\":\n        edge_length = dimensions[\"edge_length\"]\n        return (math.sqrt(2) / 3) * edge_length ** 3\n    else:\n        raise ValueError(\"Invalid shape type provided\")", "def surface_area_of_rectangular_prism(length, width, height):\n    \"\"\"\n    Calculate the surface area of a rectangular prism.\n    Parameters:\n    length (float or int): Length of the rectangular prism.\n    width (float or int): Width of the rectangular prism.\n    height (float or int): Height of the rectangular prism.\n    Returns:\n    float: The surface area of the rectangular prism.\n    Examples:\n    >>> surface_area_of_rectangular_prism(10, 4, 5)\n    220.0\n    >>> surface_area_of_rectangular_prism(7.5, 3.5, 1.5)\n    82.5\n    \"\"\"\n    return 2 * (length * width + width * height + height * length)", "def remaining_volume(main_volume, subtracted_volume):\n    \"\"\"\n    Calculate the remaining volume after subtracting one volume from another.\n    Parameters:\n    main_volume (float): The initial main volume.\n    subtracted_volume (float): The volume to subtract.\n    Returns:\n    float: The remaining volume.\n    Examples:\n    >>> remaining_volume(100, 30)\n    70\n    \"\"\"\n    return main_volume - subtracted_volume", "def volume_rectangular_box(length, width, height):\n    \"\"\"\n    Calculate the volume of a rectangular box.\n    Parameters:\n    length (float): Length of the box.\n    width (float): Width of the box.\n    height (float): Height of the box.\n    Returns:\n    float: Volume of the rectangular box.\n    Examples:\n    >>> volume_rectangular_box(2, 3, 4)\n    24\n    \"\"\"\n    return length * width * height", "def volume_difference(volume1, volume2):\n    \"\"\"\n    Calculate the difference in volumes between two solids.\n    \n    Parameters:\n    volume1 (float): Volume of the first solid.\n    volume2 (float): Volume of the second solid.\n    \n    Returns:\n    float: The difference in volumes, ensuring it's non-negative.\n    \n    Example:\n    >>> volume_difference(50, 27)\n    23.0\n    \"\"\"\n    return abs(volume1 - volume2)", "def subtract_volumes(volume1, volume2):\n    \"\"\"\n    Calculate the remaining volume after one volume is subtracted from another.\n    \n    Parameters:\n    volume1 (float): The initial or larger volume.\n    volume2 (float): The volume to subtract from the initial volume.\n    \n    Returns:\n    float: The remaining volume after subtraction.\n    \n    Examples:\n    >>> subtract_volumes(100, 50.26548245743669)\n    49.73451754256331\n    \"\"\"\n    return max(volume1 - volume2, 0)  # Ensure non-negative result", "def volume_frustum(total_volume, removed_volume):\n    \"\"\"\n    Compute the volume of a frustum by subtracting the volume of a smaller shape removed from a larger solid.\n    Parameters:\n    total_volume (float): The original volume of the larger solid before the smaller volume was removed.\n    removed_volume (float): The volume of the smaller solid that was removed.\n    Returns:\n    float: The volume of the frustum.\n    Example:\n    >>> volume_frustum(200, 50)\n    150\n    \"\"\"\n    return total_volume - removed_volume", "def dihedral_angle_between_planes(plane1_normal, plane2_normal):\n    \"\"\"\n    Calculate the dihedral angle between two planes given their normal vectors.\n    Parameters:\n        plane1_normal (list of float): the normal vector of the first plane.\n        plane2_normal (list of float): the normal vector of the second plane.\n    Returns:\n        float: the dihedral angle in radians between the two planes.\n    Examples:\n        >>> dihedral_angle_between_planes([0, 0, 1], [0, 1, 0])\n        1.5707963267948966\n    \"\"\"\n    n1 = sp.Matrix(plane1_normal)\n    n2 = sp.Matrix(plane2_normal)\n    return sp.acos(n1.dot(n2) / (n1.norm() * n2.norm()))", "def derive_dimensions_by_volume(total_volume, ratio, initial_dimension):\n    \"\"\"\n    Derive the dimensions of a rectangular solid where the dimensions are in geometric progression,\n    given the total volume and a progression ratio.\n    Parameters:\n    - total_volume (float): The total volume of the solid.\n    - ratio (float): The common ratio in the geometric progression of the dimensions.\n    - initial_dimension (float): The initial dimension for the geometric progression (commonly the smallest dimension).\n    Returns:\n    - tuple (float, float, float): Returns the dimensions (length, width, height) of the rectangular solid.\n    Example:\n    >>> derive_dimensions_by_volume(216.0, 2, 3.0)\n    (3.0, 6.0, 12.0)\n    \"\"\"\n    import math\n    # Using the formula for volume of rectangular solids: V = lwh\n    # and for geometric progression if l = a, w = ar, h = ar^2 then V = a * ar * ar^2 = a^3 * r^3\n    # Solving for 'a' we get a = (V / r^3)^(1/3)\n    a = (total_volume / (ratio ** 3)) ** (1/3)\n    length = a\n    width = a * ratio\n    height = a * (ratio ** 2)\n    return (length, width, height)", "def volume_composite_shapes(*volumes):\n    \"\"\"\n    Sum multiple volumes to calculate the total volume of a composite shape.\n    Parameters:\n    - volumes (list of float): A list of individual volumes of the composite shape.\n    Returns:\n    - float: The total volume of the composite shape.\n    Examples:\n    >>> volume_composite_shapes(24.0, 27.0, 15.707963267948967)\n    66.70796326794897\n    \"\"\"\n    return sum(volumes)", "class SolidVolumeCalculator:\n    \"\"\" Class to calculate the volumes of various 3D solids.\n    Methods\n    -------\n    cylinder_volume(radius, height)\n        Calculate the volume of a cylinder.\n    \n    tetrahedron_volume(side_length)\n        Calculate the volume of a regular tetrahedron.\n    pyramid_volume(base_area, height)\n        Calculate the volume of a pyramid.\n    solid_of_revolution(f, a, b)\n        Calculate the volume of a solid of revolution of the function f from x=a to x=b about the x-axis.\n    \"\"\"\n    @staticmethod\n    def cylinder_volume(radius, height):\n        \"\"\"\n        Calculate the volume of a right circular cylinder.\n        Parameters:\n        radius (float or sympy.Symbol): The radius of the cylinder.\n        height (float or sympy.Symbol): The height of the cylinder.\n        Returns:\n        float or sympy.Expr: The volume of the cylinder.\n        Example:\n        >>> SolidVolumeCalculator.cylinder_volume(3, 5)\n        141.3716694115407\n        \"\"\"\n        return math.pi * radius**2 * height\n    @staticmethod\n    def tetrahedron_volume(side_length):\n        \"\"\"\n        Calculate the volume of a regular tetrahedron.\n        Parameters:\n        side_length (float or sympy.Symbol): The length of a side of the tetrahedron.\n        Returns:\n        float or sympy.Expr: The volume of the tetrahedron.\n        Example:\n        >>> SolidVolumeCalculator.tetrahedron_volume(2)\n        0.9428090415820632\n        \"\"\"\n        return side_length**3 / (6 * math.sqrt(2))\n    @staticmethod\n    def pyramid_volume(base_area, height):\n        \"\"\"\n        Calculate the volume of a pyramid with a given base area and height.\n        Parameters:\n        base_area (float or sympy.Symbol): The area of the pyramid's base.\n        height (float or sympy.Symbol): The height of the pyramid.\n        Returns:\n        float or sympy.Expr: The volume of the pyramid.\n        Example:\n        >>> SolidVolumeCalculator.pyramid_volume(10, 3)\n        10.0\n        \"\"\"\n        return base_area * height / 3\n    \n    @staticmethod\n    def solid_of_revolution(f, a, b):\n        \"\"\"\n        Calculate the volume of the solid of revolution of a function f from x=a to x=b about the x-axis.\n        Parameters:\n        f (sympy function): A sympy function of x.\n        a (float or sympo.Symbol): The start of the interval of revolution.\n        b (float or sympy.Symbol): The end of the interval of revolution.\n        Returns:\n        float or sympy.Expr: The volume of the solid of revolution.\n        Example:\n        >>> x = sympy.symbols('x')\n        >>> f = sympy.Lambda(x, sympy.sqrt(1 - x**2))\n        >>> SolidVolumeCalculator.solid_of_revolution(f, -1, 1)\n        (4/3)*pi\n        \"\"\"\n        x = sympy.symbols('x')\n        return sympy.pi * sympy.integrate(f(x)**2, (x, a, b))", "def volume_of_tetrahedron(side):\n    \"\"\"\n    Calculate the volume of a regular tetrahedron given its side length.\n    Parameters:\n    - side (float or Symbol): The length of a side of the tetrahedron.\n    Returns:\n    - sympy expression: The calculated volume of the tetrahedron.\n    Examples:\n    >>> s = symbols('s')\n    >>> volume_of_tetrahedron(s)\n    s**3*sqrt(2)/12\n    \"\"\"\n    return side**3 * sqrt(2) / 12", "def cube_root(value):\n    \"\"\"\n    Compute the cube root of a given value.\n    Parameters:\n    - value: The value to compute the cube root of (float or int).\n    Returns:\n    - The cube root of the given value (float).\n    Example:\n    >>> cube_root(27)\n    3.0\n    \"\"\"\n    return value ** (1/3)", "def volume_of_revolution(func, axis, start, end):\n    \"\"\"\n    Calculate the volume of a solid of revolution by rotating a function about an axis.\n    Parameters:\n    - func (function): Function of x defining the shape to be revolved.\n    - axis (str): Axis about which the shape is revolved ('x' or 'y').\n    - start (float or Symbol): The start of the interval of revolution.\n    - end (float or Symbol): The end of the interval of revolution.\n    Returns:\n    - sympy expression: The volume of the solid of revolution.\n    Examples:\n    >>> x = symbols('x')\n    >>> f = x**2\n    >>> volume_of_revolution(f, 'x', 0, 2)\n    8*pi/5*2**5\n    \"\"\"\n    x = Symbol(\"x\")\n    if axis == 'x':\n        return pi * integrate(func**2, (x, start, end))\n    else:\n        # Assuming rotation around the y-axis is the integral of pi*r^2 dx where r = f^-1(y)\n        y = Symbol(\"y\")\n        inverse_func = func.subs(x, y)  # assuming func is invertible and expressed in terms of y\n        return pi * integrate(inverse_func**2, (y, start, end))", "def pythagorean_theorem(a=None, b=None, c=None):\n    \"\"\"\n    Calculate the length of a side of a right triangle using the Pythagorean theorem given the lengths of the other two sides.\n    Parameters:\n    a (float, optional): Length of one side of the right triangle.\n    b (float, optional): Length of the other side of the right triangle.\n    c (float, optional): Length of the hypotenuse of the right triangle.\n    Returns:\n    float: The length of the missing side.\n    Example:\n    >>> pythagorean_theorem(a=3, c=5)\n    4.0\n    >>> pythagorean_theorem(b=4, c=5)\n    3.0\n    \"\"\"\n    import math\n    if c is None:  # if hypotenuse is missing\n        return math.sqrt(a**2 + b**2)\n    if a is None:  # if one side is missing\n        return math.sqrt(c**2 - b**2)\n    if b is None:  # if the other side is missing\n        return math.sqrt(c**2 - a**2)", "def find_missing_dimension(volume, length=None, width=None, height=None):\n    \"\"\"\n    Given the volume and any two dimensions of a rectangular prism, calculate the missing dimension.\n    Parameters:\n    volume (float or int): The volume of the rectangular solid.\n    length (float or int, optional): The length of the rectangular solid. Defaults to None.\n    width (float or int, optional): The width of the rectangular solid. Defaults to None.\n    height (float or int, optional): The height of the rectangular solid. Defaults to None.\n    Returns:\n    float: The missing dimension of the rectangular solid.\n    Examples:\n    >>> find_missing_dimension(100, length=10, width=5)\n    2.0\n    >>> find_missing_dimension(36, height=1.5, width=3.2)\n    7.5\n    \"\"\"\n    if length is None:\n        missing_dimension = volume / (width * height)\n    elif width is None:\n        missing_dimension = volume / (length * height)\n    elif height is None:\n        missing_dimension = volume / (length * width)\n    else:\n        raise ValueError(\"Only one dimension should be missing.\")\n    return missing_dimension"], "Perimeter": ["def calculate_polygon_perimeter(side_lengths):\n    \"\"\"\n    Calculate the perimeter of a polygon given the lengths of its sides.\n    \n    Parameters:\n    side_lengths (list or tuple of floats/integers): The lengths of the sides of the polygon.\n    \n    Returns:\n    float: The perimeter of the polygon.\n    \n    Examples:\n    >>> calculate_polygon_perimeter([5, 5, 5, 5])  # Perimeter of a square\n    20\n    >>> calculate_polygon_perimeter([3, 4, 5])  # Perimeter of a triangle\n    12\n    \"\"\"\n    return sum(side_lengths)", "def calculate_perimeter_square(side_length):\n    \"\"\"\n    Calculate the perimeter of a square.\n    \n    Parameters:\n    side_length (float): The length of a side of the square.\n    \n    Returns:\n    float: The perimeter of the square.\n    \n    Examples:\n    >>> calculate_perimeter_square(5)\n    20\n    >>> calculate_perimeter_square(7.25)\n    29.0\n    \"\"\"\n    if side_length < 0:\n        raise ValueError(\"Side length must be non-negative\")\n    return 4 * side_length", "def calculate_perimeter(shape, *dimensions):\n    \"\"\"\n    Calculate the perimeter of various common geometric shapes.\n    \n    Parameters:\n    - shape (str): The type of shape ('square', 'rectangle', 'circle', or 'regular_polygon').\n    - dimensions (tuple of floats): Dimensions of the shape; this could be side length for a square,\n      length and width for a rectangle, radius for a circle, or side length and number of sides for a regular polygon.\n    \n    Returns:\n    float: The perimeter of the given shape.\n    \n    Examples:\n    >>> calculate_perimeter('square', 5)\n    20\n    >>> calculate_perimeter('rectangle', 5, 7)\n    24\n    >>> calculate_perimeter('circle', 3)\n    18.84955592153876\n    >>> calculate_perimeter('regular_polygon', 6, 5)  # A regular pentagon with side length 6\n    30\n    \"\"\"\n    if shape == 'square':\n        return 4 * dimensions[0]\n    elif shape == 'rectangle':\n        return 2 * (dimensions[0] + dimensions[1])\n    elif shape == 'circle':\n        return 2 * math.pi * dimensions[0]\n    elif shape == 'regular_polygon':\n        n_sides, side_length = dimensions\n        return n_sides * side_length\n    else:\n        raise ValueError(\"Unsupported shape type provided.\")", "def calculate_perimeter_rectangle(length, width):\n    \"\"\"\n    Calculate the perimeter of a rectangle.\n    \n    Parameters:\n    length (float): The length of the rectangle.\n    width (float): The width of the rectangle.\n    \n    Returns:\n    float: The perimeter of the rectangle.\n    \n    Examples:\n    >>> calculate_perimeter_rectangle(10, 5)\n    30\n    >>> calculate_perimeter_rectangle(8.0, 3.5)\n    23.0\n    \"\"\"\n    if length < 0 or width < 0:\n        raise ValueError(\"Length and width must be non-negative\")\n    return 2 * (length + width)", "def calculate_composite_shape_perimeter(regions):\n    \"\"\"\n    Calculate the perimeter of a composite shape given the perimeters of individual segments and internal overlaps.\n    \n    Parameters:\n    regions (list of dicts): Each dict represents a region with keys 'perimeter' for external perimeter, \n                             and 'internal_overlap' for the length subtracted due to internal overlaps.\n    \n    Returns:\n    float: The effective external perimeter of the composite shape, accounting for overlaps.\n    \n    Examples:\n    >>> calculate_composite_shape_perimeter([{'perimeter': 20, 'internal_overlap': 0}, {'perimeter': 30, 'internal_overlap': 5}])\n    45\n    >>> calculate_composite_shape_perimeter([{'perimeter': 10, 'internal_overlap': 1}, {'perimeter': 15, 'internal_overlap': 2}])\n    22\n    \"\"\"\n    total_perimeter = 0\n    for region in regions:\n        total_perimeter += (region['perimeter'] - region['internal_overlap'])\n    return total_perimeter", "def calculate_perimeter_circle(radius):\n    \"\"\"\n    Calculate the perimeter (circumference) of a circle.\n    \n    Parameters:\n    radius (float): The radius of the circle.\n    \n    Returns:\n    float: The circumference of the circle.\n    \n    Examples:\n    >>> calculate_perimeter_circle(4)\n    25.132741228718345\n    >>> calculate_perimeter_circle(5.5)\n    34.55751918948773\n    \"\"\"\n    if radius < 0:\n        raise ValueError(\"Radius must be non-negative\")\n    return 2 * pi * radius"], "3D Shapes": ["def point_distance(p1, p2):\n    \"\"\"\n    Calculate Euclidean distance between points p1 and p2 in 3D space.\n    \n    Parameters:\n    - p1, p2 (iterable with three numbers - list, tuple): Coordinates of the points p1 and p2.\n    \n    Returns:\n    - float: Euclidean distance between points p1 and p2.\n    \n    Example:\n    >>> point_distance((1, 2, 3), (4, 6, 8))\n    7.483314773547883\n    \"\"\"\n    return np.linalg.norm(np.array(p1) - np.array(p2))", "def surface_area_cube(side):\n    \"\"\"\n    Calculate the surface area of a cube.\n    Parameters:\n    - side : float\n        The length of a side of the cube.\n    Returns:\n    - float\n        The total surface area of the cube.\n    Examples:\n    >>> surface_area_cube(2)\n    24\n    \"\"\"\n    return 6 * (side**2)", "def volume_cylinder(radius, height):\n    \"\"\"\n    Calculate the volume of a cylinder.\n    \n    Parameters:\n    - radius (float): The radius of the cylinder.\n    - height (float): The height of the cylinder.\n    \n    Returns:\n    - float: The volume of the cylinder.\n    \n    Example:\n    >>> volume_cylinder(1, 2)\n    6.283185307179586\n    \"\"\"\n    return pi * radius ** 2 * height", "def cylinder_lateral_surface_area(radius, height):\n    \"\"\"\n    Calculate the lateral surface area of a cylinder.\n    \n    Parameters:\n    radius (float): The radius of the cylinder.\n    height (float): The height of the cylinder.\n    \n    Returns:\n    float: The lateral surface area of the cylinder.\n    Example:\n    >>> cylinder_lateral_surface_area(3, 5)\n    94.24777960769379\n    \"\"\"\n    return 2 * math.pi * radius * height", "def cube_face_diagonal(side_length):\n    \"\"\"\n    Calculate the length of the face diagonal of a cube.\n    \n    Parameters:\n    side_length (float): The length of a side of the cube.\n    \n    Returns:\n    float: The length of the face diagonal of the cube.\n    \n    Example:\n    >>> cube_face_diagonal(2)\n    2.8284271247461903\n    \"\"\"\n    return math.sqrt(2) * side_length", "def cube_properties(side_length):\n    \"\"\"\n    Calculate properties of a cube given its side length.\n    Parameters:\n    - side_length (float): The length of a side of the cube.\n    Returns:\n    - dict: Dictionary containing properties like volume, surface area, face diagonal, and space diagonal.\n    \n    Examples:\n    >>> cube_properties(2)\n    {'volume': 8, 'surface_area': 24, 'face_diagonal': 2.83, 'space_diagonal': 3.46}\n    \"\"\"\n    volume = side_length ** 3\n    surface_area = 6 * (side_length ** 2)\n    face_diagonal = np.sqrt(2) * side_length\n    space_diagonal = np.sqrt(3) * side_length\n    return {\n        \"volume\": volume,\n        \"surface_area\": surface_area,\n        \"face_diagonal\": round(face_diagonal, 2),\n        \"space_diagonal\": round(space_diagonal, 2)\n    }", "def geometric_properties_3d(shape_type, dimensions):\n    \"\"\"\n    Calculate basic geometric properties (faces, edges, vertices) for 3D shapes such as various prisms and pyramids.\n    Parameters:\n    shape_type (str): Type of the 3D shape ('triangular_prism', 'rectangular_prism', 'square_prism', 'pyramid').\n    dimensions (dict): Dimensions of the 3D shape. For prisms: {'base_edges': int, 'height': float}.\n                       For pyramids: {'base_edges': int, 'side_edges': int, 'height': float}.\n    \n    Returns:\n    dict: Dictionary containing number of faces, edges, and vertices.\n    \n    Examples:\n    >>> geometric_properties_3d('triangular_prism', {'base_edges': 3, 'height': 10})\n    {'faces': 5, 'edges': 9, 'vertices': 6}\n    \n    >>> geometric_properties_3d('pyramid', {'base_edges': 4, 'side_edges': 4, 'height': 9})\n    {'faces': 5, 'edges': 8, 'vertices': 5}\n    \"\"\"\n    if shape_type in ['triangular_prism', 'rectangular_prism', 'square_prism']:\n        base_edges = dimensions['base_edges']\n        faces = 2 + base_edges\n        edges = 3 * base_edges\n        vertices = 2 * base_edges\n    elif shape_type == 'pyramid':\n        base_edges = dimensions['base_edges']\n        faces = base_edges + 1\n        edges = 2 * base_edges\n        vertices = base_edges + 1\n    else:\n        raise ValueError(\"Unsupported shape_type provided.\")\n    \n    return {'faces': faces, 'edges': edges, 'vertices': vertices}", "def surface_area_volume(shape_type, dimensions):\n    \"\"\"\n    Calculate the surface area and volume for common 3D shapes such as prisms and pyramids based on provided dimensions.\n    Parameters:\n    shape_type (str): Type of the 3D shape ('triangular_prism', 'rectangular_prism', 'pyramid').\n    dimensions (dict): Dimensions necessary for calculations. Prisms: {'length': float, 'width': float, 'height': float}.\n                       Pyramid: {'base_length': float, 'base_width': float, 'height': float}.\n    Returns:\n    dict: Dictionary containing 'surface_area' and 'volume' of the shape.\n    Examples:\n    >>> surface_area_volume('rectangular_prism', {'length': 2, 'width': 3, 'height': 4})\n    {'surface_area': 52.0, 'volume': 24.0}\n    \n    >>> surface_area_volume('pyramid', {'base_length': 4, 'base_width': 4, 'height': 6})\n    {'surface_area': 52.624, 'volume': 32.0}\n    \"\"\"\n    if shape_type == 'rectangular_prism':\n        l, w, h = dimensions['length'], dimensions['width'], dimensions['height']\n        surface_area = 2 * (l * w + l * h + w * h)\n        volume = l * w * h\n    elif shape_type == 'pyramid':\n        l, w, h = dimensions['base_length'], dimensions['width'], dimensions['height']\n        base_area = l * w\n        surface_area = l * w + l * sqrt((w/2)**2 + h**2) + w * sqrt((l/2)**2 + h**2)\n        volume = (l * w * h) / 3\n    else:\n        raise ValueError(\"Invalid shape type provided.\")\n    return {'surface_area': surface_area, 'volume': volume}", "def cube_volume(side_length):\n    \"\"\"\n    Calculate the volume of a cube.\n    \n    Parameters:\n    side_length (float): The length of a side of the cube.\n    \n    Returns:\n    float: The volume of the cube.\n    \n    Example:\n    >>> cube_volume(3)\n    27\n    \"\"\"\n    return side_length ** 3", "def pyramid_properties(base_side, height):\n    \"\"\"\n    Calculate properties of a square base pyramid.\n    Parameters:\n    - base_side (float): The length of one side of the square base.\n    - height (float): The height of the pyramid from the base to the apex.\n    Returns:\n    - dict: Dictionary containing properties like volume and slant height.\n    \n    Examples:\n    >>> pyramid_properties(3, 4)\n    {'volume': 12.0, 'slant_height': 5.0}\n    \"\"\"\n    base_area = base_side ** 2\n    volume = (1/3) * base_area * height\n    slant_height = np.sqrt((base_side/2) ** 2 + height ** 2)\n    return {\n        \"volume\": volume,\n        \"slant_height\": round(slant_height, 2)\n    }", "def cone_volume(radius, height):\n    \"\"\"\n    Calculate the volume of a right circular cone.\n    \n    Parameters:\n    radius : float\n        Radius of the base of the cone.\n    height : float\n        Height of the cone.\n    \n    Returns:\n    float\n        Volume of the cone.\n    \n    Examples:\n    >>> cone_volume(3, 4)\n    37.69911184307752\n    \"\"\"\n    return (1 / 3) * np.pi * radius ** 2 * height", "def calculate_frustum_properties(r1, r2, h):\n    \"\"\"\n    Calculate properties of a frustum formed by truncation of a right circular cone.\n    Parameters\n    ----------\n    r1 : float\n        Radius of the smaller circular base.\n    r2 : float\n        Radius of the larger circular base.\n    h : float\n        Height of the frustum (the distance between the two bases).\n    Returns\n    -------\n    dict :\n        A dictionary containing:\n            - lateral_surface_area : float\n                The lateral surface area of the frustum.\n            - total_surface_area : float\n                The total surface area of the frustum (including the areas of the two bases).\n            - volume : float\n                The volume of the frustum.\n    Examples\n    --------\n    >>> calculate_frustum_properties(3, 5, 7)\n    {\n        'lateral_surface_area': 150.079644737231,\n        'total_surface_area': 276.46015351590174,\n        'volume': 345.5774616441417\n    }\n    \"\"\"\n    lateral_area = math.pi * (r1 + r2) * math.sqrt((r2 - r1) ** 2 + h ** 2)\n    total_area = lateral_area + math.pi * (r1 ** 2 + r2 ** 2)\n    volume = (1 / 3) * math.pi * h * (r1 ** 2 + r2 ** 2 + r1 * r2)\n    \n    return {\n        'lateral_surface_area': lateral_area,\n        'total_surface_area': total_area,\n        'volume': volume,\n    }", "def midpoint(p1, p2):\n    \"\"\"\n    Calculate the midpoint between two points in 3D space.\n    Parameters:\n    - p1 : tuple of floats\n        Coordinates of the first point (x1, y1, z1).\n    - p2 : tuple of floats\n        Coordinates of the second point (x2, y2, z2).\n    Returns:\n    - tuple of floats\n        The midpoint coordinates (mx, my, mz).\n    Examples:\n    >>> midpoint((1, 1, 1), (3, 5, 3))\n    (2.0, 3.0, 2.0)\n    \"\"\"\n    return ((p1[0] + p2[0]) / 2, (p1[1] + p2[1]) / 2, (p1[2] + p2[2]) / 2)", "def volume_cube(edge_length):\n    \"\"\"\n    Calculate the volume of a cube given the length of one edge.\n    \n    Parameters:\n    - edge_length (float/int): The length of one edge of the cube.\n    \n    Returns:\n    - float: The volume of the cube.\n    \n    Example:\n    >>> volume_cube(3)\n    27\n    \"\"\"\n    return edge_length ** 3", "def rotate_point(point, axis, theta):\n    \"\"\"\n    Rotate a point around a given axis by theta degrees in 3D space.\n    Parameters:\n        point (array-like): The [x, y, z] coordinates of the point to rotate.\n        axis (array-like): The [x, y, z] coordinates of the axis to rotate about.\n        theta (float): The rotation angle in degrees.\n    Returns:\n        array: The new [x, y, z] coordinates of the rotated point.\n    Examples:\n        >>> rotate_point([1, 0, 0], [0, 0, 1], 90)\n        array([6.123234e-17, 1.000000e+00, 0.000000e+00])\n    \"\"\"\n    axis = np.array(axis)\n    theta = np.radians(theta)\n    axis = axis / np.linalg.norm(axis)\n    a = np.cos(theta / 2)\n    b, c, d = -axis * np.sin(theta / 2)\n    aa, bb, cc, dd = a**2, b**2, c**2, d**2\n    bc, ad, ac, ab, bd, cd = b*c, a*d, a*c, a*b, b*d, c*d\n    rot_matrix = np.array([[aa+bb-cc-dd, 2*(bc+ad), 2*(bd-ac)],\n                           [2*(bc-ad), aa+cc-bb-dd, 2*(cd+ab)],\n                           [2*(bd+ac), 2*(cd-ab), aa+dd-bb-cc]])\n    return np.dot(rot_matrix, point)", "def count_unit_cubes_with_painted_faces(n, faces_painted):\n    \"\"\"\n    Calculate the number of unit cubes with a certain number of painted faces in an n x n x n cube.\n    \n    Parameters:\n    n (int): The side length of the cube in terms of number of unit cubes.\n    faces_painted (int): The number of faces that are painted on the unit cubes.\n    \n    Returns:\n    int: The count of unit cubes with exactly the specified number of painted faces.\n    \n    Example:\n    >>> count_unit_cubes_with_painted_faces(3, 1)\n    6\n    \"\"\"\n    if faces_painted == 1:\n        return 6 * (n - 2)\n    elif faces_painted == 2:\n        return 12 * (n - 2)\n    elif faces_painted == 3:\n        return 8\n    return 0", "def line_plane_intersection(plane_normal, plane_point, line_point, line_dir):\n    \"\"\"\n    Calculate the intersection point of a line and a plane in 3D.\n    \n    Parameters:\n    - plane_normal (iterable with three numbers): Normal vector of the plane.\n    - plane_point (iterable with three numbers): A point on the plane.\n    - line_point (iterable with three numbers): A point on the line.\n    - line_dir (iterable with three numbers): Direction vector of the line.\n    \n    Returns:\n    - array: The coordinates of the intersection point or None if no intersection exists.\n    \n    Example:\n    >>> line_plane_intersection([0, 0, 1], [0, 0, 5], [1, 1, 0], [0, 1, 1])\n    array([1., 4., 5.])\n    \"\"\"\n    plane_normal = np.array(plane_normal)\n    plane_point = np.array(plane_point)\n    line_point = np.array(line_point)\n    line_dir = np.array(line_dir)\n    denom = np.dot(plane_normal, line_dir)\n    if np.abs(denom) < 1e-6:\n        return None  # No intersection, the line is parallel to the plane\n    t = (np.dot(plane_normal, plane_point - line_point)) / denom\n    return line_point + t * line_dir", "def surface_area_cube(edge_length):\n    \"\"\"\n    Calculate the surface area of a cube given the length of its edge.\n    \n    Parameters:\n    - edge_length (float/int): The length of one edge of the cube.\n    \n    Returns:\n    - float: The surface area of the cube.\n    \n    Example:\n    >>> surface_area_cube(2)\n    24\n    \"\"\"\n    return 6 * (edge_length ** 2)", "def prism_properties(num_bases, base_vertices, height_exists=True):\n    \"\"\"\n    Calculate the properties (vertices, edges, faces) of a prism given \n    the properties of the base and whether it includes a height (for right prisms).\n    Parameters:\n    - num_bases (int): The number of identical bases the prism has (usually 2).\n    - base_vertices (int): The number of vertices on each base.\n    - height_exists (bool): True if the prism has a distinct height dimension (right prism), otherwise False.\n    Returns:\n    - dict: Dictionary containing number of vertices, edges, and faces.\n    Examples:\n    >>> prism_properties(2, 4)  # Rectangular prism\n    {'vertices': 8, 'edges': 12, 'faces': 6}\n    >>> prism_properties(2, 3)  # Triangular prism\n    {'vertices': 6, 'edges': 9, 'faces': 5}\n    \"\"\"\n    vertices = num_bases * base_vertices\n    edges = num_bases * base_vertices + base_vertices * (num_bases - 1)\n    faces = num_bases + (height_exists * base_vertices)\n    return {\n        'vertices': vertices,\n        'edges': edges,\n        'faces': faces\n    }", "def frustum_volume(radius1, radius2, height):\n    \"\"\"\n    Calculate the volume of a conical frustum.\n    \n    Parameters:\n    radius1 : float\n        Radius of the lower base of the frustum.\n    radius2 : float\n        Radius of the upper base of the frustum.\n    height : float\n        Height of the frustum.\n    \n    Returns:\n    float\n        Volume of the frustum.\n    \n    Examples:\n    >>> frustum_volume(3, 2, 5)\n    65.97344572538566\n    \"\"\"\n    return (1 / 3) * np.pi * height * (radius1**2 + radius1*radius2 + radius2**2)", "def volume_pyramid(base_area, height):\n    \"\"\"\n    Calculate the volume of a pyramid.\n    Parameters:\n    - base_area : float\n        The area of the pyramid's base.\n    - height : float\n        The height of the pyramid from the base to the apex.\n    Returns:\n    - float\n        The volume of the pyramid.\n    Examples:\n    >>> volume_pyramid(9, 12)\n    36\n    \"\"\"\n    return (1/3) * base_area * height", "def find_centroid_of_tetrahedron(vertex1, vertex2, vertex3, vertex4):\n    \"\"\"\n    Find the centroid of a tetrahedron given its vertices.\n    Parameters\n    ----------\n    vertex1 : tuple of float\n        Coordinates of the first vertex (x1, y1, z1).\n    vertex2 : tuple of float\n        Coordinates of the second vertex (x2, y2, z2).\n    vertex3 : tuple of float\n        Coordinates of the third vertex (x3, y3, z3).\n    vertex4 : tuple of float\n        Coordinates of the fourth vertex (x4, y4, z4).\n    Returns\n    -------\n    tuple :\n        The coordinates of the centroid.\n    Examples\n    --------\n    >>> find_centroid_of_tetrahedron((0, 0, 0), (1, 0, 0), (0, 1, 0), (0, 0, 1))\n    (0.25, 0.25, 0.25)\n    \"\"\"\n    x = (vertex1[0] + vertex2[0] + vertex3[0] + vertex4[0]) / 4\n    y = (vertex1[1] + vertex2[1] + vertex3[1] + vertex4[1]) / 4\n    z = (vertex1[2] + vertex2[2] + vertex3[2] + vertex4[2]) / 4\n    \n    return (x, y, z)", "def pythagoras_theorem(a, b):\n    \"\"\"\n    Calculate the hypotenuse of a right triangle given the other two sides.\n    Parameters:\n    a : float\n        Length of one side of the right triangle.\n    b : float\n        Length of the other side of the right triangle.\n    Returns:\n    float\n        Length of the hypotenuse.\n        \n    Examples:\n    >>> pythagoras_theorem(3, 4)\n    5.0\n    \"\"\"\n    return np.sqrt(a**2 + b**2)", "def sphere_surface_area(radius):\n    \"\"\"\n    Calculate the surface area of a sphere.\n    \n    Parameters:\n    - radius (float): The radius of the sphere.\n    \n    Returns:\n    - float: The total surface area of the sphere.\n    \n    Example:\n    >>> sphere_surface_area(2)\n    50.26548245743669\n    \"\"\"\n    return 4 * pi * radius ** 2", "def volume_polyhedron(points):\n    \"\"\"\n    Calculate the volume of a convex polyhedron defined by its vertices.\n    Parameters:\n        points (array-like): A list of vertices of the polyhedron, where each vertex is a list [x, y, z].\n    Returns:\n        float: Volume of the polyhedron.\n    \n    Examples:\n        >>> volume_polyhedron([[0, 0, 0], [1, 0, 0], [0, 1, 0], [0, 0, 1]])\n        0.16666666666666666\n    \"\"\"\n    hull = ConvexHull(points)\n    return hull.volume", "def relations_between_cube_and_sphere(cube_side):\n    \"\"\"\n    Calculate the relationship between a cube and an inscribed sphere.\n    Parameters:\n        cube_side (float): The length of the side of the cube.\n    Returns:\n        float: The radius of the sphere inscribed in the cube.\n    Example:\n        >>> relations_between_cube_and_sphere(4)\n        2.0\n    \"\"\"\n    return cube_side / 2", "def calculate_tetrahedron_properties(edge_length):\n    \"\"\"\n    Calculate properties of a regular tetrahedron.\n    Parameters\n    ----------\n    edge_length : float\n        The length of one edge of the tetrahedron.\n    Returns\n    -------\n    dict :\n        A dictionary containing:\n            - face_area : float\n                The area of one of the triangular faces.\n            - total_surface_area : float\n                The total surface area of the tetrahedron.\n            - volume : float\n                The volume of the tetrahedron.\n    Examples\n    --------\n    >>> calculate_tetrahedron_properties(3)\n    {\n        'face_area': 3.8971143170299753,\n        'total_surface_area': 15.588457268119901,\n        'volume': 3.1819805153394633\n    }\n    \"\"\"\n    face_area = (math.sqrt(3) / 4) * edge_length ** 2\n    total_surface_area = 4 * face_area\n    volume = (edge_length ** 3) / (6 * math.sqrt(2))\n    \n    return {\n        'face_area': face_area,\n        'total_surface_area': total_surface_area,\n        'volume': volume,\n    }", "def inscribed_sphere_diameter(side_length):\n    \"\"\"\n    Calculate the diameter of a sphere inscribed in a cube.\n    \n    Parameters:\n    side_length : float\n        The length of a side of the cube.\n    \n    Returns:\n    float\n        The diameter of the inscribed sphere.\n    Examples:\n    >>> diameter = inscribed_sphere_diameter(10)\n    >>> print(diameter)\n    10.0\n    \"\"\"\n    return side_length  # Diameter of inscribed sphere is equal to the side length of the cube.", "def plane_from_points(p1, p2, p3):\n    \"\"\"\n    Determine the equation of a plane given three points in 3D space.\n    \n    Parameters:\n        p1, p2, p3 (array-like): Coordinates of three points in the plane.\n    Returns:\n        array: Coefficients of the plane equation ax + by + cz + d = 0\n    \n    Examples:\n        >>> plane_from_points([0, 0, 0], [1, 0, 0], [0, 1, 0])\n        (array([0., 0., 1.]), -0.0)\n    \"\"\"\n    p1, p2, p3 = np.array(p1), np.array(p2), np.array(p3)\n    v1 = p2 - p1\n    v2 = p3 - p1\n    normal = np.cross(v1, v2)\n    d = -np.dot(normal, p1)\n    return normal, d", "def cube_cut_paint_faces(total_cubes, painted_cubes, side_cubes):\n    \"\"\"\n    Calculate the total faces painted after cutting a larger cube into\n    smaller unit cubes.\n    \n    Parameters:\n    total_cubes : int\n        Total number of smaller cubes after cutting.\n    painted_cubes : int\n        Number of painted cubes.\n    side_cubes : int\n        Number of cubes along one edge of the cube.\n    \n    Returns:\n    int\n        The number of faces that are painted.\n    \n    Examples:\n    >>> faces_painted = cube_cut_paint_faces(27, 26, 3)\n    >>> print(faces_painted)\n    54\n    \"\"\"\n    # Assuming the large cube is painted on all faces and then cut.\n    # Cubes at the center of a face only have one painted face.\n    face_center_cubes = 6 * (side_cubes - 2)**2\n    # Cubes at the edge but not corners have 2 painted faces.\n    edge_cubes = 12 * (side_cubes - 2)\n    # Corner cubes", "def subtask_reconstruction_from_projections(projections):\n    \"\"\"\n    Estimate the minimum number of unit cubes needed to match given 2D projections.\n    Parameters:\n        projections (list of list): Projections of the 3D object in terms of unit cubes per axis.\n    Returns:\n        int: Minimum number of unit cubes necessary to form the 3D shape.\n    Example:\n        >>> subtask_reconstruction_from_projections([[1, 2], [2, 1], [1, 3]])\n        6\n    \"\"\"\n    # For simplicity and lack of context, I'll return the sum of the maximums of each projection\n    return sum(max(proj) for proj in projections)"], "Transformations": ["def reflect_point(point, axis, position=0):\n    \"\"\"\n    Reflect a point across a specified axis.\n    Parameters:\n    point : tuple\n        The (x, y) coordinates of the point to reflect.\n    axis : str\n        The axis across which to reflect ('x' or 'y').\n    position : float, optional\n        The position of the axis of reflection (default is 0 for either axis).\n        \n    Returns:\n    tuple\n        The reflected (x, y) coordinates.\n        \n    Examples:\n    >>> reflect_point((2, 3), 'y')\n    (-2, 3)\n    >>> reflect_point((3, 4), 'x', 2)\n    (3, 0)\n    \"\"\"\n    x, y = point\n    if axis.lower() == 'y':\n        return (2*position - x, y)\n    elif axis.lower() == 'x':\n        return (x, 2*position - y)\n    else:\n        raise ValueError(\"Axis must be 'x' or 'y'.\")", "def rotate_point(point, angle, origin=(0, 0)):\n    \"\"\"\n    Rotate a point around a given origin by a specific angle.\n    Parameters:\n    - point (tuple): The coordinates (x, y) of the point.\n    - angle (float): The rotation angle in degrees.\n    - origin (tuple): The origin around which the point is rotated.\n    Returns:\n    - tuple: The coordinates of the rotated point.\n    \n    Examples:\n    - rotate_point((1, 0), 90) will rotate (1,0) by 90 degrees around the origin, resulting in (0,1).\n    - rotate_point((0, 1), 90, (1, 1)) will rotate (0,1) by 90 degrees around (1,1), resulting in (1,0).\n    \"\"\"\n    angle_rad = np.radians(angle)\n    sin_a, cos_a = np.sin(angle_rad), np.cos(angle_rad)\n    x, y = point\n    ox, oy = origin\n    # Translate point to origin\n    x -= ox\n    y -= oy\n    # Rotate point\n    x_new = x * cos_a - y * sin_a\n    y_new = x * sin_a + y * cos_a\n    # Translate point back\n    x_new += ox\n    y_new += oy\n    return (x_new, y_new)", "def area_of_triangle(base, height):\n    \"\"\"\n    Calculates the area of a triangle using base and height.\n    Parameters:\n    - base (float): The base of the triangle.\n    - height (float): The height of the triangle.\n    Returns:\n    - float: The area of the triangle (1/2 * base * height).\n    \n    Examples:\n    >>> area_of_triangle(3, 4)\n    6.0\n    \"\"\"\n    return 0.5 * base * height", "def area_of_rectangle(length, breadth):\n    \"\"\"\n    Calculates the area of a rectangle.\n    Parameters:\n    - length (float): The length of the rectangle.\n    - breadth (float): The breadth of the rectangle.\n    Returns:\n    - float: The area of the rectangle.\n    \n    Examples:\n    >>> area_of_rectangle(4, 5)\n    20.0\n    \"\"\"\n    return length * breadth", "def translate_point(point, vector):\n    \"\"\"\n    Translate a point by a given vector.\n    Parameters:\n    point : tuple\n        The (x, y) coordinates of the point to translate.\n    vector : tuple\n        The (dx, dy) translation vector.\n        \n    Returns:\n    tuple\n        The translated (x, y) coordinates.\n    \n    Examples:\n    >>> translate_point((1, 2), (3, 1))\n    (4, 3)\n    \"\"\"\n    x, y = point\n    dx, dy = vector\n    return (x + dx, y + dy)", "def translate_point(point, shift):\n    \"\"\"\n    Translates a point by a given shift in the coordinate plane.\n    Parameters\n    ----------\n    point : tuple of float\n        (x, y) coordinates of the point to be translated.\n    shift : tuple of float\n        (dx, dy) values by which the point should be shifted horizontally and vertically.\n    Returns\n    -------\n    tuple of float\n        New coordinates of the translated point.\n    Examples\n    --------\n    >>> translate_point((1, 2), (3, -1))\n    (4, 1)\n    \"\"\"\n    x_new, y_new = point[0] + shift[0], point[1] + shift[1]\n    return (x_new, y_new)", "def rotate(shape, angle, origin=np.array([0, 0])):\n    \"\"\"\n    Rotate a shape counterclockwise by a given angle around an origin.\n    Parameters:\n    shape (np.array): An Nx2 numpy array of points representing the shape.\n    angle (float): Angle of rotation in degrees.\n    origin (np.array, optional): 1x2 numpy array representing the rotation origin. Defaults to the origin.\n    Returns:\n    np.array: Rotated shape as an Nx2 numpy array.\n    Example:\n    >>> rotate(np.array([[1, 0], [0, 1]]), 90)\n    array([[ 0.,  1.],\n           [-1.,  0.]])\n    \"\"\"\n    rad = np.deg2rad(angle)\n    rotation_matrix = np.array([[np.cos(rad), -np.sin(rad)], [np.sin(rad), np.cos(rad)]])\n    return np.dot(shape - origin, rotation_matrix) + origin", "def apply_affine_transformation(point, matrix, translation_vector=(0, 0)):\n    \"\"\"\n    Apply an affine transformation to a 2D point using a transformation matrix and optional translation.\n    Parameters:\n    - point (tuple): A tuple (x, y) representing the coordinates of the initial point.\n    - matrix (array): A 2x2 numpy array representing the rotation or scaling matrix.\n    - translation_vector (tuple): A tuple (dx, dy) representing the translation.\n    Returns:\n    - tuple: Coordinates of the transformed point.\n    Example:\n    >>> apply_affine_transformation((1, 0), np.array([[0, -1], [1, 0]]), (1, 1))\n    (1, 2)\n    \"\"\"\n    transformed_point = np.dot(matrix, np.array(point)) + np.array(translation_vector)\n    return tuple(transformed_point)", "def calculate_distance(point1, point2, is_complex=False):\n    \"\"\"\n    Calculate the Euclidean distance between two points in the plane.\n    Parameters:\n    - point1, point2 (tuple or complex): The points between which distance is calculated.\n      Each point can either be a tuple (x, y) in Cartesian coordinates or a complex number.\n    - is_complex (bool): Whether the points are specified as complex numbers.\n    Returns:\n    - float: The calculated Euclidean distance.\n    Example:\n    >>> calculate_distance((1, 2), (4, 6))\n    5.0\n    >>> calculate_distance(1+2j, 4+6j, is_dateinline=True)\n    5.0\n    \"\"\"\n    if is_complex:\n        return abs(point1 - point2)\n    else:\n        return np.sqrt((point1[0] - point2[0])**2 + (point1[1] - point2[1])**2)", "def translate(shape, vector):\n    \"\"\"\n    Apply a translation to a geometric shape.\n    Parameters:\n    shape (np.array): An Nx2 numpy array representing points of the shape in 2D (each row is a point).\n    vector (np.array): A 1x2 numpy array representing the translation vector.\n    Returns:\n    np.array: Translated shape as an Nx2 numpy array.\n    Example:\n    >>> translate(np.array([[0, 0], [1, 0], [1, 1]]), np.array([2, 3]))\n    array([[2, 3], [3, 3], [3, 4]])\n    \"\"\"\n    return shape + vector", "def reflect(shape, axis):\n    \"\"\"\n    Reflect a shape across a specified axis.\n    Parameters:\n    shape (np.array): An Nx2 numpy array of points.\n    axis (int): Axis to reflect across. 0 for y-axis, 1 for x-axis.\n    Returns:\n    np.array: Reflected shape as an Nx2 numpy array.\n    Example:\n    >>> reflect(np.array([[1, 1], [-1, 1]]), 0)\n    array([[-1,  1],\n           [ 1,  1]])\n    \"\"\"\n    reflected_shape = np.copy(shape)\n    reflected_shape[:, axis] = -reflected_shape[:, axis]\n    return reflected_shape", "def reflect_point_over_line(point, line_coefficients):\n    \"\"\"\n    Calculate the reflection of a point across a line represented in standard form.\n    Parameters:\n    - point (tuple): A tuple (x, y) representing the coordinates of the point to reflect.\n    - line_coefficients (tuple): A tuple (A, B, C) representing the line Ax + By + C = 0.\n    Returns:\n    - tuple: Coordinates of the reflected point.\n    Example:\n    >>> reflect_point_over_line((1, 1), (1, -1, 0)) \n    (1, 1)\n    \"\"\"\n    x, y = point\n    A, B, C = line_coefficients\n    D = A * A + B * B\n    x_prime = (B * B * x - A * B * y - A * C) / D\n    y_prime = (A * A * y - A * B * x - B * C) / D\n    return (x_prime, y_prime)"], "Squares": ["def square_area(side_length):\n    \"\"\"\n    Calculate the area of a square given the side length.\n    \n    Parameters:\n    side_length : float\n        The side length of the square.\n        \n    Returns:\n    float\n        The area of the square.\n    \n    Examples:\n    >>> square_area(5)\n    25\n    \"\"\"\n    return side_length ** 2", "def square_perimeter(side_length):\n    \"\"\"\n    Calculate the perimeter of a square given the side length.\n    \n    Parameters:\n    side_length : float\n        The length of the side of the square.\n        \n    Returns:\n    float\n        The perimeter of the square.\n    \n    Examples:\n    >>> square_perimeter(5)\n    20\n    \"\"\"\n    return 4 * side_length", "def calculate_square_diagonal(side_length):\n    \"\"\"\n    Calculate the diagonal of a square using the side length.\n    \n    Parameters:\n    - side_length (float): The length of the side of the square.\n    \n    Returns:\n    - float: The length of the diagonal of the square.\n    \n    Example:\n    >>> calculate_square_diagonal(4)\n    5.656854249492381\n    \"\"\"\n    return side_length * math.sqrt(2)", "def calculate_ratio_of_areas(side_length1, side_length2):\n    \"\"\"\n    Calculate the ratio of the areas of two squares given their side lengths.\n    \n    Parameters:\n    side_length1 (float): The side length of the first square.\n    side_length2 (float): The side length of the second square.\n    \n    Returns:\n    float: The ratio of the area of the first square to the area of the second square.\n    \n    Examples:\n    >>> calculate_ratio_of_areas(4, 2)\n    4.0\n    \"\"\"\n    return (side_length1 ** 2) / (side_length2 ** 2)", "def calculate_square_properties(side_length):\n    \"\"\"\n    Calculate various properties of a square, including area, perimeter, and diagonal.\n    Parameters:\n    - side_length (float): The length of a side of the square.\n    Returns:\n    - dict: A dictionary containing the area, perimeter, and diagonal length of the square.\n    Examples:\n    >>> calculate_square_properties(4)\n    {'area': 16, 'perimeter': 16, 'diagonal': 5.656854249492381}\n    \"\"\"\n    area = side_length ** 2\n    perimeter = 4 * side_length\n    diagonal = math.sqrt(2) * side_length\n    \n    return {\n        'area': area,\n        'perimeter': perimeter,\n        'diagonal': diagonal\n    }", "def calculate_inscribed_circle_radius(side_length):\n    \"\"\"\n    Calculate the radius of a circle inscribed in a square.\n    \n    Parameters:\n    - side_length (float): The length of the side of the square.\n    \n    Returns:\n    - float: The radius of the inscribed circle.\n    \n    Example:\n    >>> calculate_inscribed_circle_radius(4)\n    2.0\n    \"\"\"\n    return side_length / 2", "def count_inscribed_squares(larger_square_side, smaller_square_side):\n    \"\"\"\n    Calculate how many smaller squares of a given side length can be inscribed within a larger square.\n    \n    Parameters:\n    larger_square_side (float): The side length of the larger square.\n    smaller_square_side (float): The side length of the smaller squares to fit inside the larger square.\n    \n    Returns:\n    int: Number of smaller squares that can fit inside the larger square.\n    \n    Examples:\n    >>> count_inscribed_squares(10, 2)\n    25\n    \"\"\"\n    num_per_side = larger_square_side // smaller_square_side\n    return num_per_side ** 2", "def number_of_squares(total_length, square_side):\n    \"\"\"\n    Calculate the maximum number of non-overlapping squares that can fit along a line of given total length.\n    Parameters:\n    - total_length (float): The total length of the line.\n    - square_side (float): The side length of each square.\n    Returns:\n    - int: The total number of non-overlapping squares that can fit.\n    Examples:\n    >>> number_of_squares(10, 2)\n    5\n    \"\"\"\n    return total_length // square_side", "def number_of_smaller_squares_in_larger_one(larger_side, smaller_side):\n    \"\"\"\n    Calculate the number of smaller squares that can fit within a larger square\n    based on the side lengths of the larger and smaller squares.\n    \n    Parameters:\n    larger_side : float\n        The side length of the larger square.\n    smaller_side : float\n        The side length of the smaller square.\n        \n    Returns:\n    int\n        The maximum number of smaller squares that can fit in the larger square.\n    \n    Examples:\n    >>> number_of_smaller_squares_in_larger_one(10, 2)\n    25\n    \"\"\"\n    return (larger_side // smaller_side) ** 2"], "Planes in Three Dimensions": ["def plane_from_normal_and_point(normal, point):\n    \"\"\"\n    Define the plane equation given a normal vector and a point through which the plane passes.\n    \n    Parameters:\n        normal (tuple): Normal vector of the plane (A, B, C).\n        point (tuple): A point (x0, y0, z0) on the plane.\n    \n    Returns:\n        sympy.Poly: The equation of the plane in symbolic form (Ax + By + Cz + D).\n    \n    Example:\n        >>> plane_from_normal_and_point((1, 2, 1), (3, 4, 5))\n        Poly(1*x + 2*y + 1*z - 14, x, y, z, domain='ZZ')\n    \"\"\"\n    x, y, z = sp.symbols('x y z')\n    A, B, C = normal\n    D = sp.simplify(-(A*point[0] + B*point[1] + C*point[2]))\n    plane_eq = A*x + B*y + C*z + D\n    return sp.Poly(plane_eq, x, y, z)", "def distance_point_to_plane(point, plane):\n    \"\"\"\n    Calculate the perpendicular distance from a point to a given plane in 3D space.\n    Parameters:\n        point (tuple): The (x, y, z) coordinates of the point.\n        plane (tuple): The coefficients (A, B, C, D) of the plane equation Ax + By + Cz + D = 0\n    Returns:\n        float: The distance from the point to the plane.\n    \n    Example:\n        >>> distance_point_to_plane((1, 1, 1), (0, 0, 1, -1))\n        2.0\n    \"\"\"\n    x0, y0, z0 = point\n    A, B, C, D = plane\n    num = abs(A*x0 + B*y0 + C*z0 + D)\n    den = np.sqrt(A**2 + B**2 + C**2)\n    return num / den", "def are_planes_parallel(plane1, plane2):\n    \"\"\"\n    Determines if two planes are parallel.\n    Parameters:\n        plane1, plane2 (tuple): The coefficients (A, B, C, D) of the plane equations\n    Returns:\n        bool: True if the planes are parallel, otherwise False\n    \n    Example:\n        >>> are_planes_parallel((0, 0, 1, 2), (0, 0, 1, 3))\n        True\n    \"\"\"\n    A1, B1, C1, _ = plane1\n    A2, B2, C2, _ = plane2\n    cross_prod = np.cross((A1, B1, C1), (A2, B2, C2))\n    return np.allclose(cross_prod, (0, 0, 0))", "def plane_equation_from_points(p1, p2, p3):\n    \"\"\"\n    Determine the equation of a plane given three non-collinear points in 3D space.\n    Parameters:\n        p1, p2, p3 (tuple): Tuples of the form (x, y, z) representing the coordinates of the points.\n    Returns:\n        tuple: Returns the coefficients (A, B, C, D) of the plane equation Ax + By + Cz + D = 0\n    \n    Example:\n        >>> plane_equation_from_points((0,0,0), (1,0,0), (0,1,0))\n        (0, 0, 1, 0)\n    \"\"\"\n    p1, p2, p3 = np.array(p1), np.array(p2), np.array(p3)\n    v1 = p2 - p1\n    v2 = p3 - p1\n    normal_vector = np.cross(v1, v2)\n    A, B, C = normal_vector\n    D = -np.dot(normal_vector, p1)\n    return (A, B, C, D)", "def plane_normal_vector(point1, point2, point3):\n    \"\"\"\n    Finds the normal vector to a plane defined by three points.\n    \n    Parameters:\n        point1 (tuple): Coordinates of the first point.\n        point2 (tuple): Coordinates of the second point.\n        point3 (tuple): Coordinates of the third point.\n        \n    Returns:\n        tuple: Normal vector components (A, B, C) of the plane.\n        \n    Example:\n        >>> plane_normal_vector((1, 2, 3), (2, 3, 4), (4, 6, 7))\n        (2, -5, 2)\n    \"\"\"\n    p1, p2, p3 = sp.Matrix(point1), sp.Matrix(point2), sp.Matrix(point3)\n    normal = (p2 - p1).cross(p3 - p1)\n    return tuple(normal)", "def check_point_on_plane(point, plane_coeffs):\n    \"\"\"\n    Check if a point is on a plane defined by the given equation.\n    Parameters:\n    - point (tuple/list): Coordinates of the point (x, y, z).\n    - plane_coeffs (tuple/list): Plane equation coefficients (A, B, C, D).\n    \n    Returns:\n    - bool: True if the point is on the plane, else False.\n    \n    Examples:\n    >>> check_point_on_plane((1, 2, 3), (1, 1, 1, -6))\n    True\n    \"\"\"\n    A, B, C, D = plane_coeffs\n    x, y, z = point\n    return abs(A * x + B * y + C * z + D) < 1e-10"], "Similar Triangles": ["def triangles_are_similar_by_aa(angle1_tri1, angle2_tri1, angle1_tri2, angle2_tri2):\n    \"\"\"\n    Determine whether two triangles are similar based on the Angle-Angle (AA) similarity condition.\n    Parameters:\n    angle1_tri1 (float): First angle of the first triangle in degrees.\n    angle2_tri1 (float): Second angle of the first triangle in degrees.\n    angle1_tri2 (float): First angle of the second triangle in degrees.\n    angle2_tri2 (float): Second angle of the second triangle in degrees.\n    Returns:\n    bool: True if the triangles are similar, False otherwise.\n    Examples:\n    >>> triangles_are_similar_by_aa(45, 90, 45, 90)\n    True\n    >>> triangles_are_similar_by_aa(45, 85, 50, 90)\n    False\n    \"\"\"\n    # Check if two sets of angles match the AA criterion\n    similar_aa1 = angle1_tri1 == angle1_tri2 and angle2_tri1 == angle2_tri2\n    similar_aa2 = angle1_tri1 == angle2_tri2 and angle2_tri1 == angle1_tri2\n    return similar_aa1 or similar_aa2", "def compute_similar_triangle_sides(base_sides, ratio):\n    \"\"\"\n    Given the side lengths of a triangle and a ratio of similarity, compute the side lengths of the similar triangle.\n    Parameters:\n    - base_sides (tuple): A tuple representing the lengths of the sides (float) of the base triangle.\n    - ratio (float): The ratio of the sides of the similar triangle compared to the base triangle.\n    Returns:\n    - similar_sides (tuple): The lengths of the sides of the similar triangle.\n    Example:\n    >>> compute_similar_triangle_sides((3, 4, 5), 2)\n    (6, 8, 10)\n    \"\"\"\n    return tuple([side * ratio for side in base_sides])", "def calculate_area_and_perimeter_ratios(sides1, sides2):\n    \"\"\"\n    Calculate the ratios of areas and perimeters between two similar triangles based on side lengths.\n    Parameters:\n        sides1 (list of float): Sides of the first triangle. \n        sides2 (list of float): Sides of the second triangle.\n    Returns:\n        tuple:\n            - float: Ratio of areas (area of triangle 2 / area of triangle 1).\n            - float: Ratio of perimeters (perimeter of triangle 2 / perimeter of triangle 1).\n    \n    Examples:\n    >>> calculate_area_and_perimeter_ratios([3, 3, 3], [6, 6, 6])\n    (4.0, 2.0)\n    \"\"\"\n    sides_ratio = [s2 / s1 for s1, s2 in zip(sides1, sides2)]\n    perimeter_ratio = sum(sides2) / sum(sides1)\n    area_ratio = np.mean(sides_ratio) ** 2  # (scale factor)^2 for areas in similar triangles\n    \n    return (area_ratio, perimeter_ratio)", "def calculate_similar_triangle_perimeter(original_perimeter, scale_factor):\n    \"\"\"\n    Calculate the perimeter of a similar triangle given the original perimeter and the scale factor.\n    \n    Parameters:\n    - original_perimeter (float): Perimeter of the original triangle.\n    - scale_factor (float): Ratio of the similar triangle's side length to the original.\n    \n    Returns:\n    - float: The perimeter of the similar triangle.\n    \n    Examples:\n    >>> calculate_similar_triangle_perimeter(30, 0.5)\n    15.0\n    \"\"\"\n    return original_perimeter * scale_factor", "def calculate_ratio(lengths_triangle1, lengths_triangle2):\n    \"\"\"\n    Calculate the corresponding side length ratios between two similar triangles.\n    \n    Parameters:\n    - lengths_triangle1 (list of float): The list of side lengths of the first triangle.\n    - lengths_triangle2 (list of float): The list of side lengths of the second triangle.\n    Returns:\n    - tuple of float: Tuple of ratios of corresponding sides.\n    Examples:\n    - calculate_ratio([3, 4, 5], [6, 8, 10]) returns (2.0, 2.0, 2.0)\n    \"\"\"\n    return tuple(b / a for a, b in zip(lengths_triangle1, lengths_triangle2))", "def calculate_area_of_triangle(base, height):\n    \"\"\"\n    Calculate the area of a triangle given base and height.\n    \n    Parameters:\n    - base (float): The length of the base of the triangle.\n    - height (float): The height of the triangle.\n    \n    Returns:\n    - float: The calculated area of the triangle.\n    \n    Examples:\n    >>> calculate_area_of_triangle(10, 5)\n    25.0\n    \"\"\"\n    return 0.5 * base * height", "def check_similarity_and_calculate_sides(angles1, sides1, angles2, sides2):\n    \"\"\"\n    Checks if two triangles are similar based on given sides and angles,\n    and calculates the missing side if the triangles are similar and some sides are missing.\n    \n    Parameters:\n        angles1 (list of float): Angles of the first triangle.\n        sides1 (list of float or None): Sides of the first triangle, use None for missing sides.\n        angles2 (list of float): Angles of the second triangle.\n        sides2 (list of float or None): Sides of the second triangle, use None for missing sides.\n    Returns:\n        tuple:\n            - bool: Whether the triangles are similar.\n            - list: New sides1 array with calculated sides if applicable.\n            - list: New sides2 array with calculated sides if applicable.\n    Examples:\n    >>> check_similarity_and_calculate_sides([60, 60, 60], [3, 3, 3], [60, 60, 60], [6, None, None])\n    (True, [3, 3, 3], [6, 6, 6])\n    \"\"\"\n    # Check for angle similarity (Angle-Angle)\n    if sorted(angles1) != sorted(angles2):\n        return (False, sides1, sides2)\n    \n    scale_factor = None\n    # Find scale factor from the non-None sides\n    for s1, s2 in zip(sides1, sides2):\n        if s1 is not None and s2 is not None:\n            scale_factor = s2 / s1\n            break\n    \n    # Calculate missing sides using the scale factor\n    if scale_factor is not None:\n        sides1 = [s if s is not None else s2 / scale_factor for s, s2 in zip(sides1, sides2)]\n        sides2 = [s if s is not None else s1 * scale_factor for s1, s in zip(sides1, sides2)]\n    \n    return (True, sides1, sides2)", "def missing_sides_of_similar_triangles(sides_known_triangle, sides_partial_triangle, ratio):\n    \"\"\"\n    Compute missing side lengths in a similar triangle given side lengths of another triangle and the ratio.\n    Parameters:\n    - sides_known_triangle (list): List of three side lengths of the fully known triangle.\n    - sides_partial_triangle (list): List of side lengths of the similar triangle, with None for unknown sides.\n    - ratio (float): The ratio of similarity between two triangles.\n    Returns:\n    - list: A list containing the computed side lengths of the similar triangle.\n    Examples:\n    >>> missing_sides_of_similar_triangles([3, 4, 5], [1.5, None, None], 0.5)\n    [1.5, 2.0, 2.5]\n    \"\"\"\n    computed_sides = []\n    for known, partial in zip(sides_known_triangle, sides_partial_triangle):\n        if partial is None:\n            computed_sides.append(known * ratio)\n        else:\n            computed_sides.append(partial)\n    return computed_sides", "def area_ratio_from_side_ratio(side_ratio):\n    \"\"\"\n    Given the ratio of the sides of similar triangles, compute the ratio of their areas.\n    \n    Parameters:\n    - side_ratio (float): The common ratio of corresponding sides of the triangles.\n    \n    Returns:\n    - float: The ratio of the areas of the triangles.\n    \n    Examples:\n    - area_ratio_from_side_ratio(2) returns 4\n    \"\"\"\n    return side_ratio ** 2", "def find_missing_sides_length(sides_tri1, known_side_tri2, missing_side_name_tri1):\n    \"\"\"\n    Calculate the unknown sides in similar triangles using known side lengths of one triangle and at least one side of the other triangle.\n    Parameters:\n    sides_tri1 (dict): Dictionary with known sides of the first triangle labeled as 'a', 'b', 'c'.\n    known_side_tri2 (tuple): A tuple with label and length of the known side of the second triangle, e.g., ('a', value).\n    missing_side_name_tri1 (str): The label of the side in the first triangle whose length needs to be determined.\n    Returns:\n    float: Length of the missing side.\n    Examples:\n    >>> find_missing_sides_length({'a': 12, 'b': 16, 'c': 20}, ('a', 6), 'b')\n    8.0\n    \"\"\"\n    label, length_side_tri2 = known_side_tri2\n    k = length_side_tri2 / sides_tri1[label]  # k is the scale factor between the triangles\n    return sides_tri1[missing_side_name_tri1] * k"], "Pythagorean Theorem": ["def calculate_leg(hypotenuse, known_leg):\n    \"\"\"\n    Calculate the missing leg in a right triangle given the length of the hypotenuse and the other leg using the Pythagorean theorem.\n    Parameters:\n    - hypotenuse : float\n        Length of the hypotenuse (the longest side of the right triangle).\n    - known_leg : float\n        Length of the known leg (one of the sides of the right triangle).\n    Returns:\n    - expression\n        Length of the unknown leg. The result is simplified and returned in radical form if applicable.\n    Examples:\n    >>> calculate_leg(13, 5)\n    12\n    >>> calculate_leg(5, 3)\n    4*sqrt(1/2) (simplified radical form)\n    \"\"\"\n    if hypotenuse <= known_leg:\n        raise ValueError(\"Hypotenuse must be the longest side in a right triangle.\")\n    \n    # Calculating the missing leg\n    missing_leg_squared = hypotenuse**2 - known_leg**2\n    # Return the simplified radical form if necessary\n    return sympy.sqrt(missing_leg_squared).simplify()", "def simplify_radical(expression):\n    \"\"\"\n    Simplifies square roots to their simplest radical form using symbolic computation.\n    Parameters:\n    expression : float\n        The expression (usually a square root) to be simplified.\n    Returns:\n    str\n        The simplified expression in radical form.\n    Examples:\n    >>> simplify_radical(8)\n    '2*sqrt(2)'\n    >>> simplify_radical(18)\n    '3*sqrt(2)'\n    \"\"\"\n    return str(nsimplify(sqrt(expression)))"], "Reflections": ["def reflect_point_across_line(point, line_point, line_slope):\n    \"\"\"\n    Reflect a given point across a line defined by a point and a slope in 2D geometry.\n    Parameters:\n    point (tuple): A tuple (x, y) representing the coordinates of the point to be reflected.\n    line_point (tuple): A tuple (x, y) representing a point through which the line passes.\n    line_slope (float): The slope of the line.\n    Returns:\n    tuple: The reflected point's coordinates (x', y').\n    Example:\n    >>> reflect_point_across_line((3, 4), (1, 2), 2)\n    (-1, 0)\n    \"\"\"\n    x, y = sp.symbols('x y')\n    x0, y0 = point\n    x1, y1 = line_point\n    # Equation of the line: y - y1 = m*(x - x1)\n    m = line_slope\n    perp_slope = -1/m  # slope of the perpendicular line\n    # Equation of perpendicular from point (x0, y0) to the line: y - y0 = perp_slope*(x - x0)\n    # Intersection with the line:\n    intersection_x = sp.solve(y0 + perp_slope*(x - x0) - (y1 + m*(x - x1)), x)\n    intersection_y = y0 + perp_slope * (intersection_x[0] - x0)\n    # Calculating the reflected point\n    reflected_x = 2*intersection_x[0] - x0\n    reflected_y = 2*intersection_y - y0\n    return (reflected_x.evalf(), reflected_y.evalf())", "def reflect_across_x(points):\n    \"\"\"\n    Reflect points across the x-axis.\n    \n    Parameters:\n    - points (ndarray): an Nx2 numpy array of points where each row represents the coordinates (x, y).\n    Returns:\n    - ndarray: the reflected points as an Nx What data is returned? array.\n    Example:\n    >>> reflect_across_x(np.array([[1, 2], [3, -1], [0, 0]]))\n    array([[ 1, -2],\n           [ 3,  1],\n           [ 0,  0]])\n    \"\"\"\n    reflected_points = points.copy()\n    reflected_points[:, 1] = -reflected_points[:, 1]\n    return reflected_points", "def reflect_across_x(point):\n    \"\"\"\n    Reflect a point across the x-axis.\n    Parameters:\n    - point (tuple): A tuple containing the x and y coordinates of the point (x, y).\n    Returns:\n    - tuple: Coordinates of the reflected point (x, -y).\n    Examples:\n    >>> reflect_across_x((5, 3))\n    (5, -3)\n    \"\"\"\n    x, y = point\n    return (x, -y)", "def reflect_point_across_plane(point, plane_normal, plane_point):\n    \"\"\"\n    Reflects a point across a plane defined by a normal vector and a point on the plane.\n    Parameters:\n    point (tuple): The point to reflect, given as (x, y, z).\n    plane_normal (tuple): The normal vector of the plane, given as (x, y, z).\n    plane_point (tuple): A point on the plane, given as (x, y, z).\n    \n    Returns:\n    tuple: The reflected point coordinates (x, y, z).\n    Example:\n    >>> reflect_point_across_plane((1, 2, 3), (0, 0, 1), (0, 0, 0))\n    (1, 2, -3)\n    \"\"\"\n    # Convert to numpy arrays\n    p = np.array(point)\n    n = np.array(plane_normal)\n    m = np.array(plane_point)\n    \n    # Compute pm and normalize n\n    pm = p - m\n    n_norm = n / np.linalg.norm(n)\n    \n    # Distance from point to the plane\n    dist = np.dot(pm, n_norm)\n    \n    # Reflect point\n    reflected_point = p - 2 * dist * n_norm\n    return tuple(reflected_point)", "def sum_of_coordinates(points):\n    \"\"\"\n    Calculate the sum of x and y coordinates among a list of points.\n    \n    Parameters:\n        points (list of tuples): List of tuples, where each tuple represents a point (x, y).\n    \n    Returns:\n        tuple: Sum of x coordinates and sum of y coordinates (sum_x, sum_y).\n    \n    Examples:\n    >>> sum_of_coordinates([(1, 2), (3, -1), (0, 0)])\n    (4, 1)\n    \"\"\"\n    sum_x = sum(point[0] for point in points)\n    sum_y = sum(point[1] for point in points)\n    return (sum_x, sum_y)", "def reflect_vector(v, u):\n    \"\"\"\n    Compute the reflection of vector v over vector u in 2D space.\n    Parameters:\n    - v (array_like): The vector to be reflected. Must be a 1-D array of length 2.\n    - u (array_like): The vector (or axis) over which v is to be reflected. Must be a 1-D array of length 2.\n    Returns:\n    - numpy.ndarray: The reflected vector as a 1-dimensional numpy array of length 2.\n    Example:\n    >>> reflect_vector(np.array([1, 2]), np.array([0, 1]))\n    array([ 1, -2])\n    \"\"\"\n    v, u = np.asarray(v), np.asarray(u)\n    if v.shape != (2,) or u.shape != (2,):\n        raise ValueError(\"Both vectors v and u must be 1-D arrays of length 2.\")\n    # Calculate the projection of v onto u\n    projection_scale = np.dot(v, u) / np.dot(u, u)\n    projection = projection_scale * u\n    # Calculate the reflection\n    reflection = v - 2 * (projection - v)\n    return reflection", "def translate_points(points, translation_vector):\n    \"\"\"\n    Translate a set of points by a given vector.\n    \n    Parameters:\n    - points (ndarray): an Nx2 numpy array of points.\n    - translation_vector (ndarray or tuple): a vector (tx, ty) by which to translate each point.\n    \n    Returns:\n    - ndarray: the translated points.\n    \n    Example:\n    >>> translate_points(np.array([[1, 2], [3, 4]]), (1, -1))\n    array([[2, 1],\n           [4, 3]])\n    \"\"\"\n    return points + np.array(translation_vector)", "def reflect_point(point, axis=\"y-axis\"):\n    \"\"\"\n    Reflects a point across the specified axis or line.\n    \n    Parameters:\n        point (tuple): A tuple representing a point in 2D space, (x, y).\n        axis (str): A string specifying the axis or line to reflect across. Acceptable values are \"x-axis\", \"y-axis\", and \"y=x\".\n    Returns:\n        tuple: The reflected point in 2D space.\n    \n    Examples:\n    >>> reflect_point((3, 4), \"x-axis\")\n    (3, -4)\n    >>> reflect_point((3, 4), \"y-axis\")\n    (-3, 4)\n    >>> reflect_point((3, 4), \"y=x\")\n    (4, 3)\n    \"\"\"\n    x, y = point\n    if axis == \"x-axis\":\n        return (x, -y)\n    elif axis == \"y-axis\":\n        return (-x, y)\n    elif axis == \"y=x\":\n        return (y, x)\n    else:\n        raise ValueError(\"Invalid axis value. Choose 'x-axis', 'y-axis', or 'y=x'.\")", "def calculate_vector_projection(v, u):\n    \"\"\"\n    Calculate the projection of a vector v onto another vector u.\n    Parameters\n    ----------\n    v : array_like\n        The vector being projected, should be an iterable of two numbers.\n    u : array_by\n        The vector onto which v is being projected, should be an iterable of two numbers.\n    Returns\n    -------\n    np.array\n        The projection of vector v onto vector u.\n    Examples\n    --------\n    >>> calculate_vector_projection([1, 2], [2, 0])\n    array([1., 0.])\n    \"\"\"\n    v = np.array(v)\n    u = np.array(u)\n    return (np.dot(v, u) / np.dot(u, u)) * u", "def midpoint(point1, point2):\n    \"\"\"\n    Computes the midpoint between two points.\n    Parameters:\n    point1 (tuple): The first point, given as (x, y).\n    point2 (tuple): The second point, given as (:\n    \n    Returns:\n    tuple: Midpoint coordinates (x, y).\n    Example:\n    >>> midpoint((0,0), (2,2))\n    (1.0, 1.0)\n    \"\"\"\n    return tuple((np.array(point1) + np.array(point2)) / 2)", "def translate_point(point, dx, dy):\n    \"\"\"\n    Translate a point in the 2D space by given deltas.\n    \n    Parameters:\n        point (tuple): A tuple representing a point (x, y).\n        dx (float): The displacement along the x-axis.\n        dy (float): The displacement along the y-axis.\n    \n    Returns:\n        tuple: The translated point (new_x, new_y).\n    \n    Examples:\n    >>> translate_point((3, 4), 1, -1)\n    (4, 3)\n    \"\"\"\n    x, y = point\n    return (x + dx, y + dy)"], "Trapezoids": ["def calculate_trapezoid_area(b1, b2, height):\n    \"\"\"\n    Calculate the area of a trapezoid given its bases and height.\n    Parameters:\n    b1 (float): Length of the first base.\n    b2 (float): Length of the second base.\n    height (float): Height of the trapezoid from one base to the other.\n    Returns:\n    float: The area of the trapezoid.\n    Example:\n    >>> calculate_trapezoid_area(5, 3, 4)\n    16.0\n    \"\"\"\n    return (b1 + b2) * height / 2", "def midpoint_segment_length(base1, base2):\n    \"\"\"\n    Calculate the length of the segment joining the midpoints of the non-parallel sides of the trapezoid,\n    using the midpoint theorem, which states the segment is parallel and equal to the average of the two bases.\n    Parameters:\n    - base1 (float): Length of the first base of the trapezoid.\n    - base2 (float): Length of the second base of the trapezoid.\n    Returns:\n    - float: Length of the midpoint segment.\n    Examples:\n    >>> midpoint_segment_length(4, 6)\n    5.0\n    \"\"\"\n    return (base1 + base2) / 2", "def trapezoid_properties(is_isosceles=False):\n    \"\"\"\n    Provides a descriptive dict of properties of either a general or an isosceles trapezoid.\n    Parameters:\n    - is_isosceles (bool): Flag to determine if the properties of an isosceles trapezoid are returned.\n    Returns:\n    - dict: Dictionary containing relevant properties.\n    Examples:\n    >>> trapezoid_properties()\n    {'Parallel sides': 2, 'Non-parallel sides': 2, 'Sum of angles': 360}\n    >>> trapezoid_properties(True)\n    {'Parallel sides': 2, 'Non-parallel sides': 2, 'Equal legs': True, 'Sum of angles': 360}\n    \"\"\"\n    properties = {\n        'Parallel sides': 2,\n        'Non-parallel sides': 2,\n        'Sum of angles': 360\n    }\n    if is_isosceles:\n        properties['Equal legs'] = True\n    return properties", "def decompose_trapezoid(base1: float, base2: float, height: float):\n    \"\"\"\n    Decompose a trapezoid into simpler shapes: a rectangle and two right triangles, and return their dimensions.\n    Parameters:\n    - base1 (float): Length of the top base.\n    - base2 (float): Length of the bottom base, assumed to be longer than base1.\n    - height (float): The height of the trapezoid.\n    Returns:\n    - tuple: dimensions of rectangle (base, height), dimensions of triangle1, dimensions of triangle2.\n    Examples:\n    >>> decompose_trapezoid(6, 10, 5)\n    ((6, 5), (4, 5), (4, 5))\n    \"\"\"\n    rectangle_base = min(base1, base2)\n    triangle_base = abs(base2 - base1) / 2\n    return ((rectangle_base, height), (triangle_base, height), (triangle_base, height))"], "Angles": ["def calculate_clock_angle(hour, minute):\n    \"\"\"\n    Calculate the angle between the hour and minute hands on a clock at a given time.\n    Parameters:\n    - hour (int): The hour hand position, must be between 0 and 23 (for both 12-hour and 24-hour format)\n    - minute (int): The minute hand position, must be between 0 and 59\n    Returns:\n    - float: The smallest angle in degrees between the hour and minute hands.\n    Examples:\n    >>> calculate_clock_angle(3, 0)\n    90.0\n    >>> calculate_clock_angle(12, 30)\n    165.0\n    \"\"\"\n    import math\n    \n    # Normalize hour to fit within a 12-hour clock\n    hour %= 12\n    \n    # Position of the hour hand (each hour moves 30 degrees plus an additional movement due to minutes)\n    hour_angle = (hour + minute / 60) * 30\n    \n    # Position of the minute hand (each minute moves 6 degrees)\n    minute_angle = minute * 6\n    \n    # To find the smaller of the two possible angles\n    angle = abs(hour_angle - minute_angle)\n    # Smaller angle measured in degrees (clockwise angle or counter-clockwise angle)\n    return min(angle, 360 - angle)", "def is_complementary(angle1, angle2):\n    \"\"\"\n    Check if two angles are complementary (sum to 90 degrees).\n    \n    Parameters:\n        angle1 (float): The first angle in degrees.\n        angle2 (float): The second angle in degrees.\n        \n    Returns:\n        bool: True if the angles are complementary, else False.\n    \"\"\"\n    return (angle1 + angle2) == 90", "def angle_sum(n_sides):\n    \"\"\"\n    Calculate the sum of the interior angles of a polygon\n    \n    Parameters:\n        n_sides (int): The number of sides in the polygon.\n        \n    Returns:\n        int: Sum of the interior angles in degrees.\n        \n    Examples:\n        >>> angle_sum(3)\n        180\n        \n    Note:\n        The sum of the interior angles of a polygon is (n-2)*180 degrees.\n    \"\"\"\n    if n_sides < 3:\n        raise ValueError(\"n_sides should be at least 3 for a valid polygon.\")\n    return (n_sides - 2) * 180", "def angle_at_hour_mark(hour):\n    \"\"\"\n    Calculate the angle of a specific hour mark from 12 o'clock on the clock face.\n    Parameters:\n    - hour (int): Hour mark (1 through 12).\n    Returns:\n    - float: Angle in degrees from the 12 o'clock position.\n    Examples:\n    >>> angle_at_hour_mark(3)\n    90.0\n    >>> angle_at_hour_mark(6)\n    180.0\n    \"\"\"\n    return (hour % 12) * 30  # As each hour represents 30 degrees", "def triangle_angle(angle1, angle2):\n    \"\"\"\n    Compute the third angle of a triangle given two angles.\n    Parameters:\n        angle1 (float): First angle of the triangle in degrees.\n        angle2 (float): Second angle of the triangle in degrees.\n    Returns:\n        float: Third angle of the triangle in degrees.\n    \"\"\"\n    return 180 - angle1 - angle2", "def calculate_point_angle(angles):\n    '''\n    This function calculates the missing angle around a point.\n    \n    Parameters: \n    angles (list): The list of known angles around a point\n   \n    Returns: \n    float: The missing angle around the point.\n    \n    Example: \n    calculate_point_angle([90, 90, 90])\n    # Output: 90.0\n    '''\n    sum_angles = sum(angles)\n    absent_angle = 360 - sum_angles\n    return absent_angle", "def calculate_quadrilateral_angle(a, b, c):\n    '''\n    This function calculates the fourth angle of a quadrilateral given three angles.\n    \n    Parameters: \n    a, b, c (float): The three angles of the quadrilateral\n   \n    Returns: \n    float: The fourth angle of the quadrilateral.\n    \n    Example: \n    calculate_quadrilateral_angle(90, 90, 90)\n    # Output: 90.0\n    '''\n    fourth_angle = 360 - a - b - c\n    return fourth_angle", "def calculate_straight_line_angle(a):\n    '''\n    This function calculates the adjacent angle on a straight line.\n    \n    Parameters: \n    a (float): The given angle on the straight line\n   \n    Returns: \n    float: The adjacent angle on the straight line.\n    \n    Example: \n    calculate_straight_line_angle(45)\n    # Output: 135.0\n    '''\n    adjacent_angle = 180 - a\n    return adjacent_angle", "def coterminal_angles(angle):\n    \"\"\"\n    Finds the positive and negative coterminal angles for a given angle.\n    \n    Parameters:\n        angle (float): Original angle in degrees.\n    Returns:\n        tuple: A tuple containing the positive and negative coterminal angles in degrees.\n    \"\"\"\n    return (angle % 360, (angle % 360) - 360)", "def calculate_polygon_external_angle():\n    '''\n    This function calculates the external angle of a polygon.\n   \n    Returns: \n    int: The external angle of a polygon.\n    \n    Example: \n    calculate_polygon_external_angle()\n    # Output: 180\n    '''\n    # External angle of any polygon is always 180\n    return 180", "def angle_between_vectors(v1, v2):\n    \"\"\"\n    Calculate the angle between two vectors in degrees.\n    \n    Parameters:\n        v1 (list or tuple): The first vector, e.g., [x1, y1].\n        v2 (list or tuple): The second vector, e.g., [x2, y2].\n        \n    Returns:\n        float: The angle between the two vectors in degrees.\n    \"\"\"\n    v1 = np.array(v1)\n    v2 = np.array(v2)\n    unit_v1 = v1 / np.linalg.norm(v1)\n    unit_v2 = v2 / np.linalg.norm(v2)\n    dot_product = np.dot(unit_v1, unit_v2)\n    angle_rad = np.arccos(dot_product)\n    angle_deg = np.degrees(angle_rad)\n    return angle_deg", "def calculate_triangle_angle(a, b):\n    '''\n    This function calculates the third angle of a triangle given two angles.\n    \n    Parameters: \n    a, b (float): The two angles of the triangle\n   \n    Returns: \n    float: The third angle of the triangle.\n    \n    Example: \n    calculate_triangle_angle(60, 60)\n    # Output: 60.0\n    '''\n    third_angle = 180 - a - b\n    return third_angle", "def sum_of_interior_angles(sides):\n    \"\"\"\n    Compute the sum of interior angles of a polygon.\n    Parameters:\n        sides (int): number of sides in the polygon.\n    Returns:\n        float: sum of the interior angles of the polygon in degrees.\n    \"\"\"\n    return (sides - 2) * 180", "def sum_of_exterior_angles():\n    \"\"\"\n    Compute the sum of exterior angles of any polygon, which is always 360 degrees.\n    Returns:\n        float: sum of the exterior angles of a polygon in degrees.\n    \"\"\"\n    return 360"], "Similarity": ["def check_similarity_by_angles(angles1, angles2):\n    \"\"\"\n    Checks whether two triangles are similar by comparing their angles.\n    \n    Parameters:\n        angles1 (tuple): A tuple of three angle measures (in degrees or radians) of the first triangle.\n        angles2 (tuple): A tuple of three angle measures (in degrees or radians) of the second triangle.\n        \n    Returns:\n        bool: Returns True if all corresponding angles are equal, implying similarity.\n    Example:\n        >>> check_similarity_by_angles((45, 45, 90), (45, 45, 90))\n        True\n        >>> check_similarity_by_angles((30, 60, 90), (30, 70, 80))\n        False\n    \"\"\"\n    # Check if each angle in angles1 is equal to the corresponding angle in angles2\n    return set(angles1) == set(angles2)", "def find_missing_length(similar_triangles, target_side_index):\n    \"\"\"\n    Calculates a missing side in similar triangles based on the property of corresponding sides being in proportion.\n    \n    Parameters:\n        similar_triangles (tuple): A tuple containing two tuples; each inner tuple represents the known sides of each triangle, where None represents the unknown side.\n        target_side_index (int): The index of the side that is missing (0 for the first side, 1 for the second side, 2 for the third side).\n    \n    Returns:\n        symbolic or numeric expression: The length of the missing side if calculable.\n    Example:\n        >>> find_missing_length(((3, 4, 5), (6, 8, None)), 2)\n        10\n        >>> find_missing_length(((2, None, 4), (3, 9, 6)), 1)\n        6\n    \"\"\"\n    known_sides1, known_sides2 = similar_triangles\n    \n    # Identify the non-None sides to use for proportions\n    not_none_indices = [i for i in range(3) if known_sides1[i] is not None and known_sides2[i] is not None]\n    \n    if not not_none_indices:\n        return None  # can't compute the missing side without any known proportions\n    \n    # Use the first available ratio to compute the missing side\n    ratio = simplify(known_sides2[not_none_indices[0]] / known_sides1[not_none_indices[0]])\n    \n    # Find the missing side using the calculated ratio\n    return simplify(known_sides1[target_side_index] * ratio)", "def area_ratio_calculator(side_ratio):\n    \"\"\"\n    Calculates the ratio of areas of two similar triangles based on the ratio of corresponding sides.\n    \n    Parameters:\n    side_ratio (float): The ratio of any corresponding sides of the two similar triangles.\n    \n    Returns:\n    float: The ratio of areas of the two triangles.\n    \n    Examples:\n    >>> area_ratio_calculator(2)\n    4.0\n    >>> area_ratio_calculator(0.5)\n    0.25\n    \"\"\"\n    return side_ratio ** 2", "def find_missing_length(similarity_ratio, known_length):\n    \"\"\"\n    Calculate the corresponding side length in a similar triangle using the similarity ratio.\n    \n    Parameters:\n    - similarity_ratio (float): The ratio of similarity between two triangles.\n    - known_length (float): The side length in one of the triangles whose corresponding\n                            side length in the similar triangle needs to be found.\n    \n    Returns:\n    - float: The corresponding side length in the other triangle.\n    Example:\n    >>> find_missing_length(0.5, 10)\n    5.0\n    \"\"\"\n    return similarity_ratio * known_length", "def find_missing_length_and_area_ratio(base_triangle, sim_ratio, missing_side=None, base_area=None):\n    \"\"\"\n    Calculate unknown sides and area ratio of similar triangles given base triangle dimensions and similarity ratio.\n    \n    Parameters:\n    - base_triangle (tuple): A tuple of three numbers representing the side lengths of the base triangle.\n    - sim_ratio (float): The ratio of similarity between two triangles.\n    - missing_side (tuple of int): Positions (0, 1, 2) of sides in base_triangle for which length is unknown.\n    - base_area (float, optional): The area of the base triangle.\n    Returns:\n    - dict: Dictionary with keys `sides` containing new side lengths, and optionally `area_ratio` if base_area provided.\n    \n    Examples:\n    >>> find_missing_length_and_area_ratio((3, 4, 5), 2)\n    {'sides': (6, 8, 10)}\n    >>> find_missing_length_and_area_ratio((3, 4, 5), 0.5, base_area=6)\n    {'sides': (1.5, 2, 2.5), 'area_ratio': 0.25}\n    \"\"\"\n    new_lengths = tuple([side * sim_ratio for side in base_triangle])\n    result = {'sides': new_lengths}\n    if base_area is not None:\n        result['area_ratio'] = sim_ratio**2\n    return result", "def proportional_sides_solver(known_ratios, known_side, target='missing'):\n    \"\"\"\n    Solves for unknown sides in similar triangles based on a known side ratio and a known side length.\n    \n    Parameters:\n    known_ratios (tuple of floats): Ratios of corresponding sides as (known_base_ratio, target_base_ratio)\n    known_side (float): Length of the known side for the computation.\n    target (str, optional): Specifies if the target is the 'missing' side or 'known'. Defaults to 'missing'.\n    \n    Returns:\n    float: Length of the target side.\n    \n    Examples:\n    >>> proportional_sides_solver((2, 3), 4)\n    6.0\n    >>> proportional_sides_solver((3, 2), 6, target='known')\n    4.0\n    \"\"\"\n    known_base_ratio, target_base_ratio = known_ratios\n    if target == 'missing':\n        return (target_base_ratio / known_base_ratio) * known_side\n    else:\n        return (known_base_ratio / target_base_ratio) * known_side", "def verify_similarity(triangle1, triangle2, criterion='SSS'):\n    \"\"\"\n    Determine if two triangles are similar based on provided side lengths or angles.\n    \n    Parameters:\n    triangle1 (dict): A dictionary containing sides (a, b, c) and optionally angles (A, B, C) of the first triangle.\n    triangle2 (dict): A dictionary containing sides (x, y, z) and optionally angles (X, Y, Z) of the second triangle.\n    criterion (str): The criterion to use for verifying similarity ('SSS', 'SAS', 'AA').\n    \n    Returns:\n    bool: True if triangles are similar under the given criterion, otherwise False.\n    \n    Examples:\n    >>> verify_similarity({'a': 3, 'b': 4, 'c': 5}, {'x': 6, 'y': 8, 'z': 10}, 'SSS')\n    True\n    >>> verify_similarity({'A': 45, 'B': 45}, {'X': 45, 'Y': 45}, 'AA')\n    True\n    \"\"\"\n    if criterion == 'SSS':\n        ratios = sorted([triangle1['a']/triangle2['x'], triangle1['b']/triangle2['y'], triangle1['c']/triangle2['z']])\n        return N(ratios[0]) == N(ratios[1]) == N(ratios[2])\n    elif criterion == 'SAS':\n        # Implement SAS logic\n        pass  # Placeholder for now\n    elif criterion == 'AA':\n        # Assume angles are in degrees and we only need two angles each\n        angles1 = sorted([triangle1.get(key) for key in ['A', 'B', 'C'] if key in triangle1])\n        angles2 = sorted([triangle2.get(key) for key in ['X', 'Y', 'Z'] if key in triangle2])\n        return N(angles1[0]) == N(angles2[0]) and N(angles1[1]) == N(angles2[1])\n    return False", "def triangle_proportional_sides(triangle1_sides, ratio):\n    \"\"\"\n    Compute the sides of a triangle given the sides of a similar triangle and the ratio of similarity.\n    \n    Parameters:\n    triangle1_sides (list of floats): The sides of the known triangle.\n    ratio (float): The ratio of proportionality to compute the sides of the second triangle.\n    \n    Returns:\n    list of floats: The calculated sides of the second triangle based on the ratio.\n    \n    Examples:\n    >>> triangle_proportional_sides([3, 4, 5], 2)\n    [6.0, 8.0, 10.0]\n    \"\"\"\n    triangle2_sides = [side * ratio for side in triangle1_sides]\n    return triangle2_sides"], "Parallelograms": ["def midpoint(point_a, point_b):\n    \"\"\"\n    Calculate the midpoint between two points in 2D space.\n    Parameters:\n    - point_a (tuple): Coordinates of the first point (x1, y1).\n    - point_b (tuple): Coordinates of the second point (x2, y2).\n    Returns:\n    - tuple: Coordinates of the midpoint.\n    Example:\n    >>> midpoint((0, 0), (2, 2))\n    (1.0, 1.0)\n    \"\"\"\n    return ((point_a[0] + point_b[0]) / 2, (point_a[1] + point_b[1]) / 2)", "def calculate_perimeter(sides):\n    \"\"\"\n    Calculate the perimeter of a parallelogram based on the lengths of its sides.\n    Parameters:\n        sides (dict): A dictionary with side lengths {'a': length of side a, 'b': length of side b}.\n    Returns:\n        float: The perimeter of the parallelogram.\n    Examples:\n        >>> calculate_perimeter({'a': 4, 'b': 3})\n        14\n    \"\"\"\n    return 2 * (sides['a'] + sides['b'])", "def distance(point_a, point_b):\n    \"\"\"\n    Calculate the Euclidean distance between two points in 2D space.\n    Parameters:\n    - point_a (tuple): Coordinates of the first point (x1, y1).\n    - point_b (tuple): Coordinates of the second point (x2, y2).\n    Returns:\n    - float: Euclidean distance.\n    Example:\n    >>> distance((0, 0), (3, 4))\n    5.0\n    \"\"\"\n    return np.sqrt((point_b[0] - point_a[0])**2 + (point_b[1] - point_a[1])**2)", "def parallelogram_area(vertices):\n    \"\"\"\n    Calculate the area of a parallelogram given its vertices.\n    Parameters:\n    - vertices (list of tuples): Coordinates of the vertices [(x1, y1), (x2, y2), (x3, y3), (x4, y4)].\n    Returns:\n    - float: Area of the parallelogram.\n    Example:\n    >>> parallelogram_area([(0, 0), (2, 0), (3, 2), (1, 2)])\n    4.0\n    \"\"\"\n    (x1, y1), (x2, y2), (x3, y3), _ = vertices\n    return abs((x2-x1)*(y3-y1) - (x3-x1)*(y2-y1))", "def verify_parallelism(vector1, vector2):\n    \"\"\"\n    Verify if two vectors are parallel by calculating the cross-product.\n    Parameters:\n        vector1 (tuple): The components of the first vector.\n        vector2 (tuple): The components of the second vector.\n    Returns:\n        bool: True if the vectors are parallel, False otherwise.\n    Examples:\n        >>> verify_parallelism((2, 2), (4, 4))\n        True\n    \"\"\"\n    return np.cross(vector1, vector2) == 0", "def diagonal_lengths(sides, angle_degrees):\n    \"\"\"\n    Calculate the lengths of the diagonals in a parallelogram using side lengths and the angle between them.\n    Parameters:\n        sides (dict): A dictionary with side lengths {'a': length of side a, 'b': length of side b}.\n        angle_degrees (float): The angle between the sides in degrees.\n    Returns:\n        dict: The lengths of diagonals {'d1': diagonal1 length, 'd2': diagonal2 length}.\n    Examples:\n        >>> diagonal_lengths({'a': 5, 'b': 3}, 60)\n        {'d1': 7.795831523312719, 'd2': 4.0}\n    \"\"\"\n    angle_radians = np.deg2rad(angle_degrees)\n    d1 = math.sqrt(sides['a']**2 + sides['b']**2 - 2 * sides['a'] * sides['b'] * math.cos(angle_radians))\n    d2 = math.sqrt(sides['a']**2 + sides['b']**2 + 2 * sides['a'] * sides['b'] * math.cos(angle_radians))\n    return {'d1': d1, 'd2': d2}"], "Coordinate Systems": ["def spherical_to_cartesian(rho, theta, phi):\n    \"\"\"\n    Converts spherical coordinates to Cartesian (rectangular) coordinates.\n    Parameters:\n        rho (float): Radial distance\n        theta (float): Azimuthal angle in radians\n        phi (float): Polar angle from the positive z-axis in radians\n    \n    Returns:\n        tuple: (x, y, z) coordinates in Cartesian system\n    \n    Examples:\n        >>> spherical_to_cartesian(1, np.pi/2, np.pi/2)\n        (1.0, 0.0, 6.123233995736766e-17) # approximately (1, 0, 0)\n    \"\"\"\n    x = rho * np.sin(phi) * np.cos(theta)\n    y = rho * np.sin(phi) * np.sin(theta)\n    z = rho * np.cos(phi)\n    return x, y, z", "def cartesian_to_cylindrical(x, y, z):\n    \"\"\"\n    Converts Cartesian (rectangular) coordinates to cylindrical coordinates.\n    Parameters:\n        x (float): x-coordinate\n        y (float): y-coordinate\n        z (float): z-coordinate\n    \n    Returns:\n        tuple: (r, theta, z) coordinates in cylindrical system\n    \n    Examples:\n        >>> cartesian_to_cylindrical(1, 0, 1)\n        (1.0, 0.0, 1) # radius, angle, height\n    \"\"\"\n    r = np.sqrt(x**2 + y**2)\n    theta = np.arctan2(y, x)\n    return r, theta, z", "def cartesian_to_polar(x, y):\n    \"\"\"Convert Cartesian coordinates to polar coordinates.\n    \n    Parameters\n    ----------\n    x : float\n        The x-coordinate in the Cartesian plane.\n    y : float\n        The y-coordinate in the Cartesian plane.\n    Returns\n    -------\n    tuple\n        A tuple containing the radius (r) and angle (theta in radians).\n    Examples\n    --------\n    >>> cartesian_to_polar(1, 1)\n    (1.4142135623730951, 0.7853981633974483)\n    \"\"\"\n    r = np.sqrt(x**2 + y**2)\n    theta = np.arctan2(y, x)\n    return r, theta", "def distance_between_points(point1: Tuple[float, float], point2: Tuple[float, float]) -> float:\n    \"\"\"\n    Calculate the Euclidean distance between two points in the xy-plane.\n    \n    Parameters:\n    - point1 (Tuple[float, float]): The first point (x1, y1).\n    - point2 (Tuple[float, float]): The second point (x2, y2).\n    \n    Returns:\n    - float: The distance between the points.\n    \n    Examples:\n    >>> distance_between_points((1, 2), (4, 6))\n    5.0\n    \"\"\"\n    return sqrt((point1[0] - point2[0])**2 + (point1[1] - point2[1])**2)", "def midpoint(p1, p2):\n    \"\"\"Calculate the midpoint between two points.\n    \n    Parameters\n    ----------\n    p1, p2 : tuple\n        Points for which to find the midpoint (each as tuple of floats (x, y)).\n    Returns\n    -------\n    tuple\n        Midpoint (x, y).\n    Examples\n    --------\n    >>> midpoint((0, 0), (2, 2))\n    (1.0, 1.0)\n    \"\"\"\n    x1, y1 = p1\n    x2, y2 = p2\n    mx = (x1 + x2) / 2\n    my = (y1 + y2) / 2\n    return (mx, my)", "def parametric_line_intercept(A, B):\n    \"\"\"\n    Determine the intersection point of two parametrically defined lines in the xy-plane.\n    Parameters:\n    - A (dict): Contains the parametric definition of line A {'point': (x1, y1), 'direction': (dx1, dy1)}\n    - B (dict): Contains the parametric definition of line B {'point': (x2, y2), 'direction': (dx2, dy2)}\n    Returns:\n    - tuple or None: The intersection point (x, y) if exists, otherwise None.\n    Examples:\n    >>> A = {'point': (0, 0), 'direction': (1, 1)}\n    >>> B = {'point': (1, 0), 'direction': (-1, 1)}\n    >>> parametric_line_intercept(A, B)\n    (0.5, 0.5)\n    \"\"\"\n    x1, y1 = A['point']\n    dx1, dy1 = A['direction']\n    x2, y2 = B['point']\n    dx2, dy2 = B['direction']\n    t, s = sp.symbols('t s')\n    equations = [\n        sp.Eq(x1 + t * dx1, x2 + s * dx2),\n        sp.Eq(y1 + t * dy1, y2 + s * dy2)\n    ]\n    result = sp.solve(equations, (t, s))\n    if result:\n        t_val, s_val = result[t], result[s]\n        xp = x1 + t_val * dx1\n        yp = y1 + t_val * dy1\n        return float(xp), float(yp)\n    \n    return None", "def parametric_to_cartesian(t: np.array, parametric_func: Callable[[np.array], np.array]) -> np.array:\n    \"\"\"\n    Convert a parametric representation of curves to Cartesian coordinates.\n    \n    Parameters:\n    - t (np.array): An array of parameter values.\n    - parametric_func (Callable[[np.array], np.array]): The parametric function defined as x(t), y(t), z(t).\n    \n    Returns:\n    - np.array: Cartesian coordinates resulting from parameter t.\n    \n    Examples:\n    >>> parametric_to_cartesian(np.array([0, np.pi/2]), lambda t: np.array([np.cos(t), np.sin(t), 0]))\n    array([[1., 0., 0.],\n           [0., 1., 0.]])\n    \"\"\"\n    return np.array([parametric_func(ti) for ti in t])", "def line_intersection(p1, p2, p3, p4):\n    \"\"\"Calculate the point of intersection between two lines defined by four points.\n    \n    Parameters\n    ----------\n    p1, p2 : tuple\n        Points on the first line (each as tuple of floats (x, y)).\n    p3, p4 : tuple\n        Points on the second line (each as tuple of floats (x, y)).\n    Returns\n    -------\n    tuple or None\n        A tuple containing the intersection point (x, y), or None if no intersection exists.\n    Examples\n    --------\n    >>> line_intersection((0, 0), (1, 1), (0, 1), (1, 0))\n    (0.5, 0.5)\n    \"\"\"\n    x1, y1 = p1\n    x2, y2 = p2\n    x3, y3 = p3\n    x4, y4 = p4\n    denom = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4)\n    if denom == 0:\n        return None  # Lines are parallel or coincident.\n    intersect_x = ((x1 * y2 - y1 * x2) * (x3 - x4) - (x1 - x2) * (x3 * y4 - y3 * x4)) / denom\n    intersect_y = ((x1 * y2 - y1 * x2) * (y3 - y4) - (y1 - y2) * (x3 * y4 - y3 * x4)) / denom\n    return (intersect_x, intersect_y)", "def adjust_angle_for_quadrant(theta, x, y):\n    \"\"\"\n    Adjust angle to ensure it falls in the correct quadrant.\n    Parameters:\n        theta (float): Computed angle in radians, typically from trigonometric function\n        x (float): x-coordinate used for adjusting angle\n        y (float): y-coordinate for specific cases\n    \n    Returns:\n        float: Adjusted angle in radians\n    \n    Examples:\n        >>> adjust_angle_for_quadrant(np.arctan(-1), -1, 0)\n        -2.356194490192345 # approximately -3π/4, which is adjusted for the correct quadrant\n    \"\"\"\n    if x < 0 and y == 0:\n        return theta + np.pi\n    return theta"], "Conic Sections": ["def ellipse_properties(a, b):\n    \"\"\"\n    Calculate significant geometric properties of an ellipse.\n    Parameters:\n    a (float): The length of the semi-major axis.\n    b (float): The length of the semi-minor axis.\n    Returns:\n    dict: A dictionary containing the focal distance (c), area, and the distance between the foci (2c).\n    Examples:\n    >>> ellipse_properties(5, 3)\n    {'focal_distance': 4.0, 'area': 47.12388980384689, 'distance_between_foci': 8.0}\n    \"\"\"\n    c = np.sqrt(a**2 - b**2)\n    area = np.pi * a * b\n    return {'focal_distance': c, 'area': area, 'distance_between_foci': 2*c}", "def ellipse_foci(a, b, center=(0, 0)):\n    \"\"\"\n    Calculate the coordinates of the foci of an ellipse.\n    Parameters:\n    a : float\n        Length of the semi-major axis.\n    b : float\n        Length of the semi-minor axis.\n    center : tuple\n        Coordinates of the center of the ellipse (h, k).\n    Returns:\n    tuple of tuples\n        Coordinates of the two foci.\n    Examples:\n    >>> ellipse_foci(5, 3)\n    ((-4.0, 0), (4.0, 0))\n    \"\"\"\n    h, k = center\n    c = np.sqrt(a**2 - b**2)\n    if a >= b:\n        foci = ((h + c, k), (h - c, k))\n    else:\n        foci = ((h, k + c), (h, k - c))\n    return foci", "def ellipse_equation(center, a, b):\n    \"\"\"\n    This function generates the standard form equation of an ellipse, \n    given its center and the lengths of its semi-major (a) and semi-minor (b) axes.\n    \n    Parameters:\n    center (tuple): The coordinates of the center of the ellipse.\n    a (float): The length of the semi-major axis.\n    b (float): The length of the semi-minor axis.\n    Returns:\n    equation (str): The standard form equation of the ellipse.\n    \"\"\"\n    x, y = sp.symbols('x y')\n    h, k = center\n    # Equation of the ellipse\n    equation = ((x-h)**2 / a**2) + ((y-k)**2 / b**2) - 1\n    return sp.simplify(equation)", "def point_on_ellipse(x, y, a, b, center=(0, 0)):\n    \"\"\"\n    Determine whether a given point (x, y) lies on the ellipse defined by semi-major axis a and\n    semi-minor axis b centered at 'center'.\n    Parameters:\n    x : float\n        x-coordinate of the point.\n    y : float\n        y-coordinate of the point.\n    a : float\n        Length of the semi-major axis.\n    b : float\n        Length of the semi-minor axis.\n    center : tuple\n        Coordinates of the center of the ellipse (h, k).\n    Returns:\n    bool\n        True if the point is on the ellipse, False otherwise.\n    Examples:\n    >>> point_on_ellipse(1, 4, 5, 3)\n    False\n    \"\"\"\n    h, k = center\n    value = ((x - h)**2 / a**2) + ((y - k)**2 / b**2)\n    return np.isclose(value, 1)", "def standard_form_to_general(x, y, h, k, a, b):\n    \"\"\"\n    Transform the standard form of an ellipse equation to its general form.\n    \n    Parameters:\n    x, y (sympy.Symbol): Symbols for the coordinate variables.\n    h, k (float): Coordinates of the center of the ellipse.\n    a (float): Length of the semi-major axis.\n    b (float): Length of the semi-minor axis.\n    Returns:\n    sympy.Expr: The general form of the ellipse equation as a sympy expression.\n    \n    Examples:\n    >>> x, y = sp.symbols('x y')\n    >>> standard_form_to_general(x, y, 0, 0, 5, 3)\n    x**2/25 + y**2/9 - 1\n    \"\"\"\n    return ((x - h)**2 / a**2 + (y - k)**2 / b**2 - 1).simplify()", "def transform_parabola(vertex, focus):\n    \"\"\"\n    Determine the standard form of a parabola given a vertex and a focus.\n    Parameters:\n        vertex (tuple): Coordinates (h, k) of the vertex of the parabola.\n        focus (tuple): Coordinates (p, q) of the focus of the parabola.\n    \n    Returns:\n        str: The standard form equation of the parabola.\n    \n    Examples:\n        >>> transform_parabola((0, 0), (0, 1))\n        'y = (x - 0)^2 / 4 + 0'\n    \"\"\"\n    h, k = vertex\n    p, q = focus\n    if p == h:  # Vertical parabola\n        a = 1/(4*(q-k))\n        equation = f'y = {a}*(x - {h})**2 + {k}'\n    else:  # Horizontal parabola\n        a = 1/(4*(p-h))\n        equation = f'x = {a}*(y - {k})**2 + {h}'\n    \n    return equation", "def ellipse_tangent_line(a, b, slope, center=(0, 0)):\n    \"\"\"\n    Calculates the y-intercept of a line tangent to the ellipse at y=mx+c\n    Parameters:\n    a : float\n        Semi-major axis of the ellipse.\n    b : float\n        Semi-minor axis of the ellipse.\n    slope : float\n        Slope (m) of the tangent line.\n    center : tuple\n        Center of the ellipse (h, k).\n    Returns:\n    float\n        y-intercept of the tangent line.\n    Examples:\n    >>> ellipse_tangent_line(5, 3, 1)\n    'y = x ± 7.54983443527075'\n    \"\"\"\n    h, k = center\n    c = (a * b) / np.sqrt((b**2) + (a**2) * slope**2)\n    return f\"y = {slope}x ± {c + k}\"", "def hyperbola_properties(a2, b2):\n    \"\"\"\n    Calculate properties of a hyperbola given a^2 and b^2.\n    \n    Parameters:\n        a2 (float): Square of the distance from the center to a vertex along the transverse axis.\n        b2 (float): Square of the distance from the center to a vertex along the conjugate axis.\n    \n    Returns:\n        dict: Dictionary containing foci distance `c`, and length of transverse and conjugate axes.\n    \n    Examples:\n        >>> hyperbola_properties(25, 16)\n        {'c': 9.0, '2a': 10, '2b': 8}\n    \"\"\"\n    a = sp.sqrt(a2)\n    b = sp.sqrt(b2)\n    c = sp.sqrt(a2 + b2)\n    \n    return {'c': c, '2a': 2*a, '2b': 2*b}"], "Quadrilaterals": ["def apply_law_of_cosines(a, b, angle_c):\n    \"\"\"\n    Apply the Law of Cosines to calculate the third side of a triangle, given two sides and the included angle.\n    Parameters:\n    - a (float): Length of the first side of the triangle.\n    - b (float): Length of the second side of the triangle.\n    - angle_c (float): The angle between sides a and b in degrees.\n    \n    Returns:\n    - float: The length of the third side of the triangle.\n    \n    Examples:\n    >>> apply_law_of_cosines(5, 6, 60)\n    4.084\n    \"\"\"\n    angle_c_rad = math.radians(angle_c)\n    c = math.sqrt(a**2 + b**2 - 2 * a * b * math.cos(angle_c_rad))\n    return c", "def check_opposite_angles_equality(angle_a, angle_b, angle_c, angle_d):\n    \"\"\"\n    Verify if opposite angles in a given quadlilateral are equal - a property of parallelograms.\n    Parameters:\n    - angle_a (Expr): Symbolic expression for angle A (one vertex angle of a quadrilateral).\n    - angle_b (Expr): Symbolic expression for angle B (adjacent to angle A).\n    - angle_c (Expr): Symbolic expression for angle C (opposite to angle A).\n    - angle_d (Expr): Symbolic expression for angle D (adjunct to angle C).\n    Returns:\n    - bool: True if opposite angles are equal (angle A equals angle C and angle B equals angle D); False otherwise.\n    Examples:\n    >>> from sympy import symbols, pi\n    >>> A, B, C, D = symbols('A B C D')\n    >>> check_opposite_angles_equality(A, B, A, B)\n    True\n    >>> check_opposite_angles_equality(pi/2, pi/3, pi/2, pi/3)\n    True\n    >>> check_opposite_angles_equality(90, 45, 89, 44)\n    False\n    \"\"\"\n    # Check for equality in both pairs of opposite angles\n    opposite_angles_equal = Eq(angle_a, angle_c) and Eq(angle_b, angle_d)\n    # Return boolean evaluation of the equality expressions\n    return solve(opposite_angles_equal)", "def area_of_right_triangle(base, height):\n    \"\"\"\n    Calculate the area of a right triangle given its base and height.\n    \n    Parameters:\n    - base (float): The length of the base of the right triangle.\n    - height (float): The height of the right triangle.\n    \n    Returns:\n    - float: The area of the right triangle.\n    \n    Examples:\n    >>> area_of_right_triangle(3, 4)\n    6.0\n    \"\"\"\n    return 0.5 * base * height", "def quadrilateral_perimeter(*sides):\n    \"\"\"\n    Calculates the perimeter of a quadrilateral given the lengths of its sides.\n    Parameters:\n    - sides (float): variable number of side lengths (expects exactly 4 sides).\n    \n    Returns:\n    - float: the perimeter of the quadrilateral.\n    Examples:\n    >>> quadrilateral_perimeter(5, 5, 8, 8)\n    26\n    \"\"\"\n    return sum(sides)", "def calculate_diagonal_rhombus(side_length):\n    \"\"\"\n    Calculate the diagonals of a rhombus given the length of its side.\n    \n    Parameters:\n    - side_length (float): The length of the side of the rhombus.\n    \n    Returns:\n    - tuple: The lengths of the diagonals of the rhombus.\n    \n    Examples:\n    >>> calculate_diagonal_rhombus(5)\n    (7.071, 7.071)\n    \"\"\"\n    diagonal = side_length * math.sqrt(2)\n    return (diagonal, diagonal)", "def verify_parallelogram_angles(angle_A, angle_B, angle_C, angle_D):\n    \"\"\"\n    Verify whether four given angles can form a parallelogram based on the properties:\n    - Opposite angles are equal.\n    - Adjacent angles are supplementary (sum to 180 degrees).\n    \n    Parameters:\n        angle_A (int/float/sympy.Expr): Angle at vertex A (degrees)\n        angle_B (int/float/sympy.Expr): Angle at vertex B (degrees)\n        angle_C (int/float/sympy.Expr): Angle at vertex C (degrees)\n        angle_D (int/float/sympy.Expr): Angle at vertex D (degrees)\n        \n    Returns:\n        bool: True if the angles can form a parallelogram, False otherwise.\n    \n    Examples:\n        >>> verify_parallelogram_angles(70, 110, 70, 110)\n        True\n        >>> verify_parallelogram_angles(70, 100, 70, 100)\n        False  # This would be false because adjacent angles 70 and 100 do not sum to 180\n    \"\"\"\n    # Checking opposite angles\n    opposite_equal = (angle_A == angle_C) and (angle_B == angle_D)\n    \n    # Checking adjacent angles\n    adjacent_supplementary = (angle_A + angle_B == 180) and (angle_C + angle_D == 180)\n    \n    return opposite_equal and adjacent_supplementary", "def triangle_calculations_in_quadrilaterals(side_lengths, angle=None, use_pythagoras=False):\n    \"\"\"\n    Function that facilitates triangle calculations such as angle calculations using the law of cosines or using the Pythagorean theorem in specific triangles within quadrilaterals.\n    \n    Parameters:\n        side_lengths (tuple[float]): The lengths of the sides of the triangle.\n        angle (float, optional): The angle for which the law of cosines is to be applied. Provided in radians if used.\n        use_pythagoras (bool): Whether to use the Pythagorean Theorem.\n    \n    Returns:\n        float: The calculated value based on given parameters (could be side length or angle).\n    \n    Example:\n        >>> triangle_calculations_in_quadrilaterals((3, 4, 5), use_pythagoras=True)\n        {'is_right_triangle': True, 'missing_side': 5}\n    \"\"\"\n    import math\n    \n    a, b, c = side_lengths\n    if use_pythagoras and angle is None:\n        # Assume right triangle; check if condition holds\n        return {'is_right_triangle': math.isclose(a**2 + b**2, c**2), 'missing_side': math.sqrt(a**2 + b**2)}\n    elif angle:\n        # Use the law of cosines: c^2 = a^2 + b^2 - 2ab*cos(C)\n        return math.sqrt(a**2 + b**2 - 2*a*b*math.cos(angle))\n    return None", "def pythagorean_theorem(a=None, b=None, c=None):\n    \"\"\"\n    Given any two sides of a right triangle, calculate the third side using the Pythagorean Theorem.\n    Parameters:\n    - a (float, optional): one leg of the right triangle.\n    - b (float, optional): the other leg of the right triangle.\n    - c (float, optional): the hypotenuse of the right triangle.\n    \n    Returns:\n    - float: the length of the missing side.\n    Examples:\n    >>> pythagorean_theorem(a=3, b=4)\n    5.0\n    >>> pythagorean_theorem(c=5, b=4)\n    3.0\n    \"\"\"\n    if a is None:\n        return math.sqrt(c**2 - b**2)\n    elif b is None:\n        return math.sqrt(c**2 - a**2)\n    elif c is None:\n        return math.sqrt(a**2 + b**2)\n    else:\n        return None", "def quadrilateral_properties_calculations(quadrilateral_type, *sides):\n    \"\"\"\n    Calculate properties like area, perimeter, and specific checks for types of quadrilaterals.\n    \n    Parameters:\n        quadrilateral_type (str): Type of the quadrilateral ['rectangle', 'rhombus', 'isosceles_trapezoid', 'general_quadrilateral']\n        *sides (float): Varies based on the type. For 'rectangle' and 'rhombus', only two are needed as they are symmetrical. \n                        For 'isosceles_trapezoid' and 'general_quadrilateral', all four sides should be provided.\n    \n    Returns:\n        dict: returns a dictionary containing properties like area, perimeter and specific type properties if any.\n    \n    Example:\n        >>> print(quadrilateral_properties_calculations('rectangle', 5, 10))\n        {'area': 50, 'perimeter': 30, 'is_square': False}\n    \"\"\"\n    import math\n    \n    result = {}\n    if quadrilateral_type in ['rectangle', 'rhombus']:\n        area = sides[0] * sides[1]\n        perimeter = 2 * (sides[0] + sides[1])\n        result['area'] = area\n        result['perimeter'] = perimeter\n        if quadrilateral_type == 'rectangle':\n            result['is_square'] = sides[0] == sides[1]\n        elif quadrilateral_type == 'rhombus':\n            result['diagonal_u'] = math.sqrt(2) * sides[0]\n            result['diagonal_v'] = math.sqrt(2) * sides[1]\n    elif quadrilateral_type == 'isosceles_trapezoid':\n        a, b, c, d = sides  # a, d are bases; b, c are legs\n        # More complex calculations like area using trapezoid formula\n    else:\n        # Calculate using general formulas, possibly Brahmagupta's formula for area of a general quadrilateral\n        pass\n    \n    return result"], "Ellipse": ["def ellipse_properties(center, a, b):\n    \"\"\"\n    Calculate properties of an ellipse given its center, semi-major axis (a),\n    and semi-minor axis (b).\n    Parameters:\n        center (tuple): The (x, y) coordinates of the ellipse's center.\n        a (float): Length of the semi-major axis.\n        b (float): Length of the semi-minor axis.\n    Returns:\n        dict: A dictionary containing properties of the ellipse such as foci,\n        area, and the standard equation.\n    Examples:\n        >>> ellipse_properties((0, 0), 5, 3)\n        {'center': (0, 0), 'semi-major': 5, 'semi-minor': 3,\n         'foci': ((-4.0, 0), (4.0, 0)), 'area': 47.12388980384689,\n         'equation': 'x^2/25 + y^2/9 = 1'}\n    \"\"\"\n    h, k = center\n    c = math.sqrt(a**2 - b**2)  # Distance from center to each focus\n    foci = ((h - c, k), (h + c, k))\n    area = math.pi * a * b\n    equation = f\"x^2/{a**2} + y^2/{b**2} = 1\"\n    return {\n        'center': center,\n        'semi-major': a,\n        'semi-minor': b,\n        'foci': foci,\n        'area': area,\n        'equation': equation\n    }", "def ellipse_standard_to_general(h, k, a, b):\n    \"\"\"\n    Convert the standard equation of an ellipse to its general form.\n    Parameters:\n        h (float): The x-coordinate of the ellipse's center.\n        k (float): The y-coordinate of the ellipse's center.\n        a (float): Length of the semi-major axis.\n        b (float): Length of the semi-minor axis.\n    Returns:\n        sympy expression: The general form of the ellipse equation.\n    Examples:\n        >>> ellipse_standard_to_general(1, 2, 5, 3)\n        Eq(x**2/25 - x*2/5 + y**2/9 - y*4/9 + 5, 0)\n    \"\"\"\n    x, y = sp.symbols('x y')\n    eq = (x - h)**2/a**2 + (y - k)**2/b**2 - 1\n    return sp.simplify(eq)", "def ellipse_area(a, b):\n    \"\"\"\n    Calculate the area of an ellipse given the lengths of its semi-major and semi-minor axes.\n    \n    Parameters:\n    a (float): length of the semi-major axis.\n    b (float): length of the semi-minor axis.\n    Returns:\n    float: Area of the ellipse.\n    Example:\n    >>> ellipse_area(5, 3)\n    47.12388980384689\n    \"\"\"\n    return math.pi * a * b", "def ellipse_standard_form(coordinates, a, b, angle=0):\n    \"\"\"\n    Represents the equation of an ellipse in its standard form based on provided parameters.\n    \n    Parameters:\n    coordinates : tuple\n        The (x, y) coordinates of the center of the ellipse.\n    a : float\n        The length of the semi-major axis.\n    b : float\n        The length of the semi-minor axis.\n    angle : float, optional\n        The rotation angle of the ellipse in degrees (default is 0).\n    Returns:\n    str\n        A string representing the standard form equation of the ellipse.\n    Examples:\n    >>> ellipse_standard_form((0, 0), 5, 3)\n    'x^2/25 + y^2/9 = 1'\n    >>> ellipse_standard_form((0, 0), 5, 3, 45)\n    'Rotated by 45 degrees: Standard equation not directly applicable.'\n    \"\"\"\n    if angle != 0:\n        return f\"Rotated by {angle} degrees: Standard equation not directly applicable.\"\n    h, k = coordinates\n    equation = f\"(x-{h})^2/{a**2} + (y-{k})^2/{b**2} = 1\"\n    return equation"]}