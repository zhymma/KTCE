{"Properties of Integers": [{"tool": "def is_prime(n):\n    \n    return isprime(n)", "subfield": "Properties of Integers", "tool_name": "is_prime", "tool_type": "function", "description": "Determine if the input integer is a prime number.", "docstring": "Determine if the input integer is a prime number.\n    Parameters:\n        n (int): The integer to check for primality.\n    Returns:\n        bool: True if n is prime, otherwise False.\n    \n    Examples:\n    >>> is_prime(29)\n    True", "Freq": 5, "TSR": 3}, {"tool": "def prime_factors(n):\n    \n    i = 2\n    factors = []\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n            factors.append(i)\n    if n > 1:\n        factors.append(n)\n    return factors", "subfield": "Properties of Integers", "tool_name": "prime_factors", "tool_type": "function", "description": "Returns the list of prime factors of a given positive integer n.", "docstring": "Returns the list of prime factors of a given positive integer n.\n    Parameters:\n    - n (int): Positive integer to factorize.\n    \n    Returns:\n    - list: Prime factors of integer n.\n    Examples:\n    >>> prime_factors(18)\n    [2, 3, 3]\n    >>> prime_factors(17)\n    [17]", "Freq": 3, "TSR": 1, "experience_pool": "- Incorrect usage of the prime_factors function in the wrong tool callings.\n- Missing function is_relatively_prime in the first wrong tool calling."}, {"tool": "def is_divisible(n, divisor):\n    \n    return n % divisor == 0", "subfield": "Properties of Integers", "tool_name": "is_divisible", "tool_type": "function", "description": "Checks if the first number is divisible by the second number.", "docstring": "Checks if the first number is divisible by the second number.\n    Parameters:\n    - n (int): Number to be checked.\n    - divisor (int): Divisor.\n    Returns:\n    bool: True if n is divisible by divisor, else False.\n    Example:\n    >>> is_divisible(10, 2)\n    True\n    >>> is_divisible(10, 3)\n    False", "Freq": 3, "TSR": 3}, {"tool": "def integer_squares(n):\n    \n    root = int(n**0.5)\n    return root * root == n", "subfield": "Properties of Integers", "tool_name": "integer_squares", "tool_type": "function", "description": "Check if a number is a perfect square.", "docstring": "Check if a number is a perfect square.\n    Parameters:\n    - n (int): The integer to check.\n    \n    Returns:\n    - bool: True if n is a perfect square, False otherwise.", "Freq": 4.5, "TSR": 3, "experience_pool": "- Experience 1:\n    - Problem: Simplify $\\sqrt{288}$.\n    - Answer: $12\\sqrt{2}$\n    - Solution: The correct solution is $12\\sqrt{2}$, not $1\\sqrt{288}$. The tool should be used to check if a number is a perfect square, not for simplifying square roots.\n- Experience 2:\n    - Problem: Find the number of ordered 17-tuples $(a_1, a_2, a_3, \\dots, a_{17})$ of integers, such that the square of any number in the 17-tuple is equal to the sum of the other 16 numbers.\n    - Answer: 12378\n    - Solution: The tool is not applicable for solving this problem. It should only be used to check if a number is a perfect square, not for calculating the number of ordered tuples."}, {"tool": "def is_coprime(a, b):\n    \n    return gcd(a, b) == 1", "subfield": "Properties of Integers", "tool_name": "is_coprime", "tool_type": "function", "description": "Checks if two numbers a and b are coprime (gcd is 1).", "docstring": "Checks if two numbers a and b are coprime (gcd is 1).\n    Parameters:\n    - a (int): First number.\n    - b (int): Second number.\n    Returns:\n    - bool: True if gcd(a, b) == 1, otherwise False.\n    Examples:\n    >>> is_coprime(14, 15)\n    True\n    >>> is_coprime(14, 21)\n    False", "Freq": 5, "TSR": 3, "experience_pool": "- Experience 1:\n    - Problem: In the first wrong tool calling, the function is_coprime is not defined, causing an error.\n    - Solution: Make sure to define the is_coprime function before calling it.\n- Experience 2:\n    - Problem: In the second wrong tool calling, the range of the for loop should be from 1 to 13 instead of 12 to include the number 12 itself.\n    - Solution: Modify the range of the for loop to include the number 12.\n- Experience 3:\n    - Problem: In the third wrong tool calling, the gcd function is not defined, causing an error.\n    - Solution: Make sure to define the gcd function before calling it."}, {"tool": "def find_divisors(n):\n    \n    divisors = []\n    for i in range(1, int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            divisors.append(i)\n            if i != n // i:\n                divisors.append(n // i)\n    divisors.sort()\n    return divisors", "subfield": "Properties of Integers", "tool_name": "find_divisors", "tool_type": "function", "description": "Find all divisors of a given integer n.", "docstring": "Find all divisors of a given integer n.\n    Parameters:\n    n (int): The integer to find divisors of.\n    Returns:\n    list of int: List of all divisors of n.\n    Example:\n    >>> find_divisors(28)\n    [1, 2, 4, 7, 14, 28]", "Freq": 4, "TSR": 3, "experience_pool": "- Experience: How to find divisors of an integer using Python.\n- Solution: The tool find_divisors(n) can be used to find all the divisors of an integer n.\n- Example: find_divisors(28) returns [1, 2, 4, 7, 14, 28]."}, {"tool": "def count_divisors(n):\n    \n    total = 0\n    root = int(math.sqrt(n))\n    for i in range(1, root + 1):\n        if n % i == 0:\n            total += 1 + (i != n // i)\n    return total", "subfield": "Properties of Integers", "tool_name": "count_divisors", "tool_type": "function", "description": "Count the divisors of an integer n.\n    :param n: The integer to count divisors for.\n    :return: The count of divisors of n.\n    \n    Examples:\n    >>> count_divisors(36)\n    9\n    >>> count_divisors(37)\n    2", "docstring": "Count the divisors of an integer n.\n    :param n: The integer to count divisors for.\n    :return: The count of divisors of n.\n    \n    Examples:\n    >>> count_divisors(36)\n    9\n    >>> count_divisors(37)\n    2", "Freq": 2, "TSR": 1}, {"tool": "def mod_multiply(a, b, n):\n    \n    return (a * b) % n", "subfield": "Properties of Integers", "tool_name": "mod_multiply", "tool_type": "function", "description": "Perform modular multiplication.", "docstring": "Perform modular multiplication.\n    Parameters:\n    a (int): First factor.\n    b (int): Second factor.\n    n (int): Modulus.\n    Returns:\n    int: Result of (a * b) % n.\n    Examples:\n    >>> mod_multiply(3, 4, 5)\n    2", "Freq": 1, "TSR": 0}, {"tool": "def is_odd(numbers):\n    \n    return [number % 2 != 0 for number in numbers]", "subfield": "Properties of Integers", "tool_name": "is_odd", "tool_type": "function", "description": "Determine if a number is odd.", "docstring": "Determine if a number is odd.\n    Parameters:\n    - numbers (list[int]): The numbers to check.\n    Returns:\n    - list[bool]: A list of booleans indicating if each number is odd (True) or even (False).", "Freq": 1, "TSR": 1, "experience_pool": "Experience 1:\nProblem: What is the sum of all odd numbers between 1 and 100?\n\nAnswer: 2500\n```python\ndef solution():\n    \"\"\"Find the sum of all odd numbers between 1 and 100.\"\"\"\n    numbers = list(range(1, 101))\n    odd_numbers = is_odd(numbers)\n    sum_odd_numbers = sum([number for number, is_odd in zip(numbers, odd_numbers) if is_odd])\n    return sum_odd_numbers\n\nprint(solution())\n```\nOutput: 2500\n\nExperience 2:\nProblem: What is the product of all even numbers between 1 and 50?\n\nAnswer: 6710886400\n```python\ndef solution():\n    \"\"\"Find the product of all even numbers between 1 and 50.\"\"\"\n    numbers = list(range(1, 51))\n    odd_numbers = is_odd(numbers)\n    product_even_numbers = 1\n    for number, is_odd in zip(numbers, odd_numbers):\n        if not is_odd:\n            product_even_numbers *= number\n    return product_even_numbers\n\nprint(solution())\n```\nOutput: 6710886400"}, {"tool": "def check_divisibility(n, div):\n    \n    return n % div == 0", "subfield": "Properties of Integers", "tool_name": "check_divisibility", "tool_type": "function", "description": "Determines if n is divisible by div.", "docstring": "Determines if n is divisible by div.\n    Parameters:\n    - n (int): The number to be checked.\n    - div (int): The divisor.\n    Returns:\n    - bool: True if n is divisible by div, False otherwise.", "Freq": 0, "TSR": 0}, {"tool": "def modular_add(a, b, mod):\n    \n    return (a + b) % mod", "subfield": "Properties of Integers", "tool_name": "modular_add", "tool_type": "function", "description": "Perform modular addition.", "docstring": "Perform modular addition.\n    \n    Parameters:\n        a (int): The first operand.\n        b (int): The second operand.\n        mod (int): The modulus.\n    Returns:\n        int: The result of (a + b) % mod.\n    Examples:\n        >>> modular_add(3, 4, 5)\n        2", "Freq": 7, "TSR": 4, "experience_pool": "Experience 1:\nProblem: What is the units digit of the sum of the nine terms of the sequence $1! + 1, \\, 2! + 2, \\, 3! + 3, \\, ..., \\, 8! + 8, \\, 9! + 9$?\nAnswer: 8\nSolution: The units digit of a number can be obtained by taking the number modulo 10. To find the units digit of the sum of the terms in the sequence, we can iterate through the numbers from 1 to 9, calculate the factorial of each number, add it to the number itself, and take the units digit of the sum using the `modular_add` function. Finally, we return the units digit of the total sum using the `units_digit` function.\n\n```python\ndef solution():\n    total = 0\n    for i in range(1, 10):\n        total = modular_add(total, (modular_add(mod_factorial(i), i, 10)), 10)\n    return units_digit(total)\n\nprint(solution())\n```\n\nExperience 2:\nProblem: What is the units digit of the sum of the nine terms of the sequence $1! + 1, \\, 2! + 2, \\, 3! + 3, \\, ..., \\, 8! + 8, \\, 9! + 9$?\nAnswer: 8\nSolution: The units digit of a number can be obtained by taking the number modulo 10. To find the units digit of the sum of the terms in the sequence, we can iterate through the numbers from 1 to 9, calculate the factorial of each number, add it to the number itself, and take the units digit of the sum using the `modular_add` function. Finally, we return the units digit of the total sum using the `units_digit` function.\n\n```python\ndef solution():\n    total = 0\n    for i in range(1, 10):\n        total = modular_add(total, (modular_add(mod_factorial(i), i, 10)), 10)\n    return units_digit(total)\n\nprint(solution())\n```"}, {"tool": "def mod_subtract(a, b, n):\n    \n    return (a - b) % n", "subfield": "Properties of Integers", "tool_name": "mod_subtract", "tool_type": "function", "description": "Perform modular subtraction.", "docstring": "Perform modular subtraction.\n    Parameters:\n    a (int): Minuend.\n    b (int): Subtrahend.\n    n (int): Modulus.\n    Returns:\n    int: Result of (a - b) % n.\n    Examples:\n    >>> mod_subtract(5, 3, 7)\n    2", "Freq": 5, "TSR": 1, "experience_pool": "- To find the sum of all integers for which the square is 182 greater than the integer itself, use the mod_subtract function with appropriate parameters. For example, mod_subtract(1, -13, 1) is not the correct usage.\n- Make sure to define all the necessary functions before using them in the code. In the second wrong tool calling, the \"absolute_value\" function is not defined, causing a ZeroDivisionError."}, {"tool": "def mod_exponent(base, exponent, modulus):\n    \n    return pow(base, exponent, modulus)", "subfield": "Properties of Integers", "tool_name": "mod_exponent", "tool_type": "function", "description": "Computes (base^exponent) % modulus using efficient exponentiation.", "docstring": "Computes (base^exponent) % modulus using efficient exponentiation.\n    Parameters:\n    base (int): Base of the exponentiation.\n    exponent (int): Exponent.\n    modulus (int): Modulus.\n    Returns:\n    int: Result of (base^exponent) % modulus.\n    Examples:\n    >>> mod_exponent(2, 10, 1000)\n    24", "Freq": 8, "TSR": 5, "experience_pool": "- Problem: Find the only real number that can be expressed in the form \\[(a + bi)^3 - 107i,\\]where $i^2 = -1,$ and $a$ and $b$ are positive integers.\n  - Answer: 198\n  - Code: `result = mod_exponent(a, 3, 11) - 3 * a * mod_exponent(b, 2, 11)`\n  - Output: -11\n- Problem: Find the only real number that can be expressed in the form \\[(a + bi)^3 - 107i,\\]where $i^2 = -1,$ and $a$ and $b$ are positive integers.\n  - Answer: 198\n  - Code: `result = mod_subtract(mod_exponent(a, 3, 11), 3 * a * mod_exponent(b, 2, 11), 11)`\n  - Output: 0\n- Problem: Evaluate $(2-w)(2-w^2)\\cdots(2-w^{10})$ where $w=e^{2\\pi i/11}.$\n  - Answer: 2047\n  - Code: \n    ```\n    result = 1\n    for k in range(1, 11):\n        w = mod_exponent(2, k, 11)\n        result = mod_multiply(result, 2 - w, 11)\n    ```\n  - Output: 0\n- Problem: $361+2(19)(6)+36=x$. Solve for $x$.\n  - Answer: 625\n  - Code: `x = mod_exponent(19, 2, 11) + 2 * 19 * 6 + mod_exponent(6, 2, 11)`\n  - Output: 240"}, {"tool": "def gcd_lcm_calculator(numbers):\n    \n    from math import gcd\n    result = {}\n    for i in range(0, len(numbers), 2):\n        a = numbers[i]\n        b = numbers[i+1]\n        gcd_value = gcd(a, b)\n        lcm_value = abs(a * b) // gcd_value\n        result[(str(a), str(b))] = (gcd_value, lcm_value)\n    return result", "subfield": "Properties of Integers", "tool_name": "gcd_lcm_calculator", "tool_type": "function", "description": "Calculate the Greatest Common Divisor (GCD) and Least Common Multiple (LCM)\n    of pairs of integers using Euclid's algorithm for GCD and the relation LCM * GCD = a * b.", "docstring": "Calculate the Greatest Common Divisor (GCD) and Least Common Multiple (LCM)\n    of pairs of integers using Euclid's algorithm for GCD and the relation LCM * GCD = a * b.\n    Parameters:\n    - numbers (list): List of integers\n    Returns:\n    - dict: Dictionary with the GCD and LCM for each pair of integers\n    Examples:\n    >>> gcd_lcm_calculator([12, 15, 100, 80])\n    {('12', '15'): (3, 60), ('100', '80'): (20, 400)}", "Freq": 3, "TSR": 2}, {"tool": "def is_divisible(n, k):\n    \n    return n % k == 0", "subfield": "Properties of Integers", "tool_name": "is_divisible", "tool_type": "function", "description": "Check if integer n is divisible by integer k.", "docstring": "Check if integer n is divisible by integer k.\n    Parameters:\n        n (int): The number to be divided.\n        k (int): The divisor.\n    Returns:\n        bool: True if n is divisible by k, False otherwise.\n    Examples:\n        >>> is_divisible(10, 5)\n        True\n        >>> is_divisible(10, 3)\n        False", "Freq": 0, "TSR": 0}, {"tool": "def list_primes(a, b):\n    \n    return list(primerange(a, b))", "subfield": "Properties of Integers", "tool_name": "list_primes", "tool_type": "function", "description": "Lists all primes in the range [a, b)", "docstring": "Lists all primes in the range [a, b)\n    Parameters:\n    - a (int): Start of the range (inclusive).\n    - b (int): End of the range (exclusive).\n    Returns:\n    - list: List of prime numbers between a and b.\n    Examples:\n    >>> list_primes(10, 20)\n    [11, 13, 17, 19]", "Freq": 1, "TSR": 1}, {"tool": "def integer_sign(n):\n    \n    if n < 0:\n        return -1\n    elif n > 0:\n        return 1\n    else:\n        return 0", "subfield": "Properties of Integers", "tool_name": "integer_sign", "tool_type": "function", "description": "Determine the sign of an integer.", "docstring": "Determine the sign of an integer.\n    Parameters:\n        n (int): The integer to check.\n    Returns:\n        int: -1 if negative, 1 if positive, 0 if zero.\n    Examples:\n        >>> integer_sign(-20)\n        -1\n        >>> integer_sign(15)\n        1", "Freq": 0, "TSR": 0}, {"tool": "def count_divisors(num):\n    count = 0\n    for i in range(1, num+1):\n        if num % i == 0:\n            count += 1\n    return count", "subfield": "Properties of Integers", "tool_name": "count_divisors", "tool_type": "function", "description": "None", "docstring": null, "Freq": 1, "TSR": 1, "experience_pool": "Experience 1:\nProblem: What is the positive integer $N$ for which $$ 22^2 \\times 55^2 = 10^2 \\times N^2 \\ ? $$\nAnswer: 121\n```python\n# Correct tool calling\nassert product_of_integers([22, 22, 55, 55]) == product_of_integers([10, 121, 121])\n```\n\nExperience 2:\nProblem: Forty teams play a tournament in which every team plays every other team exactly once. No ties occur, and each team has a $50 \\%$ chance of winning any game it plays. The probability that no two teams win the same number of games is $\\frac mn,$ where $m$ and $n$ are relatively prime positive integers. Find $\\log_2 n.$\n\nAnswer: 742\n```python\n# Define the count_divisors function\ndef count_divisors(num):\n    count = 0\n    for i in range(1, num+1):\n        if num % i == 0:\n            count += 1\n    return count\n\n# Correct tool calling\nnum_teams = 40\npowers_of_2 = num_teams - count_divisors(num_teams)\ndenominator = 2 ** powers_of_2\n```\n\nExperience 3:\nProblem: Write $x^{10} + x^5 + 1$ as the product of two polynomials with integer coefficients.\nAnswer: (x^2 + x + 1)(x^8 - x^7 + x^5 - x^4 + x^3 - x + 1)\n```python\n# Modify the tool code to handle the product of polynomials\ndef product_of_polynomials(poly1, poly2):\n    product = []\n    for i in range(len(poly1) + len(poly2) - 1):\n        product.append(0)\n    for i in range(len(poly1)):\n        for j in range(len(poly2)):\n            product[i+j] += poly1[i] * poly2[j]\n    return product\n\ndef solution():\n    x = 1\n    poly1 = [1, 1, 1]  # Coefficients of x^2 + x + 1\n    poly2 = [1, -1, 1, -1, 1, -1, 1, 0, 1]  # Coefficients of x^8 - x^7 + x^5 - x^4 + x^3 - x + 1\n    result = product_of_polynomials(poly1, poly2)\n    return result\n\nprint(solution())\n```"}, {"tool": "def consecutive_primes(n):\n    \n    return list(sympy.primerange(1, sympy.prime(n)+1))", "subfield": "Properties of Integers", "tool_name": "consecutive_primes", "tool_type": "function", "description": "Generate a list of the first n prime numbers.", "docstring": "Generate a list of the first n prime numbers.\n    Parameters:\n        n (int): The number of primes to generate.\n    Returns:\n        list: A list of the first n primes.\n    Examples:\n        >>> consecutive_primes(5)\n        [2, 3, 5, 7, 11]", "Freq": 0, "TSR": 0}, {"tool": "def count_factors(n):\n    \n    if n <= 0:\n        raise ValueError(\"n must be a positive integer\")\n    factors = sympy.divisors(n)\n    return len(factors)", "subfield": "Properties of Integers", "tool_name": "count_factors", "tool_type": "function", "description": "Count the number of factors of an integer.", "docstring": "Count the number of factors of an integer.\n    Parameters:\n    - n (int): The integer to count factors for.\n    \n    Returns:\n    - int: Number of factors of n.\n    \n    Examples:\n    >>> count_factors(12)\n    6", "Freq": 0, "TSR": 0}, {"tool": "def calculate_lcm(numbers):\n    \n    return int(np.lcm.reduce(numbers))", "subfield": "Properties of Integers", "tool_name": "calculate_lcm", "tool_type": "function", "description": "Calculate least common multiple of a list of numbers.", "docstring": "Calculate least common multiple of a list of numbers.\n    Parameters:\n    - numbers : list of int\n        The list of integers for which to calculate the LCM.\n    \n    Returns:\n    - int\n        The least common multiple of the numbers.\n    \n    Examples:\n    >>> calculate_lcm([12, 15, 20])\n    60", "Freq": 0, "TSR": 0}, {"tool": "def integer_close_to_sqrt(n):\n    \n    return round(math.sqrt(n))", "subfield": "Properties of Integers", "tool_name": "integer_close_to_sqrt", "tool_type": "function", "description": "Finds the closest integer to the square root of n.", "docstring": "Finds the closest integer to the square root of n.\n    Parameters:\n    - n (int): The number to find the square root of.\n    Returns:\n    - int: The integer closest to the square root of n.\n    Examples:\n    >>> integer_close_to_sqrt(10)\n    3\n    >>> integer_close_to_sqrt(15)\n    4", "Freq": 2, "TSR": 0}, {"tool": "def gcd(a, b):\n    \n    from math import gcd as compute_gcd\n    return compute_gcd(a, b)", "subfield": "Properties of Integers", "tool_name": "gcd", "tool_type": "function", "description": "Compute the greatest common divisor of two integers.", "docstring": "Compute the greatest common divisor of two integers.\n    \n    Parameters:\n    - a (int): First integer.\n    - b (int): Second integer.\n    Returns:\n    int: The greatest common divisor of a and b.\n    \n    Examples:\n    >>> gcd(12, 15)\n    3\n    >>> gcd(3, 7)\n    1", "Freq": 8, "TSR": 7}, {"tool": "def solve_diophantine(a, b, c):\n    \n    from math import gcd\n    if c % gcd(a, b) != 0:\n        return None\n    x, y = 0, c // b\n    while True:\n        if (c - b * y) % a == 0:\n            x = (c - b * y) // a\n            return (x, y)\n        y -= 1", "subfield": "Properties of Integers", "tool_name": "solve_diophantine", "tool_type": "function", "description": "Solve the linear Diophantine equation a*x + b*y = c for integers x and y.\n    Returns a single solution (x, y) if it exists.", "docstring": "Solve the linear Diophantine equation a*x + b*y = c for integers x and y.\n    Returns a single solution (x, y) if it exists.\n    Parameters:\n        a (int): Coefficient of x.\n        b (int): Coefficient of y.\n        c (int): Constant term.\n    Returns:\n        tuple: a tuple (x, y) representing a solution, if it exists.\n        None: if no integer solution exists.\n    Examples:\n        >>> solve_diophanine(3, -9, 12)\n        None\n        >>> solve_diophanine(2, 3, 5)\n        (1, 1)", "Freq": 0, "TSR": 0}, {"tool": "def arithmetic_sequence_sum(a, d, n):\n    \n    return n * (2 * a + (n - 1) * d) // 2", "subfield": "Properties of Integers", "tool_name": "arithmetic_sequence_sum", "tool_type": "function", "description": "Calculate the sum of the first n terms of an arithmetic sequence.", "docstring": "Calculate the sum of the first n terms of an arithmetic sequence.\n    Parameters:\n        a (int): The first term of the sequence.\n        d (int): The common difference between consecutive terms.\n        n (int): The number of terms.\n    Returns:\n        int: The sum of the first n terms of the sequence.\n    Examples:\n        >>> arithmetic_sequence_sum(1, 1, 5)\n        15", "Freq": 2, "TSR": 2}, {"tool": "def lcm(x, y):\n    \n    return abs(x*y) // gcd(x, y)", "subfield": "Properties of Integers", "tool_name": "lcm", "tool_type": "function", "description": "Compute the least common multiple (LCM) of two numbers based on their GCD.", "docstring": "Compute the least common multiple (LCM) of two numbers based on their GCD.\n    \n    Parameters:\n    - x: int, the first number.\n    - y: int, the second number.\n    \n    Returns:\n    - int, the LCM of the two numbers.\n    \n    Example:\n    >>> lcm(4, 5)\n    20", "Freq": 0, "TSR": 0}, {"tool": "def reverse_digits(n):\n    \n    return int(str(n)[::-1]) if n >= 0 else -int(str(-n)[::-1])", "subfield": "Properties of Integers", "tool_name": "reverse_digits", "tool_type": "function", "description": "Reverse the digits of an integer.", "docstring": "Reverse the digits of an integer.\n    \n    Parameters:\n        n (int): The integer to be reversed.\n    \n    Returns:\n        int: The integer formed by reversing the digits of `n`.\n    \n    Example:\n        >>> reverse_digits(123)\n        321", "Freq": 0, "TSR": 0}, {"tool": "def arithmetic_modulo_n(a, b, mod, operation='add'):\n    \n    operations = {\n        'add': (a + b) % mod,\n        'subtract': (a - b) % mod,\n        'multiply': (a * b) % mod\n    }\n    return operations.get(operation, None)", "subfield": "Properties of Integers", "tool_name": "arithmetic_modulo_n", "tool_type": "function", "description": "Perform arithmetic operations on two integers modulo `n`.", "docstring": "Perform arithmetic operations on two integers modulo `n`.\n    Parameters:\n    a : int\n        The first operand.\n    b : int\n        The second operand.\n    mod : int\n        The modulo value.\n    operation : str\n        The operation to perform ('add', 'subtract', 'multiply').\n    Returns:\n    int\n        The result of the operation performed modulo `n`.\n    Examples:\n    >>> arithmetic_modulo_n(3, 5, 6, 'add')\n    2\n    >>> arithmetic_modulo_n(4, 3, 5, 'multiply')\n    2", "Freq": 0, "TSR": 0}, {"tool": "def integer_base_conversion_and_divisibility():\n    \n    from sympy import isprime\n    import math\n    def convert_base(n, from_base, to_base):\n        \n        if from_base != 10:\n            n = int(n, from_base)\n        if to_base == 10:\n            return str(n)\n        else:\n            digits = \"0123456789ABCDEF\"\n            result = \"\"\n            while n > 0:\n                result = digits[n % to_base] + result\n                n //= to_base\n            return result or \"0\"\n    def is_divisible(n, divisor):\n        \n        return n % divisor == 0\n    \n    def repeating_decimal_period(n):\n        \n        remainders = {}\n        remainder = 1\n        position = 0\n        while remainder and remainder not in remainders:\n            remainders[remainder] = position\n            remainder = (remainder * 10) % n\n            position += 1\n        return 0 if not remainder else position - remainders[remainder]\n    base_utils = {\n        'convert_base': convert_base,\n        'is_divisible': is_divisible,\n        'repeating_decimal_period': repeating_decimal_period\n    }\n    return base_utils", "subfield": "Properties of Integers", "tool_name": "integer_base_conversion_and_divisibility", "tool_type": "function", "description": "A collection of utility functions for base conversion and checking divisibility rules.\n    Includes functions for converting numbers between different bases, checking divisibility,\n    and analyzing repeating decimals.", "docstring": "A collection of utility functions for base conversion and checking divisibility rules.\n    Includes functions for converting numbers between different bases, checking divisibility,\n    and analyzing repeating decimals.", "Freq": 1, "TSR": 1}, {"tool": "def basic_modular_operations(a, b, m, operation):\n    \n    if operation == 'add':\n        return (a + b) % m\n    elif operation == 'subtract':\n        return (a - b) % m\n    elif operation == 'multiply':\n        return (a * b) % m\n    else:\n        raise ValueError(\"Unsupported operation\")", "subfield": "Properties of Integers", "tool_name": "basic_modular_operations", "tool_type": "function", "description": "Performs basic modular arithmetic operations between two numbers.", "docstring": "Performs basic modular arithmetic operations between two numbers.\n    Parameters:\n    - a (int): The first number.\n    - b (int): The second number.\n    - m (int): The modulus.\n    - operation (str): The operation to perform ('add', 'subtract', 'multiply').\n    Returns:\n    - int: The result of the operation under modulo m.", "Freq": 0, "TSR": 0}, {"tool": "def gcd(x, y):\n    \n    while y:\n        x, y = y, x % y\n    return x", "subfield": "Properties of Integers", "tool_name": "gcd", "tool_type": "function", "description": "Compute the greatest common divisor (GCD) of two numbers using the Euclidean algorithm.", "docstring": "Compute the greatest common divisor (GCD) of two numbers using the Euclidean algorithm.\n    \n    Parameters:\n    - x: int, the first number.\n    - y: int, the second number.\n    \n    Returns:\n    - int, the GCD of x and y.\n    \n    Example:\n    >>> gcd(48, 18)\n    6", "Freq": 0, "TSR": 0}, {"tool": "def count_fourth_powers(a, b):\n    \n    low_n = int(math.pow(a, 0.25))\n    high_n = int(math.pow(b, 1/4))\n    count = 0\n    for n in range(low_n, high_n + 1):\n        if n**4 >= a and n**4 <= b:\n            count += 1\n    return count", "subfield": "Properties of Integers", "tool_name": "count_fourth_powers", "tool_type": "function", "description": "Count the number of fourth powers in the range [a, b].\n    x is considered a fourth power if x = n^4 for some integer n.", "docstring": "Count the number of fourth powers in the range [a, b].\n    x is considered a fourth power if x = n^4 for some integer n.\n    Parameters:\n        a (int): Start of the range.\n        b (int): End of the range.\n    Returns:\n        int: Count of fourth powers in the given range.\n    Examples:\n        >>> count_fourth_powers(1, 1000)\n        3\n        >>> count_fourth_powers(1, 10000)\n        4", "Freq": 1, "TSR": 1, "experience_pool": "Problem: How many positive integers $N$ less than $1000$ are there such that the equation $x^{\\lfloor x\\rfloor} = N$ has a solution for $x$?\nAnswer: 412\n```python\ndef solution():\n    return count_floor_equation_solutions(412)\n\nprint(solution())\n```\nOutput: 3"}, {"tool": "def extended_gcd(a, b):\n    \n    if a == 0:\n        return (b, 0, 1)\n    else:\n        gcd, x1, y1 = extended_gcd(b % a, a)\n        x = y1 - (b // a) * x1\n        y = x1\n        return (gcd, x, y)", "subfield": "Properties of Integers", "tool_name": "extended_gcd", "tool_type": "function", "description": "Compute the extended greatest common divisor of a and b, and return the coefficients of Bezout's identity.", "docstring": "Compute the extended greatest common divisor of a and b, and return the coefficients of Bezout's identity.\n    \n    Parameters:\n        a (int): First number.\n        b (int): Second number.\n    Returns:\n        (gcd, x, y) (tuple): gcd is the greatest common divisor of a and b.\n                             x and y are the coefficients of Bezout's identity, i.e., ax + by = gcd\n    Examples:\n        >>> extended_gcd(12, 15)\n        (3, -1, 1)", "Freq": 0, "TSR": 0}, {"tool": "def modulus_divisibility(num, base, mod):\n    \n    return (num % base) % mod == 0", "subfield": "Properties of Integers", "tool_name": "modulus_divisibility", "tool_type": "function", "description": "Checks divisibility of the number num with respect to a base after applying modulus operation.", "docstring": "Checks divisibility of the number num with respect to a base after applying modulus operation.\n    Parameters:\n        num (int): The number to check.\n        base (int): The base for modulus operation.\n        mod (int): The modulus divisor.\n    Returns:\n        bool: True if the number's modulus in the given base is divisible by mod, else False.\n    Examples:\n        >>> modulus_divisibility(20, 10, 2)\n        True\n        >>> modulus_divisibility(21, 10, 2)\n        False", "Freq": 0, "TSR": 0}, {"tool": "def digit_sum(n):\n    \n    return sum(int(digit) for digit in str(abs(n)))", "subfield": "Properties of Integers", "tool_name": "digit_sum", "tool_type": "function", "description": "Calculate the sum of the digits of an integer.", "docstring": "Calculate the sum of the digits of an integer.\n    \n    Parameters:\n        n (int): The integer whose digits will be summed.\n    \n    Returns:\n        int: The sum of the digits of `n`.\n    \n    Example:\n        >>> digit_sum(123)\n        6", "Freq": 1, "TSR": 0}, {"tool": "def count_digits(n):\n    \n    return len(str(abs(n)))", "subfield": "Properties of Integers", "tool_name": "count_digits", "tool_type": "function", "description": "Count the number of digits in an integer.", "docstring": "Count the number of digits in an integer.\n    \n    Parameters:\n        n (int): The integer to count digits.\n    \n    Returns:\n        int: The number of digits in `n`.\n    \n    Example:\n        >>> count_digits(12345)\n        5", "Freq": 1, "TSR": 0}, {"tool": "def count_numbers_in_range(start, end, number_type):\n    \n    if number_type == 'even':\n        count = len([num for num in range(start, end) if num % 2 == 0])\n    elif number_type == 'odd':\n        count = len([num for num in range(start, end) if num % 2 != 0])\n    else:\n        raise ValueError(\"Invalid number_type. Valid options are 'even' and 'odd'.\")\n    return count", "subfield": "Properties of Integers", "tool_name": "count_numbers_in_range", "tool_type": "function", "description": "Count the number of even or odd numbers within a given range [start, end).", "docstring": "Count the number of even or odd numbers within a given range [start, end).\n    Parameters:\n    - start (int): The starting integer value of the range (inclusive).\n    - end (int): The ending integer value of the range (exclusive).\n    - number_type (str): The type of numbers to count. Valid options are 'even' and 'odd'.\n    Returns:\n    int: The count of even or odd numbers depending on the specified number_type.", "Freq": 1, "TSR": 1, "experience_pool": "- Experience 1:\n    - Field: Number Theory\n    - Subfield: Properties of Integers\n    - Tool Usage Frequency: 2\n    - Tool Success Rate: 50.0%\n    - Tool docstring: Count even and odd numbers within a given range [start, end).\n    - Tool code:\n    ```python\n    def count_even_odd_in_range(start, end):\n        count_even = len([num for num in range(start, end) if num % 2 == 0])\n        count_odd = (end - start) - count_even\n        return (count_even, count_odd)\n    ```\n    - Experience: The tool accurately counts the number of even and odd numbers within a given range. However, it could be improved to be more flexible and easier to use by allowing the user to specify whether they want to count even or odd numbers.\n- Experience 2:\n    - Field: Number Theory\n    - Subfield: Properties of Integers\n    - Tool Usage Frequency: 1\n    - Tool Success Rate: 100.0%\n    - Tool docstring: Count the number of even or odd numbers within a given range [start, end).\n    - Tool code:\n    ```python\n    def count_numbers_in_range(start, end, number_type):\n        if number_type == 'even':\n            count = len([num for num in range(start, end) if num % 2 == 0])\n        elif number_type == 'odd':\n            count = len([num for num in range(start, end) if num % 2 != 0])\n        else:\n            raise ValueError(\"Invalid number_type. Valid options are 'even' and 'odd'.\")\n        return count\n    ```\n    - Experience: The evolved tool code allows the user to specify whether they want to count even or odd numbers within a given range. This makes the tool more flexible and easier to use."}, {"tool": "def is_perfect_power(n, power):\n    \n    import sympy\n    root, perfect = sympy.ntheory.primetest.integer_nthroot(n, power)\n    return perfect", "subfield": "Properties of Integers", "tool_name": "is_perfect_power", "tool_type": "function", "description": "Checks if a number is a perfect power of another integer.", "docstring": "Checks if a number is a perfect power of another integer.\n    Parameters:\n    - n (int): The number to check.\n    - power (int): The power to test.\n    Returns:\n    bool: True if n is a perfect power of 'power', else False.\n    Example:\n    >>> is_perfect_power(64, 2)\n    True\n    >>> is_perfect_power(65, 2)\n    False", "Freq": 0, "TSR": 0}, {"tool": "def list_perfect_squares(limit):\n    \n    return [i * i for i in range(int(math.sqrt(limit)) + 1)]", "subfield": "Properties of Integers", "tool_name": "list_perfect_squares", "tool_type": "function", "description": "Lists all perfect squares up to a given limit.\n    :param limit: The upper limit (inclusive) for listing perfect squares.\n    :return: A list of all perfect squares up to 'limit'.\n    \n    Examples:\n    >>> list_perfect_squares(30)\n    [0, 1, 4, 9, 16, 25]", "docstring": "Lists all perfect squares up to a given limit.\n    :param limit: The upper limit (inclusive) for listing perfect squares.\n    :return: A list of all perfect squares up to 'limit'.\n    \n    Examples:\n    >>> list_perfect_squares(30)\n    [0, 1, 4, 9, 16, 25]", "Freq": 2, "TSR": 2}, {"tool": "def filter_divisible_numbers(start, end, divisor):\n    \n    return [x for x in range(start, end + 1) if x % divisor == 0]", "subfield": "Properties of Integers", "tool_name": "filter_divisible_numbers", "tool_type": "function", "description": "Generates a list of numbers within the specified range that are divisible by the given divisor.", "docstring": "Generates a list of numbers within the specified range that are divisible by the given divisor.\n    Parameters:\n    start : int\n        The starting value of the range (inclusive).\n    end : int\n        The ending value of the range (inclusive).\n    divisor : int\n        The divisor used for filtering numbers.\n    Returns:\n    list of int\n        List of integers within the specified range that are divisible by the divisor.\n    Examples:\n    >>> filter_divisible_numbers(1, 10, 2)\n    [2, 4, 6, 8, 10]\n    >>> filter_divisible_numbers(1, 10, 3)\n    [3, 6, 9]", "Freq": 0, "TSR": 0}, {"tool": "def extended_euclidean_algorithm(a, b):\n    \n    if a == 0:\n        return (b, 0, 1)\n    else:\n        gcd, x1, y1 = extended_euclidean_algorithm(b % a, a)\n        x = y1 - (b // a) * x1\n        y = x1\n        return (gcd, x, y)", "subfield": "Properties of Integers", "tool_name": "extended_euclidean_algorithm", "tool_type": "function", "description": "Applies the Extended Euclidean Algorithm to find integers x, y such that ax + by = gcd(a, b).", "docstring": "Applies the Extended Euclidean Algorithm to find integers x, y such that ax + by = gcd(a, b).\n    Parameters:\n    - a (int): First integer\n    - b (int): Second integer\n    \n    Returns:\n    - tuple: gcd of a and b, and coefficients x, y such that ax + by = gcd(a, b)\n    Examples:\n    >>> extended_euclidean_algorithm(10, 6)\n    (2, 1, -1)\n    >>> extended_euclidean_algorithm(113, 57)\n    (1, 5, -10)", "Freq": 0, "TSR": 0}, {"tool": "def next_prime(n):\n    \n    test_num = n + 1\n    while True:\n        if is_prime(test_num):\n            return test_num\n        test_num += 1", "subfield": "Properties of Integers", "tool_name": "next_prime", "tool_type": "function", "description": "Find the smallest prime number greater than n.", "docstring": "Find the smallest prime number greater than n.\n    Parameters:\n    n (int): Starting number to find the next prime.\n    Returns:\n    int: The next prime number after n.\n    Example:\n    >>> next_prime(28)\n    29", "Freq": 0, "TSR": 0}, {"tool": "def classify_integer(n):\n    \n    if n > 0:\n        return \"positive\"\n    elif n < 0:\n        return \"negative\"\n    else:\n        return \"zero\"", "subfield": "Properties of Integers", "tool_name": "classify_integer", "tool_type": "function", "description": "Classifies an integer as positive, negative, or zero.", "docstring": "Classifies an integer as positive, negative, or zero.\n    Parameters:\n    - n (int): The integer to classify.\n    \n    Returns:\n    - str: \"positive\", \"negative\", or \"zero\" based on the value of n.\n    \n    Examples:\n    >>> classify_integer(10)\n    'positive'\n    >>> classify_integer(-5)\n    'negative'\n    >>> classify_integer(0)\n    'zero'", "Freq": 0, "TSR": 0}, {"tool": "def is_relatively_prime(x, y):\n    \n    def gcd(a, b):\n        \n        while b:\n            a, b = b, a % b\n        return a\n    return gcd(x, y) == 1", "subfield": "Properties of Integers", "tool_name": "is_relatively_prime", "tool_type": "function", "description": "Check if two numbers are relatively prime.", "docstring": "Check if two numbers are relatively prime.\n    Parameters:\n    - x: int, the first number.\n    - y: int, the second number.\n    Returns:\n    - bool, True if x and y are relatively prime, False otherwise.", "Freq": 1, "TSR": 1, "experience_pool": "- Experience: The original tool code did not correctly calculate the greatest common divisor (gcd) of two numbers. The gcd function was missing from the code, which caused the tool to fail in determining if two numbers are relatively prime. I have added the gcd function to the code to fix this issue.\n- Solution: The tool can be used to determine if two numbers are relatively prime by calling the is_relatively_prime function with the two numbers as arguments."}, {"tool": "def units_digit(number):\n    \n    return abs(number) % 10", "subfield": "Properties of Integers", "tool_name": "units_digit", "tool_type": "function", "description": "Return the units digit of a number.", "docstring": "Return the units digit of a number.\n    Parameters:\n    - number (int): The number to get the units digit from.\n    Returns:\n    - int: The units digit of the number.\n    Examples:\n    >>> units_digit(123)\n    3\n    >>> units_digit(-476)\n    6", "Freq": 2, "TSR": 0}, {"tool": "def integer_digit_manipulation():\n    \n    import numpy as np\n    from sympy import isprime\n    \n    def reverse_digits(n):\n        return int(str(n)[::-1])\n    \n    def sum_digits(n):\n        return sum(map(int, str(n)))\n    \n    def is_palindrome(n):\n        s = str(n)\n        return s == s[::-1]\n    \n    def get_digit(n, position):\n        return int(str(n)[::-1][position])\n    \n    def count_digits(n):\n        return len(str(n))\n    \n    def is_prime(n):\n        return isprime(n)\n    \n    def count_even_odd_in_range(start, end):\n        count_even = 0\n        count_odd = 0\n        for num in range(start, end):\n            if num % 2 == 0:\n                count_even += 1\n            else:\n                count_odd += 1\n        return count_even, count_odd\n    \n    def generate_numbers_with_properties():\n        count_even, count_odd = count_even_odd_in_range(66, 100)\n        numbers = []\n        for tens_digit in range(1, 10, 2):\n            for units_digit in range(0, 10, 2):\n                number = tens_digit * 10 + units_digit\n                numbers.append(number)\n        return numbers\n    \n    digit_utils = {\n        'reverse_digits': reverse_digits,\n        'sum_digits': sum_digits,\n        'is_palindrome': is_palindrome,\n        'get_digit': get_digit,\n        'count_digits': count_digits,\n        'is_prime': is_prime,\n        'generate_numbers_with_properties': generate_numbers_with_properties\n    }\n    return digit_utils", "subfield": "Properties of Integers", "tool_name": "integer_digit_manipulation", "tool_type": "function", "description": "None", "docstring": null, "Freq": 3, "TSR": 1, "experience_pool": "The tool has been evolved to include a new function called `generate_numbers_with_properties` that generates all two-digit numbers with the specified properties. This function will be useful for solving the problem of guessing a secret number. The tool code has been updated accordingly."}, {"tool": "def check_congruence(a, b, m):\n    \n    return (a - b) % m == 0", "subfield": "Properties of Integers", "tool_name": "check_congruence", "tool_type": "function", "description": "Checks if two numbers are congruent modulo another number.\n    :param a: The first integer.\n    :param b: The second integer.\n    :param m: The modulus.\n    :return: True if a ≡ b (mod m), False otherwise.\n    \n    Examples:\n    >>> check_congruence(37, 57, 10)\n    True\n    >>> check_congruence(35, 57, 10)\n    False", "docstring": "Checks if two numbers are congruent modulo another number.\n    :param a: The first integer.\n    :param b: The second integer.\n    :param m: The modulus.\n    :return: True if a ≡ b (mod m), False otherwise.\n    \n    Examples:\n    >>> check_congruence(37, 57, 10)\n    True\n    >>> check_congruence(35, 57, 10)\n    False", "Freq": 4, "TSR": 2, "experience_pool": "Experience 1:\nProblem: Find the least positive four-digit solution to the following system of congruences. \\begin{align*}\n7x &\\equiv 21 \\pmod{14} \\\\\n2x+13 &\\equiv 16 \\pmod{9} \\\\\n-2x+1 &\\equiv x \\pmod{25} \\\\\n\\end{align*}\nAnswer: 1167\n\nSolution:\n```python\n# Define the congruences\ncongruences = [(21, 14), (16, 9), (1, 25)]\n\n# Calculate the least common multiple of the moduli\nlcm_moduli = 14 * 9 * 25\n\n# Initialize the solution\nx = 0\n\n# Check for a solution\nwhile True:\n    if all(check_congruence(x, a, m) for a, m in congruences):\n        print(x)\n        break\n    x += lcm_moduli\n```\n\nExperience 2:\nProblem: Determine the sum of all prime numbers $p$ for which there exists no integer solution in $x$ to the congruence $3(6x+1)\\equiv 4\\pmod p$.\nAnswer: 5\n\nSolution:\n```python\ndef solution():\n    \"\"\"Calculates the sum of all prime numbers p for which there exists no integer solution in x to the congruence 3(6x+1) ≡ 4 (mod p).\"\"\"\n    \n    primes_no_solution = []\n    \n    for p in range(2, 1000):  # Check prime numbers up to 1000\n        if is_prime(p):\n            if not check_congruence(18, 1, p):\n                primes_no_solution.append(p)\n    \n    sum_primes_no_solution = sum(primes_no_solution)\n    \n    return sum_primes_no_solution\n\nprint(solution())\n```"}, {"tool": "def is_whole_number(n):\n    \n    return n == int(n) and n >= 0", "subfield": "Properties of Integers", "tool_name": "is_whole_number", "tool_type": "function", "description": "Check if a number is a whole number (non-negative integer).", "docstring": "Check if a number is a whole number (non-negative integer).\n    Parameters:\n    - n (int/float): The number to check.\n    \n    Returns:\n    - bool: True if n is a whole number, False otherwise.\n    \n    Examples:\n    >>> is_whole_number(5)\n    True\n    >>> is_whole_number(-1)\n    False\n    >>> is_whole_number(3.5)\n    False", "Freq": 1, "TSR": 0}, {"tool": "def extract_digits(num):\n    \n    from math import floor, log10\n    if num == 0:\n        return [0]\n    digits = []\n    while num:\n        digits.append(num % 10)\n        num = num // 10\n    return digits[::-1]", "subfield": "Properties of Integers", "tool_name": "extract_digits", "tool_type": "function", "description": "Extracts and returns the digits of the given integer as a list.", "docstring": "Extracts and returns the digits of the given integer as a list.\n    Parameters:\n        num (int): The integer from which to extract the digits.\n    Returns:\n        list: Digits of the integer.\n    Examples:\n        >>> extract_digits(1234)\n        [1, 2, 3, 4]\n        >>> extract_digits(9075)\n        [9, 0, 7, 5]", "Freq": 1, "TSR": 0}, {"tool": "def is_divisible_by(n, d):\n    \n    if d == 0:\n        raise ValueError(\"Denominator must not be zero.\")\n    return n % d == 0", "subfield": "Properties of Integers", "tool_name": "is_divisible_by", "tool_type": "function", "description": "Determine if integer n is divisible by d.", "docstring": "Determine if integer n is divisible by d.\n    Parameters:\n    n (int): Numerator integer.\n    d (int): Denominator integer (must not be zero).\n    Returns:\n    bool: True if n is divisible by d, False otherwise.\n    Example:\n    >>> is_divisible_by(10, 2)\n    True", "Freq": 3, "TSR": 2, "experience_pool": "- Incorrect usage of `calculate_power` instead of `math.sin` to calculate `a0`."}, {"tool": "def calculate_power(base, exponent):\n    \n    return base ** exponent", "subfield": "Properties of Integers", "tool_name": "calculate_power", "tool_type": "function", "description": "Compute the power of a base raised to an exponent.", "docstring": "Compute the power of a base raised to an exponent.\n    Parameters:\n        base (float or int): The base number.\n        exponent (int): The power to raise the base to.\n    Returns:\n        float: The result of the exponentiation.\n    \n    Examples:\n    >>> calculate_power(2, 10)\n    1024", "Freq": 2, "TSR": 1, "experience_pool": "- Experience 1:\n    - Field: Number Theory\n    - Subfield: Properties of Integers\n    - Tool Usage Frequency: 2\n    - Tool Success Rate: 50.0%\n    - Tool docstring:\n        ```\n        Compute the power of a base raised to an exponent.\n        Parameters:\n            base (float or int): The base number.\n            exponent (int): The power to raise the base to.\n        Returns:\n            float: The result of the exponentiation.\n        \n        Examples:\n        >>> calculate_power(2, 10)\n        1024\n        ```\n    - Task: Find the smallest positive integer n such that a_n = a_0.\n    - Calling code:\n        ```python\n        def solution():\n            a0 = calculate_power(0.5, 2)  # a0 = sin^2(pi/45)\n            \n            n = 0\n            an = a0\n            while True:\n                if is_divisible_by(2 ** n - 1, 45) or is_divisible_by(2 ** n + 1, 45):\n                    break\n                n += 1\n                an = calculate_power(0.5, 2 * n)  # an = sin^2(2^n * pi / 45)\n            \n            return n\n        \n        print(solution())\n        ```\n    - Output: 0\n    - Error: The error is not related to the tool \"calculate_power\". The error is in the logic of the calling code, where the condition for breaking the loop is incorrect. The tool is used correctly in calculating the power of 0.5 raised to 2."}, {"tool": "def sum_of_digits(n):\n    \n    return sum(int(digit) for digit in str(abs(n)))", "subfield": "Properties of Integers", "tool_name": "sum_of_digits", "tool_type": "function", "description": "Calculate the sum of the digits of an integer.", "docstring": "Calculate the sum of the digits of an integer.\n    Parameters:\n    n (int): The integer to calculate the sum of digits for.\n    Returns:\n    int: The sum of the digits of n.", "Freq": 0, "TSR": 0}], "Floor and Ceiling Functions": [{"tool": "def floor_value(x):\n    \n    return math.floor(x)", "subfield": "Floor and Ceiling Functions", "tool_name": "floor_value", "tool_type": "function", "description": "Computes the floor of a given number.", "docstring": "Computes the floor of a given number.\n    Parameters:\n        x (float or int): The number from which the floor will be calculated.\n    Returns:\n        int: The floor value of x.\n    Examples:\n        >>> floor_value(3.7)\n        3\n        >>> floor_value(-1.2)\n        -2", "Freq": 11, "TSR": 9}, {"tool": "def ceiling_value(x):\n    \n    return math.ceil(x)", "subfield": "Floor and Ceiling Functions", "tool_name": "ceiling_value", "tool_type": "function", "description": "Computes the ceiling of a given number.", "docstring": "Computes the ceiling of a given number.\n    Parameters:\n        x (float or int): The number from which the ceiling will be calculated.\n    Returns:\n        int: The ceiling value of x.\n    Examples:\n        >>> ceiling_value(3.7)\n        4\n        >>> ceiling_value(-1.2)\n        -1", "Freq": 11, "TSR": 11}, {"tool": "def floor_ceil(value):\n    \n    from math import floor, ceil\n    return (floor(value), ceil(value))", "subfield": "Floor and Ceiling Functions", "tool_name": "floor_ceil", "tool_type": "function", "description": "Calculate the floor and ceiling of a given numerical value.", "docstring": "Calculate the floor and ceiling of a given numerical value.\n    Parameters:\n    - value (float): The real number from which the floor and ceiling values are to be computed.\n    Returns:\n    - tuple: A tuple containing the floor value and the ceiling value respectively.\n    Examples:\n    >>> floor_ceil(3.7)\n    (3, 4)\n    >>> floor_ceil(-2.5)\n    (-3, -2)", "Freq": 0, "TSR": 0}, {"tool": "def floor_ceiling_expression_evaluator(expression):\n    \n    allowed_builtins = {\"math\": math}\n    result = eval(expression, {\"__builtins__\": None}, allowed_builtins)\n    return result", "subfield": "Floor and Ceiling Functions", "tool_name": "floor_ceiling_expression_evaluator", "tool_type": "function", "description": "Evaluate an expression involving floor or ceiling functions.", "docstring": "Evaluate an expression involving floor or ceiling functions.\n    Parameters:\n    - expression (str): The string of the expression involving floor and ceiling operations.\n    Returns:\n    - float: The result of the evaluated expression.\n    Examples:\n    >>> floor_ceiling_expression_evaluator(\"math.floor(3.7) + math.ceil(-2.3)\")\n    1\n    >>> floor_ceiling_expression_evaluator(\"math.floor(math.sqrt(10)) * 2\")\n    6", "Freq": 3, "TSR": 3}, {"tool": "def arithmetic_with_floor_ceil(a, b, operation):\n    \n    from math import floor, ceil\n    methods = {\n        'add': lambda x, y: floor(x) + ceil(y),\n        'subtract': lambda x, y: ceil(x) - floor(y),\n        'multiply': lambda x, y: ceil(x) * floor(y)\n    }\n    if operation in methods:\n        return methods[operation](a, b)\n    else:\n        raise ValueError(\"Unsupported operation. Use 'add', 'subtract', or 'multiply'.\")", "subfield": "Floor and Ceiling Functions", "tool_name": "arithmetic_with_floor_ceil", "tool_type": "function", "description": "Perform arithmetic operations using floor and ceiling values of the provided numbers.", "docstring": "Perform arithmetic operations using floor and ceiling values of the provided numbers.\n    \n    Parameters:\n    - a (float): The first real number.\n    - b (float): The second real number.\n    - operation (str): The arithmetic operation to perform. Supported operations are 'add', 'subtract', 'multiply'.\n    Returns:\n    - int: The result of the arithmetic operation applied using the floor/ceil values of the given numbers.\n    Examples:\n    >>> arithmetic_with_floor_ceil(3.2, 5.8, 'add')\n    (floor(3.2) + ceil(5.8)) = 3 + 6 = 9\n    >>> arithmetic_with_floor_ceil(-2.5, 4.1, 'multiply')\n    (ceil(-2.5) * floor(4.1)) = -2 * 4 = -8", "Freq": 2, "TSR": 0}, {"tool": "def calculate_fractional_part(number):\n    \n    \n    return number - math.floor(number)", "subfield": "Floor and Ceiling Functions", "tool_name": "calculate_fractional_part", "tool_type": "function", "description": "This function calculates and returns the fractional part of a given number.", "docstring": "This function calculates and returns the fractional part of a given number.\n    \n    Parameters:\n    -----------\n    number : float\n        The number for which the fractional part is to be calculated.\n        \n    Returns:\n    --------\n    float :\n        The fractional part of the given number.\n        \n    Examples:\n    ---------\n    >>> calculate_fractional_part(4.2)\n    0.2\n    >>> calculate_fractional_part(-3.9)\n    0.1", "Freq": 1, "TSR": 0}, {"tool": "def calculate_floor(number):\n    \n    \n    return math.floor(number)", "subfield": "Floor and Ceiling Functions", "tool_name": "calculate_floor", "tool_type": "function", "description": "This function calculates and returns the floor value of a given number.", "docstring": "This function calculates and returns the floor value of a given number.\n    \n    Parameters:\n    -----------\n    number : float\n        The number for which the floor value is to be calculated.\n        \n    Returns:\n    --------\n    float :\n        The floor value of the given number.\n        \n    Examples:\n    ---------\n    >>> calculate_floor(4.2)\n    4\n    >>> calculate_floor(-3.9)\n    -4", "Freq": 2, "TSR": 2}, {"tool": "def calculate_ceiling(number):\n    \n    \n    return math.ceil(number)", "subfield": "Floor and Ceiling Functions", "tool_name": "calculate_ceiling", "tool_type": "function", "description": "This function calculates and returns the ceiling value of a given number.", "docstring": "This function calculates and returns the ceiling value of a given number.\n    \n    Parameters:\n    -----------\n    number : float\n        The number for which the ceiling value is to be calculated.\n        \n    Returns:\n    --------\n    float :\n        The ceiling value of the given number.\n        \n    Examples:\n    ---------\n    >>> calculate_ceiling(4.2)\n    5\n    >>> calculate_ceiling(-3.9)\n    -3", "Freq": 0, "TSR": 0}], "Integer Properties": [{"tool": "def is_prime(n):\n    \n    return sympy.isprime(n)", "subfield": "Integer Properties", "tool_name": "is_prime", "tool_type": "function", "description": "Check if an integer is a prime number.", "docstring": "Check if an integer is a prime number.\n    Parameters:\n    n : int\n        The integer to check for primality.\n    Returns:\n    bool\n        True if n is a prime number, else False.\n    Examples:\n    >>> is_prime(29)\n    True", "Freq": 7, "TSR": 1}, {"tool": "def is_even(n):\n    \n    return n % 2 == 0", "subfield": "Integer Properties", "tool_name": "is_even", "tool_type": "function", "description": "Check if a number is even.", "docstring": "Check if a number is even.\n    \n    Parameters:\n    n (int): The number to check.\n    \n    Returns:\n    bool: True if the number is even, False otherwise.\n    \n    Example:\n    >>> is_even(4)\n    True\n    >>> is_even(5)\n    False", "Freq": 1, "TSR": 1}, {"tool": "def sum_of_digits(n):\n    \n    return sum(int(digit) for digit in str(abs(n)))", "subfield": "Integer Properties", "tool_name": "sum_of_digits", "tool_type": "function", "description": "Calculate the sum of digits of a given integer.", "docstring": "Calculate the sum of digits of a given integer.\n    Parameters:\n        n (int): The integer to calculate the sum of digits.\n    Returns:\n        int: Sum of the digits of n.", "Freq": 3, "TSR": 3}, {"tool": "def find_divisors(n):\n    \n    return sympy.divisors(n)", "subfield": "Integer Properties", "tool_name": "find_divisors", "tool_type": "function", "description": "Find all divisors of a given integer n.", "docstring": "Find all divisors of a given integer n.\n    Parameters:\n        n (int): The integer to find divisors of.\n    Returns:\n        list: A list of all divisors of n.", "Freq": 5, "TSR": 1}, {"tool": "def prime_factors(n):\n    \n    return factorint(n)", "subfield": "Integer Properties", "tool_name": "prime_factors", "tool_type": "function", "description": "Return the prime factorization of an integer n as a dictionary {prime: exponent}.", "docstring": "Return the prime factorization of an integer n as a dictionary {prime: exponent}.\n    Parameters:\n    - n (int): The number to factorize.\n    Returns:\n    - dict: A dictionary with primes as keys and their respective exponents as values.\n    Examples:\n    >>> prime_factors(18)\n    {2: 1, 3: 2}", "Freq": 4, "TSR": 2}, {"tool": "def is_perfect_cube(n):\n    \n    croot = int(round(n ** (1/3)))\n    return croot**3 == n", "subfield": "Integer Properties", "tool_name": "is_perfect_cube", "tool_type": "function", "description": "Check if a given integer n is a perfect cube.", "docstring": "Check if a given integer n is a perfect cube.\n    Parameters:\n    - n (int): The number to check.\n    Returns:\n    - bool: True if n is a perfect cube, False otherwise.\n    Examples:\n    >>> is_perfect_cube(27)\n    True\n    >>> is_perfect_cube(26)\n    False", "Freq": 0, "TSR": 0}, {"tool": "def compute_lcm(a, b):\n    \n    return abs(a*b) // gcd(a, b)", "subfield": "Integer Properties", "tool_name": "compute_lcm", "tool_type": "function", "description": "Compute the least common multiple of two integers a and b.", "docstring": "Compute the least common multiple of two integers a and b.\n    \n    Parameters:\n        a (int): First integer\n        b (int): Second integer\n    \n    Returns:\n        int: Least common multiple of a and b\n    \n    Examples:\n        >>> compute_lcm(6, 8)\n        24\n        >>> compute_lcm(5, 10)\n        10", "Freq": 0, "TSR": 0}, {"tool": "def is_perfect_square(n):\n    \n    sqrt_n = int(math.sqrt(n))\n    return sqrt_n * sqrt_n == n", "subfield": "Integer Properties", "tool_name": "is_perfect_square", "tool_type": "function", "description": "Check if a number is a perfect square.", "docstring": "Check if a number is a perfect square.\n    \n    Parameters:\n    - n: int, the number to check\n    \n    Returns:\n    - bool, True if n is a perfect square, False otherwise\n    \n    Examples:\n    >>> is_perfect_square(25)\n    True\n    >>> is_perfect_square(10)\n    False", "Freq": 1, "TSR": 1}, {"tool": "def is_odd(n):\n    \n    return n % 2 != 0", "subfield": "Integer Properties", "tool_name": "is_odd", "tool_type": "function", "description": "Check if a number is odd.", "docstring": "Check if a number is odd.\n    \n    Parameters:\n    n (int): The number to check.\n    \n    Returns:\n    bool: True if the number is odd, False otherwise.\n    \n    Example:\n    >>> is_odd(3)\n    True\n    >>> is_odd(4)\n    False", "Freq": 3, "TSR": 3}, {"tool": "def modular_inverse(a, m):\n    \n    from sympy import mod_inverse\n    try:\n        return mod_inverse(a, m)\n    except ValueError:\n        return None", "subfield": "Integer Properties", "tool_name": "modular_inverse", "tool_type": "function", "description": "Find the modular inverse of a under modulo m.", "docstring": "Find the modular inverse of a under modulo m.\n    Parameters:\n    - a (int): The number to find the inverse of.\n    - m (int): The modulus.\n    Returns:\n    - int/None: The modular inverse if it exists, otherwise None.\n    Examples:\n    - modular_inverse(3, 11) -> 4 (because (3*4) % 11 == 1)\n    - modular_inverse(10, 20) -> None (because 10 and 20 are not coprime)", "Freq": 3, "TSR": 2}, {"tool": "def is_valid_triangle(a, b, c):\n    \n    return (a + b > c) and (a + c > b) and (b + c > a)", "subfield": "Integer Properties", "tool_name": "is_valid_triangle", "tool_type": "function", "description": "Determines if three side lengths can form a triangle based on the triangle inequality theorem.", "docstring": "Determines if three side lengths can form a triangle based on the triangle inequality theorem.\n    \n    Parameters:\n    - a (int): length of side a\n    - b (int): length of side b\n    - c (int): length of side c\n    \n    Returns:\n    - bool: True if the sides can form a triangle, False otherwise\n    Examples:\n    >>> is_valid_triangle(3, 4, 5)\n    True\n    >>> is_valid_triangle(1, 2, 3)\n    False", "Freq": 0, "TSR": 0}, {"tool": "def triangle_combinations(max_side: int):\n    \n    from itertools import combinations_with_replacement\n    \n    valid_triangles = set()\n    for a, b, c in combinations_with_replacement(range(1, max_side + 1), 3):\n        if a + b > c and a + c > b and b + c > a:\n            valid_triangles.add(tuple(sorted([a, b, c])))\n    \n    return valid_triangles", "subfield": "Integer Properties", "tool_name": "triangle_combinations", "tool_type": "function", "description": "Generates all combinations of integer side lengths (a, b, c) such that they satisfy the triangle inequality.", "docstring": "Generates all combinations of integer side lengths (a, b, c) such that they satisfy the triangle inequality.\n    \n    Parameters:\n    - max_side (int): Maximum length for any side of the triangle.\n    \n    Returns:\n    - set of tuples: a set containing tuples (a, b, c), each being a valid triangle with sides a, b, and c.\n    \n    Example:\n    >>> triangle_combinations(5)\n    {(3, 4, 5), (2, 3, 4), (2, 2, 3), ...}", "Freq": 4, "TSR": 3}, {"tool": "def gcd(a, b):\n    \n    while b:\n        a, b = b, a % b\n    return a", "subfield": "Integer Properties", "tool_name": "gcd", "tool_type": "function", "description": "Compute the greatest common divisor of a and b.", "docstring": "Compute the greatest common divisor of a and b.\n    Parameters:\n    - a (int): First number.\n    - b (int): Second number.\n    Returns:\n    - int: The greatest common divisor of a and b.\n    \n    Example:\n    >>> gcd(48, 18)\n    6", "Freq": 3, "TSR": 2}, {"tool": "def is_divisible(n, m):\n    \n    return n % m == 0", "subfield": "Integer Properties", "tool_name": "is_divisible", "tool_type": "function", "description": "Checks if n is divisible by m.", "docstring": "Checks if n is divisible by m.\n    Parameters:\n    - n (int): The dividend.\n    - m (int): The divisor.\n    Returns:\n    - bool: True if n is divisible by m, False otherwise.\n    \n    Examples:\n    >>> is_divisible(20, 4)\n    True", "Freq": 2, "TSR": 0}, {"tool": "def extract_digits(n):\n    \n    return [int(x) for x in str(abs(n))]", "subfield": "Integer Properties", "tool_name": "extract_digits", "tool_type": "function", "description": "Extract digits of an integer n as a list.", "docstring": "Extract digits of an integer n as a list.\n    \n    Parameters:\n        n (int): The integer from which digits are to be extracted.\n        \n    Returns:\n        list: Digits of the given integer.\n    \n    Examples:\n        >>> extract_digits(123)\n        [1, 2, 3]", "Freq": 7, "TSR": 5}, {"tool": "def list_factors(n):\n    \n    return [i for i in range(1, n+1) if n % i == 0]", "subfield": "Integer Properties", "tool_name": "list_factors", "tool_type": "function", "description": "List all positive factors of a given integer.", "docstring": "List all positive factors of a given integer.\n    Parameters:\n    - n (int): The integer to find factors of.\n    Returns:\n    - list: A list of all positive factors of n.\n    Examples:\n    - list_factors(36) -> [1, 2, 3, 4, 6, 9, 12, 18, 36]", "Freq": 6, "TSR": 2}, {"tool": "def check_prime(number):\n    \n    return sympy.isprime(number)", "subfield": "Integer Properties", "tool_name": "check_prime", "tool_type": "function", "description": "Check if a number is prime using the sympy library.", "docstring": "Check if a number is prime using the sympy library.\n    Parameters:\n        number (int): The number to check for primality.\n    Returns:\n        bool: True if the number is prime, False otherwise.", "Freq": 0, "TSR": 0}, {"tool": "def sum_of_integers(n):\n    \n    return n * (n + 1) // 2", "subfield": "Integer Properties", "tool_name": "sum_of_integers", "tool_type": "function", "description": "Calculate the sum of the first n positive integers.", "docstring": "Calculate the sum of the first n positive integers.\n    \n    Parameters:\n    n : int\n        The number of terms.\n    \n    Returns:\n    int\n        The sum of the first n positive integers.\n    \n    Example:\n    >>> sum_of_integers(10)\n    55", "Freq": 2, "TSR": 2}, {"tool": "def is_square_free(n):\n    \n    if n < 2:\n        return True\n    for p in range(2, int(math.sqrt(n)) + 1):\n        if n % (p * p) == 0:\n            return False\n    return True", "subfield": "Integer Properties", "tool_name": "is_square_free", "tool_type": "function", "description": "Check if a number is square-free (not divisible by any perfect square other than 1).", "docstring": "Check if a number is square-free (not divisible by any perfect square other than 1).\n    \n    Parameters:\n    - n: int, the number to check\n    \n    Returns:\n    - bool, True if n is square-free, False otherwise\n    \n    Examples:\n    >>> is_square_free(30)\n    True\n    >>> is_square_free(12)\n    False", "Freq": 2, "TSR": 1}, {"tool": "def count_digit(n, digit):\n    \n    return str(n).count(str(digit))", "subfield": "Integer Properties", "tool_name": "count_digit", "tool_type": "function", "description": "Count occurrences of a specific digit in an integer.", "docstring": "Count occurrences of a specific digit in an integer.\n    \n    Parameters:\n        n (int): Integer to search within.\n        digit (int): Digit to count.\n        \n    Returns:\n        int: Number of times digit occurs in n.\n    \n    Examples:\n        >>> count_digit(1223, 2)\n        2", "Freq": 0, "TSR": 0}, {"tool": "def integer_solution_counter(func, lower_bound, upper_bound):\n    \n    import sympy as sp\n    \n    solutions = []\n    for x in sp.solveset(func(sp.symbols('x')), domain=sp.S.Integers):\n        if lower_bound <= x <= upper_bound:\n            solutions.append(int(x))\n    \n    return len(solutions), solutions", "subfield": "Integer Properties", "tool_name": "integer_solution_counter", "tool_type": "function", "description": "Counts and lists integer solutions for a given function within specified bounds.", "docstring": "Counts and lists integer solutions for a given function within specified bounds.\n    \n    Parameters:\n        func (function): A Python function that should return a boolean.\n                         It defines the conditions under which an integer is considered a solution.\n        lower_bound (int): The lower inclusive bound of the range to test.\n        upper_bound (int): The upper inclusive bound of the range to test.\n    \n    Returns:\n        tuple: First element is the count of solutions, the second element is a list of solutions.\n    \n    Examples:\n        >>> integer_solution_counter(lambda x: x % 2 == 0, 1, 10)\n        (5, [2, 4, 6, 8, 10])\n        >>> integer_solution_counter(lambda x: x**2 <= 50, -10, 10)\n        (15, [-7, -6, -5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7])", "Freq": 1, "TSR": 0}, {"tool": "def are_consecutive(numbers):\n    \n    sorted_numbers = sorted(numbers)\n    return all((sorted_numbers[i] + 1 == sorted_numbers[i + 1]\n                for i in range(len(sorted_numbers) - 1)))", "subfield": "Integer Properties", "tool_name": "are_consecutive", "tool_type": "function", "description": "Determine if a list of numbers consists of consecutive integers.", "docstring": "Determine if a list of numbers consists of consecutive integers.\n    Parameters\n    ----------\n    numbers : list of int\n        The list of integers to check.\n    Returns\n    -------\n    bool\n        True if integers are consecutive, otherwise False.\n    Examples\n    --------\n    >>> are_consecutive([1, 2, 3, 4])\n    True\n    >>> are_consecutive([1, 2, 4])\n    False", "Freq": 0, "TSR": 0}, {"tool": "def get_divisors(number):\n    \n    return divisors(number)", "subfield": "Integer Properties", "tool_name": "get_divisors", "tool_type": "function", "description": "Get all positive divisors of a given number.", "docstring": "Get all positive divisors of a given number.\n    \n    Parameters:\n    - number (int): The number to get divisors for.\n    \n    Returns:\n    - list: A list of all positive divisors.\n    \n    Examples:\n    >>> get_divisors(12)\n    [1, 2, 3, 4, 6, 12]", "Freq": 0, "TSR": 0}, {"tool": "def count_digit_combinations(digits, length, leading_zeros=False):\n    \n    if leading_zeros:\n        return product(digits, repeat=length)\n    return product([d for d in digits if d != 0], *[digits for _ in range(length - 1)])", "subfield": "Integer Properties", "tool_name": "count_digit_combinations", "tool_type": "function", "description": "Count possible numbers of a given length with specified digit constraints and optional leading zeros.", "docstring": "Count possible numbers of a given length with specified digit constraints and optional leading zeros.\n    \n    Parameters:\n    - digits (list): Allowed digits.\n    - length (int): Desired length of numbers.\n    - leading_zeros (bool): Whether leading zeros are allowed.\n    \n    Returns:\n    Iterator over all valid number combinations as strings.\n    \n    Examples:\n    >>> len(list(count_digit_combinations([1, 2, 3], 2, leading_zeros=False)))\n    9", "Freq": 2, "TSR": 1}, {"tool": "def find_factors(number):\n    \n    return list(sympy.divisors(number))", "subfield": "Integer Properties", "tool_name": "find_factors", "tool_type": "function", "description": "Find all positive factors of a given number.", "docstring": "Find all positive factors of a given number.\n    Parameters:\n        number (int): The number to factorize.\n    Returns:\n        list: A list of all positive factors of the number.", "Freq": 1, "TSR": 0}, {"tool": "def solve_sum_of_squares(target, limit=None):\n    \n    import math\n    if limit is None:\n        limit = int(math.sqrt(target))\n    solutions = []\n    for a in range(-limit, limit + 1):\n        for b in range(-limit, limit + 1):\n            if a**2 + b**2 == target:\n                solutions.append((a, b))\n    return solutions", "subfield": "Integer Properties", "tool_name": "solve_sum_of_squares", "tool_type": "function", "description": "Find pairs of integers (a, b) such that a^2 + b^2 = target, with an optional limit on values of a and b.", "docstring": "Find pairs of integers (a, b) such that a^2 + b^2 = target, with an optional limit on values of a and b.\n    \n    Parameters:\n        target (int): The target integer sum of squares.\n        limit (int, optional): Maximum absolute value for a and b. If not specified, it uses sqrt(target).\n    \n    Returns:\n        List[Tuple[int, int]]: A list of tuples (a, b) where both a^2 + b^2 equals to the target.\n    \n    Examples:\n        # Find integer solutions for a^2 + b^2 = 50\n        print(solve_sum_of_squares(50))\n        # Find integer solutions for a^2 + b^2 = 25 with |a|,|b| <= 5\n        print(solve_sum_of_squares(25, 5))", "Freq": 2, "TSR": 2}, {"tool": "def possible_numbers(digits, length, unique=False):\n    \n    if unique:\n        return [''.join(map(str, comb)) for comb in itertools.permutations(digits, length)]\n    else:\n                return [''.join(map(str, comb)) for comb in itertools.product(digits, repeat=length)]", "subfield": "Integer Properties", "tool_name": "possible_numbers", "tool_type": "function", "description": "Generate all possible numbers of a given length from specified digits.", "docstring": "Generate all possible numbers of a given length from specified digits.\n    \n    Parameters:\n        digits (list): Possible digits to use.\n        length (int): The length of numbers to generate.\n        unique (bool): If True, all digits in the number must be unique.\n        \n    Returns:\n        list: All possible numbers as strings.\n    \n    Examples:\n        >>> possible_numbers([1, 2, 3], 2)\n        ['11', '12', '13', '21', '22', '23', '31', '32', '33']\n        >>> possible_numbers([1, 2, 3], 2, unique=True)\n        ['12', '13', '21', '23', '31', '32']", "Freq": 1, "TSR": 1}, {"tool": "def basic_integer_operations(x, operation='floor', modulus=None, check_prime=False, get_divisors=False):\n    \n    if operation == 'floor':\n        result = floor(x)\n    elif operation == 'ceil':\n        result = ceil(x)\n    else:\n        result = x\n    \n    if modulus is not None:\n        result = x % modulus\n    \n    prime_status = isprime(x) if check_prime else None\n    divisor_list = divisors(x) if get_divisors else None\n    \n    return {'result': result, 'is_prime': prime_status, 'divisors': divisor_list}", "subfield": "Integer Properties", "tool_name": "basic_integer_operations", "tool_type": "function", "description": "Perform basic operations on an integer including floor, ceiling, modular arithmetic, \n    checking for primality, and getting divisors.", "docstring": "Perform basic operations on an integer including floor, ceiling, modular arithmetic, \n    checking for primality, and getting divisors.\n    \n    Parameters:\n        x (int): The integer on which to perform operations.\n        operation (str, optional): The type of mathematical floor/ceiling operation (`floor`, `ceil`). Defaults to 'floor'.\n        modulus (int, optional): For modulus operation. If provided, function returns x % modulus.\n        check_prime (bool, optional): If True, checks whether the integer is prime. Defaults to False.\n        get_divisors (bool, optional): If True, returns all divisors of x. Defaults to False.\n    \n    Returns:\n        Various outputs depending on inputs: transformed integer, boolean for primality, list of divisors.\n    \n    Examples:\n        >> basic_integer_operations(17.7, 'floor')\n        17\n        >> basic_integer_operations(28, modulus=5)\n        3\n        >> basic_integer_operations(11, check_prime=True)\n        True\n        >> basic_integer_operations(12, get_divisors=True)\n        [1, 2, 3, 4, 6, 12]", "Freq": 0, "TSR": 0}, {"tool": "def prime_factors(n):\n    \n    return sympy.ntheory.factorint(n).items()", "subfield": "Integer Properties", "tool_name": "prime_factors", "tool_type": "function", "description": "Compute the prime factors of an integer.", "docstring": "Compute the prime factors of an integer.\n    Parameters:\n    n : int\n        The integer to be factorized.\n    Returns:\n    list\n        A list of tuples representing prime factors and their exponents.\n    Examples:\n    >>> prime_factors(18)\n    [(2, 1), (3, 2)]", "Freq": 0, "TSR": 0}, {"tool": "def generate_arithmetic_sequence(start, diff, n):\n    \n    return [start + i * diff for i in range(n)]", "subfield": "Integer Properties", "tool_name": "generate_arithmetic_sequence", "tool_type": "function", "description": "Generate an arithmetic sequence from a start value with a fixed difference over n terms.", "docstring": "Generate an arithmetic sequence from a start value with a fixed difference over n terms.\n    \n    Parameters:\n    start : int\n        Starting value of the arithmetic sequence.\n    diff : int\n        Common difference between consecutive terms.\n    n : int\n        Number of terms to generate.\n    \n    Returns:\n    list\n        The list of n terms in the arithmetic sequence.\n    \n    Example:\n    >>> generate_arithmetic_sequence(1, 3, 4)\n    [1, 4, 7, 10]", "Freq": 1, "TSR": 0}, {"tool": "def filter_triangles(triangles, perimeter=None, odd_even=None):\n    \n    filtered = set()\n    for a, b, c in triangles:\n        if perimeter is not None and (a + b + c) != perimeter:\n            continue\n        if odd_even is not None:\n            if odd_even == 'odd' and (a % 2 == 0 or b % 2 == 0 or c % 2 == 0):\n                continue\n            elif odd_even == 'even' and (a % 2 != 0 or b % 2 != 0 or c % 2 != 0):\n                continue\n        filtered.add((a, b, c))\n    \n    return filtered", "subfield": "Integer Properties", "tool_name": "filter_triangles", "tool_type": "function", "description": "Filters a set of triangles based on the perimeter and/or parity conditions.", "docstring": "Filters a set of triangles based on the perimeter and/or parity conditions.\n    Parameters:\n    - triangles (set of tuples): Set of tuples (a, b, c) representing sides of the triangles.\n    - perimeter (int, optional): The exact perimeter that the triangles must have.\n    - odd_even (str, optional): 'odd' for triangles with all odd sides; 'even' for all even sides; None for no parity filter.\n    \n    Returns:\n    - set of tuples: a set of triangles that pass all filters.\n    \n    Example:\n    >>> triangles = {(3, 4, 5), (2, 3, 4), (5, 5, 5)}\n    >>> filter_triangles(triangles, perimeter=12)\n    {(3, 4, 5)}\n    >>> filter_triangles(triangles, odd_even='odd')\n    {(5, 5, 5)}", "Freq": 4, "TSR": 3}, {"tool": "def list_perfect_cubes(limit):\n    \n    cubes = [i**3 for i in range(int(round(limit ** (1/3))) + 1)]\n    return cubes", "subfield": "Integer Properties", "tool_name": "list_perfect_cubes", "tool_type": "function", "description": "Generates all perfect cubes less than or equal to the given limit.", "docstring": "Generates all perfect cubes less than or equal to the given limit.\n    \n    Parameters\n    ----------\n    limit : int\n        The upper limit for the perfect cubes.\n    Returns\n    -------\n    list\n        A list of all perfect cubes up to `limit`.\n    Examples\n    --------\n    >>> list_perfect_cubes(30)\n    [0, 1, 8, 27]", "Freq": 0, "TSR": 0}, {"tool": "def count_valid_numbers_in_range(start, end, criteria_func):\n    \n    return sum(1 for n in range(start, end + 1) if criteria_func(n))", "subfield": "Integer Properties", "tool_name": "count_valid_numbers_in_range", "tool_type": "function", "description": "Count integers within a specified range that meet a given criteria.", "docstring": "Count integers within a specified range that meet a given criteria.\n    \n    Parameters:\n        start (int): The start of the range (inclusive).\n        end (int): The end of the range (inclusive).\n        criteria_func (function): A function that takes an integer and returns a boolean.\n    \n    Returns:\n        int: The count of integers satisfying the criteria within the specified range.\n    \n    Examples:\n        >>> def is_even(n):\n        ...     return n % 2 == 0\n        >>> count_valid_numbers_in_range(1, 10, is_even)\n        5", "Freq": 0, "TSR": 0}, {"tool": "def calculate_gcd(num1, num2):\n    \n    return sympy.gcd(num1, num2)", "subfield": "Integer Properties", "tool_name": "calculate_gcd", "tool_type": "function", "description": "Calculate the greatest common divisor of two numbers.", "docstring": "Calculate the greatest common divisor of two numbers.\n    Parameters:\n        num1 (int): First integer.\n        num2 (int): Second integer.\n    Returns:\n        int: The greatest common divisor of num1 and num2.", "Freq": 0, "TSR": 0}, {"tool": "def check_digit_inclusion(n, include_digits=None, exclude_digits=None):\n    \n    str_n = str(n)\n    if include_digits and not all(str(digit) in str_n for digit in include_digits):\n        return False\n    if exclude_digits and any(str(digit) in str_n for digit in exclude_digits):\n        return False\n    return True", "subfield": "Integer Properties", "tool_name": "check_digit_inclusion", "tool_type": "function", "description": "Check whether the integer `n` includes or excludes certain digits.", "docstring": "Check whether the integer `n` includes or excludes certain digits.\n    \n    Parameters:\n        n (int): The integer to check.\n        include_digits (set of int, optional): Digits that should be included in `n`.\n        exclude_digits (set of int, optional): Digits that should be excluded from `n`.\n    \n    Returns:\n        bool: True if `n` meets the criteria, False otherwise.\n    \n    Examples:\n        >>> check_digit_inclusion(567, include_digits={5, 6}, exclude_digits={1})\n        True\n        >>> check_digit_inclusion(560, include_digits={1}, exclude_digits={0})\n        False", "Freq": 0, "TSR": 0}, {"tool": "def integer_floor(x):\n    \n    return math.floor(x)", "subfield": "Integer Properties", "tool_name": "integer_floor", "tool_type": "function", "description": "Find the floor of a real number, rounding down to the nearest integer.", "docstring": "Find the floor of a real number, rounding down to the nearest integer.\n    \n    Parameters:\n    x : float\n        The real number to find the floor of.\n    \n    Returns:\n    int\n        The floor of x.\n    \n    Example:\n    >>> integer_floor(3.7)\n    3\n    >>> integer_floor(-1.2)\n    -2", "Freq": 0, "TSR": 0}, {"tool": "def list_perfect_squares(limit):\n    \n    squares = [i*i for i in range(int(math.sqrt(limit)) + 1)]\n    return squares", "subfield": "Integer Properties", "tool_name": "list_perfect_squares", "tool_type": "function", "description": "Generates all perfect squares less than or equal to the given limit.", "docstring": "Generates all perfect squares less than or equal to the given limit.\n    \n    Parameters\n    ----------\n    limit : int\n        The upper limit for the perfect squares.\n    Returns\n    -------\n    list\n        A list of all perfect squares up to `limit`.\n    Examples\n    --------\n    >>> list_perfect_squares(30)\n    [0, 1, 4, 9, 16, 25]", "Freq": 0, "TSR": 0}, {"tool": "def is_divisible(a, b):\n    \n    if b == 0:\n        raise ValueError(\"Division by zero is not supported.\")\n    return a % b == 0", "subfield": "Integer Properties", "tool_name": "is_divisible", "tool_type": "function", "description": "Check if integer a is divisible by integer b.", "docstring": "Check if integer a is divisible by integer b.\n    Parameters:\n        a (int): The dividend.\n        b (int): The divisor.\n    Returns:\n        bool: True if a is divisible by b, False otherwise.", "Freq": 0, "TSR": 0}, {"tool": "def solve_linear_inequality(a, b, c):\n    \n    if a == 0:\n        if b <= c:\n            return float('-inf'), float('inf')  # Indeterminate case or all x satisfy\n        else:\n            return ()  # No solution\n    x = (c - b) / a\n    if a > 0:\n        return float('-inf'), x\n    else:\n        return x, float('inf')", "subfield": "Integer Properties", "tool_name": "solve_linear_inequality", "tool_type": "function", "description": "Solve a linear inequality of the form a*x + b <= c", "docstring": "Solve a linear inequality of the form a*x + b <= c\n    \n    Parameters:\n    a : int\n        The coefficient of x.\n    b : int\n        Constant term.\n    c : int\n        Right side of the inequality.\n    \n    Returns:\n    tuple\n        The range of x that satisfies the inequality.\n    \n    Example:\n    >>> solve_linear_inequality(3, -6, 12)\n    (-inf, 6.0)", "Freq": 1, "TSR": 0}, {"tool": "def polynomial_integer_values(polynomial, values):\n    \n    results = {}\n    for val in values:\n        result = polynomial.subs(sympy.Symbol('x'), val)\n        results[val] = {'value': result, 'is_integer': sympy.sympify(result).is_integer}\n    return results", "subfield": "Integer Properties", "tool_name": "polynomial_integer_values", "tool_type": "function", "description": "Evaluate a polynomial at given values and check if results are integers.", "docstring": "Evaluate a polynomial at given values and check if results are integers.\n    Parameters:\n        polynomial (sympy.Poly): The polynomial to evaluate.\n        values (list): Values at which to evaluate the polynomial.\n    Returns:\n        dict: A dictionary mapping values to their evaluation results and whether those are integers.", "Freq": 0, "TSR": 0}, {"tool": "def integer_properties_checker(n, check='prime'):\n    \n    if check == 'prime':\n        return sympy.isprime(n)\n    elif check == 'perfect_square':\n        return n == sympy.Integer(sympy.sqrt(n))**2\n    else:\n        raise ValueError(\"Unsupported check type provided. Supported types are 'prime', 'perfect_square'.\")", "subfield": "Integer Properties", "tool_name": "integer_properties_checker", "tool_type": "function", "description": "Check specific properties of an integer such as primality or perfect square.", "docstring": "Check specific properties of an integer such as primality or perfect square.\n    Parameters:\n    n (int): the integer to check\n    check (str): What to check, supported values are 'prime', 'perfect_square'\n    Returns:\n    bool: True if the property is satisfied, False otherwise\n    Examples:\n    >>> integer_properties_checker(29, 'prime')\n    True\n    >>> integer_properties_checker(28, 'perfect_square')\n    False", "Freq": 0, "TSR": 0}, {"tool": "def arithmetic_sum(a, d, n):\n    \n    return n * (2 * a + (n - 1) * d) // 2", "subfield": "Integer Properties", "tool_name": "arithmetic_sum", "tool_type": "function", "description": "Calculate the sum of the first `n` terms of an arithmetic sequence.", "docstring": "Calculate the sum of the first `n` terms of an arithmetic sequence.\n    Parameters\n    ----------\n    a : int\n        The first term of the sequence.\n    d : int\n        The common difference of the sequence.\n    n : int\n        The number of terms.\n    Returns\n    -------\n    int\n        The sum of the first `n` terms.\n    Examples\n    --------\n    >>> arithmetic_sum(1, 1, 100)  # Sum of first 100 natural numbers\n    5050\n    >>> arithmetic_sum(2, 2, 10)  # Sum of first 10 even numbers starting from 2\n    110", "Freq": 0, "TSR": 0}, {"tool": "def is_abundant(n):\n    \n    proper_factors = sum(all_factors(n)[:-1])\n    return proper_factors > n", "subfield": "Integer Properties", "tool_name": "is_abundant", "tool_type": "function", "description": "Determine if a number is abundant (sum of proper divisors greater than the number itself).", "docstring": "Determine if a number is abundant (sum of proper divisors greater than the number itself).\n    Parameters:\n    n : int\n        The number to check for abundance.\n    Returns:\n    bool\n        True if n is abundant, False otherwise.\n    Examples:\n    >>> is_abundant(12)\n    True", "Freq": 1, "TSR": 0}, {"tool": "def count_integers_within_bounds(lower_bound, upper_bound, inclusive=True):\n    \n    if inclusive:\n        return (upper_bound - lower_bound + 1)\n    else:\n        return (upper_bound - lower_bound - 1)", "subfield": "Integer Properties", "tool_name": "count_integers_within_bounds", "tool_type": "function", "description": "Calculate the total count of integers between two bounds.", "docstring": "Calculate the total count of integers between two bounds.\n    Parameters:\n    lower_bound (int): the lower bound of the range\n    upper_bound (int): the upper bound of the range\n    inclusive (bool): if True, include both bounds, else exclude bounds\n    \n    Returns:\n    int: count of integers within the specified bounds\n    Examples:\n    >>> count_integers_within_bounds(1, 10)\n    10\n    >>> count_integers_within_bounds(1, 10, inclusive=False)\n    8", "Freq": 0, "TSR": 0}, {"tool": "def find_integers_in_range(start, end, condition=lambda x: True):\n    \n    return [n for n in range(start, end + 1) if condition(n)]", "subfield": "Integer Properties", "tool_name": "find_integers_in_range", "tool_type": "function", "description": "Generates a list of integers within a specified range that meet a certain condition.", "docstring": "Generates a list of integers within a specified range that meet a certain condition.\n    \n    Parameters:\n        start (int): The start of the range (inclusive).\n        end (int): The end of the range (inclusive).\n        condition (callable): A function that takes an integer as an argument and returns\n                              a boolean indicating whether the integer meets the specified condition.\n                              Default checks if every integer in the range is valid.\n    \n    Returns:\n        List[int]: A list containing all integers in the range [start, end] that meet the condition.\n    \n    Examples:\n        # Find all integers between 1 and 100\n        print(find_integers_in_range(1, 100))\n        # Find all even integers between 1 and 100\n        print(find_integers_in_range(1, 100, lambda x: x % 2 == 0))\n        # Find all prime integers between 1 and 100\n        from sympy import isprime\n        print(find_integers_in_range(1, 100, isprime))", "Freq": 2, "TSR": 2}, {"tool": "def integer_ceiling(x):\n    \n    return math.ceil(x)", "subfield": "Integer Properties", "tool_name": "integer_ceiling", "tool_type": "function", "description": "Find the ceiling of a real number, rounding up to the nearest integer.", "docstring": "Find the ceiling of a real number, rounding up to the nearest integer.\n    \n    Parameters:\n    x : float\n        The real number to find the ceiling of.\n    \n    Returns:\n    int\n        The ceiling of x.\n    \n    Example:\n    >>> integer_ceiling(3.2)\n    4\n    >>> integer_ceiling(-2.3)\n    -2", "Freq": 0, "TSR": 0}, {"tool": "def calculate_lcm(num1, num2):\n    \n    return sympy.lcm(num1, num2)", "subfield": "Integer Properties", "tool_name": "calculate_lcm", "tool_type": "function", "description": "Calculate the least common multiple of two numbers.", "docstring": "Calculate the least common multiple of two numbers.\n    Parameters:\n        num1 (int): First integer.\n        num2 (int): Second integer.\n    Returns:\n        int: The least common multiple of num1 and num2.", "Freq": 0, "TSR": 0}, {"tool": "def polynomial_coefficients_integer(polynomial):\n    \n    return all(coeff.is_Integer for coeff in polynomial.all_coeffs())", "subfield": "Integer Properties", "tool_name": "polynomial_coefficients_integer", "tool_type": "function", "description": "Check if a polynomial expression has all integer coefficients.", "docstring": "Check if a polynomial expression has all integer coefficients.\n    Parameters:\n        polynomial (sympy.Poly): A polynomial expression.\n    Returns:\n        bool: True if all coefficients of the polynomial are integers, False otherwise.", "Freq": 0, "TSR": 0}, {"tool": "def evaluate_expression(values, operation='sum'):\n    \n    import functools\n    import operator\n    if operation == 'sum':\n        return sum(values)\n    elif operation == 'product':\n        return functools.reduce(operator.mul, values, 1)\n    else:\n        raise ValueError(\"Unsupported operation type. Supported types: 'sum', 'product'\")", "subfield": "Integer Properties", "tool_name": "evaluate_expression", "tool_type": "function", "description": "Evaluate a mathematical expression with a list of values based on operation type like sum or product.", "docstring": "Evaluate a mathematical expression with a list of values based on operation type like sum or product.\n    \n    Parameters:\n    values (list[int]): List of integer values.\n    operation (str): Type of operation ('sum', 'product').\n    \n    Returns:\n    int: Result of the operation.\n    \n    Example:\n    >>> evaluate_expression([1, 3, 5], 'sum')\n    9\n    >>> evaluate_expression([1, 3, 5], 'product')\n    15", "Freq": 0, "TSR": 0}, {"tool": "def polynomial_factors(f, var):\n    \n    from sympy import factor_list\n    return factor_list(f, gens=var)", "subfield": "Integer Properties", "tool_name": "polynomial_factors", "tool_type": "function", "description": "Find the factors of a polynomial expression.", "docstring": "Find the factors of a polynomial expression.\n    Parameters:\n    - f (sympy.Expr): Polynomial expression.\n    - var (sympy.Symbol): The variable in the polynomial.\n    Returns:\n    - List of factors.\n    Examples:\n    - polynomial_factors(x**2 - 1, x) -> [x - 1, x + 1]", "Freq": 0, "TSR": 0}], "Powers and Roots": [{"tool": "def power_mod(base, exponent, mod):\n    \n    return pow(base, exponent, mod)", "subfield": "Powers and Roots", "tool_name": "power_mod", "tool_type": "function", "description": "Calculate the base raised to the exponent modulo mod.", "docstring": "Calculate the base raised to the exponent modulo mod.\n    \n    Parameters:\n    base (int): The base number.\n    exponent (int): The power to which the base is raised.\n    mod (int): The modulus to use for the calculation.\n    \n    Returns:\n    int: The result of (base ** exponent) % mod\n    \n    Examples:\n    >>> power_mod(2, 5, 3)\n    2\n    >>> power_mod(3, 2, 4)\n    1", "Freq": 5, "TSR": 5}, {"tool": "def compute_power(base, exponent):\n    \n    return base ** exponent", "subfield": "Powers and Roots", "tool_name": "compute_power", "tool_type": "function", "description": "Computes the power of a given base raised to an exponent.", "docstring": "Computes the power of a given base raised to an exponent.\n    \n    Parameters:\n    - base (int or float or complex): The base of the exponentiation.\n    - exponent (int or float or complex): The exponent to which the base is raised.\n    \n    Returns:\n    - int or float or complex: The result of base ** exponent.\n    \n    Example:\n    >>> compute_power(2, 3)\n    8\n    >>> compute_power(3 + 4j, 2)\n    (5+24j)", "Freq": 5, "TSR": 4}, {"tool": "def estimate_square_root(n):\n    \n    return int(n**0.5)", "subfield": "Powers and Roots", "tool_name": "estimate_square_root", "tool_type": "function", "description": "Estimating the square root of n to the nearest integer.", "docstring": "Estimating the square root of n to the nearest integer.\n    Parameters:\n    n (float): The number to take the root from.\n    Returns:\n    int: The nearest integer of the square root of n.\n    Example:\n     >>> estimate_square_root(200)\n    14", "Freq": 2, "TSR": 2}, {"tool": "def simplify_expression_with_root(base, exponent, root_degree):\n    \n    return base ** (exponent / root_degree)", "subfield": "Powers and Roots", "tool_name": "simplify_expression_with_root", "tool_type": "function", "description": "Simplify an expression involving roots and exponents.", "docstring": "Simplify an expression involving roots and exponents.\n    \n    Parameters:\n    base (int or float): The base number.\n    exponent (int): The exponent, can be negative for roots.\n    root_degree (int): The degree of the root to apply.\n    \n    Returns:\n    float: The simplified result of (base ** (exponent / root_degree)).\n    \n    Examples:\n    >>> simplify_expression_with_root(8, 1, 3)\n    2.0\n    >>> simplify_expression_with_root(16, 1, 4)\n    2.0", "Freq": 3, "TSR": 3}, {"tool": "def compute_nth_root(n, r):\n    \n    return r**(1/n)", "subfield": "Powers and Roots", "tool_name": "compute_nth_root", "tool_type": "function", "description": "Computes the nth root of a number r.", "docstring": "Computes the nth root of a number r.\n    Parameters:\n    n (int): The root to compute.\n    r (float): The number to take the root from.\n    Returns:\n    float: The nth root of r.\n    Example:\n    >>> compute_nth_root(3, 27)\n    3.0", "Freq": 5, "TSR": 4, "experience_pool": "- Problem: If $64^5 = 32^x$, what is the value of $2^{-x}$?  Express your answer as a common fraction.\n  Answer: \\frac{1}{64}\n  Solution: The value of x should be 5 in order to solve the equation correctly. Therefore, the correct solution is 2^{-5} = \\frac{1}{32} = \\frac{1}{64}."}, {"tool": "def list_powers_within_range(min_val, max_val, power):\n    \n    from math import pow\n    n = 1\n    results = []\n    while pow(n, power) <= max_val:\n        if pow(n, power) >= min_val:\n            results.append(int(pow(n, power)))\n        n += 1\n    return results", "subfield": "Powers and Roots", "tool_name": "list_powers_within_range", "tool_type": "function", "description": "Generates a list of numbers that are perfect powers (such as squares, cubes) within a specified range.", "docstring": "Generates a list of numbers that are perfect powers (such as squares, cubes) within a specified range.\n    \n    Parameters:\n    min_val (int): Minimum value of the range.\n    max_val (int): Maximum value of the range.\n    power (int): The power to consider (2 for squares, 3 for cubes, etc.)\n    \n    Returns:\n    list: A list of integers that are perfect powers within the given range.\n    \n    Examples:\n    >>> list_powers_within_range(1, 100, 2)\n    [1, 4, 9, 16, 25, 36, 49, 64, 81, 100]\n    \n    >>> list_powers_within_range(1, 100, 3)\n    [1, 8, 27, 64]", "Freq": 6, "TSR": 4}, {"tool": "def compute_square_root(n):\n    \n    if n < 0:\n        raise ValueError(\"Cannot compute square root of a negative number.\")\n    return math.sqrt(n)", "subfield": "Powers and Roots", "tool_name": "compute_square_root", "tool_type": "function", "description": "Compute the square root of a number.", "docstring": "Compute the square root of a number.\n    \n    Parameters:\n        n (float|int): The number to find the square root of. Must be non-negative.\n        \n    Returns:\n        float: The square root of the number.\n    \n    Examples:\n        >>> compute_square_root(16)\n        4.0\n        >>> compute_square_root(15)\n        3.872983346207417", "Freq": 1, "TSR": 1}, {"tool": "def calculate_square_and_square_root(n):\n    \n    return n**2, sqrt(n)", "subfield": "Powers and Roots", "tool_name": "calculate_square_and_square_root", "tool_type": "function", "description": "Find the square and square root of n.", "docstring": "Find the square and square root of n.\n    Parameters:\n    n (int): Integer input to be checked.\n    Returns:\n    tuple: a tuple of square and square root of n.\n    Example:\n    >>> calculate_square_and_square_root(4)\n    (16, 2.0)", "Freq": 0, "TSR": 0}, {"tool": "def nth_root_of_unity(degree, k=1):\n    \n    return cmath.exp(2j * cmath.pi * k / degree)", "subfield": "Powers and Roots", "tool_name": "nth_root_of_unity", "tool_type": "function", "description": "Computes the k-th nth root of unity using Euler's formula.", "docstring": "Computes the k-th nth root of unity using Euler's formula.\n    \n    Parameters:\n    - degree (int): The degree of the root of unity.\n    - k (int): Specifies which nth root of unity to compute.\n    \n    Returns:\n    - complex: The k-th nth root of unity.\n    \n    Example:\n    >>> nth_root_of_unity(4)\n    (1+0j)\n    >>> nth_root_of_unity(3, 1)\n    (-0.4999999999999998+0.8660254037844387j)", "Freq": 0, "TSR": 0}, {"tool": "def find_units_digit(base, exponent):\n    \n    # Only last digit of base raised to the power affects the unit's digit.\n    return (base % 10) ** exponent % 10", "subfield": "Powers and Roots", "tool_name": "find_units_digit", "tool_type": "function", "description": "Find the unit's digit of a number raised to an exponent.", "docstring": "Find the unit's digit of a number raised to an exponent.\n    \n    Parameters:\n    base (int): The base number.\n    exponent (int): The exponent.\n    \n    Returns:\n    int: The unit's digit.\n    \n    Examples:\n    >>> find_units_digit(12, 2)\n    4\n    >>> find_units_digit(7, 3)\n    3", "Freq": 1, "TSR": 1}, {"tool": "def compute_cube_root(n):\n    \n    if n < 0:\n        return -(-n) ** (1. / 3)\n    return n ** (1. / 3)", "subfield": "Powers and Roots", "tool_name": "compute_cube_root", "tool_type": "function", "description": "Compute the cube root of a number.", "docstring": "Compute the cube root of a number.\n    \n    Parameters:\n        n (float|int): The number to find the cube root of.\n        \n    Returns:\n        float: The cube root of the number.\n    \n    Examples:\n        >>> compute_cube_root(27)\n        3.0\n        >>> compute_cube_root(-8)\n        -2.0", "Freq": 3, "TSR": 3}, {"tool": "def prime_factorization(n):\n    \n    import sympy\n    factors = sympy.factorint(n)\n    return factors", "subfield": "Powers and Roots", "tool_name": "prime_factorization", "tool_type": "function", "description": "Perform prime factorization of a number.\n    Parameter:\n    n (int): An integer to factorize into primes.\n    Returns:\n    factors (dict): A dictionary where the keys are prime factors and values are their frequencies in the factorization.\n    Example:\n    >>> prime_factorization(20)\n    {2: 2, 5: 1}", "docstring": "Perform prime factorization of a number.\n    Parameter:\n    n (int): An integer to factorize into primes.\n    Returns:\n    factors (dict): A dictionary where the keys are prime factors and values are their frequencies in the factorization.\n    Example:\n    >>> prime_factorization(20)\n    {2: 2, 5: 1}", "Freq": 0, "TSR": 0}, {"tool": "def calculate_root(n, degree):\n    \n    import numpy as np\n    result = np.power(n, 1.0/degree)\n    return result", "subfield": "Powers and Roots", "tool_name": "calculate_root", "tool_type": "function", "description": "Calculate the nth root of a number.", "docstring": "Calculate the nth root of a number.\n    Parameters:\n    n (int, float): The base number.\n    degree (int, float): The degree of root to be calculated.\n    Returns:\n    result (int, float): The calculated nth root.\n    Example:\n    >>> calculate_root(81, 4)\n    3.0", "Freq": 0, "TSR": 0}, {"tool": "def simplfy_square_root(n):\n    \n    return sqrt(n)", "subfield": "Powers and Roots", "tool_name": "simplfy_square_root", "tool_type": "function", "description": "Find the simplified form of square root of n.", "docstring": "Find the simplified form of square root of n.\n    Parameters:\n    n (int): Integer input to be checked.\n    Returns:\n    str: Simplified form of square root of n.\n    Example:\n    >>> simplify_square_root(50)\n    '5*sqrt(2)'", "Freq": 0, "TSR": 0}, {"tool": "def simplify_radical_expression(a, b):\n    \n    factor = math.gcd(a, b)\n    a //= factor\n    b //= factor\n    sqrt_a = int(math.sqrt(a))\n    sqrt_b = int(math.sqrt(b))\n    if sqrt_a ** 2 == a and sqrt_b ** 2 == b:\n        return f\"{sqrt_a * sqrt_b}\"\n    elif sqrt_a ** 2 == a:\n        return f\"{sqrt_a}*sqrt({b})\"\n    elif sqrt_b ** 2 == b:\n        return f\"sqrt({a})/{sqrt_b}\"\n    else:\n        return f\"sqrt({a}/{b})\"", "subfield": "Powers and Roots", "tool_name": "simplify_radical_expression", "tool_type": "function", "description": "Simplifies the radical expression sqrt(a / b).", "docstring": "Simplifies the radical expression sqrt(a / b).\n    \n    Parameters:\n        a (int): The numerator.\n        b (int): The denominator.\n    \n    Returns:\n        str: A string representing the simplified radical form.\n    \n    Examples:\n        >>> simplify_radical_expression(50, 2)\n        '5*sqrt(2)'\n        >>> simplify_radical_expression(18, 9)\n        'sqrt(2)'", "Freq": 0, "TSR": 0}, {"tool": "def find_pattern(seq):\n    \n    # Iterate over lengths of potential repeats\n    for i in range(1, len(seq)//2 + 1):\n        if len(seq) % i == 0: # Repeat length must divide sequence length\n            pattern = seq[:i]\n            if pattern * (len(seq) // i) == seq:\n                return pattern\n    return []", "subfield": "Powers and Roots", "tool_name": "find_pattern", "tool_type": "function", "description": "Detect a pattern in a sequence.\n    Parameter:\n    seq (list): Sequence of numbers in which to detect a pattern.\n    Returns:\n    pattern (list): Detected repeating pattern. Return empty list if no pattern is found.\n    Example:\n    >>> find_pattern([1, 2, 3, 1, 2, 3, 1, 2, 3])\n    [1, 2, 3]", "docstring": "Detect a pattern in a sequence.\n    Parameter:\n    seq (list): Sequence of numbers in which to detect a pattern.\n    Returns:\n    pattern (list): Detected repeating pattern. Return empty list if no pattern is found.\n    Example:\n    >>> find_pattern([1, 2, 3, 1, 2, 3, 1, 2, 3])\n    [1, 2, 3]", "Freq": 0, "TSR": 0}, {"tool": "def simplify_expression(expression):\n    \n    import re\n    # Replace ** with ^\n    expression = expression.replace(\"**\", \"^\")\n    # Replace 1** with 1^\n    expression = re.sub(r\"(?<=\\d)1\\^\", \"1 \", expression)\n    # Replace -1** with -1^\n    expression = re.sub(r\"(?<=-1)1\\^\", \"-1 \", expression)\n    # Simplify the expression\n    simplified_expression = eval(expression)\n    return simplified_expression", "subfield": "Powers and Roots", "tool_name": "simplify_expression", "tool_type": "function", "description": "Simplify an expression involving powers of positive and negative integers.", "docstring": "Simplify an expression involving powers of positive and negative integers.\n    Parameters:\n    expression (str): The expression to be simplified.\n    Returns:\n    simplified_expression (str): The simplified expression.\n    Example:\n    >>> simplify_expression(\"-1**2004 + (-1)**2005 + 1**2006 -1**2007\")\n    \"1 + (-1) + 1 - (-1)\"", "Freq": 0, "TSR": 0}], "Fractions and Decimals": [{"tool": "def simplify_fraction(numerator, denominator):\n    \n    return Rational(numerator, denominator)", "subfield": "Fractions and Decimals", "tool_name": "simplify_fraction", "tool_type": "function", "description": "Simplify a fraction using its numerator and denominator.", "docstring": "Simplify a fraction using its numerator and denominator.\n    Parameters:\n    - numerator (int): the numerator of the fraction.\n    - denominator (int): the denominator of the short division.\n    Returns:\n    - sympy.Rational: the simplified fraction.\n    Examples:\n    >>> simplify_fraction(10, 100)\n    1/10\n    >>> simplify_fraction(22, 7)\n    22/7", "Freq": 4, "TSR": 4}, {"tool": "def convert_repeating_decimal_to_fraction(decimal_str):\n    \n    \n    if '...' not in decimal_str:\n        # No repeating part, simple conversion        \n        return sympy.Rational(decimal_str)\n    \n    non_repeating, repeating = decimal_str.replace('...', '').split('.')\n    repeat_length = len(repeating)\n    non_repeat_length = len(non_repeating) - 1  # Excludes point\n    \n    denominator = 10**repeat_length - 1\n    numerator = int(repeating) + int(non_repeating)*10**repeat_length\n    return sympy.Rational(numerator, denominator * 10**non_repeat_length)", "subfield": "Fractions and Decimals", "tool_name": "convert_repeating_decimal_to_fraction", "tool_type": "function", "description": "Convert a repeating decimal given as a string to its simplest fractional form.", "docstring": "Convert a repeating decimal given as a string to its simplest fractional form.\n    \n    Parameters:\n    - decimal_str (str): The repeating decimal as a string, e.g., \"0.333...\", \"1.256...\"\n    \n    Returns:\n    - sympy.Rational: The fraction form of the repeating decimal.\n    \n    Examples:\n    >>> convert_repeating_decimal_to_fraction('0.333...')\n    1/3\n    >>> convert_repeating_decimal_to_fraction('1.256...')\n    sympy.Rational(1256, 999) - simplified form", "Freq": 13.0, "TSR": 5}, {"tool": "def does_fraction_terminate(numerator, denominator):\n    \n    # Prime factorization only contains 2's or 5's\n    while denominator % 2 == 0:\n        denominator //= 2\n    while denominator % 5 == 0:\n        denominator //= 5\n    return denominator == 1", "subfield": "Fractions and Decimals", "tool_name": "does_fraction_terminate", "tool_type": "function", "description": "Determines if a fraction will terminate or have infinite repeating decimals.", "docstring": "Determines if a fraction will terminate or have infinite repeating decimals.\n    \n    Parameters:\n    - numerator (int): Numerator of the fraction.\n    - denominator (int): Denominator of the fraction.\n    \n    Returns:\n    - bool: True if the fraction terminates, False otherwise.\n    \n    Examples:\n    - does_fraction_terminate(1, 2) --> True\n    - does_fraction_terminate(1, 3) --> False", "Freq": 1, "TSR": 0}, {"tool": "def modular_exponent(base, exponent, mod):\n    \n    return pow(base, exponent, mod)", "subfield": "Fractions and Decimals", "tool_name": "modular_exponent", "tool_type": "function", "description": "Calculate base raised to exponent modulo mod using efficient modular exponentiation.", "docstring": "Calculate base raised to exponent modulo mod using efficient modular exponentiation.\n    Parameters:\n        base (int): The base of the expression.\n        exponent (int): The exponent.\n        mod (int): The modulus for the operation.\n    Returns:\n        int: The result of (base^exponent) % mod.\n    Examples:\n        >>> modular_exponent(2, 10, 1000)\n        24", "Freq": 1, "TSR": 0}, {"tool": "def is_prime(num):\n    \n    return isprime(num)", "subfield": "Fractions and Decimals", "tool_name": "is_prime", "tool_type": "function", "description": "Check if a number is a prime number.", "docstring": "Check if a number is a prime number.\n    Parameters:\n        num (int): The number to check.\n    Returns:\n        bool: True if the number is a prime, else False.\n    Examples:\n        >>> is_prime(11)\n        True\n        >>> is_prime(4)\n        False", "Freq": 1, "TSR": 0}, {"tool": "def lcm(*numbers):\n    \n    return np.lcm.reduce(numbers)", "subfield": "Fractions and Decimals", "tool_name": "lcm", "tool_type": "function", "description": "Calculate the least common multiple of a series of integers.", "docstring": "Calculate the least common multiple of a series of integers.\n    Parameters:\n        numbers (int): A series of integer numbers.\n    Returns:\n        int: The least common multiple of the numbers.\n    Examples:\n        >>> lcm(5, 10, 20)\n        20", "Freq": 2, "TSR": 2}, {"tool": "def gcd(*numbers):\n    \n    return np.gcd.reduce(numbers)", "subfield": "Fractions and Decimals", "tool_name": "gcd", "tool_type": "function", "description": "Calculate the greatest common divisor of a series of integers.", "docstring": "Calculate the greatest common divisor of a series of integers.\n    Parameters:\n        numbers (int): A series of integer numbers.\n    Returns:\n        int: The greatest common divisor of the numbers.\n    Examples:\n        >>> gcd(8, 12, 16)\n        4", "Freq": 2, "TSR": 2}, {"tool": "def decimal_digits(numerator, denominator, num_digits):\n    \n    decimal_str = str(numerator / denominator)\n    decimal_digits = decimal_str.split('.')[1][:num_digits]\n    return decimal_digits", "subfield": "Fractions and Decimals", "tool_name": "decimal_digits", "tool_type": "function", "description": "Returns the first 'num_digits' digits of the decimal expansion of the fraction numerator/denominator.", "docstring": "Returns the first 'num_digits' digits of the decimal expansion of the fraction numerator/denominator.\n    Parameters:\n    numerator (int): The numerator of the fraction.\n    denominator (int): The denominator of the fraction.\n    num_digits (int): The number of digits to return.\n    Returns:\n    str: The first 'num_digits' digits of the decimal expansion of the fraction numerator/denominator.", "Freq": 3, "TSR": 2}], "Floor Function": [{"tool": "def compute_floor(x):\n    \n    return math.floor(x)", "subfield": "Floor Function", "tool_name": "compute_floor", "tool_type": "function", "description": "Compute the floor of a given real number.", "docstring": "Compute the floor of a given real number.\n    Parameters:\n    - x (float): The number for which the floor value is to be computed.\n    Returns:\n    - int: The floor value of the input number.\n    Examples:\n    >>> compute_floor(3.7)\n    3\n    >>> compute_floor(-1.2)\n    -2", "Freq": 8, "TSR": 7}, {"tool": "def iterative_floor_application(start_value, iteration_function, iterations):\n    \n    from math import floor\n    current_value = start_value\n    for _ in range(iterations):\n        current_value = floor(iteration_function(current_value))\n    return current_value", "subfield": "Floor Function", "tool_name": "iterative_floor_application", "tool_type": "function", "description": "Repeatedly apply a transformation involving the floor function and observe the result after a defined number of iterations.", "docstring": "Repeatedly apply a transformation involving the floor function and observe the result after a defined number of iterations.\n    Parameters\n    ----------\n    start_value : float\n        Initial value where the transformation begins.\n    iteration_function : callable\n        A function that defines the transformation involving the floor to apply.\n    iterations : int\n        Number of times the iteration is applied.\n    Returns\n    -------\n    float\n        Result after applying the defined transformation the number of times specified by 'iterations'.\n    Examples\n    --------\n    >>> iterative_floor_application(4.5, lambda x: x/2, 5)\n    0.140625", "Freq": 1, "TSR": 1}, {"tool": "def calculate_floor_mixed_fraction(value):\n    \n    whole, fraction = value.split('_')\n    fractional_value = Fraction(fraction)\n    total_value = int(whole) + fractional_value\n    return int(total_value)", "subfield": "Floor Function", "tool_name": "calculate_floor_mixed_fraction", "tool_type": "function", "description": "This function is used to calculate the floor value of a mixed number.\n    The floor function is the integer part of the mixed number.", "docstring": "This function is used to calculate the floor value of a mixed number.\n    The floor function is the integer part of the mixed number.\n    Parameters:\n    value (str): Input mixed number to calculate the floor value (format \"whole_numerator/denominator\")\n    Returns:\n    int: floor of the mixed number\n    Examples:\n    >>> calculate_floor_mixed_fraction(\"1_3/2\")\n    1\n    >>> calculate_floor_mixed_fraction(\"5_1/8\")\n    5", "Freq": 0, "TSR": 0}, {"tool": "def calculate_floor_negative_fraction(value):\n    \n    fractional_part = Fraction(value)\n    return math.floor(fractional_part)", "subfield": "Floor Function", "tool_name": "calculate_floor_negative_fraction", "tool_type": "function", "description": "This function is used to calculate the floor value of a negative fraction.\n    The floor function is the integer less than the negative fraction.", "docstring": "This function is used to calculate the floor value of a negative fraction.\n    The floor function is the integer less than the negative fraction.\n    Parameters:\n    value (str): Input negative fraction to calculate the floor value (format \"-numerator/denominator\")\n    Returns:\n    int: floor of the given negative fraction.\n    Examples:\n    >>> calculate_floor_negative_fraction(\"-3/2\")\n    -2\n    >>> calculate_floor_negative_fraction(\"-1/8\")\n    -1", "Freq": 0, "TSR": 0}, {"tool": "def evaluate_floor_inequality(x, expected_value, inequality_type):\n    \n    from math import floor\n    floor_x = floor(x)\n    inequalities = {\n        '<=': floor_x <= expected_value,\n        '>=': floor_x >= expected_value,\n        '=': floor_x == expected_value,\n        '<': floor_x < expected_value,\n        '>': floor_x > expected_value\n    }\n    return inequalities[inequality_type]", "subfield": "Floor Function", "tool_name": "evaluate_floor_inequality", "tool_type": "function", "description": "Evaluate whether an inequality involving the floor of a number holds.", "docstring": "Evaluate whether an inequality involving the floor of a number holds.\n    Parameters\n    ----------\n    x : float\n        The real number input to the floor function.\n    expected_value : int\n        The integer against which the floor of x is compared.\n    inequality_type : str\n        Type of inequality used for comparison {'<=', '>=', '=', '<', '>'}.\n    Returns\n    -------\n    bool\n        True if the inequality holds, False otherwise.\n    Examples\n    --------\n    >>> evaluate_floor_inequality(5.5, 5, '=')\n    True\n    >>> evaluate_floor_inequality(3.2, 3, '<')\n    False", "Freq": 1, "TSR": 0}, {"tool": "def floor_product(a, b):\n    \n    return math.floor(a) * math.floor(b)", "subfield": "Floor Function", "tool_name": "floor_product", "tool_type": "function", "description": "Calculate the product of the floors of two numbers.", "docstring": "Calculate the product of the floors of two numbers.\n    Parameters:\n    a (float): The first number.\n    b (float): The second number.\n    Returns:\n    int: The product of the floor values of the two numbers.\n    Examples:\n    >>> floor_product(3.7, 4.1)\n    12\n    >>> floor_product(-1.2, -2.5)\n    2", "Freq": 2, "TSR": 0}, {"tool": "def enhanced_floor_arithmetic(expression, function=None):\n    \n    result = eval(expression)\n    floor_result = math.floor(result)\n    if function:\n        return function(floor_result)\n    return floor_result", "subfield": "Floor Function", "tool_name": "enhanced_floor_arithmetic", "tool_type": "function", "description": "Evaluates a complex mathematical expression potentially involving other functions,\n    and then computes the floor value of the result. Optionally, a function could be applied outside the floor.", "docstring": "Evaluates a complex mathematical expression potentially involving other functions,\n    and then computes the floor value of the result. Optionally, a function could be applied outside the floor.\n    Parameters:\n    - expression (str): The mathematical expression as a string.\n    - function (callable, optional): A function to be applied after taking the floor.\n    Returns:\n    - int: The floor value of the evaluated expression or the final result after applying another function.\n    Examples:\n    >>> enhanced_floor_arithmetic(\"math.sqrt(65)\")\n    8\n    >>> enhanced_floor_arithmetic(\"(5*3 + 2)/3\")\n    5\n    >>> enhanced_floor_arithmetic(\"3.5 + 4*1.1\")\n    7\n    >>> enhanced_floor_arithmetic(\"math.sqrt(81)\", math.sin)  # Since sin(9) = 0.412\n    0", "Freq": 0, "TSR": 0}, {"tool": "def floor_of_expression(expr):\n    \n    return math.floor(eval(expr))", "subfield": "Floor Function", "tool_name": "floor_of_expression", "tool_type": "function", "description": "Evaluate the floor of an expression, potentially including more complex operations like factorials.\n    `expr` should be a string that Python can evaluate directly using the `eval` function.", "docstring": "Evaluate the floor of an expression, potentially including more complex operations like factorials.\n    `expr` should be a string that Python can evaluate directly using the `eval` function.\n    Parameters:\n    expr (str): The string representation of the mathematical expression to floor.\n    Returns:\n    int: The floor of the evaluated expression.\n    Examples:\n    >>> floor_of_expression('5/3')\n    1\n    >>> floor_of_expression('math.sqrt(64) + 0.9')\n    8", "Freq": 1, "TSR": 1}, {"tool": "def floor_of_square_root(x):\n    \n    return math.floor(math.sqrt(x))", "subfield": "Floor Function", "tool_name": "floor_of_square_root", "tool_type": "function", "description": "Calculate the floor of the square root of a number.", "docstring": "Calculate the floor of the square root of a number.\n    Parameters:\n    x (float): A real number from which the square root is calculated, and then floored.\n    Returns:\n    int: The floor of the square root of x.\n    Examples:\n    >>> floor_of_square_root(67)\n    8\n    >>> floor_of_square_root(81)\n    9", "Freq": 6, "TSR": 5}, {"tool": "def floor_function_bounds(value, lower_bound, upper_bound):\n    \n    from math import floor\n    floor_value = floor(value)\n    return lower_bound <= floor_value <= upper_bound", "subfield": "Floor Function", "tool_name": "floor_function_bounds", "tool_type": "function", "description": "Determines if the floor of a value falls within a specified integer bounds.", "docstring": "Determines if the floor of a value falls within a specified integer bounds.\n    Parameters:\n        value (float): The number to check.\n        lower_bound (int): The lower integer boundary.\n        upper_bound (int): The upper integer boundary.\n    \n    Returns:\n        bool: True if the floor of the value is within the bounds, False otherwise.\n    \n    Examples:\n    >>> floor_function_bounds(3.2, 3, 5)\n    True\n    >>> floor_function_bounds(-2.6, -1, 2)\n    False", "Freq": 0, "TSR": 0}], "Prime Numbers": [{"tool": "def prime_factors(n):\n    \n    if not isinstance(n, int):\n        raise ValueError(\"Input must be an integer.\")\n    if n < 1:\n        raise ValueError(\"Input must be a positive integer.\")\n    if n == 1:\n        return []\n    \n    factors = []\n    i = 2\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n            factors.append(i)\n    if n > 1:\n        factors.append(n)\n    \n    return factors", "subfield": "Prime Numbers", "tool_name": "prime_factors", "tool_type": "function", "description": "Compute the prime factors of a given integer n.", "docstring": "Compute the prime factors of a given integer n.\n    \n    Parameters:\n    n : int\n        Integer to factorize into its prime factors.\n        \n    Returns:\n    list\n        A list containing the prime factors of the integer n.", "Freq": 23.0, "TSR": 19.0}, {"tool": "def generate_primes(min_val, max_val):\n    \n    try:\n        if min_val > max_val:\n            return []\n        \n        def sieve(n):\n            is_prime = [True] * (n+1)\n            p = 2\n            while (p * p <= n):\n                if (is_prime[p] == True):\n                    for i in range(p * p, n+1, p):\n                        is_prime[i] = False\n                p += 1\n            return [p for p in range(2, n+1) if is_prime[p]]\n        \n        return [p for p in sieve(max_val) if p >= min_val]\n    \n    except Exception as e:\n        return []", "subfield": "Prime Numbers", "tool_name": "generate_primes", "tool_type": "function", "description": "Generate all prime numbers in a specified range.", "docstring": "Generate all prime numbers in a specified range.\n    Parameters:\n    min_val (int): The minimum value of the range.\n    max_val (int): The maximum value of the range.\n    Returns:\n    list: A list of prime numbers within the specified range. Returns an empty list if the minimum value is greater than the maximum value or if an error occurs during execution.", "Freq": 7.5, "TSR": 7.0, "experience_pool": "- Experience 1:\n    - Problem: The tool does not handle the scenario where the minimum value is greater than the maximum value.\n    - Solution: Added input validation to check if the minimum value is greater than the maximum value and return an empty list in such cases.\n- Experience 2:\n    - Problem: The tool does not have error handling, which may cause exceptions during execution.\n    - Solution: Added error handling to catch any exceptions that may occur during execution and return an empty list in case of an error."}, {"tool": "def prime_factors(n):\n    \n    from collections import defaultdict\n    factors = defaultdict(int)\n    # Check for number of 2s that divide n\n    while n % 2 == 0:\n        factors[2] += 1\n        n //= 2\n    # n must be odd at this point\n    for i in range(3, int(math.sqrt(n)) + 1, 2):\n        # While i divides n, add i and divide n\n        while n % i == 0:\n            factors[i] += 1\n            n //= i\n    # This condition is to check if n is a prime number\n    # greater than 2\n    if n > 2:\n        factors[n] += 1\n    return dict(factors)", "subfield": "Prime Numbers", "tool_name": "prime_factors", "tool_type": "function", "description": "Generate the prime factors of an integer n along with their respective powers.", "docstring": "Generate the prime factors of an integer n along with their respective powers.\n    \n    Parameters:\n        n (int): The number to factorize.\n    Returns:\n        dict: A dictionary where the keys are the prime factors and the values are their powers.\n    \n    Examples:\n        >>> prime_factors(18)\n        {2: 1, 3: 2}\n        >>> prime_factors(360)\n        {2: 3, 3: 2, 5: 1}", "Freq": 10, "TSR": 5}, {"tool": "def smallest_prime_with_digit_sum(target_sum):\n    \n    def is_prime(n):\n        \n        if n <= 1:\n            return False\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n    def digit_sum(n):\n        \n        return sum(int(digit) for digit in str(n))\n    current_number = 2\n    while True:\n        if is_prime(current_number) and digit_sum(current_number) == target_sum:\n            return current_number\n        current_number += 1", "subfield": "Prime Numbers", "tool_name": "smallest_prime_with_digit_sum", "tool_type": "function", "description": "Find the smallest prime whose digits sum to the given target_sum.", "docstring": "Find the smallest prime whose digits sum to the given target_sum.\n    Parameters:\n    target_sum (int): The desired sum of the digits.\n    Returns:\n    int: The smallest prime number whose digits sum to the target_sum.", "Freq": 1, "TSR": 1}], "Powers and Exponents": [], "Perfect Squares": [{"tool": "def is_perfect_square(n):\n    \n    if n < 0:\n        return False\n    root = math.isqrt(n)\n    return root * root == n", "subfield": "Perfect Squares", "tool_name": "is_perfect_square", "tool_type": "function", "description": "Check if a number is a perfect square.", "docstring": "Check if a number is a perfect square.\n    Parameters:\n        n (int): The number to check.\n    Returns:\n        bool: True if n is a perfect square, False otherwise.", "Freq": 9, "TSR": 3, "experience_pool": "- When checking for perfect squares, ensure that the logic of the solution is correctly implemented.\n- Pay attention to the conditions and constraints of the problem when using the tool."}, {"tool": "def generate_perfect_squares(start, end):\n    \n    root_start = math.ceil(math.sqrt(start))\n    root_end = math.floor(math.sqrt(end))\n    return [x * x for x in range(root_start, root_end + 1)]", "subfield": "Perfect Squares", "tool_name": "generate_perfect_squares", "tool_type": "function", "description": "Generate a list of perfect squares between start and end (inclusive).", "docstring": "Generate a list of perfect squares between start and end (inclusive).\n    \n    Parameters:\n        start (int): The start of the range.\n        end (int): The end of the range.\n    \n    Returns:\n        list: List of perfect squares within the given range.\n    \n    Example:\n        >>> generate_perfect_squares(1, 100)\n        [1, 4, 9, 16, 25, 36, 49, 64, 81, 100]", "Freq": 2, "TSR": 1}, {"tool": "def generate_pythagorean_triples(limit):\n    \n    triples = []\n    for c in range(5, limit + 1):\n        for a in range(3, int(c/2) + 1):\n            b = math.sqrt(c * c - a * a)\n            if b == int(b):\n                triples.append((a, int(b), c))\n    return triples", "subfield": "Perfect Squares", "tool_name": "generate_pythagorean_triples", "tool_type": "function", "description": "Generate a list of Pythagorean triples up to a given limit.", "docstring": "Generate a list of Pythagorean triples up to a given limit.\n    Parameters:\n    - limit (int): The maximum value for the hypotenuse.\n    Returns:\n    - List[tuple]: A list of tuples, each containing a Pythagorean triple (a, b, c).\n    Examples:\n    >>> generate_pythagorean_triples(15)\n    [(3, 4, 5), (6, 8, 10), (5, 12, 13)]", "Freq": 1, "TSR": 0}, {"tool": "def find_next_perfect_square(n):\n    \n    root = int(math.sqrt(n)) + 1\n    return root ** 2", "subfield": "Perfect Squares", "tool_name": "find_next_perfect_square", "tool_type": "function", "description": "Find the smallest perfect square greater than a given number.", "docstring": "Find the smallest perfect square greater than a given number.\n    Parameters:\n    - n (int): The number to exceed.\n    Returns:\n    - int: The next perfect square.\n    Examples:\n    >>> find_next_perfect_square(15)\n    16\n    >>> find_next_perfect_square(25)\n    36", "Freq": 2, "TSR": 1}, {"tool": "def last_digit_perfect_squares(limit):\n    \n    from collections import defaultdict\n    result = defaultdict(list)\n    for i in range(math.isqrt(limit) + 1):\n        sq = i * i\n        d = sq % 10\n        result[d].append(sq)\n    return dict(result)", "subfield": "Perfect Squares", "tool_name": "last_digit_perfect_squares", "tool_type": "function", "description": "Identify perfect squares up to a certain limit and their last digits.", "docstring": "Identify perfect squares up to a certain limit and their last digits.\n    Parameters:\n    - limit (int): The upper limit to which calculation is done.\n    Returns:\n    - dict: A dictionary with keys as the last digit and values as lists of perfect squares up to `limit` sharing that last digit.\n    \n    Examples:\n    >>> last_digit_perfect_squares(20)\n    {0: [0, 4, 9, 16], 1: [1], 4: [], 5: [25], 6: [36], 9: []}", "Freq": 1, "TSR": 0}, {"tool": "def difference_of_consecutive_squares(n):\n    \n    return [2 * i + 1 for i in range(1, n)]", "subfield": "Perfect Squares", "tool_name": "difference_of_consecutive_squares", "tool_type": "function", "description": "Compute the difference between squares of consecutive integers up to n.", "docstring": "Compute the difference between squares of consecutive integers up to n.\n    \n    Parameters:\n        n (int): The limit of the consecutive numbers.\n    \n    Returns:\n        list: Differences between the squares of each pair of consecutive integers.\n        \n    Examples:\n        >>> difference_of_consecutive_squares(10)\n        [3, 5, 7, 9, 11, 13, 15, 17, 19]", "Freq": 0, "TSR": 0}, {"tool": "def perfect_squares_up_to(n):\n    \n    from math import isqrt\n    return [i*i for i in range(1, isqrt(n)+1)]", "subfield": "Perfect Squares", "tool_name": "perfect_squares_up_to", "tool_type": "function", "description": "Generate all perfect squares less than or equal to `n`.", "docstring": "Generate all perfect squares less than or equal to `n`.\n    \n    Parameters:\n    -----------\n    n : int\n        Upper limit for the perfect square values.\n        \n    Returns:\n    --------\n    list\n        A list of all perfect squares ≤ `n`.\n    \n    Example:\n    --------\n    >>> perfect_squares_up_to(10)\n    [1, 4, 9]", "Freq": 4, "TSR": 4}, {"tool": "def perfect_square_divisors(n):\n    \n    factors = factorint(n)\n    divisors = {1}\n    for p, exp in factors.items():\n        # Since we want perfect squares, consider only even exponents\n        for e in range(2, exp+1, 2):  # Step by 2 to maintain even exponents\n            divisors.add(p ** e)\n    return sorted(divisors)", "subfield": "Perfect Squares", "tool_name": "perfect_square_divisors", "tool_type": "function", "description": "Find all perfect square divisors of n based on its prime factorization.", "docstring": "Find all perfect square divisors of n based on its prime factorization.\n    Parameters:\n        n (int): The number for which to find perfect square divisors.\n    \n    Returns:\n        list: List of all perfect square divisors of n.\n    \n    Example:\n        >>> perfect_square_divisors(72)\n        [1, 4, 9, 36]", "Freq": 2, "TSR": 0}, {"tool": "def consecutive_perfect_squares_difference(n):\n    \n    squares = [i * i for i in range(1, n + 1)]\n    differences = [squares[i] - squares[i-1] for i in range(1, n)]\n    return differences", "subfield": "Perfect Squares", "tool_name": "consecutive_perfect_squares_difference", "tool_type": "function", "description": "Calculate and return differences between the first `n` consecutive perfect squares.", "docstring": "Calculate and return differences between the first `n` consecutive perfect squares.\n    \n    Parameters:\n        n (int): Number of consecutive perfect squares to consider.\n        \n    Returns:\n        list: Differences between consecutive perfect squares.\n    \n    Examples:\n        >>> consecutive_perfect_squares_difference(5)\n        [3, 5, 7, 9]", "Freq": 1, "TSR": 0}, {"tool": "def list_perfect_squares(a, b):\n    \n    if a > b:\n        return []\n    # Find smallest square number >= a\n    start = math.ceil(math.sqrt(a))\n    end = math.floor(math.sqrt(b))\n    return [i * i for i in range(start, end + 1)]", "subfield": "Perfect Squares", "tool_name": "list_perfect_squares", "tool_type": "function", "description": "List all perfect squares within the range [a, b].", "docstring": "List all perfect squares within the range [a, b].\n    Parameters:\n        a (int): The lower bound of the range (inclusive).\n        b (int): The upper bound of the range (inclusive).\n    Returns:\n        List[int]: A list containing all the perfect squares within the range.", "Freq": 3, "TSR": 3}, {"tool": "def perfect_squares_range(lower, upper):\n    \n    from math import isqrt\n    lower_bound = isqrt(lower)\n    upper_bound = isqrt(upper)\n    \n    count = 0\n    for i in range(lower_bound, upper_bound+1):\n        square = i*i\n        if square >= lower and square <= upper:\n            count += 1\n    \n    return count", "subfield": "Perfect Squares", "tool_name": "perfect_squares_range", "tool_type": "function", "description": "Compute the number of perfect squares between two integer bounds using properties of consecutive squares.", "docstring": "Compute the number of perfect squares between two integer bounds using properties of consecutive squares.\n    \n    Parameters:\n    -----------\n    lower : int\n        The lower inclusive bound of the range.\n    upper : int\n        The upper inclusive bound of the range.\n    \n    Returns:\n    --------\n    int\n        The number of perfect squares in the range [lower, upper].\n    \n    Example:\n    --------\n    >>> perfect_squares_range(1, 100)\n    10", "Freq": 4.0, "TSR": 3, "experience_pool": "Tool has been evolved to accurately calculate the number of perfect squares between two integer bounds."}, {"tool": "def last_digit_of_squares():\n    \n    return {i * i % 10 for i in range(10)}", "subfield": "Perfect Squares", "tool_name": "last_digit_of_squares", "tool_type": "function", "description": "Lists the possible last digits of perfect squares in a decimal system.\n    Returns:\n        set: A set containing digits that are the last digits of a perfect square.", "docstring": "Lists the possible last digits of perfect squares in a decimal system.\n    Returns:\n        set: A set containing digits that are the last digits of a perfect square.", "Freq": 0, "TSR": 0}, {"tool": "def analyze_consecutive_integer_sums(n):\n    \n    import math\n    def is_perfect_square(num):\n        \n        if num < 0:\n            return False\n        root = math.isqrt(num)\n        return root * root == num\n    # Calculate the sum of the first n consecutive integers\n    sum_consecutive = n * (n + 1) // 2\n    perfect_square_check = is_perfect_square(sum_consecutive)\n    # Find the smallest perfect square sum for any count of consecutive integers\n    smallest_perfect_square_sum = None\n    for k in range(1, n + 1):\n        current_sum = k * (k + 1) // 2\n        if is_perfect_square(current_sum):\n            if smallest_perfect_square_sum is None or current_sum < smallest_perfect_square_sum:\n                smallest_perfect_square_sum = current_sum\n    return {\n        'sum': sum_consecutive,\n        'is_perfect_square': perfect_square_check,\n        'smallest_perfect_square_sum': smallest_perfect_square_sum\n    }", "subfield": "Perfect Squares", "tool_name": "analyze_consecutive_integer_sums", "tool_type": "function", "description": "Analyzes the sum of `n` consecutive positive integers starting from 1\n    and checks if the sum is a perfect square. Additionally, it finds the \n    smallest perfect square sum for any given count of consecutive integers.\n    Args:\n        n (int): The number of consecutive integers to analyze.\n    Returns:\n        dict: A dictionary containing:\n            - 'sum': The sum of the first `n` consecutive integers.\n            - 'is_perfect_square': A boolean indicating if the sum is a perfect square.\n            - 'smallest_perfect_square_sum': The smallest perfect square sum for \n              the first `k` consecutive integers where k ranges from 1 to n.", "docstring": "Analyzes the sum of `n` consecutive positive integers starting from 1\n    and checks if the sum is a perfect square. Additionally, it finds the \n    smallest perfect square sum for any given count of consecutive integers.\n    Args:\n        n (int): The number of consecutive integers to analyze.\n    Returns:\n        dict: A dictionary containing:\n            - 'sum': The sum of the first `n` consecutive integers.\n            - 'is_perfect_square': A boolean indicating if the sum is a perfect square.\n            - 'smallest_perfect_square_sum': The smallest perfect square sum for \n              the first `k` consecutive integers where k ranges from 1 to n.", "Freq": 1, "TSR": 0}], "Factors and Multiples": [{"tool": "def prime_factors(n):\n    \n    return factorint(n)", "subfield": "Factors and Multiples", "tool_name": "prime_factors", "tool_type": "function", "description": "Compute the prime factors of a given number along with their exponents.", "docstring": "Compute the prime factors of a given number along with their exponents.\n    \n    Parameters:\n        n (int): The integer to be factorized.\n    \n    Returns:\n        dict: Dictionary with prime factors as keys and their exponents as values.", "Freq": 3.5, "TSR": 1, "experience_pool": "Tool evolved to use the correct function for computing prime factors."}, {"tool": "def lcm(a, b):\n    \n    def gcd(x, y):\n        while y != 0:\n            x, y = y, x % y\n        return x\n    return abs(a * b) // gcd(a, b)", "subfield": "Factors and Multiples", "tool_name": "lcm", "tool_type": "function", "description": "Compute the least common multiple of two numbers.", "docstring": "Compute the least common multiple of two numbers.\n    Parameters:\n        a (int): The first integer.\n        b (int): The second integer.\n    \n    Returns:\n        int: The least common multiple of a and b.", "Freq": 15.0, "TSR": 14.5, "experience_pool": "Tool: Number Theory - Factors and Multiples\n- Issue: Runtime errors in some scenarios due to the gcd function implementation.\n- Solution: Evolved the tool by including the gcd function within the lcm function for better performance."}, {"tool": "def compute_gcd(a, b):\n    \n    from math import gcd\n    return gcd(a, b)", "subfield": "Factors and Multiples", "tool_name": "compute_gcd", "tool_type": "function", "description": "Compute the greatest common divisor (GCD) of two numbers a and b.", "docstring": "Compute the greatest common divisor (GCD) of two numbers a and b.\n    \n    Parameters:\n        a (int): First number.\n        b (int): Second number.\n    \n    Returns:\n        int: The GCD of a and b.\n    \n    Examples:\n        >>> compute_gcd(48, 180)\n        12", "Freq": 16, "TSR": 14, "experience_pool": "- When simplifying fractions, make sure to divide both the numerator and denominator by their greatest common divisor to get the simplest form.\n- When dealing with ratios, ensure that the calculations are done correctly based on the given ratio.\n- When finding the greatest common divisor of two numbers, use the compute_gcd function correctly with the correct input parameters.\n- When finding the greatest common multiple, make sure to use the correct formula and handle the calculation appropriately.\n- When searching for specific integers with a given greatest common divisor, iterate through the numbers efficiently to find the desired result."}, {"tool": "def list_divisors(n):\n    \n    from math import isqrt\n    divisors = set()\n    for i in range(1, isqrt(n) + 1):\n        if n % i == 0:\n            divisors.add(i)\n            divisors.add(n // i)\n    return sorted(divisors)", "subfield": "Factors and Multiples", "tool_name": "list_divisors", "tool_type": "function", "description": "List all divisors of the given integer n.", "docstring": "List all divisors of the given integer n.\n    \n    Parameters:\n        n (int): The number to find divisors for.\n    \n    Returns:\n        List[int]: List containing all the divisors of n.\n    \n    Examples:\n        >>> list_divisors(28)\n        [1, 2, 4, 7, 14, 28]", "Freq": 13, "TSR": 8, "experience_pool": "- When calculating the number of positive factors of a number, ensure that the divisors are correctly counted.\n- When finding the sum or product of divisors, handle the calculation accurately based on the divisors obtained.\n- When dealing with specific properties of divisors (e.g., perfect cubes), check the conditions correctly within the obtained divisors."}, {"tool": "def gcd(x, y):\n    \n    while y:\n        x, y = y, x % y\n    return x", "subfield": "Factors and Multiples", "tool_name": "gcd", "tool_type": "function", "description": "Compute the greatest common divisor of two numbers x and y.", "docstring": "Compute the greatest common divisor of two numbers x and y.\n    \n    Parameters:\n    x : int\n        First number.\n    y : int\n        Second number.\n    \n    Returns:\n    int\n        The greatest common divisor of x and y.\n    \n    Examples:\n    >>> gcd(12, 18)\n    6\n    >>> gcd(5, 13)\n    1", "Freq": 2, "TSR": 1, "experience_pool": "1. Make sure to provide correct input parameters when calling the gcd function.\n2. Check for any syntax errors or missing parameters in the function call.\n3. Verify the logic and calculations in the calling code to ensure they align with the requirements of the problem."}, {"tool": "def list_prime_factors(n):\n    \n    from sympy import primefactors\n    return primefactors(n)", "subfield": "Factors and Multiples", "tool_name": "list_prime_factors", "tool_type": "function", "description": "List all prime factors of the given integer n.", "docstring": "List all prime factors of the given integer n.\n    \n    Parameters:\n        n (int): The number to find prime factors for.\n    \n    Returns:\n        List[int]: List containing all the prime factors of n.\n    \n    Examples:\n        >>> list_prime_factors(360)\n        [2, 3, 5]", "Freq": 13, "TSR": 12, "experience_pool": "1. When calculating the largest prime factor of a number, ensure that the `list_prime_factors` function is called correctly and handle the result appropriately.\n2. When converting a number to base prime representation, verify the prime factors obtained using the `list_prime_factors` function and correctly construct the base prime representation."}, {"tool": "def get_factors(n):\n    \n    factors = set()\n    for i in range(1, int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            factors.add(i)\n            factors.add(n // i)\n    return sorted(factors)", "subfield": "Factors and Multiples", "tool_name": "get_factors", "tool_type": "function", "description": "Compute all factors of a given number.", "docstring": "Compute all factors of a given number.\n    Parameters:\n    n (int): The number to find factors for.\n    Returns:\n    List[int]: A list of all positive factors of n.\n    Examples:\n    >>> get_factors(28)\n    [1, 2, 4, 7, 14, 28]", "Freq": 7, "TSR": 5}, {"tool": "def get_multiples_in_range(base, start, end):\n    \n    start = ((start + base - 1) // base) * base  # Round start up to the nearest multiple of base\n    return list(range(start, end + 1, base))", "subfield": "Factors and Multiples", "tool_name": "get_multiples_in_range", "tool_type": "function", "description": "List all multiples of a given base number within a specified range.", "docstring": "List all multiples of a given base number within a specified range.\n    Parameters:\n    base (int): The base number whose multiples are to be found.\n    start (int): The starting point of the range (inclusive).\n    end (int): The ending point of the range (inclusive).\n    Returns:\n    List[int]: A list of all multiples of base within the range [start, end].\n    Examples:\n    >>> get_multiples_in_range(3, 1, 20)\n    [3, 6, 9, 12, 15, 18]", "Freq": 3, "TSR": 2}, {"tool": "def lcm_multiple(*numbers):\n    \n    return reduce(lcm, numbers)", "subfield": "Factors and Multiples", "tool_name": "lcm_multiple", "tool_type": "function", "description": "Compute the least common multiple (LCM) of multiple numbers.", "docstring": "Compute the least common multiple (LCM) of multiple numbers.\n    \n    Parameters:\n    numbers : tuple\n        A tuple containing the numbers.\n    \n    Returns:\n    int\n        The LCM of the provided numbers.\n    \n    Examples:\n    >>> lcm_multiple(5, 10, 20)\n    20\n    >>> lcm_multiple(7, 11)\n    77", "Freq": 4, "TSR": 4}, {"tool": "def prime_factors(n):\n    \n    factors = {}\n    # Check the number of 2s in n\n    while n % 2 == 0:\n        factors[2] = factors.get(2, 0) + 1\n        n //= 2\n    # n must be odd at this point, thus a skip of 2 is possible\n    for i in range(3, int(math.sqrt(n)) + 1, 2):\n        while (n % i == 0):\n            factors[i] = factors.get(i, 0) + 1\n            n //= i\n    # This condition is to check if n is a prime number greater than 2\n    if n > 2:\n        factors[n] = 1\n    return factors", "subfield": "Factors and Multiples", "tool_name": "prime_factors", "tool_type": "function", "description": "Returns the prime factorization of the given integer `n` as a dictionary\n    where keys are the prime factors and values are the corresponding exponents.", "docstring": "Returns the prime factorization of the given integer `n` as a dictionary\n    where keys are the prime factors and values are the corresponding exponents.\n    \n    Parameters:\n    n : int\n        The integer to factorize.\n    \n    Returns:\n    dict\n        A dictionary of prime factors with their exponents.\n    \n    Examples:\n    >>> prime_factors(18)\n    {2: 1, 3: 2}\n    >>> prime_factors(100)\n    {2: 2, 5: 2}", "Freq": 4, "TSR": 3}, {"tool": "def extended_gcd_lcm_calc(numbers):\n    \n    gcd_result = reduce(gcd, numbers)\n    lcm_result = reduce(lcm, numbers)\n    return gcd_result, lcm_result", "subfield": "Factors and Multiples", "tool_name": "extended_gcd_lcm_calc", "tool_type": "function", "description": "Calculate the gcd and lcm of a list of numbers using the reduce function.", "docstring": "Calculate the gcd and lcm of a list of numbers using the reduce function.\n    Parameters:\n        numbers (list): List of integers.\n    \n    Returns:\n        tuple: (gcd, lcm) of the list of numbers.\n    \n    Examples:\n        >>> extended_gcd_lcm_calc([48, 180, 640])\n        (4, 5760)\n        >>> extended_gcd_lcm_calc([21, 7, 14])\n        (7, 42)", "Freq": 0, "TSR": 0}], "Integers Properties": [{"tool": "def modular_inverse(a, m):\n    \n    from sympy.core.numbers import igcdex\n    g, x, y = igcdex(a, m)\n    if g != 1:\n        return None  # No modular inverse if a and m are not coprime\n    else:\n        return x % m", "subfield": "Integers Properties", "tool_name": "modular_inverse", "tool_type": "function", "description": "Computes the modular inverse of a under modulo m using the Extended Euclidean Algorithm.", "docstring": "Computes the modular inverse of a under modulo m using the Extended Euclidean Algorithm.\n    Parameters:\n        a (int): The number to find the inverse of.\n        m (int): The modulus.\n    Returns:\n        int: The modular inverse of a modulo m if it exists. Returns None if the modular inverse does not exist.\n    Example:\n        >>> modular_inverse(3, 11)\n        4", "Freq": 0, "TSR": 0}, {"tool": "def check_primality(number):\n    \n    return isprime(number)", "subfield": "Integers Properties", "tool_name": "check_primality", "tool_type": "function", "description": "Checks if an integer is a prime number.", "docstring": "Checks if an integer is a prime number.\n    Parameters:\n        number (int): The integer to check for primality.\n    Returns:\n        bool: True if the integer is prime, otherwise False.\n    Example:\n        >>> check_primality(29)\n        True", "Freq": 0, "TSR": 0}, {"tool": "def all_factors(n):\n    \n    return sorted(list(sympy.divisors(n)))", "subfield": "Integers Properties", "tool_name": "all_factors", "tool_type": "function", "description": "Generate all factors of a given integer.", "docstring": "Generate all factors of a given integer.\n    \n    Parameters:\n        n (int): The integer to find factors of.\n    \n    Returns:\n        list: A sorted list of all factors of n.\n    \n    Examples:\n        >>> all_factors(30)\n        [1, 2, 3, 5, 6, 10, 15, 30]", "Freq": 0, "TSR": 0}, {"tool": "def all_divisors(number):\n    \n    return divisors(number)", "subfield": "Integers Properties", "tool_name": "all_divisors", "tool_type": "function", "description": "Returns all divisors of a given integer.", "docstring": "Returns all divisors of a given integer.\n    Parameters:\n        number (int): The integer to find divisors for.\n    Returns:\n        list: A list of all divisors of the integer.\n    Example:\n        >>> all_divisors(28)\n        [1, 2, 4, 7, 14, 28]", "Freq": 1, "TSR": 1}, {"tool": "def prime_factors(number):\n    \n    i = 2\n    factors = []\n    while i * i <= number:\n        if number % i:\n            i += 1\n        else:\n            number //= i\n            factors.append(i)\n    if number > 1:\n        factors.append(number)\n    return factors", "subfield": "Integers Properties", "tool_name": "prime_factors", "tool_type": "function", "description": "Returns the prime factors of a given integer.", "docstring": "Returns the prime factors of a given integer.\n    Parameters:\n        number (int): The integer to factorize.\n    \n    Returns:\n        list: A list of prime factors of the integer.\n    Example:\n        >>> prime_factors(60)\n        [2, 2, 3, 5]", "Freq": 1, "TSR": 1}, {"tool": "def count_modular_solutions(f, g, modulus):\n    \n    count = 0\n    for x in range(modulus):\n        if f(x) % modulus == g(x) % modulus:\n            count += 1\n    return count", "subfield": "Integers Properties", "tool_name": "count_modular_solutions", "tool_type": "function", "description": "Counts the number of solutions to the equation f(x) ≡ g(x) (mod modulus).", "docstring": "Counts the number of solutions to the equation f(x) ≡ g(x) (mod modulus).\n    Parameters:\n        f (function): A Python function representing the left-hand side of the equation.\n        g (function): A Python function representing the right-hand side of the equation.\n        modulus (int): The modulus for the equivalence.\n    Returns:\n        int: The number of solutions x that satisfy the equation under the given modulus.\n    Example:\n        >>> f = lambda x: x**2\n        >>> g = lambda x: 1\n        >>> count_modular_solutions(f, g, 10)\n        3", "Freq": 0, "TSR": 0}, {"tool": "def modular_exponentiation(base, exponent, modulus):\n    \n    return pow(base, exponent, modulus)", "subfield": "Integers Properties", "tool_name": "modular_exponentiation", "tool_type": "function", "description": "Perform modular exponentiation (base^exponent % modulus).", "docstring": "Perform modular exponentiation (base^exponent % modulus).\n    Parameters:\n        base (int): The base of the expression.\n        exponent (int): The exponent of the expression.\n        modulus (int): The modulus to apply.\n    Returns:\n        int: Result of (base^exponent) % modulus.\n    Example:\n        >>> modular_exponentiation(2, 10, 1000)\n        24", "Freq": 0, "TSR": 0}, {"tool": "def digit_analysis(n):\n    \n    digits = [int(d) for d in str(n)]\n    return {\n        'digit_count': len(digits),\n        'even_digit_count': sum(1 for d in digits if d % 2 == 0),\n        'odd_digit_count': sum(1 for d in digits if d % 2 != 0),\n        'max_digit': max(digits),\n        'min_digit': min(digits)\n    }", "subfield": "Integers Properties", "tool_name": "digit_analysis", "tool_type": "function", "description": "Analyze the digits of a number and return various properties.", "docstring": "Analyze the digits of a number and return various properties.\n    \n    Parameters:\n        n (int): The integer to analyze.\n    \n    Returns:\n        dict: A dictionary with keys 'digit_count', 'even_digit_count', 'odd_digit_count', 'max_digit', 'min_digit'.\n    \n    Examples:\n        >>> digit_analysis(4562)\n        {'digit_count': 4, 'even_digit_count': 3, 'odd_digit_count': 1, 'max_digit': 6, 'min_digit': 2}", "Freq": 0, "TSR": 0}, {"tool": "def get_all_divisors(n):\n    \n    return divisors(n)", "subfield": "Integers Properties", "tool_name": "get_all_divisors", "tool_type": "function", "description": "List all divisors of a given integer.", "docstring": "List all divisors of a given integer.\n    Parameters:\n        n (int): The integer to find divisors for.\n    Returns:\n        list: A list of all divisors of n.\n    Example:\n        >>> get_all_divisors(30)\n        [1, 2, 3, 5, 6, 10, 15, 30]", "Freq": 0, "TSR": 0}], "Perfect Squares and Cubes": [{"tool": "def is_perfect_square(n):\n    \n    root = math.isqrt(n)\n    return root * root == n", "subfield": "Perfect Squares and Cubes", "tool_name": "is_perfect_square", "tool_type": "function", "description": "Check if a number is a perfect square.", "docstring": "Check if a number is a perfect square.\n    Parameters:\n    n (int): The number to check.\n    Returns:\n    bool: True if n is a perfect square, False otherwise.\n    Examples:\n    >>> is_perfect_square(16)\n    True\n    >>> is_perfect_square(17)\n    False", "Freq": 7, "TSR": 5}, {"tool": "def is_perfect_cube(n):\n    \n    root = round(n ** (1/3))\n    return root ** 3 == n", "subfield": "Perfect Squares and Cubes", "tool_name": "is_perfect_cube", "tool_type": "function", "description": "Check if a number is a perfect cube.", "docstring": "Check if a number is a perfect cube.\n    Parameters:\n    n (int): The number to check.\n    Returns:\n    bool: True if n is a perfect cube, False otherwise.\n    Examples:\n    >>> is_perfect_cube(27)\n    True\n    >>> is_perfect_cube(28)\n    False", "Freq": 5, "TSR": 5}, {"tool": "def find_perfect_squares(min_val, max_val):\n    \n    start = int(math.ceil(math.sqrt(min_val)))\n    end = int(math.floor(math.sqrt(max_val)))\n    return [i**2 for i in range(start, end + 1)]", "subfield": "Perfect Squares and Cubes", "tool_name": "find_perfect_squares", "tool_type": "function", "description": "Finds all perfect squares in a specified inclusive range.", "docstring": "Finds all perfect squares in a specified inclusive range.\n    \n    Parameters:\n        min_val (int): The minimum value of the range.\n        max_val (int): The maximum value of the range.\n    \n    Returns:\n        list: A list of all perfect squares within the given range [min_val, max_val].\n    \n    Examples:\n        >>> find_perfect_squares(1, 100)\n        [1, 4, 9, 16, 25, 36, 49, 64, 81, 100]", "Freq": 4, "TSR": 2}, {"tool": "def list_perfect_powers(upper_limit, power):\n    \n    results = []\n    num = 1\n    while (result := num ** power) < upper_limit:\n        results.append(result)\n        num += 1\n    return results", "subfield": "Perfect Squares and Cubes", "tool_name": "list_perfect_powers", "tool_type": "function", "description": "Lists all perfect powers less than an upper limit.", "docstring": "Lists all perfect powers less than an upper limit.\n    Parameters:\n    upper_limit (int): The upper boundary for checking the numbers.\n    power (int): The power to check for (2 for squares, 3 for cubes, etc.).\n    Returns:\n    list: A list of all perfect powers under the specified upper limit.", "Freq": 0, "TSR": 0}, {"tool": "def is_perfect_power(n, power):\n    \n    root = round(n ** (1 / power))\n    return root ** power == n", "subfield": "Perfect Squares and Cubes", "tool_name": "is_perfect_power", "tool_type": "function", "description": "Checks if a given number is a perfect power (e.g. square, cube).", "docstring": "Checks if a given number is a perfect power (e.g. square, cube).\n    Parameters:\n    n (int): The number to check.\n    power (int): The power to check against (e.g. 2 for squares, 3 for cubes).\n    Returns:\n    bool: True if n is a perfect power of the specified type, otherwise False.", "Freq": 0, "TSR": 0}, {"tool": "def is_perfect_sixth_power(n):\n    \n    sixth_root = round(n ** (1/6))\n    return sixth_root ** 6 == n", "subfield": "Perfect Squares and Cubes", "tool_name": "is_perfect_sixth_power", "tool_type": "function", "description": "Check if a number is a perfect sixth power.", "docstring": "Check if a number is a perfect sixth power.\n    Parameters:\n    n (int): The number to check.\n    Returns:\n    bool: True if n is a perfect sixth power, False otherwise.\n    Examples:\n    >>> is_perfect_sixth_power(64)\n    True\n    >>> is_perfect_sixth_power(65)\n    False", "Freq": 0, "TSR": 0}, {"tool": "def generate_squares(n):\n    \n    import math\n    return [i*i for i in range(int(math.sqrt(n)) + 1)]", "subfield": "Perfect Squares and Cubes", "tool_name": "generate_squares", "tool_type": "function", "description": "Generates a list of all perfect squares less than or equal to `n`.", "docstring": "Generates a list of all perfect squares less than or equal to `n`.\n    Parameters:\n        n (int): Upper bound for generating perfect squares.\n    Returns:\n    list: List of all perfect squares ≤ `n`.\n    Examples:\n        >>> generate_squares(10)\n        [0, 1, 4, 9]", "Freq": 0, "TSR": 0}, {"tool": "def perfect_powers(limit, power_type='square'):\n    \n    if power_type == 'square':\n        exponent = 2\n    elif power_type == 'cube':\n        exponent = 3\n    elif power_type == 'sixth':\n        exponent = 6\n    else:\n        raise ValueError(\"Unsupported power_type. Choose 'square', 'cube', or 'sixth'.\")\n    result = []\n    number = 1\n    while number**exponent <= limit:\n        result.append(number**exponent)\n        number += 1\n    return result", "subfield": "Perfect Squares and Cubes", "tool_name": "perfect_powers", "tool_type": "function", "description": "Identifies and lists all perfect power numbers up to a specified limit.", "docstring": "Identifies and lists all perfect power numbers up to a specified limit.\n    Parameters:\n    - limit (int): The upper boundary for numbers to check for being perfect powers.\n    - power_type (str): The type of power to check for ('square', 'cube', 'sixth').\n    Returns:\n    - list: A list of all perfect powers up to the specified limit.\n    Example:\n    >>> perfect_powers(100, 'square')\n    [1, 4, 9, 16, 25, 36, 49, 64, 81, 100]\n    >>> perfect_powers(100, 'cube')\n    [1, 8, 27, 64]\n    >>> perfect_powers(100, 'sixth')\n    [1, 64]", "Freq": 0, "TSR": 0}, {"tool": "def generate_cubes(n):\n    \n    return [i**3 for i in range(int(round(n**(1/3), 10)) + 1)]", "subfield": "Perfect Squares and Cubes", "tool_name": "generate_cubes", "tool_type": "function", "description": "Generates a list of all perfect cubes less than or equal to `n`.", "docstring": "Generates a list of all perfect cubes less than or equal to `n`.\n    Parameters:\n        n (int): Upper bound for generating perfect cubes.\n    Returns:\n    list: List of all perfect cubes ≤ `n`.\n    Examples:\n        >>> generate_cubes(30)\n        [0, 1, 8, 27]", "Freq": 1, "TSR": 1}, {"tool": "def nearest_perfect_power(n, direction=\"next\", power=2):\n    \n    increment = 0 if direction == \"previous\" else 1\n    candidate_root = round(n**(1/power)) + increment\n    candidate_power = candidate_root**power\n    if direction == \"previous\" and candidate_power > n:\n        candidate_root -= 1\n        candidate_power = candidate_root**power\n    return candidate_power", "subfield": "Perfect Squares and Cubes", "tool_name": "nearest_perfect_power", "tool_type": "function", "description": "Find the nearest perfect power greater ('next') or smaller ('previous') than a given number.", "docstring": "Find the nearest perfect power greater ('next') or smaller ('previous') than a given number.\n    Parameters:\n    - n (int): The reference number.\n    - direction (str): 'next' for next perfect power, 'previous' for previous (default 'next').\n    - power (int): The power to consider (default 2 for squares, 3 for cubes, etc.).\n    Returns:\n    - int: The nearest perfect power in the specified direction.\n    Examples:\n    >>> nearest_perfect_power(15)\n    16\n    >>> nearest_perfect_power(28, direction='previous', power=3)\n    27", "Freq": 0, "TSR": 0}, {"tool": "def adjusted_perfect_squares(limit, adjustment):\n    \n    results = []\n    num = 1\n    while (square := num ** 2) - adjustment < limit:\n        results.append(square - adjustment)\n        num += 1\n    return results", "subfield": "Perfect Squares and Cubes", "tool_name": "adjusted_perfect_squares", "tool_type": "function", "description": "Computes and returns perfect squares with a constant adjustment under a specified limit.", "docstring": "Computes and returns perfect squares with a constant adjustment under a specified limit.\n    Parameters:\n    limit (int): The upper limit for checking perfect squares.\n    adjustment (int): The number to subtract from each square before checking.\n    Returns:\n    list: Perfect squares with adjustment under the specified limit.", "Freq": 0, "TSR": 0}], "Divisibility": [{"tool": "def is_divisible(n, div):\n    \n    return n % div == 0", "subfield": "Divisibility", "tool_name": "is_divisible", "tool_type": "function", "description": "Check if the number `n` is divisible by the number `div`.", "docstring": "Check if the number `n` is divisible by the number `div`.\n    Parameters:\n    n (int): Number to check divisibility for.\n    div (int): Divisor.\n    Returns:\n    bool: True if `n` is divisible by `div`, False otherwise.\n    Examples:\n    >>> is_divisible(10, 5)\n    True\n    >>> is_divisible(13, 3)\n    False", "Freq": 1, "TSR": 1}, {"tool": "def lcm(*numbers):\n    \n    def lcm_pair(a, b):\n        return abs(a*b) // gcd(a, b)\n    \n    return reduce(lcm_pair, numbers, 1)", "subfield": "Divisibility", "tool_name": "lcm", "tool_type": "function", "description": "Calculate the least common multiple (LCM) of a list of integers.", "docstring": "Calculate the least common multiple (LCM) of a list of integers.\n    Parameters:\n        numbers (int): A series of integers for which the LCM is to be calculated.\n    Returns:\n        int: The least common multiple of the input numbers.\n    Examples:\n        >>> lcm(12, 15)\n        60\n        >>> lcm(2, 3, 5)\n        30", "Freq": 16, "TSR": 10, "experience_pool": "- When using the `lcm` function, make sure to provide the correct number of arguments as the function expects a series of integers.\n- Ensure that all the necessary functions like `count_multiples_of_lcm`, `is_divisible` are defined and called correctly within the solution.\n- Use the correct function name `lcm` instead of `calculate_lcm` when calculating the least common multiple."}, {"tool": "def find_divisors(n):\n    \n    return [x for x in range(1, n+1) if n % x == 0]", "subfield": "Divisibility", "tool_name": "find_divisors", "tool_type": "function", "description": "Determine divisors of a given number.", "docstring": "Determine divisors of a given number.\n    Parameters:\n    n : int\n        The number to find divisors of\n    Returns:\n    list\n        List of divisors of n.\n    Example:\n    >>> find_divisors(12)\n    [1, 2, 3, 4, 6, 12]", "Freq": 22, "TSR": 16, "experience_pool": "- When finding divisors of large numbers, consider optimizing the code to avoid timeouts.\n- Ensure that the input parameters for the tool are correct and within a reasonable range to prevent long runtimes."}, {"tool": "def count_multiples_of_lcm(lcm_value, start, end):\n    \n    if lcm_value == 0:\n        return 0\n    \n    count_start = (start + lcm_value - 1) // lcm_value\n    count_end = end // lcm_value\n    return count_end - count_start + 1", "subfield": "Divisibility", "tool_name": "count_multiples_of_lcm", "tool_type": "function", "description": "Count the number of multiples of LCM within a specified range.", "docstring": "Count the number of multiples of LCM within a specified range.\n    Parameters:\n        lcm_value (int): The LCM value to use for counting multiples.\n        start (int): The start of the range (inclusive).\n        end (int): The end of the range (inclusive).\n    Returns:\n        int: The count of multiples of the LCM within the specified range.\n    Examples:\n        >>> count_multiples_of_lcm(24, 1, 100)\n        4\n        >>> count_multiples_of_lcm(15, 1, 45)\n        3", "Freq": 5, "TSR": 4, "experience_pool": "Tool for counting multiples of LCM within a specified range has been used successfully with a success rate of 66.67%."}, {"tool": "def count_trailing_zeros_factorial(n):\n    \n    i, zeros = 5, 0\n    while n >= i:\n        zeros += n // i\n        i *= 5\n    return zeros", "subfield": "Divisibility", "tool_name": "count_trailing_zeros_factorial", "tool_type": "function", "description": "Counts the number of trailing zeros in n!.", "docstring": "Counts the number of trailing zeros in n!.\n    Parameters:\n    n (int): The factorial number n! to analyze.\n    Returns:\n    int: The number of trailing zeros in `n!`.\n    Examples:\n    >>> count_trailing_zeros_factorial(5)\n    1", "Freq": 2, "TSR": 2}, {"tool": "def sum_of_digits(number):\n    \n    return sum(int(digit) for digit in str(abs(number)))", "subfield": "Divisibility", "tool_name": "sum_of_digits", "tool_type": "function", "description": "Calculates the sum of all digits in the given integer number.", "docstring": "Calculates the sum of all digits in the given integer number.\n    Parameters:\n        number (int): The number whose digits will be summed.\n    Returns:\n        int: The sum of the digits.\n    Examples:\n    >>> sum_of_digits(123)\n    6\n    >>> sum_of_digits(104)\n    5", "Freq": 0, "TSR": 0}, {"tool": "def gcd(x, y):\n    \n    while y != 0:\n        (x, y) = (y, x % y)\n    return abs(x)", "subfield": "Divisibility", "tool_name": "gcd", "tool_type": "function", "description": "Compute the greatest common divisor of two integers.", "docstring": "Compute the greatest common divisor of two integers.\n    Parameters:\n    x : int\n        First integer.\n    y : int\n        Second integer.\n        \n    Returns:\n    int\n        The greatest common divisor of x and y.\n    Examples:\n    >>> gcd(48, 18)\n    6", "Freq": 8, "TSR": 5, "experience_pool": "- When using the gcd function, ensure that the parameters passed are correct and relevant to the problem being solved.\n- Check the mathematical calculations and logic in the calling code to ensure they align with the problem requirements.\n- If the tool usage frequency is low, it may indicate that the tool is not the primary issue, and the problem lies elsewhere in the code."}, {"tool": "def modular_power(base, exponent, modulus):\n    \n    return pow(base, exponent, modulus)", "subfield": "Divisibility", "tool_name": "modular_power", "tool_type": "function", "description": "Compute the power of a base number raised to an exponent under a given modulus using an efficient method.", "docstring": "Compute the power of a base number raised to an exponent under a given modulus using an efficient method.\n    Parameters:\n    base (int): The base number to be raised to the power.\n    exponent (int): The exponent to raise the base to.\n    modulus (int): The modulus under which to perform the operation.\n    Returns:\n    int: The result of (base ** exponent) % modulus.\n    Example:\n    >>> modular_power(2, 3, 5)\n    3", "Freq": 2, "TSR": 2}, {"tool": "def is_divisible(dividend, divisor):\n    \n    if divisor == 0:\n        raise ValueError(\"Divisor cannot be zero.\")\n    return dividend % divisor == 0", "subfield": "Divisibility", "tool_name": "is_divisible", "tool_type": "function", "description": "Determine if one number divides another without leaving a remainder.", "docstring": "Determine if one number divides another without leaving a remainder.\n    \n    Parameters:\n    - dividend (int): The number to be divided.\n    - divisor (int): The number with which to divide the dividend.\n    \n    Returns:\n    - bool: True if dividend is divisible by divisor, False otherwise.\n    \n    Examples:\n    - is_divisible(10, 2) -> True\n    - is_divisible(10, 3) -> False", "Freq": 0, "TSR": 0}, {"tool": "def divisors_from_factors(factor_dict):\n    \n    from functools import reduce\n    from itertools import product\n    # Generate lists of powers for each prime factor\n    factors_powers = [\n        [factor ** exp for exp in range(power + 1)]\n        for factor, power in factor_dict.items()\n    ]\n    # Generate all combinations of these powers\n    all_combinations = product(*factors_powers)\n    # Multiply out each combination to get the divisors\n    divisors = sorted({reduce(lambda x, y: x * y, combination, 1) for combination in all_combinations})\n    return divisors", "subfield": "Divisibility", "tool_name": "divisors_from_factors", "tool_type": "function", "description": "Calculate all divisors of a number given its prime factorization.", "docstring": "Calculate all divisors of a number given its prime factorization.\n    Parameters:\n    factor_dict : dict\n        A dictionary of prime factors and their respective exponents.\n    Returns:\n    list\n        Sorted list of all divisors of the number.\n    Examples:\n    >>> divisors_from_factors({2: 2, 3: 1, 5: 1})\n    [1, 2, 3, 4, 5, 6, 10, 12, 15, 20, 30, 60]", "Freq": 1, "TSR": 0}, {"tool": "def find_lcm(num1, num2):\n    \n    return abs(num1 * num2) // gcd(num1, num2)", "subfield": "Divisibility", "tool_name": "find_lcm", "tool_type": "function", "description": "Find the least common multiple of two numbers.", "docstring": "Find the least common multiple of two numbers.\n    \n    Parameters:\n    - num1 (int): First number.\n    - num2 (int): Second number.\n    \n    Returns:\n    - int: Least common multiple of num1 and num2.\n    \n    Examples:\n    - find_lcm(4, 6) -> 12", "Freq": 1, "TSR": 1}, {"tool": "def is_prime(n):\n    \n    if n == 1:\n        return False\n    elif n == 2:\n        return True\n    else:\n        for x in range(2, n):\n            if n % x == 0:\n                return False\n        return True", "subfield": "Divisibility", "tool_name": "is_prime", "tool_type": "function", "description": "Check if a given number is a prime number.", "docstring": "Check if a given number is a prime number.\n    Parameters:\n    n : int\n        The number to check\n    Returns:\n    bool\n        True if n is prime, False otherwise.\n        \n    Example:\n    >>> is_prime(2)\n    True\n    >>> is_prime(4)\n    False", "Freq": 1, "TSR": 0}, {"tool": "def find_factors(num):\n    \n    factors = []\n    for potential_factor in range(1, int(num**0.5) + 1):\n        if num % potential_factor == 0:\n            factors.append(potential_factor)\n            if potential_factor != num // potential_factor:\n                factors.append(num // potential_factor)\n    factors.sort()\n    return factors", "subfield": "Divisibility", "tool_name": "find_factors", "tool_type": "function", "description": "Finds all factors of a given number.", "docstring": "Finds all factors of a given number.\n    \n    Parameters:\n    - num (int): The number to find factors for.\n    Returns:\n    - List[int]: A list of all factors of num.\n    \n    Examples:\n    - find_factors(12) -> [1, 2, 3, 4, 6, 12]", "Freq": 2, "TSR": 2}, {"tool": "def extract_last_n_digits(number, n):\n    \n    return abs(number) % (10 ** n)", "subfield": "Divisibility", "tool_name": "extract_last_n_digits", "tool_type": "function", "description": "Extracts the last n digits of an integer.", "docstring": "Extracts the last n digits of an integer.\n    Parameters:\n    - number (int): The number from which to extract digits.\n    - n (int): The number of last digits to extract.\n    Returns:\n    - int: The last n digits of the number.\n    \n    Examples:\n    >>> extract_last_n_digits(12345, 2)\n    45\n    >>> extract_last_n_digits(98765, 3)\n    765", "Freq": 0, "TSR": 0}, {"tool": "def modulo_operation(n, m):\n    \n    return n % m", "subfield": "Divisibility", "tool_name": "modulo_operation", "tool_type": "function", "description": "Perform modulo operations.", "docstring": "Perform modulo operations.\n    Parameters:\n    n : int\n        Numerator in division\n    m : int\n        Denominator in division\n    Returns:\n    int\n        Remainder when n is divided by m.\n    Example:\n    >>> modulo_operation(10, 3)\n    1", "Freq": 0, "TSR": 0}, {"tool": "def find_multiples(number, limit):\n    \n    return [number * i for i in range(1, limit // number + 1)]", "subfield": "Divisibility", "tool_name": "find_multiples", "tool_type": "function", "description": "Returns a list of multiples of a given number up to a specified limit.", "docstring": "Returns a list of multiples of a given number up to a specified limit.\n    \n    Parameters:\n    - number (int): The base number of which multiples are desired.\n    - limit (int): The upper bound for multiples.\n    \n    Returns:\n    - List[int]: A list containing multiples of the number up to the limit.\n    \n    Examples:\n    - find_multiples(3, 10) -> [3, 6, 9]", "Freq": 0, "TSR": 0}, {"tool": "def divisibility_check(n, m):\n    \n    return n % m == 0", "subfield": "Divisibility", "tool_name": "divisibility_check", "tool_type": "function", "description": "Check if the number n is divisible by m.", "docstring": "Check if the number n is divisible by m.\n    Parameters:\n    n : int\n        Numerator in division\n    m : int\n        Denominator in division\n    Returns:\n    bool\n        True if n is divisible by m, False otherwise.\n    Example:\n    >>> divisibility_check(10, 2)\n    True\n    >>> divisibility_check(11, 2)\n    False", "Freq": 0, "TSR": 0}, {"tool": "def is_even(n):\n    \n    return n % 2 == 0", "subfield": "Divisibility", "tool_name": "is_even", "tool_type": "function", "description": "Check if a number is even.", "docstring": "Check if a number is even.\n    Parameters:\n    n : int\n        The number to check\n    Returns:\n    bool\n        True if n is even, False otherwise.\n        \n    Example:\n    >>> is_even(2)\n    True\n    >>> is_even(3)\n    False", "Freq": 0, "TSR": 0}, {"tool": "def satisfies_all_conditions(number, *divisors):\n    \n    return all(number % divisor == 0 for divisor in divisors)", "subfield": "Divisibility", "tool_name": "satisfies_all_conditions", "tool_type": "function", "description": "Check if a given number is divisible by all provided divisors.", "docstring": "Check if a given number is divisible by all provided divisors.\n    \n    Parameters:\n    - number (int): the number to check.\n    - divisors (int): a sequence of divisors to check against.\n    \n    Returns:\n    - bool: True if the number is divisible by all of the divisors, False otherwise.\n    \n    Example:\n    >>> satisfies_all_conditions(120, 4, 5, 6)\n    True\n    >>> satisfies_all_conditions(17, 4, 3)\n    False", "Freq": 0, "TSR": 0}, {"tool": "def factorization(n):\n    \n    i = 2\n    factors = []\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n            factors.append(i)\n    if n > 1:\n        factors.append(n)\n    return factors", "subfield": "Divisibility", "tool_name": "factorization", "tool_type": "function", "description": "Factorize a given number into prime factors.", "docstring": "Factorize a given number into prime factors.\n    Parameters:\n    n : int\n        The number to factorize\n    Returns:\n    list\n        List of prime factors of n.\n        \n    Example:\n    >>> factorization(12)\n    [2, 2, 3]", "Freq": 1, "TSR": 1}, {"tool": "def integer_division(n, m):\n    \n    quotient = n // m\n    remainder = n % m\n    return quotient, remainder", "subfield": "Divisibility", "tool_name": "integer_division", "tool_type": "function", "description": "Perform integer division and return quotient and remainder.", "docstring": "Perform integer division and return quotient and remainder.\n    Parameters:\n    n : int\n        Numerator in division\n    m : int\n        Denominator in division\n    Returns:\n    tuple\n        Quotient when n is divided by m and remainder.\n    Example:\n    >>> integer_division(10, 3)\n    (3, 1)", "Freq": 0, "TSR": 0}, {"tool": "def lcm(a, b):\n    \n    from math import gcd\n    return abs(a * b) // gcd(a, b)", "subfield": "Divisibility", "tool_name": "lcm", "tool_type": "function", "description": "Compute the Least Common Multiple of two integers a and b.", "docstring": "Compute the Least Common Multiple of two integers a and b.\n    Parameters:\n        a (int): First integer.\n        b (int): Second integer.\n    Returns:\n        int: LCM of a and b.\n    Example:\n        >>> lcm(4, 5)\n        20", "Freq": 0, "TSR": 0}, {"tool": "def compute_factorial(n):\n    \n    return factorial(n)", "subfield": "Divisibility", "tool_name": "compute_factorial", "tool_type": "function", "description": "Compute n!.", "docstring": "Compute n!.\n    Parameters:\n    n : int\n        The integer to compute the factorial of.\n    Returns:\n    int\n        n!.\n    Example:\n    >>> compute_factorial(5)\n    120", "Freq": 0, "TSR": 0}, {"tool": "def gcd(a, b):\n    \n    from math import gcd\n    return gcd(a, b)", "subfield": "Divisibility", "tool_name": "gcd", "tool_type": "function", "description": "Calculate the Greatest Common Divisor of two integers, a and b.", "docstring": "Calculate the Greatest Common Divisor of two integers, a and b.\n    Parameters:\n        a (int): First integer.\n        b (int): Second integer.\n    Returns:\n        int: GCD of a and b.\n    Example:\n        >>> gcd(8, 12)\n        4", "Freq": 0, "TSR": 0}, {"tool": "def divisor_properties(n):\n    \n    divs = divisors(n)\n    num = len(divs)\n    sum_divs = sum(divs)\n    prod_divs = sympy.prod(divs)\n    return {'number_of_divisors': num, 'sum_of_divisors': sum_divs, 'product_of_divisors': prod_divs}", "subfield": "Divisibility", "tool_name": "divisor_properties", "tool_type": "function", "description": "Calculate properties of divisors for n such as total number, sum, and product.", "docstring": "Calculate properties of divisors for n such as total number, sum, and product.\n    \n    Parameters:\n        n (int): The integer to analyze divisors for.\n    \n    Returns:\n        dict: A dictionary with keys 'number_of_divisors', 'sum_of_divisors', and 'product_of_divisors'.\n    \n    Examples:\n        >>> divisor_properties(30)\n        {'number_of_divisors': 8, 'sum_of_divisors': 72, 'product_of_divisors': 810000}", "Freq": 0, "TSR": 0}, {"tool": "def list_divisors(number):\n    \n    if number <= 0:\n        raise ValueError(\"Number must be positive.\")\n    divisors = [1]\n    for i in range(2, int(number**0.5) + 1):\n        if number % i == 0:\n            divisors.extend([i, number // i])\n    if number != 1:\n        divisors.append(number)\n    return sorted(list(set(divisors)))", "subfield": "Divisibility", "tool_name": "list_divisors", "tool_type": "function", "description": "List all divisors of a given number.", "docstring": "List all divisors of a given number.\n    Parameters:\n    number (int): The number whose divisors are to be found.\n    Returns:\n    list: A list of all divisors of the number.\n    Example:\n    >>> list_divisors(10)\n    [1, 2, 5, 10]", "Freq": 0, "TSR": 0}], "Multiples": [{"tool": "def find_multiples_in_range(base, start, end):\n    \n    if base == 0:\n        raise ValueError(\"Base cannot be zero.\")\n    return [i for i in range(max(base, start - start % base), end + 1, base) if i >= start]", "subfield": "Multiples", "tool_name": "find_multiples_in_range", "tool_type": "function", "description": "Generate all multiples of a base number within a specified range.", "docstring": "Generate all multiples of a base number within a specified range.\n    \n    Parameters:\n    - base (int): The base number of which multiples are to be found.\n    - start (int): The start of the range.\n    - end (int): The end of the range (inclusive).\n    \n    Returns:\n    - list: A list of multiples of the base number within the specified range.\n    \n    Examples:\n    >>> find_multiples_in_range(3, 100, 200)\n    [102, 105, 108, ..., 198]\n    >>> find_multiples_in_range(5, 1, 25)\n    [5, 10, 15, 20, 25]", "Freq": 10, "TSR": 10}, {"tool": "def lcm_two_numbers(a, b):\n    \n    return abs(a*b) // math.gcd(a, b)", "subfield": "Multiples", "tool_name": "lcm_two_numbers", "tool_type": "function", "description": "Compute the Least Common Multiple (LCM) of two integers using the Greatest Common Divisor (GCD).", "docstring": "Compute the Least Common Multiple (LCM) of two integers using the Greatest Common Divisor (GCD).\n    \n    Parameters:\n    - a (int): The first integer.\n    - b (int): The second integer.\n    \n    Returns:\n    - int: The LCM of the two integers.\n    \n    Examples:\n    --------\n    >>> lcm_two_numbers(12, 15)\n    60\n    >>> lcm_two_numbers(5, 10)\n    10", "Freq": 0, "TSR": 0}, {"tool": "def list_multiples(base, lower_bound, upper_bound):\n    \n    from math import ceil\n    start = ceil(lower_bound / base) * base\n    return [n for n in range(start, upper_bound + 1, base) if n >= lower_bound]", "subfield": "Multiples", "tool_name": "list_multiples", "tool_type": "function", "description": "Generates a list of multiples of the given number within a specified range.", "docstring": "Generates a list of multiples of the given number within a specified range.\n    Parameters:\n    -----------\n    base : int\n        The base number whose multiples are to be found.\n    lower_bound : int\n        The lower boundary of the range (inclusive).\n    upper_bound : int\n        The upper boundary of the range (inclusive).\n    Returns:\n    --------\n    list\n        A list of multiples of the base number within the specified range.\n    Examples:\n    ---------\n    >>> list_multiples(7, 1, 100)\n    [7, 14, 21, 28, 35, 42, 49, 56, 63, 70, 77, 84, 91, 98]", "Freq": 2, "TSR": 2}, {"tool": "def nearest_multiple(number, base):\n    \n    lower = number - (number % base)\n    higher = lower + base if number % base != 0 else lower\n    return (lower, higher)", "subfield": "Multiples", "tool_name": "nearest_multiple", "tool_type": "function", "description": "Find the nearest multiple of 'base' for the given 'number'.", "docstring": "Find the nearest multiple of 'base' for the given 'number'.\n    \n    Parameters:\n    - number (int): The number to find the nearest multiple to.\n    - base (int): The base number.\n    \n    Returns:\n    - tuple: The nearest lower and higher multiples of 'base' to 'number'.\n    \n    Examples:\n    >>> nearest_multiple(28, 5)\n    (25, 30)", "Freq": 0, "TSR": 0}, {"tool": "def generate_multiples(base, limit):\n    \n    return list(range(base, limit+1, base))", "subfield": "Multiples", "tool_name": "generate_multiples", "tool_type": "function", "description": "Generate a list of multiples of a given number up to a specified limit.", "docstring": "Generate a list of multiples of a given number up to a specified limit.\n    Parameters\n    ----------\n    base : int\n        The number for which multiples are to be generated.\n    limit : int\n        The maximum value upto which multiples should be calculated.\n    Returns\n    -------\n    list of ints\n        List containing the multiples of the base number up to the limit.\n    Examples\n    --------\n    >>> generate_multiples(3, 30)\n    [3, 6, 9, 12, 15, 18, 21, 24, 27, 30]\n    >>> generate_multiples(5, 50)\n    [5, 10, 15, 20, 25, 30, 35, 40, 45, 50]", "Freq": 4, "TSR": 3}, {"tool": "def nth_multiple(n, base):\n    \n    return n * base", "subfield": "Multiples", "tool_name": "nth_multiple", "tool_type": "function", "description": "Calculate the nth multiple of the base number.", "docstring": "Calculate the nth multiple of the base number.\n    \n    Parameters:\n    - n (int): The nth multiple to find.\n    - base (int): The base number.\n    \n    Returns:\n    - int: The nth multiple of the base number.\n    \n    Examples:\n    >>> nth_multiple(4, 3)\n    12\n    >>> nth_multiple(5, 10)\n    50", "Freq": 0, "TSR": 0}, {"tool": "def is_multiple(base, factor):\n    \n    return base % factor == 0", "subfield": "Multiples", "tool_name": "is_multiple", "tool_type": "function", "description": "Check if the first integer is a multiple of the second integer.", "docstring": "Check if the first integer is a multiple of the second integer.\n    \n    Parameters:\n        base (int): The number to be checked.\n        factor (int): The potential factor of the base number.\n    \n    Returns:\n        bool: True if base is a multiple of factor, False otherwise.\n    \n    Examples:\n        >>> is_multiple(20, 5)\n        True\n        >>> is_multiple(14, 5)\n        False\n        \n    Notes:\n        A number A is considered a multiple of number B if there exists an integer X such that B * X = A.", "Freq": 0, "TSR": 0}], "Modular Arithmetic": [{"tool": "def modular_add(a, b, m):\n    \n    return (a + b) % m", "subfield": "Modular Arithmetic", "tool_name": "modular_add", "tool_type": "function", "description": "Perform modular addition.", "docstring": "Perform modular addition.\n    Parameters:\n    - a (int): The first operand.\n    - b (int): The second operand.\n    - m (int): The modulus.\n    Returns:\n    int: The result of (a + b) % m.", "Freq": 1, "TSR": 1}, {"tool": "def mod_pow(base, exponent, modulus):\n    \n    return pow(base, exponent, modulus)", "subfield": "Modular Arithmetic", "tool_name": "mod_pow", "tool_type": "function", "description": "Compute the power of a number with a modulus using efficient exponentiation.", "docstring": "Compute the power of a number with a modulus using efficient exponentiation.\n    \n    Parameters:\n        base (int): Base of the power.\n        exponent (int): Exponent of the power.\n        modulus (int): Modulus to use.\n    \n    Returns:\n        int: The result of (base^exponent) mod modulus.\n    \n    Example:\n        mod_pow(2, 5, 13) returns 6 because (2^5) % 13 = 32 % 13 = 6.", "Freq": 11, "TSR": 10}, {"tool": "def get_modular_inverse(a, m):\n    \n    return mod_inverse(a, m)", "subfield": "Modular Arithmetic", "tool_name": "get_modular_inverse", "tool_type": "function", "description": "Computes the modular inverse of `a` under the modulus `m` using the Extended Euclidean Algorithm.", "docstring": "Computes the modular inverse of `a` under the modulus `m` using the Extended Euclidean Algorithm.\n    Parameters:\n    a (int): The number to find the inverse for.\n    m (int): The modulus.\n    Returns:\n    int: The modular inverse of `a` under `m`.\n    Raises:\n    ValueError: If no modular inverse exists, which occurs if `a` and `m` are not coprime.\n    Example:\n    >>> get_modular_inverse(3, 11)\n    4", "Freq": 6, "TSR": 4}, {"tool": "def mod_add(a, b, modulus):\n    \n    return (a + b) % modulus", "subfield": "Modular Arithmetic", "tool_name": "mod_add", "tool_type": "function", "description": "Perform modular addition.", "docstring": "Perform modular addition.\n    \n    Parameters:\n        a (int): First operand.\n        b (int): Second operand.\n        modulus (int): Modulus to use for the operation.\n    \n    Returns:\n        int: The result of (a + b) mod modulus.\n    \n    Example:\n        mod_add(5, 3, 7) returns 1 because (5 + 3) % 7 = 8 % 7 = 1.", "Freq": 0, "TSR": 0}, {"tool": "def modular_add(a, b, mod):\n    \n    return (a + b) % mod", "subfield": "Modular Arithmetic", "tool_name": "modular_add", "tool_type": "function", "description": "Calculate the sum of two numbers under a given modulus.", "docstring": "Calculate the sum of two numbers under a given modulus.\n    \n    Parameters:\n    a (int): The first number.\n    b (int): The second number.\n    mod (int): The modulus to apply.\n    \n    Returns:\n    int: The result of (a + b) % mod.\n    \n    Examples:\n    >>> modular_add(3, 5, 7)\n    1\n    >>> modular_add(6, 7, 5)\n    3", "Freq": 0, "TSR": 0}, {"tool": "def check_cyclic_pattern(base, mod):\n    \n    pattern = []\n    result = 1\n    for _ in range(mod):\n        result = (result * base) % mod\n        if result in pattern:\n            break\n        pattern.append(result)\n    return pattern", "subfield": "Modular Arithmetic", "tool_name": "check_cyclic_pattern", "tool_type": "function", "description": "Check for a cyclic pattern in modulo operations with a given base and modulus.", "docstring": "Check for a cyclic pattern in modulo operations with a given base and modulus.\n    Parameters\n    ----------\n    base : int\n        The base number.\n    mod : int\n        The modulus.\n    Returns\n    -------\n    List[int]\n        The repeating pattern in the sequence base^k (mod m) for k = 1, 2, ...\n    Examples\n    --------\n    >>> check_cyclic_pattern(2, 3)\n    [2, 1]", "Freq": 1, "TSR": 1}, {"tool": "def solve_congruence(expression_1, expression_2, mod):\n    \n    expression_1 = simplify(expression_1)\n    expression_2 = simplify(expression_2)\n    return (expression_2 - expression_1) % mod", "subfield": "Modular Arithmetic", "tool_name": "solve_congruence", "tool_type": "function", "description": "Solve for a variable in a congruence equation.", "docstring": "Solve for a variable in a congruence equation.\n    Parameters\n    ----------\n    expression_1 : int or str\n        The first expression of the congruence equation.\n    expression_2 : int or str\n        The second expression of the congruence equation.\n    mod : int\n        The modulus.\n    Returns\n    -------\n    int\n        The solution to the congruence equation.\n    Examples\n    --------\n    >>> solve_congruence('x', 1, 3)\n    1", "Freq": 2, "TSR": 0}, {"tool": "def simplify_modular_expression(expression):\n    \n    return simplify(expression)", "subfield": "Modular Arithmetic", "tool_name": "simplify_modular_expression", "tool_type": "function", "description": "Simplify a numerical expression with respect to mod.", "docstring": "Simplify a numerical expression with respect to mod.\n    \n    Parameters\n    ----------\n    expression : str\n        The expression to simplify.\n        \n    Returns\n    -------\n    int\n        The simplified result.\n        \n    Examples\n    --------\n    >>> simplify_modular_expression('2+3')\n    5", "Freq": 0, "TSR": 0}, {"tool": "def sum_modulo(elements, m):\n    \n    return sum(elements) % m", "subfield": "Modular Arithmetic", "tool_name": "sum_modulo", "tool_type": "function", "description": "Calculate the sum of elements under modulo m.", "docstring": "Calculate the sum of elements under modulo m.\n    Parameters:\n    - elements (list of int): The elements to sum.\n    - m (int): The modulus.\n    Returns:\n    - int: The sum of the given elements modulo m.\n    Examples:\n    >>> sum_modulo([1, 2, 3, 4], 5)\n    0", "Freq": 2, "TSR": 2}, {"tool": "def calculate_modular_inverse(num, mod):\n    \n    return mod_inverse(num, mod)", "subfield": "Modular Arithmetic", "tool_name": "calculate_modular_inverse", "tool_type": "function", "description": "Calculate the modular inverse of a number under a certain modulus.", "docstring": "Calculate the modular inverse of a number under a certain modulus.\n    Parameters\n    ----------\n    num : int\n        The number to find the inverse of.\n    mod : int\n        The modulus.\n    Returns\n    -------\n    int\n        The modular inverse of the number.\n    Examples\n    --------\n    >>> calculate_modular_inverse(3, 7)\n    5", "Freq": 0, "TSR": 0}, {"tool": "def calculate_power_modulo(base, power, mod):\n    \n    return pow(base, power, mod)", "subfield": "Modular Arithmetic", "tool_name": "calculate_power_modulo", "tool_type": "function", "description": "Calculate the power of a number modulo a certain number.", "docstring": "Calculate the power of a number modulo a certain number.\n    Parameters\n    ----------\n    base : int\n        The base number.\n    power : int\n        The power to raise the base number to.\n    mod : int\n        The modulus.\n    Returns\n    -------\n    int\n        The result of base^power modulo mod.\n    Examples\n    --------\n    >>> calculate_power_modulo(5, 3, 2)\n    1", "Freq": 0, "TSR": 0}, {"tool": "def find_factors(num):\n    \n    return [i for i in range(1, num + 1) if num % i == 0]", "subfield": "Modular Arithmetic", "tool_name": "find_factors", "tool_type": "function", "description": "Find all factors of a number.", "docstring": "Find all factors of a number.\n    Parameters\n    ----------\n    num : int\n        The number to find factors of.\n    Returns\n    -------\n    List[int]\n        The list of factors of the number.\n    Examples\n    --------\n    >>> find_factors(20)\n    [1, 2, 4, 5, 10, 20]", "Freq": 1, "TSR": 0}, {"tool": "def modular_operations(a, b, op='mod', m=1):\n    \n    if op == 'add':\n        return (a + b) % m\n    elif op == 'sub':\n        return (a - b) % m\n    elif op == 'mul':\n        return (a * b) % m\n    elif op == 'mod':\n        return a % b\n    elif op == 'div' and b != 0:  # division mod might need to use multiplicative inverse\n        from sympy import mod_inverse\n        inv_b = mod_inverse(b, m)\n        return (a * inv_b) % m\n    else:\n        raise ValueError(\"Operation not supported or division by zero\")", "subfield": "Modular Arithmetic", "tool_name": "modular_operations", "tool_type": "function", "description": "Perform modular arithmetic operations such as addition, subtraction, multiplication, \n    and modulus between two numbers under a modulo m.", "docstring": "Perform modular arithmetic operations such as addition, subtraction, multiplication, \n    and modulus between two numbers under a modulo m.\n    Parameters:\n    - a (int or float): The first operand.\n    - b (int or float): The second operand or the modulus.\n    - op (str): The operation type ('add', 'sub', 'mul', 'mod', 'div').\n    - m (int, optional): The modulo for the operation. Default is 1 for standard operations.\n    Returns:\n    - int or float: Result of the specified operation under modulo m.\n    Examples:\n    >>> modular_operations(10, 3, 'mod')\n    1\n    >>> modular_operations(5, 3, 'add', 7)\n    1\n    >>> modular_operations(4, 3, 'mul', 5)\n    2", "Freq": 0, "TSR": 0}, {"tool": "def calculate_gcd(num1, num2):\n    \n    return gcd(num1, num2)", "subfield": "Modular Arithmetic", "tool_name": "calculate_gcd", "tool_type": "function", "description": "Calculate the greatest common divisor (gcd) between two numbers.", "docstring": "Calculate the greatest common divisor (gcd) between two numbers.\n    Parameters\n    ----------\n    num1 : int\n        The first number.\n    num2 : int\n        The second number.\n    Returns\n    -------\n    int\n        The greatest common divisor of the two numbers.\n    Examples\n    --------\n    >>> calculate_gcd(20, 30)\n    10", "Freq": 2, "TSR": 1}], "Factorials": [{"tool": "def compute_factorial(n):\n    \n    if n < 0:\n        raise ValueError(\"Factorial is not defined for negative numbers.\")\n    return factorial(n)", "subfield": "Factorials", "tool_name": "compute_factorial", "tool_type": "function", "description": "Compute the factorial of a given non-negative integer n.", "docstring": "Compute the factorial of a given non-negative integer n.\n    Parameters:\n    - n (int): A non-negative integer whose factorial is to be calculated.\n    Returns:\n    - int: The factorial of the integer n.\n    Example:\n    >>> compute_factorial(5)\n    120\n    >>> compute_factorial(0)\n    1", "Freq": 7, "TSR": 2, "experience_pool": "- Always ensure to pass the correct parameters to the `compute_factorial` function.\n- Check the mathematical expressions and calculations in the calling code to ensure they are correct.\n- Pay attention to the order of operations and mathematical rules when using factorials in expressions."}, {"tool": "def simplify_factorial_expression(n, m):\n    \n    if n < m:\n        raise ValueError(\"Numerator factorial base must be greater than the denominator factorial base\")\n    if m < 0:\n        raise ValueError(\"Factorial base must be non-negative\")\n    result = 1\n    for i in range(m + 1, n + 1):\n        result *= i\n    return result", "subfield": "Factorials", "tool_name": "simplify_factorial_expression", "tool_type": "function", "description": "Simplifies an expression of the form n! / m! given that n > m.", "docstring": "Simplifies an expression of the form n! / m! given that n > m.\n    Parameters:\n    n (int): The numerator's factorial base, should be greater than m.\n    m (int): The denominator's factorial base, should be non-negative and less than n.\n    Returns:\n    int: The simplified result of n! / m!.\n    Examples:\n    >>> simplify_factorial_expression(5, 3)\n    20\n    >>> simplify_factorial_expression(6, 1)\n    720\n    Notes:\n    - If n == m, the result of the expression is 1 (since n! / n! = 1).\n    - This function uses an efficient method by only multiplying numbers from m+1 to n.", "Freq": 11, "TSR": 0, "experience_pool": "- When using the `simplify_factorial_expression` tool, ensure that the numerator `n` is greater than the denominator `m`.\n- Make sure that the denominator `m` is non-negative.\n- Use the tool as intended for simplifying factorial expressions, do not perform arithmetic operations directly with the factorial results."}, {"tool": "def factorial_gcd(a, b):\n    \n    return factorial(min(a, b))  # GCD of a! and b! is min(a, b)!", "subfield": "Factorials", "tool_name": "factorial_gcd", "tool_type": "function", "description": "Compute the greatest common divisor (GCD) of the factorials of two non-negative integers.", "docstring": "Compute the greatest common divisor (GCD) of the factorials of two non-negative integers.\n    Parameters:\n    a : int\n        The first non-negative integer.\n    b : int\n        The second non-negative integer.\n    Returns:\n    int\n        GCD of the factorials of a and b.\n    Examples:\n    >>> factorial_gcd(5, 3)\n    6\n    >>> factorial_gcd(7, 7)\n    5040", "Freq": 1, "TSR": 1}, {"tool": "def last_two_digits_of_factorial_sum(n):\n    \n    \n    if n < 1:\n        raise ValueError(\"The input must be a positive integer.\")\n    \n    def compute_factorial(k):\n        \n        if k < 0:\n            raise ValueError(\"Factorial is not defined for negative numbers.\")\n        result = 1\n        for i in range(2, k + 1):\n            result *= i\n        return result\n    \n    total_sum = 0\n    for i in range(1, n + 1):\n        total_sum += compute_factorial(i)\n    \n    return total_sum % 100  # Return the last two digits", "subfield": "Factorials", "tool_name": "last_two_digits_of_factorial_sum", "tool_type": "function", "description": "Computes the last two digits of the sum of factorials from 1! to n!.\n    \n    Args:\n    n (int): A positive integer representing the upper limit of the factorial sum.\n    \n    Returns:\n    int: The last two digits of the sum of factorials from 1! to n!.\n    \n    Raises:\n    ValueError: If n is less than 1.", "docstring": "Computes the last two digits of the sum of factorials from 1! to n!.\n    \n    Args:\n    n (int): A positive integer representing the upper limit of the factorial sum.\n    \n    Returns:\n    int: The last two digits of the sum of factorials from 1! to n!.\n    \n    Raises:\n    ValueError: If n is less than 1.", "Freq": 2, "TSR": 1}], "Counting Digits": [{"tool": "def count_digits(number):\n    \n    return len(str(abs(number)))", "subfield": "Counting Digits", "tool_name": "count_digits", "tool_type": "function", "description": "Count the number of digits in the given number.", "docstring": "Count the number of digits in the given number.\n    Parameters:\n    number (int): The number whose digits are to be counted.\n    Returns:\n    int: The number of digits in the given number.\n    Examples:\n    >>> count_digits(123)\n    3\n    >>> count_digits(-12345)\n    5", "Freq": 1, "TSR": 1}, {"tool": "def count_specific_digit_numbers(start, end, allowed_digits):\n    \n    allowed_digits = set(map(str, allowed_digits))  # Convert digits to strings for comparison\n    count = 0\n    for num in range(start, end + 1):\n        if set(str(num)).issubset(allowed_digits):\n            count += 1\n    return count", "subfield": "Counting Digits", "tool_name": "count_specific_digit_numbers", "tool_type": "function", "description": "Counts numbers within a range [start, end] that consist exclusively of the allowed digits.", "docstring": "Counts numbers within a range [start, end] that consist exclusively of the allowed digits.\n    \n    Parameters:\n    start (int): Starting value of the range.\n    end (int): Ending value of the range.\n    allowed_digits (set): A set of digits that are allowed in the numbers.\n    Returns:\n    int: Count of numbers only containing the allowed digits.\n    Examples:\n    >>> count_specific_digit_numbers(100, 500, {1, 2, 5})\n    31", "Freq": 5, "TSR": 5}, {"tool": "def count_relatively_prime_in_range(start, end, reference):\n    \n    \n    from math import gcd\n    def is_relatively_prime(num, ref):\n        \n        return gcd(num, ref) == 1\n    count = 0\n    for num in range(start, end + 1):\n        if is_relatively_prime(num, reference):\n            count += 1\n            \n    return count", "subfield": "Counting Digits", "tool_name": "count_relatively_prime_in_range", "tool_type": "function", "description": "Counts the number of natural numbers within a specified range [start, end]\n    that are relatively prime to a given reference number.\n    \n    A number is considered relatively prime to another if their greatest common divisor (GCD) is 1.", "docstring": "Counts the number of natural numbers within a specified range [start, end]\n    that are relatively prime to a given reference number.\n    \n    A number is considered relatively prime to another if their greatest common divisor (GCD) is 1.\n    Parameters:\n    start (int): The starting number of the range (inclusive).\n    end (int): The ending number of the range (inclusive).\n    reference (int): The reference number to which the natural numbers are compared.\n    Returns:\n    int: The count of numbers within the range that are relatively prime to the reference number.", "Freq": 1, "TSR": 1}], "Division and Remainders": [{"tool": "def calculate_division_properties(dividend, divisor):\n    \n    if divisor == 0:\n        raise ValueError(\"Divisor cannot be zero.\")\n    quotient = dividend // divisor\n    remainder = dividend % divisor\n    return quotient, remainder", "subfield": "Division and Remainders", "tool_name": "calculate_division_properties", "tool_type": "function", "description": "Calculates the quotient and remainder of integer division.", "docstring": "Calculates the quotient and remainder of integer division.\n    Parameters:\n        dividend (int): The number to be divided.\n        divisor (int): The number by which to divide.\n    Returns:\n        tuple:\n        - quotient (int): Result of the integer division.\n        - remainder (int): The remainder left over when dividend is divided by divisor.\n    Examples:\n    >>> calculate_division_properties(10, 3)\n    (3, 1)\n    >>> calculate_division_properties(25, 4)\n    (6, 1)", "Freq": 5, "TSR": 4}, {"tool": "def find_remainder(n, m):\n    \n    return n % m", "subfield": "Division and Remainders", "tool_name": "find_remainder", "tool_type": "function", "description": "Calculate the remainder when n is divided by m (n % m).", "docstring": "Calculate the remainder when n is divided by m (n % m).\n    Parameters\n    ----------\n    n : int\n        The dividend.\n    m : int\n        The divisor.\n    Returns\n    -------\n    int\n        The remainder of the division of n by m (0 <= remainder < m).\n    Examples\n    --------\n    >>> find_remainder(10, 3)\n    1\n    >>> find_remainder(-10, 3)\n    2", "Freq": 19, "TSR": 12, "experience_pool": "Tool for finding remainders in division is working correctly."}, {"tool": "def modular_pow(base, exp, modulus):\n    \n    result = 1\n    base = base % modulus\n    while exp > 0:\n        if exp % 2 == 1:\n            result = (result * base) % modulus\n        exp = exp >> 1\n        base = (base * base) % modulus\n    return result", "subfield": "Division and Remainders", "tool_name": "modular_pow", "tool_type": "function", "description": "Efficiently compute (base ** exp) % modulus using exponentiation by squaring.", "docstring": "Efficiently compute (base ** exp) % modulus using exponentiation by squaring.\n    Parameters:\n    base (int): The base number.\n    exp (int): The exponent.\n    modulus (int): Modulus to be applied.\n    Returns:\n    int: Result of (base ** exp) % modulus\n    Examples:\n    >>> modular_pow(2, 10, 1000)\n    24", "Freq": 4, "TSR": 3, "experience_pool": "Always ensure the correct modulus is used when performing modular exponentiation calculations."}, {"tool": "def factorial_mod(n, modulus):\n    \n    result = 1\n    for i in range(2, n + 1):\n        result = (result * i) % modulus\n    return result\n    print(modular_add(5, 3, 7))   # Outputs 1\n    print(modular_sub(5, 3, 7))   # Outputs 2\n    print(modular_mult(3, 4, 5))  # Outputs 2\n    print(modular_div(8, 3, 5))   # Outputs 1\n    print(modular_pow(2, 10, 1000)) # Outputs 24\n    print(factorial_mod(5, 7))    # Outputs 1", "subfield": "Division and Remainders", "tool_name": "factorial_mod", "tool_type": "function", "description": "Compute factorial of n modulo a given modulus.", "docstring": "Compute factorial of n modulo a given modulus.\n    Parameters:\n    n (int): Number to compute factorial of.\n    modulus (int): Modulus to be applied to the factorial result.\n    Returns:\n    int: n! % modulus\n    Examples:\n    >>> factorial_mod(5, 7)\n    1", "Freq": 3, "TSR": 3}, {"tool": "def find_extreme_remainder(dividend, divisors, mode='max'):\n    \n    if not divisors:\n        raise ValueError(\"Divisors list cannot be empty.\")\n    best_match = None\n    extreme_value = None\n    for divisor in divisors:\n        if divisor == 0:\n            continue\n        remainder = dividend % divisor\n        if (mode == 'max' and (extreme_value is None or remainder > extreme_value)) or (mode == 'min' and (extreme_value is None or remainder < extreme_value)):\n            best_match = divisor\n            extreme_value = remainder\n    return {'divisor': best_match, 'remainder': extreme_value, 'extreme_value': extreme_value}", "subfield": "Division and Remainders", "tool_name": "find_extreme_remainder", "tool_type": "function", "description": "For a given dividend and list of divisors, find the divisor which yields the maximum or minimum remainder.", "docstring": "For a given dividend and list of divisors, find the divisor which yields the maximum or minimum remainder.\n    \n    Parameters:\n    dividend (int): The number to be divided.\n    divisors (list of int): A list of divisors.\n    mode (str): Either 'max' or 'min', determines whether to find the maximum or minimum remainder.\n    Returns:\n    dict: A dictionary with keys 'divisor', 'remainder', and 'extreme_value' showing the selected divisor, its remainder, and the value of the remainder.\n    Examples:\n    >>> find_extreme_remainder(10, [1, 2, 3, 4])\n    {'divisor': 3, 'remainder': 1, 'extreme_value': 1}\n    >>> find_extreme_remainder(10, [2, 3, 4], mode='min')\n    {'divisor': 2, 'remainder': 0, 'extreme_value': 0}\n    >>> find_extreme_remainder(10, [2, 3, 4], mode='max')\n    {'divisor': 3, 'remainder': 1, 'extreme_value': 1}", "Freq": 11, "TSR": 4, "experience_pool": "1. Problem: Find the largest integer less than 74 that leaves a remainder of 3 when divided by 7.\n   Answer: 73\n   Code:\n   ```python\n   def solution():\n       dividend = 74\n       divisors = [7]\n       mode = 'min'\n       \n       result = find_extreme_remainder(dividend, divisors, mode)\n       \n       return result['divisor'] - 1\n\n   print(solution())\n   ```\n   Output: 6\n\n2. Problem: The number $839$ can be written as $19q+r$ where $q$ and $r$ are positive integers. What is the greatest possible value of $q-r$?\n   Answer: 41\n   Code:\n   ```python\n   def solution():\n       dividend = 839\n       divisors = [19]\n       mode = 'max'\n       \n       result = find_extreme_remainder(dividend, divisors, mode)\n       q = result['divisor']\n       r = result['remainder']\n       \n       q_minus_r = q - r\n       return q_minus_r\n\n   print(solution())\n   ```\n   Output: 16\n\n3. Problem: For some positive integer $k$, when 60 is divided by $k^2$, the remainder is 6. What is the remainder when 100 is divided by $k$?\n   Answer: 1\n   Code:\n   ```python\n   def solution():\n       # Find the divisor that yields a remainder of 6 when 60 is divided by k^2\n       result = find_extreme_remainder(60, [2, 3, 4, 5, 6, 7, 8], mode='min')\n       k = result['divisor']\n       \n       # Find the remainder when 100 is divided by k\n       remainder_100 = modular_remainder(100, k)\n       \n       return remainder_100\n\n   # Call the solution function and print the result\n   print(solution())\n   ```\n   Output: 0\n\n4. Problem: Grady distributed $x$ pieces of candy evenly among nine Halloween bags such that every bag received the greatest possible number of whole pieces of candy, but some candy was left over. What is the greatest possible number of pieces that could have been left over?\n   Answer: 8\n   Code:\n   ```python\n   def solution():\n       \"\"\"Grady distributed x pieces of candy evenly among nine Halloween bags such that every bag received the greatest possible number of whole pieces of candy, but some candy was left over. What is the greatest possible number of pieces that could have been left over?\"\"\"\n       x = 100  # Assume x as a large number\n       divisors = [9]\n       result = find_extreme_remainder(x, divisors, mode='max')['remainder']\n       return result\n\n   print(solution())\n   ```\n   Output: 1\n\n5. Problem: Every bag of Dummies (a chocolate candy) contains the same number of pieces.\n   The Dummies in one bag can't be divided equally among $9$ kids, because after each kid gets the same (whole) number of pieces, $7$ pieces are left over.\n   If the Dummies in three bags are divided equally among $9$ kids, what is the smallest number of pieces that could possibly be left over?\n   Answer: 3\n   Code:\n   ```python\n   def solution():\n       # Calculate the smallest number of pieces left over when the Dummies in three bags are divided equally among 9 kids\n       divisors = [9]\n       result = find_extreme_remainder(7, divisors, mode='min')['remainder']\n       return result\n\n   # Call the solution function and print the result\n   print(solution())\n   ```\n   Output: Code run time out!\n\n6. Problem: Find the largest integer less than 74 that leaves a remainder of 3 when divided by 7.\n   Answer: 73\n   Code:\n   ```python\n   def solution():\n       \"\"\"Find the largest integer less than 74 that leaves a remainder of 3 when divided by 7.\"\"\"\n       dividend = 74\n       divisors = list(range(1, 74))\n       result = find_extreme_remainder(dividend, divisors, mode='min')\n       return result['divisor'] - 1\n\n   print(solution())\n   ```\n   Output: 0"}, {"tool": "def find_modular_inverses(n, modulus):\n    \n    if modulus <= 0:\n        raise ValueError(\"Modulus must be a positive integer.\")\n    inverses = [x for x in range(1, modulus) if (n * x) % modulus == 1]\n    return inverses", "subfield": "Division and Remainders", "tool_name": "find_modular_inverses", "tool_type": "function", "description": "Finds all values x such that (x * n) % modulus == 1, i.e., modular inverses under a given modulus.", "docstring": "Finds all values x such that (x * n) % modulus == 1, i.e., modular inverses under a given modulus.\n    Parameters:\n        n (int): The integer number for which to find the modular inverses.\n        modulus (int): The modulus under which the inverses are calculated.\n    Returns:\n        list: List of all integers x such that x is an inverse of n under modulus.\n    Examples:\n    >>> find_modular_inverses(3, 11)\n    [4]\n    >>> find_modular_inverses(2, 5)\n    [3]", "Freq": 0, "TSR": 0}, {"tool": "def calculate_gcd(a, b):\n    \n    \n    if a == 0 and b == 0:\n        raise ValueError(\"GCD is undefined for both a and b being zero.\")\n    \n    while b:\n        a, b = b, a % b\n    return abs(a)", "subfield": "Division and Remainders", "tool_name": "calculate_gcd", "tool_type": "function", "description": "Calculate the greatest common divisor (GCD) of two integers using the Euclidean algorithm.", "docstring": "Calculate the greatest common divisor (GCD) of two integers using the Euclidean algorithm.\n    Parameters:\n    a (int): The first integer.\n    b (int): The second integer.\n    Returns:\n    int: The greatest common divisor of a and b.\n    Raises:\n    ValueError: If both a and b are zero, as GCD is undefined in that case.", "Freq": 0, "TSR": 0}, {"tool": "def polynomial_remainder(dividend, divisor):\n    \n    \n    if not any(divisor):\n        raise ValueError(\"Divisor polynomial cannot be zero.\")\n    \n    # Degree of the divisor\n    divisor_degree = len(divisor) - 1\n    # Make a copy of the dividend to perform the division\n    remainder = dividend[:]\n    \n    while len(remainder) >= len(divisor):\n        # Calculate the leading coefficient of the current term\n        leading_coeff = remainder[-1] / divisor[-1]\n        # Degree of the current term\n        degree_diff = len(remainder) - len(divisor)\n        \n        # Subtract the scaled divisor from the remainder\n        for i in range(len(divisor)):\n            remainder[degree_diff + i] -= leading_coeff * divisor[i]\n        \n        # Remove leading zeros\n        while remainder and remainder[-1] == 0:\n            remainder.pop()\n    \n    return remainder if remainder else [0]", "subfield": "Division and Remainders", "tool_name": "polynomial_remainder", "tool_type": "function", "description": "Calculate the remainder of the polynomial 'dividend' when divided by the polynomial 'divisor'.\n    \n    Args:\n    dividend (list): Coefficients of the dividend polynomial, where the i-th element represents the coefficient of x^i.\n    divisor (list): Coefficients of the divisor polynomial, where the i-th element represents the coefficient of x^i.\n    \n    Returns:\n    list: Coefficients of the remainder polynomial after division.\n    \n    Raises:\n    ValueError: If the divisor polynomial is zero or has no non-zero coefficients.\n    \n    Example:\n    >>> polynomial_remainder([1, 0, 0, 1], [1, 1])  # (x^3 + 1) % (x^2 + x)\n    [1, 0]  # Remainder is x^2", "docstring": "Calculate the remainder of the polynomial 'dividend' when divided by the polynomial 'divisor'.\n    \n    Args:\n    dividend (list): Coefficients of the dividend polynomial, where the i-th element represents the coefficient of x^i.\n    divisor (list): Coefficients of the divisor polynomial, where the i-th element represents the coefficient of x^i.\n    \n    Returns:\n    list: Coefficients of the remainder polynomial after division.\n    \n    Raises:\n    ValueError: If the divisor polynomial is zero or has no non-zero coefficients.\n    \n    Example:\n    >>> polynomial_remainder([1, 0, 0, 1], [1, 1])  # (x^3 + 1) % (x^2 + x)\n    [1, 0]  # Remainder is x^2", "Freq": 1, "TSR": 1}], "Greatest Common Divisor (GCD)": [{"tool": "def gcd_multiple(numbers):\n    \n    return reduce(math.gcd, numbers)", "subfield": "Greatest Common Divisor (GCD)", "tool_name": "gcd_multiple", "tool_type": "function", "description": "Compute the Greatest Common Divisor (GCD) of a list of numbers.", "docstring": "Compute the Greatest Common Divisor (GCD) of a list of numbers.\n    \n    Parameters:\n        numbers (list of int): A list of integers for which the GCD is required.\n    \n    Returns:\n        int: The greatest common divisor of the provided numbers.\n    \n    Examples:\n        >>> gcd_multiple([42, 56, 98])\n        14\n        >>> gcd_multiple([20, 40])\n        20", "Freq": 2, "TSR": 2}, {"tool": "def calculate_gcd(a, b):\n    \n    return gcd(a, b)", "subfield": "Greatest Common Divisor (GCD)", "tool_name": "calculate_gcd", "tool_type": "function", "description": "Calculate the Greatest Common Divisor (GCD) of two numbers.", "docstring": "Calculate the Greatest Common Divisor (GCD) of two numbers.\n    Parameters:\n    a (int): The first number.\n    b (int): The second number.\n    Returns:\n    int: The GCD of the two numbers.\n    Examples:\n    >>> calculate_gcd(12, 18)\n    6\n    >>> calculate_gcd(100, 25)\n    25", "Freq": 51, "TSR": 48}, {"tool": "def calculate_lcm(a, b):\n    \n    return abs(a*b) // gcd(a, b)", "subfield": "Greatest Common Divisor (GCD)", "tool_name": "calculate_lcm", "tool_type": "function", "description": "Calculate the Least Common Multiple (LCM) using the relationship with GCD.", "docstring": "Calculate the Least Common Multiple (LCM) using the relationship with GCD.\n    Parameters:\n    a (int): The first number.\n    b (int): The second number.\n    Returns:\n    int: The LCM of the two numbers.\n    Examples:\n    >>> calculate_lcm(12, 18)\n    36\n    >>> calculate_lcm(5, 7)\n    35", "Freq": 9, "TSR": 9}, {"tool": "def gcd_of_factorials(a, b):\n    \n    factorial_a = factorial(a)\n    factorial_b = factorial(b)\n    return gcd(factorial_a, factorial_b)", "subfield": "Greatest Common Divisor (GCD)", "tool_name": "gcd_of_factorials", "tool_type": "function", "description": "Computes the GCD of the factorials of two integers.", "docstring": "Computes the GCD of the factorials of two integers.\n    Parameters:\n        a (int): The first number whose factorial is considered.\n        b (int): The second number whose factorial is considered.\n    \n    Returns:\n        int: The GCD of the factorials of two integers.\n    \n    Examples:\n        >>> gcd_of_factorials(5, 6)\n        120  # Since 5! = 120 and 6! = 720; gcd(120, 720) = 120\n        >>> gcd_of_factorials(3, 4)\n        6    # Since 3! = 6 and 4! = 24; gcd(6, 24) = 6", "Freq": 8, "TSR": 6, "experience_pool": "- Incorrect input parameters in the calling code led to the wrong output.\n- The tool code itself is accurate and does what it is designed to do."}, {"tool": "def gcd_of_expressions(expr1, expr2, variable, value):\n    \n    import sympy as sp\n    \n    # Define the variable\n    var = sp.symbols(variable)\n    \n    # Parse the expressions\n    expression1 = sp.sympify(expr1)\n    expression2 = sp.sympify(expr2)\n    \n    # Substitute the value into the expressions\n    evaluated_expr1 = expression1.subs(var, value)\n    evaluated_expr2 = expression2.subs(var, value)\n    \n    # Compute the GCD of the evaluated expressions\n    return sp.gcd(evaluated_expr1, evaluated_expr2)", "subfield": "Greatest Common Divisor (GCD)", "tool_name": "gcd_of_expressions", "tool_type": "function", "description": "Computes the GCD of two expressions after substituting a value for a variable.", "docstring": "Computes the GCD of two expressions after substituting a value for a variable.\n    \n    Parameters:\n    expr1 (str): The first expression as a string, e.g., 'n**2 + n'.\n    expr2 (str): The second expression as a string, e.g., 'n + 1'.\n    variable (str): The variable in the expressions to substitute.\n    value (int): The value to substitute for the variable.\n    \n    Returns:\n    int: The GCD of the two expressions evaluated at the given value.\n    \n    Example:\n    >>> gcd_of_expressions('n**2 + n', 'n + 1', 'n', 3)\n    4", "Freq": 1, "TSR": 1}], "Factorials and Multiples": [{"tool": "def compute_factorial(n):\n    \n    if n < 0:\n        raise ValueError(\"Factorial is not defined for negative numbers\")\n    return math.factorial(n)", "subfield": "Factorials and Multiples", "tool_name": "compute_factorial", "tool_type": "function", "description": "Compute the factorial of a non-negative integer n.", "docstring": "Compute the factorial of a non-negative integer n.\n    \n    Parameters:\n        n (int): A non-negative integer whose factorial is to be computed.\n        \n    Returns:\n        int: The factorial of n.\n        \n    Examples:\n        >>> compute_factorial(5)\n        120\n        >>> compute_factorial(0)\n        1", "Freq": 6, "TSR": 6}, {"tool": "def sum_of_factorials_and_divisibility(n, sequence):\n    \n    import math\n    def compute_factorial(m):\n        \n        if m < 0:\n            raise ValueError(\"Factorial is not defined for negative numbers\")\n        return math.factorial(m)\n    def smallest_factorial_divisible_by(m):\n        \n        k = 1\n        while True:\n            if compute_factorial(k) % m == 0:\n                return k\n            k += 1\n    # Calculate the sum of factorials for the given sequence\n    sum_factorials = sum(compute_factorial(num) for num in sequence)\n    # Find the smallest factorial divisible by n\n    smallest_k = smallest_factorial_divisible_by(n)\n    return sum_factorials, smallest_k", "subfield": "Factorials and Multiples", "tool_name": "sum_of_factorials_and_divisibility", "tool_type": "function", "description": "Computes the sum of factorials for a given sequence of integers and checks\n    the smallest factorial that is divisible by a specified integer.", "docstring": "Computes the sum of factorials for a given sequence of integers and checks\n    the smallest factorial that is divisible by a specified integer.\n    Parameters:\n    n (int): The integer for which we want to find the smallest factorial divisible by it.\n    sequence (list of int): A list of integers for which to compute the sum of their factorials.\n    Returns:\n    tuple: A tuple containing:\n        - The sum of factorials of the numbers in the sequence.\n        - The smallest integer k such that k! is divisible by n.", "Freq": 3, "TSR": 3}, {"tool": "def compute_combinations_and_permutations(n, k):\n    \n    import math\n    if n < 0 or k < 0:\n        raise ValueError(\"n and k must be non-negative integers\")\n    if k > n:\n        raise ValueError(\"k cannot be greater than n\")\n    def compute_factorial(m):\n        if m < 0:\n            raise ValueError(\"Factorial is not defined for negative numbers\")\n        return math.factorial(m)\n    # Calculate combinations: C(n, k) = n! / (k! * (n - k)!)\n    combinations = compute_factorial(n) // (compute_factorial(k) * compute_factorial(n - k))\n    \n    # Calculate permutations: P(n, k) = n! / (n - k)!\n    permutations = compute_factorial(n) // compute_factorial(n - k)\n    \n    return combinations, permutations", "subfield": "Factorials and Multiples", "tool_name": "compute_combinations_and_permutations", "tool_type": "function", "description": "Computes the number of combinations and permutations of n items taken k at a time.", "docstring": "Computes the number of combinations and permutations of n items taken k at a time.\n    \n    Parameters:\n    n (int): The total number of items.\n    k (int): The number of items to choose.\n    \n    Returns:\n    tuple: A tuple containing the number of combinations (n choose k) and the number of permutations (n permute k).\n    \n    Raises:\n    ValueError: If n or k is negative, or if k is greater than n.", "Freq": 0, "TSR": 0}], "Digit Sums": [{"tool": "def digit_sum(number):\n    \n    return sum(int(digit) for digit in str(abs(number)))", "subfield": "Digit Sums", "tool_name": "digit_sum", "tool_type": "function", "description": "Calculate the sum of the digits of a number.", "docstring": "Calculate the sum of the digits of a number.\n    \n    Parameters:\n    number (int): The number whose digits will be summed.\n    Returns:\n    int: The sum of the digits of the number.\n    Examples:\n    >>> digit_sum(123)\n    6\n    >>> digit_sum(104)\n    5", "Freq": 1, "TSR": 1}, {"tool": "def reverse_digits(n):\n    \n    return int(str(n)[::-1]) if n >= 0 else -int(str(-n)[::-1])", "subfield": "Digit Sums", "tool_name": "reverse_digits", "tool_type": "function", "description": "Reverse the digits of the number `n` and return the resulting integer.", "docstring": "Reverse the digits of the number `n` and return the resulting integer.\n    \n    Parameters:\n        n (int): The number to be reversed.\n    \n    Returns:\n        int: The integer formed by the reverse order of the digits of `n`.\n    Examples:\n        >>> reverse_digits(123)\n        321\n        >>> reverse_digits(100)\n        1", "Freq": 0, "TSR": 0}, {"tool": "def digit_count(n):\n    \n    return len(str(abs(n)))", "subfield": "Digit Sums", "tool_name": "digit_count", "tool_type": "function", "description": "Count the number of digits in an integer.", "docstring": "Count the number of digits in an integer.\n    Parameters:\n    -----------\n    n : int\n        The number to count the digits of.\n    Returns:\n    --------\n    int\n        Number of digits in `n`.\n    Examples:\n    ---------\n    >>> digit_count(12345)\n    5\n    >>> digit_count(-123)\n    3", "Freq": 2, "TSR": 1}, {"tool": "def digit_sum(n, filter_divisor=None):\n    \n    s = sum(int(digit) for digit in str(abs(n)))\n    if filter_divisor is not None and s % filter_divisor != 0:\n        return 0\n    return s", "subfield": "Digit Sums", "tool_name": "digit_sum", "tool_type": "function", "description": "Calculate the sum of the digits of an integer `n`. Optionally, only consider the sum if it is divisible by `filter_divisor`.", "docstring": "Calculate the sum of the digits of an integer `n`. Optionally, only consider the sum if it is divisible by `filter_divisor`.\n    \n    Parameters:\n        n (int): The number whose digit sum is calculated.\n        filter_divisor (int, optional): If specified, the function will check if the digit sum is divisible by this number and return the sum if true, otherwise 0.\n    Returns:\n        int: The sum of the digits of `n` if `filter_divisor` is None or if the sum is divisible by `filter_divisor`, otherwise 0.\n    Examples:\n        >>> digit_sum(123)\n        6\n        >>> digit_sum(123, filter_divisor=3)\n        6\n        >>> digit_sum(124, filter_divisor=3)\n        0", "Freq": 0, "TSR": 0}, {"tool": "def is_palindrome(n):\n    \n    s = str(n)\n    return s == s[::-1]", "subfield": "Digit Sums", "tool_name": "is_palindrome", "tool_type": "function", "description": "Checks whether a given number is a palindrome.", "docstring": "Checks whether a given number is a palindrome.\n    Parameters:\n    - n (int): The number to check.\n    Returns:\n    - bool: True if n is a palindrome; otherwise False.\n    Examples:\n    >>> is_palindrome(121)\n    True\n    >>> is_palindrome(123)\n    False", "Freq": 3, "TSR": 2}, {"tool": "def max_digit_sum_ordering(digits, desired_sum):\n    \n    from itertools import permutations\n    valid_numbers = []\n    for perm in permutations(digits):\n        if sum(perm) == desired_sum:\n            valid_numbers.append(int(''.join(map(str, perm))))\n    return max(valid_numbers, default=None)", "subfield": "Digit Sums", "tool_name": "max_digit_sum_ordering", "tool_type": "function", "description": "Find the largest number formed by arranging digits to achieve a specified sum of digits.", "docstring": "Find the largest number formed by arranging digits to achieve a specified sum of digits.\n    Parameters:\n    -----------\n    digits : list of int\n        List of individual digits available.\n    desired_sum : int\n        The desired sum of the digits of the resulting number.\n    Returns:\n    --------\n    int or None\n        The largest number possible with the desired digit sum, or None if no such arrangement exists.\n    Examples:\n    ---------\n    >>> max_digit_sum_ordering([1, 2, 3, 9], 14)\n    9321", "Freq": 1, "TSR": 1}, {"tool": "def digit_counter(number):\n    \n    counts = {}\n    for digit in str(abs(number)):\n        dig = int(digit)\n        if dig in counts:\n            counts[dig] += 1\n        else:\n            counts[dig] = 1\n    return counts", "subfield": "Digit Sums", "tool_name": "digit_counter", "tool_type": "function", "description": "Counts the occurrence of each digit in a number.", "docstring": "Counts the occurrence of each digit in a number.\n    Parameters:\n    number (int): The number to count digits from.\n    Returns:\n    dict: A dictionary with digits as keys and their counts as values.\n    Examples:\n    >>> digit_counter(112233)\n    {1: 2, 2: 2, 3: 2}\n    >>> digit_counter(456789)\n    {4: 1, 5: 1, 6: 1, 7: 1, 8: 1, 9: 1}", "Freq": 0, "TSR": 0}, {"tool": "def sum_of_digit_powers(n, power):\n    \n    return sum(int(d)**power for d in str(abs(n)))", "subfield": "Digit Sums", "tool_name": "sum_of_digit_powers", "tool_type": "function", "description": "Calculate the sum of the digits of a number raised to a specific power.", "docstring": "Calculate the sum of the digits of a number raised to a specific power.\n    Parameters:\n    -----------\n    n : int\n        The number whose digits will be raised to the power and summed.\n    power : int\n        The power to raise each digit.\n    Returns:\n    --------\n    int\n        Sum of the digits of `n` raised to the `power`.\n    Examples:\n    ---------\n    >>> sum_of_digit_powers(123, 2)\n    14  # 1^2 + 2^2 + 3^2\n    >>> sum_of_digit_powers(321, 3)\n    36  # 3^3 + 2^3 + 1^3", "Freq": 1, "TSR": 1}, {"tool": "def valid_digit_combinations(range_digits, check_evenness=True):\n    \n    from itertools import product\n    if check_evenness:\n        pairs = [(d1, d2) for d1 in range_digits for d2 in range_digits if (d1 % 2 == d2 % 2)]\n    else:\n        pairs = list(product(range_digits, repeat=2))\n    return len(pairs) * len(range_digits)", "subfield": "Digit Sums", "tool_name": "valid_digit_combinations", "tool_type": "function", "description": "Count combinations of digits from the range where first and last digits follow specific rules.", "docstring": "Count combinations of digits from the range where first and last digits follow specific rules.\n    Parameters:\n    -----------\n    range_digits : list of int\n        The digits available for forming combinations.\n    check_evenness : bool\n        If true, checks that the first and last digits must both be even or both be odd.\n    Returns:\n    --------\n    int\n        Count of valid combinations of digits given the conditions.\n    Examples:\n    ---------\n    >>> valid_digit_combinations([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])\n    30  # 10 possible even-even or odd-odd pairs with 10 choices in between", "Freq": 0, "TSR": 0}, {"tool": "def is_palindrome(number, base=10):\n    \n    original = number\n    reversed_num = 0\n    while number > 0:\n        reversed_num = reversed_num * base + number % base\n        number //= base\n    return original == reversed_num", "subfield": "Digit Sums", "tool_name": "is_palindrome", "tool_type": "function", "description": "Check if a given number is a palindrome in the specified base.", "docstring": "Check if a given number is a palindrome in the specified base.\n    Parameters:\n    - number (int): The number to check.\n    - base (int): The numerical base in which the number's palindromic nature is to be assessed.\n    Returns:\n    - bool: True if the number is a palindrome, False otherwise.\n    Examples:\n    >>> is_palindrome(121)\n    True\n    >>> is_palindrome(123, 10)\n    False\n    >>> is_palindrome(0b101, 2)\n    True", "Freq": 0, "TSR": 0}, {"tool": "def count_digit_occurrences_in_range(start, end, digit):\n    \n    count = 0\n    for num in range(start, end + 1):\n        count += str(num).count(digit)\n    return count", "subfield": "Digit Sums", "tool_name": "count_digit_occurrences_in_range", "tool_type": "function", "description": "Counts how many times a specific digit appears within a range of numbers.", "docstring": "Counts how many times a specific digit appears within a range of numbers.\n    Parameters:\n    start (int): Start of the range (inclusive).\n    end (int): End of the range (inclusive).\n    digit (str): The digit to count occurrences of.\n    Returns:\n    int: Total count of the digit's occurrences within the specified range.\n    Examples:\n    >>> count_digit_occurrences_in_range(10, 30, '1')\n    12\n    >>> count_digit_occurrences_in_range(1, 100, '0')\n    9", "Freq": 3, "TSR": 1}, {"tool": "def is_palindromic_number(n):\n    \n    str_n = str(n)\n    return str_n == str_n[::-1]", "subfield": "Digit Sums", "tool_name": "is_palindromic_number", "tool_type": "function", "description": "Check if the given integer is a palindromic number.\n    \n    A palindromic number is a number that remains the same when its digits are reversed.", "docstring": "Check if the given integer is a palindromic number.\n    \n    A palindromic number is a number that remains the same when its digits are reversed.\n    Parameters:\n    - n (int): The number to check.\n    Returns:\n    - bool: True if n is a palindromic number, otherwise False.\n    Examples:\n    >>> is_palindromic_number(121)\n    True\n    >>> is_palindromic_number(123)\n    False", "Freq": 0, "TSR": 0}], "Modulo Arithmetic": [{"tool": "def modular_add(a, b, mod):\n    \n    return (a + b) % mod", "subfield": "Modulo Arithmetic", "tool_name": "modular_add", "tool_type": "function", "description": "Perform modular addition between two numbers.", "docstring": "Perform modular addition between two numbers.\n    Parameters:\n        a (int): The first integer.\n        b (int): The second integer.\n        mod (int): The modulus.\n    Returns:\n        int: The result of (a + b) % mod\n    Examples:\n        >>> modular_add(5, 3, 7)\n        1", "Freq": 19, "TSR": 16, "experience_pool": "- When using the tool, make sure to define any additional functions needed in the code separately.\n- Ensure that all functions called within the code are properly defined and accessible."}, {"tool": "def solve_linear_congruence(a, b, m):\n    import math\n    \n    if m == 0:\n        return None\n    \n    # Extended Euclidean Algorithm to find the modular inverse of a\n    def mod_inv(a, m):\n        m0, x0, x1 = m, 0, 1\n        while a > 1:\n            q = a // m\n            m, a = a % m, m\n            x0, x1 = x1 - q * x0, x0\n        return x1 + m0 if x1 < 0 else x1\n    \n    # Calculate the modular inverse of a\n    a_inv = mod_inv(a, m)\n    \n    if a_inv is None:\n        return None\n    else:\n        return (a_inv * b) % m", "subfield": "Modulo Arithmetic", "tool_name": "solve_linear_congruence", "tool_type": "function", "description": "None", "docstring": null, "Freq": 13.0, "TSR": 6.5, "experience_pool": "- When using the `solve_linear_congruence` function, ensure that the modulus `m` is not zero to avoid a ZeroDivisionError."}, {"tool": "def modular_inverse(a, m):\n    \n    try:\n        return mod_inverse(a, m)\n    except ValueError:\n        return \"No Inverse Exists\"", "subfield": "Modulo Arithmetic", "tool_name": "modular_inverse", "tool_type": "function", "description": "Compute the modular inverse of a mod m.\n    \n    Args:\n        a : int\n            The number whose modular inverse is to be calculated.\n        m : int\n            The modular value.\n   \n    Returns:\n        int\n            Returns the modular inverse of a mod m.", "docstring": "Compute the modular inverse of a mod m.\n    \n    Args:\n        a : int\n            The number whose modular inverse is to be calculated.\n        m : int\n            The modular value.\n   \n    Returns:\n        int\n            Returns the modular inverse of a mod m.", "Freq": 3, "TSR": 3}, {"tool": "def modular_inverse(a, mod):\n    \n    try:\n        return pow(a, -1, mod)\n    except ValueError:\n        return None", "subfield": "Modulo Arithmetic", "tool_name": "modular_inverse", "tool_type": "function", "description": "Find the modular multiplicative inverse of a under modulo mod.", "docstring": "Find the modular multiplicative inverse of a under modulo mod.\n    Parameters:\n        a (int): The integer to find the inverse.\n        mod (int): The modulus.\n    Returns:\n        int or None: The modular inverse of a modulo mod if it exists, otherwise None.\n    Examples:\n        >>> modular_inverse(3, 11)\n        4", "Freq": 9, "TSR": 9}, {"tool": "def calc_modulo(number, mod):\n    \n    return number % mod", "subfield": "Modulo Arithmetic", "tool_name": "calc_modulo", "tool_type": "function", "description": "Calculate the remainder of a division by `mod`.", "docstring": "Calculate the remainder of a division by `mod`.\n    Parameters:\n    - number (int): The number to be divided.\n    - mod (int): The divisor (modulus) to divide by.\n    Returns:\n    int: The remainder when `number` is divided by `mod`.\n    Example:\n    >>> calc_modulo(10, 3)\n    1", "Freq": 27, "TSR": 22, "experience_pool": "- When using the `calc_modulo` function, ensure that the parameters passed are correct and in the right order.\n- Double-check the calculations in the calling functions to ensure the correct usage of the `calc_modulo` function."}, {"tool": "def is_congruent(a, b, m):\n    \n    return a % m == b % m", "subfield": "Modulo Arithmetic", "tool_name": "is_congruent", "tool_type": "function", "description": "Determine if 'a' and 'b' are congruent modulo 'm'.\n    Args:\n        a : int\n            First integer.\n        b : int\n            Second integer.\n        m : int\n            The modular value.\n    Returns:\n        bool\n            Returns True if 'a' and 'b' are congruent modulo 'm', else False.", "docstring": "Determine if 'a' and 'b' are congruent modulo 'm'.\n    Args:\n        a : int\n            First integer.\n        b : int\n            Second integer.\n        m : int\n            The modular value.\n    Returns:\n        bool\n            Returns True if 'a' and 'b' are congruent modulo 'm', else False.", "Freq": 7, "TSR": 6}, {"tool": "def modular_exponentiation(base, exponent, modulus):\n    \n    if gcd(base, modulus) == 1:  # If base and modulus are coprime, Fermat's little theorem can be applied.\n        exponent = exponent % (modulus - 1)\n    result = pow(base, exponent, modulus)\n    return result", "subfield": "Modulo Arithmetic", "tool_name": "modular_exponentiation", "tool_type": "function", "description": "Calculate base^exponent mod modulus efficiently.", "docstring": "Calculate base^exponent mod modulus efficiently.\n    Parameters:\n    - base: The base of the exponentiation.\n    - exponent: The exponent.\n    - modulus: The modulus.\n    Returns:\n    - The result of (base^exponent) mod modulus.\n    \n    Examples:\n    >>> modular_exponentiation(2, 10, 1000)\n    24", "Freq": 15, "TSR": 12, "experience_pool": "- The tool for modular exponentiation has a success rate of 75.0% and has been used frequently in the field of Number Theory.\n- The tool includes a check for coprimality between the base and modulus, which is a good optimization.\n- The failed tasks are due to incorrect usage of the tool in the calling code, not the tool itself."}, {"tool": "def sum_modulo(numbers, mod):\n    \n    return sum(numbers) % mod", "subfield": "Modulo Arithmetic", "tool_name": "sum_modulo", "tool_type": "function", "description": "Calculate the sum of a list of numbers under a specified modulo.", "docstring": "Calculate the sum of a list of numbers under a specified modulo.\n    Parameters:\n    - numbers (list of int): List of integers to be summed.\n    - mod (int): The modulus for the sum operation.\n    Returns:\n    int: The result of the sum modulo `mod`.\n    Example:\n    >>> sum_modulo([1, 2, 3, 4], 3)\n    1", "Freq": 6, "TSR": 6}, {"tool": "def solve_system_of_congruences(congruences):\n    \n    from sympy.ntheory.modular import solve_congruence\n    \n    # Prepare the list of congruences in the format required by solve_congruence\n    formatted_congruences = [(a, m) for a, m in congruences]\n    \n    # Use sympy's solve_congruence to find the solution\n    try:\n        solution = solve_congruence(*formatted_congruences)\n        return solution[0]  # Return the first element which is the solution\n    except ValueError:\n        return None  # No solution exists", "subfield": "Modulo Arithmetic", "tool_name": "solve_system_of_congruences", "tool_type": "function", "description": "Solve a system of linear congruences using the Chinese Remainder Theorem.\n    \n    Args:\n        congruences : list of tuples\n            A list where each tuple contains two integers (a, m) representing \n            the congruence a (mod m).\n    \n    Returns:\n        int or None\n            The smallest non-negative solution x that satisfies all congruences, \n            or None if no solution exists.", "docstring": "Solve a system of linear congruences using the Chinese Remainder Theorem.\n    \n    Args:\n        congruences : list of tuples\n            A list where each tuple contains two integers (a, m) representing \n            the congruence a (mod m).\n    \n    Returns:\n        int or None\n            The smallest non-negative solution x that satisfies all congruences, \n            or None if no solution exists.", "Freq": 6, "TSR": 6}, {"tool": "def modular_arithmetic_solver(a, b, m):\n    \n    \n    def mod_inv(a, m):\n        \n        m0, x0, x1 = m, 0, 1\n        if m == 1:\n            return 0\n        while a > 1:\n            q = a // m\n            m, a = a % m, m\n            x0, x1 = x1 - q * x0, x0\n        return x1 + m0 if x1 < 0 else x1\n    def solve_linear_congruence(a, b, m):\n        \n        a_inv = mod_inv(a, m)\n        if a_inv is None:\n            return None\n        else:\n            return (a_inv * b) % m\n    # Calculate the modular inverse\n    inverse = mod_inv(a, m)\n    \n    # Solve the linear congruence\n    solution = solve_linear_congruence(a, b, m)\n    \n    return inverse, solution", "subfield": "Modulo Arithmetic", "tool_name": "modular_arithmetic_solver", "tool_type": "function", "description": "Solve the modular equation ax ≡ b (mod m) and find the modular inverse of a mod m.\n    \n    Args:\n        a : int\n            The coefficient of x in the modular equation.\n        b : int\n            The constant term in the modular equation.\n        m : int\n            The modulus for the equation.\n    \n    Returns:\n        tuple\n            A tuple containing the modular inverse of a mod m and the solution x to the equation ax ≡ b (mod m).\n            Returns (None, None) if no inverse exists or if no solution exists.", "docstring": "Solve the modular equation ax ≡ b (mod m) and find the modular inverse of a mod m.\n    \n    Args:\n        a : int\n            The coefficient of x in the modular equation.\n        b : int\n            The constant term in the modular equation.\n        m : int\n            The modulus for the equation.\n    \n    Returns:\n        tuple\n            A tuple containing the modular inverse of a mod m and the solution x to the equation ax ≡ b (mod m).\n            Returns (None, None) if no inverse exists or if no solution exists.", "Freq": 5, "TSR": 3}], "Base Conversion": [{"tool": "def convert_base(number, source_base, target_base):\n    \n    import numpy as np\n    # Convert the number from any base to base 10\n    base10 = int(number, source_base)\n    # Convert from base 10 to the target base\n    if target_base == 10:\n        return str(base10)\n    else:\n        return np.base_repr(base10, base=target_base)", "subfield": "Base Conversion", "tool_name": "convert_base", "tool_type": "function", "description": "Convert a number from a specific source base to a target base.", "docstring": "Convert a number from a specific source base to a target base.\n    Parameters:\n    - number (str): The number in string format in the source base.\n    - source_base (int): The base of the input number.\n    - target_base (int): The base to which the number needs to be converted.\n    Returns:\n    - str: The number converted into the target base.\n    Examples:\n    >>> convert_base('101', 2, 10)\n    '5'\n    >>> convert_base('FF', 16, 2)\n    '11111111'", "Freq": 5, "TSR": 3}, {"tool": "def binary_to_decimal(binary_str):\n    \n    return int(binary_str, 2)", "subfield": "Base Conversion", "tool_name": "binary_to_decimal", "tool_type": "function", "description": "Convert a binary number (as a string) to its decimal (base 10) representation.", "docstring": "Convert a binary number (as a string) to its decimal (base 10) representation.\n    \n    Parameters:\n    - binary_str (str): The binary number as a string.\n    \n    Returns:\n    - int: The decimal representation of the binary number.\n    \n    Examples:\n    >>> binary_to_decimal('101')\n    5\n    >>> binary_to.getValueOfKey('1101')\n    13", "Freq": 0, "TSR": 0}, {"tool": "def smallest_palindrome_of_length(length, base):\n    \n    if length == 1:\n        return '1'\n    elif length == 2:\n        return '11'\n    \n    # Start with the minimal number consisting of \"1\" followed by zeroes and closing with \"1\"\n    start = '1' + '0' * (length - 2) + '1'\n    return start", "subfield": "Base Conversion", "tool_name": "smallest_palindrome_of_length", "tool_type": "function", "description": "Finds the smallest palindromic number with the specified length in the given base.", "docstring": "Finds the smallest palindromic number with the specified length in the given base.\n    \n    Parameters:\n        length (int): The length of the palindromic number.\n        base (int): The base in which the palindrome should exist.\n    Returns:\n        str: The smallest palindrome of the given length in the specified base.\n        \n    Examples:\n        >>> smallest_palindrome_of_length(5, 2)\n        '10001'\n        >>> smallest_palindrome_of_length(3, 10)\n        '101'", "Freq": 1, "TSR": 0}, {"tool": "def smallest_binary_palindrome(length):\n    \n    # Must at least be of length 1 and has to be odd for a singular smallest palindromic number\n    if length < 1:\n        raise ValueError(\"Length must be at least 1.\")\n    \n    if length == 1:\n        return \"1\"\n    \n    half = \"1\" + \"0\" * (length // 2 - 1)\n    return half + half[::-1]  # mirror the first half to form a palindrome", "subfield": "Base Conversion", "tool_name": "smallest_binary_palindrome", "tool_type": "function", "description": "Find the smallest palindromic number in binary with a specified length.", "docstring": "Find the smallest palindromic number in binary with a specified length.\n    Parameters:\n    length : int\n        The length of the binary palindrome.\n    Returns:\n    str:\n        The smallest binary palindromic number of the specified length.\n    Examples:\n    >>> smallest_binary_palindrome(5)\n    '10001'", "Freq": 0, "TSR": 0}], "Least Common Multiple": [{"tool": "def lcm(x, y):\n    return abs(x * y) / gcd(x, y)", "subfield": "Least Common Multiple", "tool_name": "lcm", "tool_type": "function", "description": "None", "docstring": null, "Freq": 7.0, "TSR": 6.0, "experience_pool": "- When using the `reduce` function with mathematical operations, ensure that the input and output types are consistent to avoid TypeError."}, {"tool": "def lcm(x, y):\n    \n    return abs(x * y) // gcd(x, y)", "subfield": "Least Common Multiple", "tool_name": "lcm", "tool_type": "function", "description": "Calculate the Least Common Multiple (LCM) of two integers.", "docstring": "Calculate the Least Common Multiple (LCM) of two integers.\n    Parameters:\n    - x (int): First integer.\n    - y (int): Second integer.\n    Returns:\n    - int: LCM of the two integers.\n    Examples:\n    >>> lcm(12, 18)\n    36\n    >>> lcm(5, 11)\n    55", "Freq": 8, "TSR": 7}, {"tool": "def count_ordered_triples(lcm_ab, lcm_bc, lcm_ca):\n    \n    \n    def lcm(x, y):\n        return abs(x * y) // gcd(x, y)\n    def prime_factorization(n):\n        factors = Counter()\n        d = 2\n        while d * d <= n:\n            while (n % d) == 0:\n                factors[d] += 1\n                n //= d\n            d += 1\n        if n > 1:\n            factors[n] += 1\n        return factors\n    # Get prime factorizations\n    factors_ab = prime_factorization(lcm_ab)\n    factors_bc = prime_factorization(lcm_bc)\n    factors_ca = prime_factorization(lcm_ca)\n    # Calculate the number of valid triples\n    count = 0\n    for a in range(1, lcm_ab + 1):\n        for b in range(1, lcm_ab + 1):\n            if lcm(a, b) == lcm_ab:\n                for c in range(1, lcm_bc + 1):\n                    if lcm(b, c) == lcm_bc and lcm(c, a) == lcm_ca:\n                        count += 1\n    return count", "subfield": "Least Common Multiple", "tool_name": "count_ordered_triples", "tool_type": "function", "description": "Count the number of ordered triples (a, b, c) of positive integers\n    such that the least common multiples satisfy the conditions:\n    [a, b] = lcm_ab, [b, c] = lcm_bc, and [c, a] = lcm_ca.", "docstring": "Count the number of ordered triples (a, b, c) of positive integers\n    such that the least common multiples satisfy the conditions:\n    [a, b] = lcm_ab, [b, c] = lcm_bc, and [c, a] = lcm_ca.\n    \n    Parameters:\n    lcm_ab (int): The least common multiple of a and b.\n    lcm_bc (int): The least common multiple of b and c.\n    lcm_ca (int): The least common multiple of c and a.\n    \n    Returns:\n    int: The number of ordered triples (a, b, c) that satisfy the conditions.", "Freq": 1, "TSR": 1}], "Integers": [{"tool": "def find_factors(n):\n    \n    factors = []\n    for i in range(1, int(n ** 0.5) + 1):\n        if n % i == 0:\n            factors.append(i)\n            if i != n // i:\n                factors.append(n // i)\n    factors.sort()\n    return factors", "subfield": "Integers", "tool_name": "find_factors", "tool_type": "function", "description": "Finds all factors of the given integer.", "docstring": "Finds all factors of the given integer.\n    Parameters:\n    n (int): The integer to find factors of.\n    Returns:\n    list: A list containing all the factors of n.\n    Examples:\n    >>> find_factors(36)\n    [1, 2, 3, 4, 6, 9, 12, 18, 36]\n    >>> find_factors(101)\n    [1, 101]", "Freq": 0, "TSR": 0}, {"tool": "def gcd_multiple(numbers: List[int]) -> int:\n    \n    from functools import reduce\n    return reduce(math.gcd, numbers)", "subfield": "Integers", "tool_name": "gcd_multiple", "tool_type": "function", "description": "Compute the greatest common divisor of a list of integers.", "docstring": "Compute the greatest common divisor of a list of integers.\n    \n    Parameters:\n    - numbers (List[int]): A list of integers to find the GCD.\n    \n    Returns:\n    int: The greatest common divisor of the provided numbers.\n    \n    Example:\n    >>> gcd_multiple([8, 12, 16])\n    4", "Freq": 0, "TSR": 0}, {"tool": "def multiples(n, limit):\n    \n    return [i * n for i in range(1, limit // n + 1)]", "subfield": "Integers", "tool_name": "multiples", "tool_type": "function", "description": "Find all multiples of the given integer up to a specified limit.", "docstring": "Find all multiples of the given integer up to a specified limit.\n    Parameters:\n    n (int): Integer to find multiples of.\n    limit (int): Upper limit to search for multiples.\n    Returns:\n    list: List of multiples of n up to limit.\n    Examples:\n    >>> multiples(3, 10)\n    [3, 6, 9]", "Freq": 0, "TSR": 0}, {"tool": "def unique_mode(integers):\n    \n    counts = Counter(integers)\n    if len(set(counts.values())) == 1:  # check for tie in frequency\n        return None\n    mode = max(counts, key=counts.get)\n    return (mode, counts[mode])", "subfield": "Integers", "tool_name": "unique_mode", "tool_type": "function", "description": "Finds the mode of a list of integers that appears most frequently.", "docstring": "Finds the mode of a list of integers that appears most frequently.\n    Parameters:\n    integers (list): List of integers.\n    Returns:\n    tuple: mode of the list and its frequency, or None if no unique mode exists.\n    Examples:\n    >>> unique_mode([1, 2, 2, 3, 4])\n    (2, 2)\n    >>> unique_message([1, 1, 2, 2, 3, 3])\n    None", "Freq": 0, "TSR": 0}, {"tool": "def integer_solutions(poly, domain_range):\n    \n    return [(x, poly(x)) for x in domain_range if isinstance(poly(x), int)]", "subfield": "Integers", "tool_name": "integer_solutions", "tool_type": "function", "description": "Identify integer solutions for a polynomial within a specified domain.", "docstring": "Identify integer solutions for a polynomial within a specified domain.\n    Parameters:\n    poly (function): Polynomial function.\n    domain_range (range): Range of domain to check for integer solutions.\n    Returns:\n    list: List of tuples where each tuple contains (x, y) such that poly(x) == y and y is an integer.\n    Examples:\n    >>> poly = lambda x: x**2 - 4*x + 6\n    >>> integer_solutions(poly, range(-10, 10))\n    [(-8, 70), (-7, 56), (-6, 44), ..., (6, 6), (7, 8), (8, 14), (9, 22)]", "Freq": 1, "TSR": 0}, {"tool": "def is_coprime(a, b):\n    \n    return gcd(a, b) == 1", "subfield": "Integers", "tool_name": "is_coprime", "tool_type": "function", "description": "Determine if two integers are coprime (i.e., their GCD is 1).", "docstring": "Determine if two integers are coprime (i.e., their GCD is 1).\n    Parameters:\n    a (int): The first integer.\n    b (int): The second integer.\n    Returns:\n    bool: True if a and b are coprime, else False.\n    Examples:\n    >>> is_coprime(15, 28)\n    True\n    >>> is_coprime(12, 18)\n    False", "Freq": 0, "TSR": 0}, {"tool": "def is_divisible(numerator: int, denominator: int) -> bool:\n    \n    if denominator == 0:\n        raise ValueError(\"Denominator cannot be zero.\")\n    return numerator % denominator == 0", "subfield": "Integers", "tool_name": "is_divisible", "tool_type": "function", "description": "Check if the numerator is divisible by the denominator.", "docstring": "Check if the numerator is divisible by the denominator.\n    \n    Parameters:\n    - numerator (int): The number to be divided.\n    - denominator (int): The number to divide by.\n    \n    Returns:\n    bool: True if numerator is divisible by denominator, else False.\n    \n    Example:\n    >>> is_divisible(15, 5)\n    True\n    >>> is_divisible(14, 5)\n    False", "Freq": 0, "TSR": 0}], "Units Digit": [{"tool": "def powered_units_digit(base, exponent):\n    \n    # As digits patterns repeat every 4 in most cases\n    return (base ** exponent) % 10", "subfield": "Units Digit", "tool_name": "powered_units_digit", "tool_type": "function", "description": "Calculate the units digit of a number raised to a power.", "docstring": "Calculate the units digit of a number raised to a power.\n    Parameters:\n    - base (int): The base of the exponentiation.\n    - exponent (int): The exponent to raise the base.\n    Returns:\n    - int: Units digit of the result of the exponentiation.\n    Examples:\n    >>> powered_units_digit(2, 10)\n    4\n    >>> powered_units_item(7, 3)\n    3", "Freq": 5, "TSR": 4, "experience_pool": "Incorrect base values were used in the function calls, leading to incorrect results. It is important to provide the correct base values when using the powered_units_digit function."}, {"tool": "def units_digit(n):\n    \n    return abs(n) % 10", "subfield": "Units Digit", "tool_name": "units_digit", "tool_type": "function", "description": "Calculate the units digit of an integer n.", "docstring": "Calculate the units digit of an integer n.\n    \n    Parameters:\n    n (int): The integer for which the units digit is to be found.\n    Returns:\n    int: Units digit of the provided integer.\n    \n    Examples:\n    >>> units_digit(123)\n    3\n    >>> units_digit(-789)\n    9", "Freq": 1, "TSR": 1}, {"tool": "def units_digit_of_product(*args):\n    \n    product = 1\n    for number in args:\n        # Only multiply units digits to keep computations smaller\n        product = (product * (number % 10)) % 10\n    return product", "subfield": "Units Digit", "tool_name": "units_digit_of_product", "tool_type": "function", "description": "Compute the units digit of a product of multiple integers.\n    \n    This function can also be used to compute the units digit of exponentiations \n    by repeating the base in the argument list the number of times equal to the exponent.", "docstring": "Compute the units digit of a product of multiple integers.\n    \n    This function can also be used to compute the units digit of exponentiations \n    by repeating the base in the argument list the number of times equal to the exponent.\n    Parameters\n    ----------\n    *args : int\n        A variable number of integers whose product's units digit is to be calculated.\n    Returns\n    -------\n    int\n        The units digit of the product of the given integers.\n    Examples\n    --------\n    >>> units_digit_of_product(2, 5)\n    0\n    >>> units_digit_of_product(3, 4, 2)\n    4\n    >>> units_digit_of_product(9, 9)  # This can represent 9^2\n    1", "Freq": 6, "TSR": 4, "experience_pool": "- When using the units_digit_of_product function, make sure to pass only integers as arguments and not include any divisor like 1000 in the calculation.\n- The units_digit_of_product function is specifically designed to calculate the units digit of a product of integers, so ensure that the input values are appropriate for this operation."}, {"tool": "def units_digit_of_sum(*args):\n    \n    \n    def units_digit(n):\n        \n        return abs(n) % 10\n    total_sum = sum(args)\n    return units_digit(total_sum)", "subfield": "Units Digit", "tool_name": "units_digit_of_sum", "tool_type": "function", "description": "Calculate the units digit of the sum of multiple integers.\n    This function takes any number of integer arguments and computes the units digit \n    of their sum. It utilizes the properties of modular arithmetic to keep the \n    calculations efficient.", "docstring": "Calculate the units digit of the sum of multiple integers.\n    This function takes any number of integer arguments and computes the units digit \n    of their sum. It utilizes the properties of modular arithmetic to keep the \n    calculations efficient.\n    Parameters:\n    *args: integers\n        The integers for which the units digit of the sum is to be calculated.\n    Returns:\n    int\n        The units digit of the sum of the provided integers.", "Freq": 1, "TSR": 1}], "Prime Factorization": [{"tool": "def prime_factorization(n):\n    \n    if n < 1:\n        raise ValueError(\"n must be a positive integer\")\n    return sympy.factorint(n)", "subfield": "Prime Factorization", "tool_name": "prime_factorization", "tool_type": "function", "description": "Computes the prime factorization of the given integer `n`.", "docstring": "Computes the prime factorization of the given integer `n`.\n    Parameters:\n    ------------\n    n : int\n        The number to be factorized into primes.\n    \n    Returns:\n    ------------\n    dict\n        A dictionary where keys are the prime factors and values are their respective exponents in the factorization.\n    Examples:\n    ------------\n    >>> prime_factorization(18)\n    {2: 1, 3: 2}\n    \n    >>> prime_factorization(100)\n    {2: 2, 5: 2}", "Freq": 10, "TSR": 5, "experience_pool": "- When using the prime_factorization tool, ensure that the input parameter is a positive integer to avoid errors.\n- Check the logic of the solution code that calls the prime_factorization tool to ensure correct handling of the prime factors.\n- Verify the calculations and conditions in the solution code that utilizes the prime_factorization tool to avoid incorrect outputs."}, {"tool": "def number_theory_tools(numbers):\n    \n    import sympy\n    from functools import reduce\n    from math import gcd\n    def prime_factorization(n):\n        \n        if n < 1:\n            raise ValueError(\"n must be a positive integer\")\n        return sympy.factorint(n)\n    def compute_gcd(numbers):\n        \n        return reduce(gcd, numbers)\n    def compute_lcm(numbers):\n        \n        lcm = numbers[0]\n        for num in numbers[1:]:\n            lcm = lcm * num // gcd(lcm, num)\n        return lcm\n    if not all(isinstance(num, int) and num > 0 for num in numbers):\n        raise ValueError(\"All numbers must be positive integers\")\n    results = {\n        \"prime_factorizations\": {num: prime_factorization(num) for num in numbers},\n        \"gcd\": compute_gcd(numbers),\n        \"lcm\": compute_lcm(numbers)\n    }\n    return results", "subfield": "Prime Factorization", "tool_name": "number_theory_tools", "tool_type": "function", "description": "A collection of number theory tools that computes the prime factorization,\n    greatest common divisor (GCD), and least common multiple (LCM) of a list of integers.", "docstring": "A collection of number theory tools that computes the prime factorization,\n    greatest common divisor (GCD), and least common multiple (LCM) of a list of integers.\n    Parameters:\n    numbers (list of int): A list of positive integers.\n    Returns:\n    dict: A dictionary containing the prime factorization, GCD, and LCM of the input numbers.", "Freq": 0, "TSR": 0}], "Least Common Multiple (LCM)": [{"tool": "def lcm_multiple_numbers(numbers):\n    \n    if not numbers:\n        return 0\n    return reduce(lcm_two_numbers, numbers)", "subfield": "Least Common Multiple (LCM)", "tool_name": "lcm_multiple_numbers", "tool_type": "function", "description": "Calculate the Least Common Multiple (LCM) for a list of integers.", "docstring": "Calculate the Least Common Multiple (LCM) for a list of integers.\n    Parameters:\n    numbers (list): A list of integers.\n    Returns:\n    int: The least common multiple of the supplied list of integers.\n    Examples:\n    >>> lcm_multiple_numbers([4, 6, 8])\n    24\n    >>> lcm_multiple_numbers([5, 10, 20])\n    20", "Freq": 3, "TSR": 3}, {"tool": "def lcm_two_numbers(a, b):\n    \n    if a == 0 or b == 0:\n        return 0\n    return abs(a * b) // math.gcd(a, b)", "subfield": "Least Common Multiple (LCM)", "tool_name": "lcm_two_numbers", "tool_type": "function", "description": "Calculate the Least Common Multiple (LCM) of two integers.", "docstring": "Calculate the Least Common Multiple (LCM) of two integers.\n    Parameters:\n    a (int): First number.\n    b (int): Second number.\n    Returns:\n    int: The least common multiple of a and b.\n    Examples:\n    >>> lcm_two_numbers(4, 6)\n    12\n    >>> lcm_two_numbers(15, 17)\n    255", "Freq": 6, "TSR": 6}, {"tool": "def prime_factorization(n):\n    \n    from sympy import primefactors, multiplicity\n    \n    factors = {}\n    for prime in primefactors(n):\n        factors[prime] = multiplicity(prime, n)\n    return factors", "subfield": "Least Common Multiple (LCM)", "tool_name": "prime_factorization", "tool_type": "function", "description": "Compute the prime factorization of a given number.", "docstring": "Compute the prime factorization of a given number.\n    Parameters:\n    - n (int): The number to factorize.\n    Returns:\n    - dict: A dictionary where the keys are prime factors and values are their corresponding exponents.\n    Example:\n    >>> prime_factorization(360)\n    {2: 3, 3: 2, 5: 1}", "Freq": 0, "TSR": 0}, {"tool": "def possible_values_n_from_lcm_gcd_conditions(n_conditions):\n    \n    pass", "subfield": "Least Common Multiple (LCM)", "tool_name": "possible_values_n_from_lcm_gcd_conditions", "tool_type": "function", "description": "Evaluate possible integer values for n based on a series of LCM and GCD conditions.", "docstring": "Evaluate possible integer values for n based on a series of LCM and GCD conditions.\n    \n    Parameters:\n        n_conditions (dict): Dictionary specifying the conditions with \"lcm_facts\" and \"gcd_facts\" as keys.\n                             Each key maps to a list of tuples, where each tuple in \"lcm_facts\" or \"gcd_facts\"\n                             is of the form (a, b, value) indicating LCM(a, b) == value or GCD(a, b) == value.\n    \n    Returns:\n        list: List of integers that meet all the given LCM and GCD conditions.\n    \n    Examples:\n        >>> n_conditions = {\n            \"lcm_facts\": [(6, 8, 24), (5, 7, 35)],\n            \"gcd_facts\": [(4, 10, 2)]\n        }\n        >>> possible_values_n_from_lcm_gcd_conditions(n_conditions)\n        [6, 8, 5, 7, 4, 10]  # Example output and might change depending on actual implementation logic", "Freq": 0, "TSR": 0}]}