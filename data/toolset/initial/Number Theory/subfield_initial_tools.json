{"Properties of Integers": ["def is_prime(n):\n    \"\"\"\n    Determine if the input integer is a prime number.\n    Parameters:\n        n (int): The integer to check for primality.\n    Returns:\n        bool: True if n is prime, otherwise False.\n    \n    Examples:\n    >>> is_prime(29)\n    True\n    \"\"\"\n    return isprime(n)", "def prime_factors(n):\n    \"\"\"\n    Returns the list of prime factors of a given positive integer n.\n    Parameters:\n    - n (int): Positive integer to factorize.\n    \n    Returns:\n    - list: Prime factors of integer n.\n    Examples:\n    >>> prime_factors(18)\n    [2, 3, 3]\n    >>> prime_factors(17)\n    [17]\n    \"\"\"\n    i = 2\n    factors = []\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n            factors.append(i)\n    if n > 1:\n        factors.append(n)\n    return factors", "def modular_inverse(a, n):\n    \"\"\"\n    Find the modular inverse of a under modulo n if it exists. The inverse exists if and only if a and n are relatively prime.\n    \n    Parameters:\n    - a: int, the number to find an inverse for.\n    - n: int, the modulo.\n    \n    Returns:\n    - int, the modular inverse of a mod n if it exists, otherwise raises an exception.\n    \n    Example:\n    >>> modular_inverse(3, 11)\n    4\n    \"\"\"\n    if is_relatively_prime(a, n):\n        for x in range(1, n):\n            if (a * x) % n == 1:\n                return x\n    raise ValueError(f\"No modular inverse exists for {a} under modulo {n}, since they are not relatively prime.\")", "def is_divisible(n, divisor):\n    \"\"\"\n    Checks if the first number is divisible by the second number.\n    Parameters:\n    - n (int): Number to be checked.\n    - divisor (int): Divisor.\n    Returns:\n    bool: True if n is divisible by divisor, else False.\n    Example:\n    >>> is_divisible(10, 2)\n    True\n    >>> is_divisible(10, 3)\n    False\n    \"\"\"\n    return n % divisor == 0", "def integer_squares(n):\n    \"\"\"\n    Check if a number is a perfect square.\n    Parameters:\n    - n (int): The integer to check.\n    \n    Returns:\n    - bool: True if n is a perfect square, False otherwise.\n    \n    Examples:\n    >>> integer_squares(16)\n    True\n    >>> integer_squares(14)\n    False\n    \"\"\"\n    root = int(n**0.5)\n    return root * root == n", "def is_coprime(a, b):\n    \"\"\"\n    Checks if two numbers a and b are coprime (gcd is 1).\n    Parameters:\n    - a (int): First number.\n    - b (int): Second number.\n    Returns:\n    - bool: True if gcd(a, b) == 1, otherwise False.\n    Examples:\n    >>> is_coprime(14, 15)\n    True\n    >>> is_coprime(14, 21)\n    False\n    \"\"\"\n    return gcd(a, b) == 1", "def find_divisors(n):\n    \"\"\"\n    Find all divisors of a given integer n.\n    Parameters:\n    n (int): The integer to find divisors of.\n    Returns:\n    list of int: List of all divisors of n.\n    Example:\n    >>> find_divisors(28)\n    [1, 2, 4, 7, 14, 28]\n    \"\"\"\n    divisors = []\n    for i in range(1, int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            divisors.append(i)\n            if i != n // i:\n                divisors.append(n // i)\n    divisors.sort()\n    return divisors", "def count_divisors(n):\n    \"\"\"\n    Count the divisors of an integer n.\n    :param n: The integer to count divisors for.\n    :return: The count of divisors of n.\n    \n    Examples:\n    >>> count_divisors(36)\n    9\n    >>> count_divisors(37)\n    2\n    \"\"\"\n    total = 0\n    root = int(math.sqrt(n))\n    for i in range(1, root + 1):\n        if n % i == 0:\n            total += 1 + (i != n // i)\n    return total", "def mod_multiply(a, b, n):\n    \"\"\"\n    Perform modular multiplication.\n    Parameters:\n    a (int): First factor.\n    b (int): Second factor.\n    n (int): Modulus.\n    Returns:\n    int: Result of (a * b) % n.\n    Examples:\n    >>> mod_multiply(3, 4, 5)\n    2\n    \"\"\"\n    return (a * b) % n", "def nth_root(n, r):\n    \"\"\"\n    Computes the nth root of a number n.\n    Parameters:\n    - n (int): The number to find the root of.\n    - r (int): The root degree.\n    Returns:\n    - float: The nth root of n.\n    Examples:\n    >>> nth_root(16, 2)\n    4.0\n    >>> nth_root(27, 3)\n    3.0\n    \"\"\"\n    return n ** (1/r)", "def is_even(number):\n    \"\"\"\n    Determine if a number is even.\n    Parameters:\n    - number (int): The number to check.\n    Returns:\n    - bool: True if the number is even, otherwise False.\n    Examples:\n    >>> is_even(4)\n    True\n    >>> is_even(5)\n    False\n    \"\"\"\n    return number % 2 == 0", "def is_odd(number):\n    \"\"\"\n    Determine if a number is odd.\n    Parameters:\n    - number (int): The number to check.\n    Returns:\n    - bool: True if the number is odd, otherwise False.\n    Examples:\n    >>> is_odd(3)\n    True\n    >>> is_odd(10)\n    False\n    \"\"\"\n    return number % 2 != 0", "def count_perfect_squares(start, end):\n    \"\"\"Count the number of perfect squares in a given range [start, end].\n    \n    Parameters:\n    start (int): The start of the range (inclusive).\n    end (int): The end of the range (inclusive).\n    Returns:\n    int: The count of perfect squares in the range.\n    Examples:\n    >>> count_perfect_squares(1, 100)\n    10\n    \"\"\"\n    import math\n    return math.isqrt(end) - math.isqrt(start - 1)", "def absolute_value(n):\n    \"\"\"\n    Calculate the absolute value of an integer.\n    Parameters:\n    - n (int): The integer.\n    \n    Returns:\n    - int: The absolute value of n.\n    \n    Examples:\n    >>> absolute_value(-5)\n    5\n    >>> absolute_endcode_point(3)\n    3\n    \"\"\"\n    return abs(n)", "def check_divisibility(n, div):\n    \"\"\"\n    Determines if n is divisible by div.\n    Parameters:\n    - n (int): The number to be checked.\n    - div (int): The divisor.\n    Returns:\n    - bool: True if n is divisible by div, False otherwise.\n    \"\"\"\n    return n % div == 0", "def modular_add(a, b, mod):\n    \"\"\"\n    Perform modular addition.\n    \n    Parameters:\n        a (int): The first operand.\n        b (int): The second operand.\n        mod (int): The modulus.\n    Returns:\n        int: The result of (a + b) % mod.\n    Examples:\n        >>> modular_add(3, 4, 5)\n        2\n    \"\"\"\n    return (a + b) % mod", "def mod_subtract(a, b, n):\n    \"\"\"\n    Perform modular subtraction.\n    Parameters:\n    a (int): Minuend.\n    b (int): Subtrahend.\n    n (int): Modulus.\n    Returns:\n    int: Result of (a - b) % n.\n    Examples:\n    >>> mod_subtract(5, 3, 7)\n    2\n    \"\"\"\n    return (a - b) % n", "def mod_exponent(base, exponent, modulus):\n    \"\"\"\n    Computes (base^exponent) % modulus using efficient exponentiation.\n    Parameters:\n    base (int): Base of the exponentiation.\n    exponent (int): Exponent.\n    modulus (int): Modulus.\n    Returns:\n    int: Result of (base^exponent) % modulus.\n    Examples:\n    >>> mod_exponent(2, 10, 1000)\n    24\n    \"\"\"\n    return pow(base, exponent, modulus)", "def gcd_lcm_calculator(a, b):\n    \"\"\"\n    Calculate the Greatest Common Divisor (GCD) and Least Common Multiple (LCM)\n    of two integers using Euclid's algorithm for GCD and the relation LCM * GCD = a * b.\n    Parameters:\n    - a (int): First integer\n    - b (int): Second integer\n    \n    Returns:\n    - tuple: (gcd, lcm) of the integers a and b\n    Examples:\n    >>> gcd_lcm_calculator(12, 15)\n    (3, 60)\n    >>> gcd_lcm_calculator(100, 80)\n    (20, 400)\n    \"\"\"\n    from math import gcd\n    \n    gcd_value = gcd(a, b)\n    lcm_value = abs(a * b) // gcd_value\n    \n    return gcd_value, lcm_value", "def is_divisible(n, k):\n    \"\"\"\n    Check if integer n is divisible by integer k.\n    Parameters:\n        n (int): The number to be divided.\n        k (int): The divisor.\n    Returns:\n        bool: True if n is divisible by k, False otherwise.\n    Examples:\n        >>> is_divisible(10, 5)\n        True\n        >>> is_divisible(10, 3)\n        False\n    \"\"\"\n    return n % k == 0", "def list_primes(a, b):\n    \"\"\"\n    Lists all primes in the range [a, b)\n    Parameters:\n    - a (int): Start of the range (inclusive).\n    - b (int): End of the range (exclusive).\n    Returns:\n    - list: List of prime numbers between a and b.\n    Examples:\n    >>> list_primes(10, 20)\n    [11, 13, 17, 19]\n    \"\"\"\n    return list(primerange(a, b))", "def integer_sign(n):\n    \"\"\"\n    Determine the sign of an integer.\n    Parameters:\n        n (int): The integer to check.\n    Returns:\n        int: -1 if negative, 1 if positive, 0 if zero.\n    Examples:\n        >>> integer_sign(-20)\n        -1\n        >>> integer_sign(15)\n        1\n    \"\"\"\n    if n < 0:\n        return -1\n    elif n > 0:\n        return 1\n    else:\n        return 0", "def product_of_integers(numbers):\n    \"\"\"\n    Compute the product of a sequence of integers.\n    Parameters:\n         numbers (list): A list of integers.\n    Returns:\n        int: The product of the integers in the list.\n    Examples:\n        >>> product_of_integers([1, 2, 3])\n        6\n    \"\"\"\n    product = 1\n    for num in numbers:\n        product *= num\n    return product", "def consecutive_primes(n):\n    \"\"\"\n    Generate a list of the first n prime numbers.\n    Parameters:\n        n (int): The number of primes to generate.\n    Returns:\n        list: A list of the first n primes.\n    Examples:\n        >>> consecutive_primes(5)\n        [2, 3, 5, 7, 11]\n    \"\"\"\n    return list(sympy.primerange(1, sympy.prime(n)+1))", "def count_factors(n):\n    \"\"\"\n    Count the number of factors of an integer.\n    Parameters:\n    - n (int): The integer to count factors for.\n    \n    Returns:\n    - int: Number of factors of n.\n    \n    Examples:\n    >>> count_factors(12)\n    6\n    \"\"\"\n    if n <= 0:\n        raise ValueError(\"n must be a positive integer\")\n    factors = sympy.divisors(n)\n    return len(factors)", "def calculate_lcm(numbers):\n    \"\"\"\n    Calculate least common multiple of a list of numbers.\n    Parameters:\n    - numbers : list of int\n        The list of integers for which to calculate the LCM.\n    \n    Returns:\n    - int\n        The least common multiple of the numbers.\n    \n    Examples:\n    >>> calculate_lcm([12, 15, 20])\n    60\n    \"\"\"\n    return int(np.lcm.reduce(numbers))", "def integer_close_to_sqrt(n):\n    \"\"\"\n    Finds the closest integer to the square root of n.\n    Parameters:\n    - n (int): The number to find the square root of.\n    Returns:\n    - int: The integer closest to the square root of n.\n    Examples:\n    >>> integer_close_to_sqrt(10)\n    3\n    >>> integer_close_to_sqrt(15)\n    4\n    \"\"\"\n    return round(math.sqrt(n))", "def gcd(a, b):\n    \"\"\"\n    Compute the greatest common divisor of two integers.\n    \n    Parameters:\n    - a (int): First integer.\n    - b (int): Second integer.\n    Returns:\n    int: The greatest common divisor of a and b.\n    \n    Examples:\n    >>> gcd(12, 15)\n    3\n    >>> gcd(3, 7)\n    1\n    \"\"\"\n    from math import gcd as compute_gcd\n    return compute_gcd(a, b)", "def solve_diophantine(a, b, c):\n    \"\"\"\n    Solve the linear Diophantine equation a*x + b*y = c for integers x and y.\n    Returns a single solution (x, y) if it exists.\n    Parameters:\n        a (int): Coefficient of x.\n        b (int): Coefficient of y.\n        c (int): Constant term.\n    Returns:\n        tuple: a tuple (x, y) representing a solution, if it exists.\n        None: if no integer solution exists.\n    Examples:\n        >>> solve_diophanine(3, -9, 12)\n        None\n        >>> solve_diophanine(2, 3, 5)\n        (1, 1)\n    \"\"\"\n    from math import gcd\n    if c % gcd(a, b) != 0:\n        return None\n    x, y = 0, c // b\n    while True:\n        if (c - b * y) % a == 0:\n            x = (c - b * y) // a\n            return (x, y)\n        y -= 1", "def arithmetic_sequence_sum(a, d, n):\n    \"\"\"\n    Calculate the sum of the first n terms of an arithmetic sequence.\n    Parameters:\n        a (int): The first term of the sequence.\n        d (int): The common difference between consecutive terms.\n        n (int): The number of terms.\n    Returns:\n        int: The sum of the first n terms of the sequence.\n    Examples:\n        >>> arithmetic_sequence_sum(1, 1, 5)\n        15\n    \"\"\"\n    return n * (2 * a + (n - 1) * d) // 2", "def lcm(x, y):\n    \"\"\"\n    Compute the least common multiple (LCM) of two numbers based on their GCD.\n    \n    Parameters:\n    - x: int, the first number.\n    - y: int, the second number.\n    \n    Returns:\n    - int, the LCM of the two numbers.\n    \n    Example:\n    >>> lcm(4, 5)\n    20\n    \"\"\"\n    return abs(x*y) // gcd(x, y)", "def reverse_digits(n):\n    \"\"\"\n    Reverse the digits of an integer.\n    \n    Parameters:\n        n (int): The integer to be reversed.\n    \n    Returns:\n        int: The integer formed by reversing the digits of `n`.\n    \n    Example:\n        >>> reverse_digits(123)\n        321\n    \"\"\"\n    return int(str(n)[::-1]) if n >= 0 else -int(str(-n)[::-1])", "def arithmetic_modulo_n(a, b, mod, operation='add'):\n    \"\"\"\n    Perform arithmetic operations on two integers modulo `n`.\n    Parameters:\n    a : int\n        The first operand.\n    b : int\n        The second operand.\n    mod : int\n        The modulo value.\n    operation : str\n        The operation to perform ('add', 'subtract', 'multiply').\n    Returns:\n    int\n        The result of the operation performed modulo `n`.\n    Examples:\n    >>> arithmetic_modulo_n(3, 5, 6, 'add')\n    2\n    >>> arithmetic_modulo_n(4, 3, 5, 'multiply')\n    2\n    \"\"\"\n    operations = {\n        'add': (a + b) % mod,\n        'subtract': (a - b) % mod,\n        'multiply': (a * b) % mod\n    }\n    return operations.get(operation, None)", "def integer_base_conversion_and_divisibility():\n    \"\"\"\n    A collection of utility functions for base conversion and checking divisibility rules.\n    Includes functions for converting numbers between different bases, checking divisibility,\n    and analyzing repeating decimals.\n    \"\"\"\n    from sympy import isprime\n    import math\n    def convert_base(n, from_base, to_base):\n        \"\"\"\n        Converts a number from one base to another.\n        \n        Parameters\n        ----------\n        n : int or str\n            The number to convert. If not in base 10, provide as string.\n        from_base : int\n            The base of the input number.\n        to_base : int\n            The base to convert to.\n        \n        Returns\n        -------\n        str\n            The number in the target base as a string.\n        \n        Examples\n        --------\n        >>> convert_base('1010', 2, 10)\n        '10'\n        >>> convert_base('A', 16, 2)\n        '1010'\n        \"\"\"\n        if from_base != 10:\n            n = int(n, from_base)\n        if to_base == 10:\n            return str(n)\n        else:\n            digits = \"0123456789ABCDEF\"\n            result = \"\"\n            while n > 0:\n                result = digits[n % to_base] + result\n                n //= to_base\n            return result or \"0\"\n    def is_divisible(n, divisor):\n        \"\"\"\n        Checks if a number is divisible by another number.\n        \n        Parameters\n        ----------\n        n : int\n            The number to check.\n        divisor : int\n            The divisor to check against.\n        \n        Returns\n        -------\n        bool\n            True if n is divisible by divisor, False otherwise.\n        \n        Examples\n        --------\n        >>> is_divisible(10, 2)\n        True\n        >>> is_divisible(10, 3)\n        False\n        \"\"\"\n        return n % divisor == 0\n    \n    def repeating_decimal_period(n):\n        \"\"\"\n        Calculates the period of the repeating decimal for 1/n.\n        \n        Parameters\n        ----------\n        n : int\n            The integer to calculate the repeating decimal period for.\n        \n        Returns\n        -------\n        int\n            The period of the repeating decimal.\n        \n        Examples\n        --------\n        >>> repeating_decimal_period(3)\n        1\n        >>> repeating_decimal_period(7)\n        6\n        \"\"\"\n        remainders = {}\n        remainder = 1\n        position = 0\n        while remainder and remainder not in remainders:\n            remainders[remainder] = position\n            remainder = (remainder * 10) % n\n            position += 1\n        return 0 if not remainder else position - remainders[remainder]\n    base_utils = {\n        'convert_base': convert_base,\n        'is_divisible': is_divisible,\n        'repeating_decimal_period': repeating_decimal_period\n    }\n    return base_utils", "def basic_modular_operations(a, b, m, operation):\n    \"\"\"\n    Performs basic modular arithmetic operations between two numbers.\n    Parameters:\n    - a (int): The first number.\n    - b (int): The second number.\n    - m (int): The modulus.\n    - operation (str): The operation to perform ('add', 'subtract', 'multiply').\n    Returns:\n    - int: The result of the operation under modulo m.\n    \"\"\"\n    if operation == 'add':\n        return (a + b) % m\n    elif operation == 'subtract':\n        return (a - b) % m\n    elif operation == 'multiply':\n        return (a * b) % m\n    else:\n        raise ValueError(\"Unsupported operation\")", "def gcd(x, y):\n    \"\"\"\n    Compute the greatest common divisor (GCD) of two numbers using the Euclidean algorithm.\n    \n    Parameters:\n    - x: int, the first number.\n    - y: int, the second number.\n    \n    Returns:\n    - int, the GCD of x and y.\n    \n    Example:\n    >>> gcd(48, 18)\n    6\n    \"\"\"\n    while y:\n        x, y = y, x % y\n    return x", "def count_fourth_powers(a, b):\n    \"\"\"\n    Count the number of fourth powers in the range [a, b].\n    x is considered a fourth power if x = n^4 for some integer n.\n    \n    Parameters:\n        a (int): Start of the range.\n        b (int): End of the range.\n        \n    Returns:\n        int: Count of fourth powers in the given range.\n        \n    Examples:\n        >>> count_fourth_powers(1, 1000)\n        3\n        >>> count_fourth_powers(1, 10000)\n        4\n    \"\"\"\n    # Finding the floor of the fourth root of `a` and `b`.\n    low_n = int(math.pow(a, 0.25))\n    high_n = int(math.pow(b, 1/4))\n    \n    count = 0\n    for n in range(low_n, high_n + 1):\n        if n**4 >= a and n**4 <= b:\n            count += 1\n    return count", "def extended_gcd(a, b):\n    \"\"\"\n    Compute the extended greatest common divisor of a and b, and return the coefficients of Bezout's identity.\n    \n    Parameters:\n        a (int): First number.\n        b (int): Second number.\n    Returns:\n        (gcd, x, y) (tuple): gcd is the greatest common divisor of a and b.\n                             x and y are the coefficients of Bezout's identity, i.e., ax + by = gcd\n    Examples:\n        >>> extended_gcd(12, 15)\n        (3, -1, 1)\n    \"\"\"\n    if a == 0:\n        return (b, 0, 1)\n    else:\n        gcd, x1, y1 = extended_gcd(b % a, a)\n        x = y1 - (b // a) * x1\n        y = x1\n        return (gcd, x, y)", "def modulus_divisibility(num, base, mod):\n    \"\"\"\n    Checks divisibility of the number num with respect to a base after applying modulus operation.\n    Parameters:\n        num (int): The number to check.\n        base (int): The base for modulus operation.\n        mod (int): The modulus divisor.\n    Returns:\n        bool: True if the number's modulus in the given base is divisible by mod, else False.\n    Examples:\n        >>> modulus_divisibility(20, 10, 2)\n        True\n        >>> modulus_divisibility(21, 10, 2)\n        False\n    \"\"\"\n    return (num % base) % mod == 0", "def digit_sum(n):\n    \"\"\"\n    Calculate the sum of the digits of an integer.\n    \n    Parameters:\n        n (int): The integer whose digits will be summed.\n    \n    Returns:\n        int: The sum of the digits of `n`.\n    \n    Example:\n        >>> digit_sum(123)\n        6\n    \"\"\"\n    return sum(int(digit) for digit in str(abs(n)))", "def count_digits(n):\n    \"\"\"\n    Count the number of digits in an integer.\n    \n    Parameters:\n        n (int): The integer to count digits.\n    \n    Returns:\n        int: The number of digits in `n`.\n    \n    Example:\n        >>> count_digits(12345)\n        5\n    \"\"\"\n    return len(str(abs(n)))", "def count_even_odd_in_range(start, end):\n    \"\"\"\n    Count even and odd numbers within a given range [start, end).\n    Parameters:\n    - start (int): The starting integer value of the range (inclusive).\n    - end (int): The ending integer value of the range (exclusive).\n    Returns:\n    tuple: A tuple (count_even, count_odd) representing the number of even and odd numbers respectively.\n    \n    Examples:\n    >>> count_even_odd_in_range(1, 10)\n    (4, 5)\n    \"\"\"\n    count_even = len([num for num in range(start, end) if num % 2 == 0])\n    count_odd = (end - start) - count_even\n    return (count_even, count_odd)", "def is_perfect_power(n, power):\n    \"\"\"\n    Checks if a number is a perfect power of another integer.\n    Parameters:\n    - n (int): The number to check.\n    - power (int): The power to test.\n    Returns:\n    bool: True if n is a perfect power of 'power', else False.\n    Example:\n    >>> is_perfect_power(64, 2)\n    True\n    >>> is_perfect_power(65, 2)\n    False\n    \"\"\"\n    import sympy\n    root, perfect = sympy.ntheory.primetest.integer_nthroot(n, power)\n    return perfect", "def list_perfect_squares(limit):\n    \"\"\"\n    Lists all perfect squares up to a given limit.\n    :param limit: The upper limit (inclusive) for listing perfect squares.\n    :return: A list of all perfect squares up to 'limit'.\n    \n    Examples:\n    >>> list_perfect_squares(30)\n    [0, 1, 4, 9, 16, 25]\n    \"\"\"\n    return [i * i for i in range(int(math.sqrt(limit)) + 1)]", "def filter_divisible_numbers(start, end, divisor):\n    \"\"\"\n    Generates a list of numbers within the specified range that are divisible by the given divisor.\n    Parameters:\n    start : int\n        The starting value of the range (inclusive).\n    end : int\n        The ending value of the range (inclusive).\n    divisor : int\n        The divisor used for filtering numbers.\n    Returns:\n    list of int\n        List of integers within the specified range that are divisible by the divisor.\n    Examples:\n    >>> filter_divisible_numbers(1, 10, 2)\n    [2, 4, 6, 8, 10]\n    >>> filter_divisible_numbers(1, 10, 3)\n    [3, 6, 9]\n    \"\"\"\n    return [x for x in range(start, end + 1) if x % divisor == 0]", "def extended_euclidean_algorithm(a, b):\n    \"\"\"\n    Applies the Extended Euclidean Algorithm to find integers x, y such that ax + by = gcd(a, b).\n    Parameters:\n    - a (int): First integer\n    - b (int): Second integer\n    \n    Returns:\n    - tuple: gcd of a and b, and coefficients x, y such that ax + by = gcd(a, b)\n    Examples:\n    >>> extended_euclidean_algorithm(10, 6)\n    (2, 1, -1)\n    >>> extended_euclidean_algorithm(113, 57)\n    (1, 5, -10)\n    \"\"\"\n    if a == 0:\n        return (b, 0, 1)\n    else:\n        gcd, x1, y1 = extended_euclidean_algorithm(b % a, a)\n        x = y1 - (b // a) * x1\n        y = x1\n        return (gcd, x, y)", "def next_prime(n):\n    \"\"\"\n    Find the smallest prime number greater than n.\n    Parameters:\n    n (int): Starting number to find the next prime.\n    Returns:\n    int: The next prime number after n.\n    Example:\n    >>> next_prime(28)\n    29\n    \"\"\"\n    test_num = n + 1\n    while True:\n        if is_prime(test_num):\n            return test_num\n        test_num += 1", "def classify_integer(n):\n    \"\"\"\n    Classifies an integer as positive, negative, or zero.\n    Parameters:\n    - n (int): The integer to classify.\n    \n    Returns:\n    - str: \"positive\", \"negative\", or \"zero\" based on the value of n.\n    \n    Examples:\n    >>> classify_integer(10)\n    'positive'\n    >>> classify_integer(-5)\n    'negative'\n    >>> classify_integer(0)\n    'zero'\n    \"\"\"\n    if n > 0:\n        return \"positive\"\n    elif n < 0:\n        return \"negative\"\n    else:\n        return \"zero\"", "def is_relatively_prime(x, y):\n    \"\"\"\n    Check if two numbers are relatively prime.\n    \n    Parameters:\n    - x: int, the first number.\n    - y: int, the second number.\n    \n    Returns:\n    - bool, True if x and y are relatively prime, False otherwise.\n    \n    Example:\n    >>> is_relatively_prime(35, 18)\n    True\n    \"\"\"\n    return gcd(x, y) == 1", "def units_digit(number):\n    \"\"\"\n    Return the units digit of a number.\n    Parameters:\n    - number (int): The number to get the units digit from.\n    Returns:\n    - int: The units digit of the number.\n    Examples:\n    >>> units_digit(123)\n    3\n    >>> units_digit(-476)\n    6\n    \"\"\"\n    return abs(number) % 10", "def integer_digit_manipulation():\n    \"\"\"\n    A collection of utility functions for manipulating and analyzing digits of integers.\n    Includes functions like reversing digits, extracting specific digits, summing digits, \n    and checking if a number is a palindrome.\n    \"\"\"\n    import numpy as np\n    from sympy import isprime\n    def reverse_digits(n):\n        \"\"\"\n        Reverses the digits of an integer.\n        \n        Parameters\n        ----------\n        n : int\n            The integer whose digits are to be reversed.\n        \n        Returns\n        -------\n        int\n            The integer after reversing its digits.\n        \n        Examples\n        --------\n        >>> reverse_digits(1234)\n        4321\n        \"\"\"\n        return int(str(n)[::-1])\n    def sum_digits(n):\n        \"\"\"\n        Sums the digits of an integer.\n        \n        Parameters\n        ----------\n        n : int\n            The integer whose digits are to be summed.\n        \n        Returns\n        -------\n        int\n            The sum of the digits of the input integer.\n        \n        Examples\n        --------\n        >>> sum_digits(1234)\n        10\n        \"\"\"\n        return sum(map(int, str(n)))\n    \n    def is_palindrome(n):\n        \"\"\"\n        Checks if an integer is a palindrome.\n        \n        Parameters\n        ----------\n        n : int\n            The integer to check.\n        \n        Returns\n        -------\n        bool\n            True if the integer is a palindrome, False otherwise.\n        \n        Examples\n        --------\n        >>> is_palindrome(12321)\n        True\n        \"\"\"\n        s = str(n)\n        return s == s[::-1]\n    def get_digit(n, position):\n        \"\"\"\n        Gets a specific digit from an integer.\n        \n        Parameters\n        ----------\n        n : int\n            The integer from which the digit is to be extracted.\n        position : int\n            The position of the digit to extract (0-based, from right).\n        \n        Returns\n        -------\n        int\n            The digit at the specified position.\n        \n        Examples\n        --------\n        >>> get_digit(1234, 1)\n        3\n        \"\"\"\n        return int(str(n)[::-1][position])\n    \n    def count_digits(n):\n        \"\"\"\n        Counts the total number of digits in an integer.\n        \n        Parameters\n        ----------\n        n : int\n            The integer to check.\n        \n        Returns\n        -------\n        int\n            The number of digits in the integer.\n        \n        Examples\n        --------\n        >>> count_digits(1234)\n        4\n        \"\"\"\n        return len(str(n))\n    \n    def is_prime(n):\n        \"\"\"\n        Checks if an integer is a prime number.\n        \n        Parameters\n        ----------\n        n : int\n            The integer to check.\n        \n        Returns\n        -------\n        bool\n            True if the integer is a prime number, False otherwise.\n        \n        Examples\n        --------\n        >>> is_prime(7)\n        True\n        \"\"\"\n        return isprime(n)\n    \n    digit_utils = {\n        'reverse_digits': reverse_digits,\n        'sum_digits': sum_digits,\n        'is_palindrome': is_palindrome,\n        'get_digit': get_digit,\n        'count_digits': count_digits,\n        'is_prime': is_prime\n    }\n    return digit_utils", "def check_congruence(a, b, m):\n    \"\"\"\n    Checks if two numbers are congruent modulo another number.\n    :param a: The first integer.\n    :param b: The second integer.\n    :param m: The modulus.\n    :return: True if a ≡ b (mod m), False otherwise.\n    \n    Examples:\n    >>> check_congruence(37, 57, 10)\n    True\n    >>> check_congruence(35, 57, 10)\n    False\n    \"\"\"\n    return (a - b) % m == 0", "def is_whole_number(n):\n    \"\"\"\n    Check if a number is a whole number (non-negative integer).\n    Parameters:\n    - n (int/float): The number to check.\n    \n    Returns:\n    - bool: True if n is a whole number, False otherwise.\n    \n    Examples:\n    >>> is_whole_number(5)\n    True\n    >>> is_whole_number(-1)\n    False\n    >>> is_whole_number(3.5)\n    False\n    \"\"\"\n    return n == int(n) and n >= 0", "def extract_digits(num):\n    \"\"\"\n    Extracts and returns the digits of the given integer as a list.\n    Parameters:\n        num (int): The integer from which to extract the digits.\n    Returns:\n        list: Digits of the integer.\n    Examples:\n        >>> extract_digits(1234)\n        [1, 2, 3, 4]\n        >>> extract_digits(9075)\n        [9, 0, 7, 5]\n    \"\"\"\n    from math import floor, log10\n    if num == 0:\n        return [0]\n    digits = []\n    while num:\n        digits.append(num % 10)\n        num = num // 10\n    return digits[::-1]", "def is_divisible_by(n, d):\n    \"\"\"\n    Determine if integer n is divisible by d.\n    Parameters:\n    n (int): Numerator integer.\n    d (int): Denominator integer (must not be zero).\n    Returns:\n    bool: True if n is divisible by d, False otherwise.\n    Example:\n    >>> is_divisible_by(10, 2)\n    True\n    \"\"\"\n    if d == 0:\n        raise ValueError(\"Denominator must not be zero.\")\n    return n % d == 0", "def calculate_power(base, exponent):\n    \"\"\"\n    Compute the power of a base raised to an exponent.\n    Parameters:\n        base (float or int): The base number.\n        exponent (int): The power to raise the base to.\n    Returns:\n        float: The result of the exponentiation.\n    \n    Examples:\n    >>> calculate_power(2, 10)\n    1024\n    \"\"\"\n    return base ** exponent"], "Floor and Ceiling Functions": ["def floor_value(x):\n    \"\"\"\n    Computes the floor of a given number.\n    Parameters:\n        x (float or int): The number from which the floor will be calculated.\n    Returns:\n        int: The floor value of x.\n    Examples:\n        >>> floor_value(3.7)\n        3\n        >>> floor_value(-1.2)\n        -2\n    \"\"\"\n    return math.floor(x)", "def ceiling_value(x):\n    \"\"\"\n    Computes the ceiling of a given number.\n    Parameters:\n        x (float or int): The number from which the ceiling will be calculated.\n    Returns:\n        int: The ceiling value of x.\n    Examples:\n        >>> ceiling_value(3.7)\n        4\n        >>> ceiling_value(-1.2)\n        -1\n    \"\"\"\n    return math.ceil(x)", "def floor_ceil(value):\n    \"\"\"\n    Calculate the floor and ceiling of a given numerical value.\n    Parameters:\n    - value (float): The real number from which the floor and ceiling values are to be computed.\n    Returns:\n    - tuple: A tuple containing the floor value and the ceiling value respectively.\n    Examples:\n    >>> floor_ceil(3.7)\n    (3, 4)\n    >>> floor_ceil(-2.5)\n    (-3, -2)\n    \"\"\"\n    from math import floor, ceil\n    return (floor(value), ceil(value))", "def floor_ceiling_expression_evaluator(expression):\n    \"\"\"\n    Evaluate an expression involving floor or ceiling functions.\n    Parameters:\n    - expression (str): The string of the expression involving floor and ceiling operations.\n    Returns:\n    - float: The result of the evaluated expression.\n    Examples:\n    >>> floor_ceiling_expression_evaluator(\"math.floor(3.7) + math.ceil(-2.3)\")\n    1\n    >>> floor_ceiling_expression_evaluator(\"math.floor(math.sqrt(10)) * 2\")\n    6\n    \"\"\"\n    allowed_builtins = {\"math\": math}\n    result = eval(expression, {\"__builtins__\": None}, allowed_builtins)\n    return result", "def arithmetic_with_floor_ceil(a, b, operation):\n    \"\"\"\n    Perform arithmetic operations using floor and ceiling values of the provided numbers.\n    \n    Parameters:\n    - a (float): The first real number.\n    - b (float): The second real number.\n    - operation (str): The arithmetic operation to perform. Supported operations are 'add', 'subtract', 'multiply'.\n    Returns:\n    - int: The result of the arithmetic operation applied using the floor/ceil values of the given numbers.\n    Examples:\n    >>> arithmetic_with_floor_ceil(3.2, 5.8, 'add')\n    (floor(3.2) + ceil(5.8)) = 3 + 6 = 9\n    >>> arithmetic_with_floor_ceil(-2.5, 4.1, 'multiply')\n    (ceil(-2.5) * floor(4.1)) = -2 * 4 = -8\n    \"\"\"\n    from math import floor, ceil\n    methods = {\n        'add': lambda x, y: floor(x) + ceil(y),\n        'subtract': lambda x, y: ceil(x) - floor(y),\n        'multiply': lambda x, y: ceil(x) * floor(y)\n    }\n    if operation in methods:\n        return methods[operation](a, b)\n    else:\n        raise ValueError(\"Unsupported operation. Use 'add', 'subtract', or 'multiply'.\")", "def calculate_fractional_part(number):\n    \"\"\"\n    This function calculates and returns the fractional part of a given number.\n    \n    Parameters:\n    -----------\n    number : float\n        The number for which the fractional part is to be calculated.\n        \n    Returns:\n    --------\n    float :\n        The fractional part of the given number.\n        \n    Examples:\n    ---------\n    >>> calculate_fractional_part(4.2)\n    0.2\n    >>> calculate_fractional_part(-3.9)\n    0.1\n    \"\"\"\n    \n    return number - math.floor(number)", "def calculate_floor(number):\n    \"\"\"\n    This function calculates and returns the floor value of a given number.\n    \n    Parameters:\n    -----------\n    number : float\n        The number for which the floor value is to be calculated.\n        \n    Returns:\n    --------\n    float :\n        The floor value of the given number.\n        \n    Examples:\n    ---------\n    >>> calculate_floor(4.2)\n    4\n    >>> calculate_floor(-3.9)\n    -4\n    \"\"\"\n    \n    return math.floor(number)", "def calculate_ceiling(number):\n    \"\"\"\n    This function calculates and returns the ceiling value of a given number.\n    \n    Parameters:\n    -----------\n    number : float\n        The number for which the ceiling value is to be calculated.\n        \n    Returns:\n    --------\n    float :\n        The ceiling value of the given number.\n        \n    Examples:\n    ---------\n    >>> calculate_ceiling(4.2)\n    5\n    >>> calculate_ceiling(-3.9)\n    -3\n    \"\"\"\n    \n    return math.ceil(number)"], "Integer Properties": ["def is_prime(n):\n    \"\"\"\n    Check if an integer is a prime number.\n    Parameters:\n    n : int\n        The integer to check for primality.\n    Returns:\n    bool\n        True if n is a prime number, else False.\n    Examples:\n    >>> is_prime(29)\n    True\n    \"\"\"\n    return sympy.isprime(n)", "def is_even(n):\n    \"\"\"\n    Check if a number is even.\n    \n    Parameters:\n    n (int): The number to check.\n    \n    Returns:\n    bool: True if the number is even, False otherwise.\n    \n    Example:\n    >>> is_even(4)\n    True\n    >>> is_even(5)\n    False\n    \"\"\"\n    return n % 2 == 0", "def sum_of_digits(n):\n    \"\"\"\n    Calculate the sum of digits of a given integer.\n    Parameters:\n        n (int): The integer to calculate the sum of digits.\n    Returns:\n        int: Sum of the digits of n.\n    \"\"\"\n    return sum(int(digit) for digit in str(abs(n)))", "def find_divisors(n):\n    \"\"\"\n    Find all divisors of a given integer n.\n    Parameters:\n        n (int): The integer to find divisors of.\n    Returns:\n        list: A list of all divisors of n.\n    \"\"\"\n    return sympy.divisors(n)", "def prime_factors(n):\n    \"\"\"\n    Return the prime factorization of an integer n as a dictionary {prime: exponent}.\n    Parameters:\n    - n (int): The number to factorize.\n    Returns:\n    - dict: A dictionary with primes as keys and their respective exponents as values.\n    Examples:\n    >>> prime_factors(18)\n    {2: 1, 3: 2}\n    \"\"\"\n    return factorint(n)", "def is_perfect_cube(n):\n    \"\"\"\n    Check if a given integer n is a perfect cube.\n    Parameters:\n    - n (int): The number to check.\n    Returns:\n    - bool: True if n is a perfect cube, False otherwise.\n    Examples:\n    >>> is_perfect_cube(27)\n    True\n    >>> is_perfect_cube(26)\n    False\n    \"\"\"\n    croot = int(round(n ** (1/3)))\n    return croot**3 == n", "def compute_lcm(a, b):\n    \"\"\"Compute the least common multiple of two integers a and b.\n    \n    Parameters:\n        a (int): First integer\n        b (int): Second integer\n    \n    Returns:\n        int: Least common multiple of a and b\n    \n    Examples:\n        >>> compute_lcm(6, 8)\n        24\n        >>> compute_lcm(5, 10)\n        10\n    \"\"\"\n    return abs(a*b) // gcd(a, b)", "def is_perfect_square(n):\n    \"\"\"\n    Check if a number is a perfect square.\n    \n    Parameters:\n    - n: int, the number to check\n    \n    Returns:\n    - bool, True if n is a perfect square, False otherwise\n    \n    Examples:\n    >>> is_perfect_square(25)\n    True\n    >>> is_perfect_square(10)\n    False\n    \"\"\"\n    sqrt_n = int(math.sqrt(n))\n    return sqrt_n * sqrt_n == n", "def is_odd(n):\n    \"\"\"\n    Check if a number is odd.\n    \n    Parameters:\n    n (int): The number to check.\n    \n    Returns:\n    bool: True if the number is odd, False otherwise.\n    \n    Example:\n    >>> is_odd(3)\n    True\n    >>> is_odd(4)\n    False\n    \"\"\"\n    return n % 2 != 0", "def modular_inverse(a, m):\n    \"\"\"\n    Find the modular inverse of a under modulo m.\n    Parameters:\n    - a (int): The number to find the inverse of.\n    - m (int): The modulus.\n    Returns:\n    - int/None: The modular inverse if it exists, otherwise None.\n    Examples:\n    - modular_inverse(3, 11) -> 4 (because (3*4) % 11 == 1)\n    - modular_inverse(10, 20) -> None (because 10 and 20 are not coprime)\n    \"\"\"\n    from sympy import mod_inverse\n    try:\n        return mod_inverse(a, m)\n    except ValueError:\n        return None", "def is_valid_triangle(a, b, c):\n    \"\"\"\n    Determines if three side lengths can form a triangle based on the triangle inequality theorem.\n    \n    Parameters:\n    - a (int): length of side a\n    - b (int): length of side b\n    - c (int): length of side c\n    \n    Returns:\n    - bool: True if the sides can form a triangle, False otherwise\n    Examples:\n    >>> is_valid_triangle(3, 4, 5)\n    True\n    >>> is_valid_triangle(1, 2, 3)\n    False\n    \"\"\"\n    return (a + b > c) and (a + c > b) and (b + c > a)", "def triangle_combinations(max_side: int):\n    \"\"\"\n    Generates all combinations of integer side lengths (a, b, c) such that they satisfy the triangle inequality.\n    \n    Parameters:\n    - max_side (int): Maximum length for any side of the triangle.\n    \n    Returns:\n    - set of tuples: a set containing tuples (a, b, c), each being a valid triangle with sides a, b, and c.\n    \n    Example:\n    >>> triangle_combinations(5)\n    {(3, 4, 5), (2, 3, 4), (2, 2, 3), ...}\n    \"\"\"\n    from itertools import combinations_with_replacement\n    \n    valid_triangles = set()\n    for a, b, c in combinations_with_replacement(range(1, max_side + 1), 3):\n        if a + b > c and a + c > b and b + c > a:\n            valid_triangles.add(tuple(sorted([a, b, c])))\n    \n    return valid_triangles", "def gcd(a, b):\n    \"\"\"\n    Compute the greatest common divisor of a and b.\n    Parameters:\n    - a (int): First number.\n    - b (int): Second number.\n    Returns:\n    - int: The greatest common divisor of a and b.\n    \n    Example:\n    >>> gcd(48, 18)\n    6\n    \"\"\"\n    while b:\n        a, b = b, a % b\n    return a", "def is_divisible(n, m):\n    \"\"\"\n    Checks if n is divisible by m.\n    Parameters:\n    - n (int): The dividend.\n    - m (int): The divisor.\n    Returns:\n    - bool: True if n is divisible by m, False otherwise.\n    \n    Examples:\n    >>> is_divisible(20, 4)\n    True\n    \"\"\"\n    return n % m == 0", "def extract_digits(n):\n    \"\"\"Extract digits of an integer n as a list.\n    \n    Parameters:\n        n (int): The integer from which digits are to be extracted.\n        \n    Returns:\n        list: Digits of the given integer.\n    \n    Examples:\n        >>> extract_digits(123)\n        [1, 2, 3]\n    \"\"\"\n    return [int(x) for x in str(abs(n))]", "def list_factors(n):\n    \"\"\"\n    List all positive factors of a given integer.\n    Parameters:\n    - n (int): The integer to find factors of.\n    Returns:\n    - list: A list of all positive factors of n.\n    Examples:\n    - list_factors(36) -> [1, 2, 3, 4, 6, 9, 12, 18, 36]\n    \"\"\"\n    return [i for i in range(1, n+1) if n % i == 0]", "def check_prime(number):\n    \"\"\"\n    Check if a number is prime using the sympy library.\n    Parameters:\n        number (int): The number to check for primality.\n    Returns:\n        bool: True if the number is prime, False otherwise.\n    \"\"\"\n    return sympy.isprime(number)", "def sum_of_integers(n):\n    \"\"\"Calculate the sum of the first n positive integers.\n    \n    Parameters:\n    n : int\n        The number of terms.\n    \n    Returns:\n    int\n        The sum of the first n positive integers.\n    \n    Example:\n    >>> sum_of_integers(10)\n    55\n    \"\"\"\n    return n * (n + 1) // 2", "def is_square_free(n):\n    \"\"\"\n    Check if a number is square-free (not divisible by any perfect square other than 1).\n    \n    Parameters:\n    - n: int, the number to check\n    \n    Returns:\n    - bool, True if n is square-free, False otherwise\n    \n    Examples:\n    >>> is_square_free(30)\n    True\n    >>> is_square_free(12)\n    False\n    \"\"\"\n    if n < 2:\n        return True\n    for p in range(2, int(math.sqrt(n)) + 1):\n        if n % (p * p) == 0:\n            return False\n    return True", "def count_digit(n, digit):\n    \"\"\"Count occurrences of a specific digit in an integer.\n    \n    Parameters:\n        n (int): Integer to search within.\n        digit (int): Digit to count.\n        \n    Returns:\n        int: Number of times digit occurs in n.\n    \n    Examples:\n        >>> count_digit(1223, 2)\n        2\n    \"\"\"\n    return str(n).count(str(digit))", "def integer_solution_counter(func, lower_bound, upper_bound):\n    \"\"\"\n    Counts and lists integer solutions for a given function within specified bounds.\n    \n    Parameters:\n        func (function): A Python function that should return a boolean.\n                         It defines the conditions under which an integer is considered a solution.\n        lower_bound (int): The lower inclusive bound of the range to test.\n        upper_bound (int): The upper inclusive bound of the range to test.\n    \n    Returns:\n        tuple: First element is the count of solutions, the second element is a list of solutions.\n    \n    Examples:\n        >>> integer_solution_counter(lambda x: x % 2 == 0, 1, 10)\n        (5, [2, 4, 6, 8, 10])\n        >>> integer_solution_counter(lambda x: x**2 <= 50, -10, 10)\n        (15, [-7, -6, -5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7])\n    \"\"\"\n    import sympy as sp\n    \n    solutions = []\n    for x in sp.solveset(func(sp.symbols('x')), domain=sp.S.Integers):\n        if lower_bound <= x <= upper_bound:\n            solutions.append(int(x))\n    \n    return len(solutions), solutions", "def are_consecutive(numbers):\n    \"\"\"\n    Determine if a list of numbers consists of consecutive integers.\n    Parameters\n    ----------\n    numbers : list of int\n        The list of integers to check.\n    Returns\n    -------\n    bool\n        True if integers are consecutive, otherwise False.\n    Examples\n    --------\n    >>> are_consecutive([1, 2, 3, 4])\n    True\n    >>> are_consecutive([1, 2, 4])\n    False\n    \"\"\"\n    sorted_numbers = sorted(numbers)\n    return all((sorted_numbers[i] + 1 == sorted_numbers[i + 1]\n                for i in range(len(sorted_numbers) - 1)))", "def get_divisors(number):\n    \"\"\"\n    Get all positive divisors of a given number.\n    \n    Parameters:\n    - number (int): The number to get divisors for.\n    \n    Returns:\n    - list: A list of all positive divisors.\n    \n    Examples:\n    >>> get_divisors(12)\n    [1, 2, 3, 4, 6, 12]\n    \"\"\"\n    return divisors(number)", "def count_digit_combinations(digits, length, leading_zeros=False):\n    \"\"\"Count possible numbers of a given length with specified digit constraints and optional leading zeros.\n    \n    Parameters:\n    - digits (list): Allowed digits.\n    - length (int): Desired length of numbers.\n    - leading_zeros (bool): Whether leading zeros are allowed.\n    \n    Returns:\n    Iterator over all valid number combinations as strings.\n    \n    Examples:\n    >>> len(list(count_digit_combinations([1, 2, 3], 2, leading_zeros=False)))\n    9\n    \"\"\"\n    if leading_zeros:\n        return product(digits, repeat=length)\n    return product([d for d in digits if d != 0], *[digits for _ in range(length - 1)])", "def find_factors(number):\n    \"\"\"\n    Find all positive factors of a given number.\n    Parameters:\n        number (int): The number to factorize.\n    Returns:\n        list: A list of all positive factors of the number.\n    \"\"\"\n    return list(sympy.divisors(number))", "def solve_sum_of_squares(target, limit=None):\n    \"\"\"\n    Find pairs of integers (a, b) such that a^2 + b^2 = target, with an optional limit on values of a and b.\n    \n    Parameters:\n        target (int): The target integer sum of squares.\n        limit (int, optional): Maximum absolute value for a and b. If not specified, it uses sqrt(target).\n    \n    Returns:\n        List[Tuple[int, int]]: A list of tuples (a, b) where both a^2 + b^2 equals to the target.\n    \n    Examples:\n        # Find integer solutions for a^2 + b^2 = 50\n        print(solve_sum_of_squares(50))\n        # Find integer solutions for a^2 + b^2 = 25 with |a|,|b| <= 5\n        print(solve_sum_of_squares(25, 5))\n    \"\"\"\n    import math\n    if limit is None:\n        limit = int(math.sqrt(target))\n    solutions = []\n    for a in range(-limit, limit + 1):\n        for b in range(-limit, limit + 1):\n            if a**2 + b**2 == target:\n                solutions.append((a, b))\n    return solutions", "def possible_numbers(digits, length, unique=False):\n    \"\"\"Generate all possible numbers of a given length from specified digits.\n    \n    Parameters:\n        digits (list): Possible digits to use.\n        length (int): The length of numbers to generate.\n        unique (bool): If True, all digits in the number must be unique.\n        \n    Returns:\n        list: All possible numbers as strings.\n    \n    Examples:\n        >>> possible_numbers([1, 2, 3], 2)\n        ['11', '12', '13', '21', '22', '23', '31', '32', '33']\n        >>> possible_numbers([1, 2, 3], 2, unique=True)\n        ['12', '13', '21', '23', '31', '32']\n    \"\"\"\n    if unique:\n        return [''.join(map(str, comb)) for comb in itertools.permutations(digits, length)]\n    else:\n                return [''.join(map(str, comb)) for comb in itertools.product(digits, repeat=length)]", "def basic_integer_operations(x, operation='floor', modulus=None, check_prime=False, get_divisors=False):\n    \"\"\"\n    Perform basic operations on an integer including floor, ceiling, modular arithmetic, \n    checking for primality, and getting divisors.\n    \n    Parameters:\n        x (int): The integer on which to perform operations.\n        operation (str, optional): The type of mathematical floor/ceiling operation (`floor`, `ceil`). Defaults to 'floor'.\n        modulus (int, optional): For modulus operation. If provided, function returns x % modulus.\n        check_prime (bool, optional): If True, checks whether the integer is prime. Defaults to False.\n        get_divisors (bool, optional): If True, returns all divisors of x. Defaults to False.\n    \n    Returns:\n        Various outputs depending on inputs: transformed integer, boolean for primality, list of divisors.\n    \n    Examples:\n        >> basic_integer_operations(17.7, 'floor')\n        17\n        >> basic_integer_operations(28, modulus=5)\n        3\n        >> basic_integer_operations(11, check_prime=True)\n        True\n        >> basic_integer_operations(12, get_divisors=True)\n        [1, 2, 3, 4, 6, 12]\n    \"\"\"\n    if operation == 'floor':\n        result = floor(x)\n    elif operation == 'ceil':\n        result = ceil(x)\n    else:\n        result = x\n    \n    if modulus is not None:\n        result = x % modulus\n    \n    prime_status = isprime(x) if check_prime else None\n    divisor_list = divisors(x) if get_divisors else None\n    \n    return {'result': result, 'is_prime': prime_status, 'divisors': divisor_list}", "def prime_factors(n):\n    \"\"\"\n    Compute the prime factors of an integer.\n    Parameters:\n    n : int\n        The integer to be factorized.\n    Returns:\n    list\n        A list of tuples representing prime factors and their exponents.\n    Examples:\n    >>> prime_factors(18)\n    [(2, 1), (3, 2)]\n    \"\"\"\n    return sympy.ntheory.factorint(n).items()", "def generate_arithmetic_sequence(start, diff, n):\n    \"\"\"Generate an arithmetic sequence from a start value with a fixed difference over n terms.\n    \n    Parameters:\n    start : int\n        Starting value of the arithmetic sequence.\n    diff : int\n        Common difference between consecutive terms.\n    n : int\n        Number of terms to generate.\n    \n    Returns:\n    list\n        The list of n terms in the arithmetic sequence.\n    \n    Example:\n    >>> generate_arithmetic_sequence(1, 3, 4)\n    [1, 4, 7, 10]\n    \"\"\"\n    return [start + i * diff for i in range(n)]", "def filter_triangles(triangles, perimeter=None, odd_even=None):\n    \"\"\"\n    Filters a set of triangles based on the perimeter and/or parity conditions.\n    Parameters:\n    - triangles (set of tuples): Set of tuples (a, b, c) representing sides of the triangles.\n    - perimeter (int, optional): The exact perimeter that the triangles must have.\n    - odd_even (str, optional): 'odd' for triangles with all odd sides; 'even' for all even sides; None for no parity filter.\n    \n    Returns:\n    - set of tuples: a set of triangles that pass all filters.\n    \n    Example:\n    >>> triangles = {(3, 4, 5), (2, 3, 4), (5, 5, 5)}\n    >>> filter_triangles(triangles, perimeter=12)\n    {(3, 4, 5)}\n    >>> filter_triangles(triangles, odd_even='odd')\n    {(5, 5, 5)}\n    \"\"\"\n    filtered = set()\n    for a, b, c in triangles:\n        if perimeter is not None and (a + b + c) != perimeter:\n            continue\n        if odd_even is not None:\n            if odd_even == 'odd' and (a % 2 == 0 or b % 2 == 0 or c % 2 == 0):\n                continue\n            elif odd_even == 'even' and (a % 2 != 0 or b % 2 != 0 or c % 2 != 0):\n                continue\n        filtered.add((a, b, c))\n    \n    return filtered", "def list_perfect_cubes(limit):\n    \"\"\"\n    Generates all perfect cubes less than or equal to the given limit.\n    \n    Parameters\n    ----------\n    limit : int\n        The upper limit for the perfect cubes.\n    Returns\n    -------\n    list\n        A list of all perfect cubes up to `limit`.\n    Examples\n    --------\n    >>> list_perfect_cubes(30)\n    [0, 1, 8, 27]\n    \"\"\"\n    cubes = [i**3 for i in range(int(round(limit ** (1/3))) + 1)]\n    return cubes", "def count_valid_numbers_in_range(start, end, criteria_func):\n    \"\"\"\n    Count integers within a specified range that meet a given criteria.\n    \n    Parameters:\n        start (int): The start of the range (inclusive).\n        end (int): The end of the range (inclusive).\n        criteria_func (function): A function that takes an integer and returns a boolean.\n    \n    Returns:\n        int: The count of integers satisfying the criteria within the specified range.\n    \n    Examples:\n        >>> def is_even(n):\n        ...     return n % 2 == 0\n        >>> count_valid_numbers_in_range(1, 10, is_even)\n        5\n    \"\"\"\n    return sum(1 for n in range(start, end + 1) if criteria_func(n))", "def calculate_gcd(num1, num2):\n    \"\"\"\n    Calculate the greatest common divisor of two numbers.\n    Parameters:\n        num1 (int): First integer.\n        num2 (int): Second integer.\n    Returns:\n        int: The greatest common divisor of num1 and num2.\n    \"\"\"\n    return sympy.gcd(num1, num2)", "def check_digit_inclusion(n, include_digits=None, exclude_digits=None):\n    \"\"\"\n    Check whether the integer `n` includes or excludes certain digits.\n    \n    Parameters:\n        n (int): The integer to check.\n        include_digits (set of int, optional): Digits that should be included in `n`.\n        exclude_digits (set of int, optional): Digits that should be excluded from `n`.\n    \n    Returns:\n        bool: True if `n` meets the criteria, False otherwise.\n    \n    Examples:\n        >>> check_digit_inclusion(567, include_digits={5, 6}, exclude_digits={1})\n        True\n        >>> check_digit_inclusion(560, include_digits={1}, exclude_digits={0})\n        False\n    \"\"\"\n    str_n = str(n)\n    if include_digits and not all(str(digit) in str_n for digit in include_digits):\n        return False\n    if exclude_digits and any(str(digit) in str_n for digit in exclude_digits):\n        return False\n    return True", "def integer_floor(x):\n    \"\"\"Find the floor of a real number, rounding down to the nearest integer.\n    \n    Parameters:\n    x : float\n        The real number to find the floor of.\n    \n    Returns:\n    int\n        The floor of x.\n    \n    Example:\n    >>> integer_floor(3.7)\n    3\n    >>> integer_floor(-1.2)\n    -2\n    \"\"\"\n    return math.floor(x)", "def list_perfect_squares(limit):\n    \"\"\"\n    Generates all perfect squares less than or equal to the given limit.\n    \n    Parameters\n    ----------\n    limit : int\n        The upper limit for the perfect squares.\n    Returns\n    -------\n    list\n        A list of all perfect squares up to `limit`.\n    Examples\n    --------\n    >>> list_perfect_squares(30)\n    [0, 1, 4, 9, 16, 25]\n    \"\"\"\n    squares = [i*i for i in range(int(math.sqrt(limit)) + 1)]\n    return squares", "def is_divisible(a, b):\n    \"\"\"\n    Check if integer a is divisible by integer b.\n    Parameters:\n        a (int): The dividend.\n        b (int): The divisor.\n    Returns:\n        bool: True if a is divisible by b, False otherwise.\n    \"\"\"\n    if b == 0:\n        raise ValueError(\"Division by zero is not supported.\")\n    return a % b == 0", "def solve_linear_inequality(a, b, c):\n    \"\"\"Solve a linear inequality of the form a*x + b <= c\n    \n    Parameters:\n    a : int\n        The coefficient of x.\n    b : int\n        Constant term.\n    c : int\n        Right side of the inequality.\n    \n    Returns:\n    tuple\n        The range of x that satisfies the inequality.\n    \n    Example:\n    >>> solve_linear_inequality(3, -6, 12)\n    (-inf, 6.0)\n    \"\"\"\n    if a == 0:\n        if b <= c:\n            return float('-inf'), float('inf')  # Indeterminate case or all x satisfy\n        else:\n            return ()  # No solution\n    x = (c - b) / a\n    if a > 0:\n        return float('-inf'), x\n    else:\n        return x, float('inf')", "def polynomial_integer_values(polynomial, values):\n    \"\"\"\n    Evaluate a polynomial at given values and check if results are integers.\n    Parameters:\n        polynomial (sympy.Poly): The polynomial to evaluate.\n        values (list): Values at which to evaluate the polynomial.\n    Returns:\n        dict: A dictionary mapping values to their evaluation results and whether those are integers.\n    \"\"\"\n    results = {}\n    for val in values:\n        result = polynomial.subs(sympy.Symbol('x'), val)\n        results[val] = {'value': result, 'is_integer': sympy.sympify(result).is_integer}\n    return results", "def integer_properties_checker(n, check='prime'):\n    \"\"\"\n    Check specific properties of an integer such as primality or perfect square.\n    Parameters:\n    n (int): the integer to check\n    check (str): What to check, supported values are 'prime', 'perfect_square'\n    Returns:\n    bool: True if the property is satisfied, False otherwise\n    Examples:\n    >>> integer_properties_checker(29, 'prime')\n    True\n    >>> integer_properties_checker(28, 'perfect_square')\n    False\n    \"\"\"\n    if check == 'prime':\n        return sympy.isprime(n)\n    elif check == 'perfect_square':\n        return n == sympy.Integer(sympy.sqrt(n))**2\n    else:\n        raise ValueError(\"Unsupported check type provided. Supported types are 'prime', 'perfect_square'.\")", "def arithmetic_sum(a, d, n):\n    \"\"\"\n    Calculate the sum of the first `n` terms of an arithmetic sequence.\n    Parameters\n    ----------\n    a : int\n        The first term of the sequence.\n    d : int\n        The common difference of the sequence.\n    n : int\n        The number of terms.\n    Returns\n    -------\n    int\n        The sum of the first `n` terms.\n    Examples\n    --------\n    >>> arithmetic_sum(1, 1, 100)  # Sum of first 100 natural numbers\n    5050\n    >>> arithmetic_sum(2, 2, 10)  # Sum of first 10 even numbers starting from 2\n    110\n    \"\"\"\n    return n * (2 * a + (n - 1) * d) // 2", "def is_abundant(n):\n    \"\"\"\n    Determine if a number is abundant (sum of proper divisors greater than the number itself).\n    Parameters:\n    n : int\n        The number to check for abundance.\n    Returns:\n    bool\n        True if n is abundant, False otherwise.\n    Examples:\n    >>> is_abundant(12)\n    True\n    \"\"\"\n    proper_factors = sum(all_factors(n)[:-1])\n    return proper_factors > n", "def count_integers_within_bounds(lower_bound, upper_bound, inclusive=True):\n    \"\"\"\n    Calculate the total count of integers between two bounds.\n    Parameters:\n    lower_bound (int): the lower bound of the range\n    upper_bound (int): the upper bound of the range\n    inclusive (bool): if True, include both bounds, else exclude bounds\n    \n    Returns:\n    int: count of integers within the specified bounds\n    Examples:\n    >>> count_integers_within_bounds(1, 10)\n    10\n    >>> count_integers_within_bounds(1, 10, inclusive=False)\n    8\n    \"\"\"\n    if inclusive:\n        return (upper_bound - lower_bound + 1)\n    else:\n        return (upper_bound - lower_bound - 1)", "def find_integers_in_range(start, end, condition=lambda x: True):\n    \"\"\"\n    Generates a list of integers within a specified range that meet a certain condition.\n    \n    Parameters:\n        start (int): The start of the range (inclusive).\n        end (int): The end of the range (inclusive).\n        condition (callable): A function that takes an integer as an argument and returns\n                              a boolean indicating whether the integer meets the specified condition.\n                              Default checks if every integer in the range is valid.\n    \n    Returns:\n        List[int]: A list containing all integers in the range [start, end] that meet the condition.\n    \n    Examples:\n        # Find all integers between 1 and 100\n        print(find_integers_in_range(1, 100))\n        # Find all even integers between 1 and 100\n        print(find_integers_in_range(1, 100, lambda x: x % 2 == 0))\n        # Find all prime integers between 1 and 100\n        from sympy import isprime\n        print(find_integers_in_range(1, 100, isprime))\n    \"\"\"\n    return [n for n in range(start, end + 1) if condition(n)]", "def integer_ceiling(x):\n    \"\"\"Find the ceiling of a real number, rounding up to the nearest integer.\n    \n    Parameters:\n    x : float\n        The real number to find the ceiling of.\n    \n    Returns:\n    int\n        The ceiling of x.\n    \n    Example:\n    >>> integer_ceiling(3.2)\n    4\n    >>> integer_ceiling(-2.3)\n    -2\n    \"\"\"\n    return math.ceil(x)", "def calculate_lcm(num1, num2):\n    \"\"\"\n    Calculate the least common multiple of two numbers.\n    Parameters:\n        num1 (int): First integer.\n        num2 (int): Second integer.\n    Returns:\n        int: The least common multiple of num1 and num2.\n    \"\"\"\n    return sympy.lcm(num1, num2)", "def polynomial_coefficients_integer(polynomial):\n    \"\"\"\n    Check if a polynomial expression has all integer coefficients.\n    Parameters:\n        polynomial (sympy.Poly): A polynomial expression.\n    Returns:\n        bool: True if all coefficients of the polynomial are integers, False otherwise.\n    \"\"\"\n    return all(coeff.is_Integer for coeff in polynomial.all_coeffs())", "def evaluate_expression(values, operation='sum'):\n    \"\"\"\n    Evaluate a mathematical expression with a list of values based on operation type like sum or product.\n    \n    Parameters:\n    values (list[int]): List of integer values.\n    operation (str): Type of operation ('sum', 'product').\n    \n    Returns:\n    int: Result of the operation.\n    \n    Example:\n    >>> evaluate_expression([1, 3, 5], 'sum')\n    9\n    >>> evaluate_expression([1, 3, 5], 'product')\n    15\n    \"\"\"\n    import functools\n    import operator\n    if operation == 'sum':\n        return sum(values)\n    elif operation == 'product':\n        return functools.reduce(operator.mul, values, 1)\n    else:\n        raise ValueError(\"Unsupported operation type. Supported types: 'sum', 'product'\")", "def polynomial_factors(f, var):\n    \"\"\"\n    Find the factors of a polynomial expression.\n    Parameters:\n    - f (sympy.Expr): Polynomial expression.\n    - var (sympy.Symbol): The variable in the polynomial.\n    Returns:\n    - List of factors.\n    Examples:\n    - polynomial_factors(x**2 - 1, x) -> [x - 1, x + 1]\n    \"\"\"\n    from sympy import factor_list\n    return factor_list(f, gens=var)"], "Powers and Roots": ["def power_mod(base, exponent, mod):\n    \"\"\"\n    Calculate the base raised to the exponent modulo mod.\n    \n    Parameters:\n    base (int): The base number.\n    exponent (int): The power to which the base is raised.\n    mod (int): The modulus to use for the calculation.\n    \n    Returns:\n    int: The result of (base ** exponent) % mod\n    \n    Examples:\n    >>> power_mod(2, 5, 3)\n    2\n    >>> power_mod(3, 2, 4)\n    1\n    \"\"\"\n    return pow(base, exponent, mod)", "def compute_power(base, exponent):\n    \"\"\"\n    Computes the power of a given base raised to an exponent.\n    \n    Parameters:\n    - base (int or float or complex): The base of the exponentiation.\n    - exponent (int or float or complex): The exponent to which the base is raised.\n    \n    Returns:\n    - int or float or complex: The result of base ** exponent.\n    \n    Example:\n    >>> compute_power(2, 3)\n    8\n    >>> compute_power(3 + 4j, 2)\n    (5+24j)\n    \"\"\"\n    return base ** exponent", "def estimate_square_root(n):\n    \"\"\"Estimating the square root of n to the nearest integer.\n    Parameters:\n    n (float): The number to take the root from.\n    Returns:\n    int: The nearest integer of the square root of n.\n    Example:\n     >>> estimate_square_root(200)\n    14\n    \"\"\"\n    return int(n**0.5)", "def simplify_expression_with_root(base, exponent, root_degree):\n    \"\"\"\n    Simplify an expression involving roots and exponents.\n    \n    Parameters:\n    base (int or float): The base number.\n    exponent (int): The exponent, can be negative for roots.\n    root_degree (int): The degree of the root to apply.\n    \n    Returns:\n    float: The simplified result of (base ** (exponent / root_degree)).\n    \n    Examples:\n    >>> simplify_expression_with_root(8, 1, 3)\n    2.0\n    >>> simplify_expression_with_root(16, 1, 4)\n    2.0\n    \"\"\"\n    return base ** (exponent / root_degree)", "def compute_nth_root(n, r):\n    \"\"\"Computes the nth root of a number r.\n    Parameters:\n    n (int): The root to compute.\n    r (float): The number to take the root from.\n    Returns:\n    float: The nth root of r.\n    Example:\n    >>> compute_nth_root(3, 27)\n    3.0\n    \"\"\"\n    return r**(1/n)", "def perfect_squares_in_range(start, end):\n    \"\"\"Find all perfect squares within a range.\n    Parameters:\n    start (int): the start of the range.\n    end (int): the end of the range.\n    Returns:\n    list: List of all perfect squares within the range.\n    Example:\n    >>> perfect_squares_in_range(1, 10)\n    [1, 4, 9]\n    \"\"\"\n    squares = []\n    for num in range(start, end+1):\n        root = math.sqrt(num)\n        if int(root + 0.5) ** 2 == num:\n            squares.append(num)\n    return squares", "def list_powers_within_range(min_val, max_val, power):\n    \"\"\"\n    Generates a list of numbers that are perfect powers (such as squares, cubes) within a specified range.\n    \n    Parameters:\n    min_val (int): Minimum value of the range.\n    max_val (int): Maximum value of the range.\n    power (int): The power to consider (2 for squares, 3 for cubes, etc.)\n    \n    Returns:\n    list: A list of integers that are perfect powers within the given range.\n    \n    Examples:\n    >>> list_powers_within_range(1, 100, 2)\n    [1, 4, 9, 16, 25, 36, 49, 64, 81, 100]\n    \n    >>> list_powers_within_range(1, 100, 3)\n    [1, 8, 27, 64]\n    \"\"\"\n    from math import pow\n    n = 1\n    results = []\n    while pow(n, power) <= max_val:\n        if pow(n, power) >= min_val:\n            results.append(int(pow(n, power)))\n        n += 1\n    return results", "def calculate_root(value, root_degree, symbolic=False):\n    \"\"\"\n    Calculates the nth root of a specified number and optionally returns a symbolic expression.\n    Parameters:\n    value (float or int): The number from which to extract the root.\n    root_degree (int): The degree of the root (e.g., 2 for square root, 3 for cube root).\n    symbolic (bool): Whether to return the result as a symbolic expression (default is False).\n    \n    Returns:\n    float or sympy.core.expr.Expr: The numerical or symbolic nth root of the value.\n    Examples:\n    >>> calculate_root(16, 2)\n    4.0\n    >>> calculate_root(27, 3, symbolic=True)\n    3\n    \"\"\"\n    if symbolic:\n        from sympy import root, N\n        return root(value, root_degree)\n    else:\n        from math import pow\n        return pow(value, 1 / root_degree)", "def compute_square_root(n):\n    \"\"\"Compute the square root of a number.\n    \n    Parameters:\n        n (float|int): The number to find the square root of. Must be non-negative.\n        \n    Returns:\n        float: The square root of the number.\n    \n    Examples:\n        >>> compute_square_root(16)\n        4.0\n        >>> compute_square_root(15)\n        3.872983346207417\n    \"\"\"\n    if n < 0:\n        raise ValueError(\"Cannot compute square root of a negative number.\")\n    return math.sqrt(n)", "def calculate_square_and_square_root(n):\n    \"\"\"Find the square and square root of n.\n    Parameters:\n    n (int): Integer input to be checked.\n    Returns:\n    tuple: a tuple of square and square root of n.\n    Example:\n    >>> calculate_square_and_square_root(4)\n    (16, 2.0)\n    \"\"\"\n    return n**2, sqrt(n)", "def nth_root_of_unity(degree, k=1):\n    \"\"\"\n    Computes the k-th nth root of unity using Euler's formula.\n    \n    Parameters:\n    - degree (int): The degree of the root of unity.\n    - k (int): Specifies which nth root of unity to compute.\n    \n    Returns:\n    - complex: The k-th nth root of unity.\n    \n    Example:\n    >>> nth_root_of_unity(4)\n    (1+0j)\n    >>> nth_root_of_unity(3, 1)\n    (-0.4999999999999998+0.8660254037844387j)\n    \"\"\"\n    return cmath.exp(2j * cmath.pi * k / degree)", "def find_units_digit(base, exponent):\n    \"\"\"\n    Find the unit's digit of a number raised to an exponent.\n    \n    Parameters:\n    base (int): The base number.\n    exponent (int): The exponent.\n    \n    Returns:\n    int: The unit's digit.\n    \n    Examples:\n    >>> find_units_digit(12, 2)\n    4\n    >>> find_units_digit(7, 3)\n    3\n    \"\"\"\n    # Only last digit of base raised to the power affects the unit's digit.\n    return (base % 10) ** exponent % 10", "def compute_cube_root(n):\n    \"\"\"Compute the cube root of a number.\n    \n    Parameters:\n        n (float|int): The number to find the cube root of.\n        \n    Returns:\n        float: The cube root of the number.\n    \n    Examples:\n        >>> compute_cube_root(27)\n        3.0\n        >>> compute_cube_root(-8)\n        -2.0\n    \"\"\"\n    if n < 0:\n        return -(-n) ** (1. / 3)\n    return n ** (1. / 3)", "def prime_factorization(n):\n    \"\"\"\n    Perform prime factorization of a number.\n    Parameter:\n    n (int): An integer to factorize into primes.\n    Returns:\n    factors (dict): A dictionary where the keys are prime factors and values are their frequencies in the factorization.\n    Example:\n    >>> prime_factorization(20)\n    {2: 2, 5: 1}\n    \"\"\"\n    import sympy\n    factors = sympy.factorint(n)\n    return factors", "def calculate_root(n, degree):\n    \"\"\"\n    Calculate the nth root of a number.\n    Parameters:\n    n (int, float): The base number.\n    degree (int, float): The degree of root to be calculated.\n    Returns:\n    result (int, float): The calculated nth root.\n    Example:\n    >>> calculate_root(81, 4)\n    3.0\n    \"\"\"\n    import numpy as np\n    result = np.power(n, 1.0/degree)\n    return result", "def simplify_expression(expression):\n    \"\"\"\n    Simplifies mathematical expressions involving powers and roots using symbolic math.\n    \n    Parameters:\n    expression (str): The mathematical expression in string form to be simplified.\n    \n    Returns:\n    sympy.core.expr.Expr: The simplified expression.\n    \n    Examples:\n    >>> str(simplify_expression(\"sqrt(x)**2\"))\n    'x'\n    >>> str(simplify_expression(\"x**3 * x**4\"))\n    'x**7'\n    \"\"\"\n    from sympy import simplify, sympify\n    expr = sympify(expression)\n    return simplify(expr)", "def simplfy_square_root(n):\n    \"\"\"Find the simplified form of square root of n.\n    Parameters:\n    n (int): Integer input to be checked.\n    Returns:\n    str: Simplified form of square root of n.\n    Example:\n    >>> simplify_square_root(50)\n    '5*sqrt(2)'\n    \"\"\"\n    return sqrt(n)", "def simplify_radical_expression(a, b):\n    \"\"\"Simplifies the radical expression sqrt(a / b).\n    \n    Parameters:\n        a (int): The numerator.\n        b (int): The denominator.\n    \n    Returns:\n        str: A string representing the simplified radical form.\n    \n    Examples:\n        >>> simplify_radical_expression(50, 2)\n        '5*sqrt(2)'\n        >>> simplify_radical_expression(18, 9)\n        'sqrt(2)'\n    \"\"\"\n    factor = math.gcd(a, b)\n    a //= factor\n    b //= factor\n    sqrt_a = int(math.sqrt(a))\n    sqrt_b = int(math.sqrt(b))\n    if sqrt_a ** 2 == a and sqrt_b ** 2 == b:\n        return f\"{sqrt_a * sqrt_b}\"\n    elif sqrt_a ** 2 == a:\n        return f\"{sqrt_a}*sqrt({b})\"\n    elif sqrt_b ** 2 == b:\n        return f\"sqrt({a})/{sqrt_b}\"\n    else:\n        return f\"sqrt({a}/{b})\"", "def find_pattern(seq):\n    \"\"\"\n    Detect a pattern in a sequence.\n    Parameter:\n    seq (list): Sequence of numbers in which to detect a pattern.\n    Returns:\n    pattern (list): Detected repeating pattern. Return empty list if no pattern is found.\n    Example:\n    >>> find_pattern([1, 2, 3, 1, 2, 3, 1, 2, 3])\n    [1, 2, 3]\n    \"\"\"\n    # Iterate over lengths of potential repeats\n    for i in range(1, len(seq)//2 + 1):\n        if len(seq) % i == 0: # Repeat length must divide sequence length\n            pattern = seq[:i]\n            if pattern * (len(seq) // i) == seq:\n                return pattern\n    return []"], "Fractions and Decimals": ["def add_fractions(frac1, frac2):\n    \"\"\"\n    Add two fractions and return the result in its simplest form.\n    Parameters:\n    - frac1 (Fraction): First fraction.\n    - frac2 (Fraction): Second fraction.\n    Returns:\n    - Fraction: Sum of the two fractions in simplest form.\n    Examples:\n    >>> add_fractions(Fraction(1, 3), Fraction(1, 6))\n    Fraction(1, 2)\n    >>> add_fractions(Fraction(1, 2), Fraction(1, 3))\n    Fraction(5, 6)\n    \"\"\"\n    return frac1 + frac2", "def simplify_fraction(numerator, denominator):\n    \"\"\"\n    Simplify a fraction using its numerator and denominator.\n    Parameters:\n    - numerator (int): the numerator of the fraction.\n    - denominator (int): the denominator of the short division.\n    Returns:\n    - sympy.Rational: the simplified fraction.\n    Examples:\n    >>> simplify_fraction(10, 100)\n    1/10\n    >>> simplify_fraction(22, 7)\n    22/7\n    \"\"\"\n    return Rational(numerator, denominator)", "def convert_repeating_decimal_to_fraction(decimal_str):\n    \"\"\"\n    Convert a repeating decimal given as a string to its simplest fractional form.\n    Parameters:\n    - decimal_str (str): The repeating decimal as a string, e.g., \"0.333...\", \"1.256...\"\n    Returns:\n    - sympy.Rational: The fraction form of the repeating decimal.\n    Examples:\n    >>> convert_repeating_decimal_to_fraction('0.333...')\n    1/3\n    >>> convert_repeating_decimal_to_fraction('1.256...')\n    sympy.Rational(1256, 999) - simplified form\n    \"\"\"\n    if '...' not in decimal_str:\n        # No repeating part, simple conversion        \n        return sympy.Rational(decimal_str)\n    \n    non_repeating, repeating = decimal_str.replace('...', '').split('.')\n    repeat_length = len(repeating)\n    non_repeat_length = len(non_repeating) - 1  # Excludes point\n    \n    denominator = 10**repeat_length - 1\n    numerator = int(repeating) + int(non_repeating)*10**repeat_length\n    return sympy.Rational(numerator, denominator * 10**non_repeat, 10)", "def fraction_operations(fraction1, fraction2, operation='add'):\n    \"\"\"\n    Perform operations (add, subtract, multiply, divide) on two fractions.\n    Parameters:\n    - fraction1 (sympy.Rational): First fraction operand.\n    - fraction2 (sympy.Rational): Second fraction operand.\n    - operation (str): Operation to perform ('add', 'subtract', 'multiply', 'divide').\n    Returns:\n    - sympy.Rational: The result of the operation.\n    Examples:\n    >>> fraction_operations(Rational(1, 3), Rational(1, 6), 'add')\n    1/2\n    >>> fraction_operations(Rational(1, 2), Rational(1, 4), 'subtract')\n    1/4\n    \"\"\"\n    if operation == 'add':\n        return fraction1 + fraction2\n    elif operation == 'subtract':\n        return fraction1 - fraction2\n    elif operation == 'multiply':\n        return fraction1 * fraction2\n    elif operation == 'divide':\n        return fraction1 / fraction2", "def does_fraction_terminate(numerator, denominator):\n    \"\"\"\n    Determines if a fraction will terminate or have infinite repeating decimals.\n    \n    Parameters:\n    - numerator (int): Numerator of the fraction.\n    - denominator (int): Denominator of the fraction.\n    \n    Returns:\n    - bool: True if the fraction terminates, False otherwise.\n    \n    Examples:\n    - does_fraction_terminate(1, 2) --> True\n    - does_fraction_terminate(1, 3) --> False\n    \"\"\"\n    # Prime factorization only contains 2's or 5's\n    while denominator % 2 == 0:\n        denominator //= 2\n    while denominator % 5 == 0:\n        denominator //= 5\n    return denominator == 1", "def prime_factorization(n):\n    \"\"\"\n    Returns the prime factors of a given integer.\n    Parameters:\n        n (int): The number to factorize.\n    Returns:\n        list: A list of prime factors.\n    Examples:\n        >>> prime_factorization(18)\n        [2, 3, 3]\n    \"\"\"\n    factors = []\n    for prime in primefactors(n):\n        count = 0\n        while n % prime == 0:\n            n //= prime\n            count += 1\n        factors.extend([prime] * count)\n    return factors", "def modular_exponent(base, exponent, mod):\n    \"\"\"\n    Calculate base raised to exponent modulo mod using efficient modular exponentiation.\n    Parameters:\n        base (int): The base of the expression.\n        exponent (int): The exponent.\n        mod (int): The modulus for the operation.\n    Returns:\n        int: The result of (base^exponent) % mod.\n    Examples:\n        >>> modular_exponent(2, 10, 1000)\n        24\n    \"\"\"\n    return pow(base, exponent, mod)", "def is_prime(num):\n    \"\"\"\n    Check if a number is a prime number.\n    Parameters:\n        num (int): The number to check.\n    Returns:\n        bool: True if the number is a prime, else False.\n    Examples:\n        >>> is_prime(11)\n        True\n        >>> is_prime(4)\n        False\n    \"\"\"\n    return isprime(num)", "def lcm(*numbers):\n    \"\"\"\n    Calculate the least common multiple of a series of integers.\n    Parameters:\n        numbers (int): A series of integer numbers.\n    Returns:\n        int: The least common multiple of the numbers.\n    Examples:\n        >>> lcm(5, 10, 20)\n        20\n    \"\"\"\n    return np.lcm.reduce(numbers)", "def gcd(*numbers):\n    \"\"\"\n    Calculate the greatest common divisor of a series of integers.\n    Parameters:\n        numbers (int): A series of integer numbers.\n    Returns:\n        int: The greatest common divisor of the numbers.\n    Examples:\n        >>> gcd(8, 12, 16)\n        4\n    \"\"\"\n    return np.gcd.reduce(numbers)"], "Floor Function": ["def compute_floor(x):\n    \"\"\"\n    Compute the floor of a given real number.\n    Parameters:\n    - x (float): The number for which the floor value is to be computed.\n    Returns:\n    - int: The floor value of the input number.\n    Examples:\n    >>> compute_floor(3.7)\n    3\n    >>> compute_floor(-1.2)\n    -2\n    \"\"\"\n    return math.floor(x)", "def iterative_floor_application(start_value, iteration_function, iterations):\n    \"\"\"\n    Repeatedly apply a transformation involving the floor function and observe the result after a defined number of iterations.\n    Parameters\n    ----------\n    start_value : float\n        Initial value where the transformation begins.\n    iteration_function : callable\n        A function that defines the transformation involving the floor to apply.\n    iterations : int\n        Number of times the iteration is applied.\n    Returns\n    -------\n    float\n        Result after applying the defined transformation the number of times specified by 'iterations'.\n    Examples\n    --------\n    >>> iterative_floor_application(4.5, lambda x: x/2, 5)\n    0.140625\n    \"\"\"\n    from math import floor\n    current_value = start_value\n    for _ in range(iterations):\n        current_value = floor(iteration_function(current_value))\n    return current_value", "def calculate_floor_mixed_fraction(value):\n    \"\"\"\n    This function is used to calculate the floor value of a mixed number.\n    The floor function is the integer part of the mixed number.\n    Parameters:\n    value (str): Input mixed number to calculate the floor value (format \"whole_numerator/denominator\")\n    Returns:\n    int: floor of the mixed number\n    Examples:\n    >>> calculate_floor_mixed_fraction(\"1_3/2\")\n    1\n    >>> calculate_floor_mixed_fraction(\"5_1/8\")\n    5\n    \"\"\"\n    whole, fraction = value.split('_')\n    fractional_value = Fraction(fraction)\n    total_value = int(whole) + fractional_value\n    return int(total_value)", "def calculate_floor_negative_fraction(value):\n    \"\"\"\n    This function is used to calculate the floor value of a negative fraction.\n    The floor function is the integer less than the negative fraction.\n    Parameters:\n    value (str): Input negative fraction to calculate the floor value (format \"-numerator/denominator\")\n    Returns:\n    int: floor of the given negative fraction.\n    Examples:\n    >>> calculate_floor_negative_fraction(\"-3/2\")\n    -2\n    >>> calculate_floor_negative_fraction(\"-1/8\")\n    -1\n    \"\"\"\n    fractional_part = Fraction(value)\n    return math.floor(fractional_part)", "def evaluate_floor_inequality(x, expected_value, inequality_type):\n    \"\"\"\n    Evaluate whether an inequality involving the floor of a number holds.\n    Parameters\n    ----------\n    x : float\n        The real number input to the floor function.\n    expected_value : int\n        The integer against which the floor of x is compared.\n    inequality_type : str\n        Type of inequality used for comparison {'<=', '>=', '=', '<', '>'}.\n    Returns\n    -------\n    bool\n        True if the inequality holds, False otherwise.\n    Examples\n    --------\n    >>> evaluate_floor_inequality(5.5, 5, '=')\n    True\n    >>> evaluate_floor_inequality(3.2, 3, '<')\n    False\n    \"\"\"\n    from math import floor\n    floor_x = floor(x)\n    inequalities = {\n        '<=': floor_x <= expected_value,\n        '>=': floor_x >= expected_value,\n        '=': floor_x == expected_value,\n        '<': floor_x < expected_value,\n        '>': floor_x > expected_value\n    }\n    return inequalities[inequality_type]", "def floor_product(a, b):\n    \"\"\"\n    Calculate the product of the floors of two numbers.\n    Parameters:\n    a (float): The first number.\n    b (float): The second number.\n    Returns:\n    int: The product of the floor values of the two numbers.\n    Examples:\n    >>> floor_product(3.7, 4.1)\n    12\n    >>> floor_product(-1.2, -2.5)\n    2\n    \"\"\"\n    return math.floor(a) * math.floor(b)", "def enhanced_floor_arithmetic(expression, function=None):\n    \"\"\"\n    Evaluates a complex mathematical expression potentially involving other functions,\n    and then computes the floor value of the result. Optionally, a function could be applied outside the floor.\n    Parameters:\n    - expression (str): The mathematical expression as a string.\n    - function (callable, optional): A function to be applied after taking the floor.\n    Returns:\n    - int: The floor value of the evaluated expression or the final result after applying another function.\n    Examples:\n    >>> enhanced_floor_arithmetic(\"math.sqrt(65)\")\n    8\n    >>> enhanced_floor_arithmetic(\"(5*3 + 2)/3\")\n    5\n    >>> enhanced_floor_arithmetic(\"3.5 + 4*1.1\")\n    7\n    >>> enhanced_floor_arithmetic(\"math.sqrt(81)\", math.sin)  # Since sin(9) = 0.412\n    0\n    \"\"\"\n    result = eval(expression)\n    floor_result = math.floor(result)\n    if function:\n        return function(floor_result)\n    return floor_result", "def floor_of_expression(expr):\n    \"\"\"\n    Evaluate the floor of an expression, potentially including more complex operations like factorials.\n    `expr` should be a string that Python can evaluate directly using the `eval` function.\n    Parameters:\n    expr (str): The string representation of the mathematical expression to floor.\n    Returns:\n    int: The floor of the evaluated expression.\n    Examples:\n    >>> floor_of_expression('5/3')\n    1\n    >>> floor_of_expression('math.sqrt(64) + 0.9')\n    8\n    \"\"\"\n    return math.floor(eval(expr))", "def floor_of_square_root(x):\n    \"\"\"\n    Calculate the floor of the square root of a number.\n    Parameters:\n    x (float): A real number from which the square root is calculated, and then floored.\n    Returns:\n    int: The floor of the square root of x.\n    Examples:\n    >>> floor_of_square_root(67)\n    8\n    >>> floor_of_square_root(81)\n    9\n    \"\"\"\n    return math.floor(math.sqrt(x))", "def floor_function_bounds(value, lower_bound, upper_bound):\n    \"\"\"\n    Determines if the floor of a value falls within a specified integer bounds.\n    Parameters:\n        value (float): The number to check.\n        lower_bound (int): The lower integer boundary.\n        upper_bound (int): The upper integer boundary.\n    \n    Returns:\n        bool: True if the floor of the value is within the bounds, False otherwise.\n    \n    Examples:\n    >>> floor_function_bounds(3.2, 3, 5)\n    True\n    >>> floor_function_bounds(-2.6, -1, 2)\n    False\n    \"\"\"\n    from math import floor\n    floor_value = floor(value)\n    return lower_bound <= floor_value <= upper_bound"], "Prime Numbers": ["def is_prime(number):\n    \"\"\"\n    Determine if the provided number is a prime.\n    \n    Parameters:\n    number (int): The number to test for primality.\n    \n    Returns:\n    bool: True if `number` is a prime, otherwise False.\n    \n    Examples:\n    >>> is_prime(11)\n    True\n    >>> is_prime(4)\n    False\n    \"\"\"\n    return sympy.isprime(number)", "def prime_factors(n):\n    \"\"\"\n    Compute the prime factors of a given integer n.\n    \n    Parameters:\n    n : int\n        Integer to factorize into its prime factors.\n        \n    Returns:\n    list\n        A list containing the prime factors of the integer n.\n    \n    Examples:\n    >>> prime_factors(18)\n    [2, 3, 3]\n    >>> prime_factors(17)\n    [17]\n    \"\"\"\n    from sympy import primefactors\n    return primefactors(n)", "def generate_primes(min_val, max_val):\n    \"\"\"\n    Generate all prime numbers in a specified range.\n    \n    Parameters:\n    min_val (int): The minimum value of the range.\n    max_val (int): The maximum value of the range.\n    \n    Returns:\n    list: A list of prime numbers within the specified range.\n    \n    Examples:\n    >>> generate_primes(10, 20)\n    [11, 13, 17, 19]\n    \"\"\"\n    def sieve(n):\n        is_prime = [True] * (n+1)\n        p = 2\n        while (p * p <= n):\n            if (is_prime[p] == True):\n                for i in range(p * p, n+1, p):\n                    is_prime[i] = False\n            p += 1\n        return [p for p in range(2, n+1) if is_prime[p]]\n    return [p for p in sieve(max_val) if p >= min_val]", "def prime_factors(n):\n    \"\"\"\n    Generate the prime factors of an integer n along with their respective powers.\n    \n    Parameters:\n        n (int): The number to factorize.\n    Returns:\n        dict: A dictionary where the keys are the prime factors and the values are their powers.\n    \n    Examples:\n        >>> prime_factors(18)\n        {2: 1, 3: 2}\n        >>> prime_factors(360)\n        {2: 3, 3: 2, 5: 1}\n    \"\"\"\n    from collections import defaultdict\n    factors = defaultdict(int)\n    # Check for number of 2s that divide n\n    while n % 2 == 0:\n        factors[2] += 1\n        n //= 2\n    # n must be odd at this point\n    for i in range(3, int(math.sqrt(n)) + 1, 2):\n        # While i divides n, add i and divide n\n        while n % i == 0:\n            factors[i] += 1\n            n //= i\n    # This condition is to check if n is a prime number\n    # greater than 2\n    if n > 2:\n        factors[n] += 1\n    return dict(factors)"], "Powers and Exponents": ["def power_mod(base, exponent, modulus=None):\n    \"\"\"\n    Computes the power of a base raised to an exponent, optionally modulo a number.\n    \n    Parameters:\n    - base (int or float): The base of the exponentiation.\n    - exponent (int): The exponent to raise the base to.\n    - modulus (int, optional): The modulus to perform the operation under. Defaults to None.\n    Returns:\n    - result (int or float): The result of `base` raised to the power `exponent`, possibly modulo `modulus`.\n    \n    Examples:\n    >>> power_mod(2, 10)\n    1024\n    >>> power_mod(2, 10, 1000)\n    24\n    \"\"\"\n    if modulus is not None:\n        return pow(base, exponent, modulus)\n    else:\n        return pow(base, exponent)", "def decimal_to_base(num, base):\n    \"\"\"\n    Convert a decimal number to a given base.\n    \n    Parameters:\n        num (int): The decimal number to convert.\n        base (int): The base to convert the number to.\n        \n    Returns:\n        A string representing the number in the target base.\n    \n    Examples:\n        >>> decimal_to_base(10, 2)\n        '1010'\n        >>> decimal_to_base(255, 16)\n        'FF'\n    \"\"\"\n    if num == 0:\n        return \"0\"\n    digits = []\n    while num:\n        digits.append(int(num % base))\n        num //= base\n    digits = digits[::-1]\n    return ''.join(str(x) for x in digits)", "def power_of_number(base, exponent):\n    \"\"\"\n    Calculate the power of a given number.\n    \n    Parameters:\n        base (int or float or complex): The base of the power.\n        exponent (int): The exponent to which the base is raised.\n        \n    Returns:\n        The result of base raised to the power of exponent.\n    \n    Examples:\n        >>> power_of_number(2, 5)\n        32\n        >>> power_of_number(3, -1)\n        0.3333\n    \"\"\"\n    return base ** exponent", "def sum_geometric_sequence(start, ratio, n):\n    \"\"\"\n    Calculates the sum of the first n terms of a geometric sequence.\n    Parameters:\n    - start (float): The first term of the sequence.\n    - ratio (float): The common ratio between terms of the sequence.\n    - n (int): The number of terms to sum.\n    Returns:\n    - float: The sum of the first n terms of the geometric sequence.\n    \n    Examples:\n    >>> sum_geometric_sequence(1, 2, 10)\n    1023.0\n    \"\"\"\n    if ratio == 1:\n        return start * n\n    else:\n        return start * (1 - ratio ** n) / (1 - ratio)", "def binary_representation(number):\n    \"\"\"\n    Return the binary representation of a number.\n    \n    Parameters:\n    number (int): The number to represent in binary.\n    Returns:\n    str: Binary string representation of the number.\n    Examples:\n    >>> binary_representation(10)\n    '1010'\n    >>> binary_representation(31)\n    '11111'\n    \"\"\"\n    return bin(number)[2:]", "def geometric_series_sum(a, r, n):\n    \"\"\"\n    Calculate the sum of the first n terms of a geometric series.\n    \n    Parameters:\n    a (int, float): The first term of the series.\n    r (int, float): The common ratio between successive terms.\n    n (int): The number of terms to sum.\n    Returns:\n    int or float: The sum of the first n terms of the geometric series.\n    Examples:\n    >>> geometric_series_sum(1, 2, 4)\n    15\n    >>> geometric_series_r_sum(3, 3, 3)\n    39\n    \"\"\"\n    if r == 1:\n        return n * a\n    else:\n        return a * (1 - r ** n) / (1 - r)", "def totient(n):\n    \"\"\"\n    Compute Euler's Totient function φ(n), the count of integers up to n that are coprime with n.\n    \n    Parameters:\n    - n (int): The number for which to calculate the totient function.\n    \n    Returns:\n    - int: The value of φ(n).\n    \n    Examples:\n    >>> totient(9)\n    6\n    \"\"\"\n    return sp.totient(n)", "def algebraic_power(expression, exponent):\n    \"\"\"\n    Calculate and simplify high powers of algebraic expressions.\n    \n    Parameters:\n        expression (str): The algebraic expression as a string.\n        exponent (int): The power to which the expression is raised.\n        \n    Returns:\n        Simplified form of the expression raised to the given power.\n    \n    Examples:\n        >>> algebraic_power(\"x + 1\", 2)\n        x**2 + 2*x + 1\n    \"\"\"\n    x = symbols('x')\n    expanded_expr = (eval(expression))**exponent\n    return simplify(expanded_expr)", "def power_properties(base, exponent, cycle_length=None):\n    \"\"\"\n    Determines properties of powers like last digit or cycles in the power sequence.\n    \n    Parameters:\n    - base (int): The base of the expression.\n    - exponent (int): The exponent to which the base is raised.\n    - cycle_length (int, optional): The length of the cycle to explore for powers properties.\n    Returns:\n    - properties (dict): A dictionary containing properties such as last_digit and periodicity.\n    \n    Examples:\n    >>> power_properties(2, 13)\n    {'last_digit': 2}\n    >>> power_properties(3, 10, 4)\n    {'last_digit': 1, 'periodicity': ['3', '9', '7', '1']}\n    \"\"\"\n    results = {}\n    if cycle_length:\n        periodicity = [(base**i) % 10 for i in range(1, cycle_length + 1)]\n        results['periodicity'] = periodicity\n    last_digit = (base**exponent) % 10\n    results['last_digit'] = last_digit\n    return results", "def simplify_exponential_expression(base, exponent):\n    \"\"\"\n    Simplifies expressions involving powers using properties of exponents.\n    Parameters:\n    - base (int, float, Fraction): The base of the operation.\n    - exponent (int, float, Fraction): The power to which the base is raised.\n    Returns:\n    - simplified result based on the exponent rules.\n    Examples:\n    >>> simplify_exponential_expression(2, -3)\n    0.125\n    >>> simplify_exponential_expression(-3, 2)\n    9\n    \"\"\"\n    import fractions\n    if isinstance(base, fractions.Fraction) or isinstance(exponent, fractions.Fraction):\n        result = fractions.Fraction(base) ** fractions.Fraction(exponent)\n    else:\n        result = base ** exponent\n    return result"], "Perfect Squares": ["def is_perfect_square(n):\n    \"\"\"\n    Check if a number is a perfect square.\n    Parameters:\n        n (int): The number to check.\n    Returns:\n        bool: True if n is a perfect square, False otherwise.\n    \"\"\"\n    if n < 0:\n        return False\n    root = math.isqrt(n)\n    return root * root == n", "def generate_perfect_squares(start, end):\n    \"\"\"\n    Generate a list of perfect squares between start and end (inclusive).\n    \n    Parameters:\n        start (int): The start of the range.\n        end (int): The end of the range.\n    \n    Returns:\n        list: List of perfect squares within the given range.\n    \n    Example:\n        >>> generate_perfect_squares(1, 100)\n        [1, 4, 9, 16, 25, 36, 49, 64, 81, 100]\n    \"\"\"\n    root_start = math.ceil(math.sqrt(start))\n    root_end = math.floor(math.sqrt(end))\n    return [x * x for x in range(root_start, root_end + 1)]", "def generate_pythagorean_triples(limit):\n    \"\"\"\n    Generate a list of Pythagorean triples up to a given limit.\n    Parameters:\n    - limit (int): The maximum value for the hypotenuse.\n    Returns:\n    - List[tuple]: A list of tuples, each containing a Pythagorean triple (a, b, c).\n    Examples:\n    >>> generate_pythagorean_triples(15)\n    [(3, 4, 5), (6, 8, 10), (5, 12, 13)]\n    \"\"\"\n    triples = []\n    for c in range(5, limit + 1):\n        for a in range(3, int(c/2) + 1):\n            b = math.sqrt(c * c - a * a)\n            if b == int(b):\n                triples.append((a, int(b), c))\n    return triples", "def find_next_perfect_square(n):\n    \"\"\"\n    Find the smallest perfect square greater than a given number.\n    Parameters:\n    - n (int): The number to exceed.\n    Returns:\n    - int: The next perfect square.\n    Examples:\n    >>> find_next_perfect_square(15)\n    16\n    >>> find_next_perfect_square(25)\n    36\n    \"\"\"\n    root = int(math.sqrt(n)) + 1\n    return root ** 2", "def is_product_perfect_square(*args):\n    \"\"\"\n    Check if the product of given integers is a perfect square.\n    Parameters:\n        *args (int): A variable-length list of integers.\n    Returns:\n        bool: True if the product is a perfect square, False otherwise.\n    Example:\n        >>> is_product_perfect_square(2, 8)\n        True\n        >>> is_product_perfect_square(3, 5, 2)\n        False\n    \"\"\"\n    product = math.prod(args)\n    root = math.isqrt(product)\n    return root * root == product", "def consecutive_square_difference(n):\n    \"\"\"\n    Calculate the difference between squares of consecutive integers up to n.\n    \n    Parameters:\n        n (int): The upper limit of the integer range (inclusive).\n    \n    Returns:\n        list of tuples: Each tuple contains (n, (n+1)^2 - n^2).\n    \"\"\"\n    return [(x, (x+1)**2 - x**2) for x in range(1, n)]", "def perfect_square_proximity(number, tolerance):\n    \"\"\"\n    Identify if the given number is within the specified tolerance of being a perfect square.\n    \n    Parameters:\n    number (int): The target number.\n    tolerance (int): The tolerance within which the proximity to a perfect square is acceptable.\n    \n    Returns:\n    bool: True if the number is within the specified tolerance to being a perfect square, False otherwise.\n    \n    Examples:\n    >>> perfect_square_proximity(27, 2)\n    True  # Since 25 is a perfect square and |27-25| <= 2\n    >>> perfect_square_proximity(50, 1)\n    False  # Since the nearest perfect square (49 or 64) has a difference greater than 1\n    \"\"\"\n    root = math.isqrt(number)\n    proximal_square_low = root * root\n    proximal_square_high = (root + 1) * (root + 1)\n    return abs(proximal_square_low - number) <= tolerance or abs(proximal_square_high - number) <= tolerance", "def last_digit_perfect_squares(limit):\n    \"\"\"\n    Identify perfect squares up to a certain limit and their last digits.\n    Parameters:\n    - limit (int): The upper limit to which calculation is done.\n    Returns:\n    - dict: A dictionary with keys as the last digit and values as lists of perfect squares up to `limit` sharing that last digit.\n    \n    Examples:\n    >>> last_digit_perfect_squares(20)\n    {0: [0, 4, 9, 16], 1: [1], 4: [], 5: [25], 6: [36], 9: []}\n    \"\"\"\n    from collections import defaultdict\n    result = defaultdict(list)\n    for i in range(math.isqrt(limit) + 1):\n        sq = i * i\n        d = sq % 10\n        result[d].append(sq)\n    return dict(result)", "def difference_of_consecutive_squares(n):\n    \"\"\"\n    Compute the difference between squares of consecutive integers up to n.\n    \n    Parameters:\n        n (int): The limit of the consecutive numbers.\n    \n    Returns:\n        list: Differences between the squares of each pair of consecutive integers.\n        \n    Examples:\n        >>> difference_of_consecutive_squares(10)\n        [3, 5, 7, 9, 11, 13, 15, 17, 19]\n    \"\"\"\n    return [2 * i + 1 for i in range(1, n)]", "def perfect_squares_up_to(n):\n    \"\"\"\n    Generate all perfect squares less than or equal to `n`.\n    \n    Parameters:\n    -----------\n    n : int\n        Upper limit for the perfect square values.\n        \n    Returns:\n    --------\n    list\n        A list of all perfect squares ≤ `n`.\n    \n    Example:\n    --------\n    >>> perfect_squares_up_to(10)\n    [1, 4, 9]\n    \"\"\"\n    from math import isqrt\n    return [i*i for i in range(1, isqrt(n)+1)]", "def perfect_square_divisors(n):\n    \"\"\"\n    Find all perfect square divisors of n based on its prime factorization.\n    Parameters:\n        n (int): The number for which to find perfect square divisors.\n    \n    Returns:\n        list: List of all perfect square divisors of n.\n    \n    Example:\n        >>> perfect_square_divisors(72)\n        [1, 4, 9, 36]\n    \"\"\"\n    factors = factorint(n)\n    divisors = {1}\n    for p, exp in factors.items():\n        # Since we want perfect squares, consider only even exponents\n        for e in range(2, exp+1, 2):  # Step by 2 to maintain even exponents\n            divisors.add(p ** e)\n    return sorted(divisors)", "def consecutive_perfect_squares_difference(n):\n    \"\"\"\n    Calculate and return differences between the first `n` consecutive perfect squares.\n    \n    Parameters:\n        n (int): Number of consecutive perfect squares to consider.\n        \n    Returns:\n        list: Differences between consecutive perfect squares.\n    \n    Examples:\n        >>> consecutive_perfect_squares_difference(5)\n        [3, 5, 7, 9]\n    \"\"\"\n    squares = [i * i for i in range(1, n + 1)]\n    differences = [squares[i] - squares[i-1] for i in range(1, n)]\n    return differences", "def list_perfect_squares(a, b):\n    \"\"\"\n    List all perfect squares within the range [a, b].\n    Parameters:\n        a (int): The lower bound of the range (inclusive).\n        b (int): The upper bound of the range (inclusive).\n    Returns:\n        List[int]: A list containing all the perfect squares within the range.\n    \"\"\"\n    if a > b:\n        return []\n    # Find smallest square number >= a\n    start = math.ceil(math.sqrt(a))\n    end = math.floor(math.sqrt(b))\n    return [i * i for i in range(start, end + 1)]", "def perfect_squares_range(lower, upper):\n    \"\"\"\n    Compute the number of perfect squares between two integer bounds using properties of consecutive squares.\n    \n    Parameters:\n    -----------\n    lower : int\n        The lower inclusive bound of the range.\n    upper : int\n        The upper inclusive bound of the range.\n    \n    Returns:\n    --------\n    int\n        The number of perfect squares in the range [lower, upper].\n    \n    Example:\n    --------\n    >>> perfect_squares_range(1, 100)\n    10\n    \"\"\"\n    from math import isqrt\n    lower_bound = isqrt(lower)\n    upper_bound = isqrt(upper)\n    if lower_bound * lower_bound < lower:\n        lower_bound += 1\n    return max(0, upper_bound - lower_bound + 1)", "def last_digit_of_squares():\n    \"\"\"\n    Lists the possible last digits of perfect squares in a decimal system.\n    Returns:\n        set: A set containing digits that are the last digits of a perfect square.\n    \"\"\"\n    return {i * i % 10 for i in range(10)}"], "Factors and Multiples": ["def prime_factors(n):\n    \"\"\"\n    Compute the prime factors of a given number along with their exponents.\n    Parameters:\n        n (int): The integer to be factorized.\n    \n    Returns:\n        dict: Dictionary with prime factors as keys and their exponents as values.\n    \n    Examples:\n        >>> prime_factors(56)\n        {2: 3, 7: 1}\n        >>> prime_factors(360)\n        {2: 3, 3: 2, 5: 1}\n    \"\"\"\n    return factorint(n)", "def lcm(a, b):\n    \"\"\"\n    Compute the least common multiple of two numbers.\n    Parameters:\n        a (int): The first integer.\n        b (int): The second integer.\n    \n    Returns:\n        int: The least common multiple of a and b.\n    \n    Examples:\n        >>> lcm(12, 15)\n        60\n        >>> lcm(5, 7)\n        35\n    \"\"\"\n    return abs(a * b) // gcd(a, b)", "def compute_gcd(a, b):\n    \"\"\"Compute the greatest common divisor (GCD) of two numbers a and b.\n    \n    Parameters:\n        a (int): First number.\n        b (int): Second number.\n    \n    Returns:\n        int: The GCD of a and b.\n    \n    Examples:\n        >>> compute_gcd(48, 180)\n        12\n    \"\"\"\n    from math import gcd\n    return gcd(a, b)", "def list_divisors(n):\n    \"\"\"List all divisors of the given integer n.\n    \n    Parameters:\n        n (int): The number to find divisors for.\n    \n    Returns:\n        List[int]: List containing all the divisors of n.\n    \n    Examples:\n        >>> list_divisors(28)\n        [1, 2, 4, 7, 14, 28]\n    \"\"\"\n    from math import isqrt\n    divisors = set()\n    for i in range(1, isqrt(n) + 1):\n        if n % i == 0:\n            divisors.add(i)\n            divisors.add(n // i)\n    return sorted(divisors)", "def gcd(x, y):\n    \"\"\"\n    Compute the greatest common divisor of two numbers x and y.\n    \n    Parameters:\n    x : int\n        First number.\n    y : int\n        Second number.\n    \n    Returns:\n    int\n        The greatest common divisor of x and y.\n    \n    Examples:\n    >>> gcd(12, 18)\n    6\n    >>> gcd(5, 13)\n    1\n    \"\"\"\n    while y:\n        x, y = y, x % y\n    return x", "def check_prime(number):\n    \"\"\"\n    Check if a number is a prime number.\n    Parameters\n    ----------\n    number : int\n        The integer to check for primality.\n    Returns\n    -------\n    is_prime : bool\n        True if number is prime, False otherwise.\n    \n    Examples\n    --------\n    >>> check_prime(29)\n    True\n    \n    >>> check_prime(30)\n    False\n    \"\"\"\n    return isprime(number)", "def gcd_lcm_calculator(*numbers):\n    \"\"\"\n    Calculate the Greatest Common Divisor (GCD) and the Least Common Multiple (LCM) for a set of integers.\n    \n    Parameters:\n        numbers (int): A sequence of integers for which to compute the GCD and LCM.\n    \n    Returns:\n        tuple: A tuple containing two elements; the first is the GCD and the second is the LCM of the given integers.\n    Examples:\n        >>> gcd_lcm_calculator(8, 12)\n        (4, 24)\n        >>> gcd_lcm_calculator(18, 34, 56)\n        (2, 2856)\n    \"\"\"\n    from math import gcd\n    from functools import reduce\n    \n    def lcm(a, b):\n        return abs(a*b) // gcd(a, b)\n    \n    overall_gcd = reduce(gcd, numbers)\n    overall_lcm = reduce(lcm, numbers, 1)\n    \n    return (overall_gcd, overall_lcm)", "def list_prime_factors(n):\n    \"\"\"List all prime factors of the given integer n.\n    \n    Parameters:\n        n (int): The number to find prime factors for.\n    \n    Returns:\n        List[int]: List containing all the prime factors of n.\n    \n    Examples:\n        >>> list_prime_factors(360)\n        [2, 3, 5]\n    \"\"\"\n    from sympy import primefactors\n    return primefactors(n)", "def are_coprime(x, y):\n    \"\"\"\n    Check if two numbers are coprime (i.e., their GCD is 1).\n    \n    Parameters:\n    x : int\n        First number.\n    y : int\n        Second number.\n    \n    Returns:\n    bool\n        True if the numbers are coprime, else False.\n    \n    Examples:\n    >>> are_coprime(5, 9)\n    True\n    >>> are_coprime(12, 18)\n    False\n    \"\"\"\n    return gcd(x, y) == 1", "def is_perfect_square(n):\n    \"\"\"\n    Determine if a number is a perfect square.\n    Parameters:\n    n (int): The number to check.\n    Returns:\n    bool: True if n is a perfect square, otherwise False.\n    Examples:\n    >>> is_perfect_square(16)\n    True\n    >>> is_perfect_square(14)\n    False\n    \"\"\"\n    sqrt_n = int(math.sqrt(n))\n    return sqrt_n * sqrt_n == n", "def get_factors(n):\n    \"\"\"\n    Compute all factors of a given number.\n    Parameters:\n    n (int): The number to find factors for.\n    Returns:\n    List[int]: A list of all positive factors of n.\n    Examples:\n    >>> get_factors(28)\n    [1, 2, 4, 7, 14, 28]\n    \"\"\"\n    factors = set()\n    for i in range(1, int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            factors.add(i)\n            factors.add(n // i)\n    return sorted(factors)", "def gcd_multiple(*numbers):\n    \"\"\"\n    Compute the greatest common divisor (GCD) of multiple numbers.\n    \n    Parameters:\n    numbers : tuple\n        A tuple containing the numbers.\n    \n    Returns:\n    int\n        The GCD of the provided numbers.\n    \n    Examples:\n    >>> gcd_multiple(24, 36, 48)\n    12\n    >>> gcd_multiple(21, 35)\n    7\n    \"\"\"\n    return reduce(gcd, numbers)", "def get_multiples_in_range(base, start, end):\n    \"\"\"\n    List all multiples of a given base number within a specified range.\n    Parameters:\n    base (int): The base number whose multiples are to be found.\n    start (int): The starting point of the range (inclusive).\n    end (int): The ending point of the range (inclusive).\n    Returns:\n    List[int]: A list of all multiples of base within the range [start, end].\n    Examples:\n    >>> get_multiples_in_range(3, 1, 20)\n    [3, 6, 9, 12, 15, 18]\n    \"\"\"\n    start = ((start + base - 1) // base) * base  # Round start up to the nearest multiple of base\n    return list(range(start, end + 1, base))", "def lcm_multiple(*numbers):\n    \"\"\"\n    Compute the least common multiple (LCM) of multiple numbers.\n    \n    Parameters:\n    numbers : tuple\n        A tuple containing the numbers.\n    \n    Returns:\n    int\n        The LCM of the provided numbers.\n    \n    Examples:\n    >>> lcm_multiple(5, 10, 20)\n    20\n    >>> lcm_multiple(7, 11)\n    77\n    \"\"\"\n    return reduce(lcm, numbers)", "def prime_factors(n):\n    \"\"\"\n    Returns the prime factorization of the given integer `n` as a dictionary\n    where keys are the prime factors and values are the corresponding exponents.\n    \n    Parameters:\n    n : int\n        The integer to factorize.\n    \n    Returns:\n    dict\n        A dictionary of prime factors with their exponents.\n    \n    Examples:\n    >>> prime_factors(18)\n    {2: 1, 3: 2}\n    >>> prime_factors(100)\n    {2: 2, 5: 2}\n    \"\"\"\n    factors = {}\n    # Check the number of 2s in n\n    while n % 2 == 0:\n        factors[2] = factors.get(2, 0) + 1\n        n //= 2\n    # n must be odd at this point, thus a skip of 2 is possible\n    for i in range(3, int(math.sqrt(n)) + 1, 2):\n        while (n % i == 0):\n            factors[i] = factors.get(i, 0) + 1\n            n //= i\n    # This condition is to check if n is a prime number greater than 2\n    if n > 2:\n        factors[n] = 1\n    return factors", "def extended_gcd_lcm_calc(numbers):\n    \"\"\"\n    Calculate the gcd and lcm of a list of numbers using the reduce function.\n    Parameters:\n        numbers (list): List of integers.\n    \n    Returns:\n        tuple: (gcd, lcm) of the list of numbers.\n    \n    Examples:\n        >>> extended_gcd_lcm_calc([48, 180, 640])\n        (4, 5760)\n        >>> extended_gcd_lcm_calc([21, 7, 14])\n        (7, 42)\n    \"\"\"\n    gcd_result = reduce(gcd, numbers)\n    lcm_result = reduce(lcm, numbers)\n    return gcd_result, lcm_result"], "Integers Properties": ["def modular_inverse(a, m):\n    \"\"\"\n    Computes the modular inverse of a under modulo m using the Extended Euclidean Algorithm.\n    Parameters:\n        a (int): The number to find the inverse of.\n        m (int): The modulus.\n    Returns:\n        int: The modular inverse of a modulo m if it exists. Returns None if the modular inverse does not exist.\n    Example:\n        >>> modular_inverse(3, 11)\n        4\n    \"\"\"\n    from sympy.core.numbers import igcdex\n    g, x, y = igcdex(a, m)\n    if g != 1:\n        return None  # No modular inverse if a and m are not coprime\n    else:\n        return x % m", "def check_primality(number):\n    \"\"\"\n    Checks if an integer is a prime number.\n    Parameters:\n        number (int): The integer to check for primality.\n    Returns:\n        bool: True if the integer is prime, otherwise False.\n    Example:\n        >>> check_primality(29)\n        True\n    \"\"\"\n    return isprime(number)", "def all_factors(n):\n    \"\"\"\n    Generate all factors of a given integer.\n    \n    Parameters:\n        n (int): The integer to find factors of.\n    \n    Returns:\n        list: A sorted list of all factors of n.\n    \n    Examples:\n        >>> all_factors(30)\n        [1, 2, 3, 5, 6, 10, 15, 30]\n    \"\"\"\n    return sorted(list(sympy.divisors(n)))", "def all_divisors(number):\n    \"\"\"\n    Returns all divisors of a given integer.\n    Parameters:\n        number (int): The integer to find divisors for.\n    Returns:\n        list: A list of all divisors of the integer.\n    Example:\n        >>> all_divisors(28)\n        [1, 2, 4, 7, 14, 28]\n    \"\"\"\n    return divisors(number)", "def prime_factors(number):\n    \"\"\"\n    Returns the prime factors of a given integer.\n    Parameters:\n        number (int): The integer to factorize.\n    \n    Returns:\n        list: A list of prime factors of the integer.\n    Example:\n        >>> prime_factors(60)\n        [2, 2, 3, 5]\n    \"\"\"\n    i = 2\n    factors = []\n    while i * i <= number:\n        if number % i:\n            i += 1\n        else:\n            number //= i\n            factors.append(i)\n    if number > 1:\n        factors.append(number)\n    return factors", "def count_modular_solutions(f, g, modulus):\n    \"\"\"\n    Counts the number of solutions to the equation f(x) ≡ g(x) (mod modulus).\n    Parameters:\n        f (function): A Python function representing the left-hand side of the equation.\n        g (function): A Python function representing the right-hand side of the equation.\n        modulus (int): The modulus for the equivalence.\n    Returns:\n        int: The number of solutions x that satisfy the equation under the given modulus.\n    Example:\n        >>> f = lambda x: x**2\n        >>> g = lambda x: 1\n        >>> count_modular_solutions(f, g, 10)\n        3\n    \"\"\"\n    count = 0\n    for x in range(modulus):\n        if f(x) % modulus == g(x) % modulus:\n            count += 1\n    return count", "def modular_exponentiation(base, exponent, modulus):\n    \"\"\"\n    Perform modular exponentiation (base^exponent % modulus).\n    Parameters:\n        base (int): The base of the expression.\n        exponent (int): The exponent of the expression.\n        modulus (int): The modulus to apply.\n    Returns:\n        int: Result of (base^exponent) % modulus.\n    Example:\n        >>> modular_exponentiation(2, 10, 1000)\n        24\n    \"\"\"\n    return pow(base, exponent, modulus)", "def digit_analysis(n):\n    \"\"\"\n    Analyze the digits of a number and return various properties.\n    \n    Parameters:\n        n (int): The integer to analyze.\n    \n    Returns:\n        dict: A dictionary with keys 'digit_count', 'even_digit_count', 'odd_digit_count', 'max_digit', 'min_digit'.\n    \n    Examples:\n        >>> digit_analysis(4562)\n        {'digit_count': 4, 'even_digit_count': 3, 'odd_digit_count': 1, 'max_digit': 6, 'min_digit': 2}\n    \"\"\"\n    digits = [int(d) for d in str(n)]\n    return {\n        'digit_count': len(digits),\n        'even_digit_count': sum(1 for d in digits if d % 2 == 0),\n        'odd_digit_count': sum(1 for d in digits if d % 2 != 0),\n        'max_digit': max(digits),\n        'min_digit': min(digits)\n    }", "def get_all_divisors(n):\n    \"\"\"\n    List all divisors of a given integer.\n    Parameters:\n        n (int): The integer to find divisors for.\n    Returns:\n        list: A list of all divisors of n.\n    Example:\n        >>> get_all_divisors(30)\n        [1, 2, 3, 5, 6, 10, 15, 30]\n    \"\"\"\n    return divisors(n)"], "Perfect Squares and Cubes": ["def is_perfect_square(n):\n    \"\"\"\n    Check if a number is a perfect square.\n    Parameters:\n    n (int): The number to check.\n    Returns:\n    bool: True if n is a perfect square, False otherwise.\n    Examples:\n    >>> is_perfect_square(16)\n    True\n    >>> is_perfect_square(17)\n    False\n    \"\"\"\n    root = math.isqrt(n)\n    return root * root == n", "def is_perfect_cube(n):\n    \"\"\"\n    Check if a number is a perfect cube.\n    Parameters:\n    n (int): The number to check.\n    Returns:\n    bool: True if n is a perfect cube, False otherwise.\n    Examples:\n    >>> is_perfect_cube(27)\n    True\n    >>> is_perfect_cube(28)\n    False\n    \"\"\"\n    root = round(n ** (1/3))\n    return root ** 3 == n", "def find_perfect_squares(min_val, max_val):\n    \"\"\"\n    Finds all perfect squares in a specified inclusive range.\n    \n    Parameters:\n        min_val (int): The minimum value of the range.\n        max_val (int): The maximum value of the range.\n    \n    Returns:\n        list: A list of all perfect squares within the given range [min_val, max_val].\n    \n    Examples:\n        >>> find_perfect_squares(1, 100)\n        [1, 4, 9, 16, 25, 36, 49, 64, 81, 100]\n    \"\"\"\n    start = int(math.ceil(math.sqrt(min_val)))\n    end = int(math.floor(math.sqrt(max_val)))\n    return [i**2 for i in range(start, end + 1)]", "def list_perfect_powers(upper_limit, power):\n    \"\"\"\n    Lists all perfect powers less than an upper limit.\n    Parameters:\n    upper_limit (int): The upper boundary for checking the numbers.\n    power (int): The power to check for (2 for squares, 3 for cubes, etc.).\n    Returns:\n    list: A list of all perfect powers under the specified upper limit.\n    \"\"\"\n    results = []\n    num = 1\n    while (result := num ** power) < upper_limit:\n        results.append(result)\n        num += 1\n    return results", "def is_perfect_power(n, power):\n    \"\"\"\n    Checks if a given number is a perfect power (e.g. square, cube).\n    Parameters:\n    n (int): The number to check.\n    power (int): The power to check against (e.g. 2 for squares, 3 for cubes).\n    Returns:\n    bool: True if n is a perfect power of the specified type, otherwise False.\n    \"\"\"\n    root = round(n ** (1 / power))\n    return root ** power == n", "def is_perfect_sixth_power(n):\n    \"\"\"\n    Check if a number is a perfect sixth power.\n    Parameters:\n    n (int): The number to check.\n    Returns:\n    bool: True if n is a perfect sixth power, False otherwise.\n    Examples:\n    >>> is_perfect_sixth_power(64)\n    True\n    >>> is_perfect_sixth_power(65)\n    False\n    \"\"\"\n    sixth_root = round(n ** (1/6))\n    return sixth_root ** 6 == n", "def generate_squares(n):\n    \"\"\"\n    Generates a list of all perfect squares less than or equal to `n`.\n    Parameters:\n        n (int): Upper bound for generating perfect squares.\n    Returns:\n    list: List of all perfect squares ≤ `n`.\n    Examples:\n        >>> generate_squares(10)\n        [0, 1, 4, 9]\n    \"\"\"\n    import math\n    return [i*i for i in range(int(math.sqrt(n)) + 1)]", "def perfect_powers(limit, power_type='square'):\n    \"\"\"\n    Identifies and lists all perfect power numbers up to a specified limit.\n    Parameters:\n    - limit (int): The upper boundary for numbers to check for being perfect powers.\n    - power_type (str): The type of power to check for ('square', 'cube', 'sixth').\n    Returns:\n    - list: A list of all perfect powers up to the specified limit.\n    Example:\n    >>> perfect_powers(100, 'square')\n    [1, 4, 9, 16, 25, 36, 49, 64, 81, 100]\n    >>> perfect_powers(100, 'cube')\n    [1, 8, 27, 64]\n    >>> perfect_powers(100, 'sixth')\n    [1, 64]\n    \"\"\"\n    if power_type == 'square':\n        exponent = 2\n    elif power_type == 'cube':\n        exponent = 3\n    elif power_type == 'sixth':\n        exponent = 6\n    else:\n        raise ValueError(\"Unsupported power_type. Choose 'square', 'cube', or 'sixth'.\")\n    result = []\n    number = 1\n    while number**exponent <= limit:\n        result.append(number**exponent)\n        number += 1\n    return result", "def generate_cubes(n):\n    \"\"\"\n    Generates a list of all perfect cubes less than or equal to `n`.\n    Parameters:\n        n (int): Upper bound for generating perfect cubes.\n    Returns:\n    list: List of all perfect cubes ≤ `n`.\n    Examples:\n        >>> generate_cubes(30)\n        [0, 1, 8, 27]\n    \"\"\"\n    return [i**3 for i in range(int(round(n**(1/3), 10)) + 1)]", "def nearest_perfect_power(n, direction=\"next\", power=2):\n    \"\"\"\n    Find the nearest perfect power greater ('next') or smaller ('previous') than a given number.\n    Parameters:\n    - n (int): The reference number.\n    - direction (str): 'next' for next perfect power, 'previous' for previous (default 'next').\n    - power (int): The power to consider (default 2 for squares, 3 for cubes, etc.).\n    Returns:\n    - int: The nearest perfect power in the specified direction.\n    Examples:\n    >>> nearest_perfect_power(15)\n    16\n    >>> nearest_perfect_power(28, direction='previous', power=3)\n    27\n    \"\"\"\n    increment = 0 if direction == \"previous\" else 1\n    candidate_root = round(n**(1/power)) + increment\n    candidate_power = candidate_root**power\n    if direction == \"previous\" and candidate_power > n:\n        candidate_root -= 1\n        candidate_power = candidate_root**power\n    return candidate_power", "def adjusted_perfect_squares(limit, adjustment):\n    \"\"\"\n    Computes and returns perfect squares with a constant adjustment under a specified limit.\n    Parameters:\n    limit (int): The upper limit for checking perfect squares.\n    adjustment (int): The number to subtract from each square before checking.\n    Returns:\n    list: Perfect squares with adjustment under the specified limit.\n    \"\"\"\n    results = []\n    num = 1\n    while (square := num ** 2) - adjustment < limit:\n        results.append(square - adjustment)\n        num += 1\n    return results"], "Divisibility": ["def is_divisible(n, div):\n    \"\"\"\n    Check if the number `n` is divisible by the number `div`.\n    Parameters:\n    n (int): Number to check divisibility for.\n    div (int): Divisor.\n    Returns:\n    bool: True if `n` is divisible by `div`, False otherwise.\n    Examples:\n    >>> is_divisible(10, 5)\n    True\n    >>> is_divisible(13, 3)\n    False\n    \"\"\"\n    return n % div == 0", "def prime_factors(n):\n    \"\"\"\n    Determine prime factors of a given integer with their respective exponents.\n    Parameters:\n    n : int\n        The integer to factorize.\n    Returns:\n    dict\n        A dictionary where keys are the prime factors and values are their respective exponents.\n    Example:\n    >>> prime_factors(360)\n    {2: 3, 3: 2, 5: 1}\n    \"\"\"\n    return {int(p): e for p, e in sp.factorint(n).items()}", "def lcm(*numbers):\n    \"\"\"\n    Calculate the least common multiple (LCM) of a list of integers.\n    Parameters:\n        numbers (int): A series of integers for which the LCM is to be calculated.\n    Returns:\n        int: The least common multiple of the input numbers.\n    Examples:\n        >>> lcm(12, 15)\n        60\n        >>> lcm(2, 3, 5)\n        30\n    \"\"\"\n    def lcm_pair(a, b):\n        return abs(a*b) // gcd(a, b)\n    \n    return reduce(lcm_pair, numbers, 1)", "def find_divisors(n):\n    \"\"\"\n    Determine divisors of a given number.\n    Parameters:\n    n : int\n        The number to find divisors of\n    Returns:\n    list\n        List of divisors of n.\n    Example:\n    >>> find_divisors(12)\n    [1, 2, 3, 4, 6, 12]\n    \"\"\"\n    return [x for x in range(1, n+1) if n % x == 0]", "def count_multiples_of_lcm(lcm_value, start, end):\n    \"\"\"\n    Count the number of multiples of LCM within a specified range.\n    Parameters:\n        lcm_value (int): The LCM value to use for counting multiples.\n        start (int): The start of the range (inclusive).\n        end (int): The end of the range (inclusive).\n    Returns:\n        int: The count of multiples of the LCM within the specified range.\n    Examples:\n        >>> count_multiples_of_lcm(24, 1, 100)\n        4\n        >>> count_multiples_of_lcm(15, 1, 45)\n        3\n    \"\"\"\n    if lcm_value == 0:\n        return 0\n    \n    count_start = (start + lcm_value - 1) // lcm_value\n    count_end = end // lcm_value\n    return count_end - count_start + 1", "def count_trailing_zeros_factorial(n):\n    \"\"\"\n    Counts the number of trailing zeros in n!.\n    Parameters:\n    n (int): The factorial number n! to analyze.\n    Returns:\n    int: The number of trailing zeros in `n!`.\n    Examples:\n    >>> count_trailing_zeros_factorial(5)\n    1\n    \"\"\"\n    i, zeros = 5, 0\n    while n >= i:\n        zeros += n // i\n        i *= 5\n    return zeros", "def lcm(x, y):\n    \"\"\"\n    Compute the least common multiple of two integers.\n    Parameters:\n    x : int\n        First integer.\n    y : int\n        Second integer.\n        \n    Returns:\n    int\n        The least common multiple of x and y.\n    Examples:\n    >>> lcm(12, 15)\n    60\n    \"\"\"\n    return abs(x * y) // gcd(x, y)", "def sum_of_digits(number):\n    \"\"\"\n    Calculates the sum of all digits in the given integer number.\n    Parameters:\n        number (int): The number whose digits will be summed.\n    Returns:\n        int: The sum of the digits.\n    Examples:\n    >>> sum_of_digits(123)\n    6\n    >>> sum_of_digits(104)\n    5\n    \"\"\"\n    return sum(int(digit) for digit in str(abs(number)))", "def gcd(x, y):\n    \"\"\"\n    Compute the greatest common divisor of two integers.\n    Parameters:\n    x : int\n        First integer.\n    y : int\n        Second integer.\n        \n    Returns:\n    int\n        The greatest common divisor of x and y.\n    Examples:\n    >>> gcd(48, 18)\n    6\n    \"\"\"\n    while y != 0:\n        (x, y) = (y, x % y)\n    return abs(x)", "def modular_power(base, exponent, modulus):\n    \"\"\"\n    Compute the power of a base number raised to an exponent under a given modulus using an efficient method.\n    Parameters:\n    base (int): The base number to be raised to the power.\n    exponent (int): The exponent to raise the base to.\n    modulus (int): The modulus under which to perform the operation.\n    Returns:\n    int: The result of (base ** exponent) % modulus.\n    Example:\n    >>> modular_power(2, 3, 5)\n    3\n    \"\"\"\n    return pow(base, exponent, modulus)", "def extended_euclidean(a, b):\n    \"\"\"\n    Extended Euclidean Algorithm to find integers x and y such that ax + by = gcd(a, b).\n    Parameters:\n    a : int\n        First integer.\n    b : int\n        Second integer.\n        \n    Returns:\n    tuple\n        Returns gcd(a, b), x, y where ax + by = gcd(a, b).\n    Examples:\n    >>> extended_euclidean(18, 30)\n    (6, -1, 1)\n    \"\"\"\n    x0, x1, y0, y1 = 0, 1, 1, 0\n    while b != 0:\n        q = a // b\n        a, b = b, a % b\n        x0, x1 = x1, x0 - q * x1\n        y0, y1 = y1, y0 - q * y1\n    return (a, x0, y0)", "def is_divisible(dividend, divisor):\n    \"\"\"\n    Determine if one number divides another without leaving a remainder.\n    \n    Parameters:\n    - dividend (int): The number to be divided.\n    - divisor (int): The number with which to divide the dividend.\n    \n    Returns:\n    - bool: True if dividend is divisible by divisor, False otherwise.\n    \n    Examples:\n    - is_divisible(10, 2) -> True\n    - is_divisible(10, 3) -> False\n    \"\"\"\n    if divisor == 0:\n        raise ValueError(\"Divisor cannot be zero.\")\n    return dividend % divisor == 0", "def divisors_from_factors(factor_dict):\n    \"\"\"\n    Calculate all divisors of a number given its prime factorization.\n    Parameters:\n    factor_dict : dict\n        A dictionary of prime factors and their respective exponents.\n    Returns:\n    list\n        Sorted list of all divisors of the number.\n    Examples:\n    >>> divisors_from_factors({2: 2, 3: 1, 5: 1})\n    [1, 2, 3, 4, 5, 6, 10, 12, 15, 20, 30, 60]\n    \"\"\"\n    from functools import reduce\n    from itertools import product\n    # Generate lists of powers for each prime factor\n    factors_powers = [\n        [factor ** exp for exp in range(power + 1)]\n        for factor, power in factor_dict.items()\n    ]\n    # Generate all combinations of these powers\n    all_combinations = product(*factors_powers)\n    # Multiply out each combination to get the divisors\n    divisors = sorted({reduce(lambda x, y: x * y, combination, 1) for combination in all_combinations})\n    return divisors", "def find_lcm(num1, num2):\n    \"\"\"\n    Find the least common multiple of two numbers.\n    \n    Parameters:\n    - num1 (int): First number.\n    - num2 (int): Second number.\n    \n    Returns:\n    - int: Least common multiple of num1 and num2.\n    \n    Examples:\n    - find_lcm(4, 6) -> 12\n    \"\"\"\n    return abs(num1 * num2) // gcd(num1, num2)", "def is_prime(n):\n    \"\"\"\n    Check if a given number is a prime number.\n    Parameters:\n    n : int\n        The number to check\n    Returns:\n    bool\n        True if n is prime, False otherwise.\n        \n    Example:\n    >>> is_prime(2)\n    True\n    >>> is_prime(4)\n    False\n    \"\"\"\n    if n == 1:\n        return False\n    elif n == 2:\n        return True\n    else:\n        for x in range(2, n):\n            if n % x == 0:\n                return False\n        return True", "def find_factors(num):\n    \"\"\"\n    Finds all factors of a given number.\n    \n    Parameters:\n    - num (int): The number to find factors for.\n    Returns:\n    - List[int]: A list of all factors of num.\n    \n    Examples:\n    - find_factors(12) -> [1, 2, 3, 4, 6, 12]\n    \"\"\"\n    factors = []\n    for potential_factor in range(1, int(num**0.5) + 1):\n        if num % potential_factor == 0:\n            factors.append(potential_factor)\n            if potential_factor != num // potential_factor:\n                factors.append(num // potential_factor)\n    factors.sort()\n    return factors", "def extract_last_n_digits(number, n):\n    \"\"\"\n    Extracts the last n digits of an integer.\n    Parameters:\n    - number (int): The number from which to extract digits.\n    - n (int): The number of last digits to extract.\n    Returns:\n    - int: The last n digits of the number.\n    \n    Examples:\n    >>> extract_last_n_digits(12345, 2)\n    45\n    >>> extract_last_n_digits(98765, 3)\n    765\n    \"\"\"\n    return abs(number) % (10 ** n)", "def prime_factors(number):\n    \"\"\"\n    Return the prime factors of a given number as a list.\n    Parameters:\n        number (int): The integer to factorize.\n    Returns:\n        list: A list containing the prime factors of the number.\n    Examples:\n        >>> prime_factors(100)\n        [2, 2, 5, 5]\n        >>> prime_formatted_factors(36)\n        [2, 2, 3, 3]\n    \"\"\"\n    factors = []\n    for prime in primefactors(number):\n        count = 0\n        temp = number\n        while temp % prime == 0:\n            temp //= prime\n            count += 1\n        factors.extend([prime] * count)\n    return factors", "def factorial_divisor_properties(n):\n    \"\"\"\n    Analyze properties related to the divisors of n factorial, like the number of trailing zeros.\n    \n    Parameters:\n        n (int): The number to calculate factorial of.\n    \n    Returns:\n        dict: A dictionary with keys 'trailing_zeros'.\n        \n    Examples:\n        >>> factorial_divisor_properties(5)\n        {'trailing_zeros': 1}\n        >>> factorial_divisor_properties(10)\n        {'trailing_zeros': 2}\n    \"\"\"\n    trailing_zeros = 0\n    power_of_five = 5\n    while n >= power_of_five:\n        trailing_zeros += n // power_of_five\n        power_of_five *= 5\n    return {'trailing_zeros': trailing_zeros}", "def modulo_operation(n, m):\n    \"\"\"\n    Perform modulo operations.\n    Parameters:\n    n : int\n        Numerator in division\n    m : int\n        Denominator in division\n    Returns:\n    int\n        Remainder when n is divided by m.\n    Example:\n    >>> modulo_operation(10, 3)\n    1\n    \"\"\"\n    return n % m", "def find_multiples(number, limit):\n    \"\"\"\n    Returns a list of multiples of a given number up to a specified limit.\n    \n    Parameters:\n    - number (int): The base number of which multiples are desired.\n    - limit (int): The upper bound for multiples.\n    \n    Returns:\n    - List[int]: A list containing multiples of the number up to the limit.\n    \n    Examples:\n    - find_multiples(3, 10) -> [3, 6, 9]\n    \"\"\"\n    return [number * i for i in range(1, limit // number + 1)]", "def divisibility_check(n, m):\n    \"\"\"\n    Check if the number n is divisible by m.\n    Parameters:\n    n : int\n        Numerator in division\n    m : int\n        Denominator in division\n    Returns:\n    bool\n        True if n is divisible by m, False otherwise.\n    Example:\n    >>> divisibility_check(10, 2)\n    True\n    >>> divisibility_check(11, 2)\n    False\n    \"\"\"\n    return n % m == 0", "def is_even(n):\n    \"\"\"\n    Check if a number is even.\n    Parameters:\n    n : int\n        The number to check\n    Returns:\n    bool\n        True if n is even, False otherwise.\n        \n    Example:\n    >>> is_even(2)\n    True\n    >>> is_even(3)\n    False\n    \"\"\"\n    return n % 2 == 0", "def satisfies_all_conditions(number, *divisors):\n    \"\"\"\n    Check if a given number is divisible by all provided divisors.\n    \n    Parameters:\n    - number (int): the number to check.\n    - divisors (int): a sequence of divisors to check against.\n    \n    Returns:\n    - bool: True if the number is divisible by all of the divisors, False otherwise.\n    \n    Example:\n    >>> satisfies_all_conditions(120, 4, 5, 6)\n    True\n    >>> satisfies_all_conditions(17, 4, 3)\n    False\n    \"\"\"\n    return all(number % divisor == 0 for divisor in divisors)", "def factorization(n):\n    \"\"\"\n    Factorize a given number into prime factors.\n    Parameters:\n    n : int\n        The number to factorize\n    Returns:\n    list\n        List of prime factors of n.\n        \n    Example:\n    >>> factorization(12)\n    [2, 2, 3]\n    \"\"\"\n    i = 2\n    factors = []\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n            factors.append(i)\n    if n > 1:\n        factors.append(n)\n    return factors", "def integer_division(n, m):\n    \"\"\"\n    Perform integer division and return quotient and remainder.\n    Parameters:\n    n : int\n        Numerator in division\n    m : int\n        Denominator in division\n    Returns:\n    tuple\n        Quotient when n is divided by m and remainder.\n    Example:\n    >>> integer_division(10, 3)\n    (3, 1)\n    \"\"\"\n    quotient = n // m\n    remainder = n % m\n    return quotient, remainder", "def lcm(a, b):\n    \"\"\"\n    Compute the Least Common Multiple of two integers a and b.\n    Parameters:\n        a (int): First integer.\n        b (int): Second integer.\n    Returns:\n        int: LCM of a and b.\n    Example:\n        >>> lcm(4, 5)\n        20\n    \"\"\"\n    from math import gcd\n    return abs(a * b) // gcd(a, b)", "def compute_factorial(n):\n    \"\"\"\n    Compute n!.\n    Parameters:\n    n : int\n        The integer to compute the factorial of.\n    Returns:\n    int\n        n!.\n    Example:\n    >>> compute_factorial(5)\n    120\n    \"\"\"\n    return factorial(n)", "def gcd(a, b):\n    \"\"\"\n    Calculate the Greatest Common Divisor of two integers, a and b.\n    Parameters:\n        a (int): First integer.\n        b (int): Second integer.\n    Returns:\n        int: GCD of a and b.\n    Example:\n        >>> gcd(8, 12)\n        4\n    \"\"\"\n    from math import gcd\n    return gcd(a, b)", "def divisor_properties(n):\n    \"\"\"\n    Calculate properties of divisors for n such as total number, sum, and product.\n    \n    Parameters:\n        n (int): The integer to analyze divisors for.\n    \n    Returns:\n        dict: A dictionary with keys 'number_of_divisors', 'sum_of_divisors', and 'product_of_divisors'.\n    \n    Examples:\n        >>> divisor_properties(30)\n        {'number_of_divisors': 8, 'sum_of_divisors': 72, 'product_of_divisors': 810000}\n    \"\"\"\n    divs = divisors(n)\n    num = len(divs)\n    sum_divs = sum(divs)\n    prod_divs = sympy.prod(divs)\n    return {'number_of_divisors': num, 'sum_of_divisors': sum_divs, 'product_of_divisors': prod_divs}", "def list_divisors(number):\n    \"\"\"\n    List all divisors of a given number.\n    Parameters:\n    number (int): The number whose divisors are to be found.\n    Returns:\n    list: A list of all divisors of the number.\n    Example:\n    >>> list_divisors(10)\n    [1, 2, 5, 10]\n    \"\"\"\n    if number <= 0:\n        raise ValueError(\"Number must be positive.\")\n    divisors = [1]\n    for i in range(2, int(number**0.5) + 1):\n        if number % i == 0:\n            divisors.extend([i, number // i])\n    if number != 1:\n        divisors.append(number)\n    return sorted(list(set(divisors)))"], "Multiples": ["def find_multiples_in_range(base, start, end):\n    \"\"\"\n    Generate all multiples of a base number within a specified range.\n    \n    Parameters:\n    - base (int): The base number of which multiples are to be found.\n    - start (int): The start of the range.\n    - end (int): The end of the range (inclusive).\n    \n    Returns:\n    - list: A list of multiples of the base number within the specified range.\n    \n    Examples:\n    >>> find_multiples_in_range(3, 100, 200)\n    [102, 105, 108, ..., 198]\n    >>> find_multiples_in_range(5, 1, 25)\n    [5, 10, 15, 20, 25]\n    \"\"\"\n    if base == 0:\n        raise ValueError(\"Base cannot be zero.\")\n    return [i for i in range(max(base, start - start % base), end + 1, base) if i >= start]", "def lcm_two_numbers(a, b):\n    \"\"\"\n    Compute the Least Common Multiple (LCM) of two integers using the Greatest Common Divisor (GCD).\n    \n    Parameters:\n    - a (int): The first integer.\n    - b (int): The second integer.\n    \n    Returns:\n    - int: The LCM of the two integers.\n    \n    Examples:\n    --------\n    >>> lcm_two_numbers(12, 15)\n    60\n    >>> lcm_two_numbers(5, 10)\n    10\n    \"\"\"\n    return abs(a*b) // math.gcd(a, b)", "def list_multiples(base, lower_bound, upper_bound):\n    \"\"\"\n    Generates a list of multiples of the given number within a specified range.\n    Parameters:\n    -----------\n    base : int\n        The base number whose multiples are to be found.\n    lower_bound : int\n        The lower boundary of the range (inclusive).\n    upper_bound : int\n        The upper boundary of the range (inclusive).\n    Returns:\n    --------\n    list\n        A list of multiples of the base number within the specified range.\n    Examples:\n    ---------\n    >>> list_multiples(7, 1, 100)\n    [7, 14, 21, 28, 35, 42, 49, 56, 63, 70, 77, 84, 91, 98]\n    \"\"\"\n    from math import ceil\n    start = ceil(lower_bound / base) * base\n    return [n for n in range(start, upper_bound + 1, base) if n >= lower_bound]", "def nearest_multiple(number, base):\n    \"\"\"\n    Find the nearest multiple of 'base' for the given 'number'.\n    \n    Parameters:\n    - number (int): The number to find the nearest multiple to.\n    - base (int): The base number.\n    \n    Returns:\n    - tuple: The nearest lower and higher multiples of 'base' to 'number'.\n    \n    Examples:\n    >>> nearest_multiple(28, 5)\n    (25, 30)\n    \"\"\"\n    lower = number - (number % base)\n    higher = lower + base if number % base != 0 else lower\n    return (lower, higher)", "def generate_multiples(base, limit):\n    \"\"\"\n    Generate a list of multiples of a given number up to a specified limit.\n    Parameters\n    ----------\n    base : int\n        The number for which multiples are to be generated.\n    limit : int\n        The maximum value upto which multiples should be calculated.\n    Returns\n    -------\n    list of ints\n        List containing the multiples of the base number up to the limit.\n    Examples\n    --------\n    >>> generate_multiples(3, 30)\n    [3, 6, 9, 12, 15, 18, 21, 24, 27, 30]\n    >>> generate_multiples(5, 50)\n    [5, 10, 15, 20, 25, 30, 35, 40, 45, 50]\n    \"\"\"\n    return list(range(base, limit+1, base))", "def nth_multiple(n, base):\n    \"\"\"\n    Calculate the nth multiple of the base number.\n    \n    Parameters:\n    - n (int): The nth multiple to find.\n    - base (int): The base number.\n    \n    Returns:\n    - int: The nth multiple of the base number.\n    \n    Examples:\n    >>> nth_multiple(4, 3)\n    12\n    >>> nth_multiple(5, 10)\n    50\n    \"\"\"\n    return n * base", "def is_multiple(base, factor):\n    \"\"\"\n    Check if the first integer is a multiple of the second integer.\n    \n    Parameters:\n        base (int): The number to be checked.\n        factor (int): The potential factor of the base number.\n    \n    Returns:\n        bool: True if base is a multiple of factor, False otherwise.\n    \n    Examples:\n        >>> is_multiple(20, 5)\n        True\n        >>> is_multiple(14, 5)\n        False\n        \n    Notes:\n        A number A is considered a multiple of number B if there exists an integer X such that B * X = A.\n    \"\"\"\n    return base % factor == 0"], "Modular Arithmetic": ["def modular_add(a, b, m):\n    \"\"\"\n    Perform modular addition.\n    Parameters:\n    - a (int): The first operand.\n    - b (int): The second operand.\n    - m (int): The modulus.\n    Returns:\n    int: The result of (a + b) % m.\n    \"\"\"\n    return (a + b) % m", "def mod_pow(base, exponent, modulus):\n    \"\"\"\n    Compute the power of a number with a modulus using efficient exponentiation.\n    \n    Parameters:\n        base (int): Base of the power.\n        exponent (int): Exponent of the power.\n        modulus (int): Modulus to use.\n    \n    Returns:\n        int: The result of (base^exponent) mod modulus.\n    \n    Example:\n        mod_pow(2, 5, 13) returns 6 because (2^5) % 13 = 32 % 13 = 6.\n    \"\"\"\n    return pow(base, exponent, modulus)", "def get_modular_inverse(a, m):\n    \"\"\"\n    Computes the modular inverse of `a` under the modulus `m` using the Extended Euclidean Algorithm.\n    Parameters:\n    a (int): The number to find the inverse for.\n    m (int): The modulus.\n    Returns:\n    int: The modular inverse of `a` under `m`.\n    Raises:\n    ValueError: If no modular inverse exists, which occurs if `a` and `m` are not coprime.\n    Example:\n    >>> get_modular_inverse(3, 11)\n    4\n    \"\"\"\n    return mod_inverse(a, m)", "def mod_add(a, b, modulus):\n    \"\"\"\n    Perform modular addition.\n    \n    Parameters:\n        a (int): First operand.\n        b (int): Second operand.\n        modulus (int): Modulus to use for the operation.\n    \n    Returns:\n        int: The result of (a + b) mod modulus.\n    \n    Example:\n        mod_add(5, 3, 7) returns 1 because (5 + 3) % 7 = 8 % 7 = 1.\n    \"\"\"\n    return (a + b) % modulus", "def modular_add(a, b, mod):\n    \"\"\"\n    Calculate the sum of two numbers under a given modulus.\n    \n    Parameters:\n    a (int): The first number.\n    b (int): The second number.\n    mod (int): The modulus to apply.\n    \n    Returns:\n    int: The result of (a + b) % mod.\n    \n    Examples:\n    >>> modular_add(3, 5, 7)\n    1\n    >>> modular_add(6, 7, 5)\n    3\n    \"\"\"\n    return (a + b) % mod", "def check_cyclic_pattern(base, mod):\n    \"\"\"\n    Check for a cyclic pattern in modulo operations with a given base and modulus.\n    Parameters\n    ----------\n    base : int\n        The base number.\n    mod : int\n        The modulus.\n    Returns\n    -------\n    List[int]\n        The repeating pattern in the sequence base^k (mod m) for k = 1, 2, ...\n    Examples\n    --------\n    >>> check_cyclic_pattern(2, 3)\n    [2, 1]\n    \"\"\"\n    pattern = []\n    result = 1\n    for _ in range(mod):\n        result = (result * base) % mod\n        if result in pattern:\n            break\n        pattern.append(result)\n    return pattern", "def solve_congruence(expression_1, expression_2, mod):\n    \"\"\"\n    Solve for a variable in a congruence equation.\n    Parameters\n    ----------\n    expression_1 : int or str\n        The first expression of the congruence equation.\n    expression_2 : int or str\n        The second expression of the congruence equation.\n    mod : int\n        The modulus.\n    Returns\n    -------\n    int\n        The solution to the congruence equation.\n    Examples\n    --------\n    >>> solve_congruence('x', 1, 3)\n    1\n    \"\"\"\n    expression_1 = simplify(expression_1)\n    expression_2 = simplify(expression_2)\n    return (expression_2 - expression_1) % mod", "def simplify_modular_expression(expression):\n    \"\"\"\n    Simplify a numerical expression with respect to mod.\n    \n    Parameters\n    ----------\n    expression : str\n        The expression to simplify.\n        \n    Returns\n    -------\n    int\n        The simplified result.\n        \n    Examples\n    --------\n    >>> simplify_modular_expression('2+3')\n    5\n    \"\"\"\n    return simplify(expression)", "def sum_modulo(elements, m):\n    \"\"\"\n    Calculate the sum of elements under modulo m.\n    Parameters:\n    - elements (list of int): The elements to sum.\n    - m (int): The modulus.\n    Returns:\n    - int: The sum of the given elements modulo m.\n    Examples:\n    >>> sum_modulo([1, 2, 3, 4], 5)\n    0\n    \"\"\"\n    return sum(elements) % m", "def calculate_modular_inverse(num, mod):\n    \"\"\"\n    Calculate the modular inverse of a number under a certain modulus.\n    Parameters\n    ----------\n    num : int\n        The number to find the inverse of.\n    mod : int\n        The modulus.\n    Returns\n    -------\n    int\n        The modular inverse of the number.\n    Examples\n    --------\n    >>> calculate_modular_inverse(3, 7)\n    5\n    \"\"\"\n    return mod_inverse(num, mod)", "def calculate_power_modulo(base, power, mod):\n    \"\"\"\n    Calculate the power of a number modulo a certain number.\n    Parameters\n    ----------\n    base : int\n        The base number.\n    power : int\n        The power to raise the base number to.\n    mod : int\n        The modulus.\n    Returns\n    -------\n    int\n        The result of base^power modulo mod.\n    Examples\n    --------\n    >>> calculate_power_modulo(5, 3, 2)\n    1\n    \"\"\"\n    return pow(base, power, mod)", "def find_factors(num):\n    \"\"\"\n    Find all factors of a number.\n    Parameters\n    ----------\n    num : int\n        The number to find factors of.\n    Returns\n    -------\n    List[int]\n        The list of factors of the number.\n    Examples\n    --------\n    >>> find_factors(20)\n    [1, 2, 4, 5, 10, 20]\n    \"\"\"\n    return [i for i in range(1, num + 1) if num % i == 0]", "def modular_operations(a, b, op='mod', m=1):\n    \"\"\"\n    Perform modular arithmetic operations such as addition, subtraction, multiplication, \n    and modulus between two numbers under a modulo m.\n    Parameters:\n    - a (int or float): The first operand.\n    - b (int or float): The second operand or the modulus.\n    - op (str): The operation type ('add', 'sub', 'mul', 'mod', 'div').\n    - m (int, optional): The modulo for the operation. Default is 1 for standard operations.\n    Returns:\n    - int or float: Result of the specified operation under modulo m.\n    Examples:\n    >>> modular_operations(10, 3, 'mod')\n    1\n    >>> modular_operations(5, 3, 'add', 7)\n    1\n    >>> modular_operations(4, 3, 'mul', 5)\n    2\n    \"\"\"\n    if op == 'add':\n        return (a + b) % m\n    elif op == 'sub':\n        return (a - b) % m\n    elif op == 'mul':\n        return (a * b) % m\n    elif op == 'mod':\n        return a % b\n    elif op == 'div' and b != 0:  # division mod might need to use multiplicative inverse\n        from sympy import mod_inverse\n        inv_b = mod_inverse(b, m)\n        return (a * inv_b) % m\n    else:\n        raise ValueError(\"Operation not supported or division by zero\")", "def calculate_gcd(num1, num2):\n    \"\"\"\n    Calculate the greatest common divisor (gcd) between two numbers.\n    Parameters\n    ----------\n    num1 : int\n        The first number.\n    num2 : int\n        The second number.\n    Returns\n    -------\n    int\n        The greatest common divisor of the two numbers.\n    Examples\n    --------\n    >>> calculate_gcd(20, 30)\n    10\n    \"\"\"\n    return gcd(num1, num2)"], "Factorials": ["def compute_factorial(n):\n    \"\"\"\n    Compute the factorial of a given non-negative integer n.\n    Parameters:\n    - n (int): A non-negative integer whose factorial is to be calculated.\n    Returns:\n    - int: The factorial of the integer n.\n    Example:\n    >>> compute_factorial(5)\n    120\n    >>> compute_factorial(0)\n    1\n    \"\"\"\n    if n < 0:\n        raise ValueError(\"Factorial is not defined for negative numbers.\")\n    return factorial(n)", "def factorial_properties(n, analysis_type=\"trailing_zeros\"):\n    \"\"\"\n    Analyze certain properties of factorial of a number n, such as calculating trailing zeros.\n    Parameters:\n    - n (int): The number whose factorial's properties are to be analyzed.\n    - analysis_type (str): Type of analysis to perform on factorial. Supported values are 'trailing_zeros'.\n    Returns:\n    - int: Result of the analysis based on the type specified.\n    Example:\n    >>> factorial_properties(5, \"trailing_zeros\")\n    1\n    >>> factorial_properties(20, \"trailing_zeros\")\n    4\n    \"\"\"\n    if analysis_type == \"trailing_zeros\":\n        # Count trailing zeros in n!\n        count = 0\n        i = 5\n        while n // i >= 1:\n            count += n // i\n            i *= 5\n        return count\n    else:\n        raise ValueError(\"Unsupported analysis type. Supported types: 'trailing_zeros'.\")", "def simplify_factorial_expression(n, m):\n    \"\"\"\n    Simplifies an expression of the form n! / m! given that n > m.\n    Parameters:\n    n (int): The numerator's factorial base, should be greater than m.\n    m (int): The denominator's factorial base, should be non-negative and less than n.\n    Returns:\n    int: The simplified result of n! / m!.\n    Examples:\n    >>> simplify_factorial_expression(5, 3)\n    20\n    >>> simplify_factorial_expression(6, 1)\n    720\n    Notes:\n    - If n == m, the result of the expression is 1 (since n! / n! = 1).\n    - This function uses an efficient method by only multiplying numbers from m+1 to n.\n    \"\"\"\n    if n < m:\n        raise ValueError(\"Numerator factorial base must be greater than the denominator factorial base\")\n    if m < 0:\n        raise ValueError(\"Factorial base must be non-negative\")\n    result = 1\n    for i in range(m + 1, n + 1):\n        result *= i\n    return result", "def factorial_gcd(a, b):\n    \"\"\"\n    Compute the greatest common divisor (GCD) of the factorials of two non-negative integers.\n    Parameters:\n    a : int\n        The first non-negative integer.\n    b : int\n        The second non-negative integer.\n    Returns:\n    int\n        GCD of the factorials of a and b.\n    Examples:\n    >>> factorial_gcd(5, 3)\n    6\n    >>> factorial_gcd(7, 7)\n    5040\n    \"\"\"\n    return factorial(min(a, b))  # GCD of a! and b! is min(a, b)!", "def compute_double_factorial(n):\n    \"\"\"\n    Compute the double factorial of a non-negative integer, denoted as n!!,\n    which is the product of positive integers up to n that have the same parity as n.\n    Parameters:\n    n : int\n        A non-negative integer to compute the double factorial for.\n    Returns:\n    int\n        Double factorial of the integer n.\n    Examples:\n    >>> compute_double_factorial(5)\n    15\n    >>> compute_double_factorial(6)\n    48\n    \"\"\"\n    if not isinstance(n, int) or n < 0:\n        raise ValueError(\"n must be a non-negative integer\")\n    if n == 0 or n == 1:\n        return 1\n    return n * compute_double_factorial(n-2)", "def simplify_factorial_expression(expression):\n    \"\"\"\n    Simplifies an expression involving factorials, particularly useful for expressions\n    that include division and multiplication of multiple factorial terms.\n    \n    Parameters:\n    expression (str): A string representing the mathematical expression to simplify,\n                      which can include factorial notation as `factorial(n)` where `n` can be any integer.\n    \n    Returns:\n    sympy.core.expr.Expr: The simplified form of the input expression.\n    \n    Examples:\n    >>> simplify_factorial_expression(\"factorial(5)/factorial(3)\")\n    20\n    \n    >>> simplify_factorial_expression(\"factorial(n)*factorial(n-1)/factorial(n+1)\")\n    factorial(n - 1)\n    \n    Notes:\n    The function uses SymPy's simplification utilities, which can handle symbolic expressions.\n    This function assumes a correct mathematical expression is passed as input.\n    \"\"\"\n    expr = simplify(expression)\n    return expr"], "Counting Digits": ["def count_digits(number):\n    \"\"\"\n    Count the number of digits in the given number.\n    Parameters:\n    number (int): The number whose digits are to be counted.\n    Returns:\n    int: The number of digits in the given number.\n    Examples:\n    >>> count_digits(123)\n    3\n    >>> count_digits(-12345)\n    5\n    \"\"\"\n    return len(str(abs(number)))", "def count_specific_digit_numbers(start, end, allowed_digits):\n    \"\"\"\n    Counts numbers within a range [start, end] that consist exclusively of the allowed digits.\n    \n    Parameters:\n    start (int): Starting value of the range.\n    end (int): Ending value of the range.\n    allowed_digits (set): A set of digits that are allowed in the numbers.\n    Returns:\n    int: Count of numbers only containing the allowed digits.\n    Examples:\n    >>> count_specific_digit_numbers(100, 500, {1, 2, 5})\n    31\n    \"\"\"\n    allowed_digits = set(map(str, allowed_digits))  # Convert digits to strings for comparison\n    count = 0\n    for num in range(start, end + 1):\n        if set(str(num)).issubset(allowed_digits):\n            count += 1\n    return count", "def count_digit_palindromes(start, end):\n    \"\"\"\n    Count the palindromic numbers within a specified numeric range.\n    Parameters:\n    start (int): The starting number of the range.\n    end (int): The ending number of the range.\n    Returns:\n    int: The count of palindromic numbers in the range.\n    Examples:\n    >>> count_digit_palindromes(100, 300)\n    9  # Example output, exact computation needs implementation.\n    \"\"\"\n    count = 0\n    for number in range(start, end + 1):\n        if str(number) == str(number)[::-1]:\n            count += 1\n    return count", "def count_numbers_in_range_with_property(min_value, max_value, property_checker):\n    \"\"\"\n    Counts the numbers in a given range that satisfy a specified property.\n    Parameters:\n    min_value (int): The minimum value of the range.\n    max_value (int): The maximum value of the range.\n    property_checker (callable): A function that applies a property to check on each number.\n    Returns:\n    int: The count of numbers satisfying 'property_checker'.\n    Examples:\n    >>> count_numbers_in_range_with_property(1, 600, lambda x: x % 2 == 0)\n    300\n    \"\"\"\n    return sum(1 for x in range(min_value, max_value + 1) if property_checker(x))", "def is_palindrome(number):\n    \"\"\"\n    Checks if a given integer is a palindrome.\n    Parameters:\n    number (int): The number to check.\n    Returns:\n    bool: True if 'number' is a palindrome, False otherwise.\n    Examples:\n    >>> is_palindrome(12321)\n    True\n    >>> is_palindrome(12345)\n    False\n    \"\"\"\n    num_str = str(number)\n    return num_str == num_str[::-1]", "def count_palindromic_times(limit_hour, limit_minute):\n    \"\"\"\n    Counts all the valid time combinations on a digital clock that are palindromes up to given hour and minute limits.\n    Parameters:\n    - limit_hour (int): Maximum hour limit (24-based or 12-based).\n    - limit_minute (int): Maximum minute limit (typically 60).\n    Returns:\n    - int: Count of valid palindromic times.\n    Examples:\n    >>> count_palindromic_times(24, 60)\n    16\n    >>> count_palindromic_times(12, 60)\n    34\n    \"\"\"\n    def is_palindrome(s):\n        return s == s[::-1]\n    count = 0\n    for hour in range(limit_hour):\n        for min in range(limit_minute):\n            time_str = f\"{hour:02d}:{min:02d}\"\n            time_str = time_str.replace(\":\", \"\")\n            if is_palindrome(time_str):\n                count += 1\n    return count", "def range_by_digit_count(digit_count):\n    \"\"\"\n    Provides the minimum and maximum numbers that comprise the range of numbers with the specified digit count.\n    Parameters:\n    digit_count (int): The specific digit count.\n    Returns:\n    tuple: A tuple containing the minimum and maximum numbers that have the specified digit count.\n    Examples:\n    >>> range_by_limit_count(3)\n    (100, 999)\n    \"\"\"\n    if digit_count < 1:\n        raise ValueError(\"digit_count must be at least 1\")\n    min_number = 10**(digit_count - 1)\n    max_number = 10**digit_count - 1\n    return (min_number, max_number)"], "Division and Remainders": ["def calculate_division_properties(dividend, divisor):\n    \"\"\"\n    Calculates the quotient and remainder of integer division.\n    Parameters:\n        dividend (int): The number to be divided.\n        divisor (int): The number by which to divide.\n    Returns:\n        tuple:\n        - quotient (int): Result of the integer division.\n        - remainder (int): The remainder left over when dividend is divided by divisor.\n    Examples:\n    >>> calculate_division_properties(10, 3)\n    (3, 1)\n    >>> calculate_division_properties(25, 4)\n    (6, 1)\n    \"\"\"\n    if divisor == 0:\n        raise ValueError(\"Divisor cannot be zero.\")\n    quotient = dividend // divisor\n    remainder = dividend % divisor\n    return quotient, remainder", "def modular_sub(a, b, modulus):\n    \"\"\"\n    Perform modular subtraction between two numbers.\n    Parameters:\n    a (int): First number.\n    b (int): Second number.\n    modulus (int): Modulus to be applied.\n    Returns:\n    int: Result of (a - b) % modulus\n    Examples:\n    >>> modular_sub(5, 3, 7)\n    2\n    \"\"\"\n    return (a - b) % modulus", "def find_remainder(n, m):\n    \"\"\"\n    Calculate the remainder when n is divided by m (n % m).\n    Parameters\n    ----------\n    n : int\n        The dividend.\n    m : int\n        The divisor.\n    Returns\n    -------\n    int\n        The remainder of the division of n by m (0 <= remainder < m).\n    Examples\n    --------\n    >>> find_remainder(10, 3)\n    1\n    >>> find_remainder(-10, 3)\n    2\n    \"\"\"\n    return n % m", "def modular_pow(base, exp, modulus):\n    \"\"\"\n    Efficiently compute (base ** exp) % modulus using exponentiation by squaring.\n    Parameters:\n    base (int): The base number.\n    exp (int): The exponent.\n    modulus (int): Modulus to be applied.\n    Returns:\n    int: Result of (base ** exp) % modulus\n    Examples:\n    >>> modular_pow(2, 10, 1000)\n    24\n    \"\"\"\n    result = 1\n    base = base % modulus\n    while exp > 0:\n        if exp % 2 == 1:\n            result = (result * base) % modulus\n        exp = exp >> 1\n        base = (base * base) % modulus\n    return result", "def factorial_mod(n, modulus):\n    \"\"\"\n    Compute factorial of n modulo a given modulus.\n    Parameters:\n    n (int): Number to compute factorial of.\n    modulus (int): Modulus to be applied to the factorial result.\n    Returns:\n    int: n! % modulus\n    Examples:\n    >>> factorial_mod(5, 7)\n    1\n    \"\"\"\n    result = 1\n    for i in range(2, n + 1):\n        result = (result * i) % modulus\n    return result\n    print(modular_add(5, 3, 7))   # Outputs 1\n    print(modular_sub(5, 3, 7))   # Outputs 2\n    print(modular_mult(3, 4, 5))  # Outputs 2\n    print(modular_div(8, 3, 5))   # Outputs 1\n    print(modular_pow(2, 10, 1000)) # Outputs 24\n    print(factorial_mod(5, 7))    # Outputs 1", "def positive_modular(a, b):\n    \"\"\"\n    Ensure the result of modular operation is positive.\n    \n    Parameters:\n        a (int): The number to be taken modulo of.\n        b (int): The modulus.\n        \n    Returns:\n        int: A positive remainder after division.\n        \n    Examples:\n        >>> positive_modular(-10, 3)\n        2\n    \"\"\"\n    return a % b", "def find_extreme_remainder(dividend, divisors, mode='max'):\n    \"\"\"\n    For a given dividend and list of divisors, find the divisor which yields the maximum or minimum remainder.\n    \n    Parameters:\n    dividend (int): The number to be divided.\n    divisors (list of int): A list of divisors.\n    mode (str): Either 'max' or 'min', determines whether to find the maximum or minimum remainder.\n    Returns:\n    dict: A dictionary with keys 'divisor', 'remainder', and 'extreme_value' showing the selected divisor, its remainder, and the value of the remainder.\n    Examples:\n    >>> find_extreme_remainder(10, [1, 2, 3, 4])\n    {'divisor': 3, 'remainder': 1, 'extreme_value': 1}\n    >>> find_extreme_remainder(10, [2, 3, 4], mode='min')\n    {'divisor': 2, 'remainder': 0, 'extreme_value': 0}\n    >>> find_extreme_remainder(10, [2, 3, 4], mode='max')\n    {'divisor': 3, 'remainder': 1, 'extreme_value': 1}\n    \"\"\"\n    if not divisors:\n        raise ValueError(\"Divisors list cannot be empty.\")\n    best_match = None\n    extreme_value = None\n    for divisor in divisors:\n        if divisor == 0:\n            continue\n        remainder = dividend % divisor\n        if (mode == 'max' and (extreme_value is None or remainder > extreme_value)) or (mode == 'min' and (extreme_value is None or remainder < extreme_value)):\n            best_match = divisor\n            extreme_value = remainder\n    return {'divisor': best_match, 'remainder': extreme_value, 'extreme_value': extreme_value}", "def modular_remainder(a, b):\n    \"\"\"\n    Calculate the remainder when one number is divided by another using modular arithmetic.\n    \n    Parameters:\n        a (int): The dividend\n        b (int): The divisor (non-zero)\n        \n    Returns:\n        int: The remainder after division\n        \n    Examples:\n        >>> modular_remainder(10, 3)\n        1\n        >>> modular_remainder(-10, 3)\n        2\n    \"\"\"\n    return a % b", "def modular_div(a, b, modulus):\n    \"\"\"\n    Perform modular division where result is a * (inverse of b modulo modulus).\n    Parameters:\n    a (int): Numerator.\n    b (int): Denominator to find the modular inverse of.\n    modulus (int): Modulus to be applied.\n    Returns:\n    int: Result of (a * modular_inverse(b, modulus)) % modulus\n    Examples:\n    >>> modular_div(8, 3, 5)\n    1\n    Note:\n    This function assumes that b has a modular inverse under the given modulus (modulus and b are coprime).\n    \"\"\"\n    from sympy import mod_inverse\n    return (a * mod_inverse(b, modulus)) % modulus", "def modular_power(base, exponent, modulus):\n    \"\"\"\n    Calculate the result of base raised to the power exponent, all under modulo of a specified number.\n    \n    Parameters:\n        base (int): The base of the exponentiation.\n        exponent (int): The exponent.\n        modulus (int): The modulus to reduce the large number.\n        \n    Returns:\n        int: The result of (base ** exponent) % modulus\n    \n    Examples:\n        >>> modular_power(2, 10, 1000)\n        24\n    \"\"\"\n    return pow(base, exponent, modulus)", "def find_modular_inverses(n, modulus):\n    \"\"\"\n    Finds all values x such that (x * n) % modulus == 1, i.e., modular inverses under a given modulus.\n    Parameters:\n        n (int): The integer number for which to find the modular inverses.\n        modulus (int): The modulus under which the inverses are calculated.\n    Returns:\n        list: List of all integers x such that x is an inverse of n under modulus.\n    Examples:\n    >>> find_modular_inverses(3, 11)\n    [4]\n    >>> find_modular_inverses(2, 5)\n    [3]\n    \"\"\"\n    if modulus <= 0:\n        raise ValueError(\"Modulus must be a positive integer.\")\n    inverses = [x for x in range(1, modulus) if (n * x) % modulus == 1]\n    return inverses"], "Greatest Common Divisor (GCD)": ["def gcd_multiple(numbers):\n    \"\"\"\n    Compute the Greatest Common Divisor (GCD) of a list of numbers.\n    \n    Parameters:\n        numbers (list of int): A list of integers for which the GCD is required.\n    \n    Returns:\n        int: The greatest common divisor of the provided numbers.\n    \n    Examples:\n        >>> gcd_multiple([42, 56, 98])\n        14\n        >>> gcd_multiple([20, 40])\n        20\n    \"\"\"\n    return reduce(math.gcd, numbers)", "def calculate_gcd(a, b):\n    \"\"\"\n    Calculate the Greatest Common Divisor (GCD) of two numbers.\n    Parameters:\n    a (int): The first number.\n    b (int): The second number.\n    Returns:\n    int: The GCD of the two numbers.\n    Examples:\n    >>> calculate_gcd(12, 18)\n    6\n    >>> calculate_gcd(100, 25)\n    25\n    \"\"\"\n    return gcd(a, b)", "def calculate_lcm(a, b):\n    \"\"\"\n    Calculate the Least Common Multiple (LCM) using the relationship with GCD.\n    Parameters:\n    a (int): The first number.\n    b (int): The second number.\n    Returns:\n    int: The LCM of the two numbers.\n    Examples:\n    >>> calculate_lcm(12, 18)\n    36\n    >>> calculate_lcm(5, 7)\n    35\n    \"\"\"\n    return abs(a*b) // gcd(a, b)", "def prime_factors(n):\n    \"\"\"\n    Calculate the prime factors of a given number.\n    Parameters:\n    n (int): The integer to factorize.\n    Returns:\n    dict: Dictionary of prime factors and their exponents.\n    Example:\n    >>> prime_factors(60)\n    {2: 2, 3: 1, 5: 1}\n    \"\"\"\n    from sympy import primefactors\n    factors = {}\n    for p in primefactors(n):\n        count = 0\n        x = n\n        while x % p == 0:\n            x //= p\n            count += 1\n        factors[p] = count\n    return factors", "def _extended_gcd(a, b):\n    \"\"\"\n    A helper function that returns integers x, y such that ax + by = gcd(a, b).\n    \"\"\"\n    if a == 0:\n        return (0, 1)\n    else:\n        x1, y1 = _extended_gcd(b % a, a)\n        return (y1 - (b // a) * x1, x1)", "def calculate_gcd_multiple(numbers):\n    \"\"\"\n    Calculate the GCD of a list of numbers.\n    Parameters:\n    numbers (list of int): A list of integers.\n    Returns:\n    int: The GCD of the list of numbers.\n    Examples:\n    >>> calculate_gcd_multiple([24, 36, 48])\n    12\n    >>> calculate_gcd_multiple([20, 100, 200])\n    20\n    \"\"\"\n    return reduce(gcd, numbers)", "def gcd_of_factorials(a, b):\n    \"\"\"\n    Computes the GCD of the factorials of two integers.\n    Parameters:\n        a (int): The first number whose factorial is considered.\n        b (int): The second number whose factorial is considered.\n    \n    Returns:\n        int: The GCD of the factorials of two integers.\n    \n    Examples:\n        >>> gcd_of_factorials(5, 6)\n        120  # Since 5! = 120 and 6! = 720; gcd(120, 720) = 120\n        >>> gcd_of_factorials(3, 4)\n        6    # Since 3! = 6 and 4! = 24; gcd(6, 24) = 6\n    \"\"\"\n    factorial_a = factorial(a)\n    factorial_b = factorial(b)\n    return gcd(factorial_a, factorial_b)", "def gcd_of_polynomials(poly1, poly2):\n    \"\"\"\n    Computes the GCD of two polynomials represented as tuples of coefficients.\n    Parameters:\n        poly1 (tuple): The coefficients of the first polynomial.\n        poly2 (tuple): The coefficients of the second polynomial.\n    \n    Returns:\n        tuple: The GCD of the two polynomials in tuple format.\n    \n    Examples:\n        >>> gcd_of_polynomials((2, 4), (4, 8))\n        (2, 4)  # Equivalent to x + 2 where gcd is computed as tuple (1, 2)\n    \"\"\"\n    from numpy import gcd, polymul\n    # Convert polynomial tuples to a form usable for gcd computation\n    def poly_gcd(poly1, poly2):\n        result = [gcd(a, b) for a, b in zip(poly1, poly2)]\n        return tuple(result)\n    return poly_gcd(poly1, poly2)", "def factorial(n):\n    if n == 0:\n        return 1\n    else:\n        return n * factorial(n-1)"], "Factorials and Multiples": ["def compute_factorial(n):\n    \"\"\"\n    Compute the factorial of a non-negative integer n.\n    \n    Parameters:\n        n (int): A non-negative integer whose factorial is to be computed.\n        \n    Returns:\n        int: The factorial of n.\n        \n    Examples:\n        >>> compute_factorial(5)\n        120\n        >>> compute_factorial(0)\n        1\n    \"\"\"\n    if n < 0:\n        raise ValueError(\"Factorial is not defined for negative numbers\")\n    return math.factorial(n)", "def smallest_factorial_multiple(k):\n    \"\"\"\n    Finds the smallest non-negative integer n such that k is a divisor of n!.\n    \n    Parameters:\n    k : int\n        The target divisor.\n        \n    Returns:\n    int\n        The smallest n such that k divides n!.\n        \n    Example:\n    >>> smallest_factorial_multiple(7)\n    7\n    \"\"\"\n    from sympy import factorint\n    factors = factorint(k)\n    return max(factors.keys())", "def factorial_trailing_zeros(n):\n    \"\"\"\n    Count trailing zeros in n factorial.\n    \n    Parameters:\n    n : int\n        The non-negative integer to find the factorial trailing zeros of.\n        \n    Returns:\n    int\n        Number of trailing zeros in n!.\n        \n    Example:\n    >>> factorial_tralterial_zeros(5)\n    1\n    \"\"\"\n    count = 0\n    if n < 0:\n        raise ValueError(\"Negative numbers do not have factorial trailing zeros.\")\n    i = 5\n    while n // i > 0:\n        count += n // i\n        i *= 5\n    return count", "def factorial_binomial_coefficient(n, k):\n    \"\"\"\n    Calculate the binomial coefficient, C(n, k) = n! / (k! (n-k)!), representing combinations of n objects taken k at a time.\n    \n    Parameters:\n        n (int): Total number of objects.\n        k (int): Number of objects to choose.\n    \n    Returns:\n        int: The binomial coefficient of n and k.\n    \n    Examples:\n        >>> factorial_binomial_coefficient(5, 2)\n        10\n        >>> factorial_binomial_coefficient(10, 3)\n        120\n    \"\"\"\n    if k < 0 or k > n:\n        return 0\n    if k == 0 or k == n:\n        return 1\n    k = min(k, n - k)  # Take advantage of symmetry\n    c = 1\n    for i in range(k):\n        c = c * (n - i) // (i + 1)\n    return c", "def cancel_factorials(n, k):\n    \"\"\"\n    Simplify the expression n! / k! when n >= k by calculating the product from (k+1) to n.\n    \n    Parameters:\n    - n (int): Numerator factorial.\n    - k (int): Denominator factorial.\n    \n    Returns:\n    int: The result of the simplification of n! / k!.\n    Examples:\n    >>> cancel_factorials(5, 3)\n    20\n    \"\"\"\n    if n < k:\n        raise ValueError(\"n should be greater than or equal to k for cancellation.\")\n    result = 1\n    for i in range(k+1, n+1):\n        result *= i\n    return result", "def factorial_divisibility(n, k):\n    \"\"\"\n    Determine the largest power of k that divides n! (n factorial) without a remainder.\n    \n    Parameters:\n        n (int): A non-negative integer representing the factorial to be analyzed.\n        k (int): A positive integer to check for divisibility into n!.\n    \n    Returns:\n        int: The largest exponent such that k^exponent divides n! without remainder.\n        \n    Examples:\n        >>> factorial_divisibility(5, 2)\n        3\n        >>> factorial_divisibility(10, 5)\n        2\n    \"\"\"\n    count = 0\n    i = k\n    while i <= n:\n        count += n // i\n        i *= k\n    return count", "def factorial_division(numerator, denominator):\n    \"\"\"\n    Simplifies the division of two factorials using cancellation of common terms.\n    \n    Parameters:\n    numerator : int\n        The numerator factorial.\n    denominator : int\n        The denominator factorial, should be less than or equal to numerator.\n        \n    Returns:\n    int\n        The simplified result of `numerator! / denominator!`.\n        \n    Example:\n    >>> factorial_division(5, 3)\n    20\n    \"\"\"\n    if denominator > numerator:\n        raise ValueError(\"Denominator must be less than or equal to numerator.\")\n    product = 1\n    for i in range(denominator + 1, numerator + 1):\n        product *= i\n    return product", "def calculate_combinations(n, k):\n    \"\"\"\n    Calculate the number of combinations (also known as \"n choose k\") which is the way to select k items from n items without considering the order.\n    \n    Parameters:\n    - n (int): Total number of items.\n    - k (int): Number of items to choose.\n    \n    Returns:\n    int: The number of possible combinations.\n    Examples:\n    >>> calculate_combinations(5, 2)\n    10\n    >>> calculate_combinations(10, 3)\n    120\n    \"\"\"\n    return comb(n, k)"], "Digit Sums": ["def digit_sum(number):\n    \"\"\"Calculate the sum of the digits of a number.\n    \n    Parameters:\n    number (int): The number whose digits will be summed.\n    Returns:\n    int: The sum of the digits of the number.\n    Examples:\n    >>> digit_sum(123)\n    6\n    >>> digit_sum(104)\n    5\n    \"\"\"\n    return sum(int(digit) for digit in str(abs(number)))", "def reverse_digits(n):\n    \"\"\"\n    Reverse the digits of the number `n` and return the resulting integer.\n    \n    Parameters:\n        n (int): The number to be reversed.\n    \n    Returns:\n        int: The integer formed by the reverse order of the digits of `n`.\n    Examples:\n        >>> reverse_digits(123)\n        321\n        >>> reverse_digits(100)\n        1\n    \"\"\"\n    return int(str(n)[::-1]) if n >= 0 else -int(str(-n)[::-1])", "def digit_count(n):\n    \"\"\"\n    Count the number of digits in an integer.\n    Parameters:\n    -----------\n    n : int\n        The number to count the digits of.\n    Returns:\n    --------\n    int\n        Number of digits in `n`.\n    Examples:\n    ---------\n    >>> digit_count(12345)\n    5\n    >>> digit_count(-123)\n    3\n    \"\"\"\n    return len(str(abs(n)))", "def digit_sum(n, filter_divisor=None):\n    \"\"\"\n    Calculate the sum of the digits of an integer `n`. Optionally, only consider the sum if it is divisible by `filter_divisor`.\n    \n    Parameters:\n        n (int): The number whose digit sum is calculated.\n        filter_divisor (int, optional): If specified, the function will check if the digit sum is divisible by this number and return the sum if true, otherwise 0.\n    Returns:\n        int: The sum of the digits of `n` if `filter_divisor` is None or if the sum is divisible by `filter_divisor`, otherwise 0.\n    Examples:\n        >>> digit_sum(123)\n        6\n        >>> digit_sum(123, filter_divisor=3)\n        6\n        >>> digit_sum(124, filter_divisor=3)\n        0\n    \"\"\"\n    s = sum(int(digit) for digit in str(abs(n)))\n    if filter_divisor is not None and s % filter_divisor != 0:\n        return 0\n    return s", "def is_palindrome(n):\n    \"\"\"\n    Checks whether a given number is a palindrome.\n    Parameters:\n    - n (int): The number to check.\n    Returns:\n    - bool: True if n is a palindrome; otherwise False.\n    Examples:\n    >>> is_palindrome(121)\n    True\n    >>> is_palindrome(123)\n    False\n    \"\"\"\n    s = str(n)\n    return s == s[::-1]", "def max_digit_sum_ordering(digits, desired_sum):\n    \"\"\"\n    Find the largest number formed by arranging digits to achieve a specified sum of digits.\n    Parameters:\n    -----------\n    digits : list of int\n        List of individual digits available.\n    desired_sum : int\n        The desired sum of the digits of the resulting number.\n    Returns:\n    --------\n    int or None\n        The largest number possible with the desired digit sum, or None if no such arrangement exists.\n    Examples:\n    ---------\n    >>> max_digit_sum_ordering([1, 2, 3, 9], 14)\n    9321\n    \"\"\"\n    from itertools import permutations\n    valid_numbers = []\n    for perm in permutations(digits):\n        if sum(perm) == desired_sum:\n            valid_numbers.append(int(''.join(map(str, perm))))\n    return max(valid_numbers, default=None)", "def digit_counter(number):\n    \"\"\"Counts the occurrence of each digit in a number.\n    Parameters:\n    number (int): The number to count digits from.\n    Returns:\n    dict: A dictionary with digits as keys and their counts as values.\n    Examples:\n    >>> digit_counter(112233)\n    {1: 2, 2: 2, 3: 2}\n    >>> digit_counter(456789)\n    {4: 1, 5: 1, 6: 1, 7: 1, 8: 1, 9: 1}\n    \"\"\"\n    counts = {}\n    for digit in str(abs(number)):\n        dig = int(digit)\n        if dig in counts:\n            counts[dig] += 1\n        else:\n            counts[dig] = 1\n    return counts", "def sum_of_digit_powers(n, power):\n    \"\"\"\n    Calculate the sum of the digits of a number raised to a specific power.\n    Parameters:\n    -----------\n    n : int\n        The number whose digits will be raised to the power and summed.\n    power : int\n        The power to raise each digit.\n    Returns:\n    --------\n    int\n        Sum of the digits of `n` raised to the `power`.\n    Examples:\n    ---------\n    >>> sum_of_digit_powers(123, 2)\n    14  # 1^2 + 2^2 + 3^2\n    >>> sum_of_digit_powers(321, 3)\n    36  # 3^3 + 2^3 + 1^3\n    \"\"\"\n    return sum(int(d)**power for d in str(abs(n)))", "def valid_digit_combinations(range_digits, check_evenness=True):\n    \"\"\"\n    Count combinations of digits from the range where first and last digits follow specific rules.\n    Parameters:\n    -----------\n    range_digits : list of int\n        The digits available for forming combinations.\n    check_evenness : bool\n        If true, checks that the first and last digits must both be even or both be odd.\n    Returns:\n    --------\n    int\n        Count of valid combinations of digits given the conditions.\n    Examples:\n    ---------\n    >>> valid_digit_combinations([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])\n    30  # 10 possible even-even or odd-odd pairs with 10 choices in between\n    \"\"\"\n    from itertools import product\n    if check_evenness:\n        pairs = [(d1, d2) for d1 in range_digits for d2 in range_digits if (d1 % 2 == d2 % 2)]\n    else:\n        pairs = list(product(range_digits, repeat=2))\n    return len(pairs) * len(range_digits)", "def is_palindrome(number, base=10):\n    \"\"\"\n    Check if a given number is a palindrome in the specified base.\n    Parameters:\n    - number (int): The number to check.\n    - base (int): The numerical base in which the number's palindromic nature is to be assessed.\n    Returns:\n    - bool: True if the number is a palindrome, False otherwise.\n    Examples:\n    >>> is_palindrome(121)\n    True\n    >>> is_palindrome(123, 10)\n    False\n    >>> is_palindrome(0b101, 2)\n    True\n    \"\"\"\n    original = number\n    reversed_num = 0\n    while number > 0:\n        reversed_num = reversed_num * base + number % base\n        number //= base\n    return original == reversed_num", "def count_digit_occurrences_in_range(start, end, digit):\n    \"\"\"Counts how many times a specific digit appears within a range of numbers.\n    Parameters:\n    start (int): Start of the range (inclusive).\n    end (int): End of the range (inclusive).\n    digit (str): The digit to count occurrences of.\n    Returns:\n    int: Total count of the digit's occurrences within the specified range.\n    Examples:\n    >>> count_digit_occurrences_in_range(10, 30, '1')\n    12\n    >>> count_digit_occurrences_in_range(1, 100, '0')\n    9\n    \"\"\"\n    count = 0\n    for num in range(start, end + 1):\n        count += str(num).count(digit)\n    return count", "def is_palindromic_number(n):\n    \"\"\"\n    Check if the given integer is a palindromic number.\n    \n    A palindromic number is a number that remains the same when its digits are reversed.\n    Parameters:\n    - n (int): The number to check.\n    Returns:\n    - bool: True if n is a palindromic number, otherwise False.\n    Examples:\n    >>> is_palindromic_number(121)\n    True\n    >>> is_palindromic_number(123)\n    False\n    \"\"\"\n    str_n = str(n)\n    return str_n == str_n[::-1]"], "Modulo Arithmetic": ["def modular_add(a, b, mod):\n    \"\"\"\n    Perform modular addition between two numbers.\n    Parameters:\n        a (int): The first integer.\n        b (int): The second integer.\n        mod (int): The modulus.\n    Returns:\n        int: The result of (a + b) % mod\n    Examples:\n        >>> modular_add(5, 3, 7)\n        1\n    \"\"\"\n    return (a + b) % mod", "def solve_linear_congruence(a, b, m):\n    \"\"\"\n    Solve the linear congruence of the form ax ≡ b (mod m).\n    Parameters:\n    - a: Coefficient of x in the congruence.\n    - b: The right-hand side of the congruence.\n    - m: The modulus.\n    Returns:\n    - The smallest non-negative solution x of the congruence. If no solution, returns None.\n    \n    Examples:\n    >>> solve_linear_congruence(7, 1, 26)\n    15\n    \"\"\"\n    from sympy.ntheory.modular import solve_congruence\n    \n    # Transforming into the format required by solve_congruence ((a, m), (b, n))\n    cong = ((b, m),)\n    solution = solve_congruence(*cong)\n    \n    if solution is None:\n        return None\n    else:\n        return solution[0]", "def modular_inverse(a, m):\n    \"\"\"\n    Compute the modular inverse of a mod m.\n    \n    Args:\n        a : int\n            The number whose modular inverse is to be calculated.\n        m : int\n            The modular value.\n   \n    Returns:\n        int\n            Returns the modular inverse of a mod m.\n    \"\"\"\n    try:\n        return mod_inverse(a, m)\n    except ValueError:\n        return \"No Inverse Exists\"", "def modular_inverse(a, mod):\n    \"\"\"\n    Find the modular multiplicative inverse of a under modulo mod.\n    Parameters:\n        a (int): The integer to find the inverse.\n        mod (int): The modulus.\n    Returns:\n        int or None: The modular inverse of a modulo mod if it exists, otherwise None.\n    Examples:\n        >>> modular_inverse(3, 11)\n        4\n    \"\"\"\n    try:\n        return pow(a, -1, mod)\n    except ValueError:\n        return None", "def calc_modulo(number, mod):\n    \"\"\"\n    Calculate the remainder of a division by `mod`.\n    Parameters:\n    - number (int): The number to be divided.\n    - mod (int): The divisor (modulus) to divide by.\n    Returns:\n    int: The remainder when `number` is divided by `mod`.\n    Example:\n    >>> calc_modulo(10, 3)\n    1\n    \"\"\"\n    return number % mod", "def is_congruent(a, b, m):\n    \"\"\"\n    Determine if 'a' and 'b' are congruent modulo 'm'.\n    Args:\n        a : int\n            First integer.\n        b : int\n            Second integer.\n        m : int\n            The modular value.\n    Returns:\n        bool\n            Returns True if 'a' and 'b' are congruent modulo 'm', else False.\n    \"\"\"\n    return a % m == b % m", "def extended_gcd(a, b):\n    \"\"\"\n    Extended Euclidean Algorithm to find x, y such that ax + by = gcd(a, b)\n    Parameters:\n        a (int): First number\n        b (int): Second number\n    Returns:\n        tuple: (gcd, x, y), where gcd is the greatest common divisor and x, y are the coefficients of a and b respectively in the equation ax + by = gcd\n    Examples:\n        >>> extended_gcd(18, 12)\n        (6, 1, -1)\n    \"\"\"\n    if a == 0:\n        return (b, 0, 1)\n    else:\n        gcd, x, y = extended_gcd(b % a, a)\n        return (gcd, y - (b // a) * x, x)", "def modular_exponentiation(base, exponent, modulus):\n    \"\"\"\n    Calculate base^exponent mod modulus efficiently.\n    Parameters:\n    - base: The base of the exponentiation.\n    - exponent: The exponent.\n    - modulus: The modulus.\n    Returns:\n    - The result of (base^exponent) mod modulus.\n    \n    Examples:\n    >>> modular_exponentiation(2, 10, 1000)\n    24\n    \"\"\"\n    if gcd(base, modulus) == 1:  # If base and modulus are coprime, Fermat's little theorem can be applied.\n        exponent = exponent % (modulus - 1)\n    result = pow(base, exponent, modulus)\n    return result", "def reduce_modulo(a, m):\n    \"\"\"\n    Reduce a number 'a' modulo 'm'.\n    Args:\n        a : int\n            The number which is to be reduced.\n        m : int\n            The modular value.\n    Returns:\n        int\n            Returns 'a' modulo 'm'.\n    \"\"\"\n    return a % m", "def calculate_mod_inverse(a, m):\n    \"\"\"\n    This function calculates the modular multiplicative inverse of 'a' under modulo 'm'. \n    i.e., it finds an integer 'b' such that (ab)mod m == 1.\n    \n    Parameters:\n        a (int): integer to compute the modular inverse for \n        m (int): modulo to consider \n        \n    Returns:\n        int: modular inverse of `a` under modulo `m`\n        \n    Example:\n        >>> calculate_mod_inverse(3, 7)\n        5 #because (3*5)%7 == 1\n    \"\"\"\n    try:\n        return mod_inverse(a, m)\n    except ValueError as ve:\n        print(f\"No modular multiplicative inverse for {a} under modulo {m}\")\n        return None", "def mod_reduce(number, modulus):\n    \"\"\"\n    Reduces a number modulo a given modulus.\n    \n    Parameters:\n        number (int): The number to be reduced.\n        modulus (int): The modulus to be used for reduction.\n        \n    Returns:\n        int: The equivalent number in the range [0, modulus-1].\n        \n    Examples:\n        >>> mod_reduce(10, 3)\n        1\n        >>> mod_reduce(-4, 3)\n        2\n    \"\"\"\n    return number % modulus", "def least_non_negative_residue(a, mod):\n    \"\"\"\n    Compute the least non-negative residue of a under modulo mod.\n    Parameters:\n        a (int): The integer.\n        mod (int): The modulus.\n    Returns:\n        int: The least non-negative residue of a modulo mod.\n    Examples:\n        >>> least_non_negative_residue(-3, 5)\n        2\n    \"\"\"\n    return a % mod", "def simplifying_arithmetic_modulo(a, operator, b, modulo):\n    \"\"\"\n    This function takes two integers a and b, an operator (either '+', '-', '*', '/') and a modulus. \n    It applies the operator to the numbers and reduces the result modulo the given modulus.\n    Parameters:\n        a (int): The first operand\n        operator (str): The operator to use. Possible values: '+', '-', '*', '/'\n        b (int): The second operand\n        modulo (int): The modulus to use for the calculation\n    Returns:\n        int: The simplified value of the operation\n    Example:\n        >>> simplifying_arithmetic_modulo(10, '+', 15, 7)\n        4 # because (10 + 15) = 25, and 25 modulo 7 equals 4\n    \"\"\"\n    if operator == '+':\n        return (a + b) % modulo\n    elif operator == '-':\n        return (a - b) % modulo\n    elif operator == '*':\n        return (a * b) % modulo\n    elif operator == '/':\n        b_inverse = calculate_mod_inverse(b, modulo)\n        if b_inverse is not None:\n            return (a * b_inverse) % modulo\n        return None", "def is_equivalent_modulo(a, b, mod):\n    \"\"\"\n    Check if two numbers are equivalent under a specified modulo.\n    Parameters:\n    - a (int): The first number.\n    - b (int): The second number.\n    - mod (int): The modulus to test equivalence under.\n    Returns:\n    bool: True if `a` is equivalent to `b` under modulo `mod`, otherwise False.\n    Example:\n    >>> is_equivalent_modulo(14, 3, 11)\n    True\n    \"\"\"\n    return (a % mod) == (b % mod)", "def sum_modulo(numbers, mod):\n    \"\"\"\n    Calculate the sum of a list of numbers under a specified modulo.\n    Parameters:\n    - numbers (list of int): List of integers to be summed.\n    - mod (int): The modulus for the sum operation.\n    Returns:\n    int: The result of the sum modulo `mod`.\n    Example:\n    >>> sum_modulo([1, 2, 3, 4], 3)\n    1\n    \"\"\"\n    return sum(numbers) % mod"], "Base Conversion": ["def convert_base(number, source_base, target_base):\n    \"\"\"\n    Convert a number from a specific source base to a target base.\n    Parameters:\n    - number (str): The number in string format in the source base.\n    - source_base (int): The base of the input number.\n    - target_base (int): The base to which the number needs to be converted.\n    Returns:\n    - str: The number converted into the target base.\n    Examples:\n    >>> convert_base('101', 2, 10)\n    '5'\n    >>> convert_base('FF', 16, 2)\n    '11111111'\n    \"\"\"\n    import numpy as np\n    # Convert the number from any base to base 10\n    base10 = int(number, source_base)\n    # Convert from base 10 to the target base\n    if target_base == 10:\n        return str(base10)\n    else:\n        return np.base_repr(base10, base=target_base)", "def binary_to_decimal(binary_str):\n    \"\"\"\n    Convert a binary number (as a string) to its decimal (base 10) representation.\n    \n    Parameters:\n    - binary_str (str): The binary number as a string.\n    \n    Returns:\n    - int: The decimal representation of the binary number.\n    \n    Examples:\n    >>> binary_to_decimal('101')\n    5\n    >>> binary_to.getValueOfKey('1101')\n    13\n    \"\"\"\n    return int(binary_str, 2)", "def smallest_palindrome_of_length(length, base):\n    \"\"\"\n    Finds the smallest palindromic number with the specified length in the given base.\n    \n    Parameters:\n        length (int): The length of the palindromic number.\n        base (int): The base in which the palindrome should exist.\n    Returns:\n        str: The smallest palindrome of the given length in the specified base.\n        \n    Examples:\n        >>> smallest_palindrome_of_length(5, 2)\n        '10001'\n        >>> smallest_palindrome_of_length(3, 10)\n        '101'\n    \"\"\"\n    if length == 1:\n        return '1'\n    elif length == 2:\n        return '11'\n    \n    # Start with the minimal number consisting of \"1\" followed by zeroes and closing with \"1\"\n    start = '1' + '0' * (length - 2) + '1'\n    return start", "def smallest_binary_palindrome(length):\n    \"\"\"\n    Find the smallest palindromic number in binary with a specified length.\n    Parameters:\n    length : int\n        The length of the binary palindrome.\n    Returns:\n    str:\n        The smallest binary palindromic number of the specified length.\n    Examples:\n    >>> smallest_binary_palindrome(5)\n    '10001'\n    \"\"\"\n    # Must at least be of length 1 and has to be odd for a singular smallest palindromic number\n    if length < 1:\n        raise ValueError(\"Length must be at least 1.\")\n    \n    if length == 1:\n        return \"1\"\n    \n    half = \"1\" + \"0\" * (length // 2 - 1)\n    return half + half[::-1]  # mirror the first half to form a palindrome"], "Least Common Multiple": ["def lcm_multiple(numbers):\n    \"\"\"\n    Calculate the LCM of a list of integers using the lcm function defined above through reduction.\n    Parameters:\n    - numbers (list of int): List of integers to find the LCM for.\n    Returns:\n    - int: LCM of the given list of integers.\n    Examples:\n    >>> lcm_multiple([12, 15, 18])\n    180\n    >>> lcm_multiple([4, 6, 8, 12])\n    24\n    \"\"\"\n    return reduce(lcm, numbers)", "def lcm(x, y):\n    \"\"\"\n    Calculate the Least Common Multiple (LCM) of two integers.\n    Parameters:\n    - x (int): First integer.\n    - y (int): Second integer.\n    Returns:\n    - int: LCM of the two integers.\n    Examples:\n    >>> lcm(12, 18)\n    36\n    >>> lcm(5, 11)\n    55\n    \"\"\"\n    return abs(x * y) // gcd(x, y)", "def prime_factorization(number):\n    \"\"\"\n    Computes the prime factorization of a given integer.\n    Parameters:\n    - number (int): The integer to be factorized.\n    \n    Returns:\n    - List[int]: A list containing the prime factors of the input integer.\n    \n    Examples:\n    >>> prime_factorization(60)\n    [2, 2, 3, 5]\n    \n    >>> prime_factorization(13)\n    [13]\n    \n    \"\"\"\n    if number <= 0:\n        raise ValueError(\"Number must be a positive integer.\")\n    factors = []\n    for factor in primefactors(number):\n        count = 0\n        temp = number\n        while temp % factor == 0:\n            temp //= factor\n            count += 1\n        factors.extend([factor] * count)\n    return factors", "def prime_factorization(n):\n    \"\"\"\n    Compute the prime factors of a given positive integer n using the sympy library.\n    Parameters\n    ----------\n    n : int\n        The integer to factorize.\n    Returns\n    -------\n    list\n        A list of the prime factors of the integer.\n    Examples\n    --------\n    >>> prime_factorization(18)\n    [2, 3]\n    >>> prime_factorization(100)\n    [2, 5]\n    \"\"\"\n    return primefactors(n)"], "Integers": ["def find_factors(n):\n    \"\"\"\n    Finds all factors of the given integer.\n    Parameters:\n    n (int): The integer to find factors of.\n    Returns:\n    list: A list containing all the factors of n.\n    Examples:\n    >>> find_factors(36)\n    [1, 2, 3, 4, 6, 9, 12, 18, 36]\n    >>> find_factors(101)\n    [1, 101]\n    \"\"\"\n    factors = []\n    for i in range(1, int(n ** 0.5) + 1):\n        if n % i == 0:\n            factors.append(i)\n            if i != n // i:\n                factors.append(n // i)\n    factors.sort()\n    return factors", "def gcd_multiple(numbers: List[int]) -> int:\n    \"\"\"\n    Compute the greatest common divisor of a list of integers.\n    \n    Parameters:\n    - numbers (List[int]): A list of integers to find the GCD.\n    \n    Returns:\n    int: The greatest common divisor of the provided numbers.\n    \n    Example:\n    >>> gcd_multiple([8, 12, 16])\n    4\n    \"\"\"\n    from functools import reduce\n    return reduce(math.gcd, numbers)", "def multiples(n, limit):\n    \"\"\"\n    Find all multiples of the given integer up to a specified limit.\n    Parameters:\n    n (int): Integer to find multiples of.\n    limit (int): Upper limit to search for multiples.\n    Returns:\n    list: List of multiples of n up to limit.\n    Examples:\n    >>> multiples(3, 10)\n    [3, 6, 9]\n    \"\"\"\n    return [i * n for i in range(1, limit // n + 1)]", "def unique_mode(integers):\n    \"\"\"\n    Finds the mode of a list of integers that appears most frequently.\n    Parameters:\n    integers (list): List of integers.\n    Returns:\n    tuple: mode of the list and its frequency, or None if no unique mode exists.\n    Examples:\n    >>> unique_mode([1, 2, 2, 3, 4])\n    (2, 2)\n    >>> unique_message([1, 1, 2, 2, 3, 3])\n    None\n    \"\"\"\n    counts = Counter(integers)\n    if len(set(counts.values())) == 1:  # check for tie in frequency\n        return None\n    mode = max(counts, key=counts.get)\n    return (mode, counts[mode])", "def integer_solutions(poly, domain_range):\n    \"\"\"\n    Identify integer solutions for a polynomial within a specified domain.\n    Parameters:\n    poly (function): Polynomial function.\n    domain_range (range): Range of domain to check for integer solutions.\n    Returns:\n    list: List of tuples where each tuple contains (x, y) such that poly(x) == y and y is an integer.\n    Examples:\n    >>> poly = lambda x: x**2 - 4*x + 6\n    >>> integer_solutions(poly, range(-10, 10))\n    [(-8, 70), (-7, 56), (-6, 44), ..., (6, 6), (7, 8), (8, 14), (9, 22)]\n    \"\"\"\n    return [(x, poly(x)) for x in domain_range if isinstance(poly(x), int)]", "def is_coprime(a, b):\n    \"\"\"\n    Determine if two integers are coprime (i.e., their GCD is 1).\n    Parameters:\n    a (int): The first integer.\n    b (int): The second integer.\n    Returns:\n    bool: True if a and b are coprime, else False.\n    Examples:\n    >>> is_coprime(15, 28)\n    True\n    >>> is_coprime(12, 18)\n    False\n    \"\"\"\n    return gcd(a, b) == 1", "def is_divisible(numerator: int, denominator: int) -> bool:\n    \"\"\"\n    Check if the numerator is divisible by the denominator.\n    \n    Parameters:\n    - numerator (int): The number to be divided.\n    - denominator (int): The number to divide by.\n    \n    Returns:\n    bool: True if numerator is divisible by denominator, else False.\n    \n    Example:\n    >>> is_divisible(15, 5)\n    True\n    >>> is_divisible(14, 5)\n    False\n    \"\"\"\n    if denominator == 0:\n        raise ValueError(\"Denominator cannot be zero.\")\n    return numerator % denominator == 0"], "Units Digit": ["def powered_units_digit(base, exponent):\n    \"\"\"\n    Calculate the units digit of a number raised to a power.\n    Parameters:\n    - base (int): The base of the exponentiation.\n    - exponent (int): The exponent to raise the base.\n    Returns:\n    - int: Units digit of the result of the exponentiation.\n    Examples:\n    >>> powered_units_digit(2, 10)\n    4\n    >>> powered_units_item(7, 3)\n    3\n    \"\"\"\n    # As digits patterns repeat every 4 in most cases\n    return (base ** exponent) % 10", "def units_digit(n):\n    \"\"\"\n    Calculate the units digit of an integer n.\n    \n    Parameters:\n    n (int): The integer for which the units digit is to be found.\n    Returns:\n    int: Units digit of the provided integer.\n    \n    Examples:\n    >>> units_digit(123)\n    3\n    >>> units_digit(-789)\n    9\n    \"\"\"\n    return abs(n) % 10", "def units_digit_of_multiplication(a, b):\n    \"\"\"\n    Calculate the units digit of the product of two integers.\n    \n    Parameters:\n        a (int): First multiplicand.\n        b (int): Second multiplicand.\n    Returns:\n        int: The units digit of the product of a and b.\n    Examples:\n        >>> units_digit_of_multiplication(12, 15)\n        0\n        >>> units_digit_of_multiplication(123, 456)\n        8\n    \"\"\"\n    return (a * b) % 10", "def units_digit_of_product(*args):\n    \"\"\"\n    Compute the units digit of a product of multiple integers.\n    \n    This function can also be used to compute the units digit of exponentiations \n    by repeating the base in the argument list the number of times equal to the exponent.\n    Parameters\n    ----------\n    *args : int\n        A variable number of integers whose product's units digit is to be calculated.\n    Returns\n    -------\n    int\n        The units digit of the product of the given integers.\n    Examples\n    --------\n    >>> units_digit_of_product(2, 5)\n    0\n    >>> units_digit_of_product(3, 4, 2)\n    4\n    >>> units_digit_of_product(9, 9)  # This can represent 9^2\n    1\n    \"\"\"\n    product = 1\n    for number in args:\n        # Only multiply units digits to keep computations smaller\n        product = (product * (number % 10)) % 10\n    return product", "def units_digit_from_multiplication(numbers):\n    \"\"\"\n    Compute the units digit of the product of a list of numbers.\n    \n    Parameters\n    ----------\n    numbers : list\n        A list of integers whose product's units digit is required.\n    \n    Returns\n    -------\n    int\n        The units digit of the product of the numbers.\n    \n    Examples\n    --------\n    >>> units_digit_from_multiplication([12, 35, 91])\n    0\n    \n    >>> units_digit_from_multiplication([7, 5, 2])\n    0\n    \"\"\"\n    from functools import reduce\n    from operator import mul\n    # Compute the product modulo 10 directly during multiplication to keep numbers manageable\n    result = reduce(lambda x, y: (x * y) % 10, numbers, 1)\n    return result"], "Prime Factorization": ["def prime_factorization(n):\n    \"\"\"\n    Computes the prime factorization of the given integer `n`.\n    Parameters:\n    ------------\n    n : int\n        The number to be factorized into primes.\n    \n    Returns:\n    ------------\n    dict\n        A dictionary where keys are the prime factors and values are their respective exponents in the factorization.\n    Examples:\n    ------------\n    >>> prime_factorization(18)\n    {2: 1, 3: 2}\n    \n    >>> prime_factorization(100)\n    {2: 2, 5: 2}\n    \"\"\"\n    if n < 1:\n        raise ValueError(\"n must be a positive integer\")\n    return sympy.factorint(n)", "def generate_divisors_from_factors(prime_factors):\n    \"\"\"\n    Generates all possible divisors of a number given its prime factorization.\n    Parameters:\n    ------------\n    prime_factors : dict\n        A dictionary of prime factors as returned by `prime_factorization`, where keys are primes and values are their exponents.\n    \n    Returns:\n    ------------\n    list\n        A sorted list of all divisors of the number.\n    \n    Examples:\n    ------------\n    >>> generate_divisors_from_factors({2: 1, 3: 2})\n    [1, 2, 3, 6, 9, 18]\n    \n    >>> generate_divisors_from_factors({2: 2, 5: 2})\n    [1, 2, 4, 5, 10, 20, 25, 50, 100]\n    \"\"\"\n    from functools import reduce\n    from itertools import product\n    base = sorted(prime_factors.items())\n    series = []\n    for p, exp in base:\n        series.append([p**e for e in range(exp + 1)])\n    divisors = list(map(lambda x: reduce(lambda a, b: a * b, x), product(*series)))\n    return sorted(divisors)"], "Least Common Multiple (LCM)": ["def lcm_multiple_numbers(numbers):\n    \"\"\"\n    Calculate the Least Common Multiple (LCM) for a list of integers.\n    Parameters:\n    numbers (list): A list of integers.\n    Returns:\n    int: The least common multiple of the supplied list of integers.\n    Examples:\n    >>> lcm_multiple_numbers([4, 6, 8])\n    24\n    >>> lcm_multiple_numbers([5, 10, 20])\n    20\n    \"\"\"\n    if not numbers:\n        return 0\n    return reduce(lcm_two_numbers, numbers)", "def lcm_two_numbers(a, b):\n    \"\"\"\n    Calculate the Least Common Multiple (LCM) of two integers.\n    Parameters:\n    a (int): First number.\n    b (int): Second number.\n    Returns:\n    int: The least common multiple of a and b.\n    Examples:\n    >>> lcm_two_numbers(4, 6)\n    12\n    >>> lcm_two_numbers(15, 17)\n    255\n    \"\"\"\n    if a == 0 or b == 0:\n        return 0\n    return abs(a * b) // math.gcd(a, b)", "def prime_factorization(n):\n    \"\"\"\n    Compute the prime factorization of a given number.\n    Parameters:\n    - n (int): The number to factorize.\n    Returns:\n    - dict: A dictionary where the keys are prime factors and values are their corresponding exponents.\n    Example:\n    >>> prime_factorization(360)\n    {2: 3, 3: 2, 5: 1}\n    \"\"\"\n    from sympy import primefactors, multiplicity\n    \n    factors = {}\n    for prime in primefactors(n):\n        factors[prime] = multiplicity(prime, n)\n    return factors", "def possible_values_n_from_lcm_gcd_conditions(n_conditions):\n    \"\"\" Evaluate possible integer values for n based on a series of LCM and GCD conditions.\n    \n    Parameters:\n        n_conditions (dict): Dictionary specifying the conditions with \"lcm_facts\" and \"gcd_facts\" as keys.\n                             Each key maps to a list of tuples, where each tuple in \"lcm_facts\" or \"gcd_facts\"\n                             is of the form (a, b, value) indicating LCM(a, b) == value or GCD(a, b) == value.\n    \n    Returns:\n        list: List of integers that meet all the given LCM and GCD conditions.\n    \n    Examples:\n        >>> n_conditions = {\n            \"lcm_facts\": [(6, 8, 24), (5, 7, 35)],\n            \"gcd_facts\": [(4, 10, 2)]\n        }\n        >>> possible_values_n_from_lcm_gcd_conditions(n_conditions)\n        [6, 8, 5, 7, 4, 10]  # Example output and might change depending on actual implementation logic\n    \"\"\"\n    pass"]}