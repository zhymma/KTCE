{"Matrices": [["def invert_matrix(matrix):\n    \"\"\"\n    Compute the inverse of a square matrix if it is invertible.\n    Parameters:\n    matrix (ndarray): A 2D NumPy array representing the square matrix to be inverted.\n    Returns:\n    ndarray or str: Inverse of the matrix or a message indicating that the matrix is not invertible.\n    Examples:\n    >>> import numpy as np\n    >>> matrix2x2 = np.array([[1, 2], [3, 4]])\n    >>> invert_matrix(matrix2x2)\n    array([[-2. ,  1. ],\n           [ 1.5, -0.5]])\n    >>> matrix_singular = np.array([[2, 4], [1, 2]])\n    >>> invert_matrix(matrix_singular)\n    'Matrix is not invertible.'\n    \"\"\"\n    if np.linalg.det(matrix) == 0:\n        return 'Matrix is not invertible.'\n    else:\n        return np.linalg.inv(matrix)", "def matrix_inverse(matrix):\n    \"\"\"\n    Calculate the inverse of a given matrix.\n    Parameter:\n    - matrix: ndarray\n        The matrix to be inverted.\n    Returns:\n    - inverse: ndarray\n        The inverse of the given matrix.\n    \"\"\"\n    try:\n        inverse = np.linalg.inv(matrix)\n    except np.linalg.LinAlgError as err:\n        if 'Singular matrix' in str(err):\n            print(\"The input matrix is not invertible.\")\n            inverse = None\n        else:\n            raise\n    return inverse", "def matrix_inverse(matrix):\n    \"\"\"\n    Compute the inverse of a matrix if it is invertible.\n    Parameters:\n    matrix (np.ndarray): A two-dimensional numpy array representing the matrix.\n    Returns:\n    np.ndarray: The inverse of the matrix if it is invertible, raises LinAlgError if not.\n    Examples:\n    >>> matrix_inverse(np.array([[2, 3], [1, 4]]))\n    array([[ 0.8, -0.6],\n           [-0.2,  0.4]])\n    \"\"\"\n    return np.linalg.inv(matrix)", "def invert_matrix(matrix):\n    \"\"\"\n    Inverts a square matrix.\n    For a 2x2 matrix, uses the explicit formula for inversion, while for larger matrices it uses NumPy's linalg.inv method.\n    Parameters:\n    matrix (np.ndarray): A square numpy array representing the matrix.\n    Returns:\n    np.ndarray: Inverse of the matrix.\n    Examples:\n    >>> a = np.array([[1, 2], [3, 4]])\n    >>> invert_matrix(a)\n    array([[-2. ,  1. ],\n           [ 1.5, -0.5]])\n    To handle non-invertible matrices (determinant is zero), it will raise a LinAlgError.\n    \"\"\"\n    if not isinstance(matrix, np.ndarray) or len(matrix.shape) != 2 or matrix.shape[0] != matrix.shape[1]:\n        raise ValueError(\"Input should be a square matrix\")\n    \n    if matrix.shape == (2, 2):\n        # Explicit formula for 2x2 matrices: Inverse of [[a, b], [c, d]] is (1/det) * [[d, -b], [-cury, a]]\n        det = matrix[0, 0] * matrix[1, 1] - matrix[0, 1] * matrix[1, 0]\n        if det == 0:\n            raise np.linalg.LinAlgError(\"Matrix is singular and cannot be inverted.\")\n        inv_matrix = np.array([[matrix[1, 1], -matrix[0, 1]], [-matrix[1, 0], matrix[0, 0]]]) / det\n        return inv_matrix\n    else:\n        return np.linalg.inv(matrix)"], ["def vector_add(v1, v2):\n    \"\"\"\n    Add two vectors.\n    Parameters:\n        v1 (np.ndarray): The first vector.\n        v2 (np.ndarray): The second vector.\n    Returns:\n        np.ndarray: The sum of v1 and v2.\n    Example:\n        >>> v1 = np.array([1, 2, 3])\n        >>> v2 = np.array([4, 5, 6])\n        >>> vector_add(v1, v2)\n        array([5, 7, 9])\n    \"\"\"\n    return np.add(v1, v2)", "def dot_product(v1, v2):\n    \"\"\"\n    Calculate the dot product of two vectors.\n    Parameters:\n        v1 (np.ndarray): The first vector.\n        v2 (np.ndarray): The second vector.\n    Returns:\n        float: The dot product of vectors v1 and v2.\n    Example:\n        >>> v1 = np.array([1, 3, -5])\n        >>> v2 = np.array([4, -2, -1])\n        >>> dot_product(v1, v2)\n        3\n    \"\"\"\n    return np.dot(v1, v2)", "def cross_product(v1, v2):\n    \"\"\"\n    Compute the cross product of two vectors in 3D.\n    Parameters:\n        v1 (np.ndarray): The first 3D vector.\n        v2 (np.ndarray): The second 3D vector.\n    Returns:\n        np.ndarray: The cross product of vectors v1 and v2.\n    Example:\n        >>> v1 = np.array([1, 2, 3])\n        >>> v2 = np.array([4, 5, 6])\n        >>> cross_product(v1, v2)\n        array([-3,  6, -3])\n    \"\"\"\n    return np.cross(v1, v2)"], ["def matrix_operations(A, B, operation='multiply'):\n    \"\"\"\n    Perform basic operations on two matrices: multiplication, addition, subtraction.\n    Parameters:\n    A (ndarray): A 2D NumPy array, the first matrix.\n    B (ndarray): A 2D NumPy array, the second matrix, should be the same size as A for addition and subtraction.\n    operation (str): Type of operation: 'multiply', 'add', or 'subtract'.\n    Returns:\n    ndarray: Result of the specified operation executed on the matrices.\n    Examples:\n    >>> import numpy as np\n    >>> A = np.array([[1, 2], [3, 4]])\n    >>> B = np.array([[2, 0], [1, 2]])\n    >>> matrix_operations(A, B, 'multiply')\n    array([[ 4,  4],\n           [10,  8]])\n    >>> matrix_operations(A, B, 'add')\n    array([[3, 2],\n           [4, 6]])\n    >>> matrix_operations(A, B, 'subtract')\n    array([[-1,  2],\n           [ 2,  2]])\n    \"\"\"\n    if operation == 'multiply':\n        return np.dot(A, B)\n    elif operation == 'add':\n        return np.add(A, B)\n    elif operation == 'subtract':\n        return np.subtract(A, B)\n    else:\n        raise ValueError(\"Unsupported operation. Use 'multiply', 'add', or 'subtract'.\")", "def matrix_operations(matrix1, matrix2, operation):\n    \"\"\"\n    Perform basic operations (addition, multiplication, or exponentiation) on pair of matrices.\n    Parameters:\n    - matrix1: ndarray\n        First matrix to be operated on.\n    - matrix2: ndarray\n        Second matrix to be operated on.\n    - operation: str\n        The operation to be performed - 'add', 'subtract', 'multiply', 'power'.\n    Returns:\n    - result: ndarray\n        The result of the matrix operation.\n    \"\"\"\n    if operation == 'add':\n        result = np.add(matrix1, matrix2)\n    elif operation == 'subtract':\n        result = np.subtract(matrix1, matrix2)\n    elif operation == 'multiply':\n        result = np.dot(matrix1, matrix2)\n    elif operation == 'power':\n        result = np.linalg.matrix_power(matrix1, matrix2)\n    return result"], ["def vector_projection(v1, v2):\n    \"\"\"\n    Project vector v1 onto vector v2.\n    Parameters:\n        v1 (np.ndarray): The vector being projected.\n        v2 (np.ndarray): The vector onto which v1 is projected.\n    Returns:\n        np.ndarray: The projection of v1 onto v2.\n    Example:\n        >>> v1 = np.array([3, -1])\n        >>> v2 = np.array([2, 2])\n        >>> vector_projection(v1, v2)\n        array([1., 1.])\n    \"\"\"\n    v2_norm = np.dot(v2, v2)\n    if v2_norm == 0:\n        return np.zeros_like(v2)\n    return np.dot(v1, v2) / v2_norm * v2"], ["def calculate_determinant(matrix):\n    \"\"\"\n    Calculate the determinant of a square matrix.\n    Parameters:\n    matrix (ndarray): A 2D NumPy array representing the square matrix whose determinant needs to be calculated.\n    Returns:\n    float: Determinant of the matrix.\n    Examples:\n    >>> import numpy as np\n    >>> matrix2x2 = np.array([[1, 2], [3, 4]])\n    >>> calculate_determinant(matrix2x2)\n    -2.0\n    >>> matrix3x3 = np.array([[1, 2, 3], [0, 1, 4], [5, 6, 0]])\n    >>> calculate_determinant(matrix3x3)\n    1.0\n    \"\"\"\n    return np.linalg.det(matrix)", "def calculate_determinant(matrix):\n    \"\"\"\n    Calculate the determinant of a matrix.\n    Parameters:\n    matrix (np.ndarray): A two-dimensional numpy array representing the matrix.\n    Returns:\n    float: The determinant of the matrix.\n    Examples:\n    >>> calculate_determinant(np.array([[2, 3], [1, 4]]))\n    5\n    \"\"\"\n    return np.linalg.det(matrix)", "def calculate_determinant(matrix):\n    \"\"\"\n    Calculate the determinant of a square matrix.\n    Parameters:\n    matrix (np.array): A square numpy array representing the matrix.\n    Returns:\n    float: The determinant of the matrix.\n    Examples:\n    >>> a = np.array([[1, 2], [3, 4]])\n    >>> calculate_determinant(a)\n    -2.0\n    >>> b = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\n    >>> calculate_determinant(b)\n    0.0\n    \"\"\"\n    if not isinstance(matrix, np.ndarray) or len(matrix.shape) != 2 or matrix.shape[0] != matrix.shape[1]:\n        raise ValueError(\"Input should be a square matrix\")\n    return np.linalg.det(matrix)"], ["def matrix_multiply(A, B):\n    \"\"\"\n    Multiply two matrices.\n    Parameters:\n        A (np.ndarray): The first matrix.\n        B (np.ndarray): The second matrix.\n    Returns:\n        np.ndarray: The product of matrices A and B.\n    Example:\n        >>> A = np.array([[1, 2], [3, 4]])\n        >>> B = np.array([[2, 0], [1, 2]])\n        >>> matrix_multiply(A, B)\n        array([[ 4,  4],\n               [10,  8]])\n    \"\"\"\n    return np.dot(A, B)", "def matrix_add(A, B):\n    \"\"\"\n    Add two matrices.\n    Parameters:\n        A (np.ndarray): The first matrix.\n        B (np.ndarray): The second matrix.\n    Returns:\n        np.ndarray: The sum of matrices A and B.\n    Example:\n        >>> A = np.array([[1, 2], [3, 4]])\n        >>> B = np.array([[2, 1], [0, 1]])\n        >>> matrix_add(A, B)\n        array([[3, 3],\n               [3, 5]])\n    \"\"\"\n    return np.add(A, B)"], ["def is_matrix_invertible(matrix):\n    \"\"\"\n    Check if a matrix is invertible by examining its determinant.\n    Parameters:\n    matrix (np.ndarray): A two-dimensional numpy array representing the matrix.\n    Returns:\n    bool: True if the matrix is invertible, False otherwise.\n    Examples:\n    >>> is_matrix_invertible(np.array([[2, 3], [2, 3]]))\n    False\n    \"\"\"\n    return np.linalg.det(matrix) != 0"], ["def matrix_power(A, n):\n    \"\"\"\n    Compute the nth power of a square matrix A.\n    Parameters:\n        A (np.ndarray): A square matrix.\n        n (int): The exponent to raise the matrix to.\n    Returns:\n        np.ndarray: The nth power of matrix A.\n    Example:\n        >>> A = np.array([[1, 1], [1, 0]])\n        >>> matrix_power(A, 3)\n        array([[3, 2],\n               [2, 1]])\n    \"\"\"\n    return np.linalg.matrix_power(A, n)"], ["def matrix_inverse(A):\n    \"\"\"\n    Compute the inverse of matrix A.\n    Parameters:\n        A (np.ndarray): A square matrix.\n    Returns:\n        np.ndarray: The inverse of matrix A.\n    Example:\n        >>> A = np.array([[1, 2], [3, 4]])\n        >>> matrix_inverse(A)\n        array([[-2. ,  1. ],\n               [ 1.5, -0.5]])\n    \"\"\"\n    return np.linalg.inv(A)"], ["class MatrixProjection:\n    \"\"\"\n    A class to create and manipulate projection matrices.\n    Methods\n    -------\n    create_projection_matrix(u):\n        Creates the projection matrix onto vector u.\n    project_vector(v, P):\n        Projects vector v using projection matrix P.\n    \"\"\"\n    @staticmethod\n    def create_projection_matrix(u):\n        \"\"\"\n        Create the projection matrix for projecting other vectors onto vector u.\n        Parameters:\n            u (numpy.ndarray): A vector onto which other vectors will be projected.\n        Returns:\n            numpy.ndarray: Projection matrix.\n        \"\"\"\n        u_normalized = u / np.linalg.norm(u)\n        return np.outer(u_normalized, u_normalized)\n    @staticmethod\n    def project_vector(v, P):\n        \"\"\"\n        Projects vector v onto the subspace represented by projection matrix P.\n        Parameters:\n            v (numpy.ndarray): A vector to be projected.\n            P (numpy.ndarray): Projection matrix.\n        Returns:\n            numpy.ndarray: Projected vector.\n        \"\"\"\n        return np.dot(P, v)"], ["def matrix_identity(n):\n    \"\"\"\n    Generate an identity matrix of size n.\n    Parameters:\n        n (int): The size of the identity matrix.\n    Returns:\n        np.ndarray: An n x n identity matrix.\n    Example:\n        >>> matrix_identity(3)\n        array([[1, 0, 0],\n               [0, 1, 0],\n               [0, 0, 1]])\n    \"\"\"\n    return np.eye(n)"], ["class MatrixSystemSolver:\n    \"\"\"\n    A class to solve systems of linear equations represented in matrix form.\n    Methods\n    -------\n    solve_linear_system(A, b):\n        Solves the linear system Ax = b for x.\n    \"\"\"\n    @staticmethod\n    def solve_linear_system(A, b):\n        \"\"\"\n        Solve the linear system Ax = b using numpy's linear algebra solver.\n        Parameters:\n            A (numpy.ndarray): Coefficient matrix.\n            b (numpy.ndarray): Result vector.\n        Returns:\n            numpy.ndarray: Solution vector x.\n        \"\"\"\n        return np.linalg.solve(A, b)"], ["def scalar_multiply(scalar, matrix):\n    \"\"\"\n    Multiply a matrix by a scalar.\n    Parameters:\n    scalar (float): The scalar value.\n    matrix (np.ndarray): A two-dimensional numpy array.\n    Returns:\n    np.ndarray: The scalar-multiplied matrix.\n    Examples:\n    >>> scalar_multiply(3, np.array([[1, 2], [3, 4]]))\n    array([[ 3,  6],\n           [ 9, 12]])\n    \"\"\"\n    return scalar * matrix"], ["class MatrixManipulator:\n    \"\"\"\n    A utility class to perform various matrix operations such as multiplication, \n    matrix powers, inversion and checking properties like identity matrix condition.\n    Methods\n    -------\n    multiply_matrices(A, B):\n        Multiplies two matrices A and B.\n    matrix_power(A, n):\n        Computes the nth power of matrix A.\n    invert_matrix(A):\n        Computes the inverse of matrix A.\n    is_identity_matrix(A):\n        Checks if matrix A is an identity matrix.\n    \"\"\"\n    @staticmethod\n    def multiply_matrices(A, B):\n        \"\"\"\n        Multiplies two matrices A and B using the dot product.\n        Parameters:\n            A (numpy.ndarray): A matrix.\n            B (numpy.ndarray): A matrix.\n        Returns:\n            numpy.ndarray: Resultant matrix after multiplication.\n        \"\"\"\n        return np.dot(A, B)\n    @staticmethod\n    def matrix_power(A, n):\n        \"\"\"\n        Computes the nth power of matrix A using matrix multiplication.\n        Parameters:\n            A (numpy.ndarray): A square matrix.\n            n (int): The exponent to which the matrix is to be raised.\n        Returns:\n            numpy.ndarray: A to the power n.\n        \"\"\"\n        return np.linalg.matrix_power(A, n)\n    @staticmethod\n    def invert_matrix(A):\n        \"\"\"\n        Computes the inverse of matrix A if it exists.\n        Parameters:\n            A (numpy.ndarray): A square matrix.\n        Returns:\n            numpy.ndarray: Inverse of matrix A.\n        \"\"\"\n        return np.linalg.inv(A)\n    @staticmethod\n    def is_identity_matrix(A):\n        \"\"\"\n        Checks if the provided matrix A is an identity matrix.\n        Parameters:\n            A (numpy.ndarray): A square matrix.\n        Returns:\n            bool: True if A is an identity matrix, False otherwise.\n        \"\"\"\n        return np.allclose(A, np.eye(A.shape[0]))"], ["def geometric_transform(matrix, vector, transform_type):\n    \"\"\"\n    Performs the specified geometric transformation on a vector.\n    Parameters:\n    - matrix: ndarray\n        The transformation matrix to be applied.\n    - vector: ndarray\n        The vector to be transformed.\n    - transform_type: str\n        The type of transformation to be performed - 'rotation', 'reflection', 'dilation', 'projection'.\n    Returns:\n    - transformed_vector: ndarray\n        The vector after applying the transformation.\n    \"\"\"\n    if transform_type in ['rotation', 'reflection', 'dilation', 'projection']:\n        transformed_vector = np.dot(matrix, vector)\n    else:\n        print(f\"'{transform_type}' is not a supported transformation type.\")\n        transformed_vector = vector\n    return transformed_vector"], ["class MatrixEigen:\n    \"\"\"\n    A class to compute eigenvalues and eigenvectors of a matrix.\n    Methods\n    -------\n    compute_eigenvalues(A):\n        Computes eigenvalues of matrix A.\n    compute_eigenvectors(A):\n        Computes eigenvectors of matrix A.\n    \"\"\"\n    @staticmethod\n    def compute_eigenvalues(A):\n        \"\"\"\n        Compute the eigenvalues of the matrix A.\n        Parameters:\n            A (numpy.ndarray): A square matrix.\n        Returns:\n            numpy.ndarray: Array of eigenvalues.\n        \"\"\"\n        return np.linalg.eigvals(A)\n    @staticmethod\n    def compute_eigenvectors(A):\n        \"\"\"\n        Compute the eigenvectors of the matrix A.\n        Parameters:\n            A (numpy.ndarray): A square matrix.\n        Returns:\n            tuple: Returns a tuple containing an array of eigenvalues and a matrix whose columns are the corresponding right eigenvectors.\n        \"\"\"\n        return np.linalg.eig(A)"], ["def get_eigenvectors(matrix):\n    \"\"\"\n    Calculate the eigenvalues and eigenvectors of a given matrix.\n    Parameters:\n    - matrix: ndarray\n        The matrix for which the eigenvectors are to be calculated.\n    Returns:\n    - eigenvalues: ndarray\n        Eigenvalues of the given matrix.\n    - eigenvectors: ndarray\n        Eigenvectors of the given matrix.\n    \"\"\"\n    eigenvalues, eigenvectors = np.linalg.eig(matrix)\n    return eigenvalues, eigenvectors"], ["def project_vector(vector, onto):\n    \"\"\"\n    Project a vector onto another vector.\n    Parameters:\n    - vector: ndarray\n        The vector to be projected.\n    - onto: ndarray\n        The vector onto which `vector` will be projected.\n    Returns:\n    - projection: ndarray\n        The projection of `vector` onto `onto`.\n    \"\"\"\n    # Account for zero vectors\n    if np.count_nonzero(onto) == 0:\n        return np.zeros_like(vector)\n    # Compute the projection\n    scale_factor = np.dot(vector, onto) / np.dot(onto, onto)\n    projection = scale_factor * onto\n    return projection"], ["def matrix_multiply(matrix1, matrix2):\n    \"\"\"\n    Multiply two matrices.\n    Parameters:\n    matrix1 (np.ndarray): A two-dimensional numpy array.\n    matrix2 (np.ndarray): Another two-dimensional numpy array.\n    Returns:\n    np.ndarray: The product of matrix1 and matrix2.\n    Examples:\n    >>> matrix_multiply(np.array([[1, 2], [3, 4]]), np.array([[2, 0], [1, 2]]))\n    array([[ 4,  4],\n           [10,  8]])\n    \"\"\"\n    return np.dot(matrix1, matrix2)"]], "Vectors": [["def vector_magnitude(vector):\n    \"\"\"\n    Calculate the magnitude (norm) of a vector.\n    \n    Parameters:\n        vector (np.array): The vector of which to find the magnitude.\n    \n    Returns:\n        float: The magnitude of the vector.\n    \n    Examples:\n        >>> vector_magnitude(np.array([1,2,3]))\n        3.7416573867739413\n    \"\"\"\n    return np.linalg.norm(vector)", "def vector_norm(v):\n    \"\"\"\n    Compute the Euclidean norm (magnitude) of a vector.\n    Parameters:\n    v (array_like): Input vector.\n    Returns:\n    float: Norm of the vector.\n    \n    Example:\n    >>> vector_norm([3, 4])\n    5.0\n    \"\"\"\n    return np.linalg.norm(v)", "def vector_norm(vector):\n    \"\"\"\n    Calculate the norm (magnitude) of a vector.\n    Parameters:\n        vector (array_like): A one-dimensional array representing the vector.\n    Returns:\n        float: The norm of the vector.\n    Examples:\n        >>> vector_norm([3, 4])\n        5.0\n    \"\"\"\n    vector = np.array(vector)\n    return np.linalg.norm(vector)", "def vector_magnitude(v):\n    \"\"\"\n    Compute the magnitude (norm) of a vector.\n    \n    Parameters:\n        v (array): Input vector.\n    Returns:\n        float: The magnitude of the vector.\n    \"\"\"\n    return np.linalg.norm(v)", "def vector_norm(v):\n    \"\"\"\n    Calculate the Euclidean norm (magnitude) of the vector.\n    Parameters:\n        v (list or np.array): The vector.\n    Returns:\n        float: The magnitude of the vector.\n    \n    Example:\n        >>> vector_norm([3, 4])\n        5.0\n    \"\"\"\n    return np.linalg.norm(v)", "def vector_magnitude(vector):\n    \"\"\"\n    Calculate the magnitude (norm) of a vector.\n    Parameters:\n    vector (array-like): Input vector.\n    Returns:\n    float: The magnitude of the vector.\n    Examples:\n    >>> vector_magnitude(np.array([3, 4]))\n    5.0\n    \"\"\"\n    return np.linalg.norm(vector)", "def vector_magnitude(v):\n    \"\"\"\n    Compute the Euclidean norm (magnitude) of a vector.\n    Parameters:\n    - v (np.ndarray): A NumPy array representing the vector.\n    Returns:\n    - float: The magnitude of the vector.\n    Examples:\n    >>> vector_magnitude(np.array([3, 4]))\n    5.0\n    \"\"\"\n    return np.linalg.norm(v)", "def vector_magnitude(v):\n    \"\"\"\n    Compute the magnitude (norm) of a vector.\n    \n    Parameters:\n        v (array_like): The vector whose magnitude is to be calculated.\n        \n    Returns:\n        float: The magnitude of the vector.\n    \n    Examples:\n        >>> vector_magnitude([3, 4])\n        5.0\n    \"\"\"\n    return np.linalg.norm(v)"], ["def dot_product(vector_a, vector_b):\n    \"\"\"\n    Calculate the dot product of two vectors.\n    \n    Parameters:\n        vector_a (np.array): The first vector.\n        vector_b (np.array): The second vector.\n    \n    Returns:\n        float: The dot product of vector_a and vector_b.\n    \n    Examples:\n        >>> dot_product(np.array([1,2,3]), np.array([4,5,6]))\n        32\n    \"\"\"\n    return np.dot(vector_a, vector_b)", "def vector_dot(v1, v2):\n    \"\"\"\n    Compute the dot product of two vectors.\n    Parameters:\n    v1, v2 (array_like): Input vectors.\n    Returns:\n    float: Dot product of the vectors.\n    \n    Example:\n    >>> vector_dot([1, 2, 3], [4, 5, 6])\n    32.0\n    \"\"\"\n    return np.dot(v1, v2)", "def dot_product(vector1, vector2):\n    \"\"\"\n    Calculate the dot product of two vectors.\n    Parameters:\n        vector1 (array_like): A one-dimensional array representing the first vector.\n        vector2 (array_like): A one-dimensional array representing the second vector.\n    Returns:\n        float: The dot product of the two vectors.\n    Examples:\n        >>> dot_product([1, 2, 3], [4, 5, 6])\n        32.0\n    \"\"\"\n    vector1 = np.array(vector1)\n    vector2 = np.array(vector2)\n    return np.dot(vector1, vector2)", "def vector_dot(v1, v2):\n    \"\"\"\n    Calculate the dot product of two vectors.\n    \n    Parameters:\n        v1 (array): First input vector.\n        v2 (array): Second input vector.\n    Returns:\n        float: The dot product of the two vectors.\n    \"\"\"\n    return np.dot(v1, v2)", "def dot_product(vector_a, vector_b):\n    \"\"\"\n    Calculate the dot product of two vectors.\n    Parameters:\n    vector_a (array-like): First input vector.\n    vector_b (array-like): Second input vector.\n    Returns:\n    float: The dot product of the two vectors.\n    Examples:\n    >>> dot_product(np.array([1, 2, 3]), np.array([4, 5, 6]))\n    32.0\n    \"\"\"\n    return np.dot(vector_a, vector_vec_b)", "def dot_product(v1, v2):\n    \"\"\"\n    Compute the dot product of two vectors.\n    Parameters:\n    - v1 (np.ndarray): The first vector.\n    - v2 (np.ndarray): The second vector.\n    Returns:\n    - float: The dot product of the vectors.\n    Examples:\n    >>> dot_product(np.array([1, 2, 3]), np.array([4, 5, 6]))\n    32.0\n    \"\"\"\n    return np.dot(v1, v2)", "def vector_products(v1, v2, product_type):\n    \"\"\"\n    This function computes the dot and cross product of two vectors.\n    Parameters:\n    v1 (np.array): First vector\n    v2 (np.array): Second vector\n    product_type (str): Type of product required. Values can be 'dot', 'cross'\n    Returns:\n    float or np.array: Result after performing the operation\n    \"\"\"\n    if product_type == 'dot':\n        return np.dot(v1, v2)\n    elif product_type == 'cross':\n        return np.cross(v1, v2)\n    else:\n        print('Invalid Product Type!')", "def vector_dot(v1, v2):\n    \"\"\"\n    Compute the dot product of two vectors.\n    \n    Parameters:\n        v1 (array_like): First vector.\n        v2 (array_like): Second vector.\n        \n    Returns:\n        float: The dot product of the two vectors.\n    \n    Examples:\n        >>> vector_dot([1, 2, 3], [4, 5, 6])\n        32.0\n    \"\"\"\n    return np.dot(v1, v2)"], ["def angle_between_vectors(v1, v2):\n    \"\"\"\n    Calculate the angle in radians between two vectors.\n    \n    Parameters:\n        v1 (array): First input vector.\n        v2 (array): Second input vector.\n    Returns:\n        float: Angle in radians between the two vectors.\n    \"\"\"\n    dot_product = vector_dot(v1, v2)\n    magnitudes = vector_magnitude(v1) * vector_magnitude(v2)\n    return np.arccos(dot_product / magnitudes)", "def angle_between_vectors(v1, v2):\n    \"\"\"\n    Calculate the angle in radians between two vectors using the dot product formula.\n    Parameters:\n    - v1 (np.ndarray): The first vector.\n    - v2 (np.ndarray): The second vector.\n    Returns:\n    - float: The angle in radians between the vectors.\n    Examples:\n    >>> angle_between_vectors(np.array([1, 0]), np.array([0, 1]))\n    1.5707963267948966\n    \"\"\"\n    cosine_angle = dot_product(v1, v2) / (vector_magnitude(v1) * vector_magnitude(v2))\n    return np.arccos(np.clip(cosine_angle, -1, 1))  # clip to handle floating-point errors", "def angle_between_vectors(v1, v2):\n    \"\"\"\n    This function finds the angle between two vectors.\n    Parameters:\n    v1 (np.array): First vector\n    v2 (np.array): Second vector\n    Returns:\n    float: Angle in radians between the two vectors\n    \"\"\"\n    cos_theta = np.dot(v1, v2) / (np.linalg.norm(v1) * np.linalg.norm(v2))\n    return np.arccos(np.clip(cos_theta, -1, 1))"], ["def cross_product(vector_a, vector_b):\n    \"\"\"\n    Calculate the cross product of two vectors.\n    \n    Parameters:\n        vector_a (np.array): The first vector.\n        vector_b (np.array): The second vector.\n    \n    Returns:\n        np.array: The cross product of vector_a and vector_b.\n    \n    Examples:\n        >>> cross_product(np.array([1,2,3]), np.array([4,5,6]))\n        array([-3, 6, -3])\n    \"\"\"\n    return np.cross(vector_a, vector_b)", "def vector_cross(v1, v2):\n    \"\"\"\n    Calculate the cross product of two vectors in 3D space.\n    \n    Parameters:\n        v1 (array): First input vector (3 elements).\n        v2 (array): Second input vector (3 elements).\n    Returns:\n        array: The cross product of the two vectors.\n    \"\"\"\n    return np.cross(v1, v2)", "def cross_product(v1, v2):\n    \"\"\"\n    Compute the cross product of two 3-dimensional vectors.\n    Parameters:\n    - v1 (np.ndarray): The first vector (must be three-dimensional).\n    - v2 (np.ndarray): The second vector (must be three-dimensional).\n    Returns:\n    - np.ndarray: The cross product vector.\n    Examples:\n    >>> cross_product(np.array([1, 2, 3]), np.array([4, 5, 6]))\n    array([-3,  6, -3])\n    \"\"\"\n    return np.cross(v1, v2)"], ["def parallelogram_area(v1, v2):\n    \"\"\"\n    Calculate area of parallelogram formed by two vectors.\n    Parameters:\n    v1, v2 (array_like): Two 2D vectors.\n    Returns:\n    float: Area of the parallelogram.\n    \n    Example:\n    >>> parallelogram_area([1, 0], [0, 1])\n    1.0\n    \"\"\"\n    return np.abs(np.cross(v1, v2))", "def triangle_area(v1, v2):\n    \"\"\"\n    Calculate area of triangle formed by two vectors using half the area of the parallelogram they form.\n    Parameters:\n    v1, v2 (array_like): Two 2D vectors.\n    Returns:\n    float: Area of the triangle.\n    \n    Example:\n    >>> triangle_area([1, 0], [0, 1])\n    0.5\n    \"\"\"\n    return parallelogram_area(v1, v2) / 2", "def parallelogram_area(v1, v2):\n    \"\"\"\n    Calculate the area of the parallelogram formed by two vectors using the determinant method.\n    Parameters:\n        v1 (list or np.array): The first vector.\n        v2 (list or np.array): The second vector.\n    Returns:\n        float: The absolute area of the parallelogram.\n    \n    Example:\n        >>> parallelogram_area([1, 0], [0, 2])\n        2.0\n    \"\"\"\n    return np.abs(np.linalg.det(np.array([v1, v2])))", "def area_of_parallelogram(v1, v2):\n    \"\"\"\n    This function computes the area of a parallelogram formed by two vectors.\n    Parameters:\n    v1 (np.array): First vector\n    v2 (np.array): Second vector\n    Returns:\n    float: Area of the parallelogram\n    \"\"\"\n    return np.linalg.norm(np.cross(v1, v2))"], ["def scalar_multiply(scalar, v):\n    \"\"\"\n    Multiply a vector by a scalar.\n    Parameters:\n    scalar (numeric): Scalar value.\n    v (array_like): Input vector.\n    Returns:\n    ndarray: Resultant vector after multiplication.\n    \n    Example:\n    >>> scalar_multiply(3, [1, 2, 3])\n    array([3, 6, 9])\n    \"\"\"\n    return np.multiply(scalar, v)", "def scalar_multiply(vector, scalar):\n    \"\"\"\n    Multiply a vector by a scalar.\n    Parameters:\n        vector (array_like): The vector to multiply.\n        scalar (float): The scalar multiplier.\n    Returns:\n        ndarray: The result of scalar multiplication of the vector.\n    Examples:\n        >>> scalar_multiply([1, 2, 3], 4)\n        array([4, 8, 12])\n    \"\"\"\n    vector = np.array(vector)\n    return scalar * vector", "def scalar_multiply(scalar, v):\n    \"\"\"\n    Multiply a vector by a scalar.\n    Parameters:\n        scalar (float): The scalar value.\n        v (list or np.array): The vector to be scaled.\n    Returns:\n        np.array: The scaled vector.\n    \n    Example:\n        >>> scalar_multiply(5, [1, 2, 3])\n        array([5, 10, 15])\n    \"\"\"\n    return np.multiply(scalar, v)", "def scalar_multiply(scalar, vector):\n    \"\"\"\n    Multiply a vector by a scalar.\n    Parameters:\n    scalar (float): Scalar value.\n    vector (array-like): Input vector.\n    Returns:\n    ndarray: Resulting vector after multiplication.\n    Examples:\n    >>> scalar_multiply(3, np.array([1, 2, 3]))\n    array([3, 6, 9])\n    \"\"\"\n    return np.multiply(scalar, vector)", "def scalar_multiply(v, scalar):\n    \"\"\"\n    Multiply a vector by a scalar.\n    \n    Parameters:\n        v (array_like): The vector to multiply.\n        scalar (float): The scalar value.\n        \n    Returns:\n        ndarray: The vector multiplied by the scalar.\n    \n    Examples:\n        >>> scalar_multiply([1, 2, 3], 3)\n        array([3, 6, 9])\n    \"\"\"\n    return np.multiply(v, scalar)"], ["def vector_subtract(v1, v2):\n    \"\"\"\n    Subtract one vector from another.\n    Parameters:\n    v1, v2 (array_like): Input vectors.\n    Returns:\n    ndarray: Difference of the two vectors.\n    \n    Example:\n    >>> vector_subtract([4, 5, 6], [1, 2, 3])\n    array([3, 3, 3])\n    \"\"\"\n    return np.subtract(v1, v2)", "def vector_subtract(v1, v2):\n    \"\"\"\n    Subtract the second vector from the first.\n    \n    Parameters:\n        v1 (array): A vector from which to subtract.\n        v2 (array): A vector to subtract.\n    Returns:\n        array: The difference of the two vectors.\n    \"\"\"\n    return np.subtract(v1, v2)", "def vector_subtract(v1, v2):\n    \"\"\"\n    Subtract the second vector from the first vector element-wise.\n    Parameters:\n        v1 (list or np.array): The first vector from which to subtract.\n        v2 (list or np.array): The second vector to subtract.\n    Returns:\n        np.array: The element-wise difference of the vectors.\n    \n    Example:\n        >>> vector_subtract([4, 5, 6], [1, 2, 3])\n        array([3, 3, 3])\n    \"\"\"\n    return np.subtract(v1, v2)", "def vector_subtract(v1, v2):\n    \"\"\"\n    Compute the subtraction of one vector from another.\n    \n    Parameters:\n        v1 (array_like): Vector from which to subtract.\n        v2 (array_shape): Vector to subtract.\n    \n    Returns:\n        ndarray: Resultant vector from subtraction.\n    \n    Examples:\n        >>> vector_subtract([4, 5, 6], [1, 2, 3])\n        array([3, 3, 3])\n    \"\"\"\n    return np.subtract(v1, v2)"], ["def determinant_from_vectors(v1, v2):\n    \"\"\"\n    This function computes the determinant of a 2x2 matrix formed by two vectors.\n    Parameters:\n    v1 (np.array): First vector\n    v2 (np.array): Second vector\n    Returns:\n    float: Determinant of the matrix\n    \"\"\"\n    matrix = np.vstack((v1, v2))\n    return np.linalg.det(matrix)"], ["def vector_add(v1, v2):\n    \"\"\"\n    Add two vectors.\n    Parameters:\n    v1, v2 (array_like): Input vectors.\n    Returns:\n    ndarray: Sum of the two vectors.\n    \n    Example:\n    >>> vector_add([1, 2, 3], [4, 5, 6])\n    array([5, 7, 9])\n    \"\"\"\n    return np.add(v1, v2)", "def vector_add(v1, v2):\n    \"\"\"\n    Add two vectors.\n    \n    Parameters:\n        v1 (array): A vector.\n        v2 (array): Another vector.\n    Returns:\n        array: The sum of the two vectors.\n    \"\"\"\n    return np.add(v1, v2)", "def vector_add(v1, v2):\n    \"\"\"\n    Add two vectors element-wise.\n    Parameters:\n        v1 (list or np.array): The first vector.\n        v2 (list or np.array): The second vector.\n    Returns:\n        np.array: The element-wise sum of the vectors.\n    \n    Example:\n        >>> vector_add([1, 2, 3], [4, 5, 6])\n        array([5, 7, 9])\n    \"\"\"\n    return np.add(v1, v2)", "def vector_add(vector_a, vector_b):\n    \"\"\"\n    Add two vectors.\n    Parameters:\n    vector_a (array-like): First input vector.\n    vector_b (array-like): Second input vector.\n    Returns:\n    ndarray: The resulting vector after addition.\n    Examples:\n    >>> vector_add(np.array([1, 2, 3]), np.array([4, 5, 6]))\n    array([5, 7, 9])\n    \"\"\"\n    return np.add(vector_a, vector_b)", "def vector_add(v1, v2):\n    \"\"\"\n    Compute the addition of two vectors.\n    \n    Parameters:\n        v1 (array_like): First vector.\n        v2 (array_like): Second vector.\n        \n    Returns:\n        ndarray: Resultant vector from addition.\n    \n    Examples:\n        >>> vector_add([1, 2, 3], [4, 5, 6])\n        array([5, 7, 9])\n    \"\"\"\n    return np.add(v1, v2)"], ["def basic_vector_operations(v1, v2, operation):\n    \"\"\"\n    This function performs basic vector operations such as addition, subtraction and scalar multiplication\n    between two vectors.\n    Parameters:\n    v1 (np.array): First vector\n    v2 (float or np.array): Second vector or scalar\n    operation (str): Required operation. Values can be 'add', 'subtract', 'multiply'\n    Returns:\n    np.array: Result vector after performing the operation\n    \"\"\"\n    if operation == 'add':\n        return np.add(v1, v2)\n    elif operation == 'subtract':\n        return np.subtract(v1, v2)\n    elif operation == 'multiply':\n        return np.multiply(v1, v2)\n    else:\n        print('Invalid Operation!')"], ["def are_collinear(v1, v2, tolerance=1e-10):\n    \"\"\"\n    Determine if two vectors are collinear (one is a scalar multiple of the other).\n    \n    Parameters:\n        v1 (array): First input vector.\n        v2 (array): Second input vector.\n        tolerance (float): Numerical tolerance for deviation from exact collinearity.\n    \n    Returns:\n        bool: True if vectors are collinear, False otherwise.\n    \"\"\"\n    cross_prod = vector_cross(v1, v2)\n    return vector_magnitude(cross_prod) < tolerance"], ["def vector_projection(vector_u, vector_v):\n    \"\"\"\n    Project vector u onto vector v.\n    Parameters:\n        vector_u (array_like): The vector to be projected.\n        vector_v (array_like): The vector to project onto.\n    Returns:\n        ndarray: The projection of vector_u onto vector_v.\n    Examples:\n        >>> vector_projection([2, 3], [1, 1])\n        array([2.5, 2.5])\n    \"\"\"\n    vector_u = np.array(vector_u)\n    vector_v = np.array(vector_v)\n    scalar_projection = dot_product(vector_u, vector_v) / dot_product(vector_v, vector_v)\n    projection = scalar_projection * vector_v\n    return projection", "def vector_projection(vector_u, vector_v):\n    \"\"\"\n    Project vector_u onto vector_v.\n    Parameters:\n    vector_u (array-like): The vector to be projected.\n    vector_v (array-like): The vector onto which to project.\n    Returns:\n    ndarray: The projection of vector_u onto vector_v.\n    Examples:\n    >>> vector_projection(np.array([3, 3]), np.array([1, 0]))\n    array([3., 0.])\n    \"\"\"\n    scalar_proj = dot_product(vector_u, vector_v) / dot_product(vector_v, vector_v)\n    return scalar_multiply(scalar_proj, vector_v)", "def vector_projection(u, v):\n    \"\"\"\n    Compute the projection of vector u onto vector v.\n    \n    Parameters:\n        u (array_like): The vector to project.\n        v (array_like): The vector onto which to project.\n    \n    Returns:\n        ndarray: Projection of u onto v.\n    \n    Examples:\n        >>> vector_projection([3, 4], [1, 0])\n        array([3., 0.])\n    \"\"\"\n    v = np.array(v)\n    u = np.array(u)\n    scalar_projection = np.dot(u, v) / np.dot(v, v)\n    return scalar_multiply(v, scalar_projection)"], ["def vector_normalize(v):\n    \"\"\"\n    Normalize a vector to have a magnitude of 1.\n    \n    Parameters:\n        v (array): Input vector.\n    Returns:\n        array: A unit vector in the direction of the input vector.\n    \"\"\"\n    return v / vector_magnitude(v)"], ["def are_orthogonal(v1, v2, tolerance=1e-10):\n    \"\"\"\n    Determine if two vectors are orthogonal (zero dot product).\n    \n    Parameters:\n        v1 (array): First input vector.\n        v2 (array): Second input vector.\n        tolerance (float): Numerical tolerance for considering the dot product as zero.\n    \n    Returns:\n        bool: True if vectors are orthogonal, False otherwise.\n    \"\"\"\n    return np.abs(vector_dot(v1, v2)) < tolerance", "def check_orthogonality(v1, v2, tol=1e-10):\n    \"\"\"\n    Check if two vectors are orthogonal (i.e., their dot product is zero).\n    Parameters:\n    - v1 (np.ndarray): The first vector.\n    - v2 (np.ndarray): The second vector.\n    - tol (float): Tolerance for considering the dot product as zero.\n    Returns:\n    - bool: True if the vectors are orthogonal, False otherwise.\n    Examples:\n    >>> check_orthogonality(np.array([1, 0]), np.array([0, 1]))\n    True\n    \"\"\"\n    return abs(dot_product(v1, v2)) < tol"], ["def unit_vector(vector):\n    \"\"\"\n    Calculate the unit vector in the direction of the given vector.\n    \n    Parameters:\n        vector (np.array): The vector to normalize.\n    \n    Returns:\n        np.array: The unit vector in the direction of 'vector'.\n    \n    Examples:\n        >>> unit_vector(np.array([1,2,3]))\n        array([0.26726124, 0.53452248, 0.80178373])\n    \"\"\"\n    return vector / vector_magnitude(vector)"], ["def line_parameterization(point, direction, t):\n    \"\"\"\n    Define a line parameterization using a point and a direction vector.\n    Parameters:\n        point (list or np.array): A point on the line.\n        direction (list or np.array): The direction vector of the line.\n        t (float): The parameter which scales the direction vector.\n    Returns:\n        np.array: The position vector of a point on the line.\n    \n    Example:\n        >>> line_parameterization([1, 2], [3, 4], 5)\n        array([16, 22])\n    \"\"\"\n    return np.add(point, scalar_multiply(t, direction))"], ["def vector_norm(v, norm_type='L2'):\n    \"\"\"\n    This function returns the norm (magnitude) of a vector.\n    Parameters:\n    v (np.array): Vector\n    norm_type (str): Type of norm required. Default is 'L2' (Euclidean Norm)\n    Returns:\n    float: Norm of the vector\n    \"\"\"\n    return np.linalg.norm(v, ord=norm_type)"], ["def are_orthogonal(vector_a, vector_b):\n    \"\"\"\n    Determine if two vectors are orthogonal (perpendicular).\n    \n    Parameters:\n        vector_a (np.array): The first vector.\n        vector_b (np.array): The second vector.\n    \n    Returns:\n        bool: True if vectors are orthogonal, False otherwise.\n    \n    Examples:\n        >>> are_orthogonal(np.array([1,0,0]), np.array([0,1,0]))\n        True\n    \"\"\"\n    return np.isclose(dot_product(vector_a, vector_b), 0)"], ["def check_collinearity(vector_a, vector_b):\n    \"\"\"\n    Check if two vectors are collinear.\n    Parameters:\n    vector_a (array-like): First vector.\n    vector_b (array-like): Second vector.\n    \n    Returns:\n    bool: True if vectors are collinear, False otherwise.\n    Examples:\n    >>> check_collinearity(np.array([1, 2, 3]), np.array([2, 4, 6]))\n    True\n    \"\"\"\n    cross_product = np.cross(vector_a, vector_b)\n    return np.all(cross_product == 0)"], ["def vector_subtract(vector_a, vector_b):\n    \"\"\"\n    Subtract one vector from another.\n    Parameters:\n    vector_a (array-like): Vector from which to subtract.\n    vector_b (array-like): Vector to be subtracted.\n    Returns:\n    ndarray: The resulting vector after subtraction.\n    Examples:\n    >>> vector_subtract(np.array([5, 7, 9]), np.array([4, 5, 6]))\n    array([1, 2, 3])\n    \"\"\"\n    return np.subtract(vector_a, vector_b)"]], "Determinants": [["def scalar_multiply_determinant_2x2(matrix, scalar):\n    \"\"\"\n    Multiply each element of a 2x2 matrix by a scalar and calculate the new determinant.\n    \n    Parameters:\n        matrix (list of lists): A 2x2 matrix represented as a list of lists.\n        scalar (float or int): The scalar value to multiply by each element of the matrix.\n    Returns:\n        float: The determinant of the new matrix after scalar multiplication.\n    Examples:\n        >>> scalar_multiply_determinant_2x2([[1, 2], [3, 4]], 2)\n        -16.0\n        >>> scalar_multiply_determinant_2x2([[1, 2], [3, 4]], 0)\n        0.0\n    \"\"\"\n    new_matrix = np.multiply(matrix, scalar)\n    return calculate_determinant_2x2(new_matrix)", "def scalar_multiply_matrix(matrix, scalar):\n    \"\"\"\n    Multiplies each element of a 2x2 matrix by a given scalar.\n    \n    Parameters:\n    matrix (list of list of floats): The original 2x2 matrix.\n    scalar (float): The scalar value to multiply with each element of the matrix.\n    \n    Returns:\n    list of list of floats: A new 2x2 matrix each element of which has been multiplied by the scalar.\n    \n    Examples:\n    >>> scalar_multiply_matrix([[1, 2], [3, 4]], 3)\n    [[3, 6], [9, 12]]\n    >>> scalar_multiply_matrix([[1, -1], [-1, 1]], 0.5)\n    [[0.5, -0.5], [-0.5, 0.5]]\n    \"\"\"\n    return [[element * scalar for element in row] for row in matrix]", "def scale_matrix(matrix, scalar):\n    \"\"\"\n    Scales every element of a 2x2 matrix by a given scalar and discusses the impact on the determinant.\n    \n    Parameters\n    ----------\n    matrix : list of lists\n        The 2x2 matrix to be scaled, specified as a list of lists.\n    scalar : float or int\n        The scalar by which every element of the matrix will be multiplied.\n    Returns\n    -------\n    list of lists\n        The new matrix after scaling each element by the specified scalar.\n    \n    Notes\n    -----\n    When each element of a 2x2 matrix is scaled by some factor k, the determinant of the new matrix is k^2 times the original determinant.\n    \n    Examples\n    --------\n    >>> matrix = [[1, 2], [3, 4]]\n    >>> scale_matrix(matrix, 2)\n    [[2, 4], [6, 8]]\n    The determinant scales as (2^2)*(original determinant)\n    \"\"\"\n    \n    return [[scalar * element for element in row] for row in matrix]"], ["def is_orthogonal(matrix):\n    \"\"\"\n    Checks if a given square matrix is orthogonal.\n    \n    Parameters:\n        matrix (np.ndarray): A square numpy array representing the matrix to be checked.\n    Returns:\n        bool: True if the matrix is orthogonal, False otherwise.\n    Examples:\n        >>> is_orthogonal(np.array([[1, 0], [0, 1]]))\n        True\n        >>> is_orthogonal(np.array([[0, 1], [1, 0]]))\n        True\n        >>> is_orthogonal(np.array([[2, 0], [0, 2]]))\n        False\n    \"\"\"\n    if not isinstance(matrix, np.ndarray):\n        raise ValueError(\"The input should be a numpy array\")\n    \n    if matrix.shape[0] != matrix.shape[1]:\n        raise ValueError(\"The matrix must be square\")\n    \n    identity = np.eye(matrix.shape[0])\n    transpose = matrix.T\n    product = np.dot(matrix, transpose)\n    \n    return np.allclose(product, identity)", "def is_orthogonal_matrix(matrix, tol=1e-6):\n    \"\"\"\n    Checks if the matrix is orthogonal, i.e., its transpose multiplied by itself yields the identity matrix.\n    Parameters:\n    matrix (np.array): A numpy array representing a matrix.\n    tol (float): A tolerance value to determine numerical stability.\n    \n    Returns:\n    bool: True if the matrix is orthogonal within the given tolerance, False otherwise.\n    \n    Examples:\n    >>> is_orthogonal_matrix(np.array([[1, 0], [0, 1]]))\n    True\n    >>> is_orthogonal_matrix(np.array([[0.7071, 0.7071], [-0.7071, 0.7071]]))\n    True\n    \"\"\"\n    if matrix.shape[0] != matrix.shape[1]:\n        return False\n    identity_approx =  np.matmul(matrix.T, matrix)\n    identity = np.eye(matrix.shape[0])\n    return np.allclose(identity_approx, identity, atol=tol)", "def is_orthogonal(matrix):\n    \"\"\"\n    Verify if the given matrix is an orthogonal matrix by checking:\n    1. The product of the matrix and its transpose equals the identity matrix.\n    2. The determinant of the matrix is +1 or -1.\n    Parameters:\n        matrix (numpy.ndarray): A square matrix to be verified as orthogonal.\n        \n    Returns:\n        bool: True if the matrix is orthogonal, False otherwise.\n        \n    Example:\n        >>> matrix = np.array([[1, 0], [0, -1]])\n        >>> is_orthogonal(matrix)\n        True\n    \"\"\"\n    identity_matrix = np.eye(matrix.shape[0])\n    transpose_matrix = matrix.T\n    product = np.dot(matrix, transpose_matrix)\n    is_identity = np.allclose(product, identity_matrix)\n    det = linalg.det(matrix)\n    is_det_one_or_neg_one = np.isclose(abs(det), 1)\n    return is_identity and is_det_one_or_neg_one"], ["def determinant_power_rule(matrix, power):\n    \"\"\"\n    Verify the determinant power rule: det(A^n) = (det(A))^n for square matrices.\n    \n    Parameters:\n    - matrix (np.ndarray): A square matrix (2D numpy array).\n    - power (int): The power to which the matrix is raised.\n    \n    Returns:\n    - bool: True if the rule holds for the given matrix and power, False otherwise.\n    - float: The value of det(A^n).\n    - float: The value of (det(A))^n.\n    \n    Raises:\n    - ValueError: If the input matrix is not square.\n    \n    Examples:\n    >>> determinant_power_rule(np.array([[2, 0], [0, 2]]), 3)\n    (True, 8.0, 8.0)\n    \"\"\"\n    # Calculate the determinant of the matrix\n    determinant = calculate_determinant(matrix)\n    \n    # Calculate determinant of the matrix to the given power\n    matrix_power = np.linalg.matrix_power(matrix, power)\n    determinant_of_power = calculate_determinant(matrix_power)\n    \n    # Calculate power of the determinant\n    determinant_to_the_power = determinant ** power\n    \n    # Check if the determinant rule holds\n    rule_holds = np.isclose(determinant_of_power, determinant_to_the_power)\n    \n    return rule_holds, determinant_of_power, determinant_to_the_power", "def matrix_power_determinant(A, power):\n    \"\"\"\n    Calculate the determinant of a matrix raised to a given power.\n    Parameters:\n    A (list of lists or numpy.ndarray): A square matrix (n x n).\n    power (int): The exponent to which the matrix A is to be raised.\n    \n    Returns:\n    float: The determinant of the matrix A raised to the given power.\n    \n    Examples:\n    >>> matrix_power_determinant([[1, 2], [3, 4]], 2)\n    4.000000000000007\n    >>> matrix_power_determinant([[1, 1], [1, 1]], 3)\n    0.0\n    \"\"\"\n    if not isinstance(A, np.ndarray):\n        A = np.array(A)\n    \n    # Calculate matrix A raised to the specified power\n    A_power = np.linalg.matrix_power(A, power)\n    \n    # Compute and return the determinant of the resulting matrix\n    return np.linalg.det(A_power)", "def determinant_power(matrix, n):\n    \"\"\"\n    Calcuate the determinant of a square matrix raised to the power n.\n    Parameters:\n    - matrix (array_like): A square matrix (2D array or nested list) of which the determinant is to be found.\n    - n (int): The power to which the matrix determinant is raised.\n    Returns:\n    - float or int: The determinant of the matrix raised to the nth power.\n    Examples:\n    >>> determinant_power([[1, 2], [3, 4]], 2)\n    4\n    >>> determinant_power([[2, 0], [0, 2]], 3)\n    8\n    \"\"\"\n    det = determinant(matrix)  # Reuse the determinant function\n    return det ** n", "def determinant_power(matrix, power=1):\n    \"\"\"\n    Calculate the determinant of a square matrix raised to a power.\n    \n    This function uses the property that for a square matrix A,\n    det(A^n) = (det(A))^n, to compute the determinant efficiently.\n    \n    Parameters:\n        matrix (np.ndarray): A square numpy array representing the matrix A.\n        power (int): The power n to which the matrix A is raised.\n        \n    Returns:\n        float or complex: The determinant of the matrix A raised to the given power.\n    \n    Examples:\n        >>> A = np.array([[2, 1], [5, 3]])\n        >>> determinant_power(A, 2)\n        6.25\n        >>> determinant_power(A)\n        2.5\n        \n        >>> A = np.array([[1, 2], [3, 4]])\n        >>> determinant_power(A, 3)\n        -27.0\n    \"\"\"\n    if not isinstance(matrix, np.ndarray):\n        raise ValueError(\"The matrix must be a numpy array.\")\n    if matrix.shape[0] != matrix.shape[1]:\n        raise ValueError(\"Matrix must be square.\")\n    \n    # Calculate the determinant of the matrix\n    det_A = np.linalg.det(matrix)\n    \n    # Use the property that det(A^n) = (det(A))^n\n    det_A_n = det_A ** power\n    \n    return det_A_n"], ["def is_invertible(matrix):\n    \"\"\"\n    Check if a given square matrix is invertible by checking if the determinant is non-zero.\n    Parameters:\n    matrix (list of lists or np.ndarray): A square matrix to check for invertibility.\n    Returns:\n    bool: True if the matrix is invertible, False otherwise.\n    \n    Raises:\n    ValueError: If the matrix is not square.\n    Examples:\n    >>> is_invertible([[1, 2], [3, 4]])\n    True\n    >>> is_invertible([[2, 4], [1, 2]])\n    False\n    \"\"\"\n    try:\n        return np.abs(calculate_determinant(matrix)) > 1e-10\n    except ValueError:\n        raise ValueError(\"Input must be a square matrix\")", "def is_matrix_invertible(matrix):\n    \"\"\"\n    Check if a square matrix is invertible.\n    Parameters:\n    - matrix (list of lists or numpy.ndarray): A square matrix to check for invertibility.\n    Returns:\n    - bool: True if the matrix is invertible, False otherwise.\n    Raises:\n    - ValueError: If the input matrix is not square.\n    Examples:\n    >>> is_matrix_invertible([[1, 2], [3, 4]])\n    True\n    >>> is_matrix_invertible([[1, 2, 3], [4, 5, 6], [7, 8, 0]])\n    False\n    \"\"\"\n    det = calculate_determinnt(matrix)\n    return not np.isclose(det, 0)"], ["def solve_linear_system(matrix, constants):\n    \"\"\"\n    Solve a linear system using the matrix of coefficients and a constants vector, relying on determinants.\n    Parameters:\n    matrix (list[list[float]] or sp.Matrix): The coefficient matrix of the system.\n    constants (list[float] or sp.Matrix): The constants vector on the right-hand side of the equations.\n    Returns:\n    Union[sp.Matrix, None]: The solution of the system as a symbolic vector or None if no unique solution exists.\n    \n    Example:\n    >>> solve_linear_system([[2, -1], [5, 3]], [1, 28])\n    Matrix([[6], [7]])\n    \"\"\"\n    matrix = sp.Matrix(matrix)\n    constants = sp.Matrix(constants)\n    \n    if matrix.det() == 0:\n        print(\"The system has no unique solutions or infinitely many solutions.\")\n        return None\n    \n    # Using Cramer's Rule since it's based on determinants to solve\n    return matrix.solve(constants)", "def solve_linear_system(A, b):\n    \"\"\"\n    Solve the linear system Ax = b where A is a square matrix and b is the corresponding vector.\n    Parameters:\n    A (list of lists or numpy.ndarray): Coefficient matrix A of the system (n x n).\n    b (list or numpy.ndarray): Right-hand side vector b of the system (n).\n    \n    Returns:\n    numpy.ndarray or None: The solution vector x of the system. Returns None if the system has no unique solution.\n    \n    Examples:\n    >>> solve_linear_system([[1, 2], [3, 4]], [5, 6])\n    array([-4. ,  4.5])\n    >>> solve_linear_system([[1, 0], [0, 0]], [3, 4]) # No unique solution\n    None\n    \"\"\"\n    A = np.array(A)\n    b = np.array(b)\n    \n    try:\n        det_A = np.linalg.det(A)\n        if abs(det_A) < 1e-10:  # Threshold for considering a determinant to be effectively zero\n            return None\n        return np.linalg.solve(A, b)\n    except np.linalg.LinAlgError:\n        return None"], ["def calculate_determinant(matrix):\n    \"\"\"\n    Calculate the determinant of a given square matrix using recursive expansion by minors.\n    \n    Parameters:\n    matrix (np.array or list of lists): A square matrix represented as a numpy array or nested lists\n    \n    Returns:\n    float or int: The determinant of the matrix\n    \n    Examples:\n    >>> A = np.array([[1, 2], [3, 4]])\n    >>> calculate_determinant(A)\n    -2\n    \n    >>> B = [[1, 2, 3], [0, 1, 4], [5, 6, 0]]\n    >>> calculate_determinant(B)\n    1\n    \"\"\"\n    # Conversion to numpy array if needed\n    matrix = np.array(matrix)\n    n = matrix.shape[0]\n    \n    if matrix.shape[0] != matrix.shape[1]:\n        raise ValueError(\"Matrix must be square\")\n        \n    # Base case for 2x2 matrix\n    if n == 2:\n        return matrix[0, 0] * matrix[1, 1] - matrix[0, 1] * matrix[1, 0]\n    \n    # Recursive case for larger matrices\n    det = 0\n    for c in range(n):\n        minor = np.delete(np.delete(matrix, 0, axis=0), c, axis=1)\n        cofactor = ((-1) ** c) * matrix[0, c] * calculate_determinant(minor)\n        det += cofactor\n    \n    return det", "def calculate_determinant(matrix):\n    \"\"\"\n    Calculate the determinant of a given square matrix using NumPy.\n    Parameters:\n    - matrix (list[list[float]] or np.ndarray): A square matrix for which the determinant is required.\n    Returns:\n    - float: The determinant of the matrix.\n    Raises:\n    - ValueError: If the matrix is not square.\n    Examples:\n    >>> calculate_determinant([[1, 2], [3, 4]])\n    -2.0\n    >>> calculate_determinant([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\n    0.0\n    \"\"\"\n    matrix = np.array(matrix)\n    if matrix.shape[0] != matrix.shape[1]:\n        raise ValueError(\"Matrix must be square to calculate a determinant.\")\n    return np.linalg.det(matrix)", "def compute_determinant(matrix):\n    \"\"\"\n    Computes the determinant of a square matrix.\n    Parameters:\n    matrix (np.array): A square numpy array whose determinant is to be computed.\n    Returns:\n    float: The determinant of the matrix.\n    Raises:\n    ValueError: If the input matrix is not square.\n    Examples:\n    >>> compute_determinant(np.array([[1, 2], [3, 4]]))\n    -2.0\n    >>> compute_determinant(np.array([[1, 2, 3], [0, 1, 4], [5, 6, 0]]))\n    1.0\n    \"\"\"\n    if matrix.shape[0] != matrix.shape[1]:\n        raise ValueError(\"Input must be a square matrix.\")\n    \n    return float(np.linalg.det(matrix))", "def matrix_determinant(matrix):\n    \"\"\"\n    Compute the determinant of a square numpy array.\n    \n    Parameters:\n        matrix (np.ndarray): The matrix of which determinant is needed.\n    Returns:\n        float: The determinant of the matrix.\n    Examples:\n        >>> matrix_determinant(np.array([[1, 0], [0, 1]]))\n        1.0\n        >>> matrix_determinant(np.array([[3, 0, 2], [2, 0, -2], [0, 1, 1]]))\n        -2.0\n    \"\"\"\n    if not isinstance(matrix, np.ndarray):\n        raise ValueError(\"The input should be a numpy array\")\n    \n    if matrix.shape[0] != matrix.shape[1]:\n        raise ValueError(\"The matrix must be square\")\n    \n    return round(np.linalg.det(matrix), 5)", "def calculate_determinant(matrix):\n    \"\"\"\n    Calculate the determinant of the given matrix.\n    \n    Parameters:\n    matrix (list[list[float]] or np.ndarray): A square matrix for which the determinant is needed.\n    Returns:\n    float: The determinant of the matrix.\n    Example:\n    >>> calculate_determinant([[1, 2], [3, 4]])\n    -2.0\n    \"\"\"\n    matrix = np.array(matrix)\n    if matrix.shape[0] != matrix.shape[1]:\n        raise ValueError(\"The matrix must be square to compute the determinant.\")\n    return np.linalg.det(matrix)", "def calculate_determinant(matrix):\n    \"\"\"\n    Calculate and return the determinant of a square matrix.\n    \n    Parameters:\n    - matrix (np.ndarray): A square matrix (2D numpy array).\n    \n    Returns:\n    - float: The determinant of the matrix.\n    \n    Raises:\n    - ValueError: If the input matrix is not square.\n    \n    Examples:\n    >>> calculate_determinant(np.array([[1, 2], [3, 4]]))\n    -2.0\n    \"\"\"\n    # Check if the matrix is square\n    if matrix.shape[0] != matrix.shape[1]:\n        raise ValueError(\"Only square matrices are supported.\")\n    \n    return np.linalg.det(matrix)", "def determinant(matrix):\n    \"\"\"\n    Calculate the determinant of a given square matrix using cofactor expansion.\n    Parameters:\n    matrix (array-like): A square matrix of which the determinant is to be calculated.\n                         The input should be convertible to a numpy array.\n    Returns:\n    float: The determinant of the matrix.\n    Examples:\n    >>> determinant([[1, 2], [3, 4]])\n    -2.0\n    >>> determinant([[1, 0, 0], [0, 1, 0], [0, 0, 1]])\n    1.0\n    \"\"\"\n    \n    # Convert input to numpy array to ensure consistent array handling.\n    matrix = np.array(matrix)\n    \n    # Confirm the matrix is square\n    if matrix.shape[0] != matrix.shape[1]:\n        raise ValueError(\"Only square matrices have determinants\")\n    \n    # Base case for the recursion: if the matrix is 1x1.\n    if matrix.size == 1:\n        return matrix[0, 0]\n    \n    # Base case for a 2x2 matrix.\n    if matrix.shape == (2, 2):\n        return matrix[0, 0] * matrix[1, 1] - matrix[0, 1] * matrix[1, 0]\n    \n    # Recursive case: Expand along the first row\n    det = 0\n    for col in range(matrix.shape[1]):\n        # Exclude the first row and the current column to form the submatrix\n        submatrix = np.delete(np.delete(matrix, 0, axis=0), col, axis=1)\n        # Cofactor expansion: alternate signs and multiply by submatrix determinant\n        sign = (-1) ** col\n        sub_det = determinant(subforward)\n        det += sign * matrix[0, col] * sub_det\n        \n    return det", "def calculate_determinant(matrix):\n    \"\"\"\n    Compute the determinant of a given square matrix.\n    Parameters:\n    matrix (list of lists or numpy.ndarray): A square matrix (n x n) represented as a list of lists or a numpy array.\n    \n    Returns:\n    float: The determinant of the given matrix.\n    Examples:\n    >>> calculate_determinant([[1, 2], [3, 4]])\n    -2.0\n    >>> calculate_determinant([[3, 1, 2], [0, 1, 2], [-1, 1, -3]])\n    -15.0\n    \"\"\"\n    if not isinstance(matrix, np.ndarray):\n        matrix = np.array(matrix)\n    \n    return np.linalg.det(matrix)", "def calculate_determinant(matrix):\n    \"\"\"\n    Calculate the determinant of a given square matrix using NumPy's linalg.det function.\n    Parameters:\n    matrix (list of lists or np.ndarray): A square matrix represented as a list of lists or a NumPy array.\n    Returns:\n    float: The determinant of the matrix.\n    \n    Raises:\n    ValueError: If the matrix is not square.\n    Examples:\n    >>> calculate_determinant([[1, 2], [3, 4]])\n    -2.0\n    >>> calculate_determinant(np.array([[5, 6], [7, 8]]))\n    -2.0\n    \"\"\"\n    matrix = np.array(matrix)  # Convert the matrix to a NumPy array if not already\n    if matrix.shape[0] != matrix.shape[1]:\n        raise ValueError(\"Input must be a square matrix\")\n    return np.linalg.det(matrix)", "def calculate_determinant(matrix):\n    \"\"\"\n    Calculate the determinant of a matrix using numpy.linalg.det for efficiency and accuracy.\n    \n    Parameters:\n    - matrix (list of lists or np.ndarray): The matrix of which the determinant needs to be calculated. \n      It should be square (n x n).\n    \n    Returns:\n    - float: The determinant of the matrix.\n    \n    Examples:\n    >>> calculate_determinant([[1, 2], [3, 4]])\n    -2.0\n    >>> calculate_determinant([[1, 2, 3], [0, 1, 4], [5, 6, 0]])\n    1.0\n    \"\"\"\n    if not isinstance(matrix, np.ndarray):\n        matrix = np.array(matrix)\n    return round(np.linalg.det(matrix), 10)", "def calc_determinant(matrix):\n    \"\"\"\n    Calculates the determinant of a given square matrix.\n    Parameters:\n    matrix (np.array): A squared numpy array representing a matrix.\n    \n    Returns:\n    float: the determinant of the matrix.\n    \n    Examples:\n    >>> calc_determinant(np.array([[1, 0], [0, 1]]))\n    1.0\n    >>> calc_determinant(np.array([[2, 3], [1, 4]]))\n    5.0\n    \"\"\"\n    if not isinstance(matrix, np.ndarray):\n        raise ValueError(\"Input must be a numpy array.\")\n    if matrix.shape[0] != matrix.shape[1]:\n        raise ValueError(\"Matrix must be square.\")\n    \n    det = np.linalg.det(matrix)\n    return det", "def calculate_determinant(matrix):\n    \"\"\"\n    Calculate the determinant of a square matrix.\n    Parameters:\n    - matrix (list of lists or numpy.ndarray): A square matrix for which the determinant is to be calculated.\n    Returns:\n    - float: The determinant of the matrix.\n    Raises:\n    - ValueError: If the input matrix is not square.\n    Examples:\n    >>> calculate_determinant([[1, 2], [3, 4]])\n    -2\n    >>> calculate_determinant([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\n    0\n    \"\"\"\n    matrix_np = np.array(matrix)\n    if matrix_np.shape[0] != matrix_np.shape[1]:\n        raise ValueError(\"Matrix must be square.\")\n    return np.linalg.det(matrix_np)", "def determinant(matrix):\n    \"\"\"\n    Calculate the determinant of a square matrix.\n    Parameters:\n    - matrix (array_like): A square matrix (2D array or nested list) of which the determinant is to be found.\n    Returns:\n    - float or int: The determinant of the matrix.\n    Examples:\n    >>> determinant([[1, 2], [3, 4]])\n    -2\n    >>> determinant([[1, 0, 0], [0, 1, 0], [0, 0, 1]])\n    1\n    \"\"\"\n    mat = np.array(matrix)\n    if mat.shape[0] != mat.shape[1]:\n        raise ValueError(\"Only square matrices are supported.\")\n    return np.linalg.det(mat)", "def calculate_determinant(matrix):\n    \"\"\"\n    Computes the determinant of a square matrix using a recursive method based on cofactor expansion.\n    \n    Parameters\n    ----------\n    matrix : list of lists or sympy.Matrix\n        A square matrix represented as either a list of lists where each sublist represents a row \n        or a sympy.Matrix.\n    Returns\n    -------\n    int or float\n        The determinant of the matrix.\n    \n    Examples\n    --------\n    >>> calculate_determinant([[1, 2], [3, 4]])\n    -2\n    >>> calculate_determinant([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\n    0\n    \n    Raises\n    ------\n    ValueError\n        If the matrix is not square.\n    \"\"\"\n    if not isinstance(matrix, Matrix):\n        matrix = Matrix(matrix)\n    \n    if not matrix.is_square:\n        raise ValueError(\"Only square matrices are supported.\")\n    \n    return matrix.det()", "def optimized_determinant(matrix):\n    \"\"\"\n    Calculate the determinant of a square matrix using numpy's built-in determinant function for efficiency.\n    \n    Parameters\n    ----------\n    matrix : array_like\n        Input matrix, must be a square array (n, n).\n    Returns\n    -------\n    float\n        The determinant of the matrix.\n    \n    Examples\n    --------\n    >>> optimized_determinant([[1, 2], [3, 4]])\n    -2.0\n    >>> optimized_determinant([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\n    0.0\n    Raises\n    ------\n    ValueError\n        If the input is not a square matrix.\n    \"\"\"\n    matrix = np.array(matrix)\n    if matrix.shape[0] != matrix.shape[1]:\n        raise ValueError(\"Input must be a square matrix.\")\n    return np.linalg.det(matrix)", "def calculate_determinant(matrix):\n    \"\"\"\n    Compute the determinant of a matrix.\n    Parameters:\n    matrix (list[list[float]] | np.ndarray): A square matrix of which the determinant is to be calculated.\n    Returns:\n    float: The determinant of the matrix.\n    Examples:\n    >>> calculate_determinant([[1, 2], [3, 4]])\n    -2.0\n    >>> calculate_determinant([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\n    0.0\n    \"\"\"\n    if isinstance(matrix, list):  # If the input is a list, convert it to a NumPy array\n        matrix = np.array(matrix)\n    if matrix.shape[0] != matrix.shape[1]:\n        raise ValueError(\"Only square matrices have determinants\")\n    return np.linalg.det(matrix)", "def calculate_determinant(matrix):\n    \"\"\"\n    Calculate the determinant of a matrix using an optimal method based on the matrix's size.\n    Parameters:\n    - matrix (list of lists or np.ndarray): A square matrix for which the determinant is required.\n    Returns:\n    - float: The computed determinant of the matrix.\n    Raises:\n    - ValueError: If the matrix is not square.\n    Examples:\n    >>> calculate_determin (calculate_determin=\"[ [1, 2], [3, 4] ])\n    -2\n    >>> calculate_determinant([[1, 0, 0], [0, 1, 5], [2, 0, 1]])\n    -5\n    \"\"\"\n    from numpy.linalg import det\n    import numpy as np\n    # Convert list to numpy array if necessary\n    if not isinstance(matrix, np.ndarray):\n        matrix = np.array(matrix)\n    \n    # Check if the matrix is square\n    if matrix.shape[0] != matrix.shape[1]:\n        raise ValueError(\"Matrix must be square\")\n    # Compute and return the determinant\n    return det(matrix)", "def calculate_determinant(matrix):\n    \"\"\"\n    Calculate the determinant of a given square matrix.\n    \n    Parameters:\n        matrix (numpy.ndarray): A square matrix of which the determinant is to be computed.\n    \n    Returns:\n        float: The determinant of the matrix.\n        \n    Example:\n        >>> import numpy as np\n        >>> matrix = np.array([[1, 2], [3, 4]])\n        >>> calculate_determinant(matrix)\n        -2.0\n    \"\"\"\n    return linalg.det(matrix)", "def compute_determinant(matrix):\n    \"\"\"\n    Computes the determinant of a given square matrix.\n    Parameters:\n    - matrix (list of list of floats or numpy array): The matrix for which to compute the determinant.\n    Returns:\n    - float: The determinant of the matrix.\n    Example:\n    >>> compute_determinant([[1, 2], [3, 4]])\n    -2.0\n    >>> compute_determinant([[1, 0, 0], [0, 5, 0], [0, 0, 9]])\n    45.0\n    \"\"\"\n    np_matrix = np.array(matrix)\n    return np.linalg.det(np_matrix)"], ["def cross_product_3d(vector_a, vector_b):\n    \"\"\"\n    Compute the cross product of two vectors in 3D using the determinant.\n    \n    Parameters:\n    - vector_a (array_like): A sequence of three numbers representing the first vector.\n    - vector_b (array_like): A sequence of three numbers representing the second vector.\n    \n    Returns:\n    - ndarray: A numpy array representing the cross product vector.\n    \n    Raises:\n    - ValueError: If the input vectors are not three-dimensional.\n    \n    Examples:\n    >>> cross_product_3d([1, 0, 0], [0, 1, 0])\n    array([0, 0, 1])\n    >>> cross_product_3d([1, 2, 3], [4, 5, 6])\n    array([-3, 6, -3])\n    \"\"\"\n    # Ensure both vectors are numpy arrays and have the shape of (3,)\n    vector_a = np.asarray(vector_a)\n    vector_b = np.asarray(vector_b)\n    if vector_a.shape != (3,) or vector_b.shape != (3,):\n        raise ValueError(\"Both vectors must be three-dimensional.\")\n    \n    # Compute the cross product using the determinant definition and index notation\n    cross_product_vector = np.array([\n        vector_a[1] * vector_b[2] - vector_a[2] * vector_b[1],\n        vector_a[2] * vector_b[0] - vector_a[0] * vector_b[2],\n        vector_a[0] * vector_b[1] - vector_a[1] * vector_b[0]\n    ])\n    \n    return cross_product_vector", "def cross_product_3d(vector1, vector2):\n    \"\"\"\n    Calculate the cross product of two 3-dimensional vectors using determinants.\n    Parameters:\n    vector1 (list): The first vector, a list of three floats or integers.\n    vector2 (list): The second vector, a list of three floats or integers.\n    Returns:\n    list: A list of three elements representing the cross product of the two vectors.\n    Examples:\n    >>> cross_product_3d([1, 2, 3], [4, 5, 6])\n    [-3, 6, -3]\n    >>> cross_product_3d([i, j, k], [x, y, z])\n    [(j*z - k*y), (k*x - i*z), (i*y - j*x)]\n    \"\"\"\n    if len(vector1) != 3 or len(vector2) != 3:\n        raise ValueError(\"Both vectors must be 3-dimensional.\")\n    i_comp = determinant_2x2([[vector1[1], vector1[2]], [vector2[1], vector2[2]]])\n    j_comp = -determinant_2x2([[vector1[0], vector1[2]], [vector2[0], vector2[2]]])\n    k_comp = determinant_2x2([[vector1[0], vector1[1]], [vector2[0], vector2[1]]])\n    return [i_comp, j_comp, k_comp]", "def cross_product_with_determinant(vector1, vector2):\n    \"\"\"\n    Compute the cross product of two 3-dimensional vectors using the determinant method.\n    Parameters:\n    vector1 (array_like): A three-element list or array representing the first vector.\n    vector2 (array_like): A three-element list or array representing the second vector.\n    Returns:\n    ndarray: A numpy array representing the cross product vector, orthogonal to both input vectors.\n    Examples:\n    >>> cross_product_with_determinant([1, 0, 0], [0, 1, 0])\n    array([0, 0, 1])\n    >>> cross_product_with_determinant([1, 2, 3], [4, 5, 6])\n    array([-3,  6, -3])\n    \"\"\"\n    if vector1 is None or vector2 is None:\n        raise ValueError(\"Both vectors must be provided\")\n    # Ensures that both vectors have a length of 3\n    if len(vector1) != 3 or len(vector2) != 3:\n        raise ValueError(\"Both vectors must have three components\")\n    # Create the matrix using standard basis vectors i, j, k and the two input vectors\n    matrix = np.array([\n        [1, 0, 0],    # i hat\n        [0, 1, 0],    # j hat\n        [0, 0, 1],    # k hat\n        vector1,\n        vector2\n    ])\n    # Calculate the cross product using the determinant (expansion by minors method)\n    cross_product = np.array([\n        np.linalg.det(matrix[[1, 2, 4], :]),   # component along i (det of 2x2 submatrix)\n        -np.linalg.det(matrix[[0, 2, 4], :]),  # component along j (det of 2x2 submatrix)\n        np.linalg.det(matrix[[0, 1, 4], :])    # component along k (det of 2x2 submatrix)\n    ])\n    # Convert back the results to a simple array and return\n    return cross_product"], ["def compute_vector_norm(vector, ord=None):\n    \"\"\"\n    Computes the norm of a given vector.\n    Parameters:\n    vector (np.array): The vector to compute the norm of.\n    ord (int, float, optional): Order of the norm. If None, it defaults to 2 (Euclidean norm).\n    Returns:\n    float: The norm of the vector.\n    Examples:\n    >>> compute_vector_norm(np.array([3, 4]))\n    5.0\n    >>> compute_vector_norm(np.array([1, 2, 3]), ord=1)\n    6\n    \"\"\"\n    return np.linalg.norm(vector, ord=ord)"], ["def is_determinant_zero(matrix):\n    \"\"\"\n    Check whether the determinant of a matrix is zero.\n    Parameters:\n    - matrix (list of lists or np.ndarray): A square matrix whose determinant to check.\n    Returns:\n    - bool: True if the determinant of the matrix is zero, otherwise False.\n    Examples:\n    >>> is_determinant_zero([[1, 2], [2, 4]])\n    True\n    >>> is_determinant_zero([[1, 0, 0], [0, 1, 5], [2, 0, 1]])\n    False\n    \"\"\"\n    # Use the calculate_determinant function to compute the determinant\n    determinant = calculate_determinant(matrix)\n    return determinant == 0"], ["def calculate_determinant_2x2(matrix):\n    \"\"\"\n    Calculate the determinant of a 2x2 matrix.\n    \n    Parameters:\n        matrix (list of lists): A 2x2 matrix represented as a list of lists, where each sub-list represents a row.\n    Returns:\n        float: The determinant of the matrix.\n    Examples:\n        >>> calculate_determinant_2x2([[1, 2], [3, 4]])\n        -2\n        >>> calculate_determinant_2x2([[0, 1], [1, 0]])\n        -1\n    \"\"\"\n    if len(matrix) != 2 or len(matrix[0]) != 2:\n        raise ValueError(\"The input must be a 2x2 matrix.\")\n    \n    return np.linalg.det(np.array(matrix))", "def determinant_2x2(matrix):\n    \"\"\"\n    Calculate the determinant of a 2x2 matrix.\n    Parameters:\n    matrix (list of lists): A 2x2 matrix represented as a list of two lists, each containing two elements.\n    Returns:\n    float: The determinant of the given 2x2 matrix.\n    Examples:\n    >>> determinant_2x2([[a, b], [c, d]])\n    a*d - b*c\n    >>> determinant_2x2([[1, 2], [3, 4]])\n    -2\n    \"\"\"\n    if len(matrix) != 2 or len(matrix[0]) != 2 or len(matrix[1]) != 2:\n        raise ValueError(\"Input must be a 2x2 matrix.\")\n    \n    return matrix[0][0] * matrix[1][1] - matrix[0][1] * matrix[1][0]", "def calculate_determinant_2x2(matrix):\n    \"\"\"\n    Calculate the determinant of a 2x2 matrix.\n    \n    Parameters:\n    matrix (list of list of floats): A 2x2 matrix in the form [[a, b], [c, d]].\n    Returns:\n    float: The determinant of the matrix calculated as ad - bc.\n    \n    Examples:\n    >>> calculate_determinant_2x2([[1, 2], [3, 4]])\n    -2\n    >>> calculate_determinant_2x2([[0, 1], [1, 0]])\n    -1\n    \"\"\"\n    if len(matrix) != 2 or len(matrix[0]) != 2 or len(matrix[1]) != 2:\n        raise ValueError(\"The input matrix must be of size 2x2.\")\n    \n    a, b = matrix[0]\n    c, d = matrix[1]\n    return a * d - b * c", "def calculate_2x2_determinant(matrix):\n    \"\"\"\n    Calculate the determinant of a 2x2 matrix.\n    Parameters\n    ----------\n    matrix : list of lists\n        A 2x2 matrix specified as a list of lists where each sublist represents a row.\n    Returns\n    -------\n    float\n        The determinant of the given 2x2 matrix.\n    Examples\n    --------\n    >>> matrix = [[a, b], [c, d]]\n    >>> calculate_2x2_determinant(matrix)\n    ad - bc\n    \n    >>> matrix = [[1, 2], [3, 4]]\n    >>> calculate_2x2_determinant(matrix)\n    -2\n    \"\"\"\n    if len(matrix) != 2 or any(len(row) != 2 for row in matrix):\n        raise ValueError(\"Input matrix must be 2x2.\")\n    \n    a, b = matrix[0]\n    c, d = matrix[1]\n    \n    return a * d - b * c"], ["def analyze_system_matrix(matrix):\n    \"\"\"\n    Analyze the determinant of a system's matrix to determine the existence of non-trivial solutions,\n    using properties surrounding the determinant.\n    Parameters:\n    - matrix (list[list[float]] or np.ndarray): A square matrix from a system of linear equations.\n    Returns:\n    - str: Analysis of the system based on the determinant.\n    Examples:\n    >>> analyze_system_matrix([[1, 1], [2, 2]])\n    'System has infinitely many solutions (determinant is zero).'\n    >>> analyze_system_matrix([[1, 2], [3, 4]])\n    'System has a unique solution (determinant is non-zero).'\n    \"\"\"\n    determinant = calculate_determinant(matrix)\n    if np.isclose(determinant, 0):\n        return 'System has infinitely many solutions (determinant is zero).'\n    else:\n        return 'System has a unique solution (determinant is non-zero).'"], ["def check_linear_independence(*vectors):\n    \"\"\"\n    Checks if the given vectors are linearly independent.\n    Parameters:\n    - vectors (tuple of lists): Vectors to check linear independence.\n    Returns:\n    - bool: True if vectors are linearly independent, False otherwise.\n    Example:\n    >>> check_linear_independence([1, 2], [2, 4])\n    False\n    >>> check_linear_independence([1, 0, 0], [0, 1, 0], [0, 0, 1])\n    True\n    \"\"\"\n    matrix = np.array(vectors).T  # form a matrix with vectors as columns\n    determinant = np.linalg.det(matrix)\n    return np.isclose(determinant, 0, atol=1e-9)  # Check if the determinant is effectively zero"], ["def transform_and_determinant_2x2(matrix, row, scalar=None, subtract_row=None):\n    \"\"\"\n    Apply simple transformations such as row multiplication by a scalar, or subtraction of one row from another,\n    and calculate the determinant of the resulting matrix.\n    Parameters:\n        matrix (list of lists): A 2x2 matrix represented as a list of lists.\n        row (int): The index of the row to transform.\n        scalar (float, optional): Scalar to multiply the row with. If None, no multiplication is performed.\n        subtract_row (int, optional): Row index from which the selected row should be subtracted.\n    Returns:\n        float: The determinant of the transformed matrix.\n    Examples:\n        >>> transform_and_determinant_2x2([[1, 2], [3, 4]], row=1, scalar=2)\n        -16.0\n        >>> transform_and_determinant_2x2([[2, 2], [3, 3]], row=1, subtract_row=0)\n        0.0\n    \"\"\"\n    new_matrix = [list(r) for r in matrix]  # Create a copy of the matrix\n    if scalar is not None:\n        new_matrix[row] = [x * scalar for x in new_matrix[row]]\n    if subtract_row is not None:\n        new_matrix[row] = [x - y for x, y in zip(new_matrix[row], new_matrix[subtract_row])]\n    \n    return calculate_determinant_2x2(new_matrix)"], ["def calculate_determinant(matrix, symbolic=False):\n    \"\"\"\n    Compute the determinant of a square matrix using numeric or symbolic computation.\n    \n    Parameters:\n    - matrix (list of lists or sympy.Matrix): Matrix for which the determinant is to be calculated.\n    - symbolic (bool): If True, will treat the matrix elements as symbols for symbolic computation. Otherwise, will perform numerical computation.\n    \n    Returns:\n    - float or sympy.Expr: The determinant of the matrix.\n    \n    Examples:\n    >>> calculate_determinant([[1, 2], [3, 4]])\n    -2\n    >>> calculate_determinant([[1, 2], [3, 4]], symbolic=True)\n    -2\n    >>> m = sp.Matrix([[sp.cos(x), -sp.sin(x)], [sp.sin(x), sp.cos(x)]])\n    >>> calculate_determinant(m, symbolic=True)\n    1\n    \"\"\"\n    if symbolic:\n        # Assure the input is a sympy Matrix for symbolic computation\n        if not isinstance(matrix, sp.Matrix):\n            matrix = sp.Matrix(matrix)\n        return matrix.det()\n    else:\n        # Use numpy for numeric computation\n        matrix = np.array(matrix)\n        return round(float(np.linalg.det(matrix)), 10)  # rounded for floating-point precision issues"], ["class MatrixDeterminantTools:\n    \"\"\"\n    A collection of tools for working with determinants of matrices, addressing a variety of subtasks related to linear algebra and determinant properties.\n    \"\"\"\n    @staticmethod\n    def calculate_determinant(matrix):\n        \"\"\"\n        Calculate the determinant of a given square matrix.\n        Parameters:\n        matrix (np.ndarray): A square matrix whose determinant is to be calculated.\n        Returns:\n        float: The determinant of the matrix.\n        Example:\n        >>> MatrixDeterminantTools.calculate_determinant(np.array([[1, 2], [3, 4]]))\n        -2.0\n        \"\"\"\n        return np.linalg.det(matrix)\n    @staticmethod\n    def system_to_matrix(coefficients):\n        \"\"\"\n        Converts a list of coefficient lists from a system of linear equations into a matrix.\n        Parameters:\n        coefficients (list of lists): Coefficients from a system of equations, where each sublist represents the coefficients of one equation.\n        Returns:\n        np.ndarray: The coefficient matrix.\n        Example:\n        >>> MatrixDeterminantTools.system_to_matrix([[1, -2], [3, 4]])\n        array([[ 1, -2],\n               [ 3,  4]])\n        \"\"\"\n        return np.array(coefficients)\n    @staticmethod\n    def determinant_special_cases(matrix):\n        \"\"\"\n        Computes and checks determinant special cases for certain pre-defined matrices like identity, zero or diagonal matrices.\n        Parameters:\n        matrix (np.ndarray): The matrix to check special cases for.\n        Returns:\n        str: Description of the determinant case.\n        Example:\n        >>> MatrixDeterminantTools.determinant_special_cases(np.eye(2))\n        'Determinant of the identity matrix is 1.'\n        \"\"\"\n        if np.array_equal(matrix, np.eye(len(matrix))):\n            return f\"Determinant of the identity matrix is 1.\"\n        elif np.all((matrix == 0)):\n            return f\"Determinant of the zero matrix is 0.\"\n        elif np.allclose(matrix, np.diag(np.diagonal(matrix))):\n            return f\"Determinant of the diagonal matrix is product of its diagonal elements: {np.prod(np.diagonal(matrix))}.\"\n        return \"No special determinant case recognized. Consider computing normally.\"\n    @staticmethod\n    def determinant_and_matrix_powers(matrix, power):\n        \"\"\"\n        Computes determinant of a matrix raised to a specific power.\n        Parameters:\n        matrix (np.ndarray): The base matrix.\n        power (int): The power to which the matrix is to be raised.\n        Returns:\n        float: The determinant of the matrix raised to the given power.\n        Example:\n        >>> MatrixDeterminantTools.determinant_and_matrix_powers(np.array([[1, 2], [3, 4]]), 2)\n        4.0\n        \"\"\"\n        exp_matrix = np.linalg.matrix_power(matrix, power)\n        return np.linalg.det(exp_matrix)\n    @staticmethod\n    def solve_linear_system(matrix, identity):\n        \"\"\"\n        Solves a linear system where the matrix product is equated to an identity matrix.\n        Parameters:\n        matrix (np.ndarray): The coefficient matrix.\n        identity (np.ndarray): The identity matrix, typically `np.eye(n)`.\n        Returns:\n        np.ndarray: Solution to the system.\n        Example:\n        >>> MatrixDeterminantTools.solve_linear_system(np.array([[1, 2], [3, 4]]), np.eye(2))\n        array([[-2. ,  1. ],\n               [ 1.5, -0.5]])\n        \"\"\"\n        if MatrixDeterminantTools.calculate_determinant(matrix) == 0:\n            raise ValueError(\"The matrix is singular and cannot be inverted.\")\n        return np.linalg.inv(matrix)"]], "Vectors and Parametric Equations": [["def cross_product(v1, v2):\n    \"\"\"\n    Calculates the cross product of two 3D vectors.\n    Parameters:\n        v1, v2 (np.array): Input vectors.\n    Returns:\n        np.array: The cross product vector.\n    \n    Examples:\n        >>> cross_product(np.array([1, 0, 0]), np.array([0, 1, 0]))\n        array([0, 0, 1])\n    \"\"\"\n    return np.cross(v1, v2)", "def dot_product(v1, v2):\n    \"\"\"Compute the dot product of two vectors.\n    \n    Parameters:\n        v1 (np.array): First vector.\n        v2 (np.docarray): Second vector.\n        \n    Returns:\n        float: Dot product of the two vectors.\n    \"\"\"\n    return np.dot(v1, v2)", "def cross_product(v1, v2):\n    \"\"\"Compute the cross product of two vectors (3-dimensional).\n    \n    Parameters:\n        v1 (np.array): First vector.\n        v2 (np.array): Second vector.\n        \n    Returns:\n        np.array: Cross product of the two vectors.\n    \"\"\"\n    return np.cross(v1, v2)", "def dot_product(v1, v2):\n    \"\"\"\n    Computes the dot product of two vectors.\n    \n    Parameters:\n    v1 (array-like): First vector.\n    v2 (array-like): Second vector.\n    Returns:\n    float: Dot product of the vectors.\n    \n    Examples:\n    >>> dot_product([1, 2, 3], [4, 5, 6])\n    32.0\n    \"\"\"\n    return np.dot(v1, v2)", "def cross_product(v1, v2):\n    \"\"\"\n    Computes the cross product of two vectors in 3D.\n    \n    Parameters:\n    v1 (array-like): First vector in 3D.\n    v2 (array-like): Second vector in 3D.\n    Returns:\n    numpy.ndarray: Cross product of the vectors.\n    \n    Examples:\n    >>> cross_product([1, 2, 3], [4, 5, 6])\n    array([-3,  6, -3])\n    \"\"\"\n    return np.cross(v1, v2)"], ["def subtract_vectors(v1, v2):\n    \"\"\"Subtract one vector from another.\n    \n    Parameters:\n        v1 (np.array): Vector from which to subtract.\n        v2 (np.array): Vector to subtract.\n        \n    Returns:\n        np.array: Resultant vector after subtraction.\n    \"\"\"\n    return np.subtract(v1, v2)", "def subtract_vectors(v1, v2):\n    \"\"\"\n    Subtracts the second vector from the first.\n    \n    Parameters:\n    v1 (array-like): Vector from which to subtract.\n    v2 (array-like): Vector to subtract.\n    Returns:\n    numpy.ndarray: Difference of the vectors.\n    \n    Examples:\n    >>> subtract_vectors([5, 7, 9], [1, 2, 3])\n    array([4, 5, 6])\n    \"\"\"\n    return np.subtract(v1, v2)"], ["def vector_norm(v):\n    \"\"\"\n    Calculates the norm (magnitude) of a vector.\n    Parameters:\n        v (np.array): A vector.\n    Returns:\n        float: The norm of the vector.\n    \n    Examples:\n        >>> vector_norm(np.array([3, 4]))\n        5.0\n    \"\"\"\n    return np.linalg.norm(v)", "def vector_magnitude(v):\n    \"\"\"Compute the magnitude (norm) of a vector.\n    \n    Parameters:\n        v (np.array): Vector.\n        \n    Returns:\n        float: Magnitude of the vector.\n    \"\"\"\n    return np.linalg.norm(v)", "def vector_norm(v):\n    \"\"\"\n    Computes the norm (magnitude) of a vector.\n    \n    Parameters:\n    v (array-like): Input vector.\n    Returns:\n    float: Norm of the vector.\n    \n    Examples:\n    >>> vector_norm([3, 4])\n    5.0\n    \"\"\"\n    return np.linalg.norm(v)"], ["def vector_decomposition(v, w):\n    \"\"\"\n    Decompose vector v into two components, where one is parallel and the other\n    is orthogonal to vector w.\n    Parameters:\n    v (array-like): The vector to be decomposed.\n    w (array-like): The vector used for decomposition reference.\n    Returns:\n    tuple: A tuple containing the parallel component and the orthogonal component\n           of vector v with respect to w.\n    \n    Examples:\n    >>> v = np.array([3, 4])\n    >>> w = np.array([1, 0])\n    >>> parallel, orthogonal = vector_decomposition(v, w)\n    >>> parallel\n    array([3., 0.])\n    >>> orthogonal\n    array([0., 4.])\n    \"\"\"\n    v = np.asarray(v)\n    w = np.asarray(w)\n    parallel = vector_projection(v, w)\n    orthogonal = v - parallel\n    return parallel, orthogonal", "def vector_decomposition(v, w):\n    \"\"\"\n    Decompose vector v into components parallel and orthogonal to vector w.\n    \n    Parameters:\n        v (np.ndarray): A numpy array representing vector v.\n        w (np.ndarray): A numpy array representing vector w.\n        \n    Returns:\n        tuple: A tuple containing two numpy arrays:\n               1. The component of v parallel to w.\n               2. The component of v orthogonal to w.\n    \n    Example:\n        >>> v = np.array([3, 4])\n        >>> w = np.array([1, 0])\n        >>> parallel, orthogonal = vector_decomposition(v, w)\n        >>> parallel\n        array([3., 0.])\n        >>> orthogonal\n        array([0., 4.])\n    \"\"\"\n    # Calculate the parallel component (projection of v onto w)\n    parallel_component = vector_projection(v, w)\n    # Calculate the orthogonal component (v minus the parallel component)\n    orthogonal_component = v - parallel_committee\n    return (parallel_component, orthogonal_component", "def vector_decomposition(v, w):\n    \"\"\"\n    Decompose vector v into components parallel and orthogonal to vector w.\n    Parameters:\n    v (np.array): The vector to be decomposed. Must be a 1D numpy array.\n    w (np.array): The vector used for the decomposition. Must be a 1D numpy array.\n    Returns:\n    tuple: A tuple containing two numpy arrays:\n          - The first array is the parallel component of v with respect to w.\n          - The second array is the orthogonal component of v with respect to w.\n    Examples:\n    >>> vector_decomposition(np.array([3, 4]), np.array([1, 0]))\n    (array([3., 0.]), array([0., 4.]))\n    >>> vector_decomposition(np.array([1, 2, 3]), np.array([4, 5, 6]))\n    (array([0.81538462, 1.01923077, 1.22307692]), array([0.18461538, 0.98076923, 1.77692308]))\n    \"\"\"\n    parallel_component = vector_projection(v, w)\n    orthogonal_component = v - parallel_component\n    return (parallel_component, orthogonal_component)"], ["def vector_projection(v, w):\n    \"\"\"\n    Calculates the vector projection of vector v onto vector w.\n    Parameters:\n    v (array-like): The vector to be projected.\n    w (array-like): The vector onto which v is projected.\n    Returns:\n    numpy.ndarray: The projection of vector v onto vector w.\n    \n    Examples:\n    >>> v = np.array([3, 4])\n    >>> w = np.array([1, 0])\n    >>> vector_projection(v, w)\n    array([3., 0.])\n    \"\"\"\n    v = np.asarray(v)\n    w = np.asarray(w)\n    return (np.dot(v, w) / np.dot(w, w)) * w", "def vector_projection(v, w):\n    \"\"\"\n    Compute the projection of vector v onto vector w.\n    Parameters:\n        v (np.ndarray): A numpy array representing vector v.\n        w (np.ndarray): A numpy array representing vector w.\n    Returns:\n        np.ndarray: A vector representing the projection of v onto w.\n    Example:\n        >>> vector_projection(np.array([3, 4]), np.array([1, 0]))\n        array([3., 0.])\n    \"\"\"\n    # Compute the dot product of v and w\n    dot_product = np.dot(v, w)\n    # Compute the norm squared of w\n    norm_w_squared = np.dot(w, w)\n    # Compute the projection\n    projection = (dot_product / norm_w_squared) * w\n    return projection", "def vector_projection(v, w):\n    \"\"\"\n    Compute the projection of vector v onto vector w using the projection formula.\n    Parameters:\n    v (np.array): The vector to be projected. Must be a 1D numpy array.\n    w (np.array): The vector onto which v is projected. Must be a 1D numpy array.\n    Returns:\n    np.array: The projection of vector v onto vector w.\n    Examples:\n    >>> vector_projection(np.array([3, 4]), np.array([1, 0]))\n    array([3., 0.])\n    >>> vector_projection(np.array([1, 2, 3]), np.array([4, 5, 6]))\n    array([0.81538462, 1.01923077, 1.22307692])\n    \"\"\"\n    v = np.asarray(v)\n    w = np.asarray(w)\n    projection = np.dot(v, w) / np.dot(w, w) * w\n    return projection"], ["def add_vectors(v1, v2):\n    \"\"\"Add two vectors.\n    \n    Parameters:\n        v1 (np.array): First vector.\n        v2 (np.array): Second vector.\n        \n    Returns:\n        np.array: Resultant vector after addition.\n    \"\"\"\n    return np.add(v1, v2)", "def add_vectors(v1, v2):\n    \"\"\"\n    Adds two vectors.\n    \n    Parameters:\n    v1 (array-like): First vector.\n    v2 (array-like): Second vector.\n    Returns:\n    numpy.ndarray: Sum of the vectors.\n    \n    Examples:\n    >>> add_vectors([1, 2, 3], [4, 5, 6])\n    array([5, 7, 9])\n    \"\"\"\n    return np.add(v1, v2)"], ["def find_line_intersection(v1, d1, v2, d2):\n    \"\"\"\n    Finds the intersection (if any) of two lines defined in parametric form.\n    Parameters:\n        v1, v2 (np.array): Origin point vectors of the two lines.\n        d1, d2 (np.array): Direction vectors of the two lines.\n    Returns:\n        tuple: (has_intersection, point) where has_intersection is a Boolean and \n               point is the intersection point as a numpy array or None if no intersection exists.\n    Examples:\n        >>> find_line_intersection(np.array([0, 0]), np.array([1, 1]), np.array([1, 0]), np.array([-1, 1]))\n        (True, array([0.5, 0.5]))\n    \"\"\"\n    from sympy import symbols, Eq, solve, linsolve\n    t, s = symbols('t s')\n    p1 = v1 + d1 * t\n    p2 = v2 + d2 * s\n    equations = [Eq(p1[0], p2[0]), Eq(p1[1], p2[1])]\n    solution = linsolve(equations, t, s)\n    if solution:\n        t_val, s_val = tuple(solution.args[0])\n        intersection_point = evaluate_line(v1, d1, t_val)\n        return True, np.array(intersection_point, dtype=float)\n    else:\n        return False, None", "def parametric_line_intersection(p1, d1, p2, d2):\n    \"\"\"\n    Finds the intersection point of two parameterized lines, if one exists.\n    Parametric form of the lines are:\n    L1: p1 + t * d1\n    L2: p2 + s * d2\n    \n    Parameters:\n    p1 (array-like): A point on the first line.\n    d1 (array-like): Direction vector of the first line.\n    p2 (array-like): A point on the second line.\n    d2 (array-like): Direction vector of the second line.\n    Returns:\n    Union[None, numpy.ndarray]: The point of intersection, or None if no unique intersection exists.\n    \n    Examples:\n    >>> parametric_line_intersection([1, 2], [3, 4], [1, 1], [2, -1])\n    array([2., 0.])\n    \"\"\"\n    t, s = symbols('t s', real=True)\n    equations = [Eq(p1[i] + t * d1[i], p2[i] + s * d2[i]) for i in range(len(p1))]\n    result = solve(equations, (t, s))\n    \n    if not result or isinstance(result, list):  # No solution or infinite solutions\n        return None\n    t_val, s_val = result[t], result[s]\n    intersection = np.array(p1) + t_val * np.array(d1)\n    return intersection"], ["def are_lines_parallel(d1, d2):\n    \"\"\"Check if two direction vectors are parallel.\n    \n    Parameters:\n        d1, d2 (np.array): Direction vectors of two lines.\n        \n    Returns:\n        bool: True if lines are parallel, else False.\n    \"\"\"\n    cross_prod = cross_product(d1, d2)\n    return np.allclose(cross_prod, np.zeros_like(cross_prod))"], ["def parametric_line(p, d):\n    \"\"\"Create a parametric line equation from a point and a direction vector.\n    \n    Parameters:\n        p (np.array): A point on the line (position vector).\n        d (np.array): Direction vector of the line.\n        \n    Returns:\n        function: A function that computes a point on the line given a parameter t.\n    \"\"\"\n    def line(t):\n        return p + t * d\n    return line"], ["def find_intersection(l1, l2):\n    \"\"\"Find the intersection point of two parametric lines if exists.\n    \n    Parameters:\n        l1 (function): First line as a function.\n        l2 (function): Second line as a function.\n    \n    Returns:\n        np.array or None: The intersection point or None if there is no intersection.\n    \"\"\"\n    from scipy.optimize import fsolve\n    def func(t):\n        t1, t2 = t\n        return l1(t1) - l2(t2)\n    \n    sol = fsolve(func, [0, 0])\n    if np.allclose(func(sol), np.zeros_like(sol)):\n        return l1(sol[0])\n    return None"], ["def evaluate_line(v, d, t):\n    \"\"\"\n    Evaluates the parametric equation of a line at a given parameter value.\n    Parameters:\n        v (np.array): The point vector (origin) of the line.\n        d (np.array): The direction vector of the line.\n        t (float or np.array): The parameter at which to evaluate the line.\n    Returns:\n        np.array: The coordinates of the line at parameter t.\n    \n    Examples:\n        >>> evaluate_line(np.array([1, 1]), np.array([2, 2]), 0.5)\n        array([2., 2.])\n    \"\"\"\n    return v + t * d"], ["def area_of_triangle(v1, v2):\n    \"\"\"\n    Calculates the area of a triangle formed by vectors originating from the same point.\n    Parameters:\n        v1, v2 (np.array): Two vectors that form two sides of the triangle.\n    Returns:\n        float: The area of the triangle.\n    \n    Examples:\n        >>> area_of_triangle(np.array([1, 0, 0]), np.array([0, 1, 0]))\n        0.5\n    \"\"\"\n    return 0.5 * np.linalg.norm(cross_product(v1, v2))"]]}