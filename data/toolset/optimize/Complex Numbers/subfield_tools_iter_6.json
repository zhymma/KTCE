{"Absolute Value": [{"tool": "def modulus_complex(z):\n    \n    return np.abs(z)", "subfield": "Absolute Value", "tool_name": "modulus_complex", "tool_type": "function", "description": "Computes the modulus (absolute value) of a complex number.", "docstring": "Computes the modulus (absolute value) of a complex number.\n    Parameters:\n        z (complex): The complex number to compute the modulus for.\n    Returns:\n        float: The modulus of the complex number.", "Freq": 53, "TSR": 33, "experience_pool": "- Experience: When using the `modulus_complex()` function, make sure to pass a complex number as the parameter. The function expects a complex number and will raise an error if a different type is provided.\n- Experience: The `modulus_complex()` function uses the `np.abs()` function from the NumPy library to calculate the modulus of a complex number. Make sure to import the NumPy library (`import numpy as np`) before using the function."}, {"tool": "def conjugate(z):\n    \n    return np.conj(z)", "subfield": "Absolute Value", "tool_name": "conjugate", "tool_type": "function", "description": "Return the complex conjugate of the given complex number.\n    \n    :param z: complex, a complex number in the form a + bi.\n    :return: complex, the conjugate of the complex number.\n    Examples\n    --------\n    >>> conjugate(3 + 4j)\n    (3-4j)", "docstring": "Return the complex conjugate of the given complex number.\n    \n    :param z: complex, a complex number in the form a + bi.\n    :return: complex, the conjugate of the complex number.\n    Examples\n    --------\n    >>> conjugate(3 + 4j)\n    (3-4j)", "Freq": 12, "TSR": 7, "experience_pool": "- Problem: If $e^{i \\alpha} + e^{i \\beta} = \\frac{1}{4} + \\frac{3}{7} i,$ then find $e^{-i \\alpha} + e^{-i \\beta}.$\n  Answer: \\frac{1}{4} - \\frac{3}{7} i\n  Solution: The provided code correctly calculates the complex conjugate of the given complex numbers and returns the expected result.\n- Problem: The equation of the line joining the complex numbers $-2 + 3i$ and $1 + i$ can be expressed in the form\n  \\[az + b \\overline{z} = 10\\]for some complex numbers $a$ and $b$.  Find the product $ab$.\n  Answer: 13\n  Solution: The provided code correctly calculates the product of complex numbers and returns the expected result.\n- Problem: Convert $e^{11 \\pi i/2}$ to rectangular form.\n  Answer: -i\n  Solution: The provided code correctly calculates the complex conjugate of the given complex number and returns the expected result."}, {"tool": "def complex_operations(a, b, operation='multiply'):\n    \n    if operation == 'multiply':\n        return np.multiply(a, b)\n    elif operation == 'divide':\n        return np.divide(a, b)\n    elif operation == 'add':\n        return np.add(a, b)\n    elif operation == 'power':\n        return np.power(a, int(b.real))  # b is assumed to be an integer for power\n    else:\n        raise ValueError(\"Unsupported operation. Use 'multiply', 'divide', 'add', or 'power'.\")", "subfield": "Absolute Value", "tool_name": "complex_operations", "tool_type": "function", "description": "Perform operations (multiply, divide, add, power) on two complex numbers given in Cartesian form.", "docstring": "Perform operations (multiply, divide, add, power) on two complex numbers given in Cartesian form.\n    Parameters:\n    a (complex): First complex number in the form a + bi.\n    b (complex): Second complex number in the form a + bi.\n    operation (str): The operation to perform ['multiply', 'divide', 'add', 'power'].\n    Returns:\n    complex: The result of the operation.\n    Examples:\n    >> complex_operations(complex(1, 1), complex(2, 3), 'multiply')\n    (-1+5j)", "Freq": 21.25, "TSR": 11.5, "experience_pool": "Experience 1:\nProblem: The tool code is missing the necessary import statement for the numpy library, causing an \"Unsupported operation\" error.\nSolution: Add the import statement `import numpy as np` at the beginning of the tool code.\n\nExperience 2:\nProblem: The tool code is not handling the 'add' operation correctly.\nSolution: Add a new condition in the `complex_operations` function to handle the 'add' operation using the numpy `add` function."}, {"tool": "def divide_complex(z1, z2):\n    if z2 == 0:\n        raise ZeroDivisionError(\"Denominator cannot be zero.\")\n    return z1 / z2", "subfield": "Absolute Value", "tool_name": "divide_complex", "tool_type": "function", "description": "None", "docstring": null, "Freq": 3.0, "TSR": 1}, {"tool": "def conjugate_complex_number(c):\n    \n    return c.conjugate()", "subfield": "Absolute Value", "tool_name": "conjugate_complex_number", "tool_type": "function", "description": "This function computes the conjugate of a complex number.", "docstring": "This function computes the conjugate of a complex number.\n    Parameters:\n    c (complex): Complex number\n    Returns:\n    complex : The conjugate of the complex number `c`.", "Freq": 1, "TSR": 1}, {"tool": "def absolute_value_complex(complex_number):\n    \n    return abs(complex_number)", "subfield": "Absolute Value", "tool_name": "absolute_value_complex", "tool_type": "function", "description": "Computes the absolute value (modulus) of a complex number.", "docstring": "Computes the absolute value (modulus) of a complex number.\n    Parameters:\n    - complex_number (complex): The complex number for which to find the modulus.\n    Returns:\n    - float: The modulus of the complex number.\n    Example:\n    >>> absolute_value_complex(3+4j)\n    5.0", "Freq": 8, "TSR": 7}, {"tool": "def argument_complex(z):\n    \n    return np.angle(z)", "subfield": "Absolute Value", "tool_name": "argument_complex", "tool_type": "function", "description": "Computes the argument (angle) of a complex number.", "docstring": "Computes the argument (angle) of a complex number.\n    \n    Parameters:\n        z (complex): The complex number to compute the argument for.\n        \n    Returns:\n        float: The argument of the complex number in radians.", "Freq": 2, "TSR": 1, "experience_pool": "Tool code was modified to include the necessary import statement for the `np` module."}, {"tool": "def absolute_complex_number(c):\n    \n    return abs(c)", "subfield": "Absolute Value", "tool_name": "absolute_complex_number", "tool_type": "function", "description": "This function computes the absolute value (magnitude) of a complex number.", "docstring": "This function computes the absolute value (magnitude) of a complex number.\n    Parameters:\n    c (complex): Complex number whose absolute value has to be computed.\n    Returns:\n    float : absolute value (magnitude) of the input complex number `c`.", "Freq": 1, "TSR": 0}, {"tool": "def multiplicative_property(z1, z2):\n    \n    return abs(z1 * z2)", "subfield": "Absolute Value", "tool_name": "multiplicative_property", "tool_type": "function", "description": "Apply the multiplicative property of moduli on two complex numbers.", "docstring": "Apply the multiplicative property of moduli on two complex numbers.\n    Parameters\n    ----------\n    z1, z2 : complex\n        Two complex numbers.\n    Returns\n    -------\n    float\n        The product of the moduli of the given complex numbers, demonstrating that |z1*z2| = |z1|*|z2|.\n    Examples\n    --------\n    >>> multiplicative_property(1+2j, 3+4j)\n    10.0", "Freq": 7, "TSR": 7}, {"tool": "def complex_to_cartesian(z):\n    \n    return (z.real, z.imag)", "subfield": "Absolute Value", "tool_name": "complex_to_cartesian", "tool_type": "function", "description": "Decomposes a complex number into its real and imaginary parts.", "docstring": "Decomposes a complex number into its real and imaginary parts.\n    Parameters:\n        z (complex): The complex number to decompose.\n    Returns:\n        tuple: A tuple containing the real part and imaginary part of the complex number.", "Freq": 1, "TSR": 0}, {"tool": "def magnitude_phase(z):\n    \n    return (abs(z), cmath.phase(z))", "subfield": "Absolute Value", "tool_name": "magnitude_phase", "tool_type": "function", "description": "Computes the magnitude and phase of the complex number.", "docstring": "Computes the magnitude and phase of the complex number.\n    \n    Parameters:\n        z (complex): The complex number.\n    \n    Returns:\n        tuple: Magnitude and phase (angle in radians) of the complex number.\n    \n    Examples:\n        >>> magnitude_phase(1+2j)\n        (2.23606797749979, 1.1071487177940904)", "Freq": 1, "TSR": 0}, {"tool": "def complex_magnitude(z):\n    \n    return abs(z)", "subfield": "Absolute Value", "tool_name": "complex_magnitude", "tool_type": "function", "description": "Calculates the magnitude of the complex number.", "docstring": "Calculates the magnitude of the complex number.\n    Parameters:\n    - z (complex): A complex number.\n    Returns:\n    - float: The magnitude (absolute value) of the complex number.\n    Examples:\n    >>> complex_magnitude(3+4j)\n    5.0", "Freq": 1, "TSR": 0}, {"tool": "def solve_complex_equation(coefficients, target):\n    \n    import numpy as np\n    # Convert the coefficients to a numpy array\n    coefficients = np.array(coefficients, dtype=complex)\n    # Solve the equation using numpy's roots function\n    solutions = np.roots(coefficients)\n    # Round the solutions to avoid floating point errors\n    solutions = np.round(solutions, decimals=10)\n    # Filter out solutions that are not equal to the target value\n    solutions = [s for s in solutions if np.isclose(s, target)]\n    return solutions", "subfield": "Absolute Value", "tool_name": "solve_complex_equation", "tool_type": "function", "description": "Solve an equation with complex coefficients.", "docstring": "Solve an equation with complex coefficients.\n    Parameters:\n    coefficients (list): A list of complex coefficients of the equation.\n    target (complex): The target value to solve for.\n    Returns:\n    solutions (list): A list of complex solutions to the equation.", "Freq": 9, "TSR": 2}, {"tool": "def solve_complex_equation(coefficients, target):\n    \n    import numpy as np\n    # Convert the coefficients to a numpy array\n    coefficients = np.array(coefficients, dtype=complex)\n    # Solve the equation using numpy's roots function\n    solutions = np.roots(coefficients) \n    # Round the solutions to avoid floating point errors\n    solutions = np.round(solutions, decimals=10)\n    # Filter out solutions that are not equal to the target value\n    solutions = [s for s in solutions if np.isclose(s, target)]\n    return solutions", "subfield": "Absolute Value", "tool_name": "solve_complex_equation", "tool_type": "function", "description": "Solve an equation with complex coefficients.", "docstring": "Solve an equation with complex coefficients.\n    Parameters:\n    coefficients (list): A list of complex coefficients of the equation.\n    target (complex): The target value to solve for.\n    Returns:\n    solutions (list): A list of complex solutions to the equation.\n    Examples:\n    >>> solve_complex_equation([1, -4, 5], 0)\n    [2.5+0.5j, 2.5-0.5j]\n    >>> solve_complex_equation([1, -3, 3, -1], 1)\n    [1+0j]", "Freq": 2, "TSR": 1}, {"tool": "def product_complex_exponential(numbers):\n    \n    product = 1\n    for number in numbers:\n        product *= number\n    return product", "subfield": "Absolute Value", "tool_name": "product_complex_exponential", "tool_type": "function", "description": "Calculate the product of complex numbers in exponential form.", "docstring": "Calculate the product of complex numbers in exponential form.\n    Parameters:\n    numbers (list): A list of complex numbers in exponential form.\n    Returns:\n    complex: The product of the complex numbers.\n    Examples:\n    >>> numbers = [cmath.exp(1j * 0.5), cmath.exp(1j * 1.5), cmath.exp(1j * 2.5)]\n    >>> product_complex_exponential(numbers)\n    (-0.5+0.86602540378j)", "Freq": 0, "TSR": 0}], "Function Operations": []}