{"Limits": [{"tool": "def evaluate_limit(expression, variable, approaching_value, direction='both'):\n    \n    # Convert input to sympy format if necessary\n    if isinstance(expression, str):\n        expression = sp.sympify(expression)\n    if isinstance(variable, str):\n        variable = sp.Symbol(variable)\n    \n    if direction == 'both':\n        limit_value = sp.limit(expression, variable, approaching_value)\n    elif direction == '+':\n        limit_value = sp.limit(expression, variable, approaching_value, dir='+')\n    elif direction == '-':\n        limit_value = sp.limit(expression, variable, approaching_value, dir='-')\n    else:\n        raise ValueError(\"Direction must be 'both', '+', or '-'.\")\n    return limit_value", "subfield": "Limits", "tool_name": "evaluate_limit", "tool_type": "function", "description": "Evaluates the limit of a given symbolic expression as the variable approaches a specified value.", "docstring": "Evaluates the limit of a given symbolic expression as the variable approaches a specified value.\n    Parameters:\n    - expression (str or sympy.Expr): The mathematical expression for which the limit is to be calculated.\n    - variable (str or sympy.Symbol): The variable in the expression that approaches a certain value.\n    - approaching_value: The point that the variable approaches (can be a finite number, sp.oo for infinity).\n    - direction (str, optional): The direction of limit calculation ('both', '+', or '-'). Defaults to 'both' for two-sided limits.\n    Returns:\n    - limit_value (sympy.Expr): The evaluated limit of the expression.\n    Examples:\n    >>> evaluate_limit('1/x', 'x', 0, '+')\n    oo\n    >>> evaluate_limit('1/x', 'x', 0, '-')\n    -oo\n    >>> evaluate_limit('sin(x)/x', 'x', sp.oo)\n    0", "Freq": 0, "TSR": 0}, {"tool": "def check_piecewise_continuity(piecewise_func, check_points):\n    \n    results = {}\n    variable = piecewise_func.args[0][0].free_symbols.pop()  # Extract the primary variable\n    \n    for point in check_points:\n        limit_left = sp.limit(piecewise_func, variable, point, dir='-')\n        limit_right = sp.limit(piecewise_func, variable, point, dir='+')\n        func_value = piecewise_func.subs(variable, point)\n        # Check if both one-sided limits and the function value at the point are equal\n        is_continuous = (limit_left == limit_right == func_value)\n        results[point] = is_continuous\n    \n    return results", "subfield": "Limits", "tool_name": "check_piecewise_continuity", "tool_type": "function", "description": "Checks the continuity of a piecewise function at specified points and evaluates limits from both sides.", "docstring": "Checks the continuity of a piecewise function at specified points and evaluates limits from both sides.\n    Parameters:\n    - piecewise_func (sympy.Piecewise): The piecewise function to check.\n    - check_points (list): Points at which to check the continuity.\n    Returns:\n    - results (dict): A dictionary where keys are points and values are boolean indicating continuity at that point.\n    Examples:\n    >>> f = sp.Piecewise((x**2, x < 1), (x + 1, x >= 1))\n    >>> check_piecewise_continuity(f, [1])\n    {1: True}", "Freq": 1, "TSR": 1}, {"tool": "def check_continuity(expression, var, point):\n    \n    expr = sp.sympify(expression) if isinstance(expression, str) else expression\n    var = sp.symbols(var) if isinstance(var, str) else var\n    \n    left_limit = evaluate_limit(expr, var, point, dir='-')\n    right_limit = evaluate_limit(expr, var, point, dir='+')\n    value_at_point = expr.subs(var, point) if not isinstance(expr, sp.Piecewise) else expr.subs(var, point).simplify()\n    \n    is_continuous = left_limit == right_limit == value_attempt if point_potent and potential_value_at_point\n    is_continuous = left_limit ==_ability == potential_value_if point is true or \n    ensuring to-rested ressity at the left \n    return {\n        'left_limit': left_limit,\n        'right_limit': right_limit,\n        'value_at_point': value_at_point,\n        'is_continuous': is_continuous\n    }", "subfield": "Limits", "tool_name": "check_continuity", "tool_type": "function", "description": "Check continuity of an expression at a given point and provide limit evaluations from both sides.", "docstring": "Check continuity of an expression at a given point and provide limit evaluations from both sides.\n    \n    Parameters:\n    - expression : str or sympy.Expr\n        Expression whose continuity at a point is to be checked.\n    - var : str or sympo.Symbol\n        Variable in the expression, typically where the point is being substituted.\n    - point : numeric or sympy.expr\n        Point at which to check the continuity.\n        \n    Returns:\n    - continuity_info : dict\n        Dictionary returning left-hand limit, right-hand limit, and bool indicating continuity at the point.\n    \n    Examples:\n    -------\n    >>> expr = \"sp.Piecewise((x**2, x < 1), (x + 1, x >= 1))\"\n    >>> check_continuity(expr, 'x', 1)\n    {'left_limit': 1, 'right_limit': 2, 'is_continuous': False}", "Freq": 0, "TSR": 0}], "Function Operations": [{"tool": "def compose_functions(f, g, var):\n    \n    return f.subs(var, g)", "subfield": "Function Operations", "tool_name": "compose_functions", "tool_type": "function", "description": "Compose two functions f(g(x)).", "docstring": "Compose two functions f(g(x)).\n    \n    Parameters:\n        f (sympy expression): The outer function f(x).\n        g (sympy expression): The inner function g(x).\n        var (sympy symbol): The variable with respect to which the functions are defined.\n    Returns:\n        sympy expression: The composition of the functions as a symbolic expression.\n    Examples:\n        x = symbols('x')\n        f = x**2\n        g = 2*x + 1\n        print(compose_functions(f, g, x))  # Returns (2*x + 1)**2", "Freq": 1, "TSR": 1}, {"tool": "def differentiate_function(expr, var, point=None):\n    \n    derivative = diff(expr, var)\n    if point is not None:\n        return derivative.subs(var, point)\n    return derivative", "subfield": "Function Operations", "tool_name": "differentiate_function", "tool_type": "function", "description": "Differentiate an expression with respect to a given variable and optionally evaluate at a specific point.", "docstring": "Differentiate an expression with respect to a given variable and optionally evaluate at a specific point.\n    \n    Parameters:\n        expr (sympy expression): The symbolic expression of the function.\n        var (sympy symbol): The variable with respect to which the expression is differentiated.\n        point (float, optional): The point at which the derivative is evaluated. If None, the function returns a symbolic derivative.\n    Returns:\n        sympy expression or float: The derivative of the function as a symbolic expression or the evaluation result at a given point.\n    \n    Examples:\n        x = symbols('x')\n        expr = x**2 + 3*x + 2\n        print(differentiate_function(expr, x))  # Returns 2*x + 3\n        print(differentiate_function(expr, x, point=1))  # Returns 5", "Freq": 2, "TSR": 0}, {"tool": "def simplify_trigonometric_expression(expr):\n    \n    return simplify(expand_trig(expr))", "subfield": "Function Operations", "tool_name": "simplify_trigonometric_expression", "tool_type": "function", "description": "Simplifies a given trigonometric expression using trigonometric identities.", "docstring": "Simplifies a given trigonometric expression using trigonometric identities.\n    Parameters:\n    expr (sympy.Expr): The trigonometric expression to simplify\n    \n    Returns:\n    sympy.Expr: Simplified expression\n    \n    Examples:\n    >>> x = symbols('x')\n    >>> expr = sin(x)**2 + cos(x)**2\n    >>> simplify_trigonometric_expression(expr)\n    1", "Freq": 1, "TSR": 0}, {"tool": "def evaluate_function_at_point(function_expression, point):\n    \n    x = symbols('x')\n    expression = sympify(function_expression)\n    func = lambdify(x, expression, 'numpy')\n    return func(point)", "subfield": "Function Operations", "tool_name": "evaluate_function_at_point", "tool_type": "function", "description": "Evaluates a mathematical function at a specific point.", "docstring": "Evaluates a mathematical function at a specific point.\n    \n    Parameters:\n        function_expression (str): The algebraic expression of the function.\n        point (float/int): The x-value at which the function should be evaluated.\n    \n    Returns:\n        float: The function value at the specified point.\n    \n    Examples:\n        >>> evaluate_function_at_point('x**2 - 2*x + 1', 5)\n        16", "Freq": 0, "TSR": 0}, {"tool": "def differentiate_function(f, respect_to):\n    \n    return sp.diff(f, respect_to)", "subfield": "Function Operations", "tool_name": "differentiate_function", "tool_type": "function", "description": "Differentiate a function with respect to a given variable.", "docstring": "Differentiate a function with respect to a given variable.\n    Parameters:\n    f (sympy expression): The function to be differentiated.\n    respect_to (sympy symbol): The variable with respect to which the differentiation is performed.\n    Returns:\n    sympy expression: The derivative of the function.\n    Examples:\n    >>> x = sp.symbols('x')\n    >>> f = x**2\n    >>> df = differentiate_function(f, x)\n    >>> df\n    2*x", "Freq": 0, "TSR": 0}, {"tool": "def function_operations(f, g, operation, x_val=None):\n    \n    x = sp.symbols('x')\n    result = None\n    \n    if operation == 'add':\n        result = f + g\n    elif operation == 'subtract':\n        result = f - g\n    elif operation == 'multiply':\n        result = f * g\n    elif operation == 'divide':\n        result = f / g\n    elif operation == 'compose':\n        result = f.subs(x, g)\n    \n    if x_val is not None:\n        return result.subs(x, x_val)\n    return result", "subfield": "Function Operations", "tool_name": "function_operations", "tool_type": "function", "description": "Perform basic arithmetic operations on two functions and evaluate at a specific point if requested.", "docstring": "Perform basic arithmetic operations on two functions and evaluate at a specific point if requested.\n    \n    Parameters:\n        f (sympy expression or function): The first mathematical function.\n        g (sympy expression or function): The second mathematical function.\n        operation (str): The operation to perform ('add', 'subtract', 'multiply', 'divide', 'compose').\n        x_val (float, optional): The x value at which the resultant function should be evaluated.\n    \n    Returns:\n        sympy expression or numeric: The resulting function after applying the operation, or a numeric value if `x_val` is provided.\n    \n    Examples:\n        >>> x = sp.symbols('x')\n        >>> f = sp.sin(x)\n        >>> g = sp.cos(x)\n        >>> print(function_operations(f, g, 'add'))\n        sin(x) + cos(x)\n        \n        >>> print(function_operations(f, g, 'compose'))\n        sin(cos(x))\n        \n        >>> print(function_operations(f, g, 'add', 0))\n        1", "Freq": 0, "TSR": 0}, {"tool": "def evaluate_function_at_points(func, var, points):\n    \n    lambdified_func = lambdify(var, func)\n    return [lambdified_func(point) for point in points]", "subfield": "Function Operations", "tool_name": "evaluate_function_at_points", "tool_type": "function", "description": "Evaluate a symbolic function at multiple points.", "docstring": "Evaluate a symbolic function at multiple points.\n    Parameters:\n        func (sympy expression): The symbolic function to evaluate.\n        var (sympy symbol): The variable used in the function.\n        points (list): A list of points at which to evaluate the function.\n    Returns:\n        list: Results of the function evaluation at the specified points.\n    Examples:\n        x = symbols('x')\n        func = x**2 + 3*x + 2\n        points = [1, 2, 3]\n        print(evaluate_function_at_points(func, x, points))  # Returns [6, 12, 20]", "Freq": 0, "TSR": 0}, {"tool": "def translate_function(expression, horizontal_shift=0, vertical_shift=0):\n    \n    x = symbols('x')\n    func = sympify(expression)\n    transformed_func = func.subs(x, x - horizontal_shift) + vertical_shift\n    return transformed_func", "subfield": "Function Operations", "tool_name": "translate_function", "tool_type": "function", "description": "Apply horizontal and vertical translations to the function expression.", "docstring": "Apply horizontal and vertical translations to the function expression.\n    \n    Parameters:\n        expression (str): The expression of the function in x.\n        horizontal_shift (float): The shift along the x-axis (positive right, negative left).\n        vertical_shift (float): The shift along the y-axis (positive up, negative down).\n    Returns:\n        sympy expression: New function expression after translation.", "Freq": 0, "TSR": 0}, {"tool": "def function_operations(f_expr1, f_expr2, operation, var):\n    \n    x = sp.symbols(var)\n    func1 = sp.sympify(f_expr1)\n    func2 = sp.sympify(f_expr2)\n    if operation == 'add':\n        result = func1 + func2\n    elif operation == 'subtract':\n        result = func1 - func2\n    elif operation == 'multiply':\n        result = func1 * func2\n    elif operation == 'divide':\n        result = func1 / func2\n    else:\n        raise ValueError(\"Invalid operation. Choose from 'add', 'subtract', 'multiply', 'divide'.\")\n    return result", "subfield": "Function Operations", "tool_name": "function_operations", "tool_type": "function", "description": "Performs a specified operation between two functions.", "docstring": "Performs a specified operation between two functions.\n    \n    Parameters:\n    f_expr1 (str or sympy expression): The first function expression.\n    f_expr2 (str or sympy expression): The second function expression.\n    operation (str): Operation to perform. Should be one of ['add', 'subtract', 'multiply', 'divide'].\n    var (str): The variable used in both functions.\n    Returns:\n    sympy expression: Result of the operation between the two functions.\n    Example:\n    --------\n    >>> function_operations('x**2', 'x + 1', 'add', 'x')\n    x**2 + x + 1", "Freq": 0, "TSR": 0}, {"tool": "def polar_to_cartesian(r, theta):\n    \n    x = r * sp.cos(theta)\n    y = r * sp.sin(theta)\n    return x, y", "subfield": "Function Operations", "tool_name": "polar_to_cartesian", "tool_type": "function", "description": "Convert polar coordinates to Cartesian coordinates.", "docstring": "Convert polar coordinates to Cartesian coordinates.\n    \n    Parameters\n    ----------\n    r : sympy.Expr\n        The polar radius.\n    theta : sympy.Symbol\n        The polar angle.\n    \n    Returns\n    -------\n    tuple\n        A tuple containing the x and y expressions in Cartesian coordinates.\n    \n    Examples\n    --------\n    >>> r = sp.symbols('r')\n    >>> theta = sp.symbols('theta')\n    >>> polar_to_cartesian(r, theta)\n    (r*cos(theta), r*sin(theta))", "Freq": 1, "TSR": 1}, {"tool": "def function_composition(outer_function_expr, inner_function_expr, x_value):\n    \n    x = symbols('x')\n    g = sympify(inner_function_expr)\n    f = sympify(outer_function_expr)\n    composed_expr = f.subs(x, g)\n    composed_func = lambdify(x, composed_expr, 'numpy')\n    return composed_func(x_value)", "subfield": "Function Operations", "tool_name": "function_composition", "tool_type": "function", "description": "Composes two functions (f(g(x))) and evaluates at a specific x-value.", "docstring": "Composes two functions (f(g(x))) and evaluates at a specific x-value.\n    \n    Parameters:\n        outer_function_expr (str): The expression for the outer function f(x).\n        inner_function_expr (str): The expression for the inner function g(x).\n        x_value (float/int): The x-value to evaluate the composition at.\n        \n    Returns:\n        float: The result of the composed function evaluated at `x_value`.\n        \n    Examples:\n        >>> function_composition('x+1', 'x**2', 2)\n        5", "Freq": 0, "TSR": 0}, {"tool": "def derivative_function(expression, point):\n    \n    x = symbols('x')\n    func = sympify(expression)\n    deriv = diff(func, x)\n    return deriv.subs(x, point)", "subfield": "Function Operations", "tool_name": "derivative_function", "tool_type": "function", "description": "Calculates the derivative of the function at a specific point.", "docstring": "Calculates the derivative of the function at a specific point.\n    \n    Parameters:\n        expression (str): The expression of the function in x.\n        point (float): The x value at which to evaluate the derivative.\n    Returns:\n        float: The derivative of the function at the given point.", "Freq": 0, "TSR": 0}, {"tool": "def find_horizontal_translation(function_expression, translation_value):\n    \n    x = symbols('x')\n    expression = sympify(function_expression)\n    translated_expr = expression.subs(x, x - translation_value)\n    return str(translated_expr)", "subfield": "Function Operations", "tool_name": "find_horizontal_translation", "tool_type": "function", "description": "Finds the new expression of a function after a horizontal translation.", "docstring": "Finds the new expression of a function after a horizontal translation.\n    \n    Parameters:\n        function_expression (str): The algebraic expression of the function.\n        translation_value (float/int): The value to translate the function on the x-axis.\n    \n    Returns:\n        str: The algebraic expression of the translated function.\n        \n    Examples:\n        >>> find_horizontal_translation('x**2', -3)\n        '(x + 3)**2'", "Freq": 0, "TSR": 0}, {"tool": "def apply_pytogorean_identity(expr, x):\n    \n    expr = expr.subs(sin(x)**2, 1 - cos(x)**2)\n    return expr.subs(cos(x)**2, 1 - sin(x)**2)", "subfield": "Function Operations", "tool_name": "apply_pytogorean_identity", "tool_type": "function", "description": "Apply the Pythagorean identity to replace sin^2(x) or cos^2(x) in the expression.", "docstring": "Apply the Pythagorean identity to replace sin^2(x) or cos^2(x) in the expression.\n    Parameters:\n    expr (sympy.Expr): Expression to modify\n    x (sympy.Symbol): symbol representing the variable in expression\n    \n    Returns:\n    sympy.Expr: Expression after applying the identity\n    \n    Examples:\n    >>> x = symbols('x')\n    >>> expr = sin(x)**2 + 3\n    >>> apply_pytogorean_identity(expr, x)\n    1 - cos(x)**2 + 3", "Freq": 0, "TSR": 0}, {"tool": "def evaluate_graph_properties(f, x_range, properties):\n    \n    x = sp.symbols('x')\n    results = {}\n    \n    if 'intercepts' in properties:\n        results['intercepts'] = [sp.solve(f, x)]\n    \n    if 'minima' in properties:\n        deriv = sp.diff(f, x)\n        critical_points = sp.solve(deriv, x)\n        second_deriv = sp.diff(deriv, x)\n        minima = [(cp, f.subs(x, cp)) for cp in critical_points if second_deriv.subs(x, cp) > 0]\n        results['minima'] = minima\n    \n    if 'continuity' in properties:\n        points_of_discontinuity = sp.singularities(f, x)\n        continuous = all(p not in x_range for p in points_of_discontinuity)\n        results['continuity'] = continuous\n    return results", "subfield": "Function Operations", "tool_name": "evaluate_graph_properties", "tool_type": "function", "description": "Evaluate various properties of a function's graph such as intercepts, minima, and continuity over a specified range.", "docstring": "Evaluate various properties of a function's graph such as intercepts, minima, and continuity over a specified range.\n    \n    Parameters:\n        f (sympy expression): The function to analyze.\n        x_range (tuple): The range (start, end) of x values to consider.\n        properties (list): List of properties to evaluate ('intercepts', 'minima', 'continuity').\n    \n    Returns:\n        dict: A dictionary with requested properties and their evaluated results.\n    \n    Examples:\n        >>> x = sp.symbols('x')\n        >>> f = x ** 2 - 4 * x + 4\n        >>> print(evaluate_graph_properties(f, (-10, 10), ['intercepts', 'minima']))\n        {'intercepts': [2], 'minima': [(2, 0)]}", "Freq": 0, "TSR": 0}, {"tool": "def translate_function(f, var, translation):\n    \n    return f.subs(var, var - translation)", "subfield": "Function Operations", "tool_name": "translate_function", "tool_type": "function", "description": "Translate the function horizontally or vertically.", "docstring": "Translate the function horizontally or vertically.\n    \n    Parameters\n    ----------\n    f : sympy.Expr\n        The function to be translated.\n    var : sympy.Symbol\n        The variable of the function.\n    translation : sympy.Expr\n        The translation vector.\n    \n    Returns\n    -------\n    sympy.Expr\n        The translated function.\n    \n    Examples\n    --------\n    >>> x = sp.Symbol('x')\n    >>> f = x**2\n    >>> translate_function(f, x, 2)\n    (x - 2)**2", "Freq": 0, "TSR": 0}, {"tool": "def reflect_function(expression, axis='x'):\n    \n    x = symbols('x')\n    func = sympify(expression)\n    if axis == 'x':\n        reflected_func = func * -1\n    elif axis == 'y':\n        reflected_func = func.subs(x, -x)\n    else:\n        raise ValueError(\"axis must be 'x' or 'y'\")\n    return reflected_func", "subfield": "Function Operations", "tool_name": "reflect_function", "tool_type": "function", "description": "Reflect the function across a specified axis ('x' or 'y').", "docstring": "Reflect the function across a specified axis ('x' or 'y').\n    \n    Parameters:\n        expression (str): The expression of the function in x.\n        axis (str): The axis to reflect across ('x' or 'y').\n    Returns:\n        sympy expression: New function expression after reflection.", "Freq": 0, "TSR": 0}, {"tool": "def substitute_function(f, var, subs_var):\n    \n    return f.subs(var, subs_var)", "subfield": "Function Operations", "tool_name": "substitute_function", "tool_type": "function", "description": "Substitute variable in a function expression.", "docstring": "Substitute variable in a function expression.\n    \n    Parameters\n    ----------\n    f : sympy.Expr\n        The function expression.\n    var : sympy.Symbol\n        The original variable in the function.\n    subs_var : sympy.Expr\n        The expression to substitute for the original variable.\n    \n    Returns\n    -------\n    sympy.Expr\n        The substituted function.\n    \n    Examples\n    --------\n    >>> x = sp.Symbol('x')\n    >>> f = x**2 + 1\n    >>> substitute_function(f, x, x + 2)\n    (x + 2)**2 + 1", "Freq": 0, "TSR": 0}, {"tool": "def factorize_expression(expr):\n    \n    return sp.factor(expr)", "subfield": "Function Operations", "tool_name": "factorize_expression", "tool_type": "function", "description": "Factorize a given expression.", "docstring": "Factorize a given expression.\n    \n    Parameters\n    ----------\n    expr : sympy.Expr\n        The expression to be factorized.\n    \n    Returns\n    -------\n    sympy.Expr\n        The factorized expression.\n    \n    Examples\n    --------\n    >>> x = sp.Symbol('x')\n    >>> expr = x**2 - 4\n    >>> factorize_expression(expr)\n    (x - 2)*(x + 2)", "Freq": 0, "TSR": 0}, {"tool": "def subtract_functions(function_expression1, function_expression2, x_value):\n    \n    x = symbols('x')\n    f1 = sympify(function_expression1)\n    f2 = sympify(function_expression2)\n    f_sub = f1 - f2\n    func_sub = lambdify(x, f_sub, 'numpy')\n    return func_sub(x_value)", "subfield": "Function Operations", "tool_name": "subtract_functions", "tool_type": "function", "description": "Subtracts the second function from the first at a specific x-value.", "docstring": "Subtracts the second function from the first at a specific x-value.\n    \n    Parameters:\n        function_expression1 (str): The expression for the first function.\n        function_expression2 (str): The expression for the second function.\n        x_value (float/int): The x-value at which to perform the subtraction.\n        \n    Returns:\n        float: The result of the subtraction at the specified x-value.\n        \n    Examples:\n        >>> subtract_functions('x**2', '2*x', 3)\n        3", "Freq": 0, "TSR": 0}, {"tool": "def check_continuity(expr, var, point):\n    \n    left_limit = expr.subs(var, point - 1e-6)\n    right_limit = expr.subs(var, point + 1e-6)\n    point_value = expr.subs(var, point)\n    return abs(left_limit - point_value) < 1e-5 and abs(right_limit - point_value) < 1e-5", "subfield": "Function Operations", "tool_name": "check_continuity", "tool_type": "function", "description": "Check if a function is continuous at a given point.", "docstring": "Check if a function is continuous at a given point.\n    \n    Parameters:\n        expr (sympy expression): The symbolic expression of the function.\n        var (sympy symbol): The variable in the expression.\n        point (float): The point at which continuity is checked.\n    Returns:\n        bool: True if the function is continuous at the specified point, False otherwise.\n    \n    Examples:\n        x = symbols('x')\n        expr = Piecewise((x**2, x < 0), (x + 2, x >= 0))\n        print(check_continuity(expr, x, 0))  # Returns False", "Freq": 0, "TSR": 0}, {"tool": "def vertical_scale_function(f, scale_factor):\n    \n    return scale_factor * f", "subfield": "Function Operations", "tool_name": "vertical_scale_function", "tool_type": "function", "description": "Apply vertical scaling to a function.", "docstring": "Apply vertical scaling to a function.\n    \n    Parameters\n    ----------\n    f : sympy.Expr\n        The function to be scaled.\n    scale_factor : float\n        The scaling factor.\n    \n    Returns\n    -------\n    sympy.Expr\n        The scaled function.\n    \n    Examples\n    --------\n    >>> x = sp.Symbol('x')\n    >>> f = x**2 + 2\n    >>> vertical_scale_function(f, 3)\n    3*(x**2 + 2)", "Freq": 0, "TSR": 0}, {"tool": "def solve_function_equation(expr, var, target):\n    \n    equation = Eq(expr, target)\n    return solve(equation, var)", "subfield": "Function Operations", "tool_name": "solve_function_equation", "tool_type": "function", "description": "Solve a function equation \\( f(x) = target \\) for the given variable.", "docstring": "Solve a function equation \\( f(x) = target \\) for the given variable.\n    Parameters:\n        expr (sympy expression): The symbolic expression of the function.\n        var (sympy symbol): The variable in the expression.\n        target: The target value to which the function is set.\n    Returns:\n        list: Solutions to the equation.\n    Examples:\n        x = symbols('x')\n        expr = x**2 - 4*x + 4\n        print(solve_function_equation(expr, x, 0))  # Returns [2]", "Freq": 1, "TSR": 0}, {"tool": "def find_function_range(f, variable):\n    \n    derivative = diff(f, variable)\n    critical_points = solve(derivative, variable)\n    critical_values = [f.subs(variable, cp) for cp in critical_points] + [f.subs(variable, S.Infinity), f.subs(variable, S.NegativeInfinity)]\n    return (min(critical_values), max(critical_values))", "subfield": "Function Operations", "tool_name": "find_function_range", "tool_type": "function", "description": "Determines the range of a trigonometric function, especially focusing on critical points derived from derivatives.", "docstring": "Determines the range of a trigonometric function, especially focusing on critical points derived from derivatives.\n    \n    Parameters:\n    - f (sympy expression): Function whose range needs to be determined.\n    - variable (sympy symbol): The primary variable in the function.\n    \n    Returns:\n    - tuple: A possible range for the function as a description of min and max values.\n    \n    Examples:\n    >>> x = symbols('x')\n    >>> f = sin(x)\n    >>> find_function_range(f, x)\n    (-1, 1)", "Freq": 2, "TSR": 0}, {"tool": "def find_intersection(f1, f2, var):\n    \n    return sp.solve(sp.Eq(f1, f2), var)", "subfield": "Function Operations", "tool_name": "find_intersection", "tool_type": "function", "description": "Find intersections of two functions.", "docstring": "Find intersections of two functions.\n    \n    Parameters\n    ----------\n    f1 : sympy.Expr\n        The first function expression.\n    f2 : sympy.Expr\n        The second function expression.\n    var : sympy.Symbol\n        The variable of the functions.\n    \n    Returns\n    -------\n    list\n        List of intersection points as solutions.\n    Examples\n    --------\n    >>> x = sp.Symbol('x')\n    >>> f1 = x**2\n    >>> f2 = x + 2\n    >>> find_intersection(f1, f2, x)\n    [2, -1]", "Freq": 5, "TSR": 0}], "Optimization": [{"tool": "def apply_cauchy_schwarz_inequality(a, b, var):\n    \n    sum_sq_a = sum(i**2 for i in a)\n    sum_sq_b = sum(i**2 for i in b)\n    cross_prod = sum(a[i]*b[i] for i in range(len(a)))\n    \n    inequality = cross_prod**2 <= sum_sq_a * sum_sq_b\n    return inequality", "subfield": "Optimization", "tool_name": "apply_cauchy_schwarz_inequality", "tool_type": "function", "description": "Apply the Cauchy-Schwarz inequality to an expression to find the bounds.", "docstring": "Apply the Cauchy-Schwarz inequality to an expression to find the bounds.\n    \n    Parameters:\n        a (list of sp.Expr): Coefficients on the left side of the inequality.\n        b (list of sp.Expr): Coefficients on the right side of the inequality.\n        var (sp.Symbol): The main variable involved in the inequality expressions.\n    \n    Returns:\n        sp.Expr: The derived inequality expression using Cauchy-Schwarz.\n    \n    Examples:\n        >>> x = sp.symbols('x')\n        >>> a = [1, x]\n        >>> b = [x, 1]\n        >>> apply_cauchy_schwarz_inequality(a, b, x)\n        x**2 + 1 <= (x**2 + 1)**2  # Representing the inequality (1*x + x*1)^2 <= (1^2 + x^2)*(x^2 + 1^2)", "Freq": 1, "TSR": 0}, {"tool": "def AM_GM_Inequality_Tool(numbers):\n    \n    numbers = np.array(numbers)\n    if np.any(numbers < 0):\n        raise ValueError(\"All input numbers must be non-negative.\")\n    arithmetic_mean = np.mean(numbers)\n    geometric_mean = np.prod(numbers)**(1/len(numbers))\n    am_gm_equality = np.all(np.isclose(numbers, arithmetic_mean))\n    return {\n        'arithmetic_mean': arithmetic_mean,\n        'geometric_mean': geometric_mean,\n        'am_gm_equality': am_gm_equality\n    }", "subfield": "Optimization", "tool_name": "AM_GM_Inequality_Tool", "tool_type": "function", "description": "Apply the Arithmetic Mean-Geometric Mean (AM-GM) Inequality to compute the arithmetic and geometric means,\n    establish bounds, and check for equality condition in the provided list of numbers.", "docstring": "Apply the Arithmetic Mean-Geometric Mean (AM-GM) Inequality to compute the arithmetic and geometric means,\n    establish bounds, and check for equality condition in the provided list of numbers.\n    Parameters:\n    -----------\n    numbers : array-like\n        A list or array of non-negative real numbers.\n    Returns:\n    --------\n    result : dict\n        Dictionary containing:\n        - 'arithmetic_mean': Arithmetic Mean of the numbers.\n        - 'geometric_mean': Geometric Mean of the numbers.\n        - 'am_gm_equality': Boolean indicating if the equality condition holds (True if all numbers are equal).\n    Example:\n    --------\n    >>> AM_GM_Inequality_Tool([3,3,3])\n    {'arithmetic_mean': 3.0, 'geometric_mean': 3.0, 'am_gm_equality': True}", "Freq": 24, "TSR": 5}, {"tool": "def find_equality_conditions(values, inequality_type):\n    \n    from sympy import symbols\n    # Define a list to store the utilizing symbols and their associated equality conditions\n    symbols_list = [symbols('x' + str(i)) for i in range(len(values))]\n    equality_conditions = [str(symbols_list[i]) + ' = ' + str(symbols_list[(i + 1) % len(values)]) for i in range(len(values))]\n    # Conditions for equality in AM-GM or QM-AM inequality is when all variables are equal\n    return equality_conditions", "subfield": "Optimization", "tool_name": "find_equality_conditions", "tool_type": "function", "description": "Function to find conditions for equality in AM-GM and QM-AM inequality.", "docstring": "Function to find conditions for equality in AM-GM and QM-AM inequality.\n    Parameters:\n    values (list): A list of positive real numbers.\n    inequality_type (str): A string specifying the type of inequality. Possible values: 'AM-GM', 'QM-AM'.\n    Returns:\n    equality_conditions (list): The conditions for equality in the specified inequality. \n    Example:\n    >>> find_equality_conditions([1, 2, 3, 4], 'QM-AM')\n    ['x0 = x1', 'x1 = x2', 'x2 = x3', 'x3 = x0']", "Freq": 0, "TSR": 0}], "Infinite Series": [{"tool": "def infinite_series_sum(expression, variable_str, start=1):\n    \n    variable = symbols(variable_str)\n    series_expr = sympify(expression)\n    series = Sum(series_expr, (variable, start, oo))\n    return series.doit()", "subfield": "Infinite Series", "tool_name": "infinite_series_sum", "tool_type": "function", "description": "Calculates the sum of an infinite series given its general term.", "docstring": "Calculates the sum of an infinite series given its general term.\n    Parameters:\n      - expression (str or sympy expression): A symbolic expression representing the general term of the series. Should be a string or a Sympy expression.\n      - variable_str (str): The variable name as a string used in the expression.\n      - start (int): The starting index of the summation (default 1).\n    Returns:\n      - A Sympy expression of the summed series or None if the series does not converge.\n    Examples:\n      - infinite_series_sum('1/x**2', 'x') -> π²/6 (result of Σ (1/x²) from x=1 to ∞)\n      - infinite_series_sum('x/(2**x)', 'x') -> 2 (result of Σ (x/2^x) from x=1 to ∞)", "Freq": 2, "TSR": 2}, {"tool": "def decompose_to_partial_fractions(expression):\n    \n    x = symbols('x')\n    return apart(expression).simplify()", "subfield": "Infinite Series", "tool_name": "decompose_to_partial_fractions", "tool_type": "function", "description": "Decomposes a rational function into partial fractions.", "docstring": "Decomposes a rational function into partial fractions.\n    Parameters:\n    - expression (sympy expression): The rational function to decompose.\n    Returns:\n    - sympy expression: The expression decomposed into partial fractions.", "Freq": 3.5, "TSR": 1, "experience_pool": "Experience 1:\nProblem: Find the integer that is closest to $1000\\sum_{n=3}^{10000}\\frac1{n^2-4}$.\nAnswer: 521\n```python\nfrom sympy import symbols\n\ndef solution():\n    x = symbols('x')\n    expression = 1000 * (1/(x-2) - 1/(x+2))\n    result = decompose_to_partial_fractions(expression)\n    return round(result.evalf())\n    \nprint(solution())\n\n```\nOutput: 521\n\nExperience 2:\nProblem: Find\n\\[\\sum_{n = 1}^\\infty \\frac{2^n}{1 + 2^n + 2^{n + 1} + 2^{2n + 1}}.\\]\nAnswer: \\frac{1}{3}\n```python\nfrom sympy import symbols\n\ndef solution():\n    x = symbols('x')\n    expression = 2**x / (1 + 2**x + 2**(x + 1) + 2**(2*x + 1))\n    result = decompose_to_partial_fractions(expression)\n    return result\n\nprint(solution())\n\n```\nOutput: 1/3\n\nExperience 3:\nProblem: Let $k$ be a real number such that $k > 1$ and\n\\[\\sum_{n=1}^{\\infty} \\frac{5n-1}{k^n} = \\frac{13}{4}.\\]Find $k.$\nAnswer: 3\n```python\nfrom sympy import symbols\n\ndef solution():\n    k = symbols('k')\n    expression = (5*k - 1) / k\n    result = decompose_to_partial_fractions(expression)\n    return result\n\n# Calculate the partial fraction decomposition\ndecomposition = solution()\n\n# Find the value of k\nk_value = 0\nfor term in decomposition.args:\n    if term.as_numer_denom()[1] == k:\n        k_value = term.as_numer_denom()[0]\n\nk = k_value\nprint(k)\n\n```\nOutput: 3"}, {"tool": "def factor_polynomial_in_series(polynomial_expr, var):\n    \n    return simplify(polynomial_expr).factor()", "subfield": "Infinite Series", "tool_name": "factor_polynomial_in_series", "tool_type": "function", "description": "Factors a polynomial in a series expression.", "docstring": "Factors a polynomial in a series expression.\n    \n    Parameters:\n        polynomial_expr (sympy expression): The polynomial expression to be factored.\n        var (sympy Symbol): The primary variable in the polynomial expression.\n    Returns:\n        sympy expression: The factored polynomial expression.\n    \n    Examples:\n        >>> from sympy import symbols\n        >>> x = symbols('x')\n        >>> factor_polynomial_in_series(x**2 - 1, x)\n        (x - 1)*(x + 1)", "Freq": 0, "TSR": 0}, {"tool": "def check_convergence(series_expression, variable_str, start=1):\n    \n    variable = symbols(variable_str)\n    series_expr = sympify(series_expression)\n    series = Sum(series_expr, (variable, start, oo))\n    if series.is_convergent():\n        return \"The series converges.\"\n    elif series.is_divergent():\n        return \"The series diverges.\"\n    else:\n        return \"The convergence of the series could not be determined.\"", "subfield": "Infinite Series", "tool_name": "check_convergence", "tool_type": "function", "description": "Checks the convergence of an infinite series given its general term.\n    Args:\n        series_expression (str): The general term of the infinite series.\n        variable_str (str): The variable in the series expression.\n        start (int, optional): The starting index of the series. Defaults to 1.\n    Returns:\n        str: The convergence test result of the series.", "docstring": "Checks the convergence of an infinite series given its general term.\n    Args:\n        series_expression (str): The general term of the infinite series.\n        variable_str (str): The variable in the series expression.\n        start (int, optional): The starting index of the series. Defaults to 1.\n    Returns:\n        str: The convergence test result of the series.", "Freq": 0, "TSR": 0}]}