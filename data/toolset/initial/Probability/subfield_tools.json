{"Basic Concepts": [["def calculate_combinations(n, k):\n    \"\"\"\n    Calculate the number of ways to choose k items from n items without order using combinations formula.\n    \n    Parameters:\n        n (int): Total number of items.\n        k (int): Number of items to choose.\n    \n    Returns:\n        int: The number of combinations (n choose k).\n    \n    Examples:\n        >>> calculate_combinations(10, 2)\n        45\n        >>> calculate_combinations(5, 3)\n        10\n    \"\"\"\n    return math.comb(n, k)", "def combinations(n, k):\n    \"\"\"Calculate the number of combinations of `n` items taken `k` at a time.\n    \n    Parameters\n    ----------\n    n : int\n        Number of items.\n    k : int\n        Number of items to take.\n    \n    Returns\n    -------\n    int\n        Number of combinations.\n    \n    Examples\n    --------\n    >>> combinations(5, 3)\n    10\n    \"\"\"\n    return factorial(n) // (factorial(k) * factorial(n - k))", "def combination(n, k):\n    \"\"\"\n    Calculate the number of combinations for selecting k items from n items.\n    Parameters\n    ----------\n    n : int\n        The total number of items.\n    k : int\n        The number of items to select.\n    \n    Returns\n    -------\n    int\n        The number of combinations (also known as \"n choose k\").\n    Examples\n    --------\n    >>> combination(5, 3)\n    10\n    >>> combination(10, 4)\n    210\n    \"\"\"\n    return factorial(n) // (factorial(k) * factorial(n - k))"], ["def calculate_probability(favorable_outcomes, total_outcomes):\n    \"\"\"\n    Calculate the probability of an event given the number of favorable and total outcomes.\n    \n    Parameters:\n        favorable_outcomes (int): The number of favorable outcomes for the event.\n        total_outcomes (int): The total number of possible outcomes.\n    \n    Returns:\n        float: The probability of the event.\n    \n    Examples:\n        >>> calculate_probability(20, 100)\n        0.2\n        >>> calculate_probability(5, 50)\n        0.1\n    \"\"\"\n    if total_outcomes == 0:\n        raise ValueError(\"Total outcomes cannot be zero.\")\n    return favorable_outcomes / total_outcomes", "def calculate_probability(favorable, total):\n    \"\"\"\n    This function calculates the probability of an event, given the count of favorable outcomes and \n    total outcomes. It also simplifies the ratio using the greatest common divisor.\n    Parameters:\n        favorable (int): count of favorable outcomes\n        total (int): count of total outcomes\n    Returns:\n        tuple: a tuple presenting the simplified fraction of the probability (numerator, denominator)\n    Example:\n        >>> calculate_probability(5, 20)\n        (1, 4)\n    \"\"\"\n    common_factor = gcd(favorable, total)\n    return favorable // common_factor, total // common_factor", "def calculate_basic_probability(favorable_outcomes, total_outcomes):\n    \"\"\"\n    Calculate the basic probability of an event occurring.\n    Parameters\n    ----------\n    favorable_outcomes : int\n        The number of outcomes considered favorable for the event.\n    total_outcomes : int\n        The total number of possible outcomes.\n    \n    Returns\n    -------\n    float\n        The probability of the event occurring.\n    Examples\n    --------\n    >>> calculate_basic_probability(1, 6)\n    0.16666666666666666\n    >>> calculate_basic_probability(2, 52)\n    0.038461538461538464\n    \"\"\"\n    if total_outcomes == 0:\n        raise ValueError(\"Total outcomes cannot be zero.\")\n    \n    probability = favorable_outcomes / total_outcomes\n    return probability"], ["def complementary_probability(probability):\n    \"\"\"\n    Calculate the complementary probability of an event. This is the probability that the event does not occur.\n    \n    Parameters:\n        probability (float): The probability of the event that occurs.\n    \n    Returns:\n        float: The probability of the event not occurring.\n    \n    Examples:\n        >>> complementary_probability(0.75)\n        0.25\n        >>> complementary_probability(0.2)\n        0.8\n    \"\"\"\n    return 1 - probability", "def complementary_probability(p_event):\n    \"\"\"Calculate the complementary probability of an event not occurring.\n    \n    Parameters\n    ----------\n    p_event : float\n        Probability of the event occurring.\n        \n    Returns\n    -------\n    float\n        Complementary probability of the event not occurring.\n    \n    Examples\n    --------\n    >>> complementary_probability(0.75)\n    0.25\n    \"\"\"\n    return 1 - p_event"], ["def calculate_permutations(n, k):\n    \"\"\"\n    Calculate the number of ways to arrange k items from n items using permutations.\n    \n    Parameters:\n        n (int): Total number of items.\n        k (int): Number of items to arrange.\n    \n    Returns:\n        int: The number of permutations of k items from n items.\n    \n    Examples:\n        >>> calculate_permutations(10, 2)\n        90\n        >>> calculate_permutations(5, 3)\n        60\n    \"\"\"\n    return math.perm(n, k)", "def permutations(n, k):\n    \"\"\"Calculate the number of permutations of `n` items taken `k` at a time.\n    \n    Parameters\n    ----------\n    n : int\n        Number of items.\n    k : int\n        Number of items to take.\n    \n    Returns\n    -------\n    int\n        Number of permutations.\n        \n    Examples\n    --------\n    >>> permutations(5, 3)\n    60\n    \"\"\"\n    return factorial(n) // factorial(n - k)", "def permutation(n, k):\n    \"\"\"\n    Calculate the number of permutations for selecting k items from n items.\n    Parameters\n    ----------\n    n : int\n        The total number of items.\n    k : int\n        The number of items to select.\n    \n    Returns\n    -------\n    int\n        The number of permutations.\n    Examples\n    --------\n    >>> permutation(5, 3)\n    60\n    >>> permutation(10, 4)\n    5040\n    \"\"\"\n    return factorial(n) // factorial(n - k)"], ["def primes_up_to(n):\n    \"\"\"\n    Generate a list of prime numbers up to n.\n    Parameters\n    ----------\n    n : int\n    \n    Returns\n    -------\n    list\n        A list of prime numbers up to n.\n    Examples\n    --------"], ["def probability_of_independent_events(*probabilities):\n    \"\"\"\n    Calculate the probability of multiple independent events occurring together.\n    \n    Parameters:\n        probabilities (list of float): A list of probabilities of each independent event.\n    \n    Returns:\n        float: The total probability of all events occurring together.\n    \n    Examples:\n        >>> probability_of_independent_events(0.5, 0.5, 0.5)  # Probability of flipping three heads in a row\n        0.125\n        >>> probability_of_independent_events(0.3, 0.7)  # Probability of two independent events\n        0.21\n    \"\"\"\n    from functools import reduce\n    import operator\n    return reduce(operator.mul, probabilities, 1)", "def probability_independent_events(probabilities, sequential=False):\n    \"\"\"\n    Calculate the probability of multiple independent events. By default, calculates the combined probability.\n    If sequential=True, it calculates the sequential probability without replacement.\n    \n    Parameters:\n        probabilities (list of float): List of probabilities for each independent event.\n        sequential (bool): Whether to calculate sequential probabilities without replacement. Default is False.\n    \n    Returns:\n        float: Combined probability of independent events occurring.\n    Example:\n        >>> probability_independent_events([0.5, 0.5, 0.5])\n        0.125\n        >>> probability_independent_events([0.5, 0.5], True)\n        0.25\n    \"\"\"\n    from functools import reduce\n    if sequential:\n        return reduce(lambda x, y: x * y, probabilities)\n    return reduce(lambda x, y: x * y * (1 - y), probabilities, 1)"], ["def probability_intersection(p_a, p_b, p_a_intersection_b):\n    \"\"\"\n    This function calculates the probability of the intersection of two events A and B.\n    Parameters:\n        p_a (float): Probability of event A\n        p_b (float): Probability of event B\n        p_a_intersection_b (float): Probability of both A and B occurring\n    Returns:\n        float: Probability of the intersection of A and B\n    \"\"\"\n    return p_a * p_b * p_a_intersection_b", "def probability_union(p_a, p_b, p_a_intersection_b):\n    \"\"\"\n    This function calculates the probability of the union of two events A and B.\n    Parameters:\n        p_a (float): Probability of event A\n        p_b (float): Probability of event B\n        p_a_intersection_b (float): Probability of both A and B occurring\n    Returns:\n        float: Probability of the union of A and B\n    \"\"\"\n    return p_a + p_b - p_a_intersection_b"], ["def expected_value(outcomes, probabilities):\n    \"\"\"\n    Calculate the expected value (mean) of a list of outcomes weighted by their probabilities.\n    \n    Parameters:\n        outcomes (list of float): List of possible outcomes.\n        probabilities (list of float): List of probabilities associated with each outcome.\n    \n    Returns:\n        float: The expected value of the outcomes.\n    Example:\n        >>> outcomes = [0, 1]\n        >>> probabilities = [0.5, 0.5]\n        >>> expected_value(outcomes, probabilities)\n        0.5\n    \"\"\"\n    return sum(o * p for o, p in zip(outcomes, probabilities))"], ["def calculate_probability_geometric_area(favorable_area, total_area):\n    \"\"\"\n    This function calculates the probability of an event in geometrical context, given the area \n    representing the favorable outcomes and the total area.\n    Parameters:\n        favorable_area (float): area representing the favorable outcomes\n        total_area (float): total area\n    Returns:\n        float: the probability of favorable event \n    \"\"\"\n    return favorable_area / total_area", "def geometric_probability(favorable_area, total_area):\n    \"\"\"\n    Calculate probability in a geometric context as the ratio of the favorable area to the total area.\n    Parameters\n    ----------\n    favorable_area : float\n        The area of the favorable region.\n    total_area : float\n        The total area of the region in consideration.\n    \n    Returns\n    -------\n    float\n        The geometric probability of the event.\n    Examples\n    --------\n    >>> geometric_probability(5, 20)\n    0.25\n    >>> geometric_probability(1.5, 6)\n    0.25\n    \"\"\"\n    if total_area == 0:\n        raise ValueError(\"Total area cannot be zero.\")\n    \n    return favorable_area / total_area"], ["def is_prime(num):\n    \"\"\"\n    Determine if a number is prime.\n    Parameters\n    ----------\n    num : int\n    \n    Returns\n    -------\n    bool\n        True if num is prime, otherwise False.\n    \n    Examples\n    --------\n    >>> is_prime(7)\n    True\n    >>> is_prime(8)\n    False\n    \"\"\"\n    return isprime(num)"], ["def conditional_probability(P_A_given_B, P_B):\n    \"\"\"\n    Calculate the probability of A happening given that B has happened using the conditional probability formula.\n    \n    Parameters:\n        P_A_given_B (float): Probability of A given B.\n        P_B (float): Probability of B occurring.\n    \n    Returns:\n        float: The conditional probability P(A ∩ B).\n    \n    Examples:\n        >>> conditional_probability(0.4, 0.5)\n        0.2\n        >>> conditional_probability(0.9, 0.1)\n        0.09\n    \"\"\"\n    return P_A_given_B * P_B"], ["def permutation(n, r):\n    \"\"\"\n    This function calculates permutations (arrangements) of r items chosen from n distinct items.\n    Parameters:\n        n (int): size of the item set\n        r (int): the number of items to choose\n    Returns:\n        int: number of permutations of r items chosen from n items\n    \"\"\"\n    return factorial(n) / factorial(n - r)", "def combination(n, r):\n    \"\"\"\n    This function calculates combinations (selections) of r items chosen from n distinct items.\n    Parameters:\n        n (int): size of the item set \n        r (int): the number of items to choose \n    Returns:\n        int: number of combinations of r items chosen from n items\n    \"\"\"\n    return factorial(n) / (factorial(r) * factorial(n - r))"], ["def probability_of_event(prob_success, trials=1, success=1, exact=False):\n    \"\"\"Calculate the probability of an event occurring k times in n trials given a success probability.\n    \n    Parameters\n    ----------\n    prob_success : float\n        Probability of success in a single trial.\n    trials : int\n        Number of independent trials.\n    success : int\n        Number of successful events.\n    exact : bool\n        If True, return the probability of exactly `success` successes; otherwise, return at least `success` successes.\n    \n    Returns\n    -------\n    float\n        The calculated probability.\n    \n    Examples\n    --------\n    >>> probability_of_event(0.5, trials=4, success=2, exact=True)\n    0.375\n    >>> probability_of_event(0.5, trials=4, success=2, exact=False)\n    0.9375\n    \"\"\"\n    if exact:\n        return binom.pmf(success, trials, prob_success)\n    else:\n        return binom.cdf(trials-success, trials, 1 - prob_success)"], ["def binomial_coefficient(n, k):\n    \"\"\"\n    Calculate the binomial coefficient \"n choose k\" which represents\n    the number of ways to choose k items from n items without regard to order.\n    \n    Parameters:\n        n (int): Total number of items.\n        k (int): Number of items to choose.\n    \n    Returns:\n        int: Binomial coefficient representing the number of ways to choose k items from n.\n    \n    Examples:\n        >>> binomial_coefficient(5, 2)\n        10\n        >>> binomial_coefficient(10, 4)\n        210\n    \"\"\"\n    if k > n:\n        return 0\n    if k == 0 or k == n:\n        return 1\n    k = min(k, n - k)  # take advantage of symmetry\n    c = 1\n    for i in range(k):\n        c = c * (n - i) // (i + 1)\n    return c", "def binomial_coefficient(n, k):\n    \"\"\"\n    Calculate the binomial coefficient (n choose k), which is the number of ways to choose k elements from a set of n elements.\n    \n    Parameters:\n        n (int): total number of items.\n        k (int): number of items to choose.\n    \n    Returns:\n        int: The binomial coefficient C(n, k).\n    Example:\n        >>> binomial_coefficient(5, 3)\n        10\n    \"\"\"\n    if k > n:\n        return 0\n    if k == 0 or k == n:\n        return 1\n    k = min(k, n - k)  # Take advantage of symmetry\n    c = 1\n    for i in range(k):\n        c = c * (n - i) // (i + 1)\n    return c"], ["def multijective_count(n, r):\n    \"\"\"\n    This function calculates the number of multijective (or multiple) ways to map (or choose) r items \n    from n categories. This is calculated using the stars and bars method in combinatorics, \n    where there are r+ n-1 total slots, and r of them must be 'stars' (representing chosen items). \n    Parameters:\n        n (int): number of distinct categories \n        r (int): number of items to be chosen \n    Returns:\n        int: number of multijective ways\n    \"\"\"\n    return comb(r + n - 1, r)"], ["def simplify_fraction(a, b, return_sum=False):\n    \"\"\"\n    Simplify a fraction given by numerator a and denominator b, and optionally return the sum of the simplified numerator and denominator.\n    \n    Parameters:\n        a (int): Numerator of the fraction.\n        b (int): Denominator of the fraction.\n        return_sum (bool): If True, returns the sum of the simplified numerator and denominator.\n    \n    Returns:\n        Fraction or int: The simplified fraction or its sum depending on return_sum.\n    \n    Examples:\n        >>> simplify_fraction(50, 100)\n        Fraction(1, 2)\n        >>> simplify_fraction(50, 100, return_sum=True)\n        3\n    \"\"\"\n    fraction = Fraction(a, b).limit_denominator()\n    if return_sum:\n        return fraction.numerator + fraction.denominator\n    return fraction"], ["def independent_events_probability(*args):\n    \"\"\"Calculate the probability of multiple independent events all occurring.\n    \n    Parameters\n    ----------\n    *args : list of float\n        A variable number of probabilities representing independent events.\n    \n    Returns\n    -------\n    float\n        The probability of all independent events occurring.\n    \n    Examples\n    --------\n    >>> independent_events_probability(0.5, 0.5)\n    0.25   # Probability of two independent events both with P=0.5\n    \"\"\"\n    probability = 1\n    for event_probability in args:\n        probability *= event_probability\n    return probability"], ["def factorial(n):\n    \"\"\"Calculate the factorial of a number.\n    \n    Parameters\n    ----------\n    n : int\n        Non-negative integer whose factorial is to be calculated.\n    \n    Returns\n    -------\n    int\n        Factorial of `n`.\n    \n    Examples\n    --------\n    >>> factorial(5)\n    120\n    \"\"\"\n    return factorial(n)"], ["def complement_probability(event_probability):\n    \"\"\"\n    Calculate the probability of the complement of an event.\n    \n    Parameters:\n        event_probability (float): Probability of the event for which to find the complement.\n    \n    Returns:\n        float: Probability of the complement of the event.\n    Example:\n        >>> complement_probability(0.3)\n        0.7\n    \"\"\"\n    return 1 - event_probability"]], "Expected Value": [["def calculate_expected_value(outcomes, probabilities):\n    \"\"\"\n    Calculate the expected value of a discrete random variable given its outcomes and their probabilities.\n    Parameters:\n    - outcomes (np.ndarray): An array of outcomes of the random variable.\n    - probabilities (np.ndarray): An array of probabilities corresponding to these outcomes.\n    Returns:\n    - float: The expected value.\n    Examples:\n    >>> calculate_expected_value(np.array([1, 2, 3]), np.array([0.2, 0.3, 0.5]))\n    2.3\n    >>> calculate_expected_value(np.array([0, 1]), np.array([0.5, 0.5]))\n    0.5\n    \"\"\"\n    if not np.isclose(np.sum(probabilities), 1):\n        raise ValueError(\"The probabilities must sum to 1.\")\n    \n    return np.sum(outcomes * probabilities)", "def calculate_expected_value(values, probabilities):\n    \"\"\"\n    Calculate the expected value for a set of discrete outcomes.\n    Parameters:\n    - values (array-like): A list or array of possible outcomes (real numbers).\n    - probabilities (array-like): Corresponding probabilities for each outcome in `values`.\n    \n    Returns:\n    - float: The expected value of the distribution.\n    Examples:\n    >>> calculate_expected_value([1, 2, 3], [0.2, 0.5, 0.3])\n    2.1\n    \"\"\"\n    values = np.array(values)\n    probabilities = np.array(probabilities)\n    if not np.isclose(probabilities.sum(), 1):\n        raise ValueError(\"Probabilities must sum up to 1.\")\n    return np.dot(probabilities, values)", "def calculate_expected_value(outcomes, probabilities):\n    \"\"\"\n    Calculate the expected value of a discrete random variable given its possible outcomes and probabilities.\n    Parameters:\n    - outcomes (array_like): Possible outcomes (values) of the random variable.\n      Example: [1, 2, 3] for a fair die throw.\n    - probabilities (array_like): Corresponding probabilities for each outcome.\n      Example: [1/6, 1/6, 1/6, 1/6, 1/6, 1/6] for a fair die.\n    Returns:\n    - float: The expected value calculated using the formula E(X) = sum(x * p(x)).\n    \n    Example:\n    >>> calculate_expected_value([1, 2, 3, 4, 5, 6], [1/6]*6)\n    3.5\n    \"\"\"\n    # Convert inputs to numpy arrays for standardized and efficient computations\n    outcomes = np.array(outcomes)\n    probabilities = np.array(probabilities)\n    # Calculate the expected value as the weighted sum of outcomes\n    expected_value = np.sum(outcomes * probabilities)\n    return expected_value", "def calculate_expected_value(outcomes, probabilities):\n    \"\"\"\n    Compute the expected value of a discrete random variable given the possible outcomes and their respective probabilities.\n    Parameters:\n    - outcomes (list of float or int): The possible outcomes of the random variable.\n    - probabilities (list of float): The probabilities associated with each outcome. Each value must be between 0 and 1, and the sum should be approximately 1.\n    Returns:\n    - float: The expected value of the random variable.\n    Raises:\n    - ValueError: If `probabilities` do not sum to 1 or if lists `outcomes` and `probabilities` are not of the same length.\n    Examples:\n    >>> calculate_expected_value([1, 2, 3], [0.2, 0.5, 0.3])\n    2.1\n    >>> calculate_expected_value([10, 100, 1000], [0.5, 0.3, 0.2])\n    295.0\n    \"\"\"\n    import numpy as np\n    if len(outcomes) != len(probabilities):\n        raise ValueError(\"The length of outcomes and probabilities must be the same.\")\n   \n    if not np.isclose(sum(probabilities), 1):\n        raise ValueError(\"The probabilities must sum to approximately 1.\")\n    expected_value = np.dot(outcomes, probabilities)\n    \n    return expected_value", "def expected_value_with_probability_function(outcomes, probability_function):\n    \"\"\"\n    Calculate the expected value by specifying a set of outcomes and a function that calculates probabilities.\n    Parameters:\n    outcomes (list): A list of all possible outcomes.\n    probability_function (callable): A function that takes one argument (an outcome) and returns the probability of that outcome.\n    Returns:\n    float: The computed expected value.\n    Examples:\n    >>> outcomes = [0, 1, 2]\n    >>> probability_function = lambda x: 1/3 if x in [0, 1, 2] else 0\n    >>> expected_value_with_probability_function(outcomes, probability_function)\n    1.0\n    \"\"\"\n    return sum(outcome * probability_function(outcome) for outcome in outcomes)", "def calculate_expected_value(values, probabilities):\n    \"\"\"\n    Calculate the expected value from a list of values and corresponding probabilities.\n    Parameters:\n    - values (list or array or np.ndarray): A list of outcomes.\n    - probabilities (list or array or np.ndarray): A list of probabilities for each outcome.\n    \n    Returns:\n    - float: The expected value of the given distribution.\n    Example:\n    >>> calculate_expected_value([1, 2, 3], [0.2, 0.5, 0.3])\n    2.1\n    \"\"\"\n    # Convert values and probabilities to numpy arrays to utilize vectorized operations\n    values = np.array(values)\n    probabilities = np.array(probabilities)\n    # Check if the sum of the probabilities is close to 1\n    if not np.isclose(np.sum(probabilities), 1):\n        raise ValueError(\"The sum of probabilities should be 1.\")\n    # Calculate the expected value as the sum of value*probability for each value\n    expected_value = np.sum(values * probabilities)\n    return expected _value", "def expected_value(outcomes, probabilities=None):\n    \"\"\"\n    Calculate the expected value of a discrete random variable.\n    Parameters:\n    outcomes (list of float): A list of possible outcomes.\n    probabilities (list of float, optional): A list of probabilities for each outcome.\n        If not provided, it is assumed each outcome is equally likely (uniform distribution).\n        \n    Returns:\n    float: The expected value of the random variable.\n    Examples:\n    >>> expected_value([1, 2, 3, 4, 5, 6])\n    3.5\n    >>> expected_value([1, 2, 3], [0.5, 0.3, 0.2])\n    1.7\n    \"\"\"\n    import numpy as np\n    if probabilities is None:\n        # Assuming uniform probability distribution if no probabilities are provided\n        probabilities = np.ones(len(outcomes)) / len(outcomes)\n    else:\n        # Normalize probabilities to ensure they sum up to 1\n        probabilities = np.array(probabilities)\n        probabilities /= probabilities.sum()\n        \n    expected_val = np.dot(outcomes, probabilities)\n    return expected_val", "def expected_value(outcomes, probabilities):\n    \"\"\"\n    Calculate the expected value given a list of outcomes and their corresponding probabilities.\n    \n    Parameters:\n    - outcomes (list of float): A list of potential outcomes.\n    - probabilities (list of float): A list of probabilities corresponding to each outcome.\n    \n    Returns:\n    - float: The expected value calculated as the sum of all outcomes multiplied by their probabilities.\n    \n    Examples:\n    >>> expected_value([10, 20, 30], [0.3, 0.4, 0.3])\n    20.0\n    \"\"\"\n    if len(outcomes) != len(probabilities):\n        raise ValueError(\"The lists of outcomes and probabilities must have the same length.\")\n    \n    return sum(o * p for o, p in zip(outcomes, probabilities))", "def calculate_expected_value(outcomes, probabilities):\n    \"\"\"\n    Calculate the expected value given a list of outcomes and their corresponding probabilities.\n    Parameters:\n    outcomes (list or np.array): The outcomes of the random variable.\n    probabilities (list or np.array): The probabilities corresponding to these outcomes.\n    Returns:\n    float: The expected value of the random variable.\n    Example:\n    >>> calculate_expected_value([0, 1, 2], [0.2, 0.5, 0.3])\n    1.1\n    \"\"\"\n    outcomes = np.array(outimes)\n    probabilities = np.array(probabilities)\n    expected_value = np.dot(outcomes, probabilities)\n    return expected_value", "def calculate_expected_value(probabilities, values):\n    \"\"\"\n    Calculate the expected value of a discrete random variable.\n    Parameters:\n    - probabilities (list or array of float): The probabilities of each outcome. This should sum up to 1.\n    - values (list or array of float): The values corresponding to each outcome.\n    Returns:\n    - float: The expected value.\n    Raises:\n    - ValueError: If the lengths of probabilities and values do not match.\n    - ValueError: If the total probability is not close to 1 (within a reasonable floating point error margin).\n    \n    Example:\n    >>> calculate_expected_value([0.1, 0.2, 0.3, 0.4], [10, 20, 30, 40])\n    29.0\n    >>> calculate_expected_value([0.25, 0.25, 0.25, 0.25], [1, 2, 3, 4])\n    2.5\n    >>> calculate_expected_value([0.5, 0.5], [0, 1])\n    0.5\n    \"\"\"\n    probabilities = np.array(probabilities)\n    values = np.array(values)\n    \n    if len(probabilities) != len(values):\n        raise ValueError('The lengths of probabilities and values must match.')\n    if not np.isclose(np.sum(probabilities), 1):\n        raise ValueError('The total of probabilities must sum up to 1.')\n    \n    expected_value = np.sum(probabilities * values)\n    return expected_value", "def calculate_expected_value(outcomes, probabilities):\n    \"\"\"\n    Calculates the expected value for a discrete random variable given outcomes and their probabilities.\n    Parameters:\n    - outcomes (np.array or list): The possible outcomes of the random variable.\n    - probabilities (np.array or list): The probabilities associated with each outcome.\n    Returns:\n    - float: The expected value of the random variable.\n    Examples:\n    >>> calculate_expected_value([1, 2, 3, 4, 5, 6], [1/6]*6)  # Expected value for a fair die\n    3.5\n    >>> calculate_expected_value([1, 2, 3], [0.7, 0.2, 0.1])  # Expected value with non-uniform probabilities\n    1.5\n    \"\"\"\n    # Validate that the sum of probabilities is close to 1\n    if not np.isclose(sum(probabilities), 1):\n        raise ValueError(\"Sum of probabilities must be very close to 1\")\n    # Ensure matching lengths of outcomes and probabilities\n    if len(outcomes) != len(probabilities):\n        raise ValueError(\"The number of outcomes and probabilities must match\")\n    return np.dot(outcomes, probabilities)"], ["def probability_of_mutually_exclusive_events(*probabilities):\n    \"\"\"\n    Calculate the total probability of the occurrence of any one of several mutually exclusive events.\n    \n    Parameters:\n    - probabilities (floats): A sequence of probabilities for each event, each being independent and mutually exclusive.\n    \n    Returns:\n    - float: The total probability of occurring at least one of the events.\n    \n    Examples:\n    >>> probability_of_mutually_exclusive_events(0.1, 0.2, 0.05)\n    0.35\n    \"\"\"\n    return sum(probabilities)"], ["def expected_value_binomial(n, p):\n    \"\"\"\n    Calculate the expected value of a binomial distribution.\n    Parameters:\n    n (int): The number of trials.\n    p (float): The probability of success on any given trial.\n    Returns:\n    float: The expected value of the binomial distribution, which is n*p.\n    Examples:\n    >>> expected_value_binomial(10, 0.5)\n    5.0\n    >>> expected_value_binomial(20, 0.3)\n    6.0\n    \"\"\"\n    return n * p", "def expected_value_binomial(n, p):\n    \"\"\"\n    Calculates the expected value for a binomial distribution.\n    Parameters:\n    - n (int): The number of trials.\n    - p (float): The probability of success on an individual trial.\n    Returns:\n    - float: Expected value of the binomial distribution.\n    Examples:\n    >>> expected_value_binomial(10, 0.5)  # Expected value of a binomial distribution for 10 fair coins flipped\n    5.0\n    \"\"\"\n    # Calculate expected value using the property E(X) = n * p\n    return n * p"], ["def expected_value_from_pmf(pmf):\n    \"\"\"\n    Calculate the expected value from a probability mass function.\n    Parameters:\n    pmf (dict): A dictionary where keys are outcomes and values are the probabilities of these outcomes.\n    Returns:\n    float: The expected value calculated as the sum of all outcomes weighted by their probabilities.\n    Examples:\n    >>> pmf = {0: 0.5, 1: 0.3, 2: 0.2}\n    >>> expected_value_from_pmf(pmf)\n    0.7\n    \"\"\"\n    return sum(outcome * probability for outcome, probability in pmf.items())"], ["def expected_value_combinatorial(n, k, success_probability):\n    \"\"\"\n    Calculate the expected value for combinatorial probability problems, like Bernoulli trials.\n    Parameters:\n    n (int): Total number of trials or elements.\n    k (int): Number of successful trials.\n    success_probability (float): The probability of success in each trial.\n    Returns:\n    float: Expected value calculated as `E[X] = n * p` where `p` is the success probability.\n    Examples:\n    >>> expected_value_combinatorial(10, 3, 0.5)\n    5.0\n    \"\"\"\n    return n * success_probability"], ["def minimum_trials_for_repeat(total_outcomes):\n    \"\"\"\n    Calculate the minimum number of trials required to ensure at least one repeat, based on the Pigeonhole Principle.\n    \n    Parameters\n    ----------\n    total_outcomes : int\n        The total number of distinct possible outcomes in the experiment.\n    \n    Returns\n    -------\n    int\n        The minimum number of trials needed to guarantee a repeat.\n    Example\n    -------\n    >>> minimum_trials_for_repeat(total_outcomes=365)  # E.g., Birthday problem\n    366\n    \"\"\"\n    return total_outcomes + 1", "def min_trials_for_repeat(total_outcomes):\n    \"\"\"\n    Calculate the minimum number of trials needed to ensure at least one repetition\n    according to the Pigeonhole Principle.\n    Parameters:\n    - total_outcomes (int): The total number of unique possible outcomes.\n    Returns:\n    - int: The minimum number of trials to ensure at least one repeat.\n    Example:\n    >>> min_trials_for_repeat(365)\n    366\n    \"\"\"\n    return total_outcomes + 1"], ["def probability_using_combinations(n, k, success_probability):\n    \"\"\"\n    Calculate the probability of k successful events in n trials given the success probability of each event,\n    using combinations to determine the number of ways the k successes can occur.\n    Parameters:\n    n (int): Total number of trials.\n    k (int): Number of required successful trials.\n    success_probability (float): Probability of success in an individual trial.\n    Returns:\n    float: Probability of k successes in n trials.\n    Example:\n    >>> probability_using_combinations(4, 2, 0.5)\n    0.375\n    \"\"\"\n    total_ways = comb(n, k)\n    probability = total_ways * (success_probability ** k) * ((1 - success_probability) ** (n - k))\n    return probability"], ["def validate_and_normalize_probabilities(probabilities):\n    \"\"\"\n    Validate and, if necessary, normalize an array of probabilities so they sum to 1.\n    Parameters:\n    - probabilities (np.ndarray): An array of raw probability values that might not sum to 1.\n    Returns:\n    - np.ndarray: Normalized probability array.\n    Examples:\n    >>> validate_and_normalize_probabilities(np.array([0.1, 0.2, 0.3]))\n    np.array([0.1667, 0.3333, 0.5])\n    >>> validate_and_normalize_probabilities(np.array([0.5, 0.5]))\n    np.array([0.5, 0.5])\n    \"\"\"\n    prob_sum = np.sum(probabilities)\n    if prob_sum == 0:\n        raise ValueError(\"Sum of probabilities should not be zero.\")\n    return probabilities / prob_sum"], ["def expected_value_of_sum(n, k, event_value, total_value, single_event_probability):\n    \"\"\"\n    Calculate the expected value involving the sum of independent events\n    using binomial coefficients and probabilities.\n    Parameters:\n    - n (int): Total number of trials or items.\n    - k (int): Number of successes or specific event occurrences.\n    - event_value (float): Value when the specified event occurs.\n    - total_value (float): Total value to be distributed over all events.\n    - single_event_probability (float): Probability of a single success or event occurrence.\n    Returns:\n    - float: Expected value calculated using the sum of event values.\n    Examples:\n    >>> expected_value_of_sum(10, 3, 7, 70, 0.3)\n    21.0\n    \"\"\"\n    expected_count = n * comb(n-1, k-1) * single_event_tab\n    return expected_count * event_value / total_value"], ["def dice_roll_stats(dice_count, sides=6):\n    \"\"\"\n    Compute the minimum, maximum, and expected sum when rolling a certain number of dice each having a given number of sides.\n    Parameters\n    ----------\n    dice_count : int\n        Number of dice to roll.\n    sides : int, optional\n        Number of sides on each die (default is 6 for a standard die).\n    Returns\n    -------\n    dict\n        A dictionary containing 'min_sum', 'max_sum', and 'expected_sum'\n    \n    Example\n    -------\n    >>> dice_roll_stats(dice_count=3, sides=6)\n    {'min_sum': 3, 'max_sum': 18, 'expected_sum': 10.5}\n    \"\"\"\n    from sympy import Rational\n    \n    min_sum = dice_count * 1\n    max_sum = dice_count * sides\n    expected_sum = dice_count * (sides + 1) / 2\n    return {\n        'min_sum': min_sum,\n        'max_sum': max_sum,\n        'expected_sum': Rational(expected_sum).limit_denominator()\n    }"], ["def calculate_binomial_probability(n, k, p):\n    \"\"\"\n    Calculate the binomial probability P(X = k) using the formula:\n    P(X=k) = (n choose k) * p^k * (1-p)^(n-k)\n    Parameters:\n    - n (int): Number of trials.\n    - k (int): Number of desired successes.\n    - p (float): Probability of success on an individual trial.\n    Returns:\n    - float: The binomial probability of obtaining exactly k successes out of n trials.\n    Example:\n    >>> calculate_binomial_probability(10, 5, 0.5)\n    0.24609375\n    \"\"\"\n    # Calculate binomial probability using scipy's binom.pmf function\n    probability = binom.pmf(k, n, p)\n    return probability"]]}