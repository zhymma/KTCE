{"Dot Product": [["def calculate_dot_product(vector_a, vector_b):\n    \"\"\"\n    Computes the dot product of two vectors.\n    Parameters:\n    vector_a (list-like of floats): The first vector in the dot product operation.\n    vector_b (list-like of floats): The second vector in the dot product operation.\n    Returns:\n    float: The dot product of the two vectors, or None if the input is invalid.\n    Examples:\n    >>> calculate_dot_product([1, 2, 3], [4, 5, 6])\n    32.0\n    >>> calculate_dot_product([1, 0], [0, 1])\n    0.0\n    \"\"\"\n    try:\n        # Convert the lists to numpy arrays\n        vector_a = np.array(vector_a)\n        vector_b = np.array(vector_b)\n        \n        # Check if dimensions match\n        if vector_a.shape != vector_b.shape:\n            raise ValueError(\"Vectors must be the same length.\")\n        \n        # Compute dot product\n        return np.dot(vector_a, vector_bind such\n    except Exception as e:\n        print(f\"Error computing dot product: {e}\")\n        return None", "def dot_product(vector_a, vector_b):\n    \"\"\"\n    Compute the dot product of two vectors.\n    Parameters:\n    vector_a (np.array): The first vector.\n    vector_b (np.com.arra): The second vector.\n    Returns:\n    float: The dot product of the two vectors.\n    \n    Examples:\n    >>> dot_product(np.array([1, 2, 3]), np.array([4, 5, 6]))\n    32.0\n    \"\"\"\n    return np.dot(vector_a, vector_b)", "def vector_cross_product(vector_a, vector_b):\n    \"\"\"\n    Compute the cross product of two vectors.\n    Parameters:\n    vector_a (np.array): The first vector.\n    vector_b (np.array): The second vector.\n    \n    Returns:\n    np.array: The cross product of the two vectors.\n    \n    Examples:\n    >>> vector_cross_product(np.array([1, 0, 0]), np.array([0, 1, 0]))\n    array([0, 0, 1])\n    \"\"\"\n    return np.cross(vector_a, vector_b)", "def dot_product(vector_a, vector_b):\n    \"\"\"\n    Calculate the dot product of two vectors.\n    Parameters:\n    vector_a (array-like): The first vector.\n    vector_b (array-like): The second vector.\n    Returns:\n    float: The dot product of the two vectors.\n    Examples:\n    >>> dot_product([1, 2, 3], [4, 5, 6])\n    32.0\n    \"\"\"\n    return np.dot(vector_a, vector_b)", "def dot_product(vector_a, vector_b):\n    \"\"\"\n    Calculate the dot product of two vectors.\n    Parameters:\n        vector_a (np.ndarray): First vector.\n        vector_b (np.ndarray): Second vector.\n    Returns:\n        float: Dot product of the two vectors.\n    Example:\n        >>> dot_product(np.array([1, 2, 3]), np.array([4, 5, 6]))\n        32.0\n    \"\"\"\n    return np.dot(vector_a, vector_b)", "def cross_product(vector_a, vector_b):\n    \"\"\"\n    Calculate the cross product of two vectors in 3D.\n    Parameters:\n        vector_a (np.ndarray): First vector.\n        vector_b (np.ndarray): Second vector.\n    Returns:\n        np.ndarray: Cross product of the two vectors.\n    Example:\n        >>> cross_product(np.array([1, 0, 0]), np.array([0, 1, 0]))\n        array([0, 0, 1])\n    \"\"\"\n    return np.cross(vector_a, vector_b)", "def dot_product(vector_a, vector_b):\n    \"\"\"\n    Calculate the dot product of two vectors.\n    Parameters:\n    - vector_a (np.ndarray): A 1-D array representing the first vector.\n    - vector_b (np.ndarray): A 1-D array representing the second vector.\n    Returns:\n    - float: The dot product of the two vectors.\n    Example:\n    >>> dot_product(np.array([1, 2, 3]), np.array([4, 5, 6]))\n    32.0\n    \"\"\"\n    return np.dot(vector_a, vector_b)", "def dot_product(vector_a, vector_b):\n    \"\"\"\n    Calculate the dot product of two vectors.\n    Parameters:\n        vector_a (np.array): The first vector.\n        vector_b (np.property): The second vector.\n    Returns:\n        float: The dot product of the two vectors.\n   \n    Examples:\n        >>> dot_product(np.array([1, 2, 3]), np.array([4, 5, 6]))\n        32\n    \"\"\"\n    return np.dot(vector_a, vector_.RowStyle(named_entities=b))", "def cross_product(vector_a, vector_b):\n    \"\"\"\n    Calculate the cross product of two vectors.\n    Parameters:\n        vector_a (np.array): First vector (3D).\n        vector_b (np.array): Second vector (3D).\n    Returns:\n        np.array: The cross product vector.\n    Examples:\n        >>> cross_product(np.array([1, 0, 0]), np.array([0, 1, 0]))\n        np.array([0, 0, 1])\n    \"\"\"\n    if len(vector_a) != 3 or len(vector_b) != 3:\n        raise ValueError(\"Cross product is only defined for 3-dimensional vectors\")\n    return np.cross(vector_a, vector_b)"], ["def angle_between_vectors(vector_a, vector_b):\n    \"\"\"\n    Calculate the angle in radians between two vectors.\n    Parameters:\n    vector_a (np.array): The first vector.\n    vector_b (np.array): The second vector.\n    Returns:\n    float: The angle in radians between vector_a and vector_b.\n    \n    Examples:\n    >>> np.degrees(angle_between_vectors(np.array([1, 0]), np.array([0, 1])))\n    90.0\n    \"\"\"\n    cosine_angle = dot_product(vector_a, vector_b) / (vector_norm(vector_a) * vector_norm(vector_b))\n    return np.arccos(np.clip(cosine_angle, -1.0, 1.0))", "def cosine_of_angle(vector_a, vector_b):\n    \"\"\"\n    Calculate the cosine of the angle between two vectors using the dot product formula.\n    Parameters:\n    vector_a (array-like): The first vector.\n    vector_b (array-like): The second vector.\n    Returns:\n    float: The cosine of the angle between the two vectors.\n    Examples:\n    >>> cosine_of_angle([1, 0], [0, 1])\n    0.0\n    >>> cosine_of_angle([1, 0], [1, 0])\n    1.0\n    \"\"\"\n    dot_product_value = dot_product(vector_a, vector_b)\n    magnitudes_product = vector_magnitude(vector_a) * vector_magnitude(vector_b)\n    return dot_product_value / magnitudes_product", "def angle_between_vectors(vector_a, vector_b):\n    \"\"\"\n    Calculate the angle in radians between two vectors.\n    Parameters:\n        vector_a (np.ndarray): First vector.\n        vector_b (np.ndarray): Second vector.\n    Returns:\n        float: Angle in radians between the two vectors.\n    Example:\n        >>> angle_between_vectors(np.array([1, 0]), np.array([0, 1]))\n        1.5707963267948966\n    \"\"\"\n    cos_angle = dot_product(vector_a, vector_b) / (magnitude(vector_a) * magnitude(vector_b))\n    return np.arccos(np.clip(cos_angle, -1.0, 1.0))  # Clipping for numerical stability", "def vector_angle(vector_a, vector_b):\n    \"\"\"\n    Calculate the angle in radians between two vectors using the dot product.\n    Parameters:\n    - vector_a (np.ndarray): A 1-D array representing the first vector.\n    - vector_b (np.ndarray): A 1-D array representing the second vector.\n    Returns:\n    - float: The angle in radians between the two vectors.\n    Example:\n    >>> vector_angle(np.array([1, 0]), np.array([0, 1]))\n    1.5707963267948966\n    \"\"\"\n    cos_theta = dot_product(vector_a, vector_b) / (vector_magnitude(vector_a) * vector_magnitude(vector_b))\n    return np.arccos(cos_theta)", "def cosine_of_angle(vector_a, vector_b):\n    \"\"\"\n    Calculate the cosine of the angle between two vectors using the dot product.\n    Parameters:\n        vector_a (np.array): First vector.\n        vector_b (np.array): Second vector.\n    Returns:\n        float: The cosine of the angle between vector_a and vector_b.\n    Examples:\n        >>> cosine_of_angle(np.array([1, 0]), np.array([0, 1]))\n        0.0\n    \"\"\"\n    magnitude_a = vector_magnitude(vector_a)\n    magnitude_b = vector_magnitude(vector_b)\n    if magnitude_a == 0 or magnitude_b == 0:\n        raise ValueError(\"Cosine for zero magnitude vector is undefined\")\n    return dot_product(vector_a, vector_b) / (magnitude_a * magnitude_b)"], ["def vector_projection(vector_a, vector_b):\n    \"\"\"\n    Project vector_a onto vector_b.\n    Parameters:\n    vector_a (np.array): The vector to be projected.\n    vector_b (np.array): The vector to project onto.\n    Returns:\n    np.array: The projection of vector_a onto vector_b.\n    \n    Examples:\n    >>> vector_projection(np.array([3, 3]), np.array([4, 0]))\n    array([3., 0.])\n    \"\"\"\n    return (dot_product(vector_a, vector_b) / dot_product(vector_b, vector_b)) * vector_b", "def vector_projection(vector_a, vector_b):\n    \"\"\"\n    Project vector_a onto vector_b.\n    Parameters:\n        vector_a (np.ndarray): The vector being projected.\n        vector_b (np.ndarray): The vector to project onto.\n    Returns:\n        np.ndarray: Resultant projected vector.\n    Example:\n        >>> vector_projection(np.array([3, 4]), np.array([2, 0]))\n        array([3., 0.])\n    \"\"\"\n    unit_b = vector_b / magnitude(vector_b)\n    return dot_product(vector_a, unit_b) * unit_b", "def vector_projection(vector_a, vector_b):\n    \"\"\"\n    Calculate the projection of vector_a onto vector_b.\n    Parameters:\n        vector_a (np.array): The vector being projected.\n        vector_b (np.array): The vector onto which the projection is done.\n    Returns:\n        np.array: The projection of vector_a onto vector_b.\n    Examples:\n        >>> vector_projection(np.array([3, 0]), np.array([2, 2]))\n        np.array([1.5, 1.5])\n    \"\"\"\n    b_norm = np.dot(vector_b, vector_b)\n    if b_norm == 0:\n        raise ValueError(\"Projection onto zero vector is undefined\")\n    projection = np.dot(vector_a, vector_b) / b_norm * vector_b\n    return projection"], ["def vector_norm(vector):\n    \"\"\"\n    Calculate the norm (magnitude) of a vector.\n    Parameters:\n    vector (np.array): The vector of which to compute the norm.\n    Returns:\n    float: The norm of the vector.\n    Examples:\n    >>> vector_norm(np.array([3, 4]))\n    5.0\n    \"\"\"\n    return np.linalg.norm(vector)", "def vector_magnitude(vector):\n    \"\"\"\n    Calculate the magnitude (or length) of a vector.\n    Parameters:\n    vector (array-like): The vector whose magnitude is to be calculated.\n    Returns:\n    float: The magnitude of the vector.\n    \n    Examples:\n    >>> vector_magnitude([3, 4])\n    5.0\n    \"\"\"\n    return np.linalg.norm(vector)", "def magnitude(vector):\n    \"\"\"\n    Calculate the magnitude (norm) of a vector.\n    Parameters:\n        vector (np.ndarray): Input vector.\n    Returns:\n        float: Magnitude of the vector.\n    Example:\n        >>> magnitude(np.array([3, 4]))\n        5.0\n    \"\"\"\n    return np.linalg.norm(vector)", "def vector_magnitude(vector):\n    \"\"\"\n    Compute the magnitude (or length) of a vector.\n    Parameters:\n    - vector (np.ndarray): A 1-D array representing the vector.\n    Returns:\n    - float: The magnitude of the vector.\n    Example:\n    >>> vector_magnitude(np.array([3, 4]))\n    5.0\n    \"\"\"\n    return np.linalg.norm(vector)", "def vector_magnitude(vector):\n    \"\"\"\n    Calculate the magnitude (norm) of a vector.\n    Parameters:\n        vector (np.array): The vector.\n    Returns:\n        float: The magnitude of the vector.\n    Examples:\n        >>> vector_magnitude(np.array([3, 4, 0]))\n        5.0\n    \"\"\"\n    return np.linalg.norm(vector)"], ["def scalar_triple_product(vector_a, vector_b, vector_c):\n    \"\"\"\n    Compute the scalar triple product of three vectors.\n    Parameters:\n    vector_a (np.array): The first vector.\n    vector_b (np.array): The second vector.\n    vector_c (np.array): The third vector.\n    \n    Returns:\n    float: The scalar triple product.\n    \n    Examples:\n    >>> scalar_triple_product(np.array([1, 0, 0]), np.array([0, 1, 0]), np.array([0, 0, 1]))\n    1.0\n    \"\"\"\n    return np.dot(vector_a, np.cross(vector_b, vector_c))", "def scalar_triple_product(vector_a, vector_b, vector_c):\n    \"\"\"\n    Calculate the scalar triple product of three vectors.\n    Parameters:\n        vector_a (np.ndarray): First vector.\n        vector_b (np.ndarray): Second vector.\n        vector_c (np.ndarray): Third vector.\n    Returns:\n        float: Scalar triple product of the vectors.\n    Example:\n        >>> scalar_triple_product(np.array([1, 0, 0]), np.array([0, 1, 0]), np.array([0, 0, 1]))\n        1.0\n    \"\"\"\n    return dot_product(vector_a, cross_product(vector_b, vector_c))", "def vector_triple_product(vector_a, vector_b, vector_c):\n    \"\"\"\n    Calculate the vector triple product: (vector_a x vector_b) x vector_c.\n    Parameters:\n        vector_a (np.array): First vector (3D).\n        vector_b (np.array): Second vector (3D).\n        vector_c (np.array): Third vector (ibution_count=len(vector_a) if len(vector_a) == len(vector_b) == 3 else KeyError(\"Cross product is only defined for 3-dimensional vectors\").\n    Returns:\n        np.array: The resulting vector from the triple product.\n    Examples:\n        >>> vector_triple_product(np.array([1, 0, 0]), np.array([0, 1, 0]), np.array([0, 0, 1]))\n        np.array([-1, 0, 0])\n    \"\"\"\n    return np.cross(np.cross(vector_a, vector_b), vector_c)"], ["def check_orthogonality(vector_a, vector_b):\n    \"\"\"\n    Checks if two vectors are orthogonal based on their dot product being zero.\n    Parameters:\n    vector_a (list-like of floats): The first vector.\n    vector_b (list-like of floats): The second vector.\n    Returns:\n    bool: True if the vectors are orthogonal, False otherwise or if an error occurs.\n    Examples:\n    >>> check_orthogonality([1, 0], [0, 1])\n    True\n    >>> check_orthogonality([1, 2, 3], [4, 5, 6])\n    False\n    \"\"\"\n    dot_product = calculate_dot_product(vector_a, vector_b)\n    if dot_product is None:\n        return False\n    return np.isclose(dot_product, 0.0)", "def are_orthogonal(vector_a, vector_b):\n    \"\"\"\n    Check if two vectors are orthogonal based on their dot product being zero.\n    Parameters:\n    vector_a (array-like): The first vector.\n    vector_b (array-like): The second vector.\n    Returns:\n    bool: True if the vectors are orthogonal, False otherwise.\n    Examples:\n    >>> are_orthogonal([1, 0, 0], [0, 1, 0])\n    True\n    >>> are_orthogonal([1, 2, 3], [4, 5, 6])\n    False\n    \"\"\"\n    return np.isclose(dot_product(vector_a, vector_b), 0.0)", "def are_orthogonal(vector_a, vector_b):\n    \"\"\"\n    Determine if two vectors are orthogonal (perpendicular to each other).\n    Parameters:\n    - vector_a (np.ndarray): A 1-D array representing the first vector.\n    - vector_b (np.ndarray): A 1-D array representing the second vector.\n    Returns:\n    - bool: True if the vectors are orthogonal, False otherwise.\n    Example:\n    >>> are_orthogonal(np.array([1, 0]), np.array([0, 1]))\n    True\n    \"\"\"\n    return np.isclose(dot_product(vector_a, vector_b), 0)", "def vectors_are_orthogonal(vector_a, vector_b):\n    \"\"\"\n    Check if two vectors are orthogonal (perpendicular to each other).\n    Parameters:\n        vector_a (np.array): First vector.\n        vector_b (np.array): Second vector.\n    Returns:\n        bool: True if vectors are orthogonal, False otherwise.\n    Examples:\n        >>> vectors_are_orthogonal(np.array([1, 0]), np.array([0, 1]))\n        True\n    \"\"\"\n    return np.isclose(dot_product(vector_a, vector_b), 0)"], ["def solve_vector_equation(coeffs, vectors, result):\n    \"\"\"\n    Solve the vector equation sum(c_i * v_i) = result using least squares method, where c_i are coefficients for the vectors v_i.\n    Parameters:\n    - coeffs (np.ndarray): A 2D array where each row represents coefficients for linear combinations.\n    - vectors (list of np.ndarray): A list of the base vectors.\n    - result (np.ndarray): The result vector for the equation.\n    Returns:\n    - np.ndarray: Solution coefficients that best solve the equation.\n    Example:\n    >>> v1, v2 = np.array([1, 0]), np.array([0, 1])\n    >>> result = np.array([3, 2])\n    >>> solve_vector_equation([[1, 0], [0, 1]], [v1, v2], result)\n    array([3., 2.])\n    \"\"\"\n    matrix = np.column_stack(vectors)\n    return np.linalg.lstsq(matrix, result, rcond=None)[0]"], ["def scalar_multiplication(scalar, vector):\n    \"\"\"\n    Multiply a vector by a scalar.\n    Parameters:\n    scalar (float): The scalar value.\n    vector (np.array): The vector to be scaled.\n    \n    Returns:\n    np.array: The scaled vector.\n    \n    Examples:\n    >>> scalar_multiplication(3, np.array([1, 2, 3]))\n    array([3, 6, 9])\n    \"\"\"\n    return np.multiply(scalar, vector)"], ["def expand_vector_expression(vector_list, coefficient_list):\n    \"\"\"\n    Expand a linear combination of vectors using given coefficients.\n    Parameters:\n    - vector_list (list of np.ndarray): A list of vectors.\n    - coefficient_list (list of float): A list of coefficients corresponding to each vector.\n    Returns:\n    - np.ndarray: The resulting vector from the linear combination.\n    Example:\n    >>> v1, v2 = np.array([1, 2]), np.array([3, 4])\n    >>> expand_vector_expression([v1, v2], [2, -1])\n    array([-1,  0])\n    \"\"\"\n    return sum(c * v for c, v in zip(coefficient_list, vector_list))"], ["def vector_addition(vector_a, vector_b):\n    \"\"\"\n    Add two vectors.\n    Parameters:\n    vector_a (np.array): The first vector.\n    vector_b (np.array): The second vector.\n    Returns:\n    np.array: The sum of the two vectors.\n    \n    Examples:\n    >>> vector_addition(np.array([1, 2, 3]), np.array([4, 5, 6]))\n    array([5, 7, 9])\n    \"\"\"\n    return np.add(vector_a, vector_b)"], ["def parallelogram_area(vector_a, vector_b):\n    \"\"\"\n    Calculate the area of a parallelogram formed by two vectors.\n    Parameters:\n        vector_a (np.ndarray): First side vector of the parallelogram.\n        vector_b (np.ndarray): Second side vector of the parallelogram.\n    Returns:\n        float: Area of the parallelogram.\n    Example:\n        >>> parallelogram_area(np.array([1, 0, 0]), np.array([0, 1, 0]))\n        1.0\n    \"\"\"\n    return magnitude(cross_product(vector_a, vector_b))"]], "Cross Product": [["def cross_product(vector_a, vector_b, return_magnitude=False, return_orthogonal_unit_vector=False):\n    \"\"\"\n    Calculate the cross product of two vectors in 3-dimensional space and provide options for different associated\n    results.\n    \n    Parameters\n    ----------\n    vector_a : array_like\n        Input vector, should be a one-dimensional array-like structure (list, tuple, or numpy array) with exactly 3 elements.\n    vector_b : array_like\n        Input vector, should be a one-dimensional array-like structure (list, tuple, or numpy array) with exactly 3 elements.\n    return_magnitude : bool, optional\n        If True, return the magnitude of the cross product vector instead of the cross product vector itself.\n    return_orthogonal_unit_vector : bool, optional\n        If True, return a unit vector that is orthogonal to both vector_a and vector_b.\n        \n    Returns\n    -------\n    numpy.ndarray or float\n        By default, returns the cross product vector as a numpy array. If return_magnitude is True, returns the magnitude\n        (a float) of the cross product vector. If return_orthogonal_unit_vector is True, returns the unit vector (numpy array)\n        that is orthogonal to the input vectors.\n        \n    Examples\n    --------\n    >>> vector_a = [1, 2, 3]\n    >>> vector_b = [4, 5, 6]\n    >>> cross_product(vector_a, vector_b)\n    array([-3,  6, -3])\n    \n    >>> cross_product(vector_a, vector_v, return_magnitude=True)\n    10.392304845413264\n    \n    >>> cross_product(vector_a, vector_v, return_orthogonal_unit_vector=True)\n    array([-0.28867513, 0.57735027, -0.28867513])\n    \"\"\"\n    vector_a = np.array(vector_recursector_a)\n    vector_b = np.array(vector_b)\n    cross = np.cross(vector_a, vector_b)\n    if return_magnitude:\n        return np.linalg.norm(cross)\n    elif return_orthogonal_unit_vector:\n        if np.linalg.norm(cross) == 0:\n            raise ValueError(\"The input vectors are parallel so no unique orthogonal unit vector exists.\")\n        return cross / np.linalg.norm(cross)\n    else:\n        return cross", "def vector_cross_product(vector_a, vector_b):\n    \"\"\"\n    Calculate the cross product of two 3-dimensional vectors.\n    Parameters:\n    vector_a (arraylike): First input vector; must be a sequence of three numbers.\n    vector_b (arraylike): Second input vector; must be a sequence of three numbers.\n    Returns:\n    ndarray: The cross product of vectors a and b.\n    Examples:\n    >>> vector_cross_product([1, 0, 0], [0, 1, 0])\n    array([0, 0, 1])\n    >>> vector_cross_product([2, 3, 4], [5, 6, 7])\n    array([-3,  6, -3])\n    \"\"\"\n    a = np.array(vector_a)\n    b = np.array(vector_b)\n    return np.cross(a, b)", "def vector_cross_product(vector1, vector2):\n    \"\"\"\n    Calculate the cross product of two vectors in 3-dimensional space.\n    Parameters:\n      vector1 (list of float): The first vector, must be a list of three floats.\n      vector2 (list of float): The second vector, must be a list of three floats.\n    \n    Returns:\n      list of float: The cross product vector.\n    \n    Example:\n      >>> vector_cross_product([1, 2, 3], [4, 5, 6])\n      [-3, 6, -3]\n    \"\"\"\n    import numpy as np\n    return list(np.cross(vector1, vector2))"], ["def vector_triple_product(vector1, vector2, vector3):\n    \"\"\"\n    Compute the vector triple product (u x (v x w)).\n    Parameters:\n      vector1 (list of float): The first vector u, must be a list of three floats.\n      vector2 (list of float): The second vector v, must be a list of three floats.\n      vector3 (list of float): The third vector w, must be a list of three floats.\n    \n    Returns:\n      list of float: The result of the triple product.\n    \n    Example:\n      >>> vector_triple_product([1, 0, 0], [0, 1, 0], [0, 0, 1])\n      [1, 0, 0]\n    \"\"\"\n    import numpy as np\n    cross_v_w = np.cross(vector2, vector3)\n    return list(np.cross(vector1, cross_v_w))"], ["def vector_operations_toolkit(vector_a, vector_b, operation='cross_product'):\n    \"\"\"\n    Perform various vector operations including subtraction, cross product magnitudes, and checking orthogonality.\n    Parameters:\n    vector_a (arraylike): First input vector; must be 3-dimensional.\n    vector_b (arraylike): Second input vector; must be 3-dimensional.\n    operation (str): Type of operation to perform, can be 'subtraction', 'cross_product', 'magnitude', or 'orthogonality'.\n    Returns:\n    var: Depending on the operation, it can either be an ndarray, a float for magnitudes, or a boolean for orthogonality check.\n    Examples:\n    >>> vector_operations_toolkit([1, 2, 3], [4, 5, 6], 'subtraction')\n    array([-3, -3, -3])\n    >>> vector_operations_toolkit([1, 0, 0], [0, 1, 0], 'cross_product')\n    array([0, 0, 1])\n    >>> vector_operations_toolkit([1, 0, 0], [0, 1, 0], 'magnitude')\n    1.0\n    >>> vector_operations_toolkit([1, 0, 0], [0, 1, 0], 'orthogonality')\n    True\n    \"\"\"\n    a = np.array(vector_a)\n    b = np.array(vector_b)\n    if operation == 'subtraction':\n        return a - b\n    elif operation == 'cross_product':\n        return np.cross(a, b)\n    elif operation == 'magnitude':\n        return np.linalg.norm(np.cross(a, b))\n    elif operation == 'orthogonality':\n        dot_product = np.dot(a, np.cross(a, b))\n        return np.isclose(dot_product, 0)\n    else:\n        raise ValueError(\"Unsupported operation\")"], ["def vector_magnitude(vector):\n    \"\"\"\n    Calculate the magnitude (or length) of a vector in 3-dimensional space.\n    Parameters:\n      vector (list of float): The vector, must be a list of three floats.\n    \n    Returns:\n      float: The magnitude of the vector.\n    \n    Example:\n      >>> vector_magnitude([1, 2, 3])\n      3.7416573867739413\n    \"\"\"\n    import numpy as np\n    return np.linalg.norm(vector)"]]}