{"Absolute Value": [{"tool": "def add_complex(z1, z2):\n    \n    return z1 + z2", "subfield": "Absolute Value", "tool_name": "add_complex", "tool_type": "function", "description": "Adds two complex numbers.", "docstring": "Adds two complex numbers.\n    Parameters:\n        z1 (complex): The first complex number.\n        z2 (complex): The second complex number.\n    Returns:\n        complex: The sum of z1 and z2.", "Freq": 0, "TSR": 0}, {"tool": "def modulus_complex(z):\n    \n    return np.abs(z)", "subfield": "Absolute Value", "tool_name": "modulus_complex", "tool_type": "function", "description": "Computes the modulus (absolute value) of a complex number.", "docstring": "Computes the modulus (absolute value) of a complex number.\n    Parameters:\n        z (complex): The complex number to compute the modulus for.\n    Returns:\n        float: The modulus of the complex number.", "Freq": 14, "TSR": 10}, {"tool": "def conjugate(z):\n    \n    return np.conj(z)", "subfield": "Absolute Value", "tool_name": "conjugate", "tool_type": "function", "description": "Return the complex conjugate of the given complex number.\n    \n    :param z: complex, a complex number in the form a + bi.\n    :return: complex, the conjugate of the complex number.\n    Examples\n    --------\n    >>> conjugate(3 + 4j)\n    (3-4j)", "docstring": "Return the complex conjugate of the given complex number.\n    \n    :param z: complex, a complex number in the form a + bi.\n    :return: complex, the conjugate of the complex number.\n    Examples\n    --------\n    >>> conjugate(3 + 4j)\n    (3-4j)", "Freq": 1, "TSR": 1}, {"tool": "def subtract_complex(z1, z2):\n    \n    return z1 - z2", "subfield": "Absolute Value", "tool_name": "subtract_complex", "tool_type": "function", "description": "Subtracts the second complex number from the first.", "docstring": "Subtracts the second complex number from the first.\n    Parameters:\n    - z1 (complex): The first complex number.\n    - z2 (complex): The second complex number.\n    Returns:\n    - complex: The result of z1 - z2.\n    Examples:\n    >>> subtract_complex(1+2j, 3+4j)\n    (-2-2j)", "Freq": 0, "TSR": 0}, {"tool": "def complex_operations(a, b, operation='multiply'):\n    \n    if operation == 'multiply':\n        return np.multiply(a, b)\n    elif operation == 'divide':\n        return np.divide(a, b)\n    elif operation == 'power':\n        return np.power(a, int(b.real))  # b is assumed to be an integer for power\n    else:\n        raise ValueError(\"Unsupported operation. Use 'multiply', 'divide', or 'power'.\")", "subfield": "Absolute Value", "tool_name": "complex_operations", "tool_type": "function", "description": "Perform operations (multiply, divide, power) on two complex numbers given in Cartesian form.", "docstring": "Perform operations (multiply, divide, power) on two complex numbers given in Cartesian form.\n    Parameters:\n    a (complex): First complex number in the form a + bi.\n    b (complex): Second complex number in the form a + bi.\n    operation (str): The operation to perform ['multiply', 'divide', 'power'].\n    Returns:\n    complex: The result of the operation.\n    Examples:\n    >> complex_operations(complex(1, 1), complex(2, 3), 'multiply')\n    (-1+5j)", "Freq": 16, "TSR": 2}, {"tool": "def complex_to_polar(z):\n    \n    return (np.abs(z), np.angle(z))", "subfield": "Absolute Value", "tool_name": "complex_to_polar", "tool_type": "function", "description": "Converts a complex number from Cartesian form to polar coordinates (magnitude and angle).", "docstring": "Converts a complex number from Cartesian form to polar coordinates (magnitude and angle).\n    Parameters:\n        z (complex): The complex number to convert.\n    Returns:\n        tuple: A tuple containing the magnitude and angle (in radians) of the complex number.", "Freq": 3, "TSR": 1}, {"tool": "def divide_complex(z1, z2):\n    \n    return z1 / z2", "subfield": "Absolute Value", "tool_name": "divide_complex", "tool_type": "function", "description": "Divides one complex number by another.", "docstring": "Divides one complex number by another.\n    Parameters:\n        z1 (complex): The numerator complex number.\n        z2 (complex): The denominator complex number.\n    Returns:\n        complex: The quotient z1 / z2.", "Freq": 1, "TSR": 0}, {"tool": "def add_complex(c1, c2):\n    \n    return c1 + c2", "subfield": "Absolute Value", "tool_name": "add_complex", "tool_type": "function", "description": "Adds two complex numbers.", "docstring": "Adds two complex numbers.\n    Parameters:\n    - c1 (complex): The first complex number.\n    - c2 (complex): The second complex number.\n    Returns:\n    - complex: The sum of the two complex numbers.\n    Example:\n    >>> add_complex(1+1j, 1-1j)\n    (2+0j)", "Freq": 0, "TSR": 0}, {"tool": "def convert_complex_number(z, target_form='polar'):\n    \n    modulus = abs(z)\n    argument = cmath.phase(z)\n    if target_form == 'exponential':\n        return cmath.exp(complex(0, argument))\n    elif target_form == 'polar':\n        return modulus, argument\n    else:\n        raise ValueError(\"Unsupported form requested: choose 'polar' or 'exponential'\")", "subfield": "Absolute Value", "tool_name": "convert_complex_number", "tool_type": "function", "description": "Converts a complex number to the specified form and calculates its modulus and argument.", "docstring": "Converts a complex number to the specified form and calculates its modulus and argument.\n    \n    Parameters:\n        z (complex): The complex number in Cartesian form (a + bj).\n        target_form (str): The desired output form ('polar' or 'exponential').\n    \n    Returns:\n        tuple: Depending on the target_form:\n            - 'polar': (modulus, argument)\n            - 'exponential': complex number in exponential form  e^(iÎ¸)\n            \n    Examples:\n        >>> convert_complex_number(1+1j, 'polar')\n        (1.4142135623730951, 0.7853981633974483)\n        >>> convert_complex_format(1+1j, 'exponential')\n        (2.718281828459045**1j*0.7853981633974483)", "Freq": 1, "TSR": 0}, {"tool": "def get_real_imaginary(z):\n    \n    return (z.real, z.imag)", "subfield": "Absolute Value", "tool_name": "get_real_imaginary", "tool_type": "function", "description": "Extracts real and imaginary components of a complex number.", "docstring": "Extracts real and imaginary components of a complex number.\n    \n    Parameters:\n        z (complex): The complex number.\n    \n    Returns:\n        tuple: Contains the real and imaginary parts of the complex number.\n    \n    Examples:\n        >>> get_real_imaginary(1+2j)\n        (1, 2)", "Freq": 0, "TSR": 0}, {"tool": "def conjugate_complex_number(c):\n    \n    return c.conjugate()", "subfield": "Absolute Value", "tool_name": "conjugate_complex_number", "tool_type": "function", "description": "This function computes the conjugate of a complex number.", "docstring": "This function computes the conjugate of a complex number.\n    Parameters:\n    c (complex): Complex number\n    Returns:\n    complex : The conjugate of the complex number `c`.", "Freq": 1, "TSR": 1}, {"tool": "def euler_to_complex(theta):\n    \n    return cmath.exp(1j * theta)", "subfield": "Absolute Value", "tool_name": "euler_to_complex", "tool_type": "function", "description": "Converts an angle in radians, using Euler's formula, to its complex representation.", "docstring": "Converts an angle in radians, using Euler's formula, to its complex representation.\n    \n    Parameters:\n        theta (float): The angle in radians.\n    \n    Returns:\n        complex: A complex number represented by cos(theta) + i*sin(theta).\n    \n    Examples:\n        >>> euler_to_complex(np.pi/4)\n        (0.7071067811865476+0.7071067811865475j)", "Freq": 1, "TSR": 0}, {"tool": "def absolute_value_complex(complex_number):\n    \n    return abs(complex_number)", "subfield": "Absolute Value", "tool_name": "absolute_value_complex", "tool_type": "function", "description": "Computes the absolute value (modulus) of a complex number.", "docstring": "Computes the absolute value (modulus) of a complex number.\n    Parameters:\n    - complex_number (complex): The complex number for which to find the modulus.\n    Returns:\n    - float: The modulus of the complex number.\n    Example:\n    >>> absolute_value_complex(3+4j)\n    5.0", "Freq": 1, "TSR": 1}, {"tool": "def are_equal(z1, z2):\n    \n    return z1 == z2", "subfield": "Absolute Value", "tool_name": "are_equal", "tool_type": "function", "description": "Check if two complex numbers are equal.\n    \n    :param z1: complex, the first complex number.\n    :param z2: complex, the second complex number.\n    :return: bool, True if they are equal, else False.\n    Examples\n    --------\n    >>> are_equal(2+3j, 2+3j)\n    True\n    >>> are_equal(2+3j, 3+2j)\n    False", "docstring": "Check if two complex numbers are equal.\n    \n    :param z1: complex, the first complex number.\n    :param z2: complex, the second complex number.\n    :return: bool, True if they are equal, else False.\n    Examples\n    --------\n    >>> are_equal(2+3j, 2+3j)\n    True\n    >>> are_equal(2+3j, 3+2j)\n    False", "Freq": 0, "TSR": 0}, {"tool": "def argument_complex(z):\n    \n    return np.angle(z)", "subfield": "Absolute Value", "tool_name": "argument_complex", "tool_type": "function", "description": "Computes the argument (angle) of a complex number.", "docstring": "Computes the argument (angle) of a complex number.\n    Parameters:\n        z (complex): The complex number to compute the argument for.\n    Returns:\n        float: The argument of the complex number in radians.", "Freq": 1, "TSR": 1}, {"tool": "def absolute_complex_number(c):\n    \n    return abs(c)", "subfield": "Absolute Value", "tool_name": "absolute_complex_number", "tool_type": "function", "description": "This function computes the absolute value (magnitude) of a complex number.", "docstring": "This function computes the absolute value (magnitude) of a complex number.\n    Parameters:\n    c (complex): Complex number whose absolute value has to be computed.\n    Returns:\n    float : absolute value (magnitude) of the input complex number `c`.", "Freq": 1, "TSR": 0}, {"tool": "def exponent_complex_number(c, n):\n    \n    return c ** n", "subfield": "Absolute Value", "tool_name": "exponent_complex_number", "tool_type": "function", "description": "This function computes the exponent of a complex number.", "docstring": "This function computes the exponent of a complex number.\n    Parameters:\n    c (complex): Complex number\n    n (int): Exponent\n    Returns:\n    complex : The result of raising `c` to the power `n`.", "Freq": 3, "TSR": 2}, {"tool": "def complex_modulus(x, y):\n    \n    return np.sqrt(x**2 + y**2)", "subfield": "Absolute Value", "tool_name": "complex_modulus", "tool_type": "function", "description": "Calculates the modulus of a complex number given its Cartesian coordinates.", "docstring": "Calculates the modulus of a complex number given its Cartesian coordinates.\n    Parameters:\n    x (float): The real part of the complex number.\n    y (float): The imaginary part of the complex number.\n    Returns:\n    float: The modulus of the complex number.\n    Examples:\n    >> complex_modulus(3, 4)\n    5.0", "Freq": 0, "TSR": 0}, {"tool": "def calculate_complex_modulus(z, power=1, additional_operation=None):\n    \n    # Calculating modulus of the complex number\n    mod = abs(z)\n    \n    # Raising to the specified power if necessary\n    if power != 1:\n        mod = mod ** power\n    \n    # Applying additional operation if provided\n    if additional_operation:\n        mod = additional_operation(mod)\n    \n    return mod", "subfield": "Absolute Value", "tool_name": "calculate_complex_modulus", "tool_type": "function", "description": "Calculates the modulus of a complex number raised to a certain power and can perform\n    an additional predefined operation on the modulus such as squaring or square rooting.", "docstring": "Calculates the modulus of a complex number raised to a certain power and can perform\n    an additional predefined operation on the modulus such as squaring or square rooting.\n    Parameters:\n    - z (complex): The complex number (can be in the form of a complex literal or a tuple of (real, imag)).\n    - power (int): The power to which the modulus is raised. Default is 1 (no exponentiation).\n    - additional_operation (callable, optional): A function to apply to the modulus after raising it to the given power.\n    Returns:\n    - float: The result of the modulus calculation after any specified operations.\n    Examples:\n    >>> calculate_complex_modulus(3+4j)\n    5.0\n    >>> calculate_complex_modulus(1+1j, power=2)\n    2.0\n    >>> import math\n    >>> calculate_complex_modulus(1+1j, additional_operation=math.sqrt)\n    1.4142135623730951", "Freq": 0, "TSR": 0}, {"tool": "def complex_from_cartesian(real, imag):\n    \n    return complex(real, imag)", "subfield": "Absolute Value", "tool_name": "complex_from_cartesian", "tool_type": "function", "description": "Constructs a complex number from its real and imaginary parts.", "docstring": "Constructs a complex number from its real and imaginary parts.\n    Parameters:\n        real (float): The real part of the complex number.\n        imag (float): The imaginary part of the complex number.\n    Returns:\n        complex: A complex number represented as real + imag*j.", "Freq": 0, "TSR": 0}, {"tool": "def multiplicative_property(z1, z2):\n    \n    return abs(z1 * z2)", "subfield": "Absolute Value", "tool_name": "multiplicative_property", "tool_type": "function", "description": "Apply the multiplicative property of moduli on two complex numbers.", "docstring": "Apply the multiplicative property of moduli on two complex numbers.\n    Parameters\n    ----------\n    z1, z2 : complex\n        Two complex numbers.\n    Returns\n    -------\n    float\n        The product of the moduli of the given complex numbers, demonstrating that |z1*z2| = |z1|*|z2|.\n    Examples\n    --------\n    >>> multiplicative_property(1+2j, 3+4j)\n    10.0", "Freq": 2, "TSR": 2}, {"tool": "class ComplexAnalysisTool:\n    \"\"\"\n    A class for more advanced analysis involving complex numbers not covered in basic arithmetic operations.\n    \"\"\"\n    pass", "subfield": "Absolute Value", "tool_name": "ComplexAnalysisTool:\n    \"\"\"\n    A class for more advanced analysis involving complex numbers not covered in basic arithmetic operations.\n    \"\"\"\n    pass", "tool_type": "class", "description": "A class for more advanced analysis involving complex numbers not covered in basic arithmetic operations.", "docstring": "A class for more advanced analysis involving complex numbers not covered in basic arithmetic operations.", "Freq": 0, "TSR": 0}, {"tool": "def complex_to_cartesian(z):\n    \n    return (z.real, z.imag)", "subfield": "Absolute Value", "tool_name": "complex_to_cartesian", "tool_type": "function", "description": "Decomposes a complex number into its real and imaginary parts.", "docstring": "Decomposes a complex number into its real and imaginary parts.\n    Parameters:\n        z (complex): The complex number to decompose.\n    Returns:\n        tuple: A tuple containing the real part and imaginary part of the complex number.", "Freq": 0, "TSR": 0}, {"tool": "def magnitude_phase(z):\n    \n    return (abs(z), cmath.phase(z))", "subfield": "Absolute Value", "tool_name": "magnitude_phase", "tool_type": "function", "description": "Computes the magnitude and phase of the complex number.", "docstring": "Computes the magnitude and phase of the complex number.\n    \n    Parameters:\n        z (complex): The complex number.\n    \n    Returns:\n        tuple: Magnitude and phase (angle in radians) of the complex number.\n    \n    Examples:\n        >>> magnitude_phase(1+2j)\n        (2.23606797749979, 1.1071487177940904)", "Freq": 0, "TSR": 0}, {"tool": "def complex_magnitude(z):\n    \n    return abs(z)", "subfield": "Absolute Value", "tool_name": "complex_magnitude", "tool_type": "function", "description": "Calculates the magnitude of the complex number.", "docstring": "Calculates the magnitude of the complex number.\n    Parameters:\n    - z (complex): A complex number.\n    Returns:\n    - float: The magnitude (absolute value) of the complex number.\n    Examples:\n    >>> complex_magnitude(3+4j)\n    5.0", "Freq": 0, "TSR": 0}], "Function Operations": [{"tool": "def complex_add(z1, z2):\n    \n    return z1 + z2", "subfield": "Function Operations", "tool_name": "complex_add", "tool_type": "function", "description": "Add two complex numbers.", "docstring": "Add two complex numbers.\n    Parameters:\n        z1 (complex): First complex number.\n        z2 (complex): Second complex number.\n    Returns:\n        complex: Sum of the two complex numbers.\n    \n    Example:\n        >>> complex_add(1+2j, 3+4j)\n        (4+6j)", "Freq": 1, "TSR": 0}, {"tool": "def conjugate_complex(z):\n    \n    return np.conjugate(z)", "subfield": "Function Operations", "tool_name": "conjugate_complex", "tool_type": "function", "description": "Compute the complex conjugate of a complex number.", "docstring": "Compute the complex conjugate of a complex number.\n    \n    Parameters:\n        z (complex): The complex number.\n        \n    Returns:\n        complex: The conjugate of the complex number.", "Freq": 1, "TSR": 0}, {"tool": "def add_complex_numbers(z1, z2):\n    \n    return z1 + z2", "subfield": "Function Operations", "tool_name": "add_complex_numbers", "tool_type": "function", "description": "Add two complex numbers.", "docstring": "Add two complex numbers.\n    \n    Parameters:\n        z1 (sp.core.expr.Expr): A complex number.\n        z2 (sp.core.expr.Expr): Another complex number.\n        \n    Returns:\n        sp.core.expr.Expr: The sum of the two complex numbers.\n        \n    Example:\n        >>> add_complex_numbers(sp.I, 1 + 1*sp.I)\n        1 + 2*I", "Freq": 0, "TSR": 0}, {"tool": "def inverse_complex(z):\n    \n    if z == 0:\n        raise ValueError(\"Complex number cannot be zero for inversion.\")\n    return 1 / z", "subfield": "Function Operations", "tool_name": "inverse_complex", "tool_type": "function", "description": "Compute the multiplicative inverse of a complex number.", "docstring": "Compute the multiplicative inverse of a complex number.\n    \n    Parameters:\n        z (complex): The complex number to invert.\n        \n    Returns:\n        complex: The inverse of the complex number.", "Freq": 0, "TSR": 0}, {"tool": "def modulus_of_complex(z):\n    \n    if isinstance(z, tuple):\n        z = complex(*z)\n    return np.abs(z)", "subfield": "Function Operations", "tool_name": "modulus_of_complex", "tool_type": "function", "description": "Calculate the modulus (absolute value) of a complex number.", "docstring": "Calculate the modulus (absolute value) of a complex number.\n    Parameters:\n    - z (complex or tuple): The complex number.\n    Returns:\n    - float: The modulus of the complex number.\n    Example:\n    >>> modulus_of_complex((3+4j))\n    5.0", "Freq": 1, "TSR": 1}, {"tool": "def cartesian_to_polar(z):\n    \n    return cmath.polar(z)", "subfield": "Function Operations", "tool_name": "cartesian_to_polar", "tool_type": "function", "description": "Convert Cartesian coordinates to polar coordinates.", "docstring": "Convert Cartesian coordinates to polar coordinates.\n    \n    Parameters:\n        z (complex): Complex number in Cartesian form.\n    \n    Returns:\n        tuple: Two-dimensional tuple (magnitude, angle_in_radians).\n    \n    Examples:\n        >>> cartesian_to_polar(1+1j)\n        (1.4142135623730951, 0.7853981633974483)", "Freq": 0, "TSR": 0}, {"tool": "def real_part(z):\n    \n    return z.real", "subfield": "Function Operations", "tool_name": "real_part", "tool_type": "function", "description": "Extract the real part of a complex number.", "docstring": "Extract the real part of a complex number.\n    Parameters:\n        z (complex): The complex number.\n    Returns:\n        float: The real part of the complex number.\n    \n    Example:\n        >>> real_part(3+4j)\n        3.0", "Freq": 0, "TSR": 0}, {"tool": "def apply_piecewise_function(z, conditions_functions):\n    \n    result = None\n    for condition, function in conditions_functions:\n        if condition.subs(z, z):\n            result = function.subs(z, z)\n            break\n    return result", "subfield": "Function Operations", "tool_name": "apply_piecewise_function", "tool_type": "function", "description": "Apply a piecewise function to a complex number based on specified conditions and functions.", "docstring": "Apply a piecewise function to a complex number based on specified conditions and functions.\n    \n    Parameters:\n        z (sp.core.expr.Expr): The input complex number.\n        conditions_functions (list of tuples): Each tuple contains a condition and a corresponding function.\n    \n    Returns:\n        sp.core.expr.Expr: The result after applying the piecewise function.\n        \n    Example:\n        >>> conditions_functions = [\n                (sp.Abs(z) > 1, z**2),\n                (sp.Abs(z) <= 1, z + 1)\n            ]\n        >>> apply_piecewise_function(sp.I, conditions_functions)\n        1 + I", "Freq": 0, "TSR": 0}, {"tool": "def euler_to_complex(r, theta):\n    \n    return r * np.exp(1j * theta)", "subfield": "Function Operations", "tool_name": "euler_to_complex", "tool_type": "function", "description": "Convert a complex number from polar (Euler's) form (r*e^(i*theta)) to rectangular form.", "docstring": "Convert a complex number from polar (Euler's) form (r*e^(i*theta)) to rectangular form.\n    \n    Parameters:\n        r (float): Magnitude of the complex number.\n        theta (float): Phase (angle in radians) of the complex number.\n    \n    Returns:\n        complex: The complex number in rectangular form.\n    \n    Examples:\n        >>> euler_to_complex(5, np.pi/4)\n        (3.5355339059327378+3.5355339059327378j)", "Freq": 0, "TSR": 0}, {"tool": "def perform_complex_arithmetic(z1, z2, operation='add'):\n    \n    if isinstance(z1, tuple):\n        z1 = complex(*z1)\n    if isinstance(z2, tuple):\n        z2 = complex(*z2)\n    \n    if operation == 'add':\n        return z1 + z2\n    elif operation == 'subtract':\n        return z1 - z2\n    elif operation == 'multiply':\n        return z1 * z2\n    elif operation == 'divide':\n        return z1 / z2 if z2 != 0 else None", "subfield": "Function Operations", "tool_name": "perform_complex_arithmetic", "tool_type": "function", "description": "Calculate arithmetic operations between two complex numbers.", "docstring": "Calculate arithmetic operations between two complex numbers.\n    Parameters:\n    - z1 (complex or tuple): The first complex number.\n    - z2 (complex or tuple): The second complex number.\n    - operation (str): The type of arithmetic operation ('add', 'subtract', 'multiply', 'divide').\n    Returns:\n    - complex: The result of the arithmetic operation on the two complex numbers.\n    Example:\n    >>> perform_complex_arithmetic((1, 2), (3, 4), 'add')\n    (4+6j)\n    >>> perform_complex_arithmetic((1, 2), (3, 4), 'multiply')\n    (-5+10j)", "Freq": 0, "TSR": 0}, {"tool": "def complex_scale(z, factor):\n    \n    return z * factor", "subfield": "Function Operations", "tool_name": "complex_scale", "tool_type": "function", "description": "Scales a complex number by a given factor.", "docstring": "Scales a complex number by a given factor.\n    Parameters:\n    - z (complex): The complex number to scale.\n    - factor (float or complex): Scaling factor.\n    Returns:\n    - complex: The scaled complex number.\n    Examples:\n    >>> complex_scale(1+2j, 2)\n    (2+4j)", "Freq": 1, "TSR": 0}, {"tool": "def calculate_complex_power(z, power):\n    \n    if isinstance(z, tuple):\n        z = complex(*z)\n    return np.power(z, power)", "subfield": "Function Operations", "tool_name": "calculate_complex_power", "tool_type": "function", "description": "Calculate the exponentiation of a complex number.", "docstring": "Calculate the exponentiation of a complex number.\n    Parameters:\n    - z (complex or tuple): The complex number.\n    - power (int): The power to which the complex number is raised.\n    Returns:\n    - complex: The complex number raised to the specified power.\n    Example:\n    >>> calculate_complex_power((1, 2), 3)\n    (-9+46j)", "Freq": 2, "TSR": 0}, {"tool": "def normalize_angle(angle):\n    \n    return angle % (2 * math.pi)", "subfield": "Function Operations", "tool_name": "normalize_angle", "tool_type": "function", "description": "Normalize an angle to the range [0, 2*pi).", "docstring": "Normalize an angle to the range [0, 2*pi).\n    \n    Parameters:\n        angle (float): An angle in radians.\n        \n    Returns:\n        float: The angle normalized to [0, 2*pi).", "Freq": 0, "TSR": 0}, {"tool": "def from_polar(magnitude, angle):\n    \n    return magnitude * np.exp(1j * angle)", "subfield": "Function Operations", "tool_name": "from_polar", "tool_type": "function", "description": "Convert a complex number from polar to Cartesian form using Euler's formula.", "docstring": "Convert a complex number from polar to Cartesian form using Euler's formula.\n    \n    Parameters:\n        magnitude (float): The magnitude of the complex number.\n        angle (float): The angle in radians.\n        \n    Returns:\n        complex: The complex number in Cartesian form.", "Freq": 0, "TSR": 0}, {"tool": "def complex_operations(z, operation=\"modulus\"):\n    \n    if operation == \"modulus\":\n        return cmath.sqrt(z.real**2 + z.imag**2).real\n    elif operation == \"power\":\n        return cmath.exp(z)\n    elif operation == \"rationalize\":\n        return z.conjugate() / (z.real**2 + z.imag**2)\n    elif operation == \"simplify\":\n        return (z**2).real - 1 + 2 * z.imag * 1j        # Using i^2 = -1", "subfield": "Function Operations", "tool_name": "complex_operations", "tool_type": "function", "description": "Perform various operations on complex numbers such as calculating modulus, \n    finding powers, rationalizing denominator, and simplifying using i^2 = -1.", "docstring": "Perform various operations on complex numbers such as calculating modulus, \n    finding powers, rationalizing denominator, and simplifying using i^2 = -1.\n    Parameters:\n    z (complex): The complex number to operate on.\n    operation (str): Type of operation to perform ['modulus', 'power', 'rationalize', 'simplify'].\n    Returns:\n    Various: Depending on the operation, returns complex number or real number.\n    \n    Example:\n    >>> complex_operations(1+3j, \"modulus\")\n    3.1622776601683795\n    >>> complex_operations((1+3j)**2, \"simplify\")\n    (-8+6j)", "Freq": 0, "TSR": 0}, {"tool": "class ComplexOperations:\n    \"\"\"\n    A class containing a suite of operations for complex numbers.\n    \"\"\"\n    @staticmethod\n    def add_complex_numbers(z1, z2):\n        \"\"\"\n        Add two complex numbers.\n        Parameters:\n        z1 (complex): First complex number.\n        z2 (complex): Second complex number.\n        Returns:\n        complex: The sum of the two complex numbers.\n        Examples:\n        >>> ComplexOperations.add_complex_numbers(1+2j, 3+4j)\n        (4+6j)\n        \"\"\"\n        return z1 + z2\n    @staticmethod\n    def multiply_complex_numbers(z1, z2):\n        \"\"\"\n        Multiply two complex numbers.\n        Parameters:\n        z1 (complex): First complex number.\n        z2 (complex): Second complex number.\n        Returns:\n        complex: The product of the two complex numbers.\n        Examples:\n        >>> ComplexOperations.multiply_complex_numbers(1+2j, 3+4j)\n        (-5+10j)\n        \"\"\"\n        return z1 * z2\n    @staticmethod\n    def square_complex_number(z):\n        \"\"\"\n        Square a complex number.\n        Parameters:\n        z (complex): Complex number to square.\n        Returns:\n        complex: The square of the complex number.\n        Examples:\n        >>> ComplexOperations.square_complex_number(2+3j)\n        (-5+12j)\n        \"\"\"\n        return z * z\n    @staticmethod\n    def find_fixed_points(w, z):\n        \"\"\"\n        Find fixed points of the function w(z), assuming w is a lambda function.\n        Parameters:\n        w (function): A lambda function representing a complex function w(z).\n        z (sympy.Symbol): Symbolic representation of complex variable z.\n        Returns:\n        list: Solutions that satisfy w(z) = z.\n        Examples:\n        >>> z = sp.symbols('z', complex=True)\n        >>> w = lambda z: z**2 + 1 + 0*z  # Suppresses simplification issues\n        >>> ComplexOperations.find_fixed_points(w, z)\n        [1/2 - sqrt(3)*I/2, 1/2 + sqrt(3)*I/2]\n        \"\"\"\n        z_fixed = sp.Eq(w(z), z)\n        return sp.solve(z_fixed, z)\n    @staticmethod\n    def apply_piecewise_function(funcs, conditions, z):\n        \"\"\"\n        Evaluate piecewise complex functions based on conditions.\n        Parameters:\n        funcs (list of functions): A list of lambda functions for each piece.\n        conditions (list of functions): A list of lambda boolean expressions representing conditions for pieces.\n        z (complex): Complex number input.\n        Returns:\n        complex: Output after evaluating the correct piece.\n        Examples:\n        >>> funcs = [lambda z: z**2, lambda z: sp.exp(z)]\n        >>> conditions = [lambda z: sp.re(z) > 0, lambda z: sp.re(z) <= 0]\n        >>> ComplexOperations.apply_piecewise_function(funcs, conditions, -1+1j)\n        exp(-1 + 1j)\n        \"\"\"\n        for func, condition in zip(funcs, conditions):\n            if condition(z):\n                return func(z)\n        return None  # Default case if no conditions are met", "subfield": "Function Operations", "tool_name": "ComplexOperations:\n    \"\"\"\n    A class containing a suite of operations for complex numbers.\n    \"\"\"\n    @staticmethod\n    def add_complex_numbers", "tool_type": "class", "description": "A class containing a suite of operations for complex numbers.", "docstring": "A class containing a suite of operations for complex numbers.", "Freq": 0, "TSR": 0}, {"tool": "def find_fixed_points(z_function, z_var, initial_guesses):\n    \n    equation = sp.Eq(z_function, z_var)\n    solutions = []\n    for guess in initial_guesses:\n        sol = sp.nsolve(equation, z_var, guess)\n        if sol not in solutions:  # Avoid duplicate roots\n            solutions.append(sol)\n    return solutions", "subfield": "Function Operations", "tool_name": "find_fixed_points", "tool_type": "function", "description": "Find fixed points of a complex function where f(z) = z.", "docstring": "Find fixed points of a complex function where f(z) = z.\n    \n    Parameters:\n        z_function (sp.core.expr.Expr): A function of complex variable z.\n        z_var (sp.Symbol): The symbol used as a complex variable in z_function.\n        initial_guesses (list): List of initial guesses to start the root finding.\n        \n    Returns:\n        list: The list of complex numbers which are fixed points.\n        \n    Example:\n        >>> z = sp.symbols('z')\n        >>> f_z = z**2 + 1 - 1*z\n        >>> find_fixed_points(f_z, z, [0, 1 + sp.I])\n        [-1.0, 1.0]", "Freq": 0, "TSR": 0}, {"tool": "def complex_details(z):\n    \n    real_part = z.real\n    imaginary_part = z.imag\n    modulus = cmath.sqrt(real_part**2 + imaginary_part**2).real\n    reciprocal = 1 / z if z != 0 else None\n    return {\n        \"real_part\": real_part,\n        \"imaginary_part\": imaginary_part,\n        \"modulus\": modulus,\n        \"reciprocal\": reciprocal\n    }", "subfield": "Function Operations", "tool_name": "complex_details", "tool_type": "function", "description": "Provides detailed components of a complex number including real and imaginary parts,\n    and other representations.", "docstring": "Provides detailed components of a complex number including real and imaginary parts,\n    and other representations.\n    Parameters:\n    z (complex): A complex number.\n    \n    Returns:\n    dict: Dictionary containing real and imaginary parts, modulus, and reciprocal,\n    \n    Example:\n    >>> complex_details(1+3j)\n    {'real_part': 1, 'imaginary_part': 3, 'modulus': 3.1622776601683795, 'reciprocal': (0.1-0.3j)}", "Freq": 0, "TSR": 0}, {"tool": "def raise_to_power(z, power):\n    \n    magnitude, angle = to_polar(z)\n    return from_polar(magnitude**power, angle*power)", "subfield": "Function Operations", "tool_name": "raise_to_power", "tool_type": "function", "description": "Raise a complex number to a given power using DeMoivre's Theorem.", "docstring": "Raise a complex number to a given power using DeMoivre's Theorem.\n    \n    Parameters:\n        z (complex): The complex number.\n        power (int): The power to which the complex number is to be raised.\n        \n    Returns:\n        complex: The result of raising z to the power.", "Freq": 0, "TSR": 0}, {"tool": "def square_sum_complex(z1, z2):\n    \n    sum_z = z1 + z2\n    squares_sum = z1**2 + z2**2\n    twice_product = 2 * z1 * z2\n    return (sum_z**2, squares_sum, twice_product)", "subfield": "Function Operations", "tool_name": "square_sum_complex", "tool_type": "function", "description": "Calculate the square of the sum of two complex numbers and relate it to separate squares and product.", "docstring": "Calculate the square of the sum of two complex numbers and relate it to separate squares and product.\n    Parameters:\n        z1 (complex): First complex number.\n        z2 (complex): Second complex number.\n    Returns:\n        tuple: Contains the square of the sum, sum of squares, and twice the product of the numbers.\n    \n    Example:\n        >>> square_sum_complex(1+2j, 3+4j)\n        ((16+20j), (10+20j), 28+0j)", "Freq": 0, "TSR": 0}, {"tool": "def create_complex(real, imag):\n    \n    return complex(real, imag)", "subfield": "Function Operations", "tool_name": "create_complex", "tool_type": "function", "description": "Create a complex number from real and imaginary parts.", "docstring": "Create a complex number from real and imaginary parts.\n    Parameters:\n        real (float): The real part of the complex number.\n        imag (float): The imaginary part of the complex number.\n    Returns:\n        complex: The complex number represented as 'real + imag*j'.\n    \n    Example:\n        >>> create_complex(3, 4)\n        (3+4j)", "Freq": 0, "TSR": 0}, {"tool": "def magnitude_and_phase(z):\n    \n    return (np.abs(z), np.angle(z))", "subfield": "Function Operations", "tool_name": "magnitude_and_phase", "tool_type": "function", "description": "Calculate magnitude and phase (angle) of a complex number.", "docstring": "Calculate magnitude and phase (angle) of a complex number.\n    \n    Parameters:\n        z (complex): Complex number to calculate properties for.\n    \n    Returns:\n        tuple: Magnitude and phase (in radians).\n    \n    Examples:\n        >>> magnitude_and_phase(3+4j)\n        (5.0, 0.9272952180016122)", "Freq": 0, "TSR": 0}]}