{"Circles": [{"tool": "def circle_circumference(radius):\n    \n    return 2 * np.pi * radius", "subfield": "Circles", "tool_name": "circle_circumference", "tool_type": "function", "description": "Calculates the circumference of a circle given its radius.", "docstring": "Calculates the circumference of a circle given its radius.\n    \n    Parameters:\n        radius (float): The radius of the circle.\n    Returns:\n        float: The circumference of the circle.", "Freq": 2, "TSR": 0}, {"tool": "def circle_area(radius):\n    \n    return math.pi * radius ** 2", "subfield": "Circles", "tool_name": "circle_area", "tool_type": "function", "description": "Calculate the area of a circle given the radius.", "docstring": "Calculate the area of a circle given the radius.\n    \n    Parameters:\n    - radius (float): The radius of the circle.\n    \n    Returns:\n    - float: The area of the circle.", "Freq": 11.0, "TSR": 2.5}, {"tool": "def circle_standard_form(h, k, r):\n    \n    x, y = sympy.symbols('x y')\n    return sympy.Eq((x - h)**2 + (y - k)**2, r**2)", "subfield": "Circles", "tool_name": "circle_standard_form", "tool_type": "function", "description": "Create the standard form equation of a circle (x-h)^2 + (y-k)^2 = r^2.", "docstring": "Create the standard form equation of a circle (x-h)^2 + (y-k)^2 = r^2.\n    \n    Parameters:\n        h (float): The x-coordinate of the circle's center.\n        k (float): The y-coordinate of the circle's center.\n        r (float): The radius of the circle.\n        \n    Returns:\n        sympy.Eq: The equation of the circle in sympy equation format.\n        \n    Example:\n        >>> print(circle_standard_form(0, 0, 5))\n        Eq(x**2 + y**2, 25)", "Freq": 1, "TSR": 1}, {"tool": "def circle_properties_from_equation(h, k, r_squared):\n    \n    r = sqrt(r_squared)\n    area = pi * r**2\n    circumference = 2 * pi * r\n    return {\n        'center': (h, k),\n        'radius': r.evalf(),\n        'area': area.evalf(),\n        'circumference': circumference.evalf()\n    }", "subfield": "Circles", "tool_name": "circle_properties_from_equation", "tool_type": "function", "description": "Given the parameters h, k (center of the circle) and r_squared (radius squared),\n    returns the center, radius, area, and circumference of the circle.", "docstring": "Given the parameters h, k (center of the circle) and r_squared (radius squared),\n    returns the center, radius, area, and circumference of the circle.\n    \n    Parameters:\n        h (float): x-coordinate of the center of the circle\n        k (float): y-coordinate of the center of the circle\n        r_squared (float): square of the radius of the circle\n    Returns:\n        dict: Dictionary containing the center, radius, area, and circumference\n    \n    Examples:\n    >>> circle_properties_from_equation(0, 0, 25)\n    {'center': (0, 0), 'radius': 5.0, 'area': 78.5398, 'circumference': 31.4159}", "Freq": 4, "TSR": 2, "experience_pool": "Experience 1:\nProblem: What is the area of a circle with a radius of 7?\nAnswer: 153.93804002589985\n\nExperience 2:\nProblem: Calculate the circumference of a circle with a radius of 10.\nAnswer: 62.83185307179586"}, {"tool": "def point_inside_circle(center, radius, point):\n    \n    return np.sqrt((point[0] - center[0])**2 + (point[1] - center[1])**2) <= radius", "subfield": "Circles", "tool_name": "point_inside_circle", "tool_type": "function", "description": "Determine if a point is inside a given circle.", "docstring": "Determine if a point is inside a given circle.\n    \n    Parameters:\n    - center (tuple): The (x, y) coordinates of the circle's center.\n    - radius (float): The radius of the circle.\n    - point (tuple): The (x, y) coordinates of the point to check.\n    \n    Returns:\n    - bool: True if the point is inside the circle, False otherwise.", "Freq": 0, "TSR": 0}, {"tool": "def circle_properties(radius, chord_length=None, angle_radians=None):\n    area = math.pi * radius**2\n    circumference = 2 * math.pi * radius\n    properties = {\n        'Area': area,\n        'Circumference': circumference\n    }\n    if chord_length is not None:\n        if angle_radians is None:\n            angle_radians = 2 * math.acos(chord_length / (2 * radius))\n        sagitta = radius * (1 - math.cos(angle_radians / 2))\n        arc_length = radius * angle_radians\n        segment_area = (radius**2 / 2) * (angle_radians - math.sin(angle_radians))\n        \n        properties.update({\n            'Chord Length': chord_length,\n            'Sagitta': sagitta,\n            'Arc Length': arc_length,\n            'Segment Area': segment_area\n        })\n    return properties", "subfield": "Circles", "tool_name": "circle_properties", "tool_type": "function", "description": "None", "docstring": null, "Freq": 2.5, "TSR": 2}, {"tool": "def compute_triangle_properties(vertices):\n    \n    vertices = np.array(vertices)\n    side_lengths = np.linalg.norm(vertices - np.roll(vertices, -1, axis=0), axis=1)\n    s = np.sum(side_lengths) / 2  # semi-perimeter\n    area = np.sqrt(s * np.prod(s - side_lengths))  # Heron's formula\n    is_iso = np.any(side_lengths[0] == side_lengths[1]) or np.any(side_lengths[1] == side_lengths[2])\n    is_equi = np.all(side_lengths[0] == side_lengths[1])\n    properties = {\n        'Area': area,\n        'Perimeter': 2 * s,\n        'Side Lengths': side_lengths,\n        'Isosceles': is_iso,\n        'Equilateral': is_equi\n    }\n    return properties", "subfield": "Circles", "tool_name": "compute_triangle_properties", "tool_type": "function", "description": "Compute properties of a triangle given its vertices.", "docstring": "Compute properties of a triangle given its vertices.\n    Parameters:\n        vertices (array): An array of three tuples, each representing x, y coordinates of a vertex.\n    Returns:\n        dict: Properties including area, perimeter, side lengths, and types of triangle (isosceles, equilateral).", "Freq": 2, "TSR": 1, "experience_pool": "- Problem: Triangle $ABC$ has side lengths $AB=4$, $BC=5$, and $CA=6$. Points $D$ and $E$ are on ray $AB$ with $AB<AD<AE$. The point $F \\neq C$ is a point of intersection of the circumcircles of $\\triangle ACD$ and $\\triangle EBC$ satisfying $DF=2$ and $EF=7$. Then $BE$ can be expressed as $\\tfrac{a+b\\sqrt{c}}{d}$, where $a$, $b$, $c$, and $d$ are positive integers such that $a$ and $d$ are relatively prime, and $c$ is not divisible by the square of any prime. Find $a+b+c+d$.\n\n- Solution: The error in the solution code is due to the missing variables DF and EF. These variables need to be defined before using them in the equation for DE_squared. To fix the error, the solution code should include the definitions of DF and EF before calculating DE_squared.\n\n```python\n# Given side lengths of the triangle\nAB = 4\nBC = 5\nCA = 6\n\n# Compute the area of the triangle using Heron's formula\nvertices = [(0, 0), (AB, 0), (CA - (BC**2 - AB**2 - CA**2) / (2 * CA), (BC**2 - (CA - (BC**2 - AB**2 - CA**2) / (2 * CA))**2)**0.5)]\ntriangle_properties = compute_triangle_properties(vertices)\narea_ABC = triangle_properties['Area']\n\n# Define DF and EF\nDF = 2\nEF = 7\n\n# Compute DE using Law of Cosines\nDE_squared = DF**2 + EF**2 - 2 * DF * EF * cos(180 - B - A)\nDE = sqrt(DE_squared)\n\n# Compute a and b\na = symbols('a')\nb = a * sqrt(2)\neq = Eq(b * (a + 4), a * (b + 4 * sqrt(2)))\na_value = solve(eq, a)[0]\n\n# Compute BE\nBE = a_value + a_value * sqrt(2) + 4 * sqrt(2)\n\n# Calculate the final result\nresult = int(BE.as_numer_denom()[0]) + int(BE.as_numer_denom()[1]) + int(BE.as_numer_denom()[1].as_numer_denom()[0]) + int(BE.as_numer_denom()[1].as_numer_denom()[1])\nreturn result\n```"}, {"tool": "def find_curve_equation(radius):\n    \n    if radius == 0:\n        return \"Point\"\n    elif radius > 0:\n        return \"Circle\"\n    else:\n        return \"No curve\"", "subfield": "Circles", "tool_name": "find_curve_equation", "tool_type": "function", "description": "Find the curve defined by the equation r = radius.", "docstring": "Find the curve defined by the equation r = radius.\n    Parameters:\n    radius (float): The radius of the circle.\n    Returns:\n    str: The geometric shape based on the given equation.", "Freq": 0, "TSR": 0}], "Coordinate Geometry": [{"tool": "def distance_between_points(point1, point2):\n    \n    x1, y1 = point1\n    x2, y2 = point2\n    return ((x2 - x1)**2 + (y2 - y1)**2)**0.5", "subfield": "Coordinate Geometry", "tool_name": "distance_between_points", "tool_type": "function", "description": "Calculate the Euclidean distance between two points in the plane.", "docstring": "Calculate the Euclidean distance between two points in the plane.\n    \n    Parameters:\n    - point1 (tuple): The first point (x1, y1).\n    - point2 (tuple): The second point (x2, y2).\n    \n    Returns:\n    - float: The distance between the points.\n    \n    Examples:\n    >>> distance_between_points((1, 2), (4, 6))\n    5.0", "Freq": 82, "TSR": 55, "experience_pool": "Tool: distance_between_points\nField: Geometry\nSubfield: Coordinate Geometry\nTool Usage Frequency: 35\nTool Success Rate: 68.57%\nTool docstring: Calculate the Euclidean distance between two points in the plane.\n\nParameters:\n- point1 (tuple): The first point (x1, y1).\n- point2 (tuple): The second point (x2, y2).\n\nReturns:\n- float: The distance between the points.\n\nExamples:\n>>> distance_between_points((1, 2), (4, 6))\n5.0"}, {"tool": "def midpoint(p1, p2):\n    \n    return tuple((np.array(p1) + np.array(p2)) / 2)", "subfield": "Coordinate Geometry", "tool_name": "midpoint", "tool_type": "function", "description": "Calculates the midpoint between two points in a 2D coordinate system.", "docstring": "Calculates the midpoint between two points in a 2D coordinate system.\n    Parameters:\n    - p1: Tuple of coordinates (x1, y1) for the first point.\n    - p2: Tuple of coordinates (x2, y2) for the second point.\n    Returns:\n    - Tuple: Coordinates of the midpoint.\n    Example:\n    >>> midpoint((1, 2), (3, 4))\n    (2.0, 3.0)", "Freq": 37, "TSR": 26, "experience_pool": "- Problem: Point M(3,7) is the midpoint of line segment AB. If point A has coordinates (9,3), what is the sum of the coordinates of point B?\n  - Answer: 8\n  - The solution function correctly calculates the sum of the coordinates of point B using the midpoint formula.\n- Problem: Point M(4,4) is the midpoint of line segment AB. If point A has coordinates (8,4), what is the sum of the coordinates of point B?\n  - Answer: 4\n  - The solution function correctly calculates the sum of the coordinates of point B using the midpoint formula.\n- Problem: In a polar coordinate system, the midpoint of the line segment whose endpoints are (8, 5pi/12) and (8, -3pi/12) is the point (r, theta). Enter (r, theta), where r > 0 and 0 <= theta < 2pi.\n  - Answer: (4, pi/12)\n  - The solution function correctly calculates the midpoint coordinates using the given endpoints.\n- Problem: In convex quadrilateral ABCD, AB=BC=13, CD=DA=24, and angle D=60 degrees. Points X and Y are the midpoints of BC and DA respectively. Compute XY^2 (the square of the length of XY).\n  - Answer: 1033/4 + 30sqrt(3)\n  - The solution function correctly calculates the square of the length of XY using the midpoint formula and distance formula.\n- Problem: In square ABCD, AD is 4 centimeters, and M is the midpoint of CD. Let O be the intersection of AC and BM. What is the ratio of OC to OA? Express your answer as a common fraction.\n  - Answer: 1/2\n  - The solution function correctly calculates the ratio of OC to OA using the midpoint formula and line intersection formula."}, {"tool": "def slope_of_line(p1, p2):\n    \n    x1, y1 = p1\n    x2, y2 = p2\n    if x2 == x1:\n        raise ValueError(\"Vertical line segment has no slope.\")\n    return (y2 - y1) / (x2 - x1)", "subfield": "Coordinate Geometry", "tool_name": "slope_of_line", "tool_type": "function", "description": "Computes the slope of the line segment connecting two points. Raises exception if the line is vertical.", "docstring": "Computes the slope of the line segment connecting two points. Raises exception if the line is vertical.\n    Parameters:\n    - p1: Tuple of coordinates (x1, y1)\n    - p2: Tuple of coordinates (x2, y2)\n    Returns:\n    - float: Slope of the line.\n    Example:\n    >>> slope_of_line((1, 2), (3, 6))\n    2.0", "Freq": 31, "TSR": 20}, {"tool": "def area_of_triangle(p1, p2, p3):\n    if len(p1) == 2:\n        x1, y1 = p1\n        x2, y2 = p2\n        x3, y3 = p3\n        return 0.5 * abs(x1*(y2 - y3) + x2*(y3 - y1) + x3*(y1 - y2))\n    elif len(p1) == 3:\n        x1, y1, z1 = p1\n        x2, y2, z2 = p2\n        x3, y3, z3 = p3\n        return 0.5 * abs(x1*(y2*z3 - y3*z2) + x2*(y3*z1 - y1*z3) + x3*(y1*z2 - y2*z1))\n    else:\n        raise ValueError(\"Invalid number of coordinates for vertices.\")", "subfield": "Coordinate Geometry", "tool_name": "area_of_triangle", "tool_type": "function", "description": "None", "docstring": null, "Freq": 23.0, "TSR": 9.0}, {"tool": "def reflect(point, axis=\"x\"):\n    \n    x, y = point\n    if axis == \"x\":\n        return (x, -y)\n    elif axis == \"y\":\n        return (-x, y)\n    elif axis == \"origin\":\n        return (-x, -y)\n    elif axis == \"y=x\":\n        return (y, x)\n    else:\n        raise ValueError(\"Invalid axis specified.\")", "subfield": "Coordinate Geometry", "tool_name": "reflect", "tool_type": "function", "description": "Reflect a point across a specified axis in 2D.", "docstring": "Reflect a point across a specified axis in 2D.\n    \n    Parameters:\n        point (tuple): Coordinates (x, y) of the point.\n        axis (str): Axis you want to reflect over, \"x\", \"y\", or \"origin\". Additionally supports \"y=x\".\n    \n    Returns:\n        tuple: Coordinates of the reflected point.\n        \n    Examples:\n        reflect((2, 3), axis=\"x\")\n        reflect((2, 3), axis=\"y\")\n        reflect((2, 3), axis=\"origin\")\n        reflect((2, 3), axis=\"y=x\")", "Freq": 11, "TSR": 10, "experience_pool": "- Reflecting a point across the x-axis: reflect((2, 3), axis=\"x\") returns (2, -3)\n- Reflecting a point across the y-axis: reflect((2, 3), axis=\"y\") returns (-2, 3)\n- Reflecting a point across the origin: reflect((2, 3), axis=\"origin\") returns (-2, -3)\n- Reflecting a point across the line y=x: reflect((2, 3), axis=\"y=x\") returns (3, 2)"}, {"tool": "def convert_conic_to_standard_form(eq_type, coefficients):\n    \n    \n    import math\n    if eq_type in ['circle', 'ellipse']:\n        A = coefficients.get('x^2', 0)\n        B = coefficients.get('y^2', 0)\n        C = coefficients.get('x', 0)\n        D = coefficients.get('y', 0)\n        E = coefficients.get('constant', 0)\n        h = -C / (2 * A)\n        k = -D / (2 * B)\n        r_squared = -E + (C**2) / (4 * A) + (D**2) / (4 * B)\n        if eq_type == 'circle':\n            return {'center': (h, k), 'radius': math.sqrt(r_squared)}\n        elif eq_type == 'ellipse':\n            return {'center': (h, k), 'semi_major_axis': math.sqrt(r_squared / A), 'semi_minor_axis': math.sqrt(r_squared / B)}\n    elif eq_type == 'parabola':\n        # Assume coefficients of 'x^2' or 'y^2' and a linear term for directrix/vertex form conversion.\n        pass\n    elif eq_type == 'hyperbola':\n        A = coefficients.get('x^2', 0)\n        B = coefficients.get('y^2', 0)\n        C = coefficients.get('x', 0)\n        D = coefficients.get('y', 0)\n        E = coefficients.get('constant', 0)\n        h = -C / (2 * A)\n        k = -D / (2 * B)\n        r_squared = -E + (C**2) / (4 * A) - (D**2) / (4 * B)\n        return {'center': (h, k), 'semi_major_axis': math.sqrt(r_squared / A), 'semi_minor_axis': math.sqrt(r_squared / B)}\n    \n    return {}", "subfield": "Coordinate Geometry", "tool_name": "convert_conic_to_standard_form", "tool_type": "function", "description": "Converts a general equation of a conic section (circle, ellipse, parabola, hyperbola) to its standard form.", "docstring": "Converts a general equation of a conic section (circle, ellipse, parabola, hyperbola) to its standard form.\n    \n    Parameters:\n    - eq_type (str): Type of conic ('circle', 'ellipse', 'parabola', 'hyperbola').\n    - coefficients (dict): Coefficients of the equation. E.g., for a circle: {'x^2': 1, 'y^2': 1, 'x': -6, 'y': 4, 'constant': -3}\n    \n    Returns:\n    - dict: Standardized form parameters.\n    \n    Example:\n    >>> convert_conic_to_standard_form('circle', {'x^2': 1, 'y^2': 1, 'x': -6, 'y': 4, 'constant': -3})\n    {'center': (3, -2), 'radius': 4}", "Freq": 4.5, "TSR": 1}, {"tool": "def calculate_area_of_square(side_length):\n    \n    return side_length**2", "subfield": "Coordinate Geometry", "tool_name": "calculate_area_of_square", "tool_type": "function", "description": "Calculate the area of a square given the side length.", "docstring": "Calculate the area of a square given the side length.\n    \n    Parameters:\n        side_length (float or sympy expression): The length of the side of the square.\n    \n    Returns:\n        float or sympy expression: The area of the square.\n    Example:\n        area = calculate_area_of_square(5)\n        print(area)  # Output: 25", "Freq": 9, "TSR": 7, "experience_pool": "The side length of the square AE should be calculated as side_length_BE * sqrt(2) since AE is the diagonal of the square ABCD.\nThe sum_of_areas should be calculated as (area_AB + area_AE)**2."}, {"tool": "def calculate_area(shape, *args):\n    \n    if shape == 'circle':\n        radius = args[0]\n        return math.pi * radius**2\n    elif shape == 'rectangle':\n        length = args[0]\n        width = args[1]\n        return length * width\n    elif shape == 'triangle':\n        base = args[0]\n        height = args[1]\n        return 0.5 * base * height\n    else:\n        return \"Invalid shape\"", "subfield": "Coordinate Geometry", "tool_name": "calculate_area", "tool_type": "function", "description": "Calculates the area of a geometric shape.", "docstring": "Calculates the area of a geometric shape.\n    Parameters:\n    shape (str): The shape of the object ('circle', 'rectangle', 'triangle', etc.)\n    *args: Variable length arguments depending on the shape. For example, for a circle, pass the radius as the argument.\n    Returns:\n    float: The area of the geometric shape.", "Freq": 8.5, "TSR": 5, "experience_pool": "- Experience 1:\n    - Field: Geometry\n    - Subfield: Coordinate Geometry\n    - Tool Usage Frequency: 3\n    - Tool Success Rate: 66.66666666666666%\n    - Tool docstring: Calculates the area of a circle given its radius.\n    - Tool code:\n        ```python\n        def circle_area(radius):\n            return np.pi * radius**2\n        ```\n    - Problem: The graph of \\(r = -2 \\cos \\theta + 6 \\sin \\theta\\) is a circle. Find the area of the circle.\n    - Answer: 10 \\pi\n    - Solution:\n        ```python\n        from sympy import Symbol, sqrt\n\n        def solution():\n            # Calculate the radius of the circle\n            r = sqrt(10) / 2\n\n            # Calculate the area of the circle\n            area_circle = calculate_area('circle', r)\n\n            return area_circle\n\n        # Print the result\n        print(solution())\n        ```\n    - Output: 7.85398163397448"}, {"tool": "def vector_add(v1, v2):\n    \n    return np.add(v1, v2)", "subfield": "Coordinate Geometry", "tool_name": "vector_add", "tool_type": "function", "description": "Adds two vectors.", "docstring": "Adds two vectors.\n    Parameters:\n    v1 (ndarray): A numpy array representing the first vector.\n    v2 (ndarray): A numpy array representing the second vector.\n    Returns:\n    ndarray: The vector sum of v1 and v2.", "Freq": 0, "TSR": 0}, {"tool": "def circle_equation(h, k, r):\n    \n    return f\"(x - {h})^2 + (y - {k})^2 = {r}^2\"", "subfield": "Coordinate Geometry", "tool_name": "circle_equation", "tool_type": "function", "description": "Returns the standard form equation of a circle given the center (h, k) and radius r.", "docstring": "Returns the standard form equation of a circle given the center (h, k) and radius r.\n    Parameters:\n    h (float): The x-coordinate of the center.\n    k (float): The y-coordinate of the center.\n    r (float): The radius of the circle.\n    Returns:\n    str: The equation of the circle in standard form.\n    Examples:\n    >>> circle_equation(0, 0, 1)\n    '(x - 0)^2 + (y - 0)^2 = 1^2'", "Freq": 0, "TSR": 0}, {"tool": "def line_equation_from_point_slope(point, slope):\n    \n    x, y = point\n    c = y - slope * x\n    return slope, c", "subfield": "Coordinate Geometry", "tool_name": "line_equation_from_point_slope", "tool_type": "function", "description": "Find the equation of a line in slope-intercept form 'y = mx + c' given a point and a slope.", "docstring": "Find the equation of a line in slope-intercept form 'y = mx + c' given a point and a slope.\n    \n    Parameters:\n    - point (tuple): Point (x, y) through which the line passes.\n    - slope (float): Slope of the line.\n    \n    Returns:\n    - tuple: slope m and intercept c of the line 'y = mx + c'.\n    \n    Examples:\n    >>> line_equation_from_point_slope((1, 2), 3)\n    (3, -1)", "Freq": 10, "TSR": 7, "experience_pool": "Experience 1:\nProblem: Find the equation of a line passing through the points (2, 3) and (4, 5).\nSolution: We can use the line_equation_from_point_slope function to find the equation of the line.\n```python\npoint1 = (2, 3)\npoint2 = (4, 5)\nslope = (point2[1] - point1[1]) / (point2[0] - point1[0])\nequation = line_equation_from_point_slope(point1, slope)\nprint(equation)\n```\nOutput: (1, 1)\n\nExperience 2:\nProblem: Find the equation of a line passing through the points (-1, 2) and (3, 4).\nSolution: We can use the line_equation_from_point_slope function to find the equation of the line.\n```python\npoint1 = (-1, 2)\npoint2 = (3, 4)\nslope = (point2[1] - point1[1]) / (point2[0] - point1[0])\nequation = line_equation_from_point_slope(point1, slope)\nprint(equation)\n```\nOutput: (0.5, 2.5)"}, {"tool": "def vector_subtract(v1, v2):\n    \n    return np.subtract(v1, v2)", "subfield": "Coordinate Geometry", "tool_name": "vector_subtract", "tool_type": "function", "description": "Subtracts the second vector from the first.", "docstring": "Subtracts the second vector from the first.\n    Parameters:\n    v1 (ndarray): A numpy array representing the first vector.\n    v2 (ndarray): A numpy array representing the second vector.\n    Returns:\n    ndarray: The vector result of v1 - v2.", "Freq": 1, "TSR": 0}, {"tool": "def midpoint(point1, point2):\n    \n    return (np.array(point1) + np.array(point2)) / 2", "subfield": "Coordinate Geometry", "tool_name": "midpoint", "tool_type": "function", "description": "Calculate the midpoint between two points in n-dimensional space.", "docstring": "Calculate the midpoint between two points in n-dimensional space.\n    Parameters:\n        point1 (array-like): The first point coordinates.\n        point2 (array-like): The second point coordinates.\n    Returns:\n        ndarray: The coordinates of the midpoint.\n    Examples:\n        >>> midpoint([1, 2], [3, 4])\n        array([2., 3.])", "Freq": 1, "TSR": 0}, {"tool": "def point_line_position(point, line):\n    \n    x, y = point\n    m, c = line\n    line_y = m * x + c\n    if y > line_y:\n        return 'above'\n    elif y < line_y:\n        return 'below'\n    else:\n        return 'on'", "subfield": "Coordinate Geometry", "tool_name": "point_line_position", "tool_type": "function", "description": "Determine the relative position of a point with respect to a line.", "docstring": "Determine the relative position of a point with respect to a line.\n    \n    Parameters:\n    - point (tuple): The point (x, y).\n    - line (tuple): The slope and intercept (m, c) of the line.\n    \n    Returns:\n    - str: 'above', 'below' or 'on' the line\n    \n    Examples:\n    >>> point_line_position((3, 4), (1, 1))\n    'above'", "Freq": 1, "TSR": 1}, {"tool": "def vector_from_points(point1, point2):\n    \n    return np.array(point2) - np.array(point1)", "subfield": "Coordinate Geometry", "tool_name": "vector_from_points", "tool_type": "function", "description": "Calculate the vector from point1 to point2 in 3D.", "docstring": "Calculate the vector from point1 to point2 in 3D.\n    \n    Parameters:\n    - point1 (array-like): Coordinates of the first point.\n    - point2 (array-like): Coordinates of the second point.\n    \n    Returns:\n    - numpy.ndarray: The vector from point1 to point2.\n    \n    Example:\n    >>> vector_from_points([1, 2, 3], [4, 5, 6])\n    array([3, 3, 3])", "Freq": 2, "TSR": 2}, {"tool": "def circle_equation(center, radius):\n    \n    x, y = symbols('x y')\n    x0, y0 = center\n    return Eq((x - x0)**2 + (y - y0)**2, radius**2)", "subfield": "Coordinate Geometry", "tool_name": "circle_equation", "tool_type": "function", "description": "Generate the equation of a circle given the center and radius.", "docstring": "Generate the equation of a circle given the center and radius.\n    Parameters:\n        center (tuple): Coordinates of the center of the circle (x, y).\n        radius (float): The radius of the circle.\n    Returns:\n        sympy.Eq: The equation of the circle.\n    Examples:\n        >>> circle_equation((0, 0), 5)\n        Eq(x**2 + y**2, 25)", "Freq": 0, "TSR": 0}, {"tool": "def square_side_from_diagonal(diagonal):\n    \n    return diagonal / np.sqrt(2)", "subfield": "Coordinate Geometry", "tool_name": "square_side_from_diagonal", "tool_type": "function", "description": "Calculate the side length of a square given the diagonal, using the Pythagorean theorem.", "docstring": "Calculate the side length of a square given the diagonal, using the Pythagorean theorem.\n    Parameters:\n    diagonal (float): The length of the diagonal of the square.\n    Returns:\n    float: The length of one side of the square.\n    Examples:\n    >>> square_side_from_diagonal(5.656854249492381)\n    4.0", "Freq": 0, "TSR": 0}, {"tool": "def vector_magnitude(vector):\n    \n    return np.linalg.norm(vector)", "subfield": "Coordinate Geometry", "tool_name": "vector_magnitude", "tool_type": "function", "description": "Calculates the magnitude (norm) of a vector.", "docstring": "Calculates the magnitude (norm) of a vector.\n    Parameters:\n    vector (ndarray): The vector whose magnitude is to be calculated.\n    Returns:\n    float: The magnitude of the vector.", "Freq": 0, "TSR": 0}, {"tool": "def parametric_point_evaluation(param_eqs, t_values):\n    \n    results = []\n    for t_value in t_values:\n        point = {var: eq.subs('t', t_value) for var, eq in param_eqs.items()}\n        results.append(point)\n    return results", "subfield": "Coordinate Geometry", "tool_name": "parametric_point_evaluation", "tool_type": "function", "description": "Evaluate parametric equations at given parameter values.", "docstring": "Evaluate parametric equations at given parameter values.\n    \n    Parameters:\n        param_eqs (dict): A dictionary with variables as keys and their parametric equations as values.\n        t_values (list or scalar): A scalar or list of values to substitute into the parametric equations.\n    \n    Returns:\n        list or dict: Evaluated points at each parameter value.\n    \n    Example:\n        x, y, t = symbols('x y t')\n        param_eqs = {x: t**2, y: t + 1}\n        points = parametric_point_evaluation(param_eqs, [0, 1, 2])\n        print(points)  # Output: [{x: 0, y: 1}, {x: 1, y: 2}, {x: 4, y: 3}]", "Freq": 0, "TSR": 0}, {"tool": "def solve_linear_equations(A, b):\n    \n    try:\n        A = np.array(A)\n        b = np.array(b)\n        x = np.linalg.solve(A, b)\n        return x\n    except np.linalg.LinAlgError:\n        return \"Singular matrix\"", "subfield": "Coordinate Geometry", "tool_name": "solve_linear_equations", "tool_type": "function", "description": "Solve a system of linear equations Ax = b for x using NumPy.", "docstring": "Solve a system of linear equations Ax = b for x using NumPy.\n    Parameters:\n    - A (array-like): coefficient matrix.\n    - b (array-like): constant terms.\n    Returns:\n    - array: solution vector x.", "Freq": 3, "TSR": 1, "experience_pool": "- Problem: In triangle $ABC,$ $D$ lies on $\\overline{BC}$ extended past $C$ such that $BD:DC = 3:1,$ and $E$ lies on $\\overline{AC}$ such that $AE:EC = 5:3.$  Let $P$ be the intersection of lines $BE$ and $AD.$\n\n[asy]\nunitsize(0.8 cm);\n\npair A, B, C, D, E, F, P;\n\nA = (1,4);\nB = (0,0);\nC = (6,0);\nD = interp(B,C,3/2);\nE = interp(A,C,5/8);\nP = extension(A,D,B,E);\n\ndraw(A--B--C--cycle);\ndraw(A--D--C);\ndraw(B--P);\n\nlabel(\"$A$\", A, N);\nlabel(\"$B$\", B, SW);\nlabel(\"$C$\", C, S);\nlabel(\"$D$\", D, SE);\nlabel(\"$E$\", E, S);\nlabel(\"$P$\", P, NE);\n[/asy]\n\nThen\n\\[\\overrightarrow{P} = x \\overrightarrow{A} + y \\overrightarrow{B} + z \\overrightarrow{C},\\]where $x,$ $y,$ and $z$ are constants such that $x + y + z = 1.$  Enter the ordered triple $(x,y,z).$\nAnswer: \\left( \\frac{9}{19}, -\\frac{5}{19}, \\frac{15}{19} \\right)\n\n- Problem: For certain ordered pairs $(a,b)\\,$ of real numbers, the system of equations\n\\[\\begin{aligned} ax+by&=1 \\\\ x^2 + y^2 &= 50  \\end{aligned}\\]has at least one solution, and each solution is an ordered pair $(x,y)\\,$ of integers. How many such ordered pairs $(a,b)\\,$ are there?\nAnswer: 72"}, {"tool": "def point_on_line(line, point):\n    \n    m, c = line\n    x, y = point\n    return y == m * x + c", "subfield": "Coordinate Geometry", "tool_name": "point_on_line", "tool_type": "function", "description": "Determines whether a given point lies on a specified line.", "docstring": "Determines whether a given point lies on a specified line.\n    Parameters\n    ----------\n    line : tuple\n        Coefficients (m, c) of the line equation y = mx + c.\n    point : tuple\n        Coordinates of the point (x, y).\n    \n    Returns\n    -------\n    bool\n        True if the point lies on the line, False otherwise.\n    \n    Examples\n    --------\n    >>> point_on_line((2, 1), (1, 3))\n    True", "Freq": 0, "TSR": 0}, {"tool": "def reflection_point_across_line(line, point):\n    \n    m, c = line\n    x, y = point\n    d = (x + (y - c) * m) / (1 + m**2)\n    x_ref = 2*d - x\n    y_ref = 2*d*m - y + 2*c\n    return (x_ref, y_ref)", "subfield": "Coordinate Geometry", "tool_name": "reflection_point_across_line", "tool_type": "function", "description": "Finds the reflection of a point across a given line.", "docstring": "Finds the reflection of a point across a given line.\n    Parameters\n    ----------\n    line : tuple\n        Coefficients (m, c) of the line equation y = mx + c.\n    point : tuple\n        Coordinates of the point (x, y).\n    Returns\n    -------\n    tuple\n        Coordinates (x', y') of the reflected point.\n    Examples\n    --------\n    >>> reflection_point_across_line((1, 1), (2, 3))\n    (-1.0, 0.0)", "Freq": 2, "TSR": 1, "experience_pool": "- Experience 1:\n    - Problem: The reflect function is being used, which is not defined in the original tool code.\n    - Solution: Add a new reflect function to the tool code.\n- Experience 2:\n    - Problem: The line_translation parameter is being passed as a tuple (1, 0) to the reflection_point_across_line function, which expects the line equation coefficients (m, c).\n    - Solution: Update the code to handle the line_translation parameter correctly."}, {"tool": "def compute_conic_properties(eq_type, standard_params):\n    \n    import math\n    if eq_type == 'circle':\n        center = standard_params['center']\n        radius = standard_params['radius']\n        return {'center': center, 'foci': [center, center], 'radius': radius}\n    elif eq_type == 'ellipse':\n        # Calculate foci, vertices based on semi-major/minor axes.\n        pass\n    elif eq_type == 'parabola':\n        # Vertex, focus calculation.\n        pass\n    elif eq_type == 'hyperbola':\n        # Center, foci, vertices, and asymptotes.\n        pass\n    return {}", "subfield": "Coordinate Geometry", "tool_name": "compute_conic_properties", "tool_type": "function", "description": "Compute geometric properties such as center, foci, vertices, depending on the conic type.", "docstring": "Compute geometric properties such as center, foci, vertices, depending on the conic type.\n    Parameters:\n    - eq_type (str): Type of conic ('circle', 'ellipse', 'parabola', 'hyperbola').\n    - standard_params (dict): Parameters obtained from the standard form conversion.\n    Returns:\n    - dict: Detailed conic properties.\n    Example:\n    >>> compute_conic_properties('circle', {'center': (3, -2), 'radius': 4})\n    {'center': (3, -2), 'foci': [(3, -2), (3, -2)], 'radius': 4}", "Freq": 3, "TSR": 0}, {"tool": "def rectangle_properties(length, width):\n    \n    import math\n    perimeter = 2 * (length + width)\n    area = length * width\n    diagonal = math.sqrt(length**2 + width**2)\n    return {'perimeter': perimeter, 'area': area, 'diagonal': diagonal}", "subfield": "Coordinate Geometry", "tool_name": "rectangle_properties", "tool_type": "function", "description": "Calculate various properties of a rectangle given its length and width.", "docstring": "Calculate various properties of a rectangle given its length and width.\n    Parameters:\n    - length (float): The length of the rectangle.\n    - width (float): The width of the rectangle.\n    Returns:\n    - dict: Dictionary containing the perimeter, area, and diagonal of the rectangle.\n    Examples:\n    >>> rectangle_properties(4, 3)\n    {'perimeter': 14, 'area': 12, 'diagonal': 5.0}", "Freq": 0, "TSR": 0}, {"tool": "def circle_equation(cartesian_point_hk, radius):\n    \n    h, k = cartesian_point_hk\n    def equation(x, y):\n        return (x - h)**2 + (y - k)**2 - radius**2\n    return equation", "subfield": "Coordinate Geometry", "tool_name": "circle_equation", "tool_type": "function", "description": "Provides the equation of a circle in Cartesian coordinates.", "docstring": "Provides the equation of a circle in Cartesian coordinates.\n    Parameters:\n    cartesian_point_hk (tuple): (h, k) the center of the circle in Cartesian coordinates\n    radius (float): the radius of the circle\n    Returns:\n    function: Function that calculates (x - h)² + (y - k)² - r² for given x, y", "Freq": 1, "TSR": 1}, {"tool": "def distance(x1, y1, x2, y2):\n    \n    return sp.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2)", "subfield": "Coordinate Geometry", "tool_name": "distance", "tool_type": "function", "description": "Calculate the Euclidean distance between two points (x1, y1) and (x2, y2).", "docstring": "Calculate the Euclidean distance between two points (x1, y1) and (x2, y2).\n    \n    Parameters:\n        x1, y1, x2, y2 (float): Coordinates of the two points.\n        \n    Returns:\n        float: The distance between the two points.", "Freq": 0, "TSR": 0}, {"tool": "def area_of_circle(r):\n    \n    return np.pi * r**2", "subfield": "Coordinate Geometry", "tool_name": "area_of_circle", "tool_type": "function", "description": "Calculates the area of a circle given its radius.", "docstring": "Calculates the area of a circle given its radius.\n    Parameters:\n    r (float): The radius of the circle.\n    Returns:\n    float: The area of the circle.\n    Examples:\n    >>> area_of_circle(1)\n    3.141592653589793", "Freq": 2, "TSR": 2}, {"tool": "def is_collinear(points):\n    \n    if len(points) < 3:\n        return True  # Two points are always collinear\n    x1, y1 = points[0]\n    x2, y2 = points[1]\n    for (x, y) in points[2:]:\n        if (x2 - x1) * (y - y1) != (y2 - y1) * (x - x1):\n            return False\n    return True", "subfield": "Coordinate Geometry", "tool_name": "is_collinear", "tool_type": "function", "description": "Check if all points given are collinear.", "docstring": "Check if all points given are collinear.\n    \n    Parameters:\n    - points (list of tuples): List of points (x, y) to be checked.\n    \n    Returns:\n    - bool: True if all points are collinear, False otherwise.\n    Example:\n    >>> is_collinear([(1, 2), (2, 4), (3, 6)])\n    True", "Freq": 1, "TSR": 0}, {"tool": "def transform_coordinates(points, transformation_matrix):\n    \n    transformed = np.dot(transformation_matrix, np.array(points).T).T\n    return [tuple(point) for point in transformed]", "subfield": "Coordinate Geometry", "tool_name": "transform_coordinates", "tool_type": "function", "description": "Applies a transformation matrix to a list of point coordinates in 2D.", "docstring": "Applies a transformation matrix to a list of point coordinates in 2D.\n    Parameters:\n    - points: List of tuples representing the point coordinates.\n    - transformation_matrix: A 2x2 numpy array representing the transformation matrix.\n    Returns:\n    - List of tuples: New coordinates after transformation.\n    Example:\n    >>> transform_coordinates([(1, 2)], np.array([[2, 0], [0, 2]]))\n    [(2, 4)]", "Freq": 0, "TSR": 0}, {"tool": "def scalar_multiply(vector, scalar):\n    \n    return np.multiply(vector, scalar)", "subfield": "Coordinate Geometry", "tool_name": "scalar_multiply", "tool_type": "function", "description": "Multiplies a vector by a scalar.", "docstring": "Multiplies a vector by a scalar.\n    Parameters:\n    vector (ndarray): A numpy array representing the vector.\n    scalar (float): The scalar value to multiply with the vector.\n    Returns:\n    ndarray: The scaled vector.", "Freq": 0, "TSR": 0}, {"tool": "def get_line_equation(p1, p2):\n    \n    x1, y1 = p1\n    x2, y2 = p2\n    A = y2 - y1\n    B = x1 - x2\n    C = x2 * y1 - x1 * y2\n    return (A, B, C)", "subfield": "Coordinate Geometry", "tool_name": "get_line_equation", "tool_type": "function", "description": "Calculate the coefficients (A, B, C) of the line equation Ax + By + C = 0 passing through two points.", "docstring": "Calculate the coefficients (A, B, C) of the line equation Ax + By + C = 0 passing through two points.\n    Parameters:\n    - p1 (tuple): coordinates of the first point.\n    - p2 (tuple): coordinates of the second point.\n    Returns:\n    - tuple: coefficients (A, B, C) of the line.\n    Examples:\n    >>> get_line_equation((1, 2), (3, 4))\n    (2, -2, 0)", "Freq": 3, "TSR": 1}, {"tool": "class Point:\n    \"\"\"\n    This class represents a Point in 2D geometry.\n    \n    Attributes:\n        x (float): x-coordinate of the Point.\n        y (float): y-coordinate of the Point.\n    \"\"\"\n    \n    def __init__(self, x=0.0, y=0.0):\n        \"\"\"\n        The constructor for the Point class. It initializes the x and y coordinates of the point.\n        \n        Parameters:\n            x (float): The x-coordinate of the point.\n            y (float): The y-coordinate of the point.\n        \"\"\"\n        self.x = x\n        self.y = y\n    def __str__(self):\n        \"\"\"\n        This method returns the string representation of the Point.\n        \n        Returns:\n            str: A string in the format '(x, y)'.\n        \"\"\"\n        return '(' + str(self.x) + ', ' + str(self.y) + ')'\n    \n    def distance(self, other):\n        \"\"\"\n        This method calculates the Euclidean distance between this Point and another Point.\n        \n        Parameters:\n            other (Point): The other Point.\n            \n        Returns:\n            float: The Euclidean distance between the two points.\n        \"\"\"\n        return np.sqrt((self.x - other.x)**2 + (self.y - other.y)**2)", "subfield": "Coordinate Geometry", "tool_name": "Point:\n    \"\"\"\n    This class represents a Point in 2D geometry.\n    \n    Attributes:\n        x", "tool_type": "class", "description": "This class represents a Point in 2D geometry.\n    \n    Attributes:\n        x (float): x-coordinate of the Point.\n        y (float): y-coordinate of the Point.", "docstring": "This class represents a Point in 2D geometry.\n    \n    Attributes:\n        x (float): x-coordinate of the Point.\n        y (float): y-coordinate of the Point.", "Freq": 0, "TSR": 0}, {"tool": "def complete_square(expression, variable):\n    \n    a = expression.coeff(variable**2)\n    b = expression.coeff(variable)\n    completed_square = a * (variable + b/(2*a))**2 - (b**2)/(4*a)\n    return completed_square", "subfield": "Coordinate Geometry", "tool_name": "complete_square", "tool_type": "function", "description": "Complete the square for the given variable in a SymPy expression.", "docstring": "Complete the square for the given variable in a SymPy expression.", "Freq": 0, "TSR": 0}, {"tool": "def distance_point_plane(point, plane_coefficients):\n    \n    A, B, C, D = plane_coefficients\n    x, y, z = point\n    num = abs(A*x + B*y + C*z + D)\n    den = np.sqrt(A**2 + B**2 + C**2)\n    return num / den", "subfield": "Coordinate Geometry", "tool_name": "distance_point_plane", "tool_type": "function", "description": "Calculate the shortest distance from a point to a plane in 3D.", "docstring": "Calculate the shortest distance from a point to a plane in 3D.\n    \n    Parameters:\n    - point (array-like): The coordinates of the point.\n    - plane_coefficients (tuple): The coefficients (A, B, C, D) of the plane Ax + By + Cz + D = 0.\n    \n    Returns:\n    - float: The shortest distance from the point to the plane.\n    \n    Example:\n    >>> distance_point_plane([1, 2, 2], (1, 0, 0, -2))\n    1.0", "Freq": 2, "TSR": 0}, {"tool": "def distance_constraints_2d(points, distance):\n    \n    x, y = symbols('x y', real=True)\n    generated_eqs = []\n    for p1, p2 in zip(points, points[1:] + [points[0]]):\n        eq = Eq((x - p1[0]) ** 2 + (y - p1[1]) ** 2, distance ** 2)\n        generated_eqs.append(eq)\n    return generated_eqs", "subfield": "Coordinate Geometry", "tool_name": "distance_constraints_2d", "tool_type": "function", "description": "Formulate and solve a system of equations given distance constraints between multiple points in 2D.", "docstring": "Formulate and solve a system of equations given distance constraints between multiple points in 2D.\n    Parameters:\n    - points (list): List of tuples/lists where each tuple/list contains the (x, y) coordinates.\n    - distance (float): The distance that each pair of points should satisfy.\n    Returns:\n    - list: A list of sympy Eq objects expressing the distance constraints.\n    Examples:", "Freq": 0, "TSR": 0}, {"tool": "def solve_linear_system(coeff_matrix, const_vector):\n    \n    coeff_matrix = np.array(coeff_matrix)\n    const_vector = np.array(const_vector)\n    return np.linalg.solve(coeff_matrix, const_vector)", "subfield": "Coordinate Geometry", "tool_name": "solve_linear_system", "tool_type": "function", "description": "Solves a linear system of equations defined by a matrix of coefficients and a constant vector.", "docstring": "Solves a linear system of equations defined by a matrix of coefficients and a constant vector.\n    Parameters:\n    - coeff_matrix (list[list[float]]): Coefficient matrix where each row represents the coefficients of a linear equation.\n    - const_vector (list[float]): Constant terms for each equation.\n    Returns:\n    - ndarray: Solution to the system of equations.\n    Examples:\n    >>> solve_linear_system([[1, 1], [1, -1]], [5, 1])\n    array([3., 2.])", "Freq": 1, "TSR": 0}, {"tool": "def find_perpendicular_slope(slope):\n    \n    return -1 / slope", "subfield": "Coordinate Geometry", "tool_name": "find_perpendicular_slope", "tool_type": "function", "description": "Calculates the slope of a line perpendicular to a given slope.", "docstring": "Calculates the slope of a line perpendicular to a given slope.\n    \n    Parameters\n    ----------\n    slope : float\n        Slope of the given line.\n    \n    Returns\n    -------\n    float\n        Slope of the perpendicular line.\n    \n    Examples\n    --------\n    >>> find_perpendicular_slope(2)\n    -0.5", "Freq": 2, "TSR": 1}, {"tool": "class GeometryUtils:\n    \"\"\"\n    This class provides a set of utility functions for solving geometry problems.\n    \"\"\"\n    \n    def __init__(self):\n        pass\n    \n    def line_equation_from_two_points(self, point1, point2):\n        \"\"\"\n        This function calculates the equation of a line passing through two given points.\n        \n        Parameters:\n            point1 (tuple): The coordinates of the first point (x1, y1).\n            point2 (tuple): The coordinates of the second point (x2, y2).\n            \n        Returns:\n            tuple: The slope and y-intercept of the line in the form (m, c).\n        \"\"\"\n        x1, y1 = point1\n        x2, y2 = point2\n        slope = (y2 - y1) / (x2 - x1)\n        intercept = y1 - slope * x1\n        return slope, intercept\n    \n    def solve_linear_equations(self, coeff_matrix, const_vector):\n        \"\"\"\n        This function solves a system of linear equations defined by a matrix of coefficients and a constant vector.\n        \n        Parameters:\n            coeff_matrix (list): A list of lists representing the matrix of coefficients.\n            const_vector (list): A list representing the constant vector.\n            \n        Returns:\n            list: A list of solutions to the system of linear equations.\n        \"\"\"\n        coeff_matrix = np.array(coeff_matrix)\n        const_vector = np.array(const_vector)\n        solutions = np.linalg.solve(coeff_matrix, const_vector)\n        return solutions\n    \n    def distance_between_points(self, point1, point2):\n        \"\"\"\n        This function calculates the Euclidean distance between two points in a 2D coordinate system.\n        \n        Parameters:\n            point1 (tuple): The coordinates of the first point (x1, y1).\n            point2 (tuple): The coordinates of the second point (x2, y2).\n            \n        Returns:\n            float: The Euclidean distance between the two points.\n        \"\"\"\n        x1, y1 = point1\n        x2, y2 = point2\n        distance = np.sqrt((x2 - x1)**2 + (y2 - y1)**2)\n        return distance\n    \n    def line_intersection(self, line1, line2):\n        \"\"\"\n        This function calculates the intersection point of two lines in a 2D coordinate system.\n        \n        Parameters:\n            line1 (tuple): The equation of the first line in the form (m1, c1).\n            line2 (tuple): The equation of the second line in the form (m2, c2).\n            \n        Returns:\n            tuple: The coordinates of the intersection point (x, y).\n        \"\"\"\n        m1, c1 = line1\n        m2, c2 = line2\n        x = (c2 - c1) / (m1 - m2)\n        y = m1 * x + c1\n        return x, y", "subfield": "Coordinate Geometry", "tool_name": "GeometryUtils:\n    \"\"\"\n    This class provides a set of utility functions for solving geometry problems.\n    \"\"\"\n    \n    def __init__", "tool_type": "class", "description": "This class provides a set of utility functions for solving geometry problems.", "docstring": "This class provides a set of utility functions for solving geometry problems.", "Freq": 0, "TSR": 0}], "Rectangles": [{"tool": "def rectangle_area(length, width):\n    \n    return length * width", "subfield": "Rectangles", "tool_name": "rectangle_area", "tool_type": "function", "description": "Calculate the area of a rectangle.", "docstring": "Calculate the area of a rectangle.\n    Parameters:\n    length (float): the length of the rectangle.\n    width (float): the width of the rectangle.\n    Returns:\n    float: the calculated area of the rectangle.\n    \n    Example:\n    >>> rectangle_area(5, 3)\n    15", "Freq": 2, "TSR": 1}, {"tool": "def rectangle_diagonal(length, width):\n    \n    return math.sqrt(length**2 + width**2)", "subfield": "Rectangles", "tool_name": "rectangle_diagonal", "tool_type": "function", "description": "Calculates the length of the diagonal of a rectangle using Pythagoras' theorem.", "docstring": "Calculates the length of the diagonal of a rectangle using Pythagoras' theorem.\n    \n    Parameters:\n        length (float): The length of the rectangle.\n        width (float): The width of the rectangle.\n        \n    Returns:\n        float: The length of the diagonal.\n        \n    Examples:\n    >>> rectangle_diagonal(5, 4)\n    6.4031242374328485", "Freq": 2, "TSR": 0}, {"tool": "def calculate_square_perimeter(side_length):\n    \n    return 4 * side_length", "subfield": "Rectangles", "tool_name": "calculate_square_perimeter", "tool_type": "function", "description": "Calculate the perimeter of a square given the side length.", "docstring": "Calculate the perimeter of a square given the side length.\n    \n    Parameters:\n    side_length (float): The length of a side of the square.\n    \n    Returns:\n    float: The perimeter of the square.", "Freq": 3, "TSR": 2, "experience_pool": "- Experience 1:\n    - Problem: The area of a square plot of land is 325 square meters. What is the perimeter of the square, in meters? Express your answer in simplest radical form.\n    - Solution: \n        ```python\n        import math\n\n        def solution():\n            \"\"\"The area of a square plot of land is 325 square meters. What is the perimeter of the square, in meters?\"\"\"\n            area = 325\n            side_length = math.sqrt(area)\n            perimeter = calculate_square_perimeter(side_length)\n            return perimeter\n\n        # Calculate the perimeter of the square\n        print(solution())\n        ```\n    - Output: 72.11102550927978\n    - Feedback: The tool accurately calculates the perimeter of the square."}, {"tool": "def solve_rectangle_dimensions(perimeter, area=None, aspect_ratio=None, use_integers=False):\n    \n    import sympy\n    \n    length, width = sympy.symbols('length width')\n    eq1 = sympy.Eq(2 * (length + width), perimeter)\n    \n    solutions = []\n    \n    if area is not None:\n        eq2 = sympy.Eq(length * width, area)\n        sol = sympy.solve((eq1, eq2), (length, width))\n        solutions.extend(sol)\n    \n    if aspect_ratio is not None:\n        eq2 = sympy.Eq(length / width, aspect_ratio)\n        sol = sympy.solve((eq1, eq2), (length, width))\n        solutions.extend(sol)\n    \n    if not solutions:\n        solutions = sympy.solve(eq1, (length, width))\n    \n    # Filter for integer solutions if requested\n    if use_integers:\n        solutions = [(l, w) for l, w in solutions if l.is_integer and w.is_integer]\n    return solutions", "subfield": "Rectangles", "tool_name": "solve_rectangle_dimensions", "tool_type": "function", "description": "Solves for dimensions of a rectangle given constraints like perimeter, area or aspect ratio.", "docstring": "Solves for dimensions of a rectangle given constraints like perimeter, area or aspect ratio.\n    Parameters:\n    perimeter (float): The perimeter of the rectangle.\n    area (float, optional): The area of the rectangle.\n    aspect_ratio (float, optional): The ratio of length to width.\n    use_integers (bool, optional): If True, returns integer dimensions. Default is False.\n    Returns:\n    list of tuples: Possible (length, width) combinations.\n    \n    Examples:\n    >>> solve_rectangle_dimensions(20, area=24)\n    [(6, 4), (4, 6)]\n    >>> solve_rectangle_dimensions(20, aspect_ratio=1.5)\n    [(7.5, 5), (5, 7.5)]", "Freq": 15, "TSR": 4}, {"tool": "def calculate_shaded_area(length, width, shaded_length, shaded_width):\n    \n    rectangle_area = length * width\n    shaded_area = shaded_length * shaded_width\n    return rectangle_area - shaded_area", "subfield": "Rectangles", "tool_name": "calculate_shaded_area", "tool_type": "function", "description": "Calculate the area of a shaded region in a rectangle.\n    \n    Args:\n    length (float): The length of the rectangle.\n    width (float): The width of the rectangle.\n    shaded_length (float): The length of the shaded region.\n    shaded_width (float): The width of the shaded region.\n    \n    Returns:\n    float: The area of the shaded region.", "docstring": "Calculate the area of a shaded region in a rectangle.\n    \n    Args:\n    length (float): The length of the rectangle.\n    width (float): The width of the rectangle.\n    shaded_length (float): The length of the shaded region.\n    shaded_width (float): The width of the shaded region.\n    \n    Returns:\n    float: The area of the shaded region.", "Freq": 1, "TSR": 0}], "Midpoint Formula": [{"tool": "def compute_midpoint(point1, point2):\n    \n    # Ensure input is in the correct format and same dimension\n    if len(point1) != len(point2):\n        raise ValueError(\"Both points must have the same number of dimensions\")\n    # Calculate midpoint using tuple/list comprehension\n    midpoint = tuple((p1 + p2) / 2 for p1, p2 in zip(point1, point2))\n    \n    return midpoint", "subfield": "Midpoint Formula", "tool_name": "compute_midpoint", "tool_type": "function", "description": "Compute the midpoint between two points in n-dimensional space.", "docstring": "Compute the midpoint between two points in n-dimensional space.\n    Parameters:\n    point1 (tuple or list): Coordinates of the first point.\n    point2 (tuple or list): Coordinates of the second point.\n    Returns:\n    tuple: Coordinates of the midpoint.\n    Examples:\n    >>> compute_midpoint((1, 2), (3, 4))\n    (2.0, 3.0)\n    >>> compute_midpoint([0, 0, 0], [6, 8, 10])\n    (3.0, 4.0, 5.0)\n    Raises:\n    ValueError: If the dimensions of the two points are not equal.", "Freq": 14, "TSR": 13, "experience_pool": "- To calculate the value of b using the midpoint and one of the endpoints, you can directly access the coordinates of the midpoint tuple and add them together. There is no need to use the non-existent function find_endpoint_from_midpoint.\n\nExample:\nmidpoint = compute_midpoint((1, 3), (5, 7))\nb = midpoint[0] + midpoint[1]"}, {"tool": "def find_endpoint_from_midpoint(midpoint, known_point):\n    \n    import numpy as np\n    midpoint, known_point = np.array(midpoint), np.array(known_point)\n    unknown_point = 2 * midpoint - known_point\n    return unknown_point.tolist()", "subfield": "Midpoint Formula", "tool_name": "find_endpoint_from_midpoint", "tool_type": "function", "description": "Calculate the unknown endpoint of a line segment given the midpoint and the known endpoint.", "docstring": "Calculate the unknown endpoint of a line segment given the midpoint and the known endpoint.\n    Parameters:\n        midpoint (list or tuple of floats): Coordinates of the midpoint.\n        known_point (list or tuple of floats): Coordinates of the known endpoint.\n    Returns:\n        list: The coordinates of the unknown endpoint as a list of floats.\n    \n    Examples:\n        >>> find_endpoint_from_midpoint([1.0, 1.0], [0, 0])\n        [2.0, 2.0]\n        >>> find_endpoint_from_midpoint([4.0, 7.0, 9.0], [1, 3, 5])\n        [7.0, 11.0, 13.0]", "Freq": 6, "TSR": 4, "experience_pool": "experience content"}, {"tool": "def compute_distance(point1, point2):\n    \n    import math\n    \n    # Ensure input is in the correct format and same dimension\n    if len(point1) != len(point2):\n        raise ValueError(\"Both points must have the same number of dimensions\")\n    \n    # Calculate the squared difference between each coordinate\n    squared_diff = [(p1 - p2) ** 2 for p1, p2 in zip(point1, point2)]\n    \n    # Sum the squared differences and take the square root\n    distance = math.sqrt(sum(squared_diff))\n    \n    return distance", "subfield": "Midpoint Formula", "tool_name": "compute_distance", "tool_type": "function", "description": "Compute the Euclidean distance between two points in n-dimensional space.\n    \n    Args:\n        point1 (tuple or list): The coordinates of the first point.\n        point2 (tuple or list): The coordinates of the second point.\n        \n    Returns:\n        float: The Euclidean distance between the two points.", "docstring": "Compute the Euclidean distance between two points in n-dimensional space.\n    \n    Args:\n        point1 (tuple or list): The coordinates of the first point.\n        point2 (tuple or list): The coordinates of the second point.\n        \n    Returns:\n        float: The Euclidean distance between the two points.", "Freq": 0, "TSR": 0}], "Distance Formula": [{"tool": "def distance_formula_symbolic(point1, point2):\n    \n    if len(point1) != len(point2):\n        raise ValueError(\"Points must have the same dimensions\")\n    distance_expr = sqrt(sum((p1 - p2)**2 for p1, p2 in zip(point1, point2)))\n    return simplify(distance_expr)", "subfield": "Distance Formula", "tool_name": "distance_formula_symbolic", "tool_type": "function", "description": "Construct a symbolic distance formula between two points, supporting symbolic and numerical computation.", "docstring": "Construct a symbolic distance formula between two points, supporting symbolic and numerical computation.\n    Parameters:\n    - point1: array-like, the coordinates of the first point, can contain symbols or numbers\n    - point2: array-like, the coordinates of the second point, can contain symbols or numbers\n    Returns:\n    - distance_expr: sympy expression, the symbolic expression for the distance between point1 and point2\n    Examples:\n    - Using numerical coordinates:\n    >>> distance_formula_symbolic((1, 2), (4, 6))\n    sqrt(13)\n    \n    - Using symbolic coordinates:\n    >>> x, y = symbols('x y')\n    >>> distance_formula_symbolic((x, 0), (0, y))\n    sqrt(x**2 + y**2)", "Freq": 46, "TSR": 29, "experience_pool": "- To use the solve function, you need to import it from sympy: `from sympy import solve`\n- To use the pi constant, you need to import it from sympy: `from sympy import pi`\n- To use the Eq function, you need to import it from sympy: `from sympy import Eq`\n- To use the symbols function, you need to import it from sympy: `from sympy import symbols`"}, {"tool": "def pythagorean_theorem(leg_a=None, leg_b=None, hypotenuse=None):\n    \n    if hypotenuse is None and leg_a is not None and leg_b is not None:\n        return math.sqrt(leg_a**2 + leg_b**2)\n    elif leg_a is None and hypotenuse is not None and leg_b is not None:\n        return math.sqrt(hypotenuse**2 - leg_b**2)\n    elif leg_b is None and hypotenuse is not None and leg_a is not None:\n        return math.sqrt(hypotenuse**2 - leg_a**2)\n    else:\n        raise ValueError(\"Invalid input: provide exactly one missing side.\")", "subfield": "Distance Formula", "tool_name": "pythagorean_theorem", "tool_type": "function", "description": "Calculate the missing side of a right triangle using the Pythagorean theorem.", "docstring": "Calculate the missing side of a right triangle using the Pythagorean theorem.\n    Parameters:\n    -----------\n    leg_a : float, optional\n        The length of one leg of the triangle.\n    leg_b : float, optional\n        The length of the other leg of the triangle.\n    hypotenuse : float, optional\n        The length of the hypotenuse of the triangle.\n    \n    Returns:\n    --------\n    float\n        The length of the missing side of the triangle.\n    \n    Examples:\n    ---------\n    >>> pythagorean_theorem(leg_a=3, leg_b=4)\n    5.0\n    >>> pythagorean_theorem(hypotenuse=5, leg_b=4)\n    3.0\n    Raises:\n    -------\n    ValueError\n        If insufficient data is provided or too many sides are known.", "Freq": 8, "TSR": 4, "experience_pool": "Experience 1:\nProblem: [Describe the problem]\nAnswer: [Describe the answer]\n\nExperience 2:\nProblem: [Describe the problem]\nAnswer: [Describe the answer]\n\n..."}, {"tool": "def calculate_median_length(side_a, side_b):\n    \n    hypotenuse = math.sqrt(side_a**2 + side_b**2)\n    return hypotenuse / 2", "subfield": "Distance Formula", "tool_name": "calculate_median_length", "tool_type": "function", "description": "Calculate the length of the median to the hypotenuse of a right triangle, based on the other two sides.\n    The median on the hypotenuse divides it into two equal segments, each half the length of the hypotenuse.", "docstring": "Calculate the length of the median to the hypotenuse of a right triangle, based on the other two sides.\n    The median on the hypotenuse divides it into two equal segments, each half the length of the hypotenuse.\n    \n    Parameters:\n    - side_a (float): Length of one side of the right triangle.\n    - side_b (float): Length of the other side of the right triangle.\n    \n    Returns:\n    - float: The length of the median to the hypotenuse.\n    \n    Example:\n    >>> calculate_median_length(3, 4)\n    2.5", "Freq": 1, "TSR": 1}, {"tool": "def distance_formula_3D(point1, point2):\n    \n    x1, y1, z1 = point1\n    x2, y2, z2 = point2\n    distance = sqrt((x2 - x1)**2 + (y2 - y1)**2 + (z2 - z1)**2)\n    return distance", "subfield": "Distance Formula", "tool_name": "distance_formula_3D", "tool_type": "function", "description": "Calculate the distance between two points in three-dimensional space using the distance formula.\n    Args:\n        point1 (tuple): The coordinates of the first point (x1, y1, z1).\n        point2 (tuple): The coordinates of the second point (x2, y2, z2).\n    Returns:\n        float: The distance between the two points.", "docstring": "Calculate the distance between two points in three-dimensional space using the distance formula.\n    Args:\n        point1 (tuple): The coordinates of the first point (x1, y1, z1).\n        point2 (tuple): The coordinates of the second point (x2, y2, z2).\n    Returns:\n        float: The distance between the two points.", "Freq": 7, "TSR": 6}], "Area Calculation": [{"tool": "def area_triangle(base, height):\n    \n    return 0.5 * base * height", "subfield": "Area Calculation", "tool_name": "area_triangle", "tool_type": "function", "description": "Calculate area of a triangle given its base and height.", "docstring": "Calculate area of a triangle given its base and height.\n    Parameters:\n    base (float): the length of the base of the triangle.\n    height (float): the height of the triangle perpendicular to the base.\n    Returns:\n    float: the area of the triangle", "Freq": 8, "TSR": 0, "experience_pool": "Tool for calculating the area of a triangle is essential for geometry problems.\nMake sure to provide the correct base and height values when using the tool."}, {"tool": "def area_circle(radius):\n    \n    import math\n    return math.pi * radius ** 2", "subfield": "Area Calculation", "tool_name": "area_circle", "tool_type": "function", "description": "Calculate the area of a circle given its radius.", "docstring": "Calculate the area of a circle given its radius.\n    Parameters:\n    radius (float): the radius of the circle.\n    Returns:\n    float: the area of the circle calculated as pi*r^2", "Freq": 5, "TSR": 0}, {"tool": "def rectangle_area(length, width):\n    \n    return length * width", "subfield": "Area Calculation", "tool_name": "rectangle_area", "tool_type": "function", "description": "Calculate the area of a rectangle from length and width.", "docstring": "Calculate the area of a rectangle from length and width.\n    Parameters:\n    length (float): The length of the rectangle.\n    width (float): The width of the rectangle.\n    Returns:\n    float: The area of the rectangle.\n    \n    Examples:\n    >>> rectangle_area(4, 3)\n    12", "Freq": 4, "TSR": 2}, {"tool": "def triangle_area_by_sides(a, b, c):\n    \n    s = (a + b + c) / 2\n    area = sqrt(s * (s - a) * (s - b) * (s - c))\n    return area", "subfield": "Area Calculation", "tool_name": "triangle_area_by_sides", "tool_type": "function", "description": "Calculate the area of a triangle given the lengths of its sides using Heron's formula.", "docstring": "Calculate the area of a triangle given the lengths of its sides using Heron's formula.\n    Parameters:\n    - a, b, c (float): Lengths of the sides of the triangle.\n    Returns:\n    - float: The area of the triangle.\n    Examples:\n    >>> triangle_area_by_sides(3, 4, 5)\n    6.0", "Freq": 1, "TSR": 1}, {"tool": "def area_sector(radius, angle_deg):\n    \n    angle_rad = math.radians(angle_deg)\n    return 0.5 * radius**2 * angle_rad", "subfield": "Area Calculation", "tool_name": "area_sector", "tool_type": "function", "description": "Calculate the area of a sector of a circle given its radius and central angle in degrees.", "docstring": "Calculate the area of a sector of a circle given its radius and central angle in degrees.\n    Parameters:\n    - radius (float): The radius of the circle.\n    - angle_deg (float): The angle of the sector in degrees.\n    \n    Returns:\n    - float: The area of the sector.\n    \n    Example:\n    >>> area_sector(4, 90)\n    12.566370614359172", "Freq": 2, "TSR": 0}, {"tool": "def area_polygon(vertices):\n    \n    x = np.array([vertex[0] for vertex in vertices])\n    y = np.array([vertex[1] for vertex in vertices])\n    return 0.5 * np.abs(np.dot(x, np.roll(y, 1)) - np.dot(y, np.roll(x, 1)))", "subfield": "Area Calculation", "tool_name": "area_polygon", "tool_type": "function", "description": "Calculate the area of a simple polygon given its vertices.", "docstring": "Calculate the area of a simple polygon given its vertices.\n    Parameters:\n        vertices (list of tuples): List of (x, y) tuples, each representing a vertex of the polygon.\n    Returns:\n        float: The area of the polygon.\n    Examples:\n    >>> area_polygon([(0, 0), (4, 0), (4, 4), (0, 4)])  # Square with side 4\n    16.0", "Freq": 5, "TSR": 0, "experience_pool": "Tool usage experience:\n- The tool for calculating the area of a polygon is accurate and functional.\n- The tool usage issues are more related to incorrect input parameters and not the tool itself."}, {"tool": "def area_square(side_length):\n    \n    return side_length ** 2", "subfield": "Area Calculation", "tool_name": "area_square", "tool_type": "function", "description": "Calculates the area of a square.", "docstring": "Calculates the area of a square.\n    Parameters:\n        side_length (float): The length of the side of the square.\n    Returns:\n        float: The area of the square.\n    Example:\n        >>> area_square(4)\n        16", "Freq": 17, "TSR": 3, "experience_pool": "- When calculating areas of different shapes, ensure that the necessary functions like `area_circle`, `area_triangle`, `triangle_side_lengths`, and `calculate_composite_area` are defined and implemented correctly."}, {"tool": "def triangle_area_by_coordinates(x1, y1, x2, y2, x3, y3):\n    \n    return abs(x1*(y2-y3) + x2*(y3-y1) + x3*(y1-y2)) / 2", "subfield": "Area Calculation", "tool_name": "triangle_area_by_coordinates", "tool_type": "function", "description": "Calculate the area of a triangle given the coordinates of its vertices.", "docstring": "Calculate the area of a triangle given the coordinates of its vertices.\n    Parameters:\n    x1, y1 (float): Coordinates of the first vertex.\n    x2, y2 (float): Coordinates of the second vertex.\n    x3, y3 (float): Coordinates of the third vertex.\n    Returns:\n    float: The absolute value of the area of the triangle.\n    Examples:\n    >>> triangle_area_by_coordinates(0, 0, 4, 0, 2, 3)\n    6.0", "Freq": 8, "TSR": 1, "experience_pool": "Tool: Geometry - Area Calculation\nSubfield: Triangle Area Calculation\n1. Problem: Find the area of the triangle with vertices $(3,-5),$ $(-2,0),$ and $(1,-6)$.\n   Solution: The correct area is $\\frac{15}{2}$.\n2. Problem: Find the area of the triangle with vertices $(-1,4),$ $(7,0),$ and $(11,5)$.\n   Solution: The correct area is $28$.\n3. Problem: Regular hexagon $ABCDEF$ has vertices $A$ and $C$ at $(0,0)$ and $(7,1)$, respectively. What is its area?\n   Solution: The correct area is $25\\sqrt{3}$.\n4. Problem: Point $P$ is selected at random from the interior of the pentagon with vertices $A=(0,2)$, $B= (4,0)$, $C = (2\\pi +1, 0)$, $D=(2\\pi +1,4)$, and $E=(0,4)$. What is the probability that $\\angle APB$ is obtuse? Express your answer as a common fraction.\n   Solution: The correct probability is $\\frac{5}{16}$.\n5. Problem: Find the area of the triangle with vertices $(0,7,10),$ $(-1,6,6),$ and $(-4,9,6)$.\n   Solution: The correct area is $9$.\n6. Problem: What is the area, in square units, of a triangle whose vertices are at $(4, -1)$, $(10, 3)$ and $(4, 5)$?\n   Solution: The correct area is $18$.\n7. Problem: The set of points $(x,y)$ such that $|x - 3| \\le y \\le 4 - |x - 1|$ defines a region in the $xy$-plane. Compute the area of this region.\n   Solution: The correct area is $6$.\n8. Problem: A triangle has vertices at $(-3,2),(6,-2),(3,5)$. How many square units are in the area of the triangle? Express your answer as a decimal to the nearest tenth.\n   Solution: The correct area is $25.5$."}, {"tool": "def distance_between_points(x1, y1, x2, y2):\n    \n    return math.sqrt((x2 - x1)**2 + (y2 - y1)**2)", "subfield": "Area Calculation", "tool_name": "distance_between_points", "tool_type": "function", "description": "Calculate the Euclidean distance between two points in the Cartesian plane.", "docstring": "Calculate the Euclidean distance between two points in the Cartesian plane.\n    Parameters:\n    x1, y1 (float): Coordinates of the first point.\n    x2, y2 (float): Coordinates of the second point.\n    Returns:\n    float: The distance between the points.\n    Examples:\n    >>> distance_between_points(0, 0, 3, 4)\n    5.0", "Freq": 2, "TSR": 0}, {"tool": "def area_rhombus_by_diagonals(d1, d2):\n    \n    return d1 * d2 / 2", "subfield": "Area Calculation", "tool_name": "area_rhombus_by_diagonals", "tool_type": "function", "description": "Calculate the area of a rhombus given the lengths of its diagonals.", "docstring": "Calculate the area of a rhombus given the lengths of its diagonals.\n    \n    Parameters:\n    - d1 (float): Diagonal 1 length.\n    - d2 (float): Diagonal 2 length.\n    \n    Returns:\n    - float: The calculated area of the rhombus.\n    \n    Example:\n    >>> area_rhombus_by_diagonals(4, 5)\n    10.0", "Freq": 1, "TSR": 0}, {"tool": "def triangle_area_by_angle_side(angle, side1, side2):\n    \n    return 0.5 * side1 * side2 * math.sin(angle)", "subfield": "Area Calculation", "tool_name": "triangle_area_by_angle_side", "tool_type": "function", "description": "Calculate the area of a triangle given an angle and two sides enclosing the angle.", "docstring": "Calculate the area of a triangle given an angle and two sides enclosing the angle.\n    \n    Parameters:\n    - angle (float): Angle in radians between the two sides.\n    - side1 (float), side2 (float): Lengths of the sides that enclose the angle.\n    \n    Returns:\n    - float: The area of the triangle.\n    \n    Example:\n    >>> triangle_area_by_angle_side(math.pi / 2, 3, 4)  # Right angle\n    6.0", "Freq": 0, "TSR": 0}, {"tool": "def polygon_area_sides(n_sides, side_length):\n    \n    if n_sides < 3:\n        raise ValueError(\"A polygon must have at least three sides.\")\n    perimeter = n_sides * side_length\n    apothem = side_length / (2 * math.tan(math.pi / n_sides))\n    return 0.5 * perimeter * apothem", "subfield": "Area Calculation", "tool_name": "polygon_area_sides", "tool_type": "function", "description": "Calculate the area of a regular polygon using the number of sides and the side length.", "docstring": "Calculate the area of a regular polygon using the number of sides and the side length.\n    Parameters:\n    n_sides (int): The number of sides of the regular polygon.\n    side_length (float): The length of each side.\n    Returns:\n    float: The area of the polygon.\n    \n    Example:\n    >>> polygon_area_sides(4, 5)  # Square\n    25.0", "Freq": 1, "TSR": 0}, {"tool": "def calculate_composite_area(*args):\n    \n    return sum(args)", "subfield": "Area Calculation", "tool_name": "calculate_composite_area", "tool_type": "function", "description": "Calculate the total area of multiple individual areas passed as arguments.", "docstring": "Calculate the total area of multiple individual areas passed as arguments.\n    Parameters:\n    - args (float): Individual areas to be summed.\n    Returns:\n    - float: The total area of all individual areas combined.\n    Examples:\n    >>> calculate_composite_area(10, 15, 5)\n    30", "Freq": 2, "TSR": 0, "experience_pool": "- Always provide correct input parameters when calling the `calculate_composite_area` function.\n- Ensure that the correct areas are passed as arguments to the `calculate_composite_area` function.\n- Double-check the calculations and logic in the calling code to avoid errors."}, {"tool": "def composite_area(*args):\n    \n    return sum(args)", "subfield": "Area Calculation", "tool_name": "composite_area", "tool_type": "function", "description": "The function takes the areas of several shapes as input \n    and returns the total area.", "docstring": "The function takes the areas of several shapes as input \n    and returns the total area.", "Freq": 0, "TSR": 0}, {"tool": "def law_of_cosines(a, b, angle_degrees):\n    \n    angle_radians = math.radians(angle_degrees)\n    c = math.sqrt(a**2 + b**2 - 2 * a * b * math.cos(angle_radians))\n    return c", "subfield": "Area Calculation", "tool_name": "law_of_cosines", "tool_type": "function", "description": "Calculate the third side of a triangle using the Law of Cosines.", "docstring": "Calculate the third side of a triangle using the Law of Cosines.\n    Parameters:\n    a (float): Length of the first side.\n    b (float): Length of the second side.\n    angle_degrees (float): Angle between sides a and b in degrees.\n    Returns:\n    float: Length of the third side.\n    Example:\n    >>> law_of_cosines(5, 5, 90)\n    7.0710678118654755", "Freq": 1, "TSR": 0}, {"tool": "def rectangle_area(length, width):\n    \n    return length * width", "subfield": "Area Calculation", "tool_name": "rectangle_area", "tool_type": "function", "description": "The function takes the length and width of a rectangle as input \n    and returns its area.", "docstring": "The function takes the length and width of a rectangle as input \n    and returns its area.", "Freq": 0, "TSR": 0}, {"tool": "def triangle_side_lengths(angle, *dimensions):\n    \n    \n    import sympy as sp\n    def right_triangle_sides(a, b):\n        # Use the Pythagorean theorem\n        return a, b, sp.sqrt(a**2 + b**2)\n    def special_triangle_sides(angle, a):\n        if angle == 30:\n            return a, a * sp.sqrt(3), 2*a\n        elif angle == 45:\n            return a, a, a * sp.sqrt(2)\n        else:\n            raise ValueError('This tool only covers 30-60-90 and 45-45-90 triangles.')\n    if angle == 90:\n        return right_triangle_sides(*dimensions)\n    else:\n        return special_triangle_sides(angle, *dimensions)", "subfield": "Area Calculation", "tool_name": "triangle_side_lengths", "tool_type": "function", "description": "Calculate the length of sides in common triangle types (right, 30-60-90, 45-45-90).", "docstring": "Calculate the length of sides in common triangle types (right, 30-60-90, 45-45-90).\n    Parameters\n    ----------\n    angle : int\n        Internal angle in degrees of the triangle.\n    dimensions : tuple\n        Lengths of known sides.\n    Returns\n    -------\n    tuple\n        Lengths of all sides of the triangle.\n    Examples\n    --------\n    >>> triangle_side_lengths(90, 3, 4)\n    (3, 4, 5)\n    >>> triangle_side_lengths(30, 5)\n    (5, 5*sqrt(3), 10)\n    >>> triangle_side_lengths(45, 5)\n    (5, 5, 5*sqrt(2))", "Freq": 0, "TSR": 0}, {"tool": "def circle_area(radius):\n    \n    return math.pi * (radius**2)", "subfield": "Area Calculation", "tool_name": "circle_area", "tool_type": "function", "description": "The function takes the radius of a circle as input \n    and returns its area.", "docstring": "The function takes the radius of a circle as input \n    and returns its area.", "Freq": 0, "TSR": 0}, {"tool": "def rectangle_area_dynamic(L, W):\n    \n    from sympy import simplify\n    return simplify(L * W)", "subfield": "Area Calculation", "tool_name": "rectangle_area_dynamic", "tool_type": "function", "description": "Calculate the area of a rectangle while allowing the sides, L and W, to be expressions.", "docstring": "Calculate the area of a rectangle while allowing the sides, L and W, to be expressions.\n    \n    Parameters:\n    - L, W (expressions or floats): The expressions or numbers representing the length and width.\n    \n    Returns:\n    - Expression or float: The calculated area.\n    \n    Example:\n    >>> from sympy import symbols, Eq, solve\n    >>> l = symbols('l')\n    >>> rectangle_area_dynamic(l, l+2)\n    l*(l + 2)", "Freq": 0, "TSR": 0}, {"tool": "def composite_area_calculations(*areas, subtract=False):\n    \n    if subtract:\n        return areas[0] - sum(areas[1:])\n    else:\n        return sum(areas)", "subfield": "Area Calculation", "tool_name": "composite_area_calculations", "tool_type": "function", "description": "Compute the total or net area of multiple individual areas, supporting both sum and subtraction operations.", "docstring": "Compute the total or net area of multiple individual areas, supporting both sum and subtraction operations.\n    Parameters:\n        areas (list of floats): A list of individual areas.\n        subtract (bool): If True, subtracts areas instead of summing them.\n    Returns:\n        float: Total or net area after performing the sum or subtraction.\n    Example:\n        >>> composite_area_calculations(10, 5, 15)\n        30\n        >>> composite_area_calculations(10, 3, subtract=True)\n        7", "Freq": 0, "TSR": 0}, {"tool": "def line_equation_from_points(x1, y1, x2, y2):\n    \n    if x2 != x1:\n        slope = (y2 - y1) / (x2 - x1)\n        intercept = y1 - slope * x1\n        return slope, intercept\n    else:\n        return float('inf'), x1", "subfield": "Area Calculation", "tool_name": "line_equation_from_points", "tool_type": "function", "description": "Calculate the slope and y-intercept of the line passing through two points.", "docstring": "Calculate the slope and y-intercept of the line passing through two points.\n    Parameters:\n    x1, y1 (float): Coordinates of the first point.\n    x2, y2 (float): Coordinates of the second point.\n    Returns:\n    tuple: Slope and y-intercept of the line.\n    Examples:\n    >>> line_equation_from_points(0, 0, 2, 2)\n    (1.0, 0.0)\n    >>> line_equation_from_points(1, 2, 3, 8)\n    (3.0, -1.0)", "Freq": 0, "TSR": 0}, {"tool": "def pythagorean_triplet(a, b, c):\n    \n    return abs((a ** 2) + (b ** 2) - (c ** 2)) < 0.001", "subfield": "Area Calculation", "tool_name": "pythagorean_triplet", "tool_type": "function", "description": "Check if the three given lengths form a Pythagorean triplet.", "docstring": "Check if the three given lengths form a Pythagorean triplet.\n    Parameters\n    ----------\n    a : float\n        Length of the first side.\n    b : float\n        Length of the second side.\n    c : float\n        Length of the third side (hypotenuse).\n    Returns\n    -------\n    bool\n        `True` if the lengths form a Pythagorean triplet and `False` otherwise", "Freq": 0, "TSR": 0}, {"tool": "class CircleBasedCalculator:\n    \"\"\"\n    A class to calculate various geometrical properties and areas related to circles,\n    including full circles, sectors, and annuli (regions between two concentric circles).\n    \"\"\"\n    @staticmethod\n    def area_of_circle(radius):\n        \"\"\"\n        Calculate the area of a circle using the formula πr².\n        Parameters:\n            radius (float): The radius of the circle.\n        Returns:\n            float: The area of the circle.\n        Example:\n            >>> CircleBasedCalculator.area_of_circle(5)\n            78.53981633974483\n        \"\"\"\n        return math.pi * radius ** 2\n    @staticmethod\n    def area_of_sector(radius, angle_in_degrees):\n        \"\"\"\n        Calculate the area of a sector given the central angle and radius.\n        Parameters:\n            radius (float): The radius of the circle from which the sector is part.\n            angle_in_degrees (float): The angle of the sector in degrees.\n        Returns:\n            float: The area of the sector.\n        Example:\n            >>> CircleBasedCalculator.area_of_sector(5, 90)\n            19.634954084936208\n        \"\"\"\n        return (angle_in_degrees / 360) * math.pi * radius ** 2\n    @staticmethod\n    def area_of_annulus(outer_radius, inner_radius):\n        \"\"\"\n        Calculate the area of an annulus (the region between two concentric circles).\n        Parameters:\n            outer_radius (float): Radius of the outer circle.\n            inner_radius (float): Radius of the inner circle.\n        Returns:\n            float: The area of the annulus.\n        Example:\n            >>> CircleBasedCalculator.area_of_annulus(5, 3)\n            50.26548245743669\n        \"\"\"\n        return math.pi * (outer_radius ** 2 - inner_radius ** 2)\n    @staticmethod\n    def diameter_to_radius(diameter):\n        \"\"\"\n        Convert diameter to radius.\n        Parameters:\n            diameter (float): The diameter of the circle.\n        Returns:\n            float: The radius of the circle.\n        Example:\n            >>> CircleBasedCalculator.diameter_to_radius(10)\n            5.0\n        \"\"\"\n        return diameter / 2", "subfield": "Area Calculation", "tool_name": "CircleBasedCalculator:\n    \"\"\"\n    A class to calculate various geometrical properties and areas related to circles,\n    including full circles, sectors, and annuli", "tool_type": "class", "description": "A class to calculate various geometrical properties and areas related to circles,\n    including full circles, sectors, and annuli (regions between two concentric circles).", "docstring": "A class to calculate various geometrical properties and areas related to circles,\n    including full circles, sectors, and annuli (regions between two concentric circles).", "Freq": 0, "TSR": 0}, {"tool": "def centroid_polygon(vertices: List[Tuple[float, float]]) -> Tuple[float, float]:\n    \n    x_coordinates, y_coordinates = zip(*vertices)\n    num_vertices = len(vertices)\n    centroid_x = sum(x_coordinates) / num_vertices\n    centroid_y = sum(y_coordinates) / num_vertices\n    return (centroid_x, centroid_y)", "subfield": "Area Calculation", "tool_name": "centroid_polygon", "tool_type": "function", "description": "Calculates the centroid (geometric center) of a polygon given its vertices.", "docstring": "Calculates the centroid (geometric center) of a polygon given its vertices.\n    Parameters:\n    - vertices (List[Tuple[float, float]]): Coordinates of the vertices of the polygon.\n    Returns:\n    - Tuple[float, float]: The coordinates of the centroid.\n    Examples:\n    >>> print(centroid_polygon([(0, 0), (4, 0), (4, 4), (0, 4)]))\n    (2.0, 2.0)", "Freq": 0, "TSR": 0}, {"tool": "def TriangleAreaCalculator(base=None, height=None, vertices=None, sides=None):\n    \n    import math\n    if base is not None and height is not None:\n        # Simple calculation from base and height\n        return 0.5 * base * height\n    elif vertices is not None:\n        # Calculate area from vertices using determinant (shoelace formula)\n        x1, y1 = vertices[0]\n        x2, y2 = vertices[1]\n        x3, y3 = vertices[2]\n        return 0.5 * abs(x1*(y2-y3) + x2*(y3-y1) + x3*(y1-y2))\n    elif sides is not None:\n        # Using Heron's formula to find area when sides are known\n        a, b, c = sides\n        s = 0.5 * sum(sides)\n        area = math.sqrt(s * (s - a) * (s - b) * (s - c))\n        return area\n    else:\n        raise ValueError(\"Insufficient information to calculate area.\")", "subfield": "Area Calculation", "tool_name": "TriangleAreaCalculator", "tool_type": "function", "description": "Calculate the area of a triangle given base and height, vertices, or side lengths.", "docstring": "Calculate the area of a triangle given base and height, vertices, or side lengths.\n    Parameters:\n    - base (float): The base of the triangle.\n    - height (float): The height of the triangle perpendicular to the base.\n    - vertices (list of tuples): List of coordinates for the triangle's vertices as (x, y).\n    - sides (tuple): The lengths of the three sides of the triangle.\n    Returns:\n    - float: The area of the triangle.\n    Examples:\n    - TriangleAreaCalculator(base=5, height=3)\n    - TriangleAreaCalculator(vertices=[(0, 0), (5, 0), (0, 3)])\n    - TriangleAreaCalculator(sides=(3, 4, 5))", "Freq": 2, "TSR": 0, "experience_pool": "- When calculating the area of the pentagon with sides of length 15, 20, 27, 24, and 20 units, ensure that the sides provided to the `TriangleAreaCalculator` function are correct.\n- When calculating the area of the largest possible inscribed triangle in a circle with radius 6 cm, make sure to provide the correct parameters (base and height) to the `TriangleAreaCalculator` function."}, {"tool": "def find_line_intersection(p1, p2, p3, p4):\n    \n    x1, y1 = p1\n    x2, y2 = p2\n    x3, y3 = p3\n    x4, y4 = p4\n    \n    # Calculate the determinants\n    denom = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4)\n    if denom == 0:\n        return 'No unique intersection or lines are collinear'\n    \n    px = ((x1 * y2 - y1 * x2) * (x3 - x4) - (x1 - x2) * (x3 * y4 - y3 * x4)) / denom\n    py = ((x1 * y2 - y1 * x2) * (y3 - y4) - (y1 - y2) * (x3 * y4 - y3 * x4)) / denom\n    return (px, py)", "subfield": "Area Calculation", "tool_name": "find_line_intersection", "tool_type": "function", "description": "Calculate the intersection point of two lines defined by two pairs of points.", "docstring": "Calculate the intersection point of two lines defined by two pairs of points.\n    Parameters:\n    p1, p2 (tuple): (x, y) coordinates for the first and the second point of the first line.\n    p3, p4 (tuple): (x, y) coordinates for the third and the fourth point of the second line.\n    Returns:\n    tuple or str: (x, y) coordinates of the intersection point, or 'No unique intersection' if lines are collinear or do not intersect.\n    Examples:\n    >>> find_line_intersection((0, 0), (1, 1), (1, 0), (0, 1))\n    (0.5, 0.5)\n    >>> find_line_intersection((0, 0), (1, 1), (2, 2), (3, 3))\n    'No unique intersection or lines are collinear'", "Freq": 1, "TSR": 0}, {"tool": "def circle_diameter(radius):\n    \n    return 2 * radius", "subfield": "Area Calculation", "tool_name": "circle_diameter", "tool_type": "function", "description": "The function takes radius of a circle as input \n    and returns its diameter.", "docstring": "The function takes radius of a circle as input \n    and returns its diameter.", "Freq": 0, "TSR": 0}, {"tool": "def derive_side_lengths(shape, **kwargs):\n    \n    if shape == 'triangle_cosine':\n        a, b, angle = kwargs['a'], kwargs['b'], kwargs['angle']\n        angle_rad = np.radians(angle)\n        return sqrt(a**2 + b**2 - 2*a*b*np.cos(angle_rad))\n    elif shape == 'polygon_diagonal':\n        side, n_sides = kwargs['side'], kwargs['n_sides']\n        if n_sides == 4:  # square or rectangle logic\n            return sqrt(2) * side\n        else:\n            raise ValueError(\"Diagonal calculation for this polygon not supported\")", "subfield": "Area Calculation", "tool_name": "derive_side_lengths", "tool_type": "function", "description": "Derive side lengths using geometric and trigonometric relations for various shapes.", "docstring": "Derive side lengths using geometric and trigonometric relations for various shapes.\n    \n    Parameters\n    ----------\n    shape : str\n        Type of geometric shape ('triangle_cosine', 'polygon_diagonal')\n    kwargs: various\n        Known lengths, angles, and other relevant properties depending on the shape.\n    \n    Returns\n    -------\n    float\n        The derived side length or lengths depending on the calculation.\n    \n    Examples\n    --------\n    >>> derive_side_lengths('triangle_cosine', a=5, b=5, angle=60)\n    5.0\n    >>> derive_side_lengths('polygon_diagonal', side=4, n_sides=4)  # Diagonal of a square\n    5.656854249492381", "Freq": 0, "TSR": 0}], "Triangles": [{"tool": "def triangle_area(base, height):\n    \n    return 0.5 * base * height", "subfield": "Triangles", "tool_name": "triangle_area", "tool_type": "function", "description": "Calculate the area of a triangle using base and height.", "docstring": "Calculate the area of a triangle using base and height.\n    \n    Parameters:\n    base (float): Base of the triangle.\n    height (float): Height of the triangle.\n    Returns:\n    float: Area of the triangle.", "Freq": 8, "TSR": 4, "experience_pool": "Tool for calculating the area of a triangle using base and height is accurate and effective."}, {"tool": "def herons_formula(a, b, c):\n    \n    s = (a + b + c) / 2\n    area = math.sqrt(s * (s - a) * (s - b) * (s - c))\n    return area", "subfield": "Triangles", "tool_name": "herons_formula", "tool_type": "function", "description": "Calculate the area of a triangle using Heron's formula given the sides.", "docstring": "Calculate the area of a triangle using Heron's formula given the sides.\n    \n    Parameters:\n    a, b, c (float): Sides of the triangle.\n    \n    Returns:\n    float: Area of the triangle.", "Freq": 14, "TSR": 5, "experience_pool": "- Make sure to provide the correct side lengths when calling the `herons_formula` function.\n- Double-check the calculations and input values in the calling code to ensure accurate results."}, {"tool": "def is_valid_triangle(a, b, c):\n    \n    return (a+b > c) and (a+c > b) and (b+c > a)", "subfield": "Triangles", "tool_name": "is_valid_triangle", "tool_type": "function", "description": "Determines if three side lengths can form a valid triangle based on the Triangle Inequality Theorem.", "docstring": "Determines if three side lengths can form a valid triangle based on the Triangle Inequality Theorem.\n    Parameters:\n        a (float): The length of the first side.\n        b (float): The length of the second with the limil side.\n        c (float): The length of the third side.\n    Returns:\n        bool: True if the side lengths can form a triangle, False otherwise.\n    Examples:\n    >>> is_valid_triangle(3, 4, 5)\n    True\n    >>> is_valid_triangle(1, 10, 12)\n    False", "Freq": 3, "TSR": 2, "experience_pool": "Tool has been used successfully with a 50.0% success rate."}, {"tool": "def calculate_triangle_area(base=None, height=None, side=None):\n    \n    if base is not None and height is not None:\n        return 0.5 * base * height\n    elif side is not None:\n        # Area of an equilateral triangle: sqrt(3)/4 * side^2\n        return (math.sqrt(3) / 4) * (side**2)\n    else:\n        raise ValueError(\"Invalid inputs given. Provide either base and height for a regular triangle or side for an equilateral triangle.\")", "subfield": "Triangles", "tool_name": "calculate_triangle_area", "tool_type": "function", "description": "Calculate the area of a triangle using base and height or by specifying the sides using Heron's formula for equilateral triangles.", "docstring": "Calculate the area of a triangle using base and height or by specifying the sides using Heron's formula for equilateral triangles.\n    \n    Parameters:\n    base (float, optional): The base of the triangle.\n    height (float, optional): The height of the triangle.\n    side (float, optional): The length of a side if the triangle is equilateral.\n    Returns:\n    float: The area of the triangle.\n    Example:\n    >>> calculate_triangle_area(base=10, height=5)\n    25.0\n    >>> calculate_triangle_area(side=8)  # Equilateral triangle\n    13.856", "Freq": 0, "TSR": 0}, {"tool": "def calculate_third_angle(angle1, angle2):\n    \n    if angle1 + angle2 >= 180 or angle1 <= 0 or angle2 <= 0:\n        return None\n    return 180 - angle1 - angle2", "subfield": "Triangles", "tool_name": "calculate_third_angle", "tool_type": "function", "description": "Calculate the third angle of a triangle given two angles.", "docstring": "Calculate the third angle of a triangle given two angles.\n    Parameters:\n    angle1 (float): The first angle of the triangle in degrees.\n    angle2 (float): The second angle of the triangle in degrees.\n    Returns:\n    float: The third angle of the triangle in degrees, or None if the input angles do not form a valid triangle.", "Freq": 9.5, "TSR": 6, "experience_pool": "- When using the tool to calculate the third angle of a triangle, ensure that the sum of the input angles is less than 180 degrees and that each angle is greater than 0 degrees to form a valid triangle."}, {"tool": "def valid_third_side_range(a, b):\n    \n    return (abs(a - b) + 1, a + b - 1)", "subfield": "Triangles", "tool_name": "valid_third_side_range", "tool_type": "function", "description": "Determines the valid range for potential third side of a triangle given two sides, based on the Triangle Inequality Theorem.", "docstring": "Determines the valid range for potential third side of a triangle given two sides, based on the Triangle Inequality Theorem.\n    \n    Parameters:\n        a (float or int): The length of the first side.\n        b (float or int): The length of the second side.\n        \n    Returns:\n        tuple: A tuple containing the minimum and maximum values for the third side that can still form a triangle.\n    \n    Examples:\n        >>> valid_third_side_range(8, 5)\n        (3, 13)\n        >>> valid_third_side_range(15, 10)\n        (6, 24)", "Freq": 5, "TSR": 3, "experience_pool": "- Make sure to provide the correct side lengths when calling the valid_third_side_range function.\n- Ensure that the calling code correctly interprets the output of the valid_third_side_range function to get the desired result."}, {"tool": "def midpoint(x1, y1, x2, y2):\n    \n    return ((x1 + x2) / 2, (y1 + y2) / 2)", "subfield": "Triangles", "tool_name": "midpoint", "tool_type": "function", "description": "Calculate the midpoint of a segment given the coordinates of its endpoints.", "docstring": "Calculate the midpoint of a segment given the coordinates of its endpoints.\n    \n    Parameters:\n        x1, y1 (float): Coordinates of the first endpoint.\n        x2, y2 (float): Coordinates of the second endpoint.\n    \n    Returns:\n        tuple: The coordinates of the midpoint.\n    \n    Examples:\n        >>> midpoint(1, 1, 4, 5)\n        (2.5, 3.0)", "Freq": 2, "TSR": 1}, {"tool": "def calculate_side_range_and_perimeter(a: float, b: float) -> Tuple[Tuple[int, int], int]:\n    \n    if a <= 0 or b <= 0:\n        raise ValueError(\"Side lengths must be positive numbers\")\n    min_c = max(abs(a - b) + 1, 1)\n    max_c = a + b - 1\n    max_perimeter = a + b + max_c\n    return ((min_c, max_c), max_perimeter)", "subfield": "Triangles", "tool_name": "calculate_side_range_and_perimeter", "tool_type": "function", "description": "Calculate the possible values for the third side of a triangle when two sides are known.\n    Also, returns the maximal possible integer perimeter.", "docstring": "Calculate the possible values for the third side of a triangle when two sides are known.\n    Also, returns the maximal possible integer perimeter.\n    \n    Parameters:\n    a (float): Length of the first known side of the triangle.\n    b (float): Length of the second known side of the triangle.\n    \n    Returns:\n    Tuple[Tuple[int, int], int]: Returns a tuple containing another tuple and an integer. \n    The inner tuple represents the minimum and maximum possible integer values for the third side,\n    while the integer represents the maximum possible integer perimeter if the maximum side length is used.\n    \n    Examples:\n    >>> calculate_side_range_and_perimeter(3, 4)\n    ((2, 6), 13)\n    >>> calculate_side_range_and_perimeter(5, 10)\n    ((6, 14), 29)", "Freq": 10, "TSR": 3, "experience_pool": "1. The tool `calculate_side_range_and_perimeter` accurately calculates the possible range for the third side of a triangle and the maximum perimeter.\n2. Ensure that the input parameters provided to the tool are correct and within the valid range of positive numbers.\n3. The tool handles cases where the input sides are positive numbers appropriately."}, {"tool": "def triangle_side_lengths(a, b, c):\n    \n    # Convert tuples to Points\n    p1, p2, p3 = Point(a), Point(b), Point(c)\n    # Create triangle ABC\n    triangle_abc = Triangle(p1, p2, p3)\n    \n    # Calculate side lengths\n    ab = triangle_abc.ab.length.evalf()\n    bc = triangle_abc.bc.length.evalf()\n    ca = triangle_abc.ca.length.evalf()\n    \n    return {'ab': ab, 'bc': bc, 'ca': ca}", "subfield": "Triangles", "tool_name": "triangle_side_lengths", "tool_type": "function", "description": "Calculate the triangle side lengths given vertices a, b, and c.", "docstring": "Calculate the triangle side lengths given vertices a, b, and c.\n    Parameters:\n        a (tuple): Coordinates of vertex a (x1, y1)\n        b (tuple): Coordinates of vertex b (x2, y2)\n        c (tuple): Coordinates of vertex c (x3, y3)\n    \n    Returns:\n        A dictionary with side lengths ab, bc, and ca.", "Freq": 1, "TSR": 0}, {"tool": "def solve_triangle(a, b, A):\n    \n    A = math.radians(A)  # Convert angle A from degrees to radians\n    sin_A = math.sin(A)\n    sin_B = (b * sin_A) / a\n    if sin_B > 1 or sin_B < -1:  # Check for invalid triangle configuration\n        return None\n    B = math.asin(sin_B)\n    C = math.pi - A - B\n    c = (a * math.sin(C)) / sin_A\n    return (c, math.degrees(B), math.degrees(C))", "subfield": "Triangles", "tool_name": "solve_triangle", "tool_type": "function", "description": "Calculate the missing side c and the remaining angles B and C in a triangle using the Law of Sines.\n    The provided angles must be in degrees.", "docstring": "Calculate the missing side c and the remaining angles B and C in a triangle using the Law of Sines.\n    The provided angles must be in degrees.\n    \n    Parameters:\n        a (float): The length of side a.\n        b (float): The length of side b.\n        A (float): The angle opposite to side a in degrees.\n    \n    Returns:\n        tuple: Returns the length of side c and the angles B and C in degrees.\n    \n    Example:\n        >>> solve_triangle(3, 4, 30)\n        (2.3094, 53.1301, 96.8699)", "Freq": 3, "TSR": 0, "experience_pool": "Tool for solving triangles using the Law of Sines is accurate and working as intended.\nEnsure correct input parameters and calculations in the calling code for accurate results."}, {"tool": "def is_right_triangle(a, b, c):\n    \n    sides = sorted([a, b, c])\n    return math.isclose(sides[0]**2 + sides[1]**2, sides[2]**2)", "subfield": "Triangles", "tool_name": "is_right_triangle", "tool_type": "function", "description": "Determine if a triangle with sides a, b, c is a right triangle.", "docstring": "Determine if a triangle with sides a, b, c is a right triangle.\n    \n    Parameters:\n    a, b, c (float): Sides of the triangle.\n    Returns:\n    bool: True if the triangle is right, False otherwise.", "Freq": 0, "TSR": 0}, {"tool": "def area_by_inradius_semiperimeter(inradius: float, semiperimeter: float) -> float:\n    \n    return inradius * semiperimeter", "subfield": "Triangles", "tool_name": "area_by_inradius_semiperimeter", "tool_type": "function", "description": "Calculate the area of a triangle given the inradius and the semiperimeter.", "docstring": "Calculate the area of a triangle given the inradius and the semiperimeter.\n    Parameters:\n    - inradius (float): The radius of the inscribed circle of the triangle.\n    - semiperimeter (float): The semiperimeter of the triangle.\n    Returns:\n    - float: The area of the triangle.\n    Examples:\n    >>> area_by_inradius_semiperimeter(1, 6)\n    6.0", "Freq": 2, "TSR": 2}, {"tool": "def calculate_distance(point1, point2):\n    \n    return math.sqrt((point2[0] - point1[0])**2 + (point2[1] - point1[1])**2)", "subfield": "Triangles", "tool_name": "calculate_distance", "tool_type": "function", "description": "Calculate the Euclidean distance between two points in 2D space.", "docstring": "Calculate the Euclidean distance between two points in 2D space.\n    \n    Parameters:\n        point1 (tuple): The (x, y) coordinates of the first point.\n        point2 (tuple): The (x, y) coordinates of the second point.\n    \n    Returns:\n        float: The distance between the two points.\n    \n    Example:\n        >>> calculate_distance((1, 1), (4, 5))\n        5.0", "Freq": 3, "TSR": 3}, {"tool": "def angle_between_vectors(x1, y1, x2, y2):\n    \n    dot_product = x1 * x2 + y1 * y2\n    magnitude1 = math.sqrt(x1**2 + y1**2)\n    magnitude2 = math.sqrt(x2**2 + y2**2)\n    angle_radians = math.acos(dot_product / (magnitude1 * magnitude2))\n    return math.degrees(angle_radians)", "subfield": "Triangles", "tool_name": "angle_between_vectors", "tool_type": "function", "description": "Calculate the angle (in degrees) between two vectors originating from the origin.", "docstring": "Calculate the angle (in degrees) between two vectors originating from the origin.\n    \n    Parameters:\n        x1, y1 (float): Components of the first vector.\n        x2, y2 (float): Components of the second vector.\n    \n    Returns:\n        float: The angle in degrees between two vectors.\n    \n    Examples:\n        >>> angle_between_vectors(1, 0, 0, 1)\n        90.0", "Freq": 2, "TSR": 0}, {"tool": "def triangle_similarity_by_sss(a_lengths, b_lengths):\n    \n    # Extracting lengths in sorted order\n    a_sorted = sorted(a_lengths.values())\n    b_sorted = sorted(b_lengths.values())\n    \n    # Checking proportionality\n    ratios = [a/b for a, b in zip(a_sorted, b_sorted)]\n    first_ratio = ratios[0]\n    \n    return all(abs(r - first_ratio) < 1e-9 for r in ratios)", "subfield": "Triangles", "tool_name": "triangle_similarity_by_sss", "tool_type": "function", "description": "Determine if two triangles are similar by Side-Side-Side (SSS) similarity criterion.", "docstring": "Determine if two triangles are similar by Side-Side-Side (SSS) similarity criterion.\n    Parameters:\n        a_lengths (dict): Side lengths of triangle A {'ab': length1, 'bc': length2, 'ca': length3}\n        b_lengths (dict): Side lengths of triangle B {'ab': length1, 'bc': length2, 'ca': length3}\n    \n    Returns:\n        bool: True if triangles are similar, False otherwise.", "Freq": 1, "TSR": 0}, {"tool": "def pythagorean_theorem(a=None, b=None, c=None):\n    \n    import math\n    \n    if a is None:\n        return math.sqrt(c**2 - b**2)\n    elif b is None:\n        return math.sqrt(c**2 - a**2)\n    elif c is None:\n        return math.sqrt(a**2 + b**2)\n    else:\n        raise ValueError(\"Exactly one side must be None to find its length\")", "subfield": "Triangles", "tool_name": "pythagorean_theorem", "tool_type": "function", "description": "Apply the Pythagorean theorem to find the missing side of a right triangle.", "docstring": "Apply the Pythagorean theorem to find the missing side of a right triangle.\n    Parameters:\n        a (float, optional): length of side a, leg of the triangle\n        b (float, optional): length of side b, leg of the triangle\n        c (float, optional): length of side c, hypotenuse of the triangle\n    Returns:\n        float: The length of the missing side.\n    Examples:\n    >>> pythagorean_theorem(a=3, b=4)\n    5.0\n    >>> pythagorean_theorem(c=10, b=6)\n    8.0", "Freq": 4, "TSR": 1}, {"tool": "def compute_pythagorean_side_length(side1, side2, target_side):\n    \n    if target_side == \"hypotenuse\":\n        return math.sqrt(side1**2 + side2**2)\n    else:\n        return math.sqrt(max(side1, side2)**2 - min(side1, side2)**2)", "subfield": "Triangles", "tool_name": "compute_pythagorean_side_length", "tool_type": "function", "description": "Applies the Pythagorean theorem to compute a side length in a right triangle.", "docstring": "Applies the Pythagorean theorem to compute a side length in a right triangle.\n    Parameters\n    ----------\n    side1 : float\n        Length of one side of the triangle.\n    side2 : float\n        Length of another side of the triangle.\n    target_side : str\n        The side to compute. It can either be \"leg\" if both given sides are legs, or \"hypotenuse\" if one of the given sides is the hypotenuse.\n    \n    Returns\n    -------\n    float\n        The length of the requested side.\n    Example\n    -------\n    >>> compute_pythagorean_side_length(3, 4, \"hypotenuse\")\n    5.0", "Freq": 0, "TSR": 0}, {"tool": "def triangle_side_length(coord1, coord2):\n    \n    x1, y1 = coord1\n    x2, y2 = coord2\n    return math.sqrt((x2 - x1)**2 + (y2 - y1)**2)", "subfield": "Triangles", "tool_name": "triangle_side_length", "tool_type": "function", "description": "Function that calculates the length of a side of a triangle given the coordinates of its endpoints.", "docstring": "Function that calculates the length of a side of a triangle given the coordinates of its endpoints.\n    Parameters:\n    coord1 (tuple): coordinates of the first endpoint of the side. coord1 is a tuple of two numbers (x1, y1)\n    coord2 (tuple): coordinates of the second endpoint of the side. coord2 is a tuple of two numbers (x2, y2)\n    \n    Returns:\n    float: length of the side calculated by the distance formula sqrt((x2 - x1)**2 + (y2 - y1)**2)\n    \n    Examples:\n    >>> triangle_side_length((0,0), (3,4))\n    5.0", "Freq": 0, "TSR": 0}, {"tool": "def calculate_right_triangle_sides(known_side, hypotenuse=None, other_side=None):\n    \n    if hypotenuse:\n        return math.sqrt(hypotenuse**2 - known_side**2)\n    elif other_side:\n        return math.sqrt(known_side**2 + other_side**2)\n    else:\n        raise ValueError('Either hypotenuse or the other side must be known.')", "subfield": "Triangles", "tool_name": "calculate_right_triangle_sides", "tool_type": "function", "description": "Given a side and either the hypotenuse or the other side, calculate the missing side using Pythagoras' theorem.", "docstring": "Given a side and either the hypotenuse or the other side, calculate the missing side using Pythagoras' theorem.\n    Parameters:\n    - known_side (float): Length of one known side of the right triangle.\n    - hypotenuse (float, optional): Hypotenuse of the triangle, if known.\n    - other_side (float, optional): The other side (leg) of the triangle, if known.\n    Returns:\n    float: The length of the missing side.\n    \n    Example:\n    >>> calculate_right_triangle_sides(3, hypotenuse=5)\n    4.0", "Freq": 1, "TSR": 0}, {"tool": "def equilateral_triangle_properties(side_length: float) -> dict:\n    \n    from math import sqrt\n    perimeter = 3 * side_length\n    area = (sqrt(3) / 4) * side_length**2\n    return {'perimeter': perimeter, 'area': area}", "subfield": "Triangles", "tool_name": "equilateral_triangle_properties", "tool_type": "function", "description": "Calculate the perimeter and area of an equilateral triangle given its side length.", "docstring": "Calculate the perimeter and area of an equilateral triangle given its side length.\n    Parameters\n    ----------\n    side_length : float\n        The length of one side of the equilateral triangle.\n    Returns\n    -------\n    dict\n        A dictionary containing the perimeter and area of the equilateral triangle.\n    Examples\n    --------\n    >>> equilateral_triangle_properties(5)\n    {'perimeter': 15.0, 'area': 10.825317547305486}", "Freq": 0, "TSR": 0}, {"tool": "def calculate_triangle_perimeter(sides):\n    \n    return sum(sides)", "subfield": "Triangles", "tool_name": "calculate_triangle_perimeter", "tool_type": "function", "description": "Calculate the perimeter of a triangle given the lengths of the sides.", "docstring": "Calculate the perimeter of a triangle given the lengths of the sides.\n    Parameters:\n    - sides (tuple/list): A collection of the three side lengths.\n    Returns:\n    float: The perimeter of the triangle.\n    \n    Example:\n    >>> calculate_triangle_perimeter((3, 4, 5))\n    12", "Freq": 1, "TSR": 1}, {"tool": "def triangle_angle_sum():\n    \n    return 180", "subfield": "Triangles", "tool_name": "triangle_angle_sum", "tool_type": "function", "description": "Return the sum of angles in any triangle, in degrees.\n    Returns:\n    int: The sum of the internal angles of a triangle, always 180 degrees.\n    \n    Example:\n    >>> triangle_angle_sum()\n    180", "docstring": "Return the sum of angles in any triangle, in degrees.\n    Returns:\n    int: The sum of the internal angles of a triangle, always 180 degrees.\n    \n    Example:\n    >>> triangle_angle_sum()\n    180", "Freq": 0, "TSR": 0}, {"tool": "def triangle_properties(base, height, side=None):\n    \n    import sympy\n    # Calculate Area\n    area = 0.5 * base * height\n    # Calculate Hypotenuse\n    if side is not None:\n        hypotenuse = sqrt(base**2 + side**2)\n    else:\n        hypotenuse = None\n    return area, hypotenuse", "subfield": "Triangles", "tool_name": "triangle_properties", "tool_type": "function", "description": "Given the base and height of a triangle, calculate and return the area and hypotenuse length.", "docstring": "Given the base and height of a triangle, calculate and return the area and hypotenuse length.\n    Parameters:\n    base (float): The length of the base of the triangle.\n    height (float): The length of the height of the triangle.\n    side (float, optional): The length of one of the side of a right triangle to calculate the length of the hypotenuse \n    Returns:\n    area (float): The area of the triangle.\n    hypotenuse (float or None): The length of the hypotenuse of the triangle if side length is provided. None otherwise.", "Freq": 0, "TSR": 0}, {"tool": "def centroid_triangle_area(A, B, C):\n    \n    def triangle_area(x1, y1, x2, y2, x3, y3):\n        \n        return abs((x1*(y2 - y3) + x2*(y3 - y1) + x3*(y1 - y2)) / 2.0)\n    # Calculate the centroid of triangle ABC\n    G = ((A[0] + B[0] + C[0]) / 3, (A[1] + B[1] + C[1]) / 3)\n    # Calculate the centroids of the sub-triangles\n    G1 = ((B[0] + C[0] + G[0]) / 3, (B[1] + C[1] + G[1]) / 3)\n    G2 = ((C[0] + A[0] + G[0]) / 3, (C[1] + A[1] + G[1]) / 3)\n    G3 = ((A[0] + B[0] + G[0]) / 3, (A[1] + B[1] + G[1]) / 3)\n    # Calculate the area of triangle G1G2G3\n    area_G1G2G3 = triangle_area(G1[0], G1[1], G2[0], G2[1], G3[0], G3[1])\n    \n    return area_G1G2G3", "subfield": "Triangles", "tool_name": "centroid_triangle_area", "tool_type": "function", "description": "Calculate the area of the triangle formed by the centroids of triangles PBC, PCA, and PAB,\n    where P is a point inside triangle ABC.", "docstring": "Calculate the area of the triangle formed by the centroids of triangles PBC, PCA, and PAB,\n    where P is a point inside triangle ABC.\n    Parameters:\n    A (tuple): Coordinates of point A (x1, y1).\n    B (tuple): Coordinates of point B (x2, y2).\n    C (tuple): Coordinates of point C (x3, y3).\n    Returns:\n    float: Area of the triangle formed by the centroids of the sub-triangles.", "Freq": 0, "TSR": 0}, {"tool": "def triangle_properties(a, b, c=None):\n    \n    import math\n    \n    def law_of_cosines(a, b, c):\n        \n        return math.degrees(math.acos((a**2 + b**2 - c**2) / (2 * a * b)))\n    if c is not None:\n        # Calculate the angles\n        angle_A = law_of_cosines(b, c, a)\n        angle_B = law_of_cosines(a, c, b)\n        angle_C = law_of_cosines(a, b, c)\n        return max(angle_A, angle_B, angle_C)\n    # If c is not provided, calculate the valid range for the third side\n    min_c = abs(a - b) + 1  # Must be greater than the difference of the two sides\n    max_c = a + b - 1       # Must be less than the sum of the two sides\n    return {'valid_range': (min_c, max_c)}", "subfield": "Triangles", "tool_name": "triangle_properties", "tool_type": "function", "description": "Calculate the largest angle of a triangle given two sides and optionally the third side.\n    Also determines the valid range for the third side based on the other two sides.", "docstring": "Calculate the largest angle of a triangle given two sides and optionally the third side.\n    Also determines the valid range for the third side based on the other two sides.\n    \n    Parameters:\n    a (float): Length of side a.\n    b (float): Length of side b.\n    c (float, optional): Length of side c. If not provided, the function will calculate the largest angle.\n    \n    Returns:\n    dict: A dictionary containing the largest angle in degrees if c is provided, \n           or the valid range for the third side if c is not provided.", "Freq": 1, "TSR": 0}], "Parabolas": [{"tool": "def vertex_from_quadratic(a, b, c):\n    \n    h = -b / (2 * a)\n    k = a * h**2 + b * h + c\n    return h, k", "subfield": "Parabolas", "tool_name": "vertex_from_quadratic", "tool_type": "function", "description": "Calculates the vertex (h, k) of a parabola given its quadratic coefficients.", "docstring": "Calculates the vertex (h, k) of a parabola given its quadratic coefficients.\n    Parameters:\n        a (float): Coefficient of x^2.\n        b (float): Coefficient of x.\n        c (float): Constant term.\n    Returns:\n        tuple: The vertex (h, k) of the parabola.\n    Example:\n        >>> vertex_from_quadratic(1, -4, 4)\n        (2, 0)", "Freq": 2, "TSR": 1}, {"tool": "def parabola_properties(equation):\n    \n    x = sp.symbols('x')\n    a = equation.expand().coeff(x, 2)\n    b = equation.expand().coeff(x, 1)\n    c = equation.expand().coeff(x, 0)\n    # Vertex formula\n    xv = -b / (2 * a)\n    yv = equation.subs(x, xv)\n    vertex = (xv, yv)\n    # Focus and directrix\n    focus_x = xv\n    focus_y = yv + 1/(4*a)\n    focus = (focus_x, focus_y)\n    directrix = yv - 1/(4*a)\n    return {\n        \"vertex\": vertex,\n        \"focus\": focus,\n        \"directrix\": directrix,\n        \"axis of symmetry\": xv\n    }", "subfield": "Parabolas", "tool_name": "parabola_properties", "tool_type": "function", "description": "Given a quadratic equation, compute key properties of the corresponding parabola.", "docstring": "Given a quadratic equation, compute key properties of the corresponding parabola.\n    Parameters:\n    equation (sp.Expr): A sympy expression representing the quadratic equation y = ax^2 + bx + c.\n    Returns:\n    dict: A dictionary containing the vertex, focus, directrix, and axis of symmetry of the parabola.\n    Examples:\n    >>> x, y = sp.symbols('x y')\n    >>> eq = x**2 - 4*x + 4\n    >>> properties = parabola_properties(eq)\n    >>> print(properties[\"vertex\"])\n    (2, 0)\n    >>> print(properties[\"focus\"])\n    (2, 0.25)", "Freq": 6, "TSR": 4}, {"tool": "def tangent_to_parabola(point, equation):\n    \n    x, y = sp.symbols('x y')\n    x0, y0 = point\n    \n    # Derivative to find slope\n    dy_dx = sp.diff(equation, x)\n    slope = dy_dx.subs(x, x0)\n    tangent_eq = y - y0 - slope * (x - x0)\n    \n    return tangent_eq", "subfield": "Parabolas", "tool_name": "tangent_to_parabola", "tool_type": "function", "description": "Find the equation of the tangent line at a given point on the parabola y = ax^2 + bx + c.", "docstring": "Find the equation of the tangent line at a given point on the parabola y = ax^2 + bx + c.\n    Parameters:\n    point (tuple): A tuple (x0, y0) representing the point of tangency.\n    equation (sp.Expr): A sympy expression representing the quadratic parabola.\n    Returns:\n    sp.Expr: An equation representing the tangent line at the given point.\n    Examples:\n    >>> x, y = sp.symbols('x y')\n    >>> eq = x**2 - 6*x + 9\n    >>> point = (3, 0)\n    >>> tangent_line = tangent_to_parabola(point, eq)\n    >>> print(tangent_line)\n    y - 0 = 0*(x - 3)", "Freq": 0, "TSR": 0}, {"tool": "def parabola_line_intersection(a, b, c, line_slope, line_intercept):\n    \n    from numpy import roots\n    from numpy import array\n    \n    # Finding roots of the quadratic equation formed by setting y values equal\n    quadratic = [a, b - line_slope, c - line_intercept]\n    x_roots = roots(quadratic)\n    \n    # Filter only real roots\n    x_roots = x_roots[abs(x_roots.imag) < 1e-6].real\n    y_roots = line_slope * x_roots + line_intercept\n    \n    # Construct the result array\n    points = array(list(zip(x_roots, y_roots)))\n    return points", "subfield": "Parabolas", "tool_name": "parabola_line_intersection", "tool_type": "function", "description": "Computes the intersection points of a parabola y = ax^2 + bx + c with a line y = mx + n.", "docstring": "Computes the intersection points of a parabola y = ax^2 + bx + c with a line y = mx + n.\n    Parameters:\n    a : float\n        Coefficient 'a' of the parabola.\n    b : float\n        Coefficient 'b' of the parabola.\n    c : float\n        Coefficient 'c' of the parabola.\n    line_slope : float\n        Slope 'm' of the line.\n    line_intercept : float\n        Intercept 'n' of the line.\n    Returns:\n    numpy.array\n        Array containing the intersection points (x, y). Can be empty if there are no real intersections.\n    Examples:\n    >>> parabola_line_intersection(1, 0, -1, 1, 0)\n    array([[-1.61803399, -1.61803399], [0.61803399, 0.61803399]])", "Freq": 1, "TSR": 1}, {"tool": "def distance_point_to_line(px, py, a, b, c):\n    \n    return abs(a*px + b*py + c) / np.sqrt(a**2 + b**2)", "subfield": "Parabolas", "tool_name": "distance_point_to_line", "tool_type": "function", "description": "Calculates the distance from a point (px, py) to a line ax + by + c = 0.", "docstring": "Calculates the distance from a point (px, py) to a line ax + by + c = 0.\n    Parameters:\n    px (float): x-coordinate of the point\n    py (float): y-coordinate of the point\n    a (float): coefficient of x in the line equation\n    b (float): coefficient of y in the line equation\n    c (float): constant term of the line equation\n    Returns:\n    float: The distance from the point to the line.\n    Examples:\n    >>> distance_point_to_classes(1, 2, 1, -1, 0)\n    0.7071067811865476", "Freq": 1, "TSR": 1}, {"tool": "def parabola_equation(vertex, point=None, focus=None):\n    \n    x, y = sp.symbols('x y')\n    xv, yv = vertex\n    if point:\n        xp, yp = point\n        a = (yp - yv) / ((xp - xv)**2)\n        return a * (x - xv)**2 + yv\n    if focus:\n        xf, yf = focus\n        a = 1 / (4 * (yf - yv))\n        return a * (x - xv)**2 + yv", "subfield": "Parabolas", "tool_name": "parabola_equation", "tool_type": "function", "description": "Given a vertex and either a point on the parabola or the focus, this function returns the parabola's equation.", "docstring": "Given a vertex and either a point on the parabola or the focus, this function returns the parabola's equation.\n    Parameters:\n    vertex (tuple): A tuple (xv, yv) representing the vertex of the parabola.\n    point (tuple, optional): A tuple (x, y) representing another point on the parabola.\n    focus (tuple, optional): A tuple (xf, yf) representing the focus of the parabola.\n    Returns:\n    sp.Expr: A sympy expression representing the quadratic equation y = ax^2 + bx + c.\n    Examples:\n    >>> vertex = (2, 3)\n    >>> point = (0, 7)\n    >>> equation = parabola_equation(vertex, point=point)\n    >>> print(equation)\n    y = (x - 2)**2 + 3", "Freq": 2, "TSR": 1}, {"tool": "def curve_intersection(eq1, eq2, var1='x', var2='y'):\n    \n    x, y = sp.symbols(var1 + ' ' + var2)\n    intersection_points = sp.solve((eq1, eq2), (x, y))\n    return intersection_points", "subfield": "Parabolas", "tool_name": "curve_intersection", "tool_type": "function", "description": "Calculate intersection points between two curves given by their equations.", "docstring": "Calculate intersection points between two curves given by their equations.\n    \n    Parameters:\n    - eq1 (sp.Expr): The first curve equation in symbols.\n    - eq2 (sp.Expr): The second curve equation in symbols.\n    - var1 (str): The primary variable in the equations (default: 'x').\n    - var2 (str): The secondary variable in the equations (default: 'y').\n    Returns:\n    - list of tuples: List of intersection points.\n    Examples:\n    >>> x, y = sp.symbols('x y')\n    >>> parabola = y - x**2\n    >>> circle = x**2 + y**2 - 5\n    >>> curve_intersection(parabola, circle)\n    [(sqrt(5)/sqrt(3), 5/3), (-sqrt(5)/sqrt(3), 5/3)]", "Freq": 2, "TSR": 2}], "Polygons": [{"tool": "def sum_of_interior_angles(n):\n    \n    return 180 * (n - 2)", "subfield": "Polygons", "tool_name": "sum_of_interior_angles", "tool_type": "function", "description": "Calculate the sum of the interior angles of an n-sided polygon.", "docstring": "Calculate the sum of the interior angles of an n-sided polygon.\n    \n    Parameters\n    ----------\n    n : int\n        Number of sides of the polygon\n    \n    Returns\n    -------\n    int\n        Sum of the interior angles in degrees\n    \n    Examples\n    --------\n    >>> sum_of_interior_angles(4)\n    360\n    \n    >>> sum_of_interior_angles(5)\n    540", "Freq": 12, "TSR": 6}, {"tool": "def exterior_angle_from_interior(interior_angle):\n    \n    return 180 - interior_angle", "subfield": "Polygons", "tool_name": "exterior_angle_from_interior", "tool_type": "function", "description": "Calculate the exterior angle of a polygon from its interior angle.", "docstring": "Calculate the exterior angle of a polygon from its interior angle.\n    Parameters:\n    - interior_angle (float or int): Interior angle of the polygon in degrees.\n    Returns:\n    - float: Exterior angle corresponding to the given interior angle.\n    Examples:\n    >>> exterior_angle_from_interior(90)\n    90.0\n    >>> exterior_angle_from_interior(120)\n    60.0", "Freq": 1, "TSR": 0}, {"tool": "def distance_between_points(p1, p2):\n    \n    return math.sqrt((p2[0] - p1[0])**2 + (p2[1] - p1[1])**2)", "subfield": "Polygons", "tool_name": "distance_between_points", "tool_type": "function", "description": "Calculate the Euclidean distance between two points in the Cartesian plane.", "docstring": "Calculate the Euclidean distance between two points in the Cartesian plane.\n    Parameters\n    ----------\n    p1 : tuple of float\n        Coordinates (x, y) of the first point.\n    p2 : tuple of float\n        Coordinates (x, y) of the second point.\n    Returns\n    -------\n    float\n        Distance between the two points.\n    Examples\n    --------\n    >>> distance_between_points((1, 2), (4, 6))\n    5.0", "Freq": 1, "TSR": 1}, {"tool": "def polygon_exterior_angle(n):\n    \n    if n < 3:\n        raise ValueError(\"A polygon must have at least 3 sides.\")\n    return 360 / n", "subfield": "Polygons", "tool_name": "polygon_exterior_angle", "tool_type": "function", "description": "Calculate the exterior angle of an n-sided regular polygon.", "docstring": "Calculate the exterior angle of an n-sided regular polygon.\n    \n    Parameters:\n    - n: int, number of sides of the polygon\n    \n    Returns:\n    - float, measure of the exterior angle in degrees", "Freq": 3, "TSR": 0}, {"tool": "def polygon_angle_properties(n, angle_type='interior'):\n    \n    import math\n    if angle_type == 'interior':\n        if n < 3:\n            raise ValueError(\"A polygon must have at least 3 sides.\")\n        return (n - 2) * 180.0 / n\n    elif angle_type == 'exterior':\n        if n < 3:\n            raise ValueError(\"A polygon must have at least 3 sides.\")\n        return 360.0 / n\n    elif angle_type == 'solve_for_n_interior':\n        # 180(n - 2) / n = angle\n        # 180n - 360 = n * angle\n        # 180n - n * angle = 360\n        # n(180 - angle) = 360\n        # n = 360 / (180 - angle)\n        return round(360 / (180 - n))\n    elif angle_type == 'solve_for_n_exterior':\n        # 360 / n = angle\n        # n = 360 / angle\n        return round(360 / n)\n    else:\n        raise ValueError(\"Invalid angle_type specified. Choose 'interior', 'exterior', 'solve_for_n_interior' or 'solve_for_n_exterior'.\")\n    return None", "subfield": "Polygons", "tool_name": "polygon_angle_properties", "tool_type": "function", "description": "Calculate properties of angles in a regular polygon, including each individual angle and solving for 'n' given an angle.", "docstring": "Calculate properties of angles in a regular polygon, including each individual angle and solving for 'n' given an angle.\n    Parameters:\n    - n (int or float): Number of sides of the polygon, or an interior/exterior angle degree if solving for 'n'.\n    - angle_type (str): Type of calculation - 'interior', 'exterior', or 'solve_for_n_interior','solve_for_n_exterior'.\n    Returns:\n    - float or int: Depending on the angle_type, returns the degree of each angle or the number of sides.\n    Examples:\n    >>> polygon_angle_properties(4)\n    90.0\n    >>> polygon_angle_properties(90, 'solve_for_n_interior')\n    4\n    >>> polygon_angle_properties(45, 'solve_for_n_exterior')\n    8", "Freq": 6, "TSR": 2}, {"tool": "def polygon_diagonals(n):\n    \n    if n < 3:\n        raise ValueError(\"A polygon must have at least 3 sides.\")\n    return n * (n - 3) // 2", "subfield": "Polygons", "tool_name": "polygon_diagonals", "tool_type": "function", "description": "Calculate the number of diagonals in an n-sided polygon.", "docstring": "Calculate the number of diagonals in an n-sided polygon.\n    \n    Parameters:\n    - n: int, number of sides of the polygon\n    \n    Returns:\n    - int, number of diagonals", "Freq": 3, "TSR": 2}, {"tool": "def area_hexagon(side_length):\n    \"\"\"\n    Calculate the area of a regular hexagon given the side length.\n    \n    Parameters:\n    - side_length: float, the length of each side of the hexagle", "subfield": "Polygons", "tool_name": "area_hexagon", "tool_type": "function", "description": "Calculate the area of a regular hexagon given the side length.", "docstring": "Calculate the area of a regular hexagon given the side length.\n    \n    Parameters:\n    - side_length: float, the length of each side of the hexagle", "Freq": 0, "TSR": 0}, {"tool": "def area_square(side_length):\n    \n    return side_length ** 2", "subfield": "Polygons", "tool_name": "area_square", "tool_type": "function", "description": "Calculate the area of a square given the side length.", "docstring": "Calculate the area of a square given the side length.\n    \n    Parameters:\n    - side_length: float, the length of each side of the square\n    \n    Returns:\n    - float, the area of the square", "Freq": 0, "TSR": 0}, {"tool": "def polygon_area(n, side_length):\n    \n    if n < 3 or side_length <= 0:\n        raise ValueError(\"Invalid number of sides or side length.\")\n    apothem = side_length / (2 * tan(pi / n))\n    return 0.5 * n * side_length * apothem", "subfield": "Polygons", "tool_name": "polygon_area", "tool_type": "function", "description": "Calculate the area of a regular n-sided polygon given the side length.", "docstring": "Calculate the area of a regular n-sided polygon given the side length.\n    \n    Parameters:\n    - n: int, number of sides of the polygon\n    - side_length: float, length of one side of the polygon\n    \n    Returns:\n    - float, area of the polygon", "Freq": 0, "TSR": 0}, {"tool": "def calculate_triangle_area(base, height):\n    \n    return 0.5 * base * height", "subfield": "Polygons", "tool_name": "calculate_triangle_area", "tool_type": "function", "description": "Calculate the area of a triangle.", "docstring": "Calculate the area of a triangle.\n    Parameters\n    ----------\n    base: float\n        The length of the base.\n    height: float\n        The length of the height.\n    Returns\n    -------\n    float\n        The area of the triangle.\n    Example\n    -------\n        >>> calculate_triangle_area(10, 5)\n        25.0", "Freq": 0, "TSR": 0}, {"tool": "def calculate_hypotenuse(a, b):\n    \n    return math.sqrt(a**2 + b**2)", "subfield": "Polygons", "tool_name": "calculate_hypotenuse", "tool_type": "function", "description": "Calculate the hypotenuse of a right-angle triangle.", "docstring": "Calculate the hypotenuse of a right-angle triangle.\n    Parameters\n    ----------\n    a: float\n        The length of one leg of the triangle.\n    b: float\n        The length of the other leg of the triangle.\n    Returns\n    -------\n    float\n        The length of the hypotenuse.\n    Example\n    -------\n        >>> calculate_hypotenuse(3, 4)\n        5.0", "Freq": 0, "TSR": 0}], "Right Triangles": [{"tool": "def calculate_hypotenuse(leg1, leg2):\n    \n    return math.sqrt(leg1**2 + leg2**2)", "subfield": "Right Triangles", "tool_name": "calculate_hypotenuse", "tool_type": "function", "description": "Computes the length of the hypotenuse of a right triangle given the lengths of the other two legs.", "docstring": "Computes the length of the hypotenuse of a right triangle given the lengths of the other two legs.\n    Parameters:\n    leg1 (float): Length of the first leg of the triangle.\n    leg2 (float): Length of the second leg of the triangle.\n    Returns:\n    float: The length of the hypotenuse.\n    Examples:\n    >>> calculate_hypotenuse(3, 4)\n    5.0", "Freq": 4, "TSR": 4}, {"tool": "def calculate_right_triangle_side(a=None, b=None, c=None):\n    \n    import math\n    if c is None:\n        # Calculate hypotenuse\n        return math.sqrt(a ** 2 + b ** 2)\n    elif a is None:\n        # Calculate missing side a\n        return math.sqrt(c ** 2 - b ** 2)\n    elif b is None:\n        # Calculate missing side b\n        return math.sqrt(c ** 2 - a ** 2)\n    else:\n        raise ValueError(\"One and only one side length must be None.\")", "subfield": "Right Triangles", "tool_name": "calculate_right_triangle_side", "tool_type": "function", "description": "Calculate the missing side of a right triangle using the Pythagorean Theorem.", "docstring": "Calculate the missing side of a right triangle using the Pythagorean Theorem.\n    \n    Parameters:\n        a (float): The length of side a, or None if it is the unknown side.\n        b (float): The length of side b, or None if it is the unknown side.\n        c (float): The length of the hypotenuse c, or None if it is the unknown side.\n    \n    Returns:\n        float: The length of the missing side.\n        \n    Examples:\n        calculate_right_triangle_side(a=3, b=4)  # Should return 5 as the hypotenuse\n        calculate_right_triangle_side(a=3, c=5)  # Should return 4 as the other side\n        calculate_right_triangle_side(b=4, c=5)  # Should return 3 as the other side", "Freq": 11, "TSR": 7, "experience_pool": "- When finding the distance between two points, ensure that the coordinates are correctly assigned before calling the tool function.\n- When calculating the value of x in a line segment, make sure to calculate the missing side correctly before assigning it to the variable x.\n- When solving trigonometric problems, ensure that the input parameters are correctly used in the calculations."}, {"tool": "def calculate_area(leg1, leg2):\n    \n    return 0.5 * leg1 * leg2", "subfield": "Right Triangles", "tool_name": "calculate_area", "tool_type": "function", "description": "Computes the area of a right triangle.", "docstring": "Computes the area of a right triangle.\n    Parameters:\n    leg1 (float): Length of the first leg of the triangle.\n    leg2 (float): Length of the second leg of the triangle.\n    Returns:\n    float: The area of the right triangle.\n    Examples:\n    >>> calculate_area(3, 4)\n    6.0", "Freq": 1, "TSR": 0}, {"tool": "def is_right_triangle(x1, y1, x2, y2, x3, y3):\n    \n    def distance_sq(xa, ya, xb, yb):\n        return (xb - xa) ** 2 + (yb - ya) ** 2\n    d1_sq = distance_sq(x1, y1, x2, y2)\n    d2_sq = distance_sq(x2, y2, x3, y3)\n    d3_sq = distance_sq(x3, y3, x1, y1)\n    if (d1_sq + d2_sq == d3_sq) or (d2_sq + d3_sq == d1_sq) or (d1_sq + d3_sq == d2_sq):\n        return True\n    else:\n        return False", "subfield": "Right Triangles", "tool_name": "is_right_triangle", "tool_type": "function", "description": "Determines if the points (x1, y1), (x2, y2), (x3, y3) form a right triangle in a 2D plane.", "docstring": "Determines if the points (x1, y1), (x2, y2), (x3, y3) form a right triangle in a 2D plane.\n    \n    Parameters:\n    - x1, y1 (float): Coordinates of the first point.\n    - x2, y2 (float): Coordinates of the second point.\n    - x3, y3 (float): Coordinates of the third point.\n    \n    Returns:\n    - bool: True if the points form a right triangle, False otherwise.\n    \n    Examples:\n    - is_right_triangle(0, 0, 3, 0, 0, 4) -> True\n    - is_right_triangle(1, 1, 1, 5, 1, 9) -> False", "Freq": 0, "TSR": 0}, {"tool": "def is_right_triangle(ax, ay, bx, by, cx, cy):\n    \n    # Calculate squared distances between points\n    AB2 = (bx - ax)**2 + (by - ay)**2\n    AC2 = (cx - ax)**2 + (cy - ay)**2\n    BC2 = (cx - bx)**2 + (cy - by)**2\n    \n    # Check for the Pythagorean relationship between the sides\n    return (AB2 + AC2 == BC2) or (AB2 + BC2 == AC2) or (AC2 + BC2 == AB2)", "subfield": "Right Triangles", "tool_name": "is_right_triangle", "tool_type": "function", "description": "Determines if a triangle formed by three points is a right triangle using distance formula.", "docstring": "Determines if a triangle formed by three points is a right triangle using distance formula.\n    \n    Parameters:\n        ax, ay (float): Coordinates of the first vertex A.\n        bx, by (float): Coordinates of the second vertex B.\n        cx, cy (float): Coordinates of the third vertex C.\n    \n    Returns:\n        bool: True if the triangle is a right triangle, False otherwise.\n    \n    Examples:\n        >>> is_right_triangle(0, 0, 3, 0, 0, 4)\n        True\n        >>> is_right_triangle(0, 0, 2, 2, 4, 0)\n        False", "Freq": 0, "TSR": 0}, {"tool": "def is_right_triangle(side1, side2, side3):\n    \n    sides = sorted([side1, side2, side3])\n    return math.isclose(sides[2]**2, sides[0]**2 + sides[1]**2)", "subfield": "Right Triangles", "tool_name": "is_right_triangle", "tool_type": "function", "description": "Determines whether the given sides can form a right triangle.", "docstring": "Determines whether the given sides can form a right triangle.\n    Parameters:\n    side1, side2, side3 (float): The lengths of the sides of the triangle.\n    Returns:\n    bool: True if the given sides can form a right triangle, False otherwise.\n    Examples:\n    >>> is_right_triangle(3, 4, 5)\n    True\n    >>> is_right_riangle(1, 2, 3)\n    False", "Freq": 0, "TSR": 0}, {"tool": "def pythagorean_theorem(known_side1, known_side2, find='hypotenuse'):\n    \n    if find == 'hypotenuse':\n        return math.sqrt(known_side1**2 + known_side2**2)\n    elif find == 'leg':\n        if known_side1 > known_side2:\n            return math.sqrt(known_side1**2 - known_side2**2)\n        else:\n            return math.sqrt(known_side2**2 - known_side1**2)\n    else:\n        raise ValueError(\"Invalid option for 'find'. Choose 'hypotenuse' or 'leg'.\")", "subfield": "Right Triangles", "tool_name": "pythagorean_theorem", "tool_type": "function", "description": "Solves for a side of a right triangle using the Pythagorean theorem.", "docstring": "Solves for a side of a right triangle using the Pythagorean theorem.\n    \n    Parameters:\n        known_side1 (float): Length of first known side.\n        known_side2 (float): Length of second known side.\n        find (str, optional): Which side to find; choices are 'hypotenuse' or 'leg'. Default is 'hypotenuse'.\n    \n    Returns:\n        float: Length of the unknown side.\n        \n    Examples:\n        >>> pythagorean_theorem(3, 4)\n        5.0\n        >>> pythagorean_theorem(5, 4, find='leg')\n        3.0", "Freq": 2, "TSR": 1}, {"tool": "def find_missing_side(known_sides):\n    \n    a, b, c = known_sides\n    if a is None:\n        return math.sqrt(c**2 - b**2)\n    elif b is None:\n        return math.sqrt(c**2 - a**2)\n    else:  # c is None\n        return math.sqrt(a**2 + b**2)", "subfield": "Right Triangles", "tool_name": "find_missing_side", "tool_type": "function", "description": "Finds the missing side of a right triangle given the other two sides.", "docstring": "Finds the missing side of a right triangle given the other two sides.\n    \n    Parameters:\n    known_sides (list of float or None): List of two known sides and one None indicating the missing side.\n    \n    Returns:\n    float: The missing side of the right triangle.\n    \n    Examples:\n    >>> find_missing_side([3, 4, None])\n    5.0\n    >>> find_missing_side([None, 4, 5])\n    3.0", "Freq": 0, "TSR": 0}, {"tool": "def has_right_angles(ax, ay, bx, by, cx, cy, dx, dy):\n    \n    def dot_product_zero(x1, y1, x2, y2):\n        return x1 * x2 + y1 * y2 == 0\n    # Vectors for AB, BC, CD, DA\n    ABx, ABy = bx - ax, by - ay\n    BCx, BCy = cx - bx, cy - by\n    CDx, CDy = dx - cx, dy - cy\n    DAx, DAy = ax - dx, ay - dy\n    \n    # Check right angles at B, C, D respectively using dot product\n    return (dot_product_zero(ABx, ABy, BCx, BCy) and \n            dot_product_zero(BCx, BCy, CDx, CDy) and \n            dot_product_zero(CDx, CDy, DAx, DAy))", "subfield": "Right Triangles", "tool_name": "has_right_angles", "tool_type": "function", "description": "Checks whether a quadrilateral has right angles at every vertex based on coordinates.", "docstring": "Checks whether a quadrilateral has right angles at every vertex based on coordinates.\n    Parameters:\n        ax, ay (float): Coordinates of the first vertex A.\n        bx, by (float): Coordinates of the second vertex B.\n        cx, cy (float): Coordinates of the third vertex C.\n        dx, dy (float): Coordinates of the fourth vertex D.\n    \n    Returns:\n        bool: True if all angles in the quadrilateral are right angles, False otherwise.\n    \n    Examples:\n        >>> has_right_angles(0, 0, 4, 0, 4, 3, 0, 3)\n        True\n        >>> has_right_angles(0, 0, 4, 0, 5, 3, 1, 3)\n        False", "Freq": 0, "TSR": 0}, {"tool": "def right_triangle_solver(leg1=None, leg2=None, hypotenose=None):\n    \n    if hypotenose and leg1 and leg2 is None:\n        leg2 = sqrt(pow(hypotenose, 2) - pow(leg1, 2))\n        return leg1, leg2, hypotenose\n    elif hypotenose and leg2 and leg1 is None:\n        leg1 = sqrt(pow(hypotenose, 2) - pow(leg2, 2))\n        return leg1, leg2, hypotenose\n    elif leg1 and leg2 and hypotenose is None:\n        hypotenose = sqrt(pow(leg1, 2) + pow(leg2, 2))\n        return leg1, leg2, hypotenose\n    else:\n        raise ValueError(\"Two sides must be provided to solve for the third.\")", "subfield": "Right Triangles", "tool_name": "right_triangle_solver", "tool_type": "function", "description": "Solve any right triangle by determining missing side lengths.", "docstring": "Solve any right triangle by determining missing side lengths.\n    Parameters:\n    leg1 (float, optional): First leg of the triangle.\n    leg2 (float, optional): Second leg of the triangle.\n    hypotenose (float, optional): Hypotenose of the triangle.\n    Returns:\n    tuple: A tuple containing the values (leg1, leg2, hypotenose).\n    Examples:\n    >>> right_triangle_solver(leg1=3, leg2=4)\n    (3, 4, 5.0)\n    >>> right_triangle_solver(leg1=3, hypotenose=5)\n    (3, 4.0, 5)\n    >>> right_triangle_solver(leg2=4, hypotenose=5)\n    (3.0, 4, 5)", "Freq": 0, "TSR": 0}, {"tool": "def triangle_and_rectangle_solver(opposite=None, hypotenuse=None, adjacent=None, rectangle_length=None, rectangle_diagonal=None):\n    \n    \n    import math\n    \n    results = {}\n    \n    # Calculate cosine from sine if opposite and hypotenuse are provided\n    if opposite is not None and hypotenuse is not None:\n        cosine_value = math.sqrt(1 - (opposite / hypotenuse) ** 2)\n        results['cosine'] = cosine_value\n    \n    # Calculate the area of the rectangle if length and diagonal are provided\n    if rectangle_length is not None and rectangle_diagonal is not None:\n        # Use the Pythagorean theorem to find the width of the rectangle\n        width = math.sqrt(rectangle_diagonal ** 2 - rectangle_length ** 2)\n        area = rectangle_length * width\n        results['rectangle_area'] = area\n    \n    return results", "subfield": "Right Triangles", "tool_name": "triangle_and_rectangle_solver", "tool_type": "function", "description": "This function computes trigonometric values based on the sides of a right triangle\n    and calculates the area of a rectangle given its length and diagonal.", "docstring": "This function computes trigonometric values based on the sides of a right triangle\n    and calculates the area of a rectangle given its length and diagonal.\n    \n    Parameters:\n    - opposite: Length of the side opposite the angle (for sine calculations).\n    - hypotenuse: Length of the hypotenuse (for sine and cosine calculations).\n    - adjacent: Length of the side adjacent to the angle (for cosine calculations).\n    - rectangle_length: Length of the rectangle.\n    - rectangle_diagonal: Diagonal of the rectangle.\n    \n    Returns:\n    - A dictionary containing the cosine of the angle if sufficient information is provided,\n      and the area of the rectangle if its dimensions are provided.", "Freq": 1, "TSR": 1}], "Lines and Angles": [{"tool": "def line_equation(point1, point2):\n    \n    x1, y1 = point1\n    x2, y2 = point2\n    A = y2 - y1\n    B = x1 - x2\n    C = A*x1 + B*y1\n    return (A, -B, C)", "subfield": "Lines and Angles", "tool_name": "line_equation", "tool_type": "function", "description": "Return the coefficients of the line equation in the form Ax + By = C using two points.", "docstring": "Return the coefficients of the line equation in the form Ax + By = C using two points.\n    Parameters:\n    point1 (tuple): (x1, y1) coordinates of the first point.\n    point2 (tuple): (x2, y2) coordinates of the second point.\n    \n    Returns:\n    tuple: Coefficients (A, B, C) representing the line Ax + By = C.\n    \n    Examples:\n    >>> line_equation((1, 2), (3, 4))\n    (2, -2, 0)", "Freq": 3, "TSR": 1, "experience_pool": "Tool for calculating line equation is working correctly based on the provided code and examples."}, {"tool": "def find_intersection_of_lines(line1, line2):\n    \n    x, y = symbols('x y')\n    result = solve((line1, line2), (x, y))\n    if result:\n        return (result[x], result[y])\n    return None", "subfield": "Lines and Angles", "tool_name": "find_intersection_of_lines", "tool_type": "function", "description": "Finds the intersection point of two lines, if they intersect.", "docstring": "Finds the intersection point of two lines, if they intersect.\n    \n    Parameters:\n    - line1: sympy.Eq, the equation of the first line.\n    - line2: sympy.Eq, the equation of the second line.\n    Returns:\n    - tuple or None: The (x, y) coordinates of the intersection point or None if no intersection.\n    Example:\n    >>> find_intersection_of_lines(Eq(y, 2*x + 1), Eq(y, -x + 4))\n    (1, 3)", "Freq": 5, "TSR": 0, "experience_pool": "Tool code updated to handle the intersection of lines correctly and prevent dimension errors."}, {"tool": "def calculate_side_length(a, b, angle_C):\n    \n    # Converting angle from degrees to radians\n    angle_C_rad = np.deg2rad(angle_C)\n    \n    # Using Law of Cosines: c^2 = a^2 + b^2 - 2ab*cos(C)\n    c = np.sqrt(a**2 + b**2 - 2*a*b*np.cos(angle_C_rad))\n    return c", "subfield": "Lines and Angles", "tool_name": "calculate_side_length", "tool_type": "function", "description": "Calculate the length of a side in a triangle using the Law of Cosines.", "docstring": "Calculate the length of a side in a triangle using the Law of Cosines.\n    Parameters:\n    a (float): Length of the first side of the triangle.\n    b (float): Length of the second side of the triangle.\n    angle_C (float): Angle opposite the side to be calculated, in degrees.\n    Returns:\n    float: The length of the third side.\n    Examples:\n    >>> calculate_side_length(5, 7, 45)\n    3.80788655293", "Freq": 3, "TSR": 0, "experience_pool": "Tool for calculating side length in a triangle using the Law of Cosines is accurate and efficient."}, {"tool": "def calculate_distance(x1, y1, x2, y2):\n    \n    return math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2)", "subfield": "Lines and Angles", "tool_name": "calculate_distance", "tool_type": "function", "description": "Calculate the Euclidean distance between two points in the 2D coordinate plane.", "docstring": "Calculate the Euclidean distance between two points in the 2D coordinate plane.\n    Parameters:\n    x1, y1 (float): Coordinates of the first point.\n    x2, y2 (float): Coordinates of the second point.\n    Returns:\n    float: The distance between the two points.\n    Examples:\n    >>> calculate_distance(0, 0, 3, 4)\n    5.0", "Freq": 2, "TSR": 2}, {"tool": "def find_midpoint(point1, point2):\n    \n    midpoint = ((point1[0] + point2[0]) / 2, (point1[1] + point2[1]) / 2)\n    return midpoint", "subfield": "Lines and Angles", "tool_name": "find_midpoint", "tool_type": "function", "description": "Calculate the midpoint between two points in a 2D space.", "docstring": "Calculate the midpoint between two points in a 2D space.\n    Parameters:\n    point1 (tuple): The (x, y) coordinates of the first point.\n    point2 (tuple): The (x, y) coordinates of the second point.\n    Returns:\n    tuple: The (x, y) coordinates of the midpoint.\n    Example:\n    >>> find_midpoint((0, 0), (2, 2))\n    (1.0, 1.0)", "Freq": 2, "TSR": 0}, {"tool": "def calculate_supplementary_angle(angle):\n    \n    return 180 - angle", "subfield": "Lines and Angles", "tool_name": "calculate_supplementary_angle", "tool_type": "function", "description": "Calculate the supplementary angle to the given angle (Adds up to 180 degrees).", "docstring": "Calculate the supplementary angle to the given angle (Adds up to 180 degrees).\n    Parameters:\n    angle (float): An angle in degrees.\n    Returns:\n    float: The supplementary angle.\n    Examples:\n    >>> calculate_supplementray_angle(30)\n    150.0\n    >>> calculate_supplementary_angle(90)\n    90.0", "Freq": 3, "TSR": 3}, {"tool": "def find_linear_equation(x1, y1, x2, y2):\n    \n    slope = (y2 - y1) / (x2 - x1) if x2 != x1 else float('inf')\n    intercept = y1 - slope * x1\n    return (slope, intercept)", "subfield": "Lines and Angles", "tool_name": "find_linear_equation", "tool_type": "function", "description": "Calculate the slope-intercept form equation of a line given two points (x1, y1) and (x2, y2).", "docstring": "Calculate the slope-intercept form equation of a line given two points (x1, y1) and (x2, y2).\n    Parameters:\n    - x1, y1, x2, y2 (float): Coordinates of two points on the line.\n    Returns:\n    - tuple: coefficients of slope and constant (m, c) of the line y = mx + c\n    Examples:\n    - find_linear_equation(1, 2, 3, 8)", "Freq": 2, "TSR": 1}, {"tool": "def angle_between_vectors(vector1, vector2):\n    \n    dot_product = np.dot(vector1, vector2)\n    magnitude_product = np.linalg.norm(vector1) * np.linalg.norm(vector2)\n    angle_rad = math.acos(dot_product / magnitude_product)\n    angle_deg = math.degrees(angle_rad)\n    return angle_deg", "subfield": "Lines and Angles", "tool_name": "angle_between_vectors", "tool_type": "function", "description": "Calculate the angle in degrees between two vectors in 2D space.", "docstring": "Calculate the angle in degrees between two vectors in 2D space.\n    Parameters:\n    vector1 (tuple): The components (x, y) of the first vector.\n    vector2 (tuple): The components (x, y) of the second vector.\n    Returns:\n    float: The angle in degrees.\n    Example:\n    >>> angle_between_vectors((1, 0), (0, 1))\n    90.0", "Freq": 2, "TSR": 0}, {"tool": "def check_parallelism(line1_coeffs, line2_coeffs):\n    \n    A1, B1 = line1_coeffs\n    A2, B2 = line2_coeffs\n    return np.isclose(A1 * B2, A2 * B1)", "subfield": "Lines and Angles", "tool_name": "check_parallelism", "tool_type": "function", "description": "Checks whether two lines are parallel.", "docstring": "Checks whether two lines are parallel.\n    Parameters:\n    line1_coeffs (tuple/list): Coefficients (A, B) of the first line (Ax + By = C).\n    line2_coeffs (tuple/list): Coefficients (A, B) of the second line (Ax + By = C).\n    Returns:\n    bool: True if lines are parallel, False otherwise.\n    Example:\n    >>> check_parallelism((1, -2), (2, -4))\n    True\n    >>> check_parallelism((1, 2), (2, -5))\n    False", "Freq": 2, "TSR": 1}, {"tool": "def radians_to_degrees(radians):\n    \n    return math.degrees(radians)", "subfield": "Lines and Angles", "tool_name": "radians_to_degrees", "tool_type": "function", "description": "Converts an angle from radians to degrees.", "docstring": "Converts an angle from radians to degrees.\n    Parameters:\n    radians (float): The angle in radians.\n    Returns:\n    degrees (float): The angle in degrees.\n    Examples:\n    >>> radians_to_degrees(math.pi)\n    180.0", "Freq": 0, "TSR": 0}, {"tool": "def angle_between_lines(line1, line2):\n    \n    # Extract coefficients\n    a1, b1, _ = line1\n    a2, b2, _ = line2\n    # Calculating angle using the formula:\n    # tan(theta) = |(m2-m1)/(1+m1*m2)|  where m = -a/b for each line\n    numerator = np.abs(a2 * b1 - a1 * b2)\n    denominator = np.abs(a1 * b2 + a2 * b1)\n    angle_rad = np.arctan(numerator / denominator)\n    angle_deg = np.degrees(angle_rad)\n    return angle_deg", "subfield": "Lines and Angles", "tool_name": "angle_between_lines", "tool_type": "function", "description": "Calculate the angle in degrees between two lines given their coefficients.", "docstring": "Calculate the angle in degrees between two lines given their coefficients.\n    Parameters:\n    line1 (tuple): Coefficients (a, b, c) of the first line in the form ax + by + c = 0.\n    line2 (tuple): Coefficients (a, b, c) of the second line in the form ax + by + c = 0.\n    Returns:\n    float: Angle in degrees between the two lines.\n    Example:\n    >>> angle_between_lines((1, -1, 0), (1, 1, 0))\n    90.0", "Freq": 1, "TSR": 0}, {"tool": "def are_complementary(*angles):\n    \n    import numpy as np  # Importing Numpy for numerical operations\n    if np.isclose(sum(angles), 90):\n        return True\n    else:\n        return False", "subfield": "Lines and Angles", "tool_name": "are_complementary", "tool_type": "function", "description": "Check if the provided angles sum up to 90 degrees, thus are complementary.", "docstring": "Check if the provided angles sum up to 90 degrees, thus are complementary.\n    \n    Parameters:\n        angles (float or int): a variable number of angle measures\n    \n    Returns:\n        bool: True if the sum of angles is 90 degrees, False otherwise.\n        \n    Examples:\n        >>> are_complementary(30, 60)\n        True\n        >>> are_complementary(45, 45)\n        True\n        >>> are_complementary(90, 0)\n        True\n        >>> are_complementary(50, 40, 10)\n        False", "Freq": 0, "TSR": 0}, {"tool": "def calculate_angle_relations(parallel, transversal, known_angle, angle_type):\n    \n    from math import fmod\n    if not transversal:\n        return \"No transversal line present!\"\n    if parallel:\n        if angle_type == 'corresponding' or angle_type == 'alternate':\n            return known_angle\n        elif angle_type == 'supplementary':\n            return 180 - known_angle\n    else:\n        if angle_type == 'corresponding':\n            # Non-parallel lines can have non-equal corresponding angles, dependent on geometry.\n            return None\n        elif angle_type == 'alternate':\n            # Still equal if the lines aren't intersected by a curve or such.\n            return known_angle\n        elif angle_type == 'supplementary':\n            return 180 - known_angle\n    return None", "subfield": "Lines and Angles", "tool_name": "calculate_angle_relations", "tool_type": "function", "description": "Calculate angles such as corresponding, supplementary, or alternate when dealing\n    with two lines and a transversal, focusing on situations where lines might be parallel.", "docstring": "Calculate angles such as corresponding, supplementary, or alternate when dealing\n    with two lines and a transversal, focusing on situations where lines might be parallel.\n    \n    Parameters:\n        parallel (bool): A flag indicating whether the two lines are parallel.\n        transversal (bool): A flag indicating if there is a transversal intersecting the two lines.\n        known_angle (int or float): A known angle measurement in degrees.\n        angle_type (str): A descriptive type of the angle relation to compute:\n                          'corresponding', 'supplementary', or 'alternate'.\n    Returns:\n        float: The calculated angle in degrees based upon the type and parallelism.\n    Examples:\n        >>> calculate_angle_relations(True, True, 30, 'corresponding')\n        30\n        >>> calculate_angle_relations(True, True, 150, 'supplementary')\n        30\n        >>> calculate_angle_relations(True, True, 60, 'alternate')\n        60", "Freq": 2, "TSR": 2}, {"tool": "def triangle_angle_solver(angle1, angle2=None, angle3=None):\n    \n    if angle1 is not None and angle2 is not None:\n        angle3 = 180 - angle1 - angle2\n    elif angle1 is not None and angle3 is not None:\n        angle2 = 180 - angle1 - angle3\n    elif angle2 is not None and angle3 is not None:\n        angle1 = 180 - angle2 - angle3\n    else:\n        raise ValueError(\"At least two angles must be provided\")\n      \n    return angle1, angle2, angle3", "subfield": "Lines and Angles", "tool_name": "triangle_angle_solver", "tool_type": "function", "description": "Calculates the missing angles in a triangle given at least one known angle.", "docstring": "Calculates the missing angles in a triangle given at least one known angle.\n    \n    Parameters:\n    angle1: float or None\n        The degree of the first angle. If set to None, it's considered unknown.\n    angle2: float or None\n        The degree of the second angle. If None, calculated from other angles.\n    angle3: float or None\n        The degree of the third angle. If None, calculated from other angles.\n    \n    Returns:\n    tuple\n        A tuple (a1, a2, a3) representing the angles of the triangle.\n        \n    Examples:\n    >>> triangle_angle_solver(90, 30)\n    (90, 30, 60)\n    >>> triangle_angle_solver(45, 45)\n    (45, 45, 90)", "Freq": 3, "TSR": 0}, {"tool": "def angle_between_parallel_lines(angle_one, is_supplementary=False):\n    \n    if is_supplementary:\n        return angle_one\n    else:\n        return 180 - angle_one", "subfield": "Lines and Angles", "tool_name": "angle_between_parallel_lines", "tool_type": "function", "description": "Determines angles formed when two parallel lines are intersected by a transversal.", "docstring": "Determines angles formed when two parallel lines are intersected by a transversal.\n    \n    Parameters:\n        angle_one : float or sympy.Expr\n            The measure of one of the given angles in degrees.\n        is_supplementary : bool, optional\n            Determines if the function should return the supplementary angle (default is False).\n            \n    Returns:\n        float or sympy.Expr\n            Returns the corresponding angle measure based on properties of parallel lines.\n            If `is_supplementary` is True, returns the supplementary angle to angle_one.\n    \n    Examples:\n        >>> angle_between_parallel_lines(50)\n        130\n        >>> angle_between_parallel_lines(50, True)\n        50\n        >>> angle_between_parallel_lines(sp.Symbol('x') + 10)\n        170 - x", "Freq": 2, "TSR": 2}, {"tool": "def calculate_vertical_angle(given_angle):\n    \n    return given_angle", "subfield": "Lines and Angles", "tool_name": "calculate_vertical_angle", "tool_type": "function", "description": "Calculate the vertical angle given one angle. Vertical angles are equal when two lines intersect.", "docstring": "Calculate the vertical angle given one angle. Vertical angles are equal when two lines intersect.\n    Parameters:\n    given_angle (float): The given angle in degrees.\n    Returns:\n    float: The vertical angle which is equal to the given angle.\n    Example:\n    >>> calculate_vertical_angle(45)\n    45.0", "Freq": 0, "TSR": 0}, {"tool": "def check_line_properties(line1_coeff, line2_coeff, check_type='parallel'):\n    \n    A1, B1, C1 = line1_coeff\n    A2, B2, C2 = line2_coeff\n    \n    if check_type == 'parallel':\n        return A1*B2 == A2*B1\n    elif check_type == 'perpendicular':\n        return -A1*A2 == B1*B2\n    elif check_type == 'intersection':\n        determinant = A1*B2 - A2*B1\n        if determinant == 0:\n            return False  # Lines are parallel or coincident, no single intersection\n        else:\n            x = (B2*C1 - B1*C2) / determinant\n            y = (A1*C2 - A2*C1) / determinant\n            return (x, y)\n    return False", "subfield": "Lines and Angles", "tool_name": "check_line_properties", "tool_type": "function", "description": "Determine if two lines are parallel or perpendicular, or find the intersection point.", "docstring": "Determine if two lines are parallel or perpendicular, or find the intersection point.\n    \n    Parameters:\n        line1_coeff (tuple): Coefficients (A, B, C) of the first line in the form Ax + By = C.\n        line2_coeff (tuple): Coefficients (A, B, C) of the second line.\n        check_type (str): Type of property to check: 'parallel', 'perpendicular', 'intersection'.\n    Returns:\n        bool or tuple: Depending on 'check_type', returns boolean for parallel or perpendicular,\n                       and tuple (x, y) for intersection point if lines intersect.\n                       \n    Examples:\n        >>> check_line_properties((1, -1, 0), (2, -2, 0))\n        True  # Lines are parallel\n        >>> check_line_properties((1, -1, 0), (1, 1, 0), 'perpendicular')\n        True  # Lines are perpendicular\n        >>> check_line_properties((1, -1, 0), (1, 1, 2), 'intersection')\n        (1, 1)  # Intersection point", "Freq": 5, "TSR": 2, "experience_pool": "The tool for checking line properties is functioning correctly. The issues in the code provided are due to incorrect usage in the calling code, not the tool itself."}, {"tool": "def angle_between_tangent_and_radius(point_of_tangency, center_of_circle):\n    \n    # For a circle, the angle between the radius to the point of tangency and the tangent at that point is always 90 degrees.\n    return 90.0", "subfield": "Lines and Angles", "tool_name": "angle_between_tangent_and_radius", "tool_type": "function", "description": "Calculate the angle formed at the point of tangency between the tangent to a circle and the radius.", "docstring": "Calculate the angle formed at the point of tangency between the tangent to a circle and the radius.\n    Parameters:\n    point_of_tangency (tuple): A tuple (x, y) representing the coordinates of the point where the tangent touches the circle.\n    center_of_circle (tuple): A tuple (x, y) representing the coordinates of the circle's center.\n    Returns:\n    angle (float): The angle in degrees between the tangent and the radius at the point of tangency, which is always 90 degrees for a circle.\n    Examples:\n    >>> angle_between_tangent_and_radius((2, 4), (1, 1))\n    90.0", "Freq": 0, "TSR": 0}, {"tool": "def check_vertical_angles(angle1, angle2):\n    \n    return angle1 == angle2", "subfield": "Lines and Angles", "tool_name": "check_vertical_angles", "tool_type": "function", "description": "Checks if two given angles are vertical angles. Vertical angles are always congruent.", "docstring": "Checks if two given angles are vertical angles. Vertical angles are always congruent.\n    \n    Parameters:\n        angle1 (float or int): The measure of the first angle in degrees.\n        angle2 (float or int): The measure of the second angle in degrees.\n        \n    Returns:\n        bool: True if the angles are congruent (equal), False otherwise.\n    \n    Examples:\n        >>> check_vertical_angles(45, 45)\n        True\n        >>> check_vertical_angles(130, 130)\n        True\n        >>> check_vertical_angles(110, 120)\n        False", "Freq": 0, "TSR": 0}, {"tool": "def check_line_relationship(point1, point2, point3, point4):\n    \n    # Calculate direction vectors\n    dir1 = np.array([point2[0] - point1[0], point2[1] - point1[1]])\n    dir2 = np.array([point4[0] - point3[0], point4[1] - point3[1]])\n    \n    # Check parallelism (cross product == 0)\n    if np.cross(dir1, dir2) == 0:\n        return 'parallel'\n    \n    # Check perpendicularity (dot product == 0)\n    if np.dot(dir1, dir2) == 0:\n        return 'perpendicular'\n    return 'none'", "subfield": "Lines and Angles", "tool_name": "check_line_relationship", "tool_type": "function", "description": "Check if two lines described by two points each (points on the first line and points on the second line) are parallel or perpendicular.", "docstring": "Check if two lines described by two points each (points on the first line and points on the second line) are parallel or perpendicular.\n    Parameters:\n    - point1, point2 (tuple): Coordinates of the first and second point (x, y) on the first line.\n    - point3, point4 (tuple): Coordinates of the first and second point (x, y) on the second line.\n    Returns:\n    - str: 'parallel', 'perpendicular', or 'none' indicating the relationship between the two lines.\n    \n    Examples:\n    - check_line_relationship((0,0), (1,1), (0,1), (1,2)) returns 'parallel'.\n    - check_line_relationship((0,0), (1,0), (0,0), (0,1)) returns 'perpendicular'.", "Freq": 0, "TSR": 0}, {"tool": "def line_perpendicular_to(line, point):\n    \n    x, y = sp.symbols('x y')\n    A, B, _ = sp.poly(line).coeffs()\n    px, py = point\n    # For line Ax + By + C = 0, the perpendicular line is Bx - Ay + (Ay1 - Bx1)\n    perp_line_expr = B*x - A*y + (A*py - B*px)\n    return sp.simplify(perp_line_expr)", "subfield": "Lines and Angles", "tool_name": "line_perpendicular_to", "tool_type": "function", "description": "Creates the equation of a line that is perpendicular to the given line and passes through the specified point.", "docstring": "Creates the equation of a line that is perpendicular to the given line and passes through the specified point.\n    \n    Parameters:\n    - line (sympy.Expr): The equation of the initial line in form `Ax + By + C = 0`.\n    - point (tuple): A tuple (px, py) representing the point through which the perpendicular line must pass.\n    \n    Returns:\n    - sympy.Expr: The equation of the perpendicular line.\n    \n    Example:\n    >>> line = create_line_equation((0, 0), (1, 1))\n    >>> perp_line = line_perpendicular_to(line, (1, 0))\n    >>> print(perp_line)\n    x + y - 1", "Freq": 0, "TSR": 0}, {"tool": "def identify_line_type(point1, point2):\n    \n    if point1[0] == point2[0]:\n        return 'vertical'\n    elif point1[1] == point2[1]:\n        return 'horizontal'\n    else:\n        return 'diagonal'", "subfield": "Lines and Angles", "tool_name": "identify_line_type", "tool_type": "function", "description": "Identifies the type of line (horizontal, vertical, or diagonal) formed by two given points.", "docstring": "Identifies the type of line (horizontal, vertical, or diagonal) formed by two given points.\n    Parameters:\n        point1 (tuple): The (x, y) coordinate of the first point.\n        point2 (tuple): The (x, y) coordinate of the second point.\n    Returns:\n        str: Returns \"horizontal\" if line is horizontal, \"vertical\" if vertical, and \"diagonal\" otherwise.\n    Example:\n        >>> identify_line_type((0, 0), (5, 0))\n        'horizontal'\n        >>> identify_line_range((1, 1), (1, 3))\n        'vertical'\n        >>> identify_line_range((1, 1), (3, 3))\n        'diagonal'", "Freq": 0, "TSR": 0}, {"tool": "def line_length(point1, point2):\n    \n    point1 = np.array(point1)\n    point2 = np.array(point2)\n    return np.linalg.norm(point1 - point2)", "subfield": "Lines and Angles", "tool_name": "line_length", "tool_type": "function", "description": "Calculate the Euclidean distance between two points.", "docstring": "Calculate the Euclidean distance between two points.\n    Parameters:\n    point1 (tuple): A tuple (x, y) representing the coordinates of the first point.\n    point2 (tuple): A tuple (x, y) representing the coordinates of the second point.\n    Returns:\n    length (float): The length of the line segment between the two points.\n    Examples:\n    >>> line_length((1, 1), (4, 5))\n    5.0", "Freq": 1, "TSR": 0}, {"tool": "def compute_slope(x1, y1, x2, y2):\n    \n    # Utilizing sympy points computation to avoid division by zero\n    p1, p2 = Point(x1, y1), Point(x2, y2)\n    line = Line(p1, p2)\n    return line.slope", "subfield": "Lines and Angles", "tool_name": "compute_slope", "tool_type": "function", "description": "Compute the slope of a line passing through points (x1, y1) and (x2, y2).", "docstring": "Compute the slope of a line passing through points (x1, y1) and (x2, y2).\n    \n    Parameters:\n        x1, y1, x2, y2 (int or float): Coordinates of two points.\n    \n    Returns:\n        slope (int or float or sympy object): The slope of the line.\n        \n    Examples:\n        slope = compute_slope(1, 2, 3, 8)\n        print(slope)  # 3", "Freq": 0, "TSR": 0}, {"tool": "def cyclic_quadrilateral_angles(angle1, angle2=None):\n    \n    if angle2 is None:\n        angle2 = 180 - angle1\n    else:\n        if angle1 + angle2 != 180:\n            raise ValueError(\"Opposite angles in a cyclic quadrilateral must sum up to 180 degrees.\")\n      \n    return angle1, angle2", "subfield": "Lines and Angles", "tool_name": "cyclic_quadrilateral_angles", "tool_type": "function", "description": "Determines the missing angles in a cyclic quadrilateral given two opposite angles.", "docstring": "Determines the missing angles in a cyclic quadrilateral given two opposite angles.\n    \n    Parameters:\n    angle1: float\n        The degree of one angle of the cyclic quadrilateral.\n    angle2: float or None\n        The degree of the opposite angle. If None, it's calculated.\n    \n    Returns:\n    tuple\n        A tuple (a1, a2) representing the angles of two opposite pairs in the cyclic quadrilateral.\n        \n    Examples:\n    >>> cyclic_quadrilateral_angles(110)\n    (110, 70)\n    >>> cyclic_quadrilateral_angles(80, 100)\n    (80, 100)", "Freq": 1, "TSR": 0}, {"tool": "def check_parallel(line1, line2):\n    \n    return calculate_slope(line1) == calculate_slope(line2)", "subfield": "Lines and Angles", "tool_name": "check_parallel", "tool_type": "function", "description": "Check if two lines are parallel.", "docstring": "Check if two lines are parallel.\n    \n    Parameters:\n    line1 (tuple): Coefficients (a, b, c) for the first line ax + by + c = 0.\n    line2 (tuple): Coefficients (a, b, c) for the second line ax + by + c = 0.\n    \n    Returns:\n    bool: True if the lines are parallel, False otherwise.", "Freq": 0, "TSR": 0}, {"tool": "def segment_length(point1, point2):\n    \n    length = np.sqrt((point2[0] - point1[0])**2 + (point2[1] - point1[1])**2)\n    return length", "subfield": "Lines and Angles", "tool_name": "segment_length", "tool_type": "function", "description": "Calculate the length of the segment connecting two points in 2D space.", "docstring": "Calculate the length of the segment connecting two points in 2D space.\n    Parameters:\n    point1 (tuple): The (x, y) coordinates of the first point.\n    point2 (tuple): The (x, y) coordinates of the second point.\n    Returns:\n    float: The length of the segment.\n    Example:\n    >>> segment_length((0, 0), (4, 3))\n    5.0", "Freq": 1, "TSR": 0}, {"tool": "def slope_between_points(point1, point2):\n    \n    x1, y1 = point1\n    x2, y2 = point2\n    try:\n        return (y2 - y1) / (x2 - x1)\n    except ZeroDivisionError:\n        return 'undefined'", "subfield": "Lines and Angles", "tool_name": "slope_between_points", "tool_type": "function", "description": "Calculates the slope between two given points.", "docstring": "Calculates the slope between two given points.\n    \n    Parameters:\n        point1 : tuple of two floats or sympy.Expr\n            Coordinates of the first point (x1, y1).\n        point2 : tuple of two floats or sympa.Expressions\n            Coordinates of the second point (x2, y2).\n    Returns:\n        float or sympy.Expr\n            The slope value between the two points.\n    \n    Example:\n        >>> slope_between_points((1, 2), (3, 8))\n        3\n        >>> slope_between_keys((1, 2), (1, 8))\n        'undefined'  # Division by zero, or handle with symbolics if used in equations.", "Freq": 0, "TSR": 0}, {"tool": "def sum_of_triangle_angles():\n    \n    return 180", "subfield": "Lines and Angles", "tool_name": "sum_of_triangle_angles", "tool_type": "function", "description": "Returns the sum of the internal angles of a triangle, which is always 180 degrees.\n    Returns:\n    int: Sum of angles in a triangle.\n    \n    Examples:\n    >>> sum_of_triangle_angles()\n    180", "docstring": "Returns the sum of the internal angles of a triangle, which is always 180 degrees.\n    Returns:\n    int: Sum of angles in a triangle.\n    \n    Examples:\n    >>> sum_of_triangle_angles()\n    180", "Freq": 0, "TSR": 0}, {"tool": "def calculate_polygon_angle(n_sides, internal_or_external=True):\n    \n    if internal_or_external:\n        # Interior angle calculation\n        return (n_sides - 2) * 180 / n_sides\n    else:\n        # Exterior angle calculation (regular polygon)\n        return 360 / n_sides", "subfield": "Lines and Angles", "tool_name": "calculate_polygon_angle", "tool_type": "function", "description": "Calculate the interior or exterior angles of a regular polygon given the number of sides.", "docstring": "Calculate the interior or exterior angles of a regular polygon given the number of sides.\n    \n    Parameters:\n        n_sides (int): The number of sides in the polygon.\n        internal_or_external (bool): True for internal angle calculation, False for external angles.\n        \n    Returns:\n        float: The angle in degrees.\n        \n    Example:\n        >>> calculate_polygon_angle(4)\n        90.0\n        >>> calculate_polygon_angle(4, False)\n        90.0", "Freq": 0, "TSR": 0}, {"tool": "def find_line_equation(x1, y1, x2, y2):\n    \n    p1, p2 = Point(x1, y1), Point(x2, y2)\n    line = Line(p1, p2)\n    return Eq(line.equation(), 0)", "subfield": "Lines and Angles", "tool_name": "find_line_equation", "tool_type": "function", "description": "Generate the equation of a line passing through points (x1, y1) and (x2, y2).", "docstring": "Generate the equation of a line passing through points (x1, y1) and (x2, y2).\n    \n    Parameters:\n        x1, y1, x2, y2 (int or float): Coordinates of two points.\n    \n    Returns:\n        sympy Eq: The equation of the line in the format `Eq(line expression, 0)`\n        \n    Examples:\n        equation = find_line_equation(0, 0, 1, 1)\n        print(equation)  # Eq(-x + y, 0)", "Freq": 0, "TSR": 0}, {"tool": "def check_parallel(angle1, angle2):\n    \n    return math.isclose(angle1, angle2, abs_tol=1e-9)", "subfield": "Lines and Angles", "tool_name": "check_parallel", "tool_type": "function", "description": "Determine if two lines are parallel based on their corresponding or alternate angles.", "docstring": "Determine if two lines are parallel based on their corresponding or alternate angles.\n    Parameters:\n    angle1 (float): The angle formed between the first line and the transversal.\n    angle2 (float): The angle formed between the second line and the transversal.\n    Returns:\n    bool: True if lines are parallel, False otherwise.\n    \n    Examples:\n    >>> check_parallel(120, 120)\n    True\n    >>> check_parallel(120, 130)\n    False", "Freq": 0, "TSR": 0}, {"tool": "def check_triangle_inequality(a, b, c):\n    \n    return a + b > c and a + c > b and b + c > a", "subfield": "Lines and Angles", "tool_name": "check_triangle_inequality", "tool_type": "function", "description": "Determine if three lengths can form a triangle based on the triangle inequality theorem.", "docstring": "Determine if three lengths can form a triangle based on the triangle inequality theorem.\n    Parameters:\n    a, b, c (float): Lengths of the sides of a potential triangle.\n    Returns:\n    bool: True if the lengths satisfy the triangle inequality, False otherwise.\n    Examples:\n    >>> check_triangle_inequality(3, 4, 5)\n    True\n    >>> check_triangle_inequality(1, 10, 12)\n    False", "Freq": 0, "TSR": 0}, {"tool": "def calculate_slope(line):\n    \n    a, b, c = line\n    if b == 0:\n        raise ValueError(\"Slope is undefined for vertical lines.\")\n    return -a / b", "subfield": "Lines and Angles", "tool_name": "calculate_slope", "tool_type": "function", "description": "Calculate the slope of a line given in the form ax + by + c = 0.", "docstring": "Calculate the slope of a line given in the form ax + by + c = 0.\n    Parameters:\n    line (tuple): Coefficients (a, b, c) representing the line ax + by + c = 0.\n    Returns:\n    float: Slope of the line.", "Freq": 0, "TSR": 0}, {"tool": "def angle_bisector_theorem(a, b, angle):\n    \n    theta = sp.rad(angle)\n    return (a / b)", "subfield": "Lines and Angles", "tool_name": "angle_bisector_theorem", "tool_type": "function", "description": "Applies the angle bisector theorem within a triangle to find the relationships of segments.", "docstring": "Applies the angle bisector theorem within a triangle to find the relationships of segments.\n    Parameters:\n        a (float): The length of one side of the triangle.\n        b (float): The length of the adjacent side of the triangle.\n        angle (float): The angle being bisected in degrees.\n        \n    Returns:\n        float: The ratio of the two segments created by bisecting the given angle.\n    Examples:\n        >>> angle_bisector_theorem(4, 6, 60)\n        0.8", "Freq": 0, "TSR": 0}, {"tool": "def distance_between_parallel_lines(slope, intercept1, intercept2):\n    \n    return abs(intercept2 - intercept1) / math.sqrt(slope**2 + 1)", "subfield": "Lines and Angles", "tool_name": "distance_between_parallel_lines", "tool_type": "function", "description": "Calculate the distance between two parallel lines given by y = mx + c1 and y = mx + c2.", "docstring": "Calculate the distance between two parallel lines given by y = mx + c1 and y = mx + c2.\n    Parameters:\n    - slope (float): Slope of the parallel lines.\n    - intercept1, intercept2 (float): Y-intercepts of the two lines.\n    Returns:\n    - float: The distance between the two parallel lines.\n    Examples:\n    - distance_between_parallel_lines(1, 2, 5)", "Freq": 0, "TSR": 0}, {"tool": "def angle_in_cyclic_quadrilateral(adjacent_sum):\n    \n    # In a cyclic quadrilateral, the sum of opposite angles is 180 degrees\n    return 180 - adjacent_sum", "subfield": "Lines and Angles", "tool_name": "angle_in_cyclic_quadrilateral", "tool_type": "function", "description": "Calculate the opposite angle in a cyclic quadrilateral given the sum of two adjacent angles.", "docstring": "Calculate the opposite angle in a cyclic quadrilateral given the sum of two adjacent angles.\n    \n    Parameters:\n        adjacent_sum (float): Sum of two adjacent angles in degrees.\n        \n    Returns:\n        float: Each of the opposite angles in degrees.\n        \n    Example:\n        >>> angle_in_cyclic_quadrilateral(90)\n        90.0", "Freq": 0, "TSR": 0}, {"tool": "def sum_of_angles_around_point():\n    \n    return 360", "subfield": "Lines and Angles", "tool_name": "sum_of_angles_around_point", "tool_type": "function", "description": "Returns the sum of the angles around a point, which is always 360 degrees.\n    Returns:\n    int: Sum of angles around a point.\n    \n    Examples:\n    >>> sum_of_angles_roud_point()\n    360", "docstring": "Returns the sum of the angles around a point, which is always 360 degrees.\n    Returns:\n    int: Sum of angles around a point.\n    \n    Examples:\n    >>> sum_of_angles_roud_point()\n    360", "Freq": 0, "TSR": 0}, {"tool": "def calculate_missing_angle(known_angle, relation_type='supplementary'):\n    \n    if relation_type == 'supplementary':\n        return 180 - known_angle\n    elif relation_type == 'complementary':\n        return 90 - known_angle\n    else:\n        raise ValueError(\"relation_type must be 'supplementary' or 'complementary'\")", "subfield": "Lines and Angles", "tool_name": "calculate_missing_angle", "tool_type": "function", "description": "Calculate the missing angle based on the type of angle relation.", "docstring": "Calculate the missing angle based on the type of angle relation.\n    Parameters:\n    known_angle (float): The known angle in degrees.\n    relation_type (str): Type of angle relation, 'supplementary' or 'complementary'.\n    Returns:\n    float: The missing angle in degrees.\n    Example:\n    >>> calculate_missing_angle(150, 'supplementary')\n    30.0\n    >>> calculate_missingHandler(30, 'complementary')\n    60.0", "Freq": 1, "TSR": 1}, {"tool": "def perpendicular_slope(slope):\n    \n    if slope == 0:\n        return np.inf\n    elif slope == np.inf:\n        return 0\n    else:\n        return -1 / slope", "subfield": "Lines and Angles", "tool_name": "perpendicular_slope", "tool_type": "function", "description": "Calculates the slope of a line perpendicular to the line with a given slope.", "docstring": "Calculates the slope of a line perpendicular to the line with a given slope.\n    \n    Parameters:\n        slope (float): Slope of the original line.\n    \n    Returns:\n        float: Slope of the line that is perpendicular to the given line.\n    \n    Examples:\n        >>> perpendicular_slope(4)\n        -0.25\n        >>> perpendicular_slope(0)\n        inf", "Freq": 0, "TSR": 0}, {"tool": "def are_corresponding_angles_equal(angle_set1, angle_set2):\n    \n    return np.allclose(angle_set1, angle_set2)", "subfield": "Lines and Angles", "tool_name": "are_corresponding_angles_equal", "tool_type": "function", "description": "Check if corresponding angles in two sets are equal, useful for parallel lines crossed by a transversal.", "docstring": "Check if corresponding angles in two sets are equal, useful for parallel lines crossed by a transversal.\n    Parameters:\n    angle_set1 (list of float): Angles in the first set.\n    angle_set2 (list of float): Angles in the second set.\n    \n    Returns:\n    bool: True if each corresponding angle in the sets are equal, False otherwise.\n    \n    Examples:\n    >>> are_corresponding_angles_equal([110, 70], [110, 70])\n    True\n    >>> are_corresponding_angles_equal([110, 70], [70, 110])\n    False", "Freq": 0, "TSR": 0}, {"tool": "def distance_from_point_to_line(px, py, slope, intercept):\n    \n    return abs(slope * px - py + intercept) / math.sqrt(slope**2 + 1)", "subfield": "Lines and Angles", "tool_name": "distance_from_point_to_line", "tool_type": "function", "description": "Calculate the perpendicular distance from a point to a line given by y = mx + c.", "docstring": "Calculate the perpendicular distance from a point to a line given by y = mx + c.\n    Parameters:\n    - px, py (float): Coordinates of the point.\n    - slope, intercept (float): Coefficients of the line y = mx + c.\n    Returns:\n    - float: The perpendicular distance from (px, py) to the line.\n    Examples:\n    - distance_from_point_to_line(1, 2, 1, 0)  # Line y = x", "Freq": 0, "TSR": 0}, {"tool": "def solve_linear_equations(eq_list):\n    \n    variables = set().union(*(eq.free_symbols for eq in eq_list))\n    solution = solve(eq_list, list(variables))\n    return solution", "subfield": "Lines and Angles", "tool_name": "solve_linear_equations", "tool_type": "function", "description": "Solves a system of linear equations.", "docstring": "Solves a system of linear equations.\n    \n    Parameters:\n        eq_list (list): A list of sympy Eq objects representing equations.\n    \n    Returns:\n        dict: A dictionary containing the solution for the variables in the equations.\n        \n    Examples:\n        x, y = symbols('x y')\n        eq1 = Eq(x + y, 10)\n        eq2 = Eq(2*x - y, 0)\n        solutions = solve_linear_equations([eq1, eq2])\n        print(solutions)  # {x: 10/3, y: 20/3}", "Freq": 0, "TSR": 0}, {"tool": "def calculate_triangle_angle_sum(angle1, angle2):\n    \n    return 180.0 - angle1 - angle2", "subfield": "Lines and Angles", "tool_name": "calculate_triangle_angle_sum", "tool_type": "function", "description": "Given two angles of a triangle, returns the third angle using the fact\n    that sum of angles in a triangle is always 180 degrees.", "docstring": "Given two angles of a triangle, returns the third angle using the fact\n    that sum of angles in a triangle is always 180 degrees.\n    Parameters:\n    - angle1 (float): First angle in degrees\n    - angle2 (float): Second angle in degrees\n    Returns:\n    - float: Third angle in the triangle\n    Example:\n    >>> calculate_triangle_angle_sum(90, 30)\n    60.0", "Freq": 3, "TSR": 1, "experience_pool": "Tool `calculate_triangle_angle_sum` is used to find the third angle of a triangle by subtracting the sum of the given two angles from 180 degrees."}, {"tool": "def check_symmetry(x1, y1, x2, y2, line_x):\n    \n    return x1 + x2 == 2 * line_x and y1 == y2", "subfield": "Lines and Angles", "tool_name": "check_symmetry", "tool_type": "function", "description": "Checks whether two points are symmetric with respect to a vertical line x = line_x.", "docstring": "Checks whether two points are symmetric with respect to a vertical line x = line_x.\n    Parameters:\n        x1, y1 (float, float): Coordinates of the first point.\n        x2, y2 (float, float): Coordinates of the second point.\n        line_x (float): x-coordinate of the vertical line of symmetry.\n    Returns:\n        bool: Returns True if the points are symmetric with respect to the line, otherwise False.\n    \n    Examples:\n        >>> check_symmetry(3, 4, 7, 4, 5)\n        True\n        >>> check_symmetry(1, 2, 3, 4, 5)\n        False", "Freq": 0, "TSR": 0}, {"tool": "def calculate_line_segment_length(coord1, coord2):\n    \n    return math.hypot(coord2[0] - coord1[0], coord2[1] - coord1[1])", "subfield": "Lines and Angles", "tool_name": "calculate_line_segment_length", "tool_type": "function", "description": "Calculates the length of the line segment between two coordinates.", "docstring": "Calculates the length of the line segment between two coordinates.\n    Parameters:\n    - coord1 (tuple of float): The (x, y) coordinates of the first point\n    - coord2 (tuple of float): The (x, y) coordinates of the second point\n    Returns:\n    - float: The length of the line segment between the given points\n    Example:\n    >>> calculate_line_segment_length((0, 0), (3, 4))\n    5.0", "Freq": 0, "TSR": 0}], "Volume of Solids": [{"tool": "def cylinder_volume(radius, height):\n    \n    return math.pi * radius ** 2 * height", "subfield": "Volume of Solids", "tool_name": "cylinder_volume", "tool_type": "function", "description": "Calculate the volume of a cylinder given the radius and height.", "docstring": "Calculate the volume of a cylinder given the radius and height.\n    \n    Parameters:\n    radius (float): The radius of the base of the cylinder.\n    height (float): The height of the cylinder.\n    \n    Returns:\n    float: The volume of the cylinder.\n    \n    Examples:\n    >>> cylinder_volume(2, 4)\n    50.26548245743669", "Freq": 10, "TSR": 6, "experience_pool": "- When using the `cylinder_volume` function, make sure to pass in the correct parameters (radius and height) to calculate the volume of a cylinder.\n- If additional calculations are needed, consider creating helper functions like `volume_sphere` and `remaining_volume` separately to avoid errors in the main solution function."}, {"tool": "def volume_of_rectangular_prism(length, width, height):\n    \n    return length * width * height", "subfield": "Volume of Solids", "tool_name": "volume_of_rectangular_prism", "tool_type": "function", "description": "Calculate the volume of a rectangular prism.", "docstring": "Calculate the volume of a rectangular prism.\n    Parameters:\n    - length: The length of the prism (float or int).\n    - width: The width of the prism (float or int).\n    - height: The height of the prism (float or int).\n    Returns:\n    - The volume of the rectangular prism (float).\n    Example:\n    >>> volume_of_rectangular_prism(2, 3, 4)\n    24", "Freq": 6, "TSR": 6}, {"tool": "def volume_sphere(radius):\n    \n    return (4/3) * math.pi * (radius ** 3)", "subfield": "Volume of Solids", "tool_name": "volume_sphere", "tool_type": "function", "description": "Calculate the volume of a sphere given its radius.", "docstring": "Calculate the volume of a sphere given its radius.\n    Parameters:\n    radius (float): The radius of the sphere.\n    Returns:\n    float: The volume of the sphere.\n    Examples:\n    >>> volume_sphere(3)\n    113.09733552923255", "Freq": 16, "TSR": 3, "experience_pool": "1. Calculating the volume of a sphere using the `volume_sphere` function has been successful in various scenarios.\n2. The formula used in the `volume_sphere` function is mathematically correct and provides accurate results.\n3. The docstring of the `volume_sphere` function clearly explains its purpose and usage."}, {"tool": "def cone_volume(radius, height):\n    \n    return (1/3) * math.pi * pow(radius, 2) * height", "subfield": "Volume of Solids", "tool_name": "cone_volume", "tool_type": "function", "description": "Calculate the volume of a cone.", "docstring": "Calculate the volume of a cone.\n    \n    Parameters:\n        radius (float): The radius of the cone.\n        height (float): The height of the cone.\n    \n    Returns:\n        float: The volume of the cone.\n    \n    Example:\n        >>> cone_volume(3, 4)\n        37.69911184307752", "Freq": 9, "TSR": 5, "experience_pool": "Tool for calculating the volume of a cone is working accurately based on successful outputs.\nIncorrect results in wrong tool callings are due to incorrect input values provided, not the tool itself."}, {"tool": "def pyramid_volume(base_area, height):\n    \n    return (1/3) * base_area * height", "subfield": "Volume of Solids", "tool_name": "pyramid_volume", "tool_type": "function", "description": "Calculate the volume of a pyramid given the area of the base and the height from the base to the apex.", "docstring": "Calculate the volume of a pyramid given the area of the base and the height from the base to the apex.\n    Parameters:\n    base_area (float): The area of the pyramid's base.\n    height (float): The height from the base to the apex.\n    \n    Returns:\n    float: The volume of the pyramid.\n    Example:\n    >>> pyramid_volume(10, 15)\n    50.0", "Freq": 7, "TSR": 4}, {"tool": "def volume_from_face_areas(area1, area2, area3):\n    \n    def equations(p):\n        L, W, H = p\n        return (L*W - area1, W*H - area2, L*H - area3)\n    \n    initial_guess = (np.sqrt(area1), np.sqrt(area2), np.sqrt(area3))\n    solution = fsolve(equations, initial_guess)\n    \n    # Check if all derived equations are almost close to zero for correctness\n    if np.allclose(np.array(equations(solution)), [0.0, 0.0, 0.0], atol=1e-6):\n        return solution[0] * solution[1] * solution[2]\n    else:\n        return None", "subfield": "Volume of Solids", "tool_name": "volume_from_face_areas", "tool_type": "function", "description": "Calculates the volume of a rectangular prism using the areas of its faces.\n    Here, it's assumed that:\n    - area1 = length * width\n    - area2 = width * height\n    - area3 = length * height", "docstring": "Calculates the volume of a rectangular prism using the areas of its faces.\n    Here, it's assumed that:\n    - area1 = length * width\n    - area2 = width * height\n    - area3 = length * height\n    Parameters:\n    - area1 (float): Area of the first face (length x width).\n    - area2 (float): Area of the second face (width x height).\n    - area3 (float): Area of the third face (length x height).\n    Returns:\n    - float: The calculated volume of the rectangular prism if the solution is found, otherwise None.\n    Example:\n    >>> volume_from_face_areas(24, 30, 20)\n    60.0", "Freq": 3, "TSR": 3}, {"tool": "def calculate_rectangle_area(length, width):\n    \n    return length * width", "subfield": "Volume of Solids", "tool_name": "calculate_rectangle_area", "tool_type": "function", "description": "Calculate the area of a rectangle.", "docstring": "Calculate the area of a rectangle.\n    Parameters:\n    length (float): The length of the rectangle.\n    width (float): The width of the rectangle.\n    Returns:\n    float: The area of the rectangle.\n    Example:\n    >>> calculate_rectangle_area(5, 6)\n    30", "Freq": 0, "TSR": 0}, {"tool": "def volume_cube(edge_length):\n    \n    return edge_length ** 3", "subfield": "Volume of Solids", "tool_name": "volume_cube", "tool_type": "function", "description": "Calculate the volume of a cube given its edge length.", "docstring": "Calculate the volume of a cube given its edge length.\n    Parameters:\n    edge_length (float): The edge length of the cube.\n    Returns:\n    float: The volume of the cube.\n    Examples:\n    >>> volume_cube(2)\n    8", "Freq": 14, "TSR": 9}, {"tool": "def volume_of_tetrahedron_from_vertices(v1, v2, v3, v4):\n    \n    matrix = np.array([\n        [v1[0]-v4[0], v1[1]-v4[1], v1[2]-v4[2]],\n        [v2[0]-v4[0], v2[1]-v4[1], v2[2]-v4[2]],\n        [v3[0]-v4[0], v3[1]-v4[1], v3[2]-v4[2]]\n    ])\n    return abs(np.linalg.det(matrix) / 6)", "subfield": "Volume of Solids", "tool_name": "volume_of_tetrahedron_from_vertices", "tool_type": "function", "description": "Calculate the volume of a tetrahedron given the coordinates of its vertices.", "docstring": "Calculate the volume of a tetrahedron given the coordinates of its vertices.\n    \n    Parameters:\n    - v1, v2, v3, v4 (array-like): Coordinates of the vertices of the tetrahedron.\n                                   Each should be an iterable of length 3 (x, y, z coordinates).\n    \n    Returns:\n    - float: The volume of the tetrahedron.\n    \n    Example:\n    >>> volume_of_tetrahedron_from_vertices([0,0,0], [1,0,0], [0,1,0], [0,0,1])\n    0.16666666666666666", "Freq": 0, "TSR": 0}, {"tool": "def volume_of_regular_octahedron(edge_length):\n    \n    return (1/3) * math.sqrt(2) * edge_length**3", "subfield": "Volume of Solids", "tool_name": "volume_of_regular_octahedron", "tool_type": "function", "description": "Calculate the volume of a regular octahedron given its edge length.", "docstring": "Calculate the volume of a regular octahedron given its edge length.\n    Parameters:\n    - edge_length: The length of an edge of the octahedron (float or int).\n    Returns:\n    - The volume of the regular octahedron (float).\n    Example:\n    >>> volume_of_regular_octahedron(3)\n    3.181980515339464", "Freq": 1, "TSR": 1}, {"tool": "def volume_rectangular_parallelepiped(length, width, height):\n    \n    return length * width * height", "subfield": "Volume of Solids", "tool_name": "volume_rectangular_parallelepiped", "tool_type": "function", "description": "Calculates the volume of a rectangular parallelepiped (box).", "docstring": "Calculates the volume of a rectangular parallelepiped (box).\n    \n    Parameters:\n    - length (float): Length of the parallelepiped.\n    - width (float): Width of the parallelepiped.\n    - height (float): Height of the parallelepiped.\n    \n    Returns:\n    - float: The volume of the rectangular parallelepiped.\n    \n    Examples:\n    >>> volume_rectangular_parallelepiped(2, 3, 4)\n    24", "Freq": 9, "TSR": 2, "experience_pool": "1. When using the `volume_rectangular_parallelepiped` function, ensure that the input parameters are correctly provided.\n2. Make sure to define and implement any additional functions like `volume_cube` or `remaining_volume` before using them in calculations.\n3. Double-check the calculations and formulas used in the solution to avoid errors in the final output."}, {"tool": "def area_square(side):\n    \n    return side ** 2", "subfield": "Volume of Solids", "tool_name": "area_square", "tool_type": "function", "description": "Compute the area of a square given the side length.", "docstring": "Compute the area of a square given the side length.\n    Parameters:\n    side (float): The length of one side of the square.\n    Returns:\n    float: The area of the square.\n    Example:\n    >>> area_square(4)\n    16", "Freq": 0, "TSR": 0}, {"tool": "def calculate_volume(shape_type, dimensions):\n    \n    if shape_type == \"sphere\":\n        radius = dimensions[\"radius\"]\n        return (4/3) * math.pi * radius ** 3\n    elif shape_type == \"rectangular_prism\":\n        length = dimensions[\"length\"]\n        width = dimensions[\"width\"]\n        height = dimensions[\"height\"]\n        return length * width * height\n    elif shape_type == \"cube\":\n        edge_length = dimensions[\"edge_length\"]\n        return edge_length ** 3\n    elif shape_type == \"octahedron\":\n        edge_length = dimensions[\"edge_length\"]\n        return (math.sqrt(2) / 3) * edge_length ** 3\n    else:\n        raise ValueError(\"Invalid shape type provided\")", "subfield": "Volume of Solids", "tool_name": "calculate_volume", "tool_type": "function", "description": "Calculate the volume of various geometric solids based on given parameters.", "docstring": "Calculate the volume of various geometric solids based on given parameters.\n    \n    Parameters:\n        shape_type (str): Type of shape (\"sphere\", \"rectangular_prism\", \"cube\", \"octahedron\")\n        dimensions (dict): A dictionary containing the required dimensions:\n                           For a sphere: {'radius': r}\n                           For a rectangular prism: {'length': l, 'width': w, 'height': h}\n                           For a cube: {'edge_length': a}\n                           For an octahedron: {'edge_length': a}\n    Returns:\n        float: The volume of the geometric solid.\n    \n    Examples:\n        calculate_volume(\"sphere\", {\"radius\": 3})\n        calculate_volume(\"rectangular_prism\", {\"length\": 5, \"width\": 3, \"height\": 2})\n        calculate_volume(\"cube\", {\"edge_length\": 4})\n        calculate_volume(\"octahedron\", {\"edge_length\": 5})", "Freq": 0, "TSR": 0}, {"tool": "def surface_area_of_rectangular_prism(length, width, height):\n    \n    return 2 * (length * width + width * height + height * length)", "subfield": "Volume of Solids", "tool_name": "surface_area_of_rectangular_prism", "tool_type": "function", "description": "Calculate the surface area of a rectangular prism.", "docstring": "Calculate the surface area of a rectangular prism.\n    Parameters:\n    length (float or int): Length of the rectangular prism.\n    width (float or int): Width of the rectangular prism.\n    height (float or int): Height of the rectangular prism.\n    Returns:\n    float: The surface area of the rectangular prism.\n    Examples:\n    >>> surface_area_of_rectangular_prism(10, 4, 5)\n    220.0\n    >>> surface_area_of_rectangular_prism(7.5, 3.5, 1.5)\n    82.5", "Freq": 1, "TSR": 1}, {"tool": "def volume_rectangular_box(length, width, height):\n    \n    return length * width * height", "subfield": "Volume of Solids", "tool_name": "volume_rectangular_box", "tool_type": "function", "description": "Calculate the volume of a rectangular box.", "docstring": "Calculate the volume of a rectangular box.\n    Parameters:\n    length (float): Length of the box.\n    width (float): Width of the box.\n    height (float): Height of the box.\n    Returns:\n    float: Volume of the rectangular box.\n    Examples:\n    >>> volume_rectangular_box(2, 3, 4)\n    24", "Freq": 0, "TSR": 0}, {"tool": "def volume_difference(volume1, volume2):\n    \n    return abs(volume1 - volume2)", "subfield": "Volume of Solids", "tool_name": "volume_difference", "tool_type": "function", "description": "Calculate the difference in volumes between two solids.", "docstring": "Calculate the difference in volumes between two solids.\n    \n    Parameters:\n    volume1 (float): Volume of the first solid.\n    volume2 (float): Volume of the second solid.\n    \n    Returns:\n    float: The difference in volumes, ensuring it's non-negative.\n    \n    Example:\n    >>> volume_difference(50, 27)\n    23.0", "Freq": 1, "TSR": 0}, {"tool": "def subtract_volumes(volume1, volume2):\n    \n    return max(volume1 - volume2, 0)  # Ensure non-negative result", "subfield": "Volume of Solids", "tool_name": "subtract_volumes", "tool_type": "function", "description": "Calculate the remaining volume after one volume is subtracted from another.", "docstring": "Calculate the remaining volume after one volume is subtracted from another.\n    \n    Parameters:\n    volume1 (float): The initial or larger volume.\n    volume2 (float): The volume to subtract from the initial volume.\n    \n    Returns:\n    float: The remaining volume after subtraction.\n    \n    Examples:\n    >>> subtract_volumes(100, 50.26548245743669)\n    49.73451754256331", "Freq": 0, "TSR": 0}, {"tool": "def volume_frustum(total_volume, removed_volume):\n    \n    return total_volume - removed_volume", "subfield": "Volume of Solids", "tool_name": "volume_frustum", "tool_type": "function", "description": "Compute the volume of a frustum by subtracting the volume of a smaller shape removed from a larger solid.", "docstring": "Compute the volume of a frustum by subtracting the volume of a smaller shape removed from a larger solid.\n    Parameters:\n    total_volume (float): The original volume of the larger solid before the smaller volume was removed.\n    removed_volume (float): The volume of the smaller solid that was removed.\n    Returns:\n    float: The volume of the frustum.\n    Example:\n    >>> volume_frustum(200, 50)\n    150", "Freq": 1, "TSR": 0}, {"tool": "def dihedral_angle_between_planes(plane1_normal, plane2_normal):\n    \n    n1 = sp.Matrix(plane1_normal)\n    n2 = sp.Matrix(plane2_normal)\n    return sp.acos(n1.dot(n2) / (n1.norm() * n2.norm()))", "subfield": "Volume of Solids", "tool_name": "dihedral_angle_between_planes", "tool_type": "function", "description": "Calculate the dihedral angle between two planes given their normal vectors.", "docstring": "Calculate the dihedral angle between two planes given their normal vectors.\n    Parameters:\n        plane1_normal (list of float): the normal vector of the first plane.\n        plane2_normal (list of float): the normal vector of the second plane.\n    Returns:\n        float: the dihedral angle in radians between the two planes.\n    Examples:\n        >>> dihedral_angle_between_planes([0, 0, 1], [0, 1, 0])\n        1.5707963267948966", "Freq": 0, "TSR": 0}, {"tool": "def derive_dimensions_by_volume(total_volume, ratio, initial_dimension):\n    \n    import math\n    # Using the formula for volume of rectangular solids: V = lwh\n    # and for geometric progression if l = a, w = ar, h = ar^2 then V = a * ar * ar^2 = a^3 * r^3\n    # Solving for 'a' we get a = (V / r^3)^(1/3)\n    a = (total_volume / (ratio ** 3)) ** (1/3)\n    length = a\n    width = a * ratio\n    height = a * (ratio ** 2)\n    return (length, width, height)", "subfield": "Volume of Solids", "tool_name": "derive_dimensions_by_volume", "tool_type": "function", "description": "Derive the dimensions of a rectangular solid where the dimensions are in geometric progression,\n    given the total volume and a progression ratio.", "docstring": "Derive the dimensions of a rectangular solid where the dimensions are in geometric progression,\n    given the total volume and a progression ratio.\n    Parameters:\n    - total_volume (float): The total volume of the solid.\n    - ratio (float): The common ratio in the geometric progression of the dimensions.\n    - initial_dimension (float): The initial dimension for the geometric progression (commonly the smallest dimension).\n    Returns:\n    - tuple (float, float, float): Returns the dimensions (length, width, height) of the rectangular solid.\n    Example:\n    >>> derive_dimensions_by_volume(216.0, 2, 3.0)\n    (3.0, 6.0, 12.0)", "Freq": 1, "TSR": 0}, {"tool": "def volume_composite_shapes(*volumes):\n    \n    return sum(volumes)", "subfield": "Volume of Solids", "tool_name": "volume_composite_shapes", "tool_type": "function", "description": "Sum multiple volumes to calculate the total volume of a composite shape.", "docstring": "Sum multiple volumes to calculate the total volume of a composite shape.\n    Parameters:\n    - volumes (list of float): A list of individual volumes of the composite shape.\n    Returns:\n    - float: The total volume of the composite shape.\n    Examples:\n    >>> volume_composite_shapes(24.0, 27.0, 15.707963267948967)\n    66.70796326794897", "Freq": 0, "TSR": 0}, {"tool": "class SolidVolumeCalculator:\n    \"\"\" Class to calculate the volumes of various 3D solids.\n    Methods\n    -------\n    cylinder_volume(radius, height)\n        Calculate the volume of a cylinder.\n    \n    tetrahedron_volume(side_length)\n        Calculate the volume of a regular tetrahedron.\n    pyramid_volume(base_area, height)\n        Calculate the volume of a pyramid.\n    solid_of_revolution(f, a, b)\n        Calculate the volume of a solid of revolution of the function f from x=a to x=b about the x-axis.\n    \"\"\"\n    @staticmethod\n    def cylinder_volume(radius, height):\n        \"\"\"\n        Calculate the volume of a right circular cylinder.\n        Parameters:\n        radius (float or sympy.Symbol): The radius of the cylinder.\n        height (float or sympy.Symbol): The height of the cylinder.\n        Returns:\n        float or sympy.Expr: The volume of the cylinder.\n        Example:\n        >>> SolidVolumeCalculator.cylinder_volume(3, 5)\n        141.3716694115407\n        \"\"\"\n        return math.pi * radius**2 * height\n    @staticmethod\n    def tetrahedron_volume(side_length):\n        \"\"\"\n        Calculate the volume of a regular tetrahedron.\n        Parameters:\n        side_length (float or sympy.Symbol): The length of a side of the tetrahedron.\n        Returns:\n        float or sympy.Expr: The volume of the tetrahedron.\n        Example:\n        >>> SolidVolumeCalculator.tetrahedron_volume(2)\n        0.9428090415820632\n        \"\"\"\n        return side_length**3 / (6 * math.sqrt(2))\n    @staticmethod\n    def pyramid_volume(base_area, height):\n        \"\"\"\n        Calculate the volume of a pyramid with a given base area and height.\n        Parameters:\n        base_area (float or sympy.Symbol): The area of the pyramid's base.\n        height (float or sympy.Symbol): The height of the pyramid.\n        Returns:\n        float or sympy.Expr: The volume of the pyramid.\n        Example:\n        >>> SolidVolumeCalculator.pyramid_volume(10, 3)\n        10.0\n        \"\"\"\n        return base_area * height / 3\n    \n    @staticmethod\n    def solid_of_revolution(f, a, b):\n        \"\"\"\n        Calculate the volume of the solid of revolution of a function f from x=a to x=b about the x-axis.\n        Parameters:\n        f (sympy function): A sympy function of x.\n        a (float or sympo.Symbol): The start of the interval of revolution.\n        b (float or sympy.Symbol): The end of the interval of revolution.\n        Returns:\n        float or sympy.Expr: The volume of the solid of revolution.\n        Example:\n        >>> x = sympy.symbols('x')\n        >>> f = sympy.Lambda(x, sympy.sqrt(1 - x**2))\n        >>> SolidVolumeCalculator.solid_of_revolution(f, -1, 1)\n        (4/3)*pi\n        \"\"\"\n        x = sympy.symbols('x')\n        return sympy.pi * sympy.integrate(f(x)**2, (x, a, b))", "subfield": "Volume of Solids", "tool_name": "SolidVolumeCalculator:\n    \"\"\" Class to calculate the volumes of various 3D solids.\n    Methods\n    -------\n    cylinder_volume", "tool_type": "class", "description": "Class to calculate the volumes of various 3D solids.\n    Methods\n    -------\n    cylinder_volume(radius, height)\n        Calculate the volume of a cylinder.\n    \n    tetrahedron_volume(side_length)\n        Calculate the volume of a regular tetrahedron.\n    pyramid_volume(base_area, height)\n        Calculate the volume of a pyramid.\n    solid_of_revolution(f, a, b)\n        Calculate the volume of a solid of revolution of the function f from x=a to x=b about the x-axis.", "docstring": "Class to calculate the volumes of various 3D solids.\n    Methods\n    -------\n    cylinder_volume(radius, height)\n        Calculate the volume of a cylinder.\n    \n    tetrahedron_volume(side_length)\n        Calculate the volume of a regular tetrahedron.\n    pyramid_volume(base_area, height)\n        Calculate the volume of a pyramid.\n    solid_of_revolution(f, a, b)\n        Calculate the volume of a solid of revolution of the function f from x=a to x=b about the x-axis.", "Freq": 0, "TSR": 0}, {"tool": "def volume_of_tetrahedron(side):\n    \n    return side**3 * sqrt(2) / 12", "subfield": "Volume of Solids", "tool_name": "volume_of_tetrahedron", "tool_type": "function", "description": "Calculate the volume of a regular tetrahedron given its side length.", "docstring": "Calculate the volume of a regular tetrahedron given its side length.\n    Parameters:\n    - side (float or Symbol): The length of a side of the tetrahedron.\n    Returns:\n    - sympy expression: The calculated volume of the tetrahedron.\n    Examples:\n    >>> s = symbols('s')\n    >>> volume_of_tetrahedron(s)\n    s**3*sqrt(2)/12", "Freq": 0, "TSR": 0}, {"tool": "def volume_of_revolution(func, axis, start, end):\n    \n    x = Symbol(\"x\")\n    if axis == 'x':\n        return pi * integrate(func**2, (x, start, end))\n    else:\n        # Assuming rotation around the y-axis is the integral of pi*r^2 dx where r = f^-1(y)\n        y = Symbol(\"y\")\n        inverse_func = func.subs(x, y)  # assuming func is invertible and expressed in terms of y\n        return pi * integrate(inverse_func**2, (y, start, end))", "subfield": "Volume of Solids", "tool_name": "volume_of_revolution", "tool_type": "function", "description": "Calculate the volume of a solid of revolution by rotating a function about an axis.", "docstring": "Calculate the volume of a solid of revolution by rotating a function about an axis.\n    Parameters:\n    - func (function): Function of x defining the shape to be revolved.\n    - axis (str): Axis about which the shape is revolved ('x' or 'y').\n    - start (float or Symbol): The start of the interval of revolution.\n    - end (float or Symbol): The end of the interval of revolution.\n    Returns:\n    - sympy expression: The volume of the solid of revolution.\n    Examples:\n    >>> x = symbols('x')\n    >>> f = x**2\n    >>> volume_of_revolution(f, 'x', 0, 2)\n    8*pi/5*2**5", "Freq": 0, "TSR": 0}, {"tool": "def pythagorean_theorem(a=None, b=None, c=None):\n    \n    import math\n    if c is None:  # if hypotenuse is missing\n        return math.sqrt(a**2 + b**2)\n    if a is None:  # if one side is missing\n        return math.sqrt(c**2 - b**2)\n    if b is None:  # if the other side is missing\n        return math.sqrt(c**2 - a**2)", "subfield": "Volume of Solids", "tool_name": "pythagorean_theorem", "tool_type": "function", "description": "Calculate the length of a side of a right triangle using the Pythagorean theorem given the lengths of the other two sides.", "docstring": "Calculate the length of a side of a right triangle using the Pythagorean theorem given the lengths of the other two sides.\n    Parameters:\n    a (float, optional): Length of one side of the right triangle.\n    b (float, optional): Length of the other side of the right triangle.\n    c (float, optional): Length of the hypotenuse of the right triangle.\n    Returns:\n    float: The length of the missing side.\n    Example:\n    >>> pythagorean_theorem(a=3, c=5)\n    4.0\n    >>> pythagorean_theorem(b=4, c=5)\n    3.0", "Freq": 0, "TSR": 0}, {"tool": "def find_missing_dimension(volume, length=None, width=None, height=None):\n    \n    if length is None:\n        missing_dimension = volume / (width * height)\n    elif width is None:\n        missing_dimension = volume / (length * height)\n    elif height is None:\n        missing_dimension = volume / (length * width)\n    else:\n        raise ValueError(\"Only one dimension should be missing.\")\n    return missing_dimension", "subfield": "Volume of Solids", "tool_name": "find_missing_dimension", "tool_type": "function", "description": "Given the volume and any two dimensions of a rectangular prism, calculate the missing dimension.", "docstring": "Given the volume and any two dimensions of a rectangular prism, calculate the missing dimension.\n    Parameters:\n    volume (float or int): The volume of the rectangular solid.\n    length (float or int, optional): The length of the rectangular solid. Defaults to None.\n    width (float or int, optional): The width of the rectangular solid. Defaults to None.\n    height (float or int, optional): The height of the rectangular solid. Defaults to None.\n    Returns:\n    float: The missing dimension of the rectangular solid.\n    Examples:\n    >>> find_missing_dimension(100, length=10, width=5)\n    2.0\n    >>> find_missing_dimension(36, height=1.5, width=3.2)\n    7.5", "Freq": 0, "TSR": 0}, {"tool": "def calculate_geometric_solid_volume(shape_type, dimensions):\n    \n    import math\n    def sphere_volume(radius):\n        \n        return (4/3) * math.pi * radius ** 3\n    def tetrahedron_volume(side_length):\n        \n        return (side_length ** 3) / (6 * math.sqrt(2))\n    def pyramid_volume(base_area, height):\n        \n        return (1/3) * base_area * height\n    if shape_type == \"sphere\":\n        radius = dimensions[\"radius\"]\n        return sphere_volume(radius)\n    elif shape_type == \"tetrahedron\":\n        side_length = dimensions[\"side_length\"]\n        return tetrahedron_volume(side_length)\n    elif shape_type == \"pyramid\":\n        base_area = dimensions[\"base_area\"]\n        height = dimensions[\"height\"]\n        return pyramid_volume(base_area, height)\n    else:\n        raise ValueError(\"Invalid shape type provided\")", "subfield": "Volume of Solids", "tool_name": "calculate_geometric_solid_volume", "tool_type": "function", "description": "Calculate the volume of various geometric solids based on given parameters.", "docstring": "Calculate the volume of various geometric solids based on given parameters.\n    \n    Parameters:\n    shape_type (str): The type of solid (\"sphere\", \"complex_solid\", \"tetrahedron\", \"pyramid\").\n    dimensions (dict): A dictionary containing the necessary dimensions for the calculation.\n    \n    Returns:\n    float: The volume of the specified solid.\n    \n    Example:\n    >>> calculate_geometric_solid_volume(\"sphere\", {\"radius\": 3})\n    113.09733552923255\n    >>> calculate_geometric_solid_volume(\"tetrahedron\", {\"side_length\": 4})\n    10.666666666666666", "Freq": 0, "TSR": 0}], "Perimeter": [{"tool": "def calculate_polygon_perimeter(side_lengths):\n    \n    return sum(side_lengths)", "subfield": "Perimeter", "tool_name": "calculate_polygon_perimeter", "tool_type": "function", "description": "Calculate the perimeter of a polygon given the lengths of its sides.", "docstring": "Calculate the perimeter of a polygon given the lengths of its sides.\n    \n    Parameters:\n    side_lengths (list or tuple of floats/integers): The lengths of the sides of the polygon.\n    \n    Returns:\n    float: The perimeter of the polygon.\n    \n    Examples:\n    >>> calculate_polygon_perimeter([5, 5, 5, 5])  # Perimeter of a square\n    20\n    >>> calculate_polygon_perimeter([3, 4, 5])  # Perimeter of a triangle\n    12", "Freq": 4, "TSR": 3}, {"tool": "def calculate_perimeter_square(side_length):\n    \n    if side_length < 0:\n        raise ValueError(\"Side length must be non-negative\")\n    return 4 * side_length", "subfield": "Perimeter", "tool_name": "calculate_perimeter_square", "tool_type": "function", "description": "Calculate the perimeter of a square.", "docstring": "Calculate the perimeter of a square.\n    \n    Parameters:\n    side_length (float): The length of a side of the square.\n    \n    Returns:\n    float: The perimeter of the square.\n    \n    Examples:\n    >>> calculate_perimeter_square(5)\n    20\n    >>> calculate_perimeter_square(7.25)\n    29.0", "Freq": 4, "TSR": 3}, {"tool": "def calculate_perimeter(shape, *dimensions):\n    \n    if shape == 'square':\n        return 4 * dimensions[0]\n    elif shape == 'rectangle':\n        return 2 * (dimensions[0] + dimensions[1])\n    elif shape == 'circle':\n        return 2 * math.pi * dimensions[0]\n    elif shape == 'regular_polygon':\n        n_sides, side_length = dimensions\n        return n_sides * side_length\n    else:\n        raise ValueError(\"Unsupported shape type provided.\")", "subfield": "Perimeter", "tool_name": "calculate_perimeter", "tool_type": "function", "description": "Calculate the perimeter of various common geometric shapes.", "docstring": "Calculate the perimeter of various common geometric shapes.\n    \n    Parameters:\n    - shape (str): The type of shape ('square', 'rectangle', 'circle', or 'regular_polygon').\n    - dimensions (tuple of floats): Dimensions of the shape; this could be side length for a square,\n      length and width for a rectangle, radius for a circle, or side length and number of sides for a regular polygon.\n    \n    Returns:\n    float: The perimeter of the given shape.\n    \n    Examples:\n    >>> calculate_perimeter('square', 5)\n    20\n    >>> calculate_perimeter('rectangle', 5, 7)\n    24\n    >>> calculate_perimeter('circle', 3)\n    18.84955592153876\n    >>> calculate_perimeter('regular_polygon', 6, 5)  # A regular pentagon with side length 6\n    30", "Freq": 0, "TSR": 0}, {"tool": "def calculate_perimeter_rectangle(length, width):\n    \n    if length < 0 or width < 0:\n        raise ValueError(\"Length and width must be non-negative\")\n    return 2 * (length + width)", "subfield": "Perimeter", "tool_name": "calculate_perimeter_rectangle", "tool_type": "function", "description": "Calculate the perimeter of a rectangle.", "docstring": "Calculate the perimeter of a rectangle.\n    \n    Parameters:\n    length (float): The length of the rectangle.\n    width (float): The width of the rectangle.\n    \n    Returns:\n    float: The perimeter of the rectangle.\n    \n    Examples:\n    >>> calculate_perimeter_rectangle(10, 5)\n    30\n    >>> calculate_perimeter_rectangle(8.0, 3.5)\n    23.0", "Freq": 0, "TSR": 0}, {"tool": "def calculate_composite_shape_perimeter(regions):\n    \n    total_perimeter = 0\n    for region in regions:\n        total_perimeter += (region['perimeter'] - region['internal_overlap'])\n    return total_perimeter", "subfield": "Perimeter", "tool_name": "calculate_composite_shape_perimeter", "tool_type": "function", "description": "Calculate the perimeter of a composite shape given the perimeters of individual segments and internal overlaps.", "docstring": "Calculate the perimeter of a composite shape given the perimeters of individual segments and internal overlaps.\n    \n    Parameters:\n    regions (list of dicts): Each dict represents a region with keys 'perimeter' for external perimeter, \n                             and 'internal_overlap' for the length subtracted due to internal overlaps.\n    \n    Returns:\n    float: The effective external perimeter of the composite shape, accounting for overlaps.\n    \n    Examples:\n    >>> calculate_composite_shape_perimeter([{'perimeter': 20, 'internal_overlap': 0}, {'perimeter': 30, 'internal_overlap': 5}])\n    45\n    >>> calculate_composite_shape_perimeter([{'perimeter': 10, 'internal_overlap': 1}, {'perimeter': 15, 'internal_overlap': 2}])\n    22", "Freq": 0, "TSR": 0}, {"tool": "def calculate_perimeter_circle(radius):\n    \n    if radius < 0:\n        raise ValueError(\"Radius must be non-negative\")\n    return 2 * pi * radius", "subfield": "Perimeter", "tool_name": "calculate_perimeter_circle", "tool_type": "function", "description": "Calculate the perimeter (circumference) of a circle.", "docstring": "Calculate the perimeter (circumference) of a circle.\n    \n    Parameters:\n    radius (float): The radius of the circle.\n    \n    Returns:\n    float: The circumference of the circle.\n    \n    Examples:\n    >>> calculate_perimeter_circle(4)\n    25.132741228718345\n    >>> calculate_perimeter_circle(5.5)\n    34.55751918948773", "Freq": 0, "TSR": 0}], "3D Shapes": [{"tool": "def point_distance(p1, p2):\n    \n    return np.linalg.norm(np.array(p1) - np.array(p2))", "subfield": "3D Shapes", "tool_name": "point_distance", "tool_type": "function", "description": "Calculate Euclidean distance between points p1 and p2 in 3D space.", "docstring": "Calculate Euclidean distance between points p1 and p2 in 3D space.\n    \n    Parameters:\n    - p1, p2 (iterable with three numbers - list, tuple): Coordinates of the points p1 and p2.\n    \n    Returns:\n    - float: Euclidean distance between points p1 and p2.\n    \n    Example:\n    >>> point_distance((1, 2, 3), (4, 6, 8))\n    7.483314773547883", "Freq": 4, "TSR": 3, "experience_pool": "- When using the tool, ensure that the input parameters are correctly provided as iterable with three numbers (list, tuple) for both points p1 and p2.\n- Double-check the coordinates of the points and the calculations involved in determining the distances between them to avoid errors in the final results."}, {"tool": "def volume_cylinder(radius, height):\n    \n    return pi * radius ** 2 * height", "subfield": "3D Shapes", "tool_name": "volume_cylinder", "tool_type": "function", "description": "Calculate the volume of a cylinder.", "docstring": "Calculate the volume of a cylinder.\n    \n    Parameters:\n    - radius (float): The radius of the cylinder.\n    - height (float): The height of the cylinder.\n    \n    Returns:\n    - float: The volume of the cylinder.\n    \n    Example:\n    >>> volume_cylinder(1, 2)\n    6.283185307179586", "Freq": 4, "TSR": 4}, {"tool": "def cylinder_lateral_surface_area(radius, height):\n    \n    return 2 * math.pi * radius * height", "subfield": "3D Shapes", "tool_name": "cylinder_lateral_surface_area", "tool_type": "function", "description": "Calculate the lateral surface area of a cylinder.", "docstring": "Calculate the lateral surface area of a cylinder.\n    \n    Parameters:\n    radius (float): The radius of the cylinder.\n    height (float): The height of the cylinder.\n    \n    Returns:\n    float: The lateral surface area of the cylinder.\n    Example:\n    >>> cylinder_lateral_surface_area(3, 5)\n    94.24777960769379", "Freq": 1, "TSR": 1}, {"tool": "def cube_properties(side_length):\n    \n    volume = side_length ** 3\n    surface_area = 6 * (side_length ** 2)\n    face_diagonal = np.sqrt(2) * side_length\n    space_diagonal = np.sqrt(3) * side_length\n    return {\n        \"volume\": volume,\n        \"surface_area\": surface_area,\n        \"face_diagonal\": round(face_diagonal, 2),\n        \"space_diagonal\": round(space_diagonal, 2)\n    }", "subfield": "3D Shapes", "tool_name": "cube_properties", "tool_type": "function", "description": "Calculate properties of a cube given its side length.", "docstring": "Calculate properties of a cube given its side length.\n    Parameters:\n    - side_length (float): The length of a side of the cube.\n    Returns:\n    - dict: Dictionary containing properties like volume, surface area, face diagonal, and space diagonal.\n    \n    Examples:\n    >>> cube_properties(2)\n    {'volume': 8, 'surface_area': 24, 'face_diagonal': 2.83, 'space_diagonal': 3.46}", "Freq": 5, "TSR": 4}, {"tool": "def geometric_properties_3d(shape_type, dimensions):\n    \n    if shape_type in ['triangular_prism', 'rectangular_prism', 'square_prism']:\n        base_edges = dimensions['base_edges']\n        faces = 2 + base_edges\n        edges = 3 * base_edges\n        vertices = 2 * base_edges\n    elif shape_type == 'pyramid':\n        base_edges = dimensions['base_edges']\n        faces = base_edges + 1\n        edges = 2 * base_edges\n        vertices = base_edges + 1\n    else:\n        raise ValueError(\"Unsupported shape_type provided.\")\n    \n    return {'faces': faces, 'edges': edges, 'vertices': vertices}", "subfield": "3D Shapes", "tool_name": "geometric_properties_3d", "tool_type": "function", "description": "Calculate basic geometric properties (faces, edges, vertices) for 3D shapes such as various prisms and pyramids.", "docstring": "Calculate basic geometric properties (faces, edges, vertices) for 3D shapes such as various prisms and pyramids.\n    Parameters:\n    shape_type (str): Type of the 3D shape ('triangular_prism', 'rectangular_prism', 'square_prism', 'pyramid').\n    dimensions (dict): Dimensions of the 3D shape. For prisms: {'base_edges': int, 'height': float}.\n                       For pyramids: {'base_edges': int, 'side_edges': int, 'height': float}.\n    \n    Returns:\n    dict: Dictionary containing number of faces, edges, and vertices.\n    \n    Examples:\n    >>> geometric_properties_3d('triangular_prism', {'base_edges': 3, 'height': 10})\n    {'faces': 5, 'edges': 9, 'vertices': 6}\n    \n    >>> geometric_properties_3d('pyramid', {'base_edges': 4, 'side_edges': 4, 'height': 9})\n    {'faces': 5, 'edges': 8, 'vertices': 5}", "Freq": 4, "TSR": 4}, {"tool": "def surface_area_volume(shape_type, dimensions):\n    \n    if shape_type == 'rectangular_prism':\n        l, w, h = dimensions['length'], dimensions['width'], dimensions['height']\n        surface_area = 2 * (l * w + l * h + w * h)\n        volume = l * w * h\n    elif shape_type == 'pyramid':\n        l, w, h = dimensions['base_length'], dimensions['width'], dimensions['height']\n        base_area = l * w\n        surface_area = l * w + l * sqrt((w/2)**2 + h**2) + w * sqrt((l/2)**2 + h**2)\n        volume = (l * w * h) / 3\n    else:\n        raise ValueError(\"Invalid shape type provided.\")\n    return {'surface_area': surface_area, 'volume': volume}", "subfield": "3D Shapes", "tool_name": "surface_area_volume", "tool_type": "function", "description": "Calculate the surface area and volume for common 3D shapes such as prisms and pyramids based on provided dimensions.", "docstring": "Calculate the surface area and volume for common 3D shapes such as prisms and pyramids based on provided dimensions.\n    Parameters:\n    shape_type (str): Type of the 3D shape ('triangular_prism', 'rectangular_prism', 'pyramid').\n    dimensions (dict): Dimensions necessary for calculations. Prisms: {'length': float, 'width': float, 'height': float}.\n                       Pyramid: {'base_length': float, 'base_width': float, 'height': float}.\n    Returns:\n    dict: Dictionary containing 'surface_area' and 'volume' of the shape.\n    Examples:\n    >>> surface_area_volume('rectangular_prism', {'length': 2, 'width': 3, 'height': 4})\n    {'surface_area': 52.0, 'volume': 24.0}\n    \n    >>> surface_area_volume('pyramid', {'base_length': 4, 'base_width': 4, 'height': 6})\n    {'surface_area': 52.624, 'volume': 32.0}", "Freq": 1, "TSR": 1}, {"tool": "def cube_volume(side_length):\n    \n    return side_length ** 3", "subfield": "3D Shapes", "tool_name": "cube_volume", "tool_type": "function", "description": "Calculate the volume of a cube.", "docstring": "Calculate the volume of a cube.\n    \n    Parameters:\n    side_length (float): The length of a side of the cube.\n    \n    Returns:\n    float: The volume of the cube.\n    \n    Example:\n    >>> cube_volume(3)\n    27", "Freq": 3, "TSR": 1, "experience_pool": "- When calculating the side length of a cube inscribed in a sphere, use the formula: cube_side_length = sphere_diameter / math.sqrt(3)\n- Ensure that the correct formula for calculating the inscribed cube volume is used: inscribed_cube_volume = cube_volume(cube_side_length)"}, {"tool": "def pyramid_properties(base_side, height):\n    \n    base_area = base_side ** 2\n    volume = (1/3) * base_area * height\n    slant_height = np.sqrt((base_side/2) ** 2 + height ** 2)\n    return {\n        \"volume\": volume,\n        \"slant_height\": round(slant_height, 2)\n    }", "subfield": "3D Shapes", "tool_name": "pyramid_properties", "tool_type": "function", "description": "Calculate properties of a square base pyramid.", "docstring": "Calculate properties of a square base pyramid.\n    Parameters:\n    - base_side (float): The length of one side of the square base.\n    - height (float): The height of the pyramid from the base to the apex.\n    Returns:\n    - dict: Dictionary containing properties like volume and slant height.\n    \n    Examples:\n    >>> pyramid_properties(3, 4)\n    {'volume': 12.0, 'slant_height': 5.0}", "Freq": 2, "TSR": 0}, {"tool": "def calculate_frustum_properties(r1, r2, h):\n    \n    lateral_area = math.pi * (r1 + r2) * math.sqrt((r2 - r1) ** 2 + h ** 2)\n    total_area = lateral_area + math.pi * (r1 ** 2 + r2 ** 2)\n    volume = (1 / 3) * math.pi * h * (r1 ** 2 + r2 ** 2 + r1 * r2)\n    \n    return {\n        'lateral_surface_area': lateral_area,\n        'total_surface_area': total_area,\n        'volume': volume,\n    }", "subfield": "3D Shapes", "tool_name": "calculate_frustum_properties", "tool_type": "function", "description": "Calculate properties of a frustum formed by truncation of a right circular cone.", "docstring": "Calculate properties of a frustum formed by truncation of a right circular cone.\n    Parameters\n    ----------\n    r1 : float\n        Radius of the smaller circular base.\n    r2 : float\n        Radius of the larger circular base.\n    h : float\n        Height of the frustum (the distance between the two bases).\n    Returns\n    -------\n    dict :\n        A dictionary containing:\n            - lateral_surface_area : float\n                The lateral surface area of the frustum.\n            - total_surface_area : float\n                The total surface area of the frustum (including the areas of the two bases).\n            - volume : float\n                The volume of the frustum.\n    Examples\n    --------\n    >>> calculate_frustum_properties(3, 5, 7)\n    {\n        'lateral_surface_area': 150.079644737231,\n        'total_surface_area': 276.46015351590174,\n        'volume': 345.5774616441417\n    }", "Freq": 2, "TSR": 0, "experience_pool": "- Make sure to provide the correct input parameters (r1, r2, h) when calling the calculate_frustum_properties function.\n- Double-check the calculations and formulas used in the calling code to ensure they align with the properties of a frustum."}, {"tool": "def midpoint(p1, p2):\n    \n    return ((p1[0] + p2[0]) / 2, (p1[1] + p2[1]) / 2, (p1[2] + p2[2]) / 2)", "subfield": "3D Shapes", "tool_name": "midpoint", "tool_type": "function", "description": "Calculate the midpoint between two points in 3D space.", "docstring": "Calculate the midpoint between two points in 3D space.\n    Parameters:\n    - p1 : tuple of floats\n        Coordinates of the first point (x1, y1, z1).\n    - p2 : tuple of floats\n        Coordinates of the second point (x2, y2, z2).\n    Returns:\n    - tuple of floats\n        The midpoint coordinates (mx, my, mz).\n    Examples:\n    >>> midpoint((1, 1, 1), (3, 5, 3))\n    (2.0, 3.0, 2.0)", "Freq": 3, "TSR": 3}, {"tool": "def rotate_point(point, axis, theta):\n    \n    axis = np.array(axis)\n    theta = np.radians(theta)\n    axis = axis / np.linalg.norm(axis)\n    a = np.cos(theta / 2)\n    b, c, d = -axis * np.sin(theta / 2)\n    aa, bb, cc, dd = a**2, b**2, c**2, d**2\n    bc, ad, ac, ab, bd, cd = b*c, a*d, a*c, a*b, b*d, c*d\n    rot_matrix = np.array([[aa+bb-cc-dd, 2*(bc+ad), 2*(bd-ac)],\n                           [2*(bc-ad), aa+cc-bb-dd, 2*(cd+ab)],\n                           [2*(bd+ac), 2*(cd-ab), aa+dd-bb-cc]])\n    return np.dot(rot_matrix, point)", "subfield": "3D Shapes", "tool_name": "rotate_point", "tool_type": "function", "description": "Rotate a point around a given axis by theta degrees in 3D space.", "docstring": "Rotate a point around a given axis by theta degrees in 3D space.\n    Parameters:\n        point (array-like): The [x, y, z] coordinates of the point to rotate.\n        axis (array-like): The [x, y, z] coordinates of the axis to rotate about.\n        theta (float): The rotation angle in degrees.\n    Returns:\n        array: The new [x, y, z] coordinates of the rotated point.\n    Examples:\n        >>> rotate_point([1, 0, 0], [0, 0, 1], 90)\n        array([6.123234e-17, 1.000000e+00, 0.000000e+00])", "Freq": 0, "TSR": 0}, {"tool": "def count_unit_cubes_with_painted_faces(n, faces_painted):\n    \n    if faces_painted == 0:\n        return 0\n    elif faces_painted == 1:\n        return 6 * (n - 2)**2\n    elif faces_painted == 2:\n        return 12 * (n - 2)\n    elif faces_painted == 3:\n        return 8\n    return 0", "subfield": "3D Shapes", "tool_name": "count_unit_cubes_with_painted_faces", "tool_type": "function", "description": "Calculate the number of unit cubes with a certain number of painted faces in an n x n x n cube.", "docstring": "Calculate the number of unit cubes with a certain number of painted faces in an n x n x n cube.\n    Parameters:\n    n (int): The side length of the cube in terms of number of unit cubes.\n    faces_painted (int): The number of faces that are painted on the unit cubes.\n    Returns:\n    int: The count of unit cubes with exactly the specified number of painted faces.", "Freq": 3.5, "TSR": 1, "experience_pool": "Tool has been evolved to handle different scenarios and provide correct results."}, {"tool": "def line_plane_intersection(plane_normal, plane_point, line_point, line_dir):\n    \n    plane_normal = np.array(plane_normal)\n    plane_point = np.array(plane_point)\n    line_point = np.array(line_point)\n    line_dir = np.array(line_dir)\n    denom = np.dot(plane_normal, line_dir)\n    if np.abs(denom) < 1e-6:\n        return None  # No intersection, the line is parallel to the plane\n    t = (np.dot(plane_normal, plane_point - line_point)) / denom\n    return line_point + t * line_dir", "subfield": "3D Shapes", "tool_name": "line_plane_intersection", "tool_type": "function", "description": "Calculate the intersection point of a line and a plane in 3D.", "docstring": "Calculate the intersection point of a line and a plane in 3D.\n    \n    Parameters:\n    - plane_normal (iterable with three numbers): Normal vector of the plane.\n    - plane_point (iterable with three numbers): A point on the plane.\n    - line_point (iterable with three numbers): A point on the line.\n    - line_dir (iterable with three numbers): Direction vector of the line.\n    \n    Returns:\n    - array: The coordinates of the intersection point or None if no intersection exists.\n    \n    Example:\n    >>> line_plane_intersection([0, 0, 1], [0, 0, 5], [1, 1, 0], [0, 1, 1])\n    array([1., 4., 5.])", "Freq": 3, "TSR": 0, "experience_pool": "- Make sure to provide the correct input parameters (plane_normal, plane_point, line_point, line_dir) when calling the line_plane_intersection function.\n- Double-check the calculations and coordinates of points when using the line_plane_intersection function."}, {"tool": "def surface_area_cube(edge_length):\n    \n    return 6 * (edge_length ** 2)", "subfield": "3D Shapes", "tool_name": "surface_area_cube", "tool_type": "function", "description": "Calculate the surface area of a cube given the length of its edge.", "docstring": "Calculate the surface area of a cube given the length of its edge.\n    \n    Parameters:\n    - edge_length (float/int): The length of one edge of the cube.\n    \n    Returns:\n    - float: The surface area of the cube.\n    \n    Example:\n    >>> surface_area_cube(2)\n    24", "Freq": 1, "TSR": 1}, {"tool": "def prism_properties(num_bases, base_vertices, height_exists=True):\n    \n    vertices = num_bases * base_vertices\n    edges = num_bases * base_vertices + base_vertices * (num_bases - 1)\n    faces = num_bases + (height_exists * base_vertices)\n    return {\n        'vertices': vertices,\n        'edges': edges,\n        'faces': faces\n    }", "subfield": "3D Shapes", "tool_name": "prism_properties", "tool_type": "function", "description": "Calculate the properties (vertices, edges, faces) of a prism given \n    the properties of the base and whether it includes a height (for right prisms).", "docstring": "Calculate the properties (vertices, edges, faces) of a prism given \n    the properties of the base and whether it includes a height (for right prisms).\n    Parameters:\n    - num_bases (int): The number of identical bases the prism has (usually 2).\n    - base_vertices (int): The number of vertices on each base.\n    - height_exists (bool): True if the prism has a distinct height dimension (right prism), otherwise False.\n    Returns:\n    - dict: Dictionary containing number of vertices, edges, and faces.\n    Examples:\n    >>> prism_properties(2, 4)  # Rectangular prism\n    {'vertices': 8, 'edges': 12, 'faces': 6}\n    >>> prism_properties(2, 3)  # Triangular prism\n    {'vertices': 6, 'edges': 9, 'faces': 5}", "Freq": 0, "TSR": 0}, {"tool": "def volume_pyramid(base_area, height):\n    \n    return (1/3) * base_area * height", "subfield": "3D Shapes", "tool_name": "volume_pyramid", "tool_type": "function", "description": "Calculate the volume of a pyramid.", "docstring": "Calculate the volume of a pyramid.\n    Parameters:\n    - base_area : float\n        The area of the pyramid's base.\n    - height : float\n        The height of the pyramid from the base to the apex.\n    Returns:\n    - float\n        The volume of the pyramid.\n    Examples:\n    >>> volume_pyramid(9, 12)\n    36", "Freq": 2, "TSR": 2}, {"tool": "def find_centroid_of_tetrahedron(vertex1, vertex2, vertex3, vertex4):\n    \n    x = (vertex1[0] + vertex2[0] + vertex3[0] + vertex4[0]) / 4\n    y = (vertex1[1] + vertex2[1] + vertex3[1] + vertex4[1]) / 4\n    z = (vertex1[2] + vertex2[2] + vertex3[2] + vertex4[2]) / 4\n    \n    return (x, y, z)", "subfield": "3D Shapes", "tool_name": "find_centroid_of_tetrahedron", "tool_type": "function", "description": "Find the centroid of a tetrahedron given its vertices.", "docstring": "Find the centroid of a tetrahedron given its vertices.\n    Parameters\n    ----------\n    vertex1 : tuple of float\n        Coordinates of the first vertex (x1, y1, z1).\n    vertex2 : tuple of float\n        Coordinates of the second vertex (x2, y2, z2).\n    vertex3 : tuple of float\n        Coordinates of the third vertex (x3, y3, z3).\n    vertex4 : tuple of float\n        Coordinates of the fourth vertex (x4, y4, z4).\n    Returns\n    -------\n    tuple :\n        The coordinates of the centroid.\n    Examples\n    --------\n    >>> find_centroid_of_tetrahedron((0, 0, 0), (1, 0, 0), (0, 1, 0), (0, 0, 1))\n    (0.25, 0.25, 0.25)", "Freq": 2, "TSR": 2}, {"tool": "def pythagoras_theorem(a, b):\n    \n    return np.sqrt(a**2 + b**2)", "subfield": "3D Shapes", "tool_name": "pythagoras_theorem", "tool_type": "function", "description": "Calculate the hypotenuse of a right triangle given the other two sides.", "docstring": "Calculate the hypotenuse of a right triangle given the other two sides.\n    Parameters:\n    a : float\n        Length of one side of the right triangle.\n    b : float\n        Length of the other side of the right triangle.\n    Returns:\n    float\n        Length of the hypotenuse.\n        \n    Examples:\n    >>> pythagoras_theorem(3, 4)\n    5.0", "Freq": 2, "TSR": 2}, {"tool": "def sphere_surface_area(radius):\n    \n    return 4 * pi * radius ** 2", "subfield": "3D Shapes", "tool_name": "sphere_surface_area", "tool_type": "function", "description": "Calculate the surface area of a sphere.", "docstring": "Calculate the surface area of a sphere.\n    \n    Parameters:\n    - radius (float): The radius of the sphere.\n    \n    Returns:\n    - float: The total surface area of the sphere.\n    \n    Example:\n    >>> sphere_surface_area(2)\n    50.26548245743669", "Freq": 1, "TSR": 0}, {"tool": "def volume_polyhedron(points):\n    \n    hull = ConvexHull(points)\n    return hull.volume", "subfield": "3D Shapes", "tool_name": "volume_polyhedron", "tool_type": "function", "description": "Calculate the volume of a convex polyhedron defined by its vertices.", "docstring": "Calculate the volume of a convex polyhedron defined by its vertices.\n    Parameters:\n        points (array-like): A list of vertices of the polyhedron, where each vertex is a list [x, y, z].\n    Returns:\n        float: Volume of the polyhedron.\n    \n    Examples:\n        >>> volume_polyhedron([[0, 0, 0], [1, 0, 0], [0, 1, 0], [0, 0, 1]])\n        0.16666666666666666", "Freq": 0, "TSR": 0}, {"tool": "def relations_between_cube_and_sphere(cube_side):\n    \n    return cube_side / 2", "subfield": "3D Shapes", "tool_name": "relations_between_cube_and_sphere", "tool_type": "function", "description": "Calculate the relationship between a cube and an inscribed sphere.", "docstring": "Calculate the relationship between a cube and an inscribed sphere.\n    Parameters:\n        cube_side (float): The length of the side of the cube.\n    Returns:\n        float: The radius of the sphere inscribed in the cube.\n    Example:\n        >>> relations_between_cube_and_sphere(4)\n        2.0", "Freq": 1, "TSR": 0}, {"tool": "def calculate_tetrahedron_properties(edge_length):\n    \n    face_area = (math.sqrt(3) / 4) * edge_length ** 2\n    total_surface_area = 4 * face_area\n    volume = (edge_length ** 3) / (6 * math.sqrt(2))\n    \n    return {\n        'face_area': face_area,\n        'total_surface_area': total_surface_area,\n        'volume': volume,\n    }", "subfield": "3D Shapes", "tool_name": "calculate_tetrahedron_properties", "tool_type": "function", "description": "Calculate properties of a regular tetrahedron.", "docstring": "Calculate properties of a regular tetrahedron.\n    Parameters\n    ----------\n    edge_length : float\n        The length of one edge of the tetrahedron.\n    Returns\n    -------\n    dict :\n        A dictionary containing:\n            - face_area : float\n                The area of one of the triangular faces.\n            - total_surface_area : float\n                The total surface area of the tetrahedron.\n            - volume : float\n                The volume of the tetrahedron.\n    Examples\n    --------\n    >>> calculate_tetrahedron_properties(3)\n    {\n        'face_area': 3.8971143170299753,\n        'total_surface_area': 15.588457268119901,\n        'volume': 3.1819805153394633\n    }", "Freq": 2, "TSR": 0}, {"tool": "def inscribed_sphere_diameter(side_length):\n    \n    return side_length  # Diameter of inscribed sphere is equal to the side length of the cube.", "subfield": "3D Shapes", "tool_name": "inscribed_sphere_diameter", "tool_type": "function", "description": "Calculate the diameter of a sphere inscribed in a cube.", "docstring": "Calculate the diameter of a sphere inscribed in a cube.\n    \n    Parameters:\n    side_length : float\n        The length of a side of the cube.\n    \n    Returns:\n    float\n        The diameter of the inscribed sphere.\n    Examples:\n    >>> diameter = inscribed_sphere_diameter(10)\n    >>> print(diameter)\n    10.0", "Freq": 0, "TSR": 0}, {"tool": "def plane_from_points(p1, p2, p3):\n    \n    p1, p2, p3 = np.array(p1), np.array(p2), np.array(p3)\n    v1 = p2 - p1\n    v2 = p3 - p1\n    normal = np.cross(v1, v2)\n    d = -np.dot(normal, p1)\n    return normal, d", "subfield": "3D Shapes", "tool_name": "plane_from_points", "tool_type": "function", "description": "Determine the equation of a plane given three points in 3D space.", "docstring": "Determine the equation of a plane given three points in 3D space.\n    \n    Parameters:\n        p1, p2, p3 (array-like): Coordinates of three points in the plane.\n    Returns:\n        array: Coefficients of the plane equation ax + by + cz + d = 0\n    \n    Examples:\n        >>> plane_from_points([0, 0, 0], [1, 0, 0], [0, 1, 0])\n        (array([0., 0., 1.]), -0.0)", "Freq": 1, "TSR": 0}, {"tool": "def cube_cut_paint_faces(total_cubes, painted_cubes, side_cubes):\n    \n    # Assuming the large cube is painted on all faces and then cut.\n    # Cubes at the center of a face only have one painted face.\n    face_center_cubes = 6 * (side_cubes - 2)**2\n    # Cubes at the edge but not corners have 2 painted faces.\n    edge_cubes = 12 * (side_cubes - 2)\n    # Corner cubes", "subfield": "3D Shapes", "tool_name": "cube_cut_paint_faces", "tool_type": "function", "description": "Calculate the total faces painted after cutting a larger cube into\n    smaller unit cubes.", "docstring": "Calculate the total faces painted after cutting a larger cube into\n    smaller unit cubes.\n    \n    Parameters:\n    total_cubes : int\n        Total number of smaller cubes after cutting.\n    painted_cubes : int\n        Number of painted cubes.\n    side_cubes : int\n        Number of cubes along one edge of the cube.\n    \n    Returns:\n    int\n        The number of faces that are painted.\n    \n    Examples:\n    >>> faces_painted = cube_cut_paint_faces(27, 26, 3)\n    >>> print(faces_painted)\n    54", "Freq": 0, "TSR": 0}, {"tool": "def subtask_reconstruction_from_projections(projections):\n    \n    # For simplicity and lack of context, I'll return the sum of the maximums of each projection\n    return sum(max(proj) for proj in projections)", "subfield": "3D Shapes", "tool_name": "subtask_reconstruction_from_projections", "tool_type": "function", "description": "Estimate the minimum number of unit cubes needed to match given 2D projections.", "docstring": "Estimate the minimum number of unit cubes needed to match given 2D projections.\n    Parameters:\n        projections (list of list): Projections of the 3D object in terms of unit cubes per axis.\n    Returns:\n        int: Minimum number of unit cubes necessary to form the 3D shape.\n    Example:\n        >>> subtask_reconstruction_from_projections([[1, 2], [2, 1], [1, 3]])\n        6", "Freq": 0, "TSR": 0}, {"tool": "def geometric_calculations(shape_type, dimensions):\n    \n    \n    def count_diagonals_cube():\n        # A cube has 12 edges and 8 vertices\n        vertices = 8\n        edges = 12\n        # Diagonals = Total connections - edges - vertices\n        diagonals = (vertices * (vertices - 1) // 2) - edges - vertices\n        return diagonals\n    \n    def orthocenter_triangle(A, B, C):\n        # Calculate the orthocenter of triangle ABC\n        # A, B, C are tuples representing the coordinates of the vertices\n        A = np.array(A)\n        B = np.array(B)\n        C = np.array(C)\n        \n        # Calculate the midpoints of sides\n        D = (A + B) / 2\n        E = (B + C) / 2\n        F = (C + A) / 2\n        \n        # Calculate the slopes of the altitudes\n        slope_AB = (B[1] - A[1]) / (B[0] - A[0]) if (B[0] - A[0]) != 0 else float('inf')\n        slope_BC = (C[1] - B[1]) / (C[0] - B[0]) if (C[0] - B[0]) != 0 else float('inf')\n        \n        # Calculate the perpendicular slopes\n        perp_slope_AB = -1 / slope_AB if slope_AB != 0 else 0\n        perp_slope_BC = -1 / slope_BC if slope_BC != 0 else 0\n        \n        # Calculate the equations of the altitudes\n        # Using point-slope form: y - y1 = m(x - x1)\n        # For altitude from C to AB\n        altitude_C = lambda x: perp_slope_AB * (x - C[0]) + C[1]\n        # For altitude from A to BC\n        altitude_A = lambda x: perp_slope_BC * (x - A[0]) + A[1]\n        \n        # Solve for intersection (orthocenter)\n        # This requires solving altitude_C(x) = altitude_A(x)\n        # This can be done numerically or symbolically depending on the slopes\n        \n        # Here we will use a numerical approach to find the intersection\n        from scipy.optimize import fsolve\n        \n        def equations(x):\n            return altitude_C(x) - altitude_A(x)\n        \n        x_orthocenter = fsolve(equations, A[0])[0]\n        y_orthocenter = altitude_C(x_orthocenter)\n        \n        return (x_orthocenter, y_orthocenter)\n    \n    def cylinder_in_hemisphere(radius_cylinder, radius_hemisphere):\n        # Calculate the height of a cylinder inscribed in a hemisphere\n        height = np.sqrt(radius_hemisphere**2 - radius_cylinder**2)\n        return height\n    \n    if shape_type == 'cube':\n        return {'number_of_diagonals': count_diagonals_cube()}\n    elif shape_type == 'triangle':\n        return {'orthocenter': orthocenter_triangle(**dimensions)}\n    elif shape_type == 'cylinder_in_hemisphere':\n        return {'height': cylinder_in_hemisphere(dimensions['radius_cylinder'], dimensions['radius_hemisphere'])}\n    else:\n        raise ValueError(\"Unsupported shape_type provided.\")", "subfield": "3D Shapes", "tool_name": "geometric_calculations", "tool_type": "function", "description": "Perform various geometric calculations based on the shape type and dimensions provided.", "docstring": "Perform various geometric calculations based on the shape type and dimensions provided.\n    Parameters:\n    shape_type (str): The type of geometric shape ('cube', 'triangle', 'cylinder_in_hemisphere').\n    dimensions (dict): A dictionary containing the necessary dimensions for the calculation.\n    Returns:\n    dict: A dictionary containing the results of the calculations.", "Freq": 3, "TSR": 1}], "Transformations": [{"tool": "def reflect_point(point, axis, position=0):\n    \n    x, y = point\n    if axis.lower() == 'y':\n        return (2*position - x, y)\n    elif axis.lower() == 'x':\n        return (x, 2*position - y)\n    else:\n        raise ValueError(\"Axis must be 'x' or 'y'.\")", "subfield": "Transformations", "tool_name": "reflect_point", "tool_type": "function", "description": "Reflect a point across a specified axis.", "docstring": "Reflect a point across a specified axis.\n    Parameters:\n    point : tuple\n        The (x, y) coordinates of the point to reflect.\n    axis : str\n        The axis across which to reflect ('x' or 'y').\n    position : float, optional\n        The position of the axis of reflection (default is 0 for either axis).\n        \n    Returns:\n    tuple\n        The reflected (x, y) coordinates.\n        \n    Examples:\n    >>> reflect_point((2, 3), 'y')\n    (-2, 3)\n    >>> reflect_point((3, 4), 'x', 2)\n    (3, 0)", "Freq": 6, "TSR": 4, "experience_pool": "Reflect_point function is used to reflect a point across a specified axis. The axis parameter should be either 'x' or 'y'. Make sure to provide the correct axis parameter when calling the function."}, {"tool": "def rotate_point(point, angle, origin=(0, 0)):\n    \n    angle_rad = np.radians(angle)\n    sin_a, cos_a = np.sin(angle_rad), np.cos(angle_rad)\n    x, y = point\n    ox, oy = origin\n    # Translate point to origin\n    x -= ox\n    y -= oy\n    # Rotate point\n    x_new = x * cos_a - y * sin_a\n    y_new = x * sin_a + y * cos_a\n    # Translate point back\n    x_new += ox\n    y_new += oy\n    return (x_new, y_new)", "subfield": "Transformations", "tool_name": "rotate_point", "tool_type": "function", "description": "Rotate a point around a given origin by a specific angle.", "docstring": "Rotate a point around a given origin by a specific angle.\n    Parameters:\n    - point (tuple): The coordinates (x, y) of the point.\n    - angle (float): The rotation angle in degrees.\n    - origin (tuple): The origin around which the point is rotated.\n    Returns:\n    - tuple: The coordinates of the rotated point.\n    \n    Examples:\n    - rotate_point((1, 0), 90) will rotate (1,0) by 90 degrees around the origin, resulting in (0,1).\n    - rotate_point((0, 1), 90, (1, 1)) will rotate (0,1) by 90 degrees around (1,1), resulting in (1,0).", "Freq": 8, "TSR": 2, "experience_pool": "1. When rotating points using the rotate_point function, ensure that the input parameters are correctly provided in the form of tuples for point and origin, and a float for the angle.\n2. When calling the rotate_point function, make sure to pass the correct number of parameters and provide the necessary origin if different from the default (0, 0).\n3. Remember that the rotate_point function returns the coordinates of the rotated point as a tuple."}, {"tool": "def translate_point(point, vector):\n    \n    x, y = point\n    dx, dy = vector\n    return (x + dx, y + dy)", "subfield": "Transformations", "tool_name": "translate_point", "tool_type": "function", "description": "Translate a point by a given vector.", "docstring": "Translate a point by a given vector.\n    Parameters:\n    point : tuple\n        The (x, y) coordinates of the point to translate.\n    vector : tuple\n        The (dx, dy) translation vector.\n        \n    Returns:\n    tuple\n        The translated (x, y) coordinates.\n    \n    Examples:\n    >>> translate_point((1, 2), (3, 1))\n    (4, 3)", "Freq": 4, "TSR": 4}, {"tool": "def rotate(shape, angle, origin=np.array([0, 0])):\n    \n    rad = np.deg2rad(angle)\n    rotation_matrix = np.array([[np.cos(rad), -np.sin(rad)], [np.sin(rad), np.cos(rad)]])\n    return np.dot(shape - origin, rotation_matrix) + origin", "subfield": "Transformations", "tool_name": "rotate", "tool_type": "function", "description": "Rotate a shape counterclockwise by a given angle around an origin.", "docstring": "Rotate a shape counterclockwise by a given angle around an origin.\n    Parameters:\n    shape (np.array): An Nx2 numpy array of points representing the shape.\n    angle (float): Angle of rotation in degrees.\n    origin (np.array, optional): 1x2 numpy array representing the rotation origin. Defaults to the origin.\n    Returns:\n    np.array: Rotated shape as an Nx2 numpy array.\n    Example:\n    >>> rotate(np.array([[1, 0], [0, 1]]), 90)\n    array([[ 0.,  1.],\n           [-1.,  0.]])", "Freq": 0, "TSR": 0}, {"tool": "def apply_affine_transformation(point, matrix, translation_vector=(0, 0)):\n    \n    transformed_point = np.dot(matrix, np.array(point)) + np.array(translation_vector)\n    return tuple(transformed_point)", "subfield": "Transformations", "tool_name": "apply_affine_transformation", "tool_type": "function", "description": "Apply an affine transformation to a 2D point using a transformation matrix and optional translation.", "docstring": "Apply an affine transformation to a 2D point using a transformation matrix and optional translation.\n    Parameters:\n    - point (tuple): A tuple (x, y) representing the coordinates of the initial point.\n    - matrix (array): A 2x2 numpy array representing the rotation or scaling matrix.\n    - translation_vector (tuple): A tuple (dx, dy) representing the translation.\n    Returns:\n    - tuple: Coordinates of the transformed point.\n    Example:\n    >>> apply_affine_transformation((1, 0), np.array([[0, -1], [1, 0]]), (1, 1))\n    (1, 2)", "Freq": 0, "TSR": 0}, {"tool": "def calculate_distance(point1, point2, is_complex=False):\n    \n    if is_complex:\n        return abs(point1 - point2)\n    else:\n        return np.sqrt((point1[0] - point2[0])**2 + (point1[1] - point2[1])**2)", "subfield": "Transformations", "tool_name": "calculate_distance", "tool_type": "function", "description": "Calculate the Euclidean distance between two points in the plane.", "docstring": "Calculate the Euclidean distance between two points in the plane.\n    Parameters:\n    - point1, point2 (tuple or complex): The points between which distance is calculated.\n      Each point can either be a tuple (x, y) in Cartesian coordinates or a complex number.\n    - is_complex (bool): Whether the points are specified as complex numbers.\n    Returns:\n    - float: The calculated Euclidean distance.\n    Example:\n    >>> calculate_distance((1, 2), (4, 6))\n    5.0\n    >>> calculate_distance(1+2j, 4+6j, is_dateinline=True)\n    5.0", "Freq": 1, "TSR": 1}, {"tool": "def translate(shape, vector):\n    \n    return shape + vector", "subfield": "Transformations", "tool_name": "translate", "tool_type": "function", "description": "Apply a translation to a geometric shape.", "docstring": "Apply a translation to a geometric shape.\n    Parameters:\n    shape (np.array): An Nx2 numpy array representing points of the shape in 2D (each row is a point).\n    vector (np.array): A 1x2 numpy array representing the translation vector.\n    Returns:\n    np.array: Translated shape as an Nx2 numpy array.\n    Example:\n    >>> translate(np.array([[0, 0], [1, 0], [1, 1]]), np.array([2, 3]))\n    array([[2, 3], [3, 3], [3, 4]])", "Freq": 0, "TSR": 0}, {"tool": "def reflect(shape, axis):\n    \n    reflected_shape = np.copy(shape)\n    reflected_shape[:, axis] = -reflected_shape[:, axis]\n    return reflected_shape", "subfield": "Transformations", "tool_name": "reflect", "tool_type": "function", "description": "Reflect a shape across a specified axis.", "docstring": "Reflect a shape across a specified axis.\n    Parameters:\n    shape (np.array): An Nx2 numpy array of points.\n    axis (int): Axis to reflect across. 0 for y-axis, 1 for x-axis.\n    Returns:\n    np.array: Reflected shape as an Nx2 numpy array.\n    Example:\n    >>> reflect(np.array([[1, 1], [-1, 1]]), 0)\n    array([[-1,  1],\n           [ 1,  1]])", "Freq": 2, "TSR": 0}, {"tool": "def reflect_point_over_line(point, line_coefficients):\n    \n    x, y = point\n    A, B, C = line_coefficients\n    D = A * A + B * B\n    x_prime = (B * B * x - A * B * y - A * C) / D\n    y_prime = (A * A * y - A * B * x - B * C) / D\n    return (x_prime, y_prime)", "subfield": "Transformations", "tool_name": "reflect_point_over_line", "tool_type": "function", "description": "Calculate the reflection of a point across a line represented in standard form.", "docstring": "Calculate the reflection of a point across a line represented in standard form.\n    Parameters:\n    - point (tuple): A tuple (x, y) representing the coordinates of the point to reflect.\n    - line_coefficients (tuple): A tuple (A, B, C) representing the line Ax + By + C = 0.\n    Returns:\n    - tuple: Coordinates of the reflected point.\n    Example:\n    >>> reflect_point_over_line((1, 1), (1, -1, 0)) \n    (1, 1)", "Freq": 0, "TSR": 0}, {"tool": "def generate_transformation_matrix(transformation_type, parameters):\n    \n    import numpy as np\n    if transformation_type.lower() == 'reflection':\n        axis = parameters.get('axis', 'x').lower()\n        position = parameters.get('position', 0)\n        if axis == 'x':\n            return np.array([[1, 0], [0, -1]])\n        elif axis == 'y':\n            return np.array([[-1, 0], [0, 1]])\n        else:\n            raise ValueError(\"Invalid axis for reflection. Use 'x' or 'y'.\")\n    \n    elif transformation_type.lower() == 'dilation':\n        center = parameters.get('center', (0, 0))\n        scale_factor = parameters.get('scale_factor', 1)\n        cx, cy = center\n        return np.array([[scale_factor, 0, cx * (1 - scale_factor)], \n                         [0, scale_factor, cy * (1 - scale_factor)], \n                         [0, 0, 1]])\n    \n    else:\n        raise ValueError(\"Transformation type not recognized. Use 'reflection' or 'dilation'.\")", "subfield": "Transformations", "tool_name": "generate_transformation_matrix", "tool_type": "function", "description": "Generate a transformation matrix based on the specified transformation type.", "docstring": "Generate a transformation matrix based on the specified transformation type.\n    Parameters:\n    transformation_type (str): The type of transformation ('reflection', 'dilation').\n    parameters (dict): A dictionary containing the parameters for the transformation.\n                       For 'reflection', provide 'axis' (str) and 'position' (float, optional).\n                       For 'dilation', provide 'center' (tuple of float) and 'scale_factor' (float).\n    Returns:\n    np.ndarray: The transformation matrix for the specified transformation.\n    Raises:\n    ValueError: If the transformation_type is not recognized or if parameters are invalid.", "Freq": 1, "TSR": 0}], "Squares": [{"tool": "def square_area(side_length):\n    \n    return side_length ** 2", "subfield": "Squares", "tool_name": "square_area", "tool_type": "function", "description": "Calculate the area of a square given the side length.", "docstring": "Calculate the area of a square given the side length.\n    \n    Parameters:\n    side_length : float\n        The side length of the square.\n        \n    Returns:\n    float\n        The area of the square.\n    \n    Examples:\n    >>> square_area(5)\n    25", "Freq": 3, "TSR": 2}, {"tool": "def calculate_square_properties(side_length):\n    \n    area = side_length ** 2\n    perimeter = 4 * side_length\n    diagonal = math.sqrt(2) * side_length\n    \n    return {\n        'area': area,\n        'perimeter': perimeter,\n        'diagonal': diagonal\n    }", "subfield": "Squares", "tool_name": "calculate_square_properties", "tool_type": "function", "description": "Calculate various properties of a square, including area, perimeter, and diagonal.", "docstring": "Calculate various properties of a square, including area, perimeter, and diagonal.\n    Parameters:\n    - side_length (float): The length of a side of the square.\n    Returns:\n    - dict: A dictionary containing the area, perimeter, and diagonal length of the square.\n    Examples:\n    >>> calculate_square_properties(4)\n    {'area': 16, 'perimeter': 16, 'diagonal': 5.656854249492381}", "Freq": 1, "TSR": 0}, {"tool": "def calculate_inscribed_circle_radius(side_length):\n    \n    return side_length / 2", "subfield": "Squares", "tool_name": "calculate_inscribed_circle_radius", "tool_type": "function", "description": "Calculate the radius of a circle inscribed in a square.", "docstring": "Calculate the radius of a circle inscribed in a square.\n    \n    Parameters:\n    - side_length (float): The length of the side of the square.\n    \n    Returns:\n    - float: The radius of the inscribed circle.\n    \n    Example:\n    >>> calculate_inscribed_circle_radius(4)\n    2.0", "Freq": 0, "TSR": 0}, {"tool": "def count_inscribed_squares(larger_square_side, smaller_square_side):\n    \n    num_per_side = larger_square_side // smaller_square_side\n    return num_per_side ** 2", "subfield": "Squares", "tool_name": "count_inscribed_squares", "tool_type": "function", "description": "Calculate how many smaller squares of a given side length can be inscribed within a larger square.", "docstring": "Calculate how many smaller squares of a given side length can be inscribed within a larger square.\n    \n    Parameters:\n    larger_square_side (float): The side length of the larger square.\n    smaller_square_side (float): The side length of the smaller squares to fit inside the larger square.\n    \n    Returns:\n    int: Number of smaller squares that can fit inside the larger square.\n    \n    Examples:\n    >>> count_inscribed_squares(10, 2)\n    25", "Freq": 0, "TSR": 0}, {"tool": "def number_of_squares(total_length, square_side):\n    \n    return total_length // square_side", "subfield": "Squares", "tool_name": "number_of_squares", "tool_type": "function", "description": "Calculate the maximum number of non-overlapping squares that can fit along a line of given total length.", "docstring": "Calculate the maximum number of non-overlapping squares that can fit along a line of given total length.\n    Parameters:\n    - total_length (float): The total length of the line.\n    - square_side (float): The side length of each square.\n    Returns:\n    - int: The total number of non-overlapping squares that can fit.\n    Examples:\n    >>> number_of_squares(10, 2)\n    5", "Freq": 0, "TSR": 0}, {"tool": "def number_of_smaller_squares_in_larger_one(larger_side, smaller_side):\n    \n    return (larger_side // smaller_side) ** 2", "subfield": "Squares", "tool_name": "number_of_smaller_squares_in_larger_one", "tool_type": "function", "description": "Calculate the number of smaller squares that can fit within a larger square\n    based on the side lengths of the larger and smaller squares.", "docstring": "Calculate the number of smaller squares that can fit within a larger square\n    based on the side lengths of the larger and smaller squares.\n    \n    Parameters:\n    larger_side : float\n        The side length of the larger square.\n    smaller_side : float\n        The side length of the smaller square.\n        \n    Returns:\n    int\n        The maximum number of smaller squares that can fit in the larger square.\n    \n    Examples:\n    >>> number_of_smaller_squares_in_larger_one(10, 2)\n    25", "Freq": 0, "TSR": 0}, {"tool": "def square_side_length(area=None, perimeter=None):\n    \n    if area is not None and perimeter is not None:\n        raise ValueError(\"Please provide either area or perimeter, not both.\")\n    \n    if area is not None:\n        return area ** 0.5  # side length from area\n    \n    if perimeter is not None:\n        return perimeter / 4  # side length from perimeter\n    \n    raise ValueError(\"Either area or perimeter must be provided.\")", "subfield": "Squares", "tool_name": "square_side_length", "tool_type": "function", "description": "Calculate the side length of a square based on its area or perimeter.", "docstring": "Calculate the side length of a square based on its area or perimeter.\n    \n    Parameters:\n    area (float): The area of the square. Default is None.\n    perimeter (float): The perimeter of the square. Default is None.\n    \n    Returns:\n    float: The side length of the square.\n    \n    Raises:\n    ValueError: If neither area nor perimeter is provided, or if both are provided.\n    \n    Notes:\n    The side length can be calculated using the following formulas:\n    - From area: side_length = sqrt(area)\n    - From perimeter: side_length = perimeter / 4", "Freq": 2, "TSR": 1}], "Planes in Three Dimensions": [{"tool": "def plane_from_normal_and_point(normal, point):\n    \n    x, y, z = sp.symbols('x y z')\n    A, B, C = normal\n    D = sp.simplify(-(A*point[0] + B*point[1] + C*point[2]))\n    plane_eq = A*x + B*y + C*z + D\n    return sp.Poly(plane_eq, x, y, z)", "subfield": "Planes in Three Dimensions", "tool_name": "plane_from_normal_and_point", "tool_type": "function", "description": "Define the plane equation given a normal vector and a point through which the plane passes.", "docstring": "Define the plane equation given a normal vector and a point through which the plane passes.\n    \n    Parameters:\n        normal (tuple): Normal vector of the plane (A, B, C).\n        point (tuple): A point (x0, y0, z0) on the plane.\n    \n    Returns:\n        sympy.Poly: The equation of the plane in symbolic form (Ax + By + Cz + D).\n    \n    Example:\n        >>> plane_from_normal_and_point((1, 2, 1), (3, 4, 5))\n        Poly(1*x + 2*y + 1*z - 14, x, y, z, domain='ZZ')", "Freq": 0, "TSR": 0}, {"tool": "def distance_point_to_plane(point, plane):\n    \n    x0, y0, z0 = point\n    A, B, C, D = plane\n    num = abs(A*x0 + B*y0 + C*z0 + D)\n    den = np.sqrt(A**2 + B**2 + C**2)\n    return num / den", "subfield": "Planes in Three Dimensions", "tool_name": "distance_point_to_plane", "tool_type": "function", "description": "Calculate the perpendicular distance from a point to a given plane in 3D space.", "docstring": "Calculate the perpendicular distance from a point to a given plane in 3D space.\n    Parameters:\n        point (tuple): The (x, y, z) coordinates of the point.\n        plane (tuple): The coefficients (A, B, C, D) of the plane equation Ax + By + Cz + D = 0\n    Returns:\n        float: The distance from the point to the plane.\n    \n    Example:\n        >>> distance_point_to_plane((1, 1, 1), (0, 0, 1, -1))\n        2.0", "Freq": 1, "TSR": 1}, {"tool": "def are_planes_parallel(plane1, plane2):\n    \n    A1, B1, C1, _ = plane1\n    A2, B2, C2, _ = plane2\n    cross_prod = np.cross((A1, B1, C1), (A2, B2, C2))\n    return np.allclose(cross_prod, (0, 0, 0))", "subfield": "Planes in Three Dimensions", "tool_name": "are_planes_parallel", "tool_type": "function", "description": "Determines if two planes are parallel.", "docstring": "Determines if two planes are parallel.\n    Parameters:\n        plane1, plane2 (tuple): The coefficients (A, B, C, D) of the plane equations\n    Returns:\n        bool: True if the planes are parallel, otherwise False\n    \n    Example:\n        >>> are_planes_parallel((0, 0, 1, 2), (0, 0, 1, 3))\n        True", "Freq": 0, "TSR": 0}, {"tool": "def plane_equation_from_points(p1, p2, p3):\n    \n    p1, p2, p3 = np.array(p1), np.array(p2), np.array(p3)\n    v1 = p2 - p1\n    v2 = p3 - p1\n    normal_vector = np.cross(v1, v2)\n    A, B, C = normal_vector\n    D = -np.dot(normal_vector, p1)\n    return (A, B, C, D)", "subfield": "Planes in Three Dimensions", "tool_name": "plane_equation_from_points", "tool_type": "function", "description": "Determine the equation of a plane given three non-collinear points in 3D space.", "docstring": "Determine the equation of a plane given three non-collinear points in 3D space.\n    Parameters:\n        p1, p2, p3 (tuple): Tuples of the form (x, y, z) representing the coordinates of the points.\n    Returns:\n        tuple: Returns the coefficients (A, B, C, D) of the plane equation Ax + By + Cz + D = 0\n    \n    Example:\n        >>> plane_equation_from_points((0,0,0), (1,0,0), (0,1,0))\n        (0, 0, 1, 0)", "Freq": 3, "TSR": 0}, {"tool": "def plane_normal_vector(point1, point2, point3):\n    \n    p1, p2, p3 = sp.Matrix(point1), sp.Matrix(point2), sp.Matrix(point3)\n    normal = (p2 - p1).cross(p3 - p1)\n    return tuple(normal)", "subfield": "Planes in Three Dimensions", "tool_name": "plane_normal_vector", "tool_type": "function", "description": "Finds the normal vector to a plane defined by three points.", "docstring": "Finds the normal vector to a plane defined by three points.\n    \n    Parameters:\n        point1 (tuple): Coordinates of the first point.\n        point2 (tuple): Coordinates of the second point.\n        point3 (tuple): Coordinates of the third point.\n        \n    Returns:\n        tuple: Normal vector components (A, B, C) of the plane.\n        \n    Example:\n        >>> plane_normal_vector((1, 2, 3), (2, 3, 4), (4, 6, 7))\n        (2, -5, 2)", "Freq": 0, "TSR": 0}, {"tool": "def check_point_on_plane(point, plane_coeffs):\n    \n    A, B, C, D = plane_coeffs\n    x, y, z = point\n    return abs(A * x + B * y + C * z + D) < 1e-10", "subfield": "Planes in Three Dimensions", "tool_name": "check_point_on_plane", "tool_type": "function", "description": "Check if a point is on a plane defined by the given equation.", "docstring": "Check if a point is on a plane defined by the given equation.\n    Parameters:\n    - point (tuple/list): Coordinates of the point (x, y, z).\n    - plane_coeffs (tuple/list): Plane equation coefficients (A, B, C, D).\n    \n    Returns:\n    - bool: True if the point is on the plane, else False.\n    \n    Examples:\n    >>> check_point_on_plane((1, 2, 3), (1, 1, 1, -6))\n    True", "Freq": 0, "TSR": 0}], "Similar Triangles": [{"tool": "def compute_similar_triangle_sides(base_sides, ratio):\n    \n    return tuple([side * ratio for side in base_sides])", "subfield": "Similar Triangles", "tool_name": "compute_similar_triangle_sides", "tool_type": "function", "description": "Given the side lengths of a triangle and a ratio of similarity, compute the side lengths of the similar triangle.", "docstring": "Given the side lengths of a triangle and a ratio of similarity, compute the side lengths of the similar triangle.\n    Parameters:\n    - base_sides (tuple): A tuple representing the lengths of the sides (float) of the base triangle.\n    - ratio (float): The ratio of the sides of the similar triangle compared to the base triangle.\n    Returns:\n    - similar_sides (tuple): The lengths of the sides of the similar triangle.\n    Example:\n    >>> compute_similar_triangle_sides((3, 4, 5), 2)\n    (6, 8, 10)", "Freq": 1, "TSR": 0}, {"tool": "def calculate_area_and_perimeter_ratios(sides1, sides2):\n    \n    sides_ratio = [s2 / s1 for s1, s2 in zip(sides1, sides2)]\n    perimeter_ratio = sum(sides2) / sum(sides1)\n    area_ratio = np.mean(sides_ratio) ** 2  # (scale factor)^2 for areas in similar triangles\n    \n    return (area_ratio, perimeter_ratio)", "subfield": "Similar Triangles", "tool_name": "calculate_area_and_perimeter_ratios", "tool_type": "function", "description": "Calculate the ratios of areas and perimeters between two similar triangles based on side lengths.", "docstring": "Calculate the ratios of areas and perimeters between two similar triangles based on side lengths.\n    Parameters:\n        sides1 (list of float): Sides of the first triangle. \n        sides2 (list of float): Sides of the second triangle.\n    Returns:\n        tuple:\n            - float: Ratio of areas (area of triangle 2 / area of triangle 1).\n            - float: Ratio of perimeters (perimeter of triangle 2 / perimeter of triangle 1).\n    \n    Examples:\n    >>> calculate_area_and_perimeter_ratios([3, 3, 3], [6, 6, 6])\n    (4.0, 2.0)", "Freq": 5, "TSR": 2}, {"tool": "def calculate_similar_triangle_perimeter(original_perimeter, scale_factor):\n    \n    return original_perimeter * scale_factor", "subfield": "Similar Triangles", "tool_name": "calculate_similar_triangle_perimeter", "tool_type": "function", "description": "Calculate the perimeter of a similar triangle given the original perimeter and the scale factor.", "docstring": "Calculate the perimeter of a similar triangle given the original perimeter and the scale factor.\n    \n    Parameters:\n    - original_perimeter (float): Perimeter of the original triangle.\n    - scale_factor (float): Ratio of the similar triangle's side length to the original.\n    \n    Returns:\n    - float: The perimeter of the similar triangle.\n    \n    Examples:\n    >>> calculate_similar_triangle_perimeter(30, 0.5)\n    15.0", "Freq": 3, "TSR": 2}, {"tool": "def calculate_ratio(lengths_triangle1, lengths_triangle2):\n    \n    return tuple(b / a for a, b in zip(lengths_triangle1, lengths_triangle2))", "subfield": "Similar Triangles", "tool_name": "calculate_ratio", "tool_type": "function", "description": "Calculate the corresponding side length ratios between two similar triangles.", "docstring": "Calculate the corresponding side length ratios between two similar triangles.\n    \n    Parameters:\n    - lengths_triangle1 (list of float): The list of side lengths of the first triangle.\n    - lengths_triangle2 (list of float): The list of side lengths of the second triangle.\n    Returns:\n    - tuple of float: Tuple of ratios of corresponding sides.\n    Examples:\n    - calculate_ratio([3, 4, 5], [6, 8, 10]) returns (2.0, 2.0, 2.0)", "Freq": 1, "TSR": 0}, {"tool": "def calculate_area_of_triangle(base, height):\n    \n    return 0.5 * base * height", "subfield": "Similar Triangles", "tool_name": "calculate_area_of_triangle", "tool_type": "function", "description": "Calculate the area of a triangle given base and height.", "docstring": "Calculate the area of a triangle given base and height.\n    \n    Parameters:\n    - base (float): The length of the base of the triangle.\n    - height (float): The height of the triangle.\n    \n    Returns:\n    - float: The calculated area of the triangle.\n    \n    Examples:\n    >>> calculate_area_of_triangle(10, 5)\n    25.0", "Freq": 5, "TSR": 0, "experience_pool": "Tool: calculate_area_of_triangle\nField: Geometry\nSubfield: Similar Triangles\n- Correct usage: calculate_area_of_triangle(10, 5) returns 25.0\n- Correct usage: calculate_area_of_triangle(3, 4) returns 6.0\n- Correct usage: calculate_area_of_triangle(7, 8) returns 28.0"}, {"tool": "def missing_sides_of_similar_triangles(sides_known_triangle, sides_partial_triangle, ratio):\n    \n    computed_sides = []\n    for known, partial in zip(sides_known_triangle, sides_partial_triangle):\n        if partial is None:\n            computed_sides.append(known * ratio)\n        else:\n            computed_sides.append(partial)\n    return computed_sides", "subfield": "Similar Triangles", "tool_name": "missing_sides_of_similar_triangles", "tool_type": "function", "description": "Compute missing side lengths in a similar triangle given side lengths of another triangle and the ratio.", "docstring": "Compute missing side lengths in a similar triangle given side lengths of another triangle and the ratio.\n    Parameters:\n    - sides_known_triangle (list): List of three side lengths of the fully known triangle.\n    - sides_partial_triangle (list): List of side lengths of the similar triangle, with None for unknown sides.\n    - ratio (float): The ratio of similarity between two triangles.\n    Returns:\n    - list: A list containing the computed side lengths of the similar triangle.\n    Examples:\n    >>> missing_sides_of_similar_triangles([3, 4, 5], [1.5, None, None], 0.5)\n    [1.5, 2.0, 2.5]", "Freq": 8, "TSR": 0, "experience_pool": "- The tool is functioning correctly and providing accurate results.\n- The errors in the wrong tool callings are related to incorrect input parameters or calculations in the calling code."}, {"tool": "def area_ratio_from_side_ratio(side_ratio):\n    \n    return side_ratio ** 2", "subfield": "Similar Triangles", "tool_name": "area_ratio_from_side_ratio", "tool_type": "function", "description": "Given the ratio of the sides of similar triangles, compute the ratio of their areas.", "docstring": "Given the ratio of the sides of similar triangles, compute the ratio of their areas.\n    \n    Parameters:\n    - side_ratio (float): The common ratio of corresponding sides of the triangles.\n    \n    Returns:\n    - float: The ratio of the areas of the triangles.\n    \n    Examples:\n    - area_ratio_from_side_ratio(2) returns 4", "Freq": 3, "TSR": 2}, {"tool": "def solve_similar_triangle_properties(known_sides=None, known_area=None, perimeter=None, ratio=None):\n    \n    \n    results = {}\n    \n    def calculate_area_from_ratio(known_area, ratio):\n        \n        return known_area * (ratio ** 2)\n    \n    def calculate_sides_from_perimeter(perimeter, ratio):\n        \n        return perimeter * ratio\n    \n    if known_area is not None and ratio is not None:\n        results['similar_triangle_area'] = calculate_area_from_ratio(known_area, ratio)\n    \n    if perimeter is not None and ratio is not None:\n        results['similar_triangle_perimeter'] = calculate_sides_from_perimeter(perimeter, ratio)\n    \n    if known_sides is not None and ratio is not None:\n        results['similar_triangle_sides'] = tuple(side * ratio for side in known_sides)\n    \n    return results", "subfield": "Similar Triangles", "tool_name": "solve_similar_triangle_properties", "tool_type": "function", "description": "Solve for unknown properties of similar triangles given known sides, area, perimeter, and ratio.", "docstring": "Solve for unknown properties of similar triangles given known sides, area, perimeter, and ratio.\n    Parameters:\n    known_sides (tuple): A tuple containing the known side lengths of the triangle.\n    known_area (float): The area of the known triangle.\n    perimeter (float): The perimeter of the known triangle.\n    ratio (float): The ratio of similarity between the triangles.\n    Returns:\n    dict: A dictionary containing the calculated unknown side lengths, area, and perimeter of the similar triangle.", "Freq": 0, "TSR": 0}], "Pythagorean Theorem": [{"tool": "def simplify_radical(expression):\n    \n    return str(nsimplify(sqrt(expression)))", "subfield": "Pythagorean Theorem", "tool_name": "simplify_radical", "tool_type": "function", "description": "Simplifies square roots to their simplest radical form using symbolic computation.", "docstring": "Simplifies square roots to their simplest radical form using symbolic computation.\n    Parameters:\n    expression : float\n        The expression (usually a square root) to be simplified.\n    Returns:\n    str\n        The simplified expression in radical form.\n    Examples:\n    >>> simplify_radical(8)\n    '2*sqrt(2)'\n    >>> simplify_radical(18)\n    '3*sqrt(2)'", "Freq": 0, "TSR": 0}, {"tool": "def pythagorean_tools(leg_a=None, leg_b=None, hypotenuse=None, radius=None, hemisphere_radius=None):\n    \n    \n    results = {}\n    \n    def calculate_hypotenuse(leg_a, leg_b):\n        \n        return (leg_a**2 + leg_b**2)**0.5\n    \n    def calculate_missing_leg(hypotenuse, leg_a):\n        \n        missing_leg_squared = hypotenuse**2 - leg_a**2\n        if missing_leg_squared < 0:\n            raise ValueError(\"Hypotenuse must be greater than the known leg.\")\n        return missing_leg_squared**0.5\n    \n    def calculate_cylinder_height(radius, hemisphere_radius):\n        \n        height_squared = hemisphere_radius**2 - radius**2\n        if height_squared < 0:\n            raise ValueError(\"The radius must be less than the hemisphere radius.\")\n        return height_squared**0.5\n    \n    # Calculate hypotenuse if both legs are provided\n    if leg_a is not None and leg_b is not None:\n        results['hypotenuse'] = calculate_hypotenuse(leg_a, leg_b)\n    \n    # Calculate missing leg if hypotenuse and one leg are provided\n    if hypotenuse is not None and leg_a is not None:\n        results['missing_leg'] = calculate_missing_leg(hypotenuse, leg_a)\n    \n    # Calculate height of the cylinder inscribed in a hemisphere\n    if radius is not None and hemisphere_radius is not None:\n        results['cylinder_height'] = calculate_cylinder_height(radius, hemisphere_radius)\n    \n    return results", "subfield": "Pythagorean Theorem", "tool_name": "pythagorean_tools", "tool_type": "function", "description": "A toolset for performing calculations related to the Pythagorean theorem and geometric shapes.", "docstring": "A toolset for performing calculations related to the Pythagorean theorem and geometric shapes.\n    \n    Parameters:\n    leg_a (float): Length of one leg of the right triangle.\n    leg_b (float): Length of the other leg of the right triangle.\n    hypotenuse (float): Length of the hypotenuse of the right triangle.\n    radius (float): Radius of the inscribed cylinder.\n    hemisphere_radius (float): Radius of the hemisphere in which the cylinder is inscribed.\n    \n    Returns:\n    dict: A dictionary containing the results of the calculations, which may include:\n        - 'hypotenuse': Length of the hypotenuse if both legs are provided.\n        - 'missing_leg': Length of the missing leg if one leg and the hypotenuse are provided.\n        - 'cylinder_height': Height of the inscribed cylinder if the radius and hemisphere radius are provided.", "Freq": 2, "TSR": 2}], "Reflections": [{"tool": "def reflect_point_across_line(point, line_point, line_slope):\n    \n    x, y = sp.symbols('x y')\n    x0, y0 = point\n    x1, y1 = line_point\n    # Equation of the line: y - y1 = m*(x - x1)\n    m = line_slope\n    perp_slope = -1/m  # slope of the perpendicular line\n    # Equation of perpendicular from point (x0, y0) to the line: y - y0 = perp_slope*(x - x0)\n    # Intersection with the line:\n    intersection_x = sp.solve(y0 + perp_slope*(x - x0) - (y1 + m*(x - x1)), x)\n    intersection_y = y0 + perp_slope * (intersection_x[0] - x0)\n    # Calculating the reflected point\n    reflected_x = 2*intersection_x[0] - x0\n    reflected_y = 2*intersection_y - y0\n    return (reflected_x.evalf(), reflected_y.evalf())", "subfield": "Reflections", "tool_name": "reflect_point_across_line", "tool_type": "function", "description": "Reflect a given point across a line defined by a point and a slope in 2D geometry.", "docstring": "Reflect a given point across a line defined by a point and a slope in 2D geometry.\n    Parameters:\n    point (tuple): A tuple (x, y) representing the coordinates of the point to be reflected.\n    line_point (tuple): A tuple (x, y) representing a point through which the line passes.\n    line_slope (float): The slope of the line.\n    Returns:\n    tuple: The reflected point's coordinates (x', y').\n    Example:\n    >>> reflect_point_across_line((3, 4), (1, 2), 2)\n    (-1, 0)", "Freq": 2, "TSR": 0}, {"tool": "def reflect_across_x(points):\n    \n    reflected_points = points.copy()\n    reflected_points[:, 1] = -reflected_points[:, 1]\n    return reflected_points", "subfield": "Reflections", "tool_name": "reflect_across_x", "tool_type": "function", "description": "Reflect points across the x-axis.", "docstring": "Reflect points across the x-axis.\n    \n    Parameters:\n    - points (ndarray): an Nx2 numpy array of points where each row represents the coordinates (x, y).\n    Returns:\n    - ndarray: the reflected points as an Nx What data is returned? array.\n    Example:\n    >>> reflect_across_x(np.array([[1, 2], [3, -1], [0, 0]]))\n    array([[ 1, -2],\n           [ 3,  1],\n           [ 0,  0]])", "Freq": 0, "TSR": 0}, {"tool": "def reflect_across_x(point):\n    \n    x, y = point\n    return (x, -y)", "subfield": "Reflections", "tool_name": "reflect_across_x", "tool_type": "function", "description": "Reflect a point across the x-axis.", "docstring": "Reflect a point across the x-axis.\n    Parameters:\n    - point (tuple): A tuple containing the x and y coordinates of the point (x, y).\n    Returns:\n    - tuple: Coordinates of the reflected point (x, -y).\n    Examples:\n    >>> reflect_across_x((5, 3))\n    (5, -3)", "Freq": 0, "TSR": 0}, {"tool": "def reflect_point_across_plane(point, plane_normal, plane_point):\n    \n    # Convert to numpy arrays\n    p = np.array(point)\n    n = np.array(plane_normal)\n    m = np.array(plane_point)\n    \n    # Compute pm and normalize n\n    pm = p - m\n    n_norm = n / np.linalg.norm(n)\n    \n    # Distance from point to the plane\n    dist = np.dot(pm, n_norm)\n    \n    # Reflect point\n    reflected_point = p - 2 * dist * n_norm\n    return tuple(reflected_point)", "subfield": "Reflections", "tool_name": "reflect_point_across_plane", "tool_type": "function", "description": "Reflects a point across a plane defined by a normal vector and a point on the plane.", "docstring": "Reflects a point across a plane defined by a normal vector and a point on the plane.\n    Parameters:\n    point (tuple): The point to reflect, given as (x, y, z).\n    plane_normal (tuple): The normal vector of the plane, given as (x, y, z).\n    plane_point (tuple): A point on the plane, given as (x, y, z).\n    \n    Returns:\n    tuple: The reflected point coordinates (x, y, z).\n    Example:\n    >>> reflect_point_across_plane((1, 2, 3), (0, 0, 1), (0, 0, 0))\n    (1, 2, -3)", "Freq": 2, "TSR": 0}, {"tool": "def sum_of_coordinates(points):\n    \n    sum_x = sum(point[0] for point in points)\n    sum_y = sum(point[1] for point in points)\n    return (sum_x, sum_y)", "subfield": "Reflections", "tool_name": "sum_of_coordinates", "tool_type": "function", "description": "Calculate the sum of x and y coordinates among a list of points.", "docstring": "Calculate the sum of x and y coordinates among a list of points.\n    \n    Parameters:\n        points (list of tuples): List of tuples, where each tuple represents a point (x, y).\n    \n    Returns:\n        tuple: Sum of x coordinates and sum of y coordinates (sum_x, sum_y).\n    \n    Examples:\n    >>> sum_of_coordinates([(1, 2), (3, -1), (0, 0)])\n    (4, 1)", "Freq": 0, "TSR": 0}, {"tool": "def reflect_vector(v, u):\n    \n    v, u = np.asarray(v), np.asarray(u)\n    if v.shape != (2,) or u.shape != (2,):\n        raise ValueError(\"Both vectors v and u must be 1-D arrays of length 2.\")\n    # Calculate the projection of v onto u\n    projection_scale = np.dot(v, u) / np.dot(u, u)\n    projection = projection_scale * u\n    # Calculate the reflection\n    reflection = v - 2 * (projection - v)\n    return reflection", "subfield": "Reflections", "tool_name": "reflect_vector", "tool_type": "function", "description": "Compute the reflection of vector v over vector u in 2D space.", "docstring": "Compute the reflection of vector v over vector u in 2D space.\n    Parameters:\n    - v (array_like): The vector to be reflected. Must be a 1-D array of length 2.\n    - u (array_like): The vector (or axis) over which v is to be reflected. Must be a 1-D array of length 2.\n    Returns:\n    - numpy.ndarray: The reflected vector as a 1-dimensional numpy array of length 2.\n    Example:\n    >>> reflect_vector(np.array([1, 2]), np.array([0, 1]))\n    array([ 1, -2])", "Freq": 1, "TSR": 0}, {"tool": "def translate_points(points, translation_vector):\n    \n    return points + np.array(translation_vector)", "subfield": "Reflections", "tool_name": "translate_points", "tool_type": "function", "description": "Translate a set of points by a given vector.", "docstring": "Translate a set of points by a given vector.\n    \n    Parameters:\n    - points (ndarray): an Nx2 numpy array of points.\n    - translation_vector (ndarray or tuple): a vector (tx, ty) by which to translate each point.\n    \n    Returns:\n    - ndarray: the translated points.\n    \n    Example:\n    >>> translate_points(np.array([[1, 2], [3, 4]]), (1, -1))\n    array([[2, 1],\n           [4, 3]])", "Freq": 0, "TSR": 0}, {"tool": "def reflect_point(point, axis=\"y-axis\"):\n    \n    x, y = point\n    if axis == \"x-axis\":\n        return (x, -y)\n    elif axis == \"y-axis\":\n        return (-x, y)\n    elif axis == \"y=x\":\n        return (y, x)\n    else:\n        raise ValueError(\"Invalid axis value. Choose 'x-axis', 'y-axis', or 'y=x'.\")", "subfield": "Reflections", "tool_name": "reflect_point", "tool_type": "function", "description": "Reflects a point across the specified axis or line.", "docstring": "Reflects a point across the specified axis or line.\n    \n    Parameters:\n        point (tuple): A tuple representing a point in 2D space, (x, y).\n        axis (str): A string specifying the axis or line to reflect across. Acceptable values are \"x-axis\", \"y-axis\", and \"y=x\".\n    Returns:\n        tuple: The reflected point in 2D space.\n    \n    Examples:\n    >>> reflect_point((3, 4), \"x-axis\")\n    (3, -4)\n    >>> reflect_point((3, 4), \"y-axis\")\n    (-3, 4)\n    >>> reflect_point((3, 4), \"y=x\")\n    (4, 3)", "Freq": 0, "TSR": 0}, {"tool": "def calculate_vector_projection(v, u):\n    \n    v = np.array(v)\n    u = np.array(u)\n    return (np.dot(v, u) / np.dot(u, u)) * u", "subfield": "Reflections", "tool_name": "calculate_vector_projection", "tool_type": "function", "description": "Calculate the projection of a vector v onto another vector u.", "docstring": "Calculate the projection of a vector v onto another vector u.\n    Parameters\n    ----------\n    v : array_like\n        The vector being projected, should be an iterable of two numbers.\n    u : array_by\n        The vector onto which v is being projected, should be an iterable of two numbers.\n    Returns\n    -------\n    np.array\n        The projection of vector v onto vector u.\n    Examples\n    --------\n    >>> calculate_vector_projection([1, 2], [2, 0])\n    array([1., 0.])", "Freq": 0, "TSR": 0}, {"tool": "def midpoint(point1, point2):\n    \n    return tuple((np.array(point1) + np.array(point2)) / 2)", "subfield": "Reflections", "tool_name": "midpoint", "tool_type": "function", "description": "Computes the midpoint between two points.", "docstring": "Computes the midpoint between two points.\n    Parameters:\n    point1 (tuple): The first point, given as (x, y).\n    point2 (tuple): The second point, given as (:\n    \n    Returns:\n    tuple: Midpoint coordinates (x, y).\n    Example:\n    >>> midpoint((0,0), (2,2))\n    (1.0, 1.0)", "Freq": 0, "TSR": 0}, {"tool": "def translate_point(point, dx, dy):\n    \n    x, y = point\n    return (x + dx, y + dy)", "subfield": "Reflections", "tool_name": "translate_point", "tool_type": "function", "description": "Translate a point in the 2D space by given deltas.", "docstring": "Translate a point in the 2D space by given deltas.\n    \n    Parameters:\n        point (tuple): A tuple representing a point (x, y).\n        dx (float): The displacement along the x-axis.\n        dy (float): The displacement along the y-axis.\n    \n    Returns:\n        tuple: The translated point (new_x, new_y).\n    \n    Examples:\n    >>> translate_point((3, 4), 1, -1)\n    (4, 3)", "Freq": 0, "TSR": 0}], "Trapezoids": [{"tool": "def calculate_trapezoid_area(b1, b2, height):\n    \n    return (b1 + b2) * height / 2", "subfield": "Trapezoids", "tool_name": "calculate_trapezoid_area", "tool_type": "function", "description": "Calculate the area of a trapezoid given its bases and height.", "docstring": "Calculate the area of a trapezoid given its bases and height.\n    Parameters:\n    b1 (float): Length of the first base.\n    b2 (float): Length of the second base.\n    height (float): Height of the trapezoid from one base to the other.\n    Returns:\n    float: The area of the trapezoid.\n    Example:\n    >>> calculate_trapezoid_area(5, 3, 4)\n    16.0", "Freq": 2, "TSR": 0}, {"tool": "def midpoint_segment_length(base1, base2):\n    \n    return (base1 + base2) / 2", "subfield": "Trapezoids", "tool_name": "midpoint_segment_length", "tool_type": "function", "description": "Calculate the length of the segment joining the midpoints of the non-parallel sides of the trapezoid,\n    using the midpoint theorem, which states the segment is parallel and equal to the average of the two bases.", "docstring": "Calculate the length of the segment joining the midpoints of the non-parallel sides of the trapezoid,\n    using the midpoint theorem, which states the segment is parallel and equal to the average of the two bases.\n    Parameters:\n    - base1 (float): Length of the first base of the trapezoid.\n    - base2 (float): Length of the second base of the trapezoid.\n    Returns:\n    - float: Length of the midpoint segment.\n    Examples:\n    >>> midpoint_segment_length(4, 6)\n    5.0", "Freq": 1, "TSR": 1}, {"tool": "def trapezoid_properties(is_isosceles=False):\n    \n    properties = {\n        'Parallel sides': 2,\n        'Non-parallel sides': 2,\n        'Sum of angles': 360\n    }\n    if is_isosceles:\n        properties['Equal legs'] = True\n    return properties", "subfield": "Trapezoids", "tool_name": "trapezoid_properties", "tool_type": "function", "description": "Provides a descriptive dict of properties of either a general or an isosceles trapezoid.", "docstring": "Provides a descriptive dict of properties of either a general or an isosceles trapezoid.\n    Parameters:\n    - is_isosceles (bool): Flag to determine if the properties of an isosceles trapezoid are returned.\n    Returns:\n    - dict: Dictionary containing relevant properties.\n    Examples:\n    >>> trapezoid_properties()\n    {'Parallel sides': 2, 'Non-parallel sides': 2, 'Sum of angles': 360}\n    >>> trapezoid_properties(True)\n    {'Parallel sides': 2, 'Non-parallel sides': 2, 'Equal legs': True, 'Sum of angles': 360}", "Freq": 0, "TSR": 0}, {"tool": "def decompose_trapezoid(base1: float, base2: float, height: float):\n    \n    rectangle_base = min(base1, base2)\n    triangle_base = abs(base2 - base1) / 2\n    return ((rectangle_base, height), (triangle_base, height), (triangle_base, height))", "subfield": "Trapezoids", "tool_name": "decompose_trapezoid", "tool_type": "function", "description": "Decompose a trapezoid into simpler shapes: a rectangle and two right triangles, and return their dimensions.", "docstring": "Decompose a trapezoid into simpler shapes: a rectangle and two right triangles, and return their dimensions.\n    Parameters:\n    - base1 (float): Length of the top base.\n    - base2 (float): Length of the bottom base, assumed to be longer than base1.\n    - height (float): The height of the trapezoid.\n    Returns:\n    - tuple: dimensions of rectangle (base, height), dimensions of triangle1, dimensions of triangle2.\n    Examples:\n    >>> decompose_trapezoid(6, 10, 5)\n    ((6, 5), (4, 5), (4, 5))", "Freq": 0, "TSR": 0}], "Angles": [{"tool": "def calculate_clock_angle(hour, minute):\n    \n    import math\n    \n    # Normalize hour to fit within a 12-hour clock\n    hour %= 12\n    \n    # Position of the hour hand (each hour moves 30 degrees plus an additional movement due to minutes)\n    hour_angle = (hour + minute / 60) * 30\n    \n    # Position of the minute hand (each minute moves 6 degrees)\n    minute_angle = minute * 6\n    \n    # To find the smaller of the two possible angles\n    angle = abs(hour_angle - minute_angle)\n    # Smaller angle measured in degrees (clockwise angle or counter-clockwise angle)\n    return min(angle, 360 - angle)", "subfield": "Angles", "tool_name": "calculate_clock_angle", "tool_type": "function", "description": "Calculate the angle between the hour and minute hands on a clock at a given time.", "docstring": "Calculate the angle between the hour and minute hands on a clock at a given time.\n    Parameters:\n    - hour (int): The hour hand position, must be between 0 and 23 (for both 12-hour and 24-hour format)\n    - minute (int): The minute hand position, must be between 0 and 59\n    Returns:\n    - float: The smallest angle in degrees between the hour and minute hands.\n    Examples:\n    >>> calculate_clock_angle(3, 0)\n    90.0\n    >>> calculate_clock_angle(12, 30)\n    165.0", "Freq": 14, "TSR": 14}, {"tool": "def triangle_angle(angle1, angle2):\n    \n    return 180 - angle1 - angle2", "subfield": "Angles", "tool_name": "triangle_angle", "tool_type": "function", "description": "Compute the third angle of a triangle given two angles.", "docstring": "Compute the third angle of a triangle given two angles.\n    Parameters:\n        angle1 (float): First angle of the triangle in degrees.\n        angle2 (float): Second angle of the triangle in degrees.\n    Returns:\n        float: Third angle of the triangle in degrees.", "Freq": 4, "TSR": 4}, {"tool": "def calculate_point_angle(angles):\n    \n    sum_angles = sum(angles)\n    absent_angle = 360 - sum_angles\n    return absent_angle", "subfield": "Angles", "tool_name": "calculate_point_angle", "tool_type": "function", "description": "This function calculates the missing angle around a point.", "docstring": "This function calculates the missing angle around a point.\n    \n    Parameters: \n    angles (list): The list of known angles around a point\n   \n    Returns: \n    float: The missing angle around the point.\n    \n    Example: \n    calculate_point_angle([90, 90, 90])\n    # Output: 90.0", "Freq": 5, "TSR": 2, "experience_pool": "Tool is working correctly and calculates the missing angle around a point accurately."}, {"tool": "def calculate_quadrilateral_angle(a, b, c):\n    \n    fourth_angle = 360 - a - b - c\n    return fourth_angle", "subfield": "Angles", "tool_name": "calculate_quadrilateral_angle", "tool_type": "function", "description": "This function calculates the fourth angle of a quadrilateral given three angles.", "docstring": "This function calculates the fourth angle of a quadrilateral given three angles.\n    \n    Parameters: \n    a, b, c (float): The three angles of the quadrilateral\n   \n    Returns: \n    float: The fourth angle of the quadrilateral.\n    \n    Example: \n    calculate_quadrilateral_angle(90, 90, 90)\n    # Output: 90.0", "Freq": 1, "TSR": 0}, {"tool": "def calculate_straight_line_angle(a):\n    \n    adjacent_angle = 180 - a\n    return adjacent_angle", "subfield": "Angles", "tool_name": "calculate_straight_line_angle", "tool_type": "function", "description": "This function calculates the adjacent angle on a straight line.", "docstring": "This function calculates the adjacent angle on a straight line.\n    \n    Parameters: \n    a (float): The given angle on the straight line\n   \n    Returns: \n    float: The adjacent angle on the straight line.\n    \n    Example: \n    calculate_straight_line_angle(45)\n    # Output: 135.0", "Freq": 0, "TSR": 0}, {"tool": "def coterminal_angles(angle):\n    \n    return (angle % 360, (angle % 360) - 360)", "subfield": "Angles", "tool_name": "coterminal_angles", "tool_type": "function", "description": "Finds the positive and negative coterminal angles for a given angle.", "docstring": "Finds the positive and negative coterminal angles for a given angle.\n    \n    Parameters:\n        angle (float): Original angle in degrees.\n    Returns:\n        tuple: A tuple containing the positive and negative coterminal angles in degrees.", "Freq": 0, "TSR": 0}, {"tool": "def calculate_polygon_external_angle():\n    \n    # External angle of any polygon is always 180\n    return 180", "subfield": "Angles", "tool_name": "calculate_polygon_external_angle", "tool_type": "function", "description": "This function calculates the external angle of a polygon.\n   \n    Returns: \n    int: The external angle of a polygon.\n    \n    Example: \n    calculate_polygon_external_angle()\n    # Output: 180", "docstring": "This function calculates the external angle of a polygon.\n   \n    Returns: \n    int: The external angle of a polygon.\n    \n    Example: \n    calculate_polygon_external_angle()\n    # Output: 180", "Freq": 0, "TSR": 0}, {"tool": "def angle_between_vectors(v1, v2):\n    \n    v1 = np.array(v1)\n    v2 = np.array(v2)\n    unit_v1 = v1 / np.linalg.norm(v1)\n    unit_v2 = v2 / np.linalg.norm(v2)\n    dot_product = np.dot(unit_v1, unit_v2)\n    angle_rad = np.arccos(dot_product)\n    angle_deg = np.degrees(angle_rad)\n    return angle_deg", "subfield": "Angles", "tool_name": "angle_between_vectors", "tool_type": "function", "description": "Calculate the angle between two vectors in degrees.", "docstring": "Calculate the angle between two vectors in degrees.\n    \n    Parameters:\n        v1 (list or tuple): The first vector, e.g., [x1, y1].\n        v2 (list or tuple): The second vector, e.g., [x2, y2].\n        \n    Returns:\n        float: The angle between the two vectors in degrees.", "Freq": 0, "TSR": 0}, {"tool": "def calculate_triangle_angle(a, b):\n    \n    third_angle = 180 - a - b\n    return third_angle", "subfield": "Angles", "tool_name": "calculate_triangle_angle", "tool_type": "function", "description": "This function calculates the third angle of a triangle given two angles.", "docstring": "This function calculates the third angle of a triangle given two angles.\n    \n    Parameters: \n    a, b (float): The two angles of the triangle\n   \n    Returns: \n    float: The third angle of the triangle.\n    \n    Example: \n    calculate_triangle_angle(60, 60)\n    # Output: 60.0", "Freq": 0, "TSR": 0}, {"tool": "def sum_of_interior_angles(sides):\n    \n    return (sides - 2) * 180", "subfield": "Angles", "tool_name": "sum_of_interior_angles", "tool_type": "function", "description": "Compute the sum of interior angles of a polygon.", "docstring": "Compute the sum of interior angles of a polygon.\n    Parameters:\n        sides (int): number of sides in the polygon.\n    Returns:\n        float: sum of the interior angles of the polygon in degrees.", "Freq": 0, "TSR": 0}, {"tool": "def sum_of_exterior_angles():\n    \n    return 360", "subfield": "Angles", "tool_name": "sum_of_exterior_angles", "tool_type": "function", "description": "Compute the sum of exterior angles of any polygon, which is always 360 degrees.\n    Returns:\n        float: sum of the exterior angles of a polygon in degrees.", "docstring": "Compute the sum of exterior angles of any polygon, which is always 360 degrees.\n    Returns:\n        float: sum of the exterior angles of a polygon in degrees.", "Freq": 0, "TSR": 0}, {"tool": "def calculate_regular_polygon_angles(sides):\n    \n    \n    if sides < 3:\n        raise ValueError(\"A polygon must have at least 3 sides.\")\n    \n    # Calculate the interior angle\n    interior_angle = (sides - 2) * 180 / sides\n    \n    # Calculate the exterior angle\n    exterior_angle = 180 - interior_angle\n    \n    # Calculate the sum of interior angles\n    sum_interior_angles = (sides - 2) * 180\n    \n    # The sum of exterior angles is always 360 degrees\n    sum_exterior_angles = 360\n    \n    return {\n        'interior_angle': interior_angle,\n        'exterior_angle': exterior_angle,\n        'sum_interior_angles': sum_interior_angles,\n        'sum_exterior_angles': sum_exterior_angles\n    }", "subfield": "Angles", "tool_name": "calculate_regular_polygon_angles", "tool_type": "function", "description": "Calculate the interior and exterior angles of a regular polygon and the sum of angles at the vertices.", "docstring": "Calculate the interior and exterior angles of a regular polygon and the sum of angles at the vertices.\n    \n    Parameters:\n    sides (int): The number of sides of the regular polygon.\n    \n    Returns:\n    dict: A dictionary containing the following:\n        - 'interior_angle': The measure of each interior angle in degrees.\n        - 'exterior_angle': The measure of each exterior angle in degrees.\n        - 'sum_interior_angles': The sum of all interior angles in degrees.\n        - 'sum_exterior_angles': The sum of all exterior angles in degrees (always 360).\n    \n    Example:\n    >>> calculate_regular_polygon_angles(7)\n    {'interior_angle': 128.57142857142858, 'exterior_angle': 51.42857142857143, \n     'sum_interior_angles': 900.0, 'sum_exterior_angles': 360}", "Freq": 1, "TSR": 1}], "Similarity": [{"tool": "def check_similarity_by_angles(angles1, angles2):\n    \n    # Check if each angle in angles1 is equal to the corresponding angle in angles2\n    return set(angles1) == set(angles2)", "subfield": "Similarity", "tool_name": "check_similarity_by_angles", "tool_type": "function", "description": "Checks whether two triangles are similar by comparing their angles.", "docstring": "Checks whether two triangles are similar by comparing their angles.\n    \n    Parameters:\n        angles1 (tuple): A tuple of three angle measures (in degrees or radians) of the first triangle.\n        angles2 (tuple): A tuple of three angle measures (in degrees or radians) of the second triangle.\n        \n    Returns:\n        bool: Returns True if all corresponding angles are equal, implying similarity.\n    Example:\n        >>> check_similarity_by_angles((45, 45, 90), (45, 45, 90))\n        True\n        >>> check_similarity_by_angles((30, 60, 90), (30, 70, 80))\n        False", "Freq": 0, "TSR": 0}, {"tool": "def find_missing_length(similar_triangles, target_side_index):\n    \n    known_sides1, known_sides2 = similar_triangles\n    \n    # Identify the non-None sides to use for proportions\n    not_none_indices = [i for i in range(3) if known_sides1[i] is not None and known_sides2[i] is not None]\n    \n    if not not_none_indices:\n        return None  # can't compute the missing side without any known proportions\n    \n    # Use the first available ratio to compute the missing side\n    ratio = simplify(known_sides2[not_none_indices[0]] / known_sides1[not_none_indices[0]])\n    \n    # Find the missing side using the calculated ratio\n    return simplify(known_sides1[target_side_index] * ratio)", "subfield": "Similarity", "tool_name": "find_missing_length", "tool_type": "function", "description": "Calculates a missing side in similar triangles based on the property of corresponding sides being in proportion.", "docstring": "Calculates a missing side in similar triangles based on the property of corresponding sides being in proportion.\n    \n    Parameters:\n        similar_triangles (tuple): A tuple containing two tuples; each inner tuple represents the known sides of each triangle, where None represents the unknown side.\n        target_side_index (int): The index of the side that is missing (0 for the first side, 1 for the second side, 2 for the third side).\n    \n    Returns:\n        symbolic or numeric expression: The length of the missing side if calculable.\n    Example:\n        >>> find_missing_length(((3, 4, 5), (6, 8, None)), 2)\n        10\n        >>> find_missing_length(((2, None, 4), (3, 9, 6)), 1)\n        6", "Freq": 2, "TSR": 0}, {"tool": "def area_ratio_calculator(side_ratio):\n    \n    return side_ratio ** 2", "subfield": "Similarity", "tool_name": "area_ratio_calculator", "tool_type": "function", "description": "Calculates the ratio of areas of two similar triangles based on the ratio of corresponding sides.", "docstring": "Calculates the ratio of areas of two similar triangles based on the ratio of corresponding sides.\n    \n    Parameters:\n    side_ratio (float): The ratio of any corresponding sides of the two similar triangles.\n    \n    Returns:\n    float: The ratio of areas of the two triangles.\n    \n    Examples:\n    >>> area_ratio_calculator(2)\n    4.0\n    >>> area_ratio_calculator(0.5)\n    0.25", "Freq": 0, "TSR": 0}, {"tool": "def find_missing_length(similarity_ratio, known_length):\n    \n    return similarity_ratio * known_length", "subfield": "Similarity", "tool_name": "find_missing_length", "tool_type": "function", "description": "Calculate the corresponding side length in a similar triangle using the similarity ratio.", "docstring": "Calculate the corresponding side length in a similar triangle using the similarity ratio.\n    \n    Parameters:\n    - similarity_ratio (float): The ratio of similarity between two triangles.\n    - known_length (float): The side length in one of the triangles whose corresponding\n                            side length in the similar triangle needs to be found.\n    \n    Returns:\n    - float: The corresponding side length in the other triangle.\n    Example:\n    >>> find_missing_length(0.5, 10)\n    5.0", "Freq": 0, "TSR": 0}, {"tool": "def find_missing_length_and_area_ratio(base_triangle, sim_ratio, missing_side=None, base_area=None):\n    \n    new_lengths = tuple([side * sim_ratio for side in base_triangle])\n    result = {'sides': new_lengths}\n    if base_area is not None:\n        result['area_ratio'] = sim_ratio**2\n    return result", "subfield": "Similarity", "tool_name": "find_missing_length_and_area_ratio", "tool_type": "function", "description": "Calculate unknown sides and area ratio of similar triangles given base triangle dimensions and similarity ratio.", "docstring": "Calculate unknown sides and area ratio of similar triangles given base triangle dimensions and similarity ratio.\n    \n    Parameters:\n    - base_triangle (tuple): A tuple of three numbers representing the side lengths of the base triangle.\n    - sim_ratio (float): The ratio of similarity between two triangles.\n    - missing_side (tuple of int): Positions (0, 1, 2) of sides in base_triangle for which length is unknown.\n    - base_area (float, optional): The area of the base triangle.\n    Returns:\n    - dict: Dictionary with keys `sides` containing new side lengths, and optionally `area_ratio` if base_area provided.\n    \n    Examples:\n    >>> find_missing_length_and_area_ratio((3, 4, 5), 2)\n    {'sides': (6, 8, 10)}\n    >>> find_missing_length_and_area_ratio((3, 4, 5), 0.5, base_area=6)\n    {'sides': (1.5, 2, 2.5), 'area_ratio': 0.25}", "Freq": 1, "TSR": 0}, {"tool": "def proportional_sides_solver(known_ratios, known_side, target='missing'):\n    \n    known_base_ratio, target_base_ratio = known_ratios\n    if target == 'missing':\n        return (target_base_ratio / known_base_ratio) * known_side\n    else:\n        return (known_base_ratio / target_base_ratio) * known_side", "subfield": "Similarity", "tool_name": "proportional_sides_solver", "tool_type": "function", "description": "Solves for unknown sides in similar triangles based on a known side ratio and a known side length.", "docstring": "Solves for unknown sides in similar triangles based on a known side ratio and a known side length.\n    \n    Parameters:\n    known_ratios (tuple of floats): Ratios of corresponding sides as (known_base_ratio, target_base_ratio)\n    known_side (float): Length of the known side for the computation.\n    target (str, optional): Specifies if the target is the 'missing' side or 'known'. Defaults to 'missing'.\n    \n    Returns:\n    float: Length of the target side.\n    \n    Examples:\n    >>> proportional_sides_solver((2, 3), 4)\n    6.0\n    >>> proportional_sides_solver((3, 2), 6, target='known')\n    4.0", "Freq": 0, "TSR": 0}, {"tool": "def verify_similarity(triangle1, triangle2, criterion='SSS'):\n    \n    if criterion == 'SSS':\n        ratios = sorted([triangle1['a']/triangle2['x'], triangle1['b']/triangle2['y'], triangle1['c']/triangle2['z']])\n        return N(ratios[0]) == N(ratios[1]) == N(ratios[2])\n    elif criterion == 'SAS':\n        # Implement SAS logic\n        pass  # Placeholder for now\n    elif criterion == 'AA':\n        # Assume angles are in degrees and we only need two angles each\n        angles1 = sorted([triangle1.get(key) for key in ['A', 'B', 'C'] if key in triangle1])\n        angles2 = sorted([triangle2.get(key) for key in ['X', 'Y', 'Z'] if key in triangle2])\n        return N(angles1[0]) == N(angles2[0]) and N(angles1[1]) == N(angles2[1])\n    return False", "subfield": "Similarity", "tool_name": "verify_similarity", "tool_type": "function", "description": "Determine if two triangles are similar based on provided side lengths or angles.", "docstring": "Determine if two triangles are similar based on provided side lengths or angles.\n    \n    Parameters:\n    triangle1 (dict): A dictionary containing sides (a, b, c) and optionally angles (A, B, C) of the first triangle.\n    triangle2 (dict): A dictionary containing sides (x, y, z) and optionally angles (X, Y, Z) of the second triangle.\n    criterion (str): The criterion to use for verifying similarity ('SSS', 'SAS', 'AA').\n    \n    Returns:\n    bool: True if triangles are similar under the given criterion, otherwise False.\n    \n    Examples:\n    >>> verify_similarity({'a': 3, 'b': 4, 'c': 5}, {'x': 6, 'y': 8, 'z': 10}, 'SSS')\n    True\n    >>> verify_similarity({'A': 45, 'B': 45}, {'X': 45, 'Y': 45}, 'AA')\n    True", "Freq": 0, "TSR": 0}, {"tool": "def triangle_proportional_sides(triangle1_sides, ratio):\n    \n    triangle2_sides = [side * ratio for side in triangle1_sides]\n    return triangle2_sides", "subfield": "Similarity", "tool_name": "triangle_proportional_sides", "tool_type": "function", "description": "Compute the sides of a triangle given the sides of a similar triangle and the ratio of similarity.", "docstring": "Compute the sides of a triangle given the sides of a similar triangle and the ratio of similarity.\n    \n    Parameters:\n    triangle1_sides (list of floats): The sides of the known triangle.\n    ratio (float): The ratio of proportionality to compute the sides of the second triangle.\n    \n    Returns:\n    list of floats: The calculated sides of the second triangle based on the ratio.\n    \n    Examples:\n    >>> triangle_proportional_sides([3, 4, 5], 2)\n    [6.0, 8.0, 10.0]", "Freq": 0, "TSR": 0}], "Parallelograms": [{"tool": "def midpoint(point_a, point_b):\n    \n    return ((point_a[0] + point_b[0]) / 2, (point_a[1] + point_b[1]) / 2)", "subfield": "Parallelograms", "tool_name": "midpoint", "tool_type": "function", "description": "Calculate the midpoint between two points in 2D space.", "docstring": "Calculate the midpoint between two points in 2D space.\n    Parameters:\n    - point_a (tuple): Coordinates of the first point (x1, y1).\n    - point_b (tuple): Coordinates of the second point (x2, y2).\n    Returns:\n    - tuple: Coordinates of the midpoint.\n    Example:\n    >>> midpoint((0, 0), (2, 2))\n    (1.0, 1.0)", "Freq": 1, "TSR": 1}, {"tool": "def calculate_perimeter(sides):\n    \n    return 2 * (sides['a'] + sides['b'])", "subfield": "Parallelograms", "tool_name": "calculate_perimeter", "tool_type": "function", "description": "Calculate the perimeter of a parallelogram based on the lengths of its sides.", "docstring": "Calculate the perimeter of a parallelogram based on the lengths of its sides.\n    Parameters:\n        sides (dict): A dictionary with side lengths {'a': length of side a, 'b': length of side b}.\n    Returns:\n        float: The perimeter of the parallelogram.\n    Examples:\n        >>> calculate_perimeter({'a': 4, 'b': 3})\n        14", "Freq": 1, "TSR": 0}, {"tool": "def distance(point_a, point_b):\n    \n    return np.sqrt((point_b[0] - point_a[0])**2 + (point_b[1] - point_a[1])**2)", "subfield": "Parallelograms", "tool_name": "distance", "tool_type": "function", "description": "Calculate the Euclidean distance between two points in 2D space.", "docstring": "Calculate the Euclidean distance between two points in 2D space.\n    Parameters:\n    - point_a (tuple): Coordinates of the first point (x1, y1).\n    - point_b (tuple): Coordinates of the second point (x2, y2).\n    Returns:\n    - float: Euclidean distance.\n    Example:\n    >>> distance((0, 0), (3, 4))\n    5.0", "Freq": 1, "TSR": 0}, {"tool": "def parallelogram_area(vertices):\n    \n    (x1, y1), (x2, y2), (x3, y3), _ = vertices\n    return abs((x2-x1)*(y3-y1) - (x3-x1)*(y2-y1))", "subfield": "Parallelograms", "tool_name": "parallelogram_area", "tool_type": "function", "description": "Calculate the area of a parallelogram given its vertices.", "docstring": "Calculate the area of a parallelogram given its vertices.\n    Parameters:\n    - vertices (list of tuples): Coordinates of the vertices [(x1, y1), (x2, y2), (x3, y3), (x4, y4)].\n    Returns:\n    - float: Area of the parallelogram.\n    Example:\n    >>> parallelogram_area([(0, 0), (2, 0), (3, 2), (1, 2)])\n    4.0", "Freq": 0, "TSR": 0}, {"tool": "def verify_parallelism(vector1, vector2):\n    \n    return np.cross(vector1, vector2) == 0", "subfield": "Parallelograms", "tool_name": "verify_parallelism", "tool_type": "function", "description": "Verify if two vectors are parallel by calculating the cross-product.", "docstring": "Verify if two vectors are parallel by calculating the cross-product.\n    Parameters:\n        vector1 (tuple): The components of the first vector.\n        vector2 (tuple): The components of the second vector.\n    Returns:\n        bool: True if the vectors are parallel, False otherwise.\n    Examples:\n        >>> verify_parallelism((2, 2), (4, 4))\n        True", "Freq": 0, "TSR": 0}, {"tool": "def diagonal_lengths(sides, angle_degrees):\n    \n    angle_radians = np.deg2rad(angle_degrees)\n    d1 = math.sqrt(sides['a']**2 + sides['b']**2 - 2 * sides['a'] * sides['b'] * math.cos(angle_radians))\n    d2 = math.sqrt(sides['a']**2 + sides['b']**2 + 2 * sides['a'] * sides['b'] * math.cos(angle_radians))\n    return {'d1': d1, 'd2': d2}", "subfield": "Parallelograms", "tool_name": "diagonal_lengths", "tool_type": "function", "description": "Calculate the lengths of the diagonals in a parallelogram using side lengths and the angle between them.", "docstring": "Calculate the lengths of the diagonals in a parallelogram using side lengths and the angle between them.\n    Parameters:\n        sides (dict): A dictionary with side lengths {'a': length of side a, 'b': length of side b}.\n        angle_degrees (float): The angle between the sides in degrees.\n    Returns:\n        dict: The lengths of diagonals {'d1': diagonal1 length, 'd2': diagonal2 length}.\n    Examples:\n        >>> diagonal_lengths({'a': 5, 'b': 3}, 60)\n        {'d1': 7.795831523312719, 'd2': 4.0}", "Freq": 0, "TSR": 0}], "Coordinate Systems": [{"tool": "def spherical_to_cartesian(rho, theta, phi):\n    \n    x = rho * np.sin(phi) * np.cos(theta)\n    y = rho * np.sin(phi) * np.sin(theta)\n    z = rho * np.cos(phi)\n    return x, y, z", "subfield": "Coordinate Systems", "tool_name": "spherical_to_cartesian", "tool_type": "function", "description": "Converts spherical coordinates to Cartesian (rectangular) coordinates.", "docstring": "Converts spherical coordinates to Cartesian (rectangular) coordinates.\n    Parameters:\n        rho (float): Radial distance\n        theta (float): Azimuthal angle in radians\n        phi (float): Polar angle from the positive z-axis in radians\n    \n    Returns:\n        tuple: (x, y, z) coordinates in Cartesian system\n    \n    Examples:\n        >>> spherical_to_cartesian(1, np.pi/2, np.pi/2)\n        (1.0, 0.0, 6.123233995736766e-17) # approximately (1, 0, 0)", "Freq": 4, "TSR": 1}, {"tool": "def cartesian_to_cylindrical(x, y, z):\n    \n    r = np.sqrt(x**2 + y**2)\n    theta = np.arctan2(y, x)\n    return r, theta, z", "subfield": "Coordinate Systems", "tool_name": "cartesian_to_cylindrical", "tool_type": "function", "description": "Converts Cartesian (rectangular) coordinates to cylindrical coordinates.", "docstring": "Converts Cartesian (rectangular) coordinates to cylindrical coordinates.\n    Parameters:\n        x (float): x-coordinate\n        y (float): y-coordinate\n        z (float): z-coordinate\n    \n    Returns:\n        tuple: (r, theta, z) coordinates in cylindrical system\n    \n    Examples:\n        >>> cartesian_to_cylindrical(1, 0, 1)\n        (1.0, 0.0, 1) # radius, angle, height", "Freq": 1, "TSR": 1}, {"tool": "def cartesian_to_polar(x, y):\n    \n    r = np.sqrt(x**2 + y**2)\n    theta = np.arctan2(y, x)\n    return r, theta", "subfield": "Coordinate Systems", "tool_name": "cartesian_to_polar", "tool_type": "function", "description": "Convert Cartesian coordinates to polar coordinates.", "docstring": "Convert Cartesian coordinates to polar coordinates.\n    \n    Parameters\n    ----------\n    x : float\n        The x-coordinate in the Cartesian plane.\n    y : float\n        The y-coordinate in the Cartesian plane.\n    Returns\n    -------\n    tuple\n        A tuple containing the radius (r) and angle (theta in radians).\n    Examples\n    --------\n    >>> cartesian_to_polar(1, 1)\n    (1.4142135623730951, 0.7853981633974483)", "Freq": 0, "TSR": 0}, {"tool": "def distance_between_points(point1: Tuple[float, float], point2: Tuple[float, float]) -> float:\n    \n    return sqrt((point1[0] - point2[0])**2 + (point1[1] - point2[1])**2)", "subfield": "Coordinate Systems", "tool_name": "distance_between_points", "tool_type": "function", "description": "Calculate the Euclidean distance between two points in the xy-plane.", "docstring": "Calculate the Euclidean distance between two points in the xy-plane.\n    \n    Parameters:\n    - point1 (Tuple[float, float]): The first point (x1, y1).\n    - point2 (Tuple[float, float]): The second point (x2, y2).\n    \n    Returns:\n    - float: The distance between the points.\n    \n    Examples:\n    >>> distance_between_points((1, 2), (4, 6))\n    5.0", "Freq": 0, "TSR": 0}, {"tool": "def midpoint(p1, p2):\n    \n    x1, y1 = p1\n    x2, y2 = p2\n    mx = (x1 + x2) / 2\n    my = (y1 + y2) / 2\n    return (mx, my)", "subfield": "Coordinate Systems", "tool_name": "midpoint", "tool_type": "function", "description": "Calculate the midpoint between two points.", "docstring": "Calculate the midpoint between two points.\n    \n    Parameters\n    ----------\n    p1, p2 : tuple\n        Points for which to find the midpoint (each as tuple of floats (x, y)).\n    Returns\n    -------\n    tuple\n        Midpoint (x, y).\n    Examples\n    --------\n    >>> midpoint((0, 0), (2, 2))\n    (1.0, 1.0)", "Freq": 0, "TSR": 0}, {"tool": "def parametric_line_intercept(A, B):\n    \n    x1, y1 = A['point']\n    dx1, dy1 = A['direction']\n    x2, y2 = B['point']\n    dx2, dy2 = B['direction']\n    t, s = sp.symbols('t s')\n    equations = [\n        sp.Eq(x1 + t * dx1, x2 + s * dx2),\n        sp.Eq(y1 + t * dy1, y2 + s * dy2)\n    ]\n    result = sp.solve(equations, (t, s))\n    if result:\n        t_val, s_val = result[t], result[s]\n        xp = x1 + t_val * dx1\n        yp = y1 + t_val * dy1\n        return float(xp), float(yp)\n    \n    return None", "subfield": "Coordinate Systems", "tool_name": "parametric_line_intercept", "tool_type": "function", "description": "Determine the intersection point of two parametrically defined lines in the xy-plane.", "docstring": "Determine the intersection point of two parametrically defined lines in the xy-plane.\n    Parameters:\n    - A (dict): Contains the parametric definition of line A {'point': (x1, y1), 'direction': (dx1, dy1)}\n    - B (dict): Contains the parametric definition of line B {'point': (x2, y2), 'direction': (dx2, dy2)}\n    Returns:\n    - tuple or None: The intersection point (x, y) if exists, otherwise None.\n    Examples:\n    >>> A = {'point': (0, 0), 'direction': (1, 1)}\n    >>> B = {'point': (1, 0), 'direction': (-1, 1)}\n    >>> parametric_line_intercept(A, B)\n    (0.5, 0.5)", "Freq": 1, "TSR": 0}, {"tool": "def parametric_to_cartesian(t: np.array, parametric_func: Callable[[np.array], np.array]) -> np.array:\n    \n    return np.array([parametric_func(ti) for ti in t])", "subfield": "Coordinate Systems", "tool_name": "parametric_to_cartesian", "tool_type": "function", "description": "Convert a parametric representation of curves to Cartesian coordinates.", "docstring": "Convert a parametric representation of curves to Cartesian coordinates.\n    \n    Parameters:\n    - t (np.array): An array of parameter values.\n    - parametric_func (Callable[[np.array], np.array]): The parametric function defined as x(t), y(t), z(t).\n    \n    Returns:\n    - np.array: Cartesian coordinates resulting from parameter t.\n    \n    Examples:\n    >>> parametric_to_cartesian(np.array([0, np.pi/2]), lambda t: np.array([np.cos(t), np.sin(t), 0]))\n    array([[1., 0., 0.],\n           [0., 1., 0.]])", "Freq": 0, "TSR": 0}, {"tool": "def line_intersection(p1, p2, p3, p4):\n    \n    x1, y1 = p1\n    x2, y2 = p2\n    x3, y3 = p3\n    x4, y4 = p4\n    denom = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4)\n    if denom == 0:\n        return None  # Lines are parallel or coincident.\n    intersect_x = ((x1 * y2 - y1 * x2) * (x3 - x4) - (x1 - x2) * (x3 * y4 - y3 * x4)) / denom\n    intersect_y = ((x1 * y2 - y1 * x2) * (y3 - y4) - (y1 - y2) * (x3 * y4 - y3 * x4)) / denom\n    return (intersect_x, intersect_y)", "subfield": "Coordinate Systems", "tool_name": "line_intersection", "tool_type": "function", "description": "Calculate the point of intersection between two lines defined by four points.", "docstring": "Calculate the point of intersection between two lines defined by four points.\n    \n    Parameters\n    ----------\n    p1, p2 : tuple\n        Points on the first line (each as tuple of floats (x, y)).\n    p3, p4 : tuple\n        Points on the second line (each as tuple of floats (x, y)).\n    Returns\n    -------\n    tuple or None\n        A tuple containing the intersection point (x, y), or None if no intersection exists.\n    Examples\n    --------\n    >>> line_intersection((0, 0), (1, 1), (0, 1), (1, 0))\n    (0.5, 0.5)", "Freq": 0, "TSR": 0}, {"tool": "def adjust_angle_for_quadrant(theta, x, y):\n    \n    if x < 0 and y == 0:\n        return theta + np.pi\n    return theta", "subfield": "Coordinate Systems", "tool_name": "adjust_angle_for_quadrant", "tool_type": "function", "description": "Adjust angle to ensure it falls in the correct quadrant.", "docstring": "Adjust angle to ensure it falls in the correct quadrant.\n    Parameters:\n        theta (float): Computed angle in radians, typically from trigonometric function\n        x (float): x-coordinate used for adjusting angle\n        y (float): y-coordinate for specific cases\n    \n    Returns:\n        float: Adjusted angle in radians\n    \n    Examples:\n        >>> adjust_angle_for_quadrant(np.arctan(-1), -1, 0)\n        -2.356194490192345 # approximately -3π/4, which is adjusted for the correct quadrant", "Freq": 0, "TSR": 0}], "Conic Sections": [{"tool": "def ellipse_properties(a, b):\n    \n    c = np.sqrt(a**2 - b**2)\n    area = np.pi * a * b\n    return {'focal_distance': c, 'area': area, 'distance_between_foci': 2*c}", "subfield": "Conic Sections", "tool_name": "ellipse_properties", "tool_type": "function", "description": "Calculate significant geometric properties of an ellipse.", "docstring": "Calculate significant geometric properties of an ellipse.\n    Parameters:\n    a (float): The length of the semi-major axis.\n    b (float): The length of the semi-minor axis.\n    Returns:\n    dict: A dictionary containing the focal distance (c), area, and the distance between the foci (2c).\n    Examples:\n    >>> ellipse_properties(5, 3)\n    {'focal_distance': 4.0, 'area': 47.12388980384689, 'distance_between_foci': 8.0}", "Freq": 1, "TSR": 0}, {"tool": "def ellipse_foci(a, b, center=(0, 0)):\n    \n    h, k = center\n    c = np.sqrt(a**2 - b**2)\n    if a >= b:\n        foci = ((h + c, k), (h - c, k))\n    else:\n        foci = ((h, k + c), (h, k - c))\n    return foci", "subfield": "Conic Sections", "tool_name": "ellipse_foci", "tool_type": "function", "description": "Calculate the coordinates of the foci of an ellipse.", "docstring": "Calculate the coordinates of the foci of an ellipse.\n    Parameters:\n    a : float\n        Length of the semi-major axis.\n    b : float\n        Length of the semi-minor axis.\n    center : tuple\n        Coordinates of the center of the ellipse (h, k).\n    Returns:\n    tuple of tuples\n        Coordinates of the two foci.\n    Examples:\n    >>> ellipse_foci(5, 3)\n    ((-4.0, 0), (4.0, 0))", "Freq": 3, "TSR": 1}, {"tool": "def ellipse_equation(center, a, b):\n    \n    x, y = sp.symbols('x y')\n    h, k = center\n    # Equation of the ellipse\n    equation = ((x-h)**2 / a**2) + ((y-k)**2 / b**2) - 1\n    return sp.simplify(equation)", "subfield": "Conic Sections", "tool_name": "ellipse_equation", "tool_type": "function", "description": "This function generates the standard form equation of an ellipse, \n    given its center and the lengths of its semi-major (a) and semi-minor (b) axes.", "docstring": "This function generates the standard form equation of an ellipse, \n    given its center and the lengths of its semi-major (a) and semi-minor (b) axes.\n    \n    Parameters:\n    center (tuple): The coordinates of the center of the ellipse.\n    a (float): The length of the semi-major axis.\n    b (float): The length of the semi-minor axis.\n    Returns:\n    equation (str): The standard form equation of the ellipse.", "Freq": 1, "TSR": 1}, {"tool": "def point_on_ellipse(x, y, a, b, center=(0, 0)):\n    \n    h, k = center\n    value = ((x - h)**2 / a**2) + ((y - k)**2 / b**2)\n    return np.isclose(value, 1)", "subfield": "Conic Sections", "tool_name": "point_on_ellipse", "tool_type": "function", "description": "Determine whether a given point (x, y) lies on the ellipse defined by semi-major axis a and\n    semi-minor axis b centered at 'center'.", "docstring": "Determine whether a given point (x, y) lies on the ellipse defined by semi-major axis a and\n    semi-minor axis b centered at 'center'.\n    Parameters:\n    x : float\n        x-coordinate of the point.\n    y : float\n        y-coordinate of the point.\n    a : float\n        Length of the semi-major axis.\n    b : float\n        Length of the semi-minor axis.\n    center : tuple\n        Coordinates of the center of the ellipse (h, k).\n    Returns:\n    bool\n        True if the point is on the ellipse, False otherwise.\n    Examples:\n    >>> point_on_ellipse(1, 4, 5, 3)\n    False", "Freq": 1, "TSR": 0}, {"tool": "def standard_form_to_general(x, y, h, k, a, b):\n    \n    return ((x - h)**2 / a**2 + (y - k)**2 / b**2 - 1).simplify()", "subfield": "Conic Sections", "tool_name": "standard_form_to_general", "tool_type": "function", "description": "Transform the standard form of an ellipse equation to its general form.", "docstring": "Transform the standard form of an ellipse equation to its general form.\n    \n    Parameters:\n    x, y (sympy.Symbol): Symbols for the coordinate variables.\n    h, k (float): Coordinates of the center of the ellipse.\n    a (float): Length of the semi-major axis.\n    b (float): Length of the semi-minor axis.\n    Returns:\n    sympy.Expr: The general form of the ellipse equation as a sympy expression.\n    \n    Examples:\n    >>> x, y = sp.symbols('x y')\n    >>> standard_form_to_general(x, y, 0, 0, 5, 3)\n    x**2/25 + y**2/9 - 1", "Freq": 0, "TSR": 0}, {"tool": "def transform_parabola(vertex, focus):\n    \n    h, k = vertex\n    p, q = focus\n    if p == h:  # Vertical parabola\n        a = 1/(4*(q-k))\n        equation = f'y = {a}*(x - {h})**2 + {k}'\n    else:  # Horizontal parabola\n        a = 1/(4*(p-h))\n        equation = f'x = {a}*(y - {k})**2 + {h}'\n    \n    return equation", "subfield": "Conic Sections", "tool_name": "transform_parabola", "tool_type": "function", "description": "Determine the standard form of a parabola given a vertex and a focus.", "docstring": "Determine the standard form of a parabola given a vertex and a focus.\n    Parameters:\n        vertex (tuple): Coordinates (h, k) of the vertex of the parabola.\n        focus (tuple): Coordinates (p, q) of the focus of the parabola.\n    \n    Returns:\n        str: The standard form equation of the parabola.\n    \n    Examples:\n        >>> transform_parabola((0, 0), (0, 1))\n        'y = (x - 0)^2 / 4 + 0'", "Freq": 2, "TSR": 1}, {"tool": "def ellipse_tangent_line(a, b, slope, center=(0, 0)):\n    \n    h, k = center\n    c = (a * b) / np.sqrt((b**2) + (a**2) * slope**2)\n    return f\"y = {slope}x ± {c + k}\"", "subfield": "Conic Sections", "tool_name": "ellipse_tangent_line", "tool_type": "function", "description": "Calculates the y-intercept of a line tangent to the ellipse at y=mx+c", "docstring": "Calculates the y-intercept of a line tangent to the ellipse at y=mx+c\n    Parameters:\n    a : float\n        Semi-major axis of the ellipse.\n    b : float\n        Semi-minor axis of the ellipse.\n    slope : float\n        Slope (m) of the tangent line.\n    center : tuple\n        Center of the ellipse (h, k).\n    Returns:\n    float\n        y-intercept of the tangent line.\n    Examples:\n    >>> ellipse_tangent_line(5, 3, 1)\n    'y = x ± 7.54983443527075'", "Freq": 0, "TSR": 0}, {"tool": "def hyperbola_properties(a2, b2):\n    \n    a = sp.sqrt(a2)\n    b = sp.sqrt(b2)\n    c = sp.sqrt(a2 + b2)\n    \n    return {'c': c, '2a': 2*a, '2b': 2*b}", "subfield": "Conic Sections", "tool_name": "hyperbola_properties", "tool_type": "function", "description": "Calculate properties of a hyperbola given a^2 and b^2.", "docstring": "Calculate properties of a hyperbola given a^2 and b^2.\n    \n    Parameters:\n        a2 (float): Square of the distance from the center to a vertex along the transverse axis.\n        b2 (float): Square of the distance from the center to a vertex along the conjugate axis.\n    \n    Returns:\n        dict: Dictionary containing foci distance `c`, and length of transverse and conjugate axes.\n    \n    Examples:\n        >>> hyperbola_properties(25, 16)\n        {'c': 9.0, '2a': 10, '2b': 8}", "Freq": 1, "TSR": 1}], "Quadrilaterals": [{"tool": "def apply_law_of_cosines(a, b, angle_c):\n    \n    angle_c_rad = math.radians(angle_c)\n    c = math.sqrt(a**2 + b**2 - 2 * a * b * math.cos(angle_c_rad))\n    return c", "subfield": "Quadrilaterals", "tool_name": "apply_law_of_cosines", "tool_type": "function", "description": "Apply the Law of Cosines to calculate the third side of a triangle, given two sides and the included angle.", "docstring": "Apply the Law of Cosines to calculate the third side of a triangle, given two sides and the included angle.\n    Parameters:\n    - a (float): Length of the first side of the triangle.\n    - b (float): Length of the second side of the triangle.\n    - angle_c (float): The angle between sides a and b in degrees.\n    \n    Returns:\n    - float: The length of the third side of the triangle.\n    \n    Examples:\n    >>> apply_law_of_cosines(5, 6, 60)\n    4.084", "Freq": 0, "TSR": 0}, {"tool": "def check_opposite_angles_equality(angle_a, angle_b, angle_c, angle_d):\n    \n    # Check for equality in both pairs of opposite angles\n    opposite_angles_equal = Eq(angle_a, angle_c) and Eq(angle_b, angle_d)\n    # Return boolean evaluation of the equality expressions\n    return solve(opposite_angles_equal)", "subfield": "Quadrilaterals", "tool_name": "check_opposite_angles_equality", "tool_type": "function", "description": "Verify if opposite angles in a given quadlilateral are equal - a property of parallelograms.", "docstring": "Verify if opposite angles in a given quadlilateral are equal - a property of parallelograms.\n    Parameters:\n    - angle_a (Expr): Symbolic expression for angle A (one vertex angle of a quadrilateral).\n    - angle_b (Expr): Symbolic expression for angle B (adjacent to angle A).\n    - angle_c (Expr): Symbolic expression for angle C (opposite to angle A).\n    - angle_d (Expr): Symbolic expression for angle D (adjunct to angle C).\n    Returns:\n    - bool: True if opposite angles are equal (angle A equals angle C and angle B equals angle D); False otherwise.\n    Examples:\n    >>> from sympy import symbols, pi\n    >>> A, B, C, D = symbols('A B C D')\n    >>> check_opposite_angles_equality(A, B, A, B)\n    True\n    >>> check_opposite_angles_equality(pi/2, pi/3, pi/2, pi/3)\n    True\n    >>> check_opposite_angles_equality(90, 45, 89, 44)\n    False", "Freq": 0, "TSR": 0}, {"tool": "def area_of_right_triangle(base, height):\n    \n    return 0.5 * base * height", "subfield": "Quadrilaterals", "tool_name": "area_of_right_triangle", "tool_type": "function", "description": "Calculate the area of a right triangle given its base and height.", "docstring": "Calculate the area of a right triangle given its base and height.\n    \n    Parameters:\n    - base (float): The length of the base of the right triangle.\n    - height (float): The height of the right triangle.\n    \n    Returns:\n    - float: The area of the right triangle.\n    \n    Examples:\n    >>> area_of_right_triangle(3, 4)\n    6.0", "Freq": 1, "TSR": 1}, {"tool": "def quadrilateral_perimeter(*sides):\n    \n    return sum(sides)", "subfield": "Quadrilaterals", "tool_name": "quadrilateral_perimeter", "tool_type": "function", "description": "Calculates the perimeter of a quadrilateral given the lengths of its sides.", "docstring": "Calculates the perimeter of a quadrilateral given the lengths of its sides.\n    Parameters:\n    - sides (float): variable number of side lengths (expects exactly 4 sides).\n    \n    Returns:\n    - float: the perimeter of the quadrilateral.\n    Examples:\n    >>> quadrilateral_perimeter(5, 5, 8, 8)\n    26", "Freq": 1, "TSR": 1}, {"tool": "def calculate_diagonal_rhombus(side_length):\n    \n    diagonal = side_length * math.sqrt(2)\n    return (diagonal, diagonal)", "subfield": "Quadrilaterals", "tool_name": "calculate_diagonal_rhombus", "tool_type": "function", "description": "Calculate the diagonals of a rhombus given the length of its side.", "docstring": "Calculate the diagonals of a rhombus given the length of its side.\n    \n    Parameters:\n    - side_length (float): The length of the side of the rhombus.\n    \n    Returns:\n    - tuple: The lengths of the diagonals of the rhombus.\n    \n    Examples:\n    >>> calculate_diagonal_rhombus(5)\n    (7.071, 7.071)", "Freq": 0, "TSR": 0}, {"tool": "def verify_parallelogram_angles(angle_A, angle_B, angle_C, angle_D):\n    \n    # Checking opposite angles\n    opposite_equal = (angle_A == angle_C) and (angle_B == angle_D)\n    \n    # Checking adjacent angles\n    adjacent_supplementary = (angle_A + angle_B == 180) and (angle_C + angle_D == 180)\n    \n    return opposite_equal and adjacent_supplementary", "subfield": "Quadrilaterals", "tool_name": "verify_parallelogram_angles", "tool_type": "function", "description": "Verify whether four given angles can form a parallelogram based on the properties:\n    - Opposite angles are equal.\n    - Adjacent angles are supplementary (sum to 180 degrees).", "docstring": "Verify whether four given angles can form a parallelogram based on the properties:\n    - Opposite angles are equal.\n    - Adjacent angles are supplementary (sum to 180 degrees).\n    \n    Parameters:\n        angle_A (int/float/sympy.Expr): Angle at vertex A (degrees)\n        angle_B (int/float/sympy.Expr): Angle at vertex B (degrees)\n        angle_C (int/float/sympy.Expr): Angle at vertex C (degrees)\n        angle_D (int/float/sympy.Expr): Angle at vertex D (degrees)\n        \n    Returns:\n        bool: True if the angles can form a parallelogram, False otherwise.\n    \n    Examples:\n        >>> verify_parallelogram_angles(70, 110, 70, 110)\n        True\n        >>> verify_parallelogram_angles(70, 100, 70, 100)\n        False  # This would be false because adjacent angles 70 and 100 do not sum to 180", "Freq": 0, "TSR": 0}, {"tool": "def triangle_calculations_in_quadrilaterals(side_lengths, angle=None, use_pythagoras=False):\n    \n    import math\n    \n    a, b, c = side_lengths\n    if use_pythagoras and angle is None:\n        # Assume right triangle; check if condition holds\n        return {'is_right_triangle': math.isclose(a**2 + b**2, c**2), 'missing_side': math.sqrt(a**2 + b**2)}\n    elif angle:\n        # Use the law of cosines: c^2 = a^2 + b^2 - 2ab*cos(C)\n        return math.sqrt(a**2 + b**2 - 2*a*b*math.cos(angle))\n    return None", "subfield": "Quadrilaterals", "tool_name": "triangle_calculations_in_quadrilaterals", "tool_type": "function", "description": "Function that facilitates triangle calculations such as angle calculations using the law of cosines or using the Pythagorean theorem in specific triangles within quadrilaterals.", "docstring": "Function that facilitates triangle calculations such as angle calculations using the law of cosines or using the Pythagorean theorem in specific triangles within quadrilaterals.\n    \n    Parameters:\n        side_lengths (tuple[float]): The lengths of the sides of the triangle.\n        angle (float, optional): The angle for which the law of cosines is to be applied. Provided in radians if used.\n        use_pythagoras (bool): Whether to use the Pythagorean Theorem.\n    \n    Returns:\n        float: The calculated value based on given parameters (could be side length or angle).\n    \n    Example:\n        >>> triangle_calculations_in_quadrilaterals((3, 4, 5), use_pythagoras=True)\n        {'is_right_triangle': True, 'missing_side': 5}", "Freq": 1, "TSR": 1}, {"tool": "def pythagorean_theorem(a=None, b=None, c=None):\n    \n    if a is None:\n        return math.sqrt(c**2 - b**2)\n    elif b is None:\n        return math.sqrt(c**2 - a**2)\n    elif c is None:\n        return math.sqrt(a**2 + b**2)\n    else:\n        return None", "subfield": "Quadrilaterals", "tool_name": "pythagorean_theorem", "tool_type": "function", "description": "Given any two sides of a right triangle, calculate the third side using the Pythagorean Theorem.", "docstring": "Given any two sides of a right triangle, calculate the third side using the Pythagorean Theorem.\n    Parameters:\n    - a (float, optional): one leg of the right triangle.\n    - b (float, optional): the other leg of the right triangle.\n    - c (float, optional): the hypotenuse of the right triangle.\n    \n    Returns:\n    - float: the length of the missing side.\n    Examples:\n    >>> pythagorean_theorem(a=3, b=4)\n    5.0\n    >>> pythagorean_theorem(c=5, b=4)\n    3.0", "Freq": 0, "TSR": 0}, {"tool": "def quadrilateral_properties_calculations(quadrilateral_type, *sides):\n    \n    import math\n    \n    result = {}\n    if quadrilateral_type in ['rectangle', 'rhombus']:\n        area = sides[0] * sides[1]\n        perimeter = 2 * (sides[0] + sides[1])\n        result['area'] = area\n        result['perimeter'] = perimeter\n        if quadrilateral_type == 'rectangle':\n            result['is_square'] = sides[0] == sides[1]\n        elif quadrilateral_type == 'rhombus':\n            result['diagonal_u'] = math.sqrt(2) * sides[0]\n            result['diagonal_v'] = math.sqrt(2) * sides[1]\n    elif quadrilateral_type == 'isosceles_trapezoid':\n        a, b, c, d = sides  # a, d are bases; b, c are legs\n        # More complex calculations like area using trapezoid formula\n    else:\n        # Calculate using general formulas, possibly Brahmagupta's formula for area of a general quadrilateral\n        pass\n    \n    return result", "subfield": "Quadrilaterals", "tool_name": "quadrilateral_properties_calculations", "tool_type": "function", "description": "Calculate properties like area, perimeter, and specific checks for types of quadrilaterals.", "docstring": "Calculate properties like area, perimeter, and specific checks for types of quadrilaterals.\n    \n    Parameters:\n        quadrilateral_type (str): Type of the quadrilateral ['rectangle', 'rhombus', 'isosceles_trapezoid', 'general_quadrilateral']\n        *sides (float): Varies based on the type. For 'rectangle' and 'rhombus', only two are needed as they are symmetrical. \n                        For 'isosceles_trapezoid' and 'general_quadrilateral', all four sides should be provided.\n    \n    Returns:\n        dict: returns a dictionary containing properties like area, perimeter and specific type properties if any.\n    \n    Example:\n        >>> print(quadrilateral_properties_calculations('rectangle', 5, 10))\n        {'area': 50, 'perimeter': 30, 'is_square': False}", "Freq": 0, "TSR": 0}], "Ellipse": [{"tool": "def ellipse_standard_to_general(h, k, a, b):\n    \n    x, y = sp.symbols('x y')\n    eq = (x - h)**2/a**2 + (y - k)**2/b**2 - 1\n    return sp.simplify(eq)", "subfield": "Ellipse", "tool_name": "ellipse_standard_to_general", "tool_type": "function", "description": "Convert the standard equation of an ellipse to its general form.", "docstring": "Convert the standard equation of an ellipse to its general form.\n    Parameters:\n        h (float): The x-coordinate of the ellipse's center.\n        k (float): The y-coordinate of the ellipse's center.\n        a (float): Length of the semi-major axis.\n        b (float): Length of the semi-minor axis.\n    Returns:\n        sympy expression: The general form of the ellipse equation.\n    Examples:\n        >>> ellipse_standard_to_general(1, 2, 5, 3)\n        Eq(x**2/25 - x*2/5 + y**2/9 - y*4/9 + 5, 0)", "Freq": 0, "TSR": 0}, {"tool": "def ellipse_area(a, b):\n    \n    return math.pi * a * b", "subfield": "Ellipse", "tool_name": "ellipse_area", "tool_type": "function", "description": "Calculate the area of an ellipse given the lengths of its semi-major and semi-minor axes.", "docstring": "Calculate the area of an ellipse given the lengths of its semi-major and semi-minor axes.\n    \n    Parameters:\n    a (float): length of the semi-major axis.\n    b (float): length of the semi-minor axis.\n    Returns:\n    float: Area of the ellipse.\n    Example:\n    >>> ellipse_area(5, 3)\n    47.12388980384689", "Freq": 0, "TSR": 0}, {"tool": "def ellipse_standard_form(coordinates, a, b, angle=0):\n    \n    if angle != 0:\n        return f\"Rotated by {angle} degrees: Standard equation not directly applicable.\"\n    h, k = coordinates\n    equation = f\"(x-{h})^2/{a**2} + (y-{k})^2/{b**2} = 1\"\n    return equation", "subfield": "Ellipse", "tool_name": "ellipse_standard_form", "tool_type": "function", "description": "Represents the equation of an ellipse in its standard form based on provided parameters.", "docstring": "Represents the equation of an ellipse in its standard form based on provided parameters.\n    \n    Parameters:\n    coordinates : tuple\n        The (x, y) coordinates of the center of the ellipse.\n    a : float\n        The length of the semi-major axis.\n    b : float\n        The length of the semi-minor axis.\n    angle : float, optional\n        The rotation angle of the ellipse in degrees (default is 0).\n    Returns:\n    str\n        A string representing the standard form equation of the ellipse.\n    Examples:\n    >>> ellipse_standard_form((0, 0), 5, 3)\n    'x^2/25 + y^2/9 = 1'\n    >>> ellipse_standard_form((0, 0), 5, 3, 45)\n    'Rotated by 45 degrees: Standard equation not directly applicable.'", "Freq": 0, "TSR": 0}, {"tool": "def ellipse_properties(focus_distance, inscribed_circle_diameter):\n    \n    \n    def calculate_axes(focus_distance, inscribed_circle_diameter):\n        # The radius of the inscribed circle\n        r = inscribed_circle_diameter / 2\n        \n        # Estimate the semi-major axis (a)\n        a = focus_distance + r\n        \n        # Calculate the semi-minor axis (b) using the relationship c^2 = a^2 - b^2\n        c = focus_distance\n        b = math.sqrt(a**2 - c**2)\n        \n        return a, b\n    \n    def calculate_foci_distance(a, b):\n        # The distance between the foci of the ellipse is given by 2c\n        c = math.sqrt(a**2 - b**2)\n        return 2 * c\n    \n    # Calculate semi-major and semi-minor axes\n    a, b = calculate_axes(focus_distance, inscribed_circle_diameter)\n    \n    # Calculate the distance between the foci\n    foci_distance = calculate_foci_distance(a, b)\n    \n    return a, b, foci_distance", "subfield": "Ellipse", "tool_name": "ellipse_properties", "tool_type": "function", "description": "Calculate the semi-major and semi-minor axes of an ellipse given the distance from the center to one focus\n    and the diameter of the inscribed circle of a triangle formed by the center and a point on the ellipse.", "docstring": "Calculate the semi-major and semi-minor axes of an ellipse given the distance from the center to one focus\n    and the diameter of the inscribed circle of a triangle formed by the center and a point on the ellipse.\n    \n    Parameters:\n    focus_distance (float): The distance from the center of the ellipse to one of its foci.\n    inscribed_circle_diameter (float): The diameter of the inscribed circle of the triangle formed.\n    \n    Returns:\n    tuple: A tuple containing the semi-major axis (a), semi-minor axis (b), and the distance between the foci (2c).", "Freq": 3, "TSR": 0}]}