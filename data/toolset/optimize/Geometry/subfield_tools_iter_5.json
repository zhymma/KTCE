{"Circles": [{"tool": "def circle_circumference(radius):\n    \n    return 2 * np.pi * radius", "subfield": "Circles", "tool_name": "circle_circumference", "tool_type": "function", "description": "Calculates the circumference of a circle given its radius.", "docstring": "Calculates the circumference of a circle given its radius.\n    \n    Parameters:\n        radius (float): The radius of the circle.\n    Returns:\n        float: The circumference of the circle.", "Freq": 2, "TSR": 0}, {"tool": "def circle_area(radius):\n    \n    return math.pi * radius ** 2", "subfield": "Circles", "tool_name": "circle_area", "tool_type": "function", "description": "Calculate the area of a circle given the radius.", "docstring": "Calculate the area of a circle given the radius.\n    \n    Parameters:\n    - radius (float): The radius of the circle.\n    \n    Returns:\n    - float: The area of the circle.", "Freq": 11.0, "TSR": 2.5}, {"tool": "def circle_standard_form(h, k, r):\n    \n    x, y = sympy.symbols('x y')\n    return sympy.Eq((x - h)**2 + (y - k)**2, r**2)", "subfield": "Circles", "tool_name": "circle_standard_form", "tool_type": "function", "description": "Create the standard form equation of a circle (x-h)^2 + (y-k)^2 = r^2.", "docstring": "Create the standard form equation of a circle (x-h)^2 + (y-k)^2 = r^2.\n    \n    Parameters:\n        h (float): The x-coordinate of the circle's center.\n        k (float): The y-coordinate of the circle's center.\n        r (float): The radius of the circle.\n        \n    Returns:\n        sympy.Eq: The equation of the circle in sympy equation format.\n        \n    Example:\n        >>> print(circle_standard_form(0, 0, 5))\n        Eq(x**2 + y**2, 25)", "Freq": 1, "TSR": 1}, {"tool": "def circle_properties_from_equation(h, k, r_squared):\n    \n    r = sqrt(r_squared)\n    area = pi * r**2\n    circumference = 2 * pi * r\n    return {\n        'center': (h, k),\n        'radius': r.evalf(),\n        'area': area.evalf(),\n        'circumference': circumference.evalf()\n    }", "subfield": "Circles", "tool_name": "circle_properties_from_equation", "tool_type": "function", "description": "Given the parameters h, k (center of the circle) and r_squared (radius squared),\n    returns the center, radius, area, and circumference of the circle.", "docstring": "Given the parameters h, k (center of the circle) and r_squared (radius squared),\n    returns the center, radius, area, and circumference of the circle.\n    \n    Parameters:\n        h (float): x-coordinate of the center of the circle\n        k (float): y-coordinate of the center of the circle\n        r_squared (float): square of the radius of the circle\n    Returns:\n        dict: Dictionary containing the center, radius, area, and circumference\n    \n    Examples:\n    >>> circle_properties_from_equation(0, 0, 25)\n    {'center': (0, 0), 'radius': 5.0, 'area': 78.5398, 'circumference': 31.4159}", "Freq": 4, "TSR": 2, "experience_pool": "Experience 1:\nProblem: What is the area of a circle with a radius of 7?\nAnswer: 153.93804002589985\n\nExperience 2:\nProblem: Calculate the circumference of a circle with a radius of 10.\nAnswer: 62.83185307179586"}, {"tool": "def point_inside_circle(center, radius, point):\n    \n    return np.sqrt((point[0] - center[0])**2 + (point[1] - center[1])**2) <= radius", "subfield": "Circles", "tool_name": "point_inside_circle", "tool_type": "function", "description": "Determine if a point is inside a given circle.", "docstring": "Determine if a point is inside a given circle.\n    \n    Parameters:\n    - center (tuple): The (x, y) coordinates of the circle's center.\n    - radius (float): The radius of the circle.\n    - point (tuple): The (x, y) coordinates of the point to check.\n    \n    Returns:\n    - bool: True if the point is inside the circle, False otherwise.", "Freq": 0, "TSR": 0}, {"tool": "def circle_properties(radius, chord_length=None, angle_radians=None):\n    area = math.pi * radius**2\n    circumference = 2 * math.pi * radius\n    properties = {\n        'Area': area,\n        'Circumference': circumference\n    }\n    if chord_length is not None:\n        if angle_radians is None:\n            angle_radians = 2 * math.acos(chord_length / (2 * radius))\n        sagitta = radius * (1 - math.cos(angle_radians / 2))\n        arc_length = radius * angle_radians\n        segment_area = (radius**2 / 2) * (angle_radians - math.sin(angle_radians))\n        \n        properties.update({\n            'Chord Length': chord_length,\n            'Sagitta': sagitta,\n            'Arc Length': arc_length,\n            'Segment Area': segment_area\n        })\n    return properties", "subfield": "Circles", "tool_name": "circle_properties", "tool_type": "function", "description": "None", "docstring": null, "Freq": 2.5, "TSR": 2}, {"tool": "def compute_triangle_properties(vertices):\n    \n    vertices = np.array(vertices)\n    side_lengths = np.linalg.norm(vertices - np.roll(vertices, -1, axis=0), axis=1)\n    s = np.sum(side_lengths) / 2  # semi-perimeter\n    area = np.sqrt(s * np.prod(s - side_lengths))  # Heron's formula\n    is_iso = np.any(side_lengths[0] == side_lengths[1]) or np.any(side_lengths[1] == side_lengths[2])\n    is_equi = np.all(side_lengths[0] == side_lengths[1])\n    properties = {\n        'Area': area,\n        'Perimeter': 2 * s,\n        'Side Lengths': side_lengths,\n        'Isosceles': is_iso,\n        'Equilateral': is_equi\n    }\n    return properties", "subfield": "Circles", "tool_name": "compute_triangle_properties", "tool_type": "function", "description": "Compute properties of a triangle given its vertices.", "docstring": "Compute properties of a triangle given its vertices.\n    Parameters:\n        vertices (array): An array of three tuples, each representing x, y coordinates of a vertex.\n    Returns:\n        dict: Properties including area, perimeter, side lengths, and types of triangle (isosceles, equilateral).", "Freq": 2, "TSR": 1, "experience_pool": "- Problem: Triangle $ABC$ has side lengths $AB=4$, $BC=5$, and $CA=6$. Points $D$ and $E$ are on ray $AB$ with $AB<AD<AE$. The point $F \\neq C$ is a point of intersection of the circumcircles of $\\triangle ACD$ and $\\triangle EBC$ satisfying $DF=2$ and $EF=7$. Then $BE$ can be expressed as $\\tfrac{a+b\\sqrt{c}}{d}$, where $a$, $b$, $c$, and $d$ are positive integers such that $a$ and $d$ are relatively prime, and $c$ is not divisible by the square of any prime. Find $a+b+c+d$.\n\n- Solution: The error in the solution code is due to the missing variables DF and EF. These variables need to be defined before using them in the equation for DE_squared. To fix the error, the solution code should include the definitions of DF and EF before calculating DE_squared.\n\n```python\n# Given side lengths of the triangle\nAB = 4\nBC = 5\nCA = 6\n\n# Compute the area of the triangle using Heron's formula\nvertices = [(0, 0), (AB, 0), (CA - (BC**2 - AB**2 - CA**2) / (2 * CA), (BC**2 - (CA - (BC**2 - AB**2 - CA**2) / (2 * CA))**2)**0.5)]\ntriangle_properties = compute_triangle_properties(vertices)\narea_ABC = triangle_properties['Area']\n\n# Define DF and EF\nDF = 2\nEF = 7\n\n# Compute DE using Law of Cosines\nDE_squared = DF**2 + EF**2 - 2 * DF * EF * cos(180 - B - A)\nDE = sqrt(DE_squared)\n\n# Compute a and b\na = symbols('a')\nb = a * sqrt(2)\neq = Eq(b * (a + 4), a * (b + 4 * sqrt(2)))\na_value = solve(eq, a)[0]\n\n# Compute BE\nBE = a_value + a_value * sqrt(2) + 4 * sqrt(2)\n\n# Calculate the final result\nresult = int(BE.as_numer_denom()[0]) + int(BE.as_numer_denom()[1]) + int(BE.as_numer_denom()[1].as_numer_denom()[0]) + int(BE.as_numer_denom()[1].as_numer_denom()[1])\nreturn result\n```"}, {"tool": "def find_curve_equation(radius):\n    \n    if radius == 0:\n        return \"Point\"\n    elif radius > 0:\n        return \"Circle\"\n    else:\n        return \"No curve\"", "subfield": "Circles", "tool_name": "find_curve_equation", "tool_type": "function", "description": "Find the curve defined by the equation r = radius.", "docstring": "Find the curve defined by the equation r = radius.\n    Parameters:\n    radius (float): The radius of the circle.\n    Returns:\n    str: The geometric shape based on the given equation.", "Freq": 0, "TSR": 0}], "Coordinate Geometry": [{"tool": "def distance_between_points(point1, point2):\n    \n    x1, y1 = point1\n    x2, y2 = point2\n    return ((x2 - x1)**2 + (y2 - y1)**2)**0.5", "subfield": "Coordinate Geometry", "tool_name": "distance_between_points", "tool_type": "function", "description": "Calculate the Euclidean distance between two points in the plane.", "docstring": "Calculate the Euclidean distance between two points in the plane.\n    \n    Parameters:\n    - point1 (tuple): The first point (x1, y1).\n    - point2 (tuple): The second point (x2, y2).\n    \n    Returns:\n    - float: The distance between the points.\n    \n    Examples:\n    >>> distance_between_points((1, 2), (4, 6))\n    5.0", "Freq": 82, "TSR": 55, "experience_pool": "Tool: distance_between_points\nField: Geometry\nSubfield: Coordinate Geometry\nTool Usage Frequency: 35\nTool Success Rate: 68.57%\nTool docstring: Calculate the Euclidean distance between two points in the plane.\n\nParameters:\n- point1 (tuple): The first point (x1, y1).\n- point2 (tuple): The second point (x2, y2).\n\nReturns:\n- float: The distance between the points.\n\nExamples:\n>>> distance_between_points((1, 2), (4, 6))\n5.0"}, {"tool": "def midpoint(p1, p2):\n    \n    return tuple((np.array(p1) + np.array(p2)) / 2)", "subfield": "Coordinate Geometry", "tool_name": "midpoint", "tool_type": "function", "description": "Calculates the midpoint between two points in a 2D coordinate system.", "docstring": "Calculates the midpoint between two points in a 2D coordinate system.\n    Parameters:\n    - p1: Tuple of coordinates (x1, y1) for the first point.\n    - p2: Tuple of coordinates (x2, y2) for the second point.\n    Returns:\n    - Tuple: Coordinates of the midpoint.\n    Example:\n    >>> midpoint((1, 2), (3, 4))\n    (2.0, 3.0)", "Freq": 37, "TSR": 26, "experience_pool": "- Problem: Point M(3,7) is the midpoint of line segment AB. If point A has coordinates (9,3), what is the sum of the coordinates of point B?\n  - Answer: 8\n  - The solution function correctly calculates the sum of the coordinates of point B using the midpoint formula.\n- Problem: Point M(4,4) is the midpoint of line segment AB. If point A has coordinates (8,4), what is the sum of the coordinates of point B?\n  - Answer: 4\n  - The solution function correctly calculates the sum of the coordinates of point B using the midpoint formula.\n- Problem: In a polar coordinate system, the midpoint of the line segment whose endpoints are (8, 5pi/12) and (8, -3pi/12) is the point (r, theta). Enter (r, theta), where r > 0 and 0 <= theta < 2pi.\n  - Answer: (4, pi/12)\n  - The solution function correctly calculates the midpoint coordinates using the given endpoints.\n- Problem: In convex quadrilateral ABCD, AB=BC=13, CD=DA=24, and angle D=60 degrees. Points X and Y are the midpoints of BC and DA respectively. Compute XY^2 (the square of the length of XY).\n  - Answer: 1033/4 + 30sqrt(3)\n  - The solution function correctly calculates the square of the length of XY using the midpoint formula and distance formula.\n- Problem: In square ABCD, AD is 4 centimeters, and M is the midpoint of CD. Let O be the intersection of AC and BM. What is the ratio of OC to OA? Express your answer as a common fraction.\n  - Answer: 1/2\n  - The solution function correctly calculates the ratio of OC to OA using the midpoint formula and line intersection formula."}, {"tool": "def slope_of_line(p1, p2):\n    \n    x1, y1 = p1\n    x2, y2 = p2\n    if x2 == x1:\n        raise ValueError(\"Vertical line segment has no slope.\")\n    return (y2 - y1) / (x2 - x1)", "subfield": "Coordinate Geometry", "tool_name": "slope_of_line", "tool_type": "function", "description": "Computes the slope of the line segment connecting two points. Raises exception if the line is vertical.", "docstring": "Computes the slope of the line segment connecting two points. Raises exception if the line is vertical.\n    Parameters:\n    - p1: Tuple of coordinates (x1, y1)\n    - p2: Tuple of coordinates (x2, y2)\n    Returns:\n    - float: Slope of the line.\n    Example:\n    >>> slope_of_line((1, 2), (3, 6))\n    2.0", "Freq": 31, "TSR": 20}, {"tool": "def area_of_triangle(p1, p2, p3):\n    if len(p1) == 2:\n        x1, y1 = p1\n        x2, y2 = p2\n        x3, y3 = p3\n        return 0.5 * abs(x1*(y2 - y3) + x2*(y3 - y1) + x3*(y1 - y2))\n    elif len(p1) == 3:\n        x1, y1, z1 = p1\n        x2, y2, z2 = p2\n        x3, y3, z3 = p3\n        return 0.5 * abs(x1*(y2*z3 - y3*z2) + x2*(y3*z1 - y1*z3) + x3*(y1*z2 - y2*z1))\n    else:\n        raise ValueError(\"Invalid number of coordinates for vertices.\")", "subfield": "Coordinate Geometry", "tool_name": "area_of_triangle", "tool_type": "function", "description": "None", "docstring": null, "Freq": 23.0, "TSR": 9.0}, {"tool": "def reflect(point, axis=\"x\"):\n    \n    x, y = point\n    if axis == \"x\":\n        return (x, -y)\n    elif axis == \"y\":\n        return (-x, y)\n    elif axis == \"origin\":\n        return (-x, -y)\n    elif axis == \"y=x\":\n        return (y, x)\n    else:\n        raise ValueError(\"Invalid axis specified.\")", "subfield": "Coordinate Geometry", "tool_name": "reflect", "tool_type": "function", "description": "Reflect a point across a specified axis in 2D.", "docstring": "Reflect a point across a specified axis in 2D.\n    \n    Parameters:\n        point (tuple): Coordinates (x, y) of the point.\n        axis (str): Axis you want to reflect over, \"x\", \"y\", or \"origin\". Additionally supports \"y=x\".\n    \n    Returns:\n        tuple: Coordinates of the reflected point.\n        \n    Examples:\n        reflect((2, 3), axis=\"x\")\n        reflect((2, 3), axis=\"y\")\n        reflect((2, 3), axis=\"origin\")\n        reflect((2, 3), axis=\"y=x\")", "Freq": 11, "TSR": 10, "experience_pool": "- Reflecting a point across the x-axis: reflect((2, 3), axis=\"x\") returns (2, -3)\n- Reflecting a point across the y-axis: reflect((2, 3), axis=\"y\") returns (-2, 3)\n- Reflecting a point across the origin: reflect((2, 3), axis=\"origin\") returns (-2, -3)\n- Reflecting a point across the line y=x: reflect((2, 3), axis=\"y=x\") returns (3, 2)"}, {"tool": "def convert_conic_to_standard_form(eq_type, coefficients):\n    \n    \n    import math\n    if eq_type in ['circle', 'ellipse']:\n        A = coefficients.get('x^2', 0)\n        B = coefficients.get('y^2', 0)\n        C = coefficients.get('x', 0)\n        D = coefficients.get('y', 0)\n        E = coefficients.get('constant', 0)\n        h = -C / (2 * A)\n        k = -D / (2 * B)\n        r_squared = -E + (C**2) / (4 * A) + (D**2) / (4 * B)\n        if eq_type == 'circle':\n            return {'center': (h, k), 'radius': math.sqrt(r_squared)}\n        elif eq_type == 'ellipse':\n            return {'center': (h, k), 'semi_major_axis': math.sqrt(r_squared / A), 'semi_minor_axis': math.sqrt(r_squared / B)}\n    elif eq_type == 'parabola':\n        # Assume coefficients of 'x^2' or 'y^2' and a linear term for directrix/vertex form conversion.\n        pass\n    elif eq_type == 'hyperbola':\n        A = coefficients.get('x^2', 0)\n        B = coefficients.get('y^2', 0)\n        C = coefficients.get('x', 0)\n        D = coefficients.get('y', 0)\n        E = coefficients.get('constant', 0)\n        h = -C / (2 * A)\n        k = -D / (2 * B)\n        r_squared = -E + (C**2) / (4 * A) - (D**2) / (4 * B)\n        return {'center': (h, k), 'semi_major_axis': math.sqrt(r_squared / A), 'semi_minor_axis': math.sqrt(r_squared / B)}\n    \n    return {}", "subfield": "Coordinate Geometry", "tool_name": "convert_conic_to_standard_form", "tool_type": "function", "description": "Converts a general equation of a conic section (circle, ellipse, parabola, hyperbola) to its standard form.", "docstring": "Converts a general equation of a conic section (circle, ellipse, parabola, hyperbola) to its standard form.\n    \n    Parameters:\n    - eq_type (str): Type of conic ('circle', 'ellipse', 'parabola', 'hyperbola').\n    - coefficients (dict): Coefficients of the equation. E.g., for a circle: {'x^2': 1, 'y^2': 1, 'x': -6, 'y': 4, 'constant': -3}\n    \n    Returns:\n    - dict: Standardized form parameters.\n    \n    Example:\n    >>> convert_conic_to_standard_form('circle', {'x^2': 1, 'y^2': 1, 'x': -6, 'y': 4, 'constant': -3})\n    {'center': (3, -2), 'radius': 4}", "Freq": 4.5, "TSR": 1}, {"tool": "def calculate_area_of_square(side_length):\n    \n    return side_length**2", "subfield": "Coordinate Geometry", "tool_name": "calculate_area_of_square", "tool_type": "function", "description": "Calculate the area of a square given the side length.", "docstring": "Calculate the area of a square given the side length.\n    \n    Parameters:\n        side_length (float or sympy expression): The length of the side of the square.\n    \n    Returns:\n        float or sympy expression: The area of the square.\n    Example:\n        area = calculate_area_of_square(5)\n        print(area)  # Output: 25", "Freq": 9, "TSR": 7, "experience_pool": "The side length of the square AE should be calculated as side_length_BE * sqrt(2) since AE is the diagonal of the square ABCD.\nThe sum_of_areas should be calculated as (area_AB + area_AE)**2."}, {"tool": "def calculate_area(shape, *args):\n    \n    if shape == 'circle':\n        radius = args[0]\n        return math.pi * radius**2\n    elif shape == 'rectangle':\n        length = args[0]\n        width = args[1]\n        return length * width\n    elif shape == 'triangle':\n        base = args[0]\n        height = args[1]\n        return 0.5 * base * height\n    else:\n        return \"Invalid shape\"", "subfield": "Coordinate Geometry", "tool_name": "calculate_area", "tool_type": "function", "description": "Calculates the area of a geometric shape.", "docstring": "Calculates the area of a geometric shape.\n    Parameters:\n    shape (str): The shape of the object ('circle', 'rectangle', 'triangle', etc.)\n    *args: Variable length arguments depending on the shape. For example, for a circle, pass the radius as the argument.\n    Returns:\n    float: The area of the geometric shape.", "Freq": 8.5, "TSR": 5, "experience_pool": "- Experience 1:\n    - Field: Geometry\n    - Subfield: Coordinate Geometry\n    - Tool Usage Frequency: 3\n    - Tool Success Rate: 66.66666666666666%\n    - Tool docstring: Calculates the area of a circle given its radius.\n    - Tool code:\n        ```python\n        def circle_area(radius):\n            return np.pi * radius**2\n        ```\n    - Problem: The graph of \\(r = -2 \\cos \\theta + 6 \\sin \\theta\\) is a circle. Find the area of the circle.\n    - Answer: 10 \\pi\n    - Solution:\n        ```python\n        from sympy import Symbol, sqrt\n\n        def solution():\n            # Calculate the radius of the circle\n            r = sqrt(10) / 2\n\n            # Calculate the area of the circle\n            area_circle = calculate_area('circle', r)\n\n            return area_circle\n\n        # Print the result\n        print(solution())\n        ```\n    - Output: 7.85398163397448"}, {"tool": "def vector_add(v1, v2):\n    \n    return np.add(v1, v2)", "subfield": "Coordinate Geometry", "tool_name": "vector_add", "tool_type": "function", "description": "Adds two vectors.", "docstring": "Adds two vectors.\n    Parameters:\n    v1 (ndarray): A numpy array representing the first vector.\n    v2 (ndarray): A numpy array representing the second vector.\n    Returns:\n    ndarray: The vector sum of v1 and v2.", "Freq": 0, "TSR": 0}, {"tool": "def circle_equation(h, k, r):\n    \n    return f\"(x - {h})^2 + (y - {k})^2 = {r}^2\"", "subfield": "Coordinate Geometry", "tool_name": "circle_equation", "tool_type": "function", "description": "Returns the standard form equation of a circle given the center (h, k) and radius r.", "docstring": "Returns the standard form equation of a circle given the center (h, k) and radius r.\n    Parameters:\n    h (float): The x-coordinate of the center.\n    k (float): The y-coordinate of the center.\n    r (float): The radius of the circle.\n    Returns:\n    str: The equation of the circle in standard form.\n    Examples:\n    >>> circle_equation(0, 0, 1)\n    '(x - 0)^2 + (y - 0)^2 = 1^2'", "Freq": 0, "TSR": 0}, {"tool": "def line_equation_from_point_slope(point, slope):\n    \n    x, y = point\n    c = y - slope * x\n    return slope, c", "subfield": "Coordinate Geometry", "tool_name": "line_equation_from_point_slope", "tool_type": "function", "description": "Find the equation of a line in slope-intercept form 'y = mx + c' given a point and a slope.", "docstring": "Find the equation of a line in slope-intercept form 'y = mx + c' given a point and a slope.\n    \n    Parameters:\n    - point (tuple): Point (x, y) through which the line passes.\n    - slope (float): Slope of the line.\n    \n    Returns:\n    - tuple: slope m and intercept c of the line 'y = mx + c'.\n    \n    Examples:\n    >>> line_equation_from_point_slope((1, 2), 3)\n    (3, -1)", "Freq": 10, "TSR": 7, "experience_pool": "Experience 1:\nProblem: Find the equation of a line passing through the points (2, 3) and (4, 5).\nSolution: We can use the line_equation_from_point_slope function to find the equation of the line.\n```python\npoint1 = (2, 3)\npoint2 = (4, 5)\nslope = (point2[1] - point1[1]) / (point2[0] - point1[0])\nequation = line_equation_from_point_slope(point1, slope)\nprint(equation)\n```\nOutput: (1, 1)\n\nExperience 2:\nProblem: Find the equation of a line passing through the points (-1, 2) and (3, 4).\nSolution: We can use the line_equation_from_point_slope function to find the equation of the line.\n```python\npoint1 = (-1, 2)\npoint2 = (3, 4)\nslope = (point2[1] - point1[1]) / (point2[0] - point1[0])\nequation = line_equation_from_point_slope(point1, slope)\nprint(equation)\n```\nOutput: (0.5, 2.5)"}, {"tool": "def vector_subtract(v1, v2):\n    \n    return np.subtract(v1, v2)", "subfield": "Coordinate Geometry", "tool_name": "vector_subtract", "tool_type": "function", "description": "Subtracts the second vector from the first.", "docstring": "Subtracts the second vector from the first.\n    Parameters:\n    v1 (ndarray): A numpy array representing the first vector.\n    v2 (ndarray): A numpy array representing the second vector.\n    Returns:\n    ndarray: The vector result of v1 - v2.", "Freq": 1, "TSR": 0}, {"tool": "def midpoint(point1, point2):\n    \n    return (np.array(point1) + np.array(point2)) / 2", "subfield": "Coordinate Geometry", "tool_name": "midpoint", "tool_type": "function", "description": "Calculate the midpoint between two points in n-dimensional space.", "docstring": "Calculate the midpoint between two points in n-dimensional space.\n    Parameters:\n        point1 (array-like): The first point coordinates.\n        point2 (array-like): The second point coordinates.\n    Returns:\n        ndarray: The coordinates of the midpoint.\n    Examples:\n        >>> midpoint([1, 2], [3, 4])\n        array([2., 3.])", "Freq": 1, "TSR": 0}, {"tool": "def point_line_position(point, line):\n    \n    x, y = point\n    m, c = line\n    line_y = m * x + c\n    if y > line_y:\n        return 'above'\n    elif y < line_y:\n        return 'below'\n    else:\n        return 'on'", "subfield": "Coordinate Geometry", "tool_name": "point_line_position", "tool_type": "function", "description": "Determine the relative position of a point with respect to a line.", "docstring": "Determine the relative position of a point with respect to a line.\n    \n    Parameters:\n    - point (tuple): The point (x, y).\n    - line (tuple): The slope and intercept (m, c) of the line.\n    \n    Returns:\n    - str: 'above', 'below' or 'on' the line\n    \n    Examples:\n    >>> point_line_position((3, 4), (1, 1))\n    'above'", "Freq": 1, "TSR": 1}, {"tool": "def vector_from_points(point1, point2):\n    \n    return np.array(point2) - np.array(point1)", "subfield": "Coordinate Geometry", "tool_name": "vector_from_points", "tool_type": "function", "description": "Calculate the vector from point1 to point2 in 3D.", "docstring": "Calculate the vector from point1 to point2 in 3D.\n    \n    Parameters:\n    - point1 (array-like): Coordinates of the first point.\n    - point2 (array-like): Coordinates of the second point.\n    \n    Returns:\n    - numpy.ndarray: The vector from point1 to point2.\n    \n    Example:\n    >>> vector_from_points([1, 2, 3], [4, 5, 6])\n    array([3, 3, 3])", "Freq": 2, "TSR": 2}, {"tool": "def circle_equation(center, radius):\n    \n    x, y = symbols('x y')\n    x0, y0 = center\n    return Eq((x - x0)**2 + (y - y0)**2, radius**2)", "subfield": "Coordinate Geometry", "tool_name": "circle_equation", "tool_type": "function", "description": "Generate the equation of a circle given the center and radius.", "docstring": "Generate the equation of a circle given the center and radius.\n    Parameters:\n        center (tuple): Coordinates of the center of the circle (x, y).\n        radius (float): The radius of the circle.\n    Returns:\n        sympy.Eq: The equation of the circle.\n    Examples:\n        >>> circle_equation((0, 0), 5)\n        Eq(x**2 + y**2, 25)", "Freq": 0, "TSR": 0}, {"tool": "def square_side_from_diagonal(diagonal):\n    \n    return diagonal / np.sqrt(2)", "subfield": "Coordinate Geometry", "tool_name": "square_side_from_diagonal", "tool_type": "function", "description": "Calculate the side length of a square given the diagonal, using the Pythagorean theorem.", "docstring": "Calculate the side length of a square given the diagonal, using the Pythagorean theorem.\n    Parameters:\n    diagonal (float): The length of the diagonal of the square.\n    Returns:\n    float: The length of one side of the square.\n    Examples:\n    >>> square_side_from_diagonal(5.656854249492381)\n    4.0", "Freq": 0, "TSR": 0}, {"tool": "def vector_magnitude(vector):\n    \n    return np.linalg.norm(vector)", "subfield": "Coordinate Geometry", "tool_name": "vector_magnitude", "tool_type": "function", "description": "Calculates the magnitude (norm) of a vector.", "docstring": "Calculates the magnitude (norm) of a vector.\n    Parameters:\n    vector (ndarray): The vector whose magnitude is to be calculated.\n    Returns:\n    float: The magnitude of the vector.", "Freq": 0, "TSR": 0}, {"tool": "def parametric_point_evaluation(param_eqs, t_values):\n    \n    results = []\n    for t_value in t_values:\n        point = {var: eq.subs('t', t_value) for var, eq in param_eqs.items()}\n        results.append(point)\n    return results", "subfield": "Coordinate Geometry", "tool_name": "parametric_point_evaluation", "tool_type": "function", "description": "Evaluate parametric equations at given parameter values.", "docstring": "Evaluate parametric equations at given parameter values.\n    \n    Parameters:\n        param_eqs (dict): A dictionary with variables as keys and their parametric equations as values.\n        t_values (list or scalar): A scalar or list of values to substitute into the parametric equations.\n    \n    Returns:\n        list or dict: Evaluated points at each parameter value.\n    \n    Example:\n        x, y, t = symbols('x y t')\n        param_eqs = {x: t**2, y: t + 1}\n        points = parametric_point_evaluation(param_eqs, [0, 1, 2])\n        print(points)  # Output: [{x: 0, y: 1}, {x: 1, y: 2}, {x: 4, y: 3}]", "Freq": 0, "TSR": 0}, {"tool": "def solve_linear_equations(A, b):\n    \n    try:\n        A = np.array(A)\n        b = np.array(b)\n        x = np.linalg.solve(A, b)\n        return x\n    except np.linalg.LinAlgError:\n        return \"Singular matrix\"", "subfield": "Coordinate Geometry", "tool_name": "solve_linear_equations", "tool_type": "function", "description": "Solve a system of linear equations Ax = b for x using NumPy.", "docstring": "Solve a system of linear equations Ax = b for x using NumPy.\n    Parameters:\n    - A (array-like): coefficient matrix.\n    - b (array-like): constant terms.\n    Returns:\n    - array: solution vector x.", "Freq": 3, "TSR": 1, "experience_pool": "- Problem: In triangle $ABC,$ $D$ lies on $\\overline{BC}$ extended past $C$ such that $BD:DC = 3:1,$ and $E$ lies on $\\overline{AC}$ such that $AE:EC = 5:3.$  Let $P$ be the intersection of lines $BE$ and $AD.$\n\n[asy]\nunitsize(0.8 cm);\n\npair A, B, C, D, E, F, P;\n\nA = (1,4);\nB = (0,0);\nC = (6,0);\nD = interp(B,C,3/2);\nE = interp(A,C,5/8);\nP = extension(A,D,B,E);\n\ndraw(A--B--C--cycle);\ndraw(A--D--C);\ndraw(B--P);\n\nlabel(\"$A$\", A, N);\nlabel(\"$B$\", B, SW);\nlabel(\"$C$\", C, S);\nlabel(\"$D$\", D, SE);\nlabel(\"$E$\", E, S);\nlabel(\"$P$\", P, NE);\n[/asy]\n\nThen\n\\[\\overrightarrow{P} = x \\overrightarrow{A} + y \\overrightarrow{B} + z \\overrightarrow{C},\\]where $x,$ $y,$ and $z$ are constants such that $x + y + z = 1.$  Enter the ordered triple $(x,y,z).$\nAnswer: \\left( \\frac{9}{19}, -\\frac{5}{19}, \\frac{15}{19} \\right)\n\n- Problem: For certain ordered pairs $(a,b)\\,$ of real numbers, the system of equations\n\\[\\begin{aligned} ax+by&=1 \\\\ x^2 + y^2 &= 50  \\end{aligned}\\]has at least one solution, and each solution is an ordered pair $(x,y)\\,$ of integers. How many such ordered pairs $(a,b)\\,$ are there?\nAnswer: 72"}, {"tool": "def point_on_line(line, point):\n    \n    m, c = line\n    x, y = point\n    return y == m * x + c", "subfield": "Coordinate Geometry", "tool_name": "point_on_line", "tool_type": "function", "description": "Determines whether a given point lies on a specified line.", "docstring": "Determines whether a given point lies on a specified line.\n    Parameters\n    ----------\n    line : tuple\n        Coefficients (m, c) of the line equation y = mx + c.\n    point : tuple\n        Coordinates of the point (x, y).\n    \n    Returns\n    -------\n    bool\n        True if the point lies on the line, False otherwise.\n    \n    Examples\n    --------\n    >>> point_on_line((2, 1), (1, 3))\n    True", "Freq": 0, "TSR": 0}, {"tool": "def reflection_point_across_line(line, point):\n    \n    m, c = line\n    x, y = point\n    d = (x + (y - c) * m) / (1 + m**2)\n    x_ref = 2*d - x\n    y_ref = 2*d*m - y + 2*c\n    return (x_ref, y_ref)", "subfield": "Coordinate Geometry", "tool_name": "reflection_point_across_line", "tool_type": "function", "description": "Finds the reflection of a point across a given line.", "docstring": "Finds the reflection of a point across a given line.\n    Parameters\n    ----------\n    line : tuple\n        Coefficients (m, c) of the line equation y = mx + c.\n    point : tuple\n        Coordinates of the point (x, y).\n    Returns\n    -------\n    tuple\n        Coordinates (x', y') of the reflected point.\n    Examples\n    --------\n    >>> reflection_point_across_line((1, 1), (2, 3))\n    (-1.0, 0.0)", "Freq": 2, "TSR": 1, "experience_pool": "- Experience 1:\n    - Problem: The reflect function is being used, which is not defined in the original tool code.\n    - Solution: Add a new reflect function to the tool code.\n- Experience 2:\n    - Problem: The line_translation parameter is being passed as a tuple (1, 0) to the reflection_point_across_line function, which expects the line equation coefficients (m, c).\n    - Solution: Update the code to handle the line_translation parameter correctly."}, {"tool": "def compute_conic_properties(eq_type, standard_params):\n    \n    import math\n    if eq_type == 'circle':\n        center = standard_params['center']\n        radius = standard_params['radius']\n        return {'center': center, 'foci': [center, center], 'radius': radius}\n    elif eq_type == 'ellipse':\n        # Calculate foci, vertices based on semi-major/minor axes.\n        pass\n    elif eq_type == 'parabola':\n        # Vertex, focus calculation.\n        pass\n    elif eq_type == 'hyperbola':\n        # Center, foci, vertices, and asymptotes.\n        pass\n    return {}", "subfield": "Coordinate Geometry", "tool_name": "compute_conic_properties", "tool_type": "function", "description": "Compute geometric properties such as center, foci, vertices, depending on the conic type.", "docstring": "Compute geometric properties such as center, foci, vertices, depending on the conic type.\n    Parameters:\n    - eq_type (str): Type of conic ('circle', 'ellipse', 'parabola', 'hyperbola').\n    - standard_params (dict): Parameters obtained from the standard form conversion.\n    Returns:\n    - dict: Detailed conic properties.\n    Example:\n    >>> compute_conic_properties('circle', {'center': (3, -2), 'radius': 4})\n    {'center': (3, -2), 'foci': [(3, -2), (3, -2)], 'radius': 4}", "Freq": 3, "TSR": 0}, {"tool": "def rectangle_properties(length, width):\n    \n    import math\n    perimeter = 2 * (length + width)\n    area = length * width\n    diagonal = math.sqrt(length**2 + width**2)\n    return {'perimeter': perimeter, 'area': area, 'diagonal': diagonal}", "subfield": "Coordinate Geometry", "tool_name": "rectangle_properties", "tool_type": "function", "description": "Calculate various properties of a rectangle given its length and width.", "docstring": "Calculate various properties of a rectangle given its length and width.\n    Parameters:\n    - length (float): The length of the rectangle.\n    - width (float): The width of the rectangle.\n    Returns:\n    - dict: Dictionary containing the perimeter, area, and diagonal of the rectangle.\n    Examples:\n    >>> rectangle_properties(4, 3)\n    {'perimeter': 14, 'area': 12, 'diagonal': 5.0}", "Freq": 0, "TSR": 0}, {"tool": "def circle_equation(cartesian_point_hk, radius):\n    \n    h, k = cartesian_point_hk\n    def equation(x, y):\n        return (x - h)**2 + (y - k)**2 - radius**2\n    return equation", "subfield": "Coordinate Geometry", "tool_name": "circle_equation", "tool_type": "function", "description": "Provides the equation of a circle in Cartesian coordinates.", "docstring": "Provides the equation of a circle in Cartesian coordinates.\n    Parameters:\n    cartesian_point_hk (tuple): (h, k) the center of the circle in Cartesian coordinates\n    radius (float): the radius of the circle\n    Returns:\n    function: Function that calculates (x - h)² + (y - k)² - r² for given x, y", "Freq": 1, "TSR": 1}, {"tool": "def distance(x1, y1, x2, y2):\n    \n    return sp.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2)", "subfield": "Coordinate Geometry", "tool_name": "distance", "tool_type": "function", "description": "Calculate the Euclidean distance between two points (x1, y1) and (x2, y2).", "docstring": "Calculate the Euclidean distance between two points (x1, y1) and (x2, y2).\n    \n    Parameters:\n        x1, y1, x2, y2 (float): Coordinates of the two points.\n        \n    Returns:\n        float: The distance between the two points.", "Freq": 0, "TSR": 0}, {"tool": "def area_of_circle(r):\n    \n    return np.pi * r**2", "subfield": "Coordinate Geometry", "tool_name": "area_of_circle", "tool_type": "function", "description": "Calculates the area of a circle given its radius.", "docstring": "Calculates the area of a circle given its radius.\n    Parameters:\n    r (float): The radius of the circle.\n    Returns:\n    float: The area of the circle.\n    Examples:\n    >>> area_of_circle(1)\n    3.141592653589793", "Freq": 2, "TSR": 2}, {"tool": "def is_collinear(points):\n    \n    if len(points) < 3:\n        return True  # Two points are always collinear\n    x1, y1 = points[0]\n    x2, y2 = points[1]\n    for (x, y) in points[2:]:\n        if (x2 - x1) * (y - y1) != (y2 - y1) * (x - x1):\n            return False\n    return True", "subfield": "Coordinate Geometry", "tool_name": "is_collinear", "tool_type": "function", "description": "Check if all points given are collinear.", "docstring": "Check if all points given are collinear.\n    \n    Parameters:\n    - points (list of tuples): List of points (x, y) to be checked.\n    \n    Returns:\n    - bool: True if all points are collinear, False otherwise.\n    Example:\n    >>> is_collinear([(1, 2), (2, 4), (3, 6)])\n    True", "Freq": 1, "TSR": 0}, {"tool": "def transform_coordinates(points, transformation_matrix):\n    \n    transformed = np.dot(transformation_matrix, np.array(points).T).T\n    return [tuple(point) for point in transformed]", "subfield": "Coordinate Geometry", "tool_name": "transform_coordinates", "tool_type": "function", "description": "Applies a transformation matrix to a list of point coordinates in 2D.", "docstring": "Applies a transformation matrix to a list of point coordinates in 2D.\n    Parameters:\n    - points: List of tuples representing the point coordinates.\n    - transformation_matrix: A 2x2 numpy array representing the transformation matrix.\n    Returns:\n    - List of tuples: New coordinates after transformation.\n    Example:\n    >>> transform_coordinates([(1, 2)], np.array([[2, 0], [0, 2]]))\n    [(2, 4)]", "Freq": 0, "TSR": 0}, {"tool": "def scalar_multiply(vector, scalar):\n    \n    return np.multiply(vector, scalar)", "subfield": "Coordinate Geometry", "tool_name": "scalar_multiply", "tool_type": "function", "description": "Multiplies a vector by a scalar.", "docstring": "Multiplies a vector by a scalar.\n    Parameters:\n    vector (ndarray): A numpy array representing the vector.\n    scalar (float): The scalar value to multiply with the vector.\n    Returns:\n    ndarray: The scaled vector.", "Freq": 0, "TSR": 0}, {"tool": "def get_line_equation(p1, p2):\n    \n    x1, y1 = p1\n    x2, y2 = p2\n    A = y2 - y1\n    B = x1 - x2\n    C = x2 * y1 - x1 * y2\n    return (A, B, C)", "subfield": "Coordinate Geometry", "tool_name": "get_line_equation", "tool_type": "function", "description": "Calculate the coefficients (A, B, C) of the line equation Ax + By + C = 0 passing through two points.", "docstring": "Calculate the coefficients (A, B, C) of the line equation Ax + By + C = 0 passing through two points.\n    Parameters:\n    - p1 (tuple): coordinates of the first point.\n    - p2 (tuple): coordinates of the second point.\n    Returns:\n    - tuple: coefficients (A, B, C) of the line.\n    Examples:\n    >>> get_line_equation((1, 2), (3, 4))\n    (2, -2, 0)", "Freq": 3, "TSR": 1}, {"tool": "class Point:\n    \"\"\"\n    This class represents a Point in 2D geometry.\n    \n    Attributes:\n        x (float): x-coordinate of the Point.\n        y (float): y-coordinate of the Point.\n    \"\"\"\n    \n    def __init__(self, x=0.0, y=0.0):\n        \"\"\"\n        The constructor for the Point class. It initializes the x and y coordinates of the point.\n        \n        Parameters:\n            x (float): The x-coordinate of the point.\n            y (float): The y-coordinate of the point.\n        \"\"\"\n        self.x = x\n        self.y = y\n    def __str__(self):\n        \"\"\"\n        This method returns the string representation of the Point.\n        \n        Returns:\n            str: A string in the format '(x, y)'.\n        \"\"\"\n        return '(' + str(self.x) + ', ' + str(self.y) + ')'\n    \n    def distance(self, other):\n        \"\"\"\n        This method calculates the Euclidean distance between this Point and another Point.\n        \n        Parameters:\n            other (Point): The other Point.\n            \n        Returns:\n            float: The Euclidean distance between the two points.\n        \"\"\"\n        return np.sqrt((self.x - other.x)**2 + (self.y - other.y)**2)", "subfield": "Coordinate Geometry", "tool_name": "Point:\n    \"\"\"\n    This class represents a Point in 2D geometry.\n    \n    Attributes:\n        x", "tool_type": "class", "description": "This class represents a Point in 2D geometry.\n    \n    Attributes:\n        x (float): x-coordinate of the Point.\n        y (float): y-coordinate of the Point.", "docstring": "This class represents a Point in 2D geometry.\n    \n    Attributes:\n        x (float): x-coordinate of the Point.\n        y (float): y-coordinate of the Point.", "Freq": 0, "TSR": 0}, {"tool": "def complete_square(expression, variable):\n    \n    a = expression.coeff(variable**2)\n    b = expression.coeff(variable)\n    completed_square = a * (variable + b/(2*a))**2 - (b**2)/(4*a)\n    return completed_square", "subfield": "Coordinate Geometry", "tool_name": "complete_square", "tool_type": "function", "description": "Complete the square for the given variable in a SymPy expression.", "docstring": "Complete the square for the given variable in a SymPy expression.", "Freq": 0, "TSR": 0}, {"tool": "def distance_point_plane(point, plane_coefficients):\n    \n    A, B, C, D = plane_coefficients\n    x, y, z = point\n    num = abs(A*x + B*y + C*z + D)\n    den = np.sqrt(A**2 + B**2 + C**2)\n    return num / den", "subfield": "Coordinate Geometry", "tool_name": "distance_point_plane", "tool_type": "function", "description": "Calculate the shortest distance from a point to a plane in 3D.", "docstring": "Calculate the shortest distance from a point to a plane in 3D.\n    \n    Parameters:\n    - point (array-like): The coordinates of the point.\n    - plane_coefficients (tuple): The coefficients (A, B, C, D) of the plane Ax + By + Cz + D = 0.\n    \n    Returns:\n    - float: The shortest distance from the point to the plane.\n    \n    Example:\n    >>> distance_point_plane([1, 2, 2], (1, 0, 0, -2))\n    1.0", "Freq": 2, "TSR": 0}, {"tool": "def distance_constraints_2d(points, distance):\n    \n    x, y = symbols('x y', real=True)\n    generated_eqs = []\n    for p1, p2 in zip(points, points[1:] + [points[0]]):\n        eq = Eq((x - p1[0]) ** 2 + (y - p1[1]) ** 2, distance ** 2)\n        generated_eqs.append(eq)\n    return generated_eqs", "subfield": "Coordinate Geometry", "tool_name": "distance_constraints_2d", "tool_type": "function", "description": "Formulate and solve a system of equations given distance constraints between multiple points in 2D.", "docstring": "Formulate and solve a system of equations given distance constraints between multiple points in 2D.\n    Parameters:\n    - points (list): List of tuples/lists where each tuple/list contains the (x, y) coordinates.\n    - distance (float): The distance that each pair of points should satisfy.\n    Returns:\n    - list: A list of sympy Eq objects expressing the distance constraints.\n    Examples:", "Freq": 0, "TSR": 0}, {"tool": "def solve_linear_system(coeff_matrix, const_vector):\n    \n    coeff_matrix = np.array(coeff_matrix)\n    const_vector = np.array(const_vector)\n    return np.linalg.solve(coeff_matrix, const_vector)", "subfield": "Coordinate Geometry", "tool_name": "solve_linear_system", "tool_type": "function", "description": "Solves a linear system of equations defined by a matrix of coefficients and a constant vector.", "docstring": "Solves a linear system of equations defined by a matrix of coefficients and a constant vector.\n    Parameters:\n    - coeff_matrix (list[list[float]]): Coefficient matrix where each row represents the coefficients of a linear equation.\n    - const_vector (list[float]): Constant terms for each equation.\n    Returns:\n    - ndarray: Solution to the system of equations.\n    Examples:\n    >>> solve_linear_system([[1, 1], [1, -1]], [5, 1])\n    array([3., 2.])", "Freq": 1, "TSR": 0}, {"tool": "def find_perpendicular_slope(slope):\n    \n    return -1 / slope", "subfield": "Coordinate Geometry", "tool_name": "find_perpendicular_slope", "tool_type": "function", "description": "Calculates the slope of a line perpendicular to a given slope.", "docstring": "Calculates the slope of a line perpendicular to a given slope.\n    \n    Parameters\n    ----------\n    slope : float\n        Slope of the given line.\n    \n    Returns\n    -------\n    float\n        Slope of the perpendicular line.\n    \n    Examples\n    --------\n    >>> find_perpendicular_slope(2)\n    -0.5", "Freq": 2, "TSR": 1}, {"tool": "class GeometryUtils:\n    \"\"\"\n    This class provides a set of utility functions for solving geometry problems.\n    \"\"\"\n    \n    def __init__(self):\n        pass\n    \n    def line_equation_from_two_points(self, point1, point2):\n        \"\"\"\n        This function calculates the equation of a line passing through two given points.\n        \n        Parameters:\n            point1 (tuple): The coordinates of the first point (x1, y1).\n            point2 (tuple): The coordinates of the second point (x2, y2).\n            \n        Returns:\n            tuple: The slope and y-intercept of the line in the form (m, c).\n        \"\"\"\n        x1, y1 = point1\n        x2, y2 = point2\n        slope = (y2 - y1) / (x2 - x1)\n        intercept = y1 - slope * x1\n        return slope, intercept\n    \n    def solve_linear_equations(self, coeff_matrix, const_vector):\n        \"\"\"\n        This function solves a system of linear equations defined by a matrix of coefficients and a constant vector.\n        \n        Parameters:\n            coeff_matrix (list): A list of lists representing the matrix of coefficients.\n            const_vector (list): A list representing the constant vector.\n            \n        Returns:\n            list: A list of solutions to the system of linear equations.\n        \"\"\"\n        coeff_matrix = np.array(coeff_matrix)\n        const_vector = np.array(const_vector)\n        solutions = np.linalg.solve(coeff_matrix, const_vector)\n        return solutions\n    \n    def distance_between_points(self, point1, point2):\n        \"\"\"\n        This function calculates the Euclidean distance between two points in a 2D coordinate system.\n        \n        Parameters:\n            point1 (tuple): The coordinates of the first point (x1, y1).\n            point2 (tuple): The coordinates of the second point (x2, y2).\n            \n        Returns:\n            float: The Euclidean distance between the two points.\n        \"\"\"\n        x1, y1 = point1\n        x2, y2 = point2\n        distance = np.sqrt((x2 - x1)**2 + (y2 - y1)**2)\n        return distance\n    \n    def line_intersection(self, line1, line2):\n        \"\"\"\n        This function calculates the intersection point of two lines in a 2D coordinate system.\n        \n        Parameters:\n            line1 (tuple): The equation of the first line in the form (m1, c1).\n            line2 (tuple): The equation of the second line in the form (m2, c2).\n            \n        Returns:\n            tuple: The coordinates of the intersection point (x, y).\n        \"\"\"\n        m1, c1 = line1\n        m2, c2 = line2\n        x = (c2 - c1) / (m1 - m2)\n        y = m1 * x + c1\n        return x, y", "subfield": "Coordinate Geometry", "tool_name": "GeometryUtils:\n    \"\"\"\n    This class provides a set of utility functions for solving geometry problems.\n    \"\"\"\n    \n    def __init__", "tool_type": "class", "description": "This class provides a set of utility functions for solving geometry problems.", "docstring": "This class provides a set of utility functions for solving geometry problems.", "Freq": 0, "TSR": 0}], "Rectangles": [{"tool": "def rectangle_area(length, width):\n    \n    return length * width", "subfield": "Rectangles", "tool_name": "rectangle_area", "tool_type": "function", "description": "Calculate the area of a rectangle.", "docstring": "Calculate the area of a rectangle.\n    Parameters:\n    length (float): the length of the rectangle.\n    width (float): the width of the rectangle.\n    Returns:\n    float: the calculated area of the rectangle.\n    \n    Example:\n    >>> rectangle_area(5, 3)\n    15", "Freq": 2, "TSR": 1}, {"tool": "def rectangle_diagonal(length, width):\n    \n    return math.sqrt(length**2 + width**2)", "subfield": "Rectangles", "tool_name": "rectangle_diagonal", "tool_type": "function", "description": "Calculates the length of the diagonal of a rectangle using Pythagoras' theorem.", "docstring": "Calculates the length of the diagonal of a rectangle using Pythagoras' theorem.\n    \n    Parameters:\n        length (float): The length of the rectangle.\n        width (float): The width of the rectangle.\n        \n    Returns:\n        float: The length of the diagonal.\n        \n    Examples:\n    >>> rectangle_diagonal(5, 4)\n    6.4031242374328485", "Freq": 2, "TSR": 0}, {"tool": "def calculate_square_perimeter(side_length):\n    \n    return 4 * side_length", "subfield": "Rectangles", "tool_name": "calculate_square_perimeter", "tool_type": "function", "description": "Calculate the perimeter of a square given the side length.", "docstring": "Calculate the perimeter of a square given the side length.\n    \n    Parameters:\n    side_length (float): The length of a side of the square.\n    \n    Returns:\n    float: The perimeter of the square.", "Freq": 3, "TSR": 2, "experience_pool": "- Experience 1:\n    - Problem: The area of a square plot of land is 325 square meters. What is the perimeter of the square, in meters? Express your answer in simplest radical form.\n    - Solution: \n        ```python\n        import math\n\n        def solution():\n            \"\"\"The area of a square plot of land is 325 square meters. What is the perimeter of the square, in meters?\"\"\"\n            area = 325\n            side_length = math.sqrt(area)\n            perimeter = calculate_square_perimeter(side_length)\n            return perimeter\n\n        # Calculate the perimeter of the square\n        print(solution())\n        ```\n    - Output: 72.11102550927978\n    - Feedback: The tool accurately calculates the perimeter of the square."}, {"tool": "def solve_rectangle_dimensions(perimeter, area=None, aspect_ratio=None, use_integers=False):\n    \n    import sympy\n    \n    length, width = sympy.symbols('length width')\n    eq1 = sympy.Eq(2 * (length + width), perimeter)\n    \n    solutions = []\n    \n    if area is not None:\n        eq2 = sympy.Eq(length * width, area)\n        sol = sympy.solve((eq1, eq2), (length, width))\n        solutions.extend(sol)\n    \n    if aspect_ratio is not None:\n        eq2 = sympy.Eq(length / width, aspect_ratio)\n        sol = sympy.solve((eq1, eq2), (length, width))\n        solutions.extend(sol)\n    \n    if not solutions:\n        solutions = sympy.solve(eq1, (length, width))\n    \n    # Filter for integer solutions if requested\n    if use_integers:\n        solutions = [(l, w) for l, w in solutions if l.is_integer and w.is_integer]\n    return solutions", "subfield": "Rectangles", "tool_name": "solve_rectangle_dimensions", "tool_type": "function", "description": "Solves for dimensions of a rectangle given constraints like perimeter, area or aspect ratio.", "docstring": "Solves for dimensions of a rectangle given constraints like perimeter, area or aspect ratio.\n    Parameters:\n    perimeter (float): The perimeter of the rectangle.\n    area (float, optional): The area of the rectangle.\n    aspect_ratio (float, optional): The ratio of length to width.\n    use_integers (bool, optional): If True, returns integer dimensions. Default is False.\n    Returns:\n    list of tuples: Possible (length, width) combinations.\n    \n    Examples:\n    >>> solve_rectangle_dimensions(20, area=24)\n    [(6, 4), (4, 6)]\n    >>> solve_rectangle_dimensions(20, aspect_ratio=1.5)\n    [(7.5, 5), (5, 7.5)]", "Freq": 15, "TSR": 4}, {"tool": "def calculate_shaded_area(length, width, shaded_length, shaded_width):\n    \n    rectangle_area = length * width\n    shaded_area = shaded_length * shaded_width\n    return rectangle_area - shaded_area", "subfield": "Rectangles", "tool_name": "calculate_shaded_area", "tool_type": "function", "description": "Calculate the area of a shaded region in a rectangle.\n    \n    Args:\n    length (float): The length of the rectangle.\n    width (float): The width of the rectangle.\n    shaded_length (float): The length of the shaded region.\n    shaded_width (float): The width of the shaded region.\n    \n    Returns:\n    float: The area of the shaded region.", "docstring": "Calculate the area of a shaded region in a rectangle.\n    \n    Args:\n    length (float): The length of the rectangle.\n    width (float): The width of the rectangle.\n    shaded_length (float): The length of the shaded region.\n    shaded_width (float): The width of the shaded region.\n    \n    Returns:\n    float: The area of the shaded region.", "Freq": 1, "TSR": 0}], "Midpoint Formula": [{"tool": "def compute_midpoint(point1, point2):\n    \n    # Ensure input is in the correct format and same dimension\n    if len(point1) != len(point2):\n        raise ValueError(\"Both points must have the same number of dimensions\")\n    # Calculate midpoint using tuple/list comprehension\n    midpoint = tuple((p1 + p2) / 2 for p1, p2 in zip(point1, point2))\n    \n    return midpoint", "subfield": "Midpoint Formula", "tool_name": "compute_midpoint", "tool_type": "function", "description": "Compute the midpoint between two points in n-dimensional space.", "docstring": "Compute the midpoint between two points in n-dimensional space.\n    Parameters:\n    point1 (tuple or list): Coordinates of the first point.\n    point2 (tuple or list): Coordinates of the second point.\n    Returns:\n    tuple: Coordinates of the midpoint.\n    Examples:\n    >>> compute_midpoint((1, 2), (3, 4))\n    (2.0, 3.0)\n    >>> compute_midpoint([0, 0, 0], [6, 8, 10])\n    (3.0, 4.0, 5.0)\n    Raises:\n    ValueError: If the dimensions of the two points are not equal.", "Freq": 28, "TSR": 27, "experience_pool": "- To calculate the value of b using the midpoint and one of the endpoints, you can directly access the coordinates of the midpoint tuple and add them together. There is no need to use the non-existent function find_endpoint_from_midpoint.\n\nExample:\nmidpoint = compute_midpoint((1, 3), (5, 7))\nb = midpoint[0] + midpoint[1]"}, {"tool": "def find_endpoint_from_midpoint(midpoint, known_point):\n    \n    import numpy as np\n    midpoint, known_point = np.array(midpoint), np.array(known_point)\n    unknown_point = 2 * midpoint - known_point\n    return unknown_point.tolist()", "subfield": "Midpoint Formula", "tool_name": "find_endpoint_from_midpoint", "tool_type": "function", "description": "Calculate the unknown endpoint of a line segment given the midpoint and the known endpoint.", "docstring": "Calculate the unknown endpoint of a line segment given the midpoint and the known endpoint.\n    Parameters:\n        midpoint (list or tuple of floats): Coordinates of the midpoint.\n        known_point (list or tuple of floats): Coordinates of the known endpoint.\n    Returns:\n        list: The coordinates of the unknown endpoint as a list of floats.\n    \n    Examples:\n        >>> find_endpoint_from_midpoint([1.0, 1.0], [0, 0])\n        [2.0, 2.0]\n        >>> find_endpoint_from_midpoint([4.0, 7.0, 9.0], [1, 3, 5])\n        [7.0, 11.0, 13.0]", "Freq": 10, "TSR": 8, "experience_pool": "- Problem: The graph of the line $x+y=b$ is a perpendicular bisector of the line segment from $(1,3)$ to $(5,7)$. What is the value of b?\n  - Answer: 8\n  - Solution:\n    ```python\n    def solution():\n        # Calculate the midpoint of the line segment\n        midpoint = compute_midpoint((1, 3), (5, 7))\n        \n        # Find the value of b using the midpoint and one of the endpoints\n        b = find_endpoint_from_midpoint(midpoint, [1, 3])[0] + find_endpoint_from_midpoint(midpoint, [1, 3])[1]\n        \n        return b\n\n    # Calculate the value of b\n    print(solution())\n    ```\n  - Output: 12.0\n\n- Problem: Let $\\mathbf{a}$ and $\\mathbf{b}$ be vectors, and let $\\mathbf{m}$ be the midpoint of $\\mathbf{a}$ and $\\mathbf{b}.$  Given $\\mathbf{m} = \\begin{pmatrix} 3 \\\\ 7 \\end{pmatrix}$ and $\\mathbf{a} \\cdot \\mathbf{b} = 6,$ find $\\|\\mathbf{a}\\|^2 + \\|\\mathbf{b}\\|^2.$\n  - Answer: 220\n  - Solution:\n    ```python\n    def solution():\n        # Given values\n        m = [3, 7]\n        ab_dot = 6\n        \n        # Calculate the known endpoint\n        a_plus_b = find_endpoint_from_midpoint(m, m)\n        \n        # Calculate the norm squared of a + b\n        norm_squared_a_plus_b = sum([x**2 for x in a_plus_b])\n        \n        # Calculate the norm squared of a + norm squared of b\n        norm_squared_a_plus_norm_squared_b = norm_squared_a_plus_b - 2 * ab_dot\n        \n        return norm_squared_a_plus_norm_squared_b\n\n    # Calculate the result\n    print(solution())\n    ```\n  - Output: 46\n\n- Problem: Let $\\mathbf{a}$ and $\\mathbf{b}$ be vectors, and let $\\mathbf{m}$ be the midpoint of $\\mathbf{a}$ and $\\mathbf{b}.$  Given $\\mathbf{m} = \\begin{pmatrix} 3 \\\\ 7 \\end{pmatrix}$ and $\\mathbf{a} \\cdot \\mathbf{b} = 6,$ find $\\|\\mathbf{a}\\|^2 + \\|\\mathbf{b}\\|^2.$\n  - Answer: 220\n  - Solution:\n    ```python\n    def solution():\n        # Given values\n        m = [3, 7]\n        ab_dot = 6\n        \n        # Calculate the known endpoint\n        a = find_endpoint_from_midpoint(m, [1, 3])\n        b = find_endpoint_from_midpoint(m, [5, 7])\n        \n        # Calculate the norm squared of a + norm squared of b\n        norm_squared_a_plus_norm_squared_b = sum([x**2 for x in a]) + sum([x**2 for x in b])\n        \n        return norm_squared_a_plus_norm_squared_b\n\n    # Calculate the result\n    print(solution())\n    ```\n  - Output: 196"}, {"tool": "def find_vector_sum(midpoint, proportion):\n    \n    import numpy as np\n    \n    # Convert midpoint to numpy array\n    midpoint = np.array(midpoint)\n    \n    # Compute the difference vector between the midpoint and one of the vectors\n    difference_vector = proportion * (midpoint - np.zeros_like(midpoint))\n    \n    # Compute the sum of the vectors\n    sum_vectors = midpoint + difference_vector\n    \n    return sum_vectors.tolist()", "subfield": "Midpoint Formula", "tool_name": "find_vector_sum", "tool_type": "function", "description": "Find the sum of vectors when the midpoint and proportion are known.", "docstring": "Find the sum of vectors when the midpoint and proportion are known.\n    Parameters:\n    midpoint (tuple/list): The coordinates of the midpoint of the vectors.\n    proportion (float): The proportion of the distance from the midpoint to one of the vectors.\n    Returns:\n    sum_vectors (tuple/list): The sum of the vectors.", "Freq": 1, "TSR": 1}], "Distance Formula": [{"tool": "def distance_formula_symbolic(point1, point2):\n    \n    if len(point1) != len(point2):\n        raise ValueError(\"Points must have the same dimensions\")\n    distance_expr = sqrt(sum((p1 - p2)**2 for p1, p2 in zip(point1, point2)))\n    return simplify(distance_expr)", "subfield": "Distance Formula", "tool_name": "distance_formula_symbolic", "tool_type": "function", "description": "Construct a symbolic distance formula between two points, supporting symbolic and numerical computation.", "docstring": "Construct a symbolic distance formula between two points, supporting symbolic and numerical computation.\n    Parameters:\n    - point1: array-like, the coordinates of the first point, can contain symbols or numbers\n    - point2: array-like, the coordinates of the second point, can contain symbols or numbers\n    Returns:\n    - distance_expr: sympy expression, the symbolic expression for the distance between point1 and point2\n    Examples:\n    - Using numerical coordinates:\n    >>> distance_formula_symbolic((1, 2), (4, 6))\n    sqrt(13)\n    \n    - Using symbolic coordinates:\n    >>> x, y = symbols('x y')\n    >>> distance_formula_symbolic((x, 0), (0, y))\n    sqrt(x**2 + y**2)", "Freq": 82, "TSR": 54, "experience_pool": "- To use the solve function, you need to import it from sympy: `from sympy import solve`\n- To use the pi constant, you need to import it from sympy: `from sympy import pi`\n- To use the Eq function, you need to import it from sympy: `from sympy import Eq`\n- To use the symbols function, you need to import it from sympy: `from sympy import symbols`"}, {"tool": "def pythagorean_theorem(leg_a=None, leg_b=None, hypotenuse=None):\n    \n    if hypotenuse is None and leg_a is not None and leg_b is not None:\n        return math.sqrt(leg_a**2 + leg_b**2)\n    elif leg_a is None and hypotenuse is not None and leg_b is not None:\n        return math.sqrt(hypotenuse**2 - leg_b**2)\n    elif leg_b is None and hypotenuse is not None and leg_a is not None:\n        return math.sqrt(hypotenuse**2 - leg_a**2)\n    elif leg_a is not None and leg_b is not None and hypotenuse is None:\n        return math.sqrt(leg_a**2 + leg_b**2)\n    else:\n        raise ValueError(\"Invalid input: provide exactly one missing side.\")", "subfield": "Distance Formula", "tool_name": "pythagorean_theorem", "tool_type": "function", "description": "Calculate the missing side of a right triangle using the Pythagorean theorem.", "docstring": "Calculate the missing side of a right triangle using the Pythagorean theorem.\n    Parameters:\n    -----------\n    leg_a : float, optional\n        The length of one leg of the triangle.\n    leg_b : float, optional\n        The length of the other leg of the triangle.\n    hypotenuse : float, optional\n        The length of the hypotenuse of the triangle.\n    \n    Returns:\n    --------\n    float\n        The length of the missing side of the triangle.\n    \n    Examples:\n    ---------\n    >>> pythagorean_theorem(leg_a=3, leg_b=4)\n    5.0\n    >>> pythagorean_theorem(hypotenuse=5, leg_b=4)\n    3.0\n    \n    Raises:\n    -------\n    ValueError\n        If insufficient data is provided or too many sides are known.", "Freq": 6.0, "TSR": 3.0, "experience_pool": "Experience 1:\nProblem: Adam and Simon start on bicycle trips from the same point at the same time. Adam travels east at 8mph and Simon travels south at 6mph. After how many hours are they 60 miles apart?\nAnswer: 6\n\nExperience 2:\nProblem: In convex quadrilateral $ABCD$, $AB=BC=13$, $CD=DA=24$, and $\\angle D=60^\\circ$.  Points $X$ and $Y$ are the midpoints of $\\overline{BC}$ and $\\overline{DA}$ respectively.  Compute $XY^2$ (the square of the length of $XY$).\nAnswer: \\frac{1033}{4}+30\\sqrt{3}\n\nExperience 3:\nProblem: A circle of radius $2$ has center at $(2,0)$. A circle of radius $1$ has center at $(5,0)$.  A line is tangent to the two circles at points in the first quadrant.  What is the $y$-intercept of the line?\nAnswer: 2\\sqrt{2}\n\nExperience 4:\nProblem: What is the $x$-coordinate of the point on the $x$-axis that is equidistant from points $A( -2, 0)$ and $B(0,4)$?\nAnswer: 3"}, {"tool": "def calculate_median_length(side_a, side_b):\n    \n    hypotenuse = math.sqrt(side_a**2 + side_b**2)\n    return hypotenuse / 2", "subfield": "Distance Formula", "tool_name": "calculate_median_length", "tool_type": "function", "description": "Calculate the length of the median to the hypotenuse of a right triangle, based on the other two sides.\n    The median on the hypotenuse divides it into two equal segments, each half the length of the hypotenuse.", "docstring": "Calculate the length of the median to the hypotenuse of a right triangle, based on the other two sides.\n    The median on the hypotenuse divides it into two equal segments, each half the length of the hypotenuse.\n    \n    Parameters:\n    - side_a (float): Length of one side of the right triangle.\n    - side_b (float): Length of the other side of the right triangle.\n    \n    Returns:\n    - float: The length of the median to the hypotenuse.\n    \n    Example:\n    >>> calculate_median_length(3, 4)\n    2.5", "Freq": 1, "TSR": 1}, {"tool": "def distance_formula_3D(point1, point2):\n    \n    x1, y1, z1 = point1\n    x2, y2, z2 = point2\n    distance = sqrt((x2 - x1)**2 + (y2 - y1)**2 + (z2 - z1)**2)\n    return distance", "subfield": "Distance Formula", "tool_name": "distance_formula_3D", "tool_type": "function", "description": "Calculate the distance between two points in three-dimensional space using the distance formula.\n    Args:\n        point1 (tuple): The coordinates of the first point (x1, y1, z1).\n        point2 (tuple): The coordinates of the second point (x2, y2, z2).\n    Returns:\n        float: The distance between the two points.", "docstring": "Calculate the distance between two points in three-dimensional space using the distance formula.\n    Args:\n        point1 (tuple): The coordinates of the first point (x1, y1, z1).\n        point2 (tuple): The coordinates of the second point (x2, y2, z2).\n    Returns:\n        float: The distance between the two points.", "Freq": 13, "TSR": 11, "experience_pool": "- Experience: Calculating the distance between two points in three-dimensional space.\n  - Problem: In coordinate space, a particle starts at the point $(2,3,4)$ and ends at the point $(-1,-3,-3),$ along the line connecting the two points. Along the way, the particle intersects the unit sphere centered at the origin at two points. Then the distance between these two points can be expressed in the form $\\frac{a}{\\sqrt{b}},$ where $a$ and $b$ are positive integers, and $b$ is not divisible by the square of a prime. Find $a + b.$\n  - Solution: The distance between the two points can be calculated using the distance_formula_3D function.\n    ```python\n    def solution():\n        point1 = (2, 3, 4)\n        point2 = (-1, -3, -3)\n        \n        distance = distance_formula_3D(point1, point2)\n        \n        result = distance\n        return result\n    \n    print(solution())\n    ```\n  - Output: 12*sqrt(47)/47"}, {"tool": "def solve_for_x(a, b, c, d, point):\n    \n    x0, y0, z0 = point\n    x = (d - b*y0 - c*z0) / a\n    return x", "subfield": "Distance Formula", "tool_name": "solve_for_x", "tool_type": "function", "description": "Solve for x in the equation ax + by + cz = d, given the coefficients and a point.\n    Args:\n        a (float): The coefficient of x.\n        b (float): The coefficient of y.\n        c (float): The coefficient of z.\n        d (float): The constant term.\n        point (tuple): The coordinates of the given point (x0, y0, z0).\n    Returns:\n        float: The value of x.", "docstring": "Solve for x in the equation ax + by + cz = d, given the coefficients and a point.\n    Args:\n        a (float): The coefficient of x.\n        b (float): The coefficient of y.\n        c (float): The coefficient of z.\n        d (float): The constant term.\n        point (tuple): The coordinates of the given point (x0, y0, z0).\n    Returns:\n        float: The value of x.", "Freq": 0, "TSR": 0}, {"tool": "def solve_for_y(a, b, c, d, point):\n    \n    x0, y0, z0 = point\n    y = (d - a*x0 - c*z0) / b\n    return y", "subfield": "Distance Formula", "tool_name": "solve_for_y", "tool_type": "function", "description": "Solve for y in the equation ax + by + cz = d, given the coefficients and a point.\n    Args:\n        a (float): The coefficient of x.\n        b (float): The coefficient of y.\n        c (float): The coefficient of z.\n        d (float): The constant term.\n        point (tuple): The coordinates of the given point (x0, y0, z0).\n    Returns:\n        float: The value of y.", "docstring": "Solve for y in the equation ax + by + cz = d, given the coefficients and a point.\n    Args:\n        a (float): The coefficient of x.\n        b (float): The coefficient of y.\n        c (float): The coefficient of z.\n        d (float): The constant term.\n        point (tuple): The coordinates of the given point (x0, y0, z0).\n    Returns:\n        float: The value of y.", "Freq": 0, "TSR": 0}, {"tool": "def solve_for_z(a, b, c, d, point):\n    \n    x0, y0, z0 = point\n    z = (d - a*x0 - b*y0) / c\n    return z", "subfield": "Distance Formula", "tool_name": "solve_for_z", "tool_type": "function", "description": "Solve for z in the equation ax + by + cz = d, given the coefficients and a point.\n    Args:\n        a (float): The coefficient of x.\n        b (float): The coefficient of y.\n        c (float): The coefficient of z.\n        d (float): The constant term.\n        point (tuple): The coordinates of the given point (x0, y0, z0).\n    Returns:\n        float: The value of z.", "docstring": "Solve for z in the equation ax + by + cz = d, given the coefficients and a point.\n    Args:\n        a (float): The coefficient of x.\n        b (float): The coefficient of y.\n        c (float): The coefficient of z.\n        d (float): The constant term.\n        point (tuple): The coordinates of the given point (x0, y0, z0).\n    Returns:\n        float: The value of z.", "Freq": 0, "TSR": 0}], "Area Calculation": [{"tool": "def area_triangle(base, height):\n    \n    return 0.5 * base * height", "subfield": "Area Calculation", "tool_name": "area_triangle", "tool_type": "function", "description": "Calculate area of a triangle given its base and height.", "docstring": "Calculate area of a triangle given its base and height.\n    Parameters:\n    base (float): the length of the base of the triangle.\n    height (float): the height of the triangle perpendicular to the base.\n    Returns:\n    float: the area of the triangle", "Freq": 16, "TSR": 1, "experience_pool": "1. Make sure to provide the correct base and height values when using the tool for calculating the area of a triangle.\n2. Pay attention to the specific requirements of each problem and ensure that the input parameters match those requirements.\n3. Double-check the calculations involving triangles to avoid errors in the final result.\n4. Low success rates may be due to the complexity of the problem, not tool usage errors. Verify the input parameters and calculations thoroughly."}, {"tool": "def area_circle(radius):\n    \n    import math\n    return math.pi * radius ** 2", "subfield": "Area Calculation", "tool_name": "area_circle", "tool_type": "function", "description": "Calculate the area of a circle given its radius.", "docstring": "Calculate the area of a circle given its radius.\n    Parameters:\n    radius (float): the radius of the circle.\n    Returns:\n    float: the area of the circle calculated as pi*r^2", "Freq": 17, "TSR": 3, "experience_pool": "- Make sure to call the correct function `area_circle` instead of `area_square` when calculating the area of a circle.\n- Ensure that the correct parameters are passed to the function when calculating the area of a circle."}, {"tool": "def rectangle_area(length, width):\n    \n    return length * width", "subfield": "Area Calculation", "tool_name": "rectangle_area", "tool_type": "function", "description": "Calculate the area of a rectangle from length and width.", "docstring": "Calculate the area of a rectangle from length and width.\n    Parameters:\n    length (float): The length of the rectangle.\n    width (float): The width of the rectangle.\n    Returns:\n    float: The area of the rectangle.\n    \n    Examples:\n    >>> rectangle_area(4, 3)\n    12", "Freq": 22, "TSR": 16, "experience_pool": "- The tool `rectangle_area` is used to calculate the area of a rectangle from its length and width, and it is functioning correctly.\n- Ensure to provide the correct length and width values when calling the `rectangle_area` function to get the accurate area of the rectangle."}, {"tool": "def triangle_area_by_sides(a, b, c):\n    \n    s = (a + b + c) / 2\n    area = sqrt(s * (s - a) * (s - b) * (s - c))\n    return area", "subfield": "Area Calculation", "tool_name": "triangle_area_by_sides", "tool_type": "function", "description": "Calculate the area of a triangle given the lengths of its sides using Heron's formula.", "docstring": "Calculate the area of a triangle given the lengths of its sides using Heron's formula.\n    Parameters:\n    - a, b, c (float): Lengths of the sides of the triangle.\n    Returns:\n    - float: The area of the triangle.\n    Examples:\n    >>> triangle_area_by_sides(3, 4, 5)\n    6.0", "Freq": 4, "TSR": 3, "experience_pool": "- Always ensure that the input parameters for the `triangle_area_by_sides` function are the lengths of the sides of the triangle.\n- Make sure to correctly calculate the lengths of the medians or other geometric properties based on the triangle sides before using the `triangle_area_by_sides` function."}, {"tool": "def area_sector(radius, angle_deg):\n    \n    angle_rad = math.radians(angle_deg)\n    return 0.5 * radius**2 * angle_rad", "subfield": "Area Calculation", "tool_name": "area_sector", "tool_type": "function", "description": "Calculate the area of a sector of a circle given its radius and central angle in degrees.", "docstring": "Calculate the area of a sector of a circle given its radius and central angle in degrees.\n    Parameters:\n    - radius (float): The radius of the circle.\n    - angle_deg (float): The angle of the sector in degrees.\n    \n    Returns:\n    - float: The area of the sector.\n    \n    Example:\n    >>> area_sector(4, 90)\n    12.566370614359172", "Freq": 4, "TSR": 0, "experience_pool": "- Make sure to correctly calculate the area of figures or shapes using the area_sector function.\n- Double-check the angle values and radius when calling the area_sector function to ensure accurate results.\n- Verify the calculations and logic in the calling code to avoid errors in determining the area of complex shapes."}, {"tool": "def area_polygon(vertices):\n    \n    x = np.array([vertex[0] for vertex in vertices])\n    y = np.array([vertex[1] for vertex in vertices])\n    return 0.5 * np.abs(np.dot(x, np.roll(y, 1)) - np.dot(y, np.roll(x, 1)))", "subfield": "Area Calculation", "tool_name": "area_polygon", "tool_type": "function", "description": "Calculate the area of a simple polygon given its vertices.", "docstring": "Calculate the area of a simple polygon given its vertices.\n    Parameters:\n        vertices (list of tuples): List of (x, y) tuples, each representing a vertex of the polygon.\n    Returns:\n        float: The area of the polygon.\n    Examples:\n    >>> area_polygon([(0, 0), (4, 0), (4, 4), (0, 4)])  # Square with side 4\n    16.0", "Freq": 6, "TSR": 0, "experience_pool": "Tool for calculating the area of a polygon is accurate and functional. Issues with tool usage are mainly due to incorrect input parameters in the calling code."}, {"tool": "def area_square(side_length):\n    \n    return side_length ** 2", "subfield": "Area Calculation", "tool_name": "area_square", "tool_type": "function", "description": "Calculates the area of a square.", "docstring": "Calculates the area of a square.\n    Parameters:\n        side_length (float): The length of the side of the square.\n    Returns:\n        float: The area of the square.\n    Example:\n        >>> area_square(4)\n        16", "Freq": 24, "TSR": 6, "experience_pool": "1. When using the `area_square` function, ensure that the correct side length of the square is provided as a parameter.\n2. Make sure that all necessary functions like `area_circle`, `area_triangle`, `triangle_side_lengths`, and `calculate_composite_area` are defined and implemented correctly when working with different shapes.\n3. Double-check the input parameters and function calls to avoid errors related to missing parameters.\n4. Verify the existence and correctness of all required functions before executing the code that uses them.\n5. Pay attention to failed tasks and corresponding error information to identify the root cause of the issue."}, {"tool": "def triangle_area_by_coordinates(x1, y1, x2, y2, x3, y3):\n    \n    return abs(x1*(y2-y3) + x2*(y3-y1) + x3*(y1-y2)) / 2", "subfield": "Area Calculation", "tool_name": "triangle_area_by_coordinates", "tool_type": "function", "description": "Calculate the area of a triangle given the coordinates of its vertices.", "docstring": "Calculate the area of a triangle given the coordinates of its vertices.\n    Parameters:\n    x1, y1 (float): Coordinates of the first vertex.\n    x2, y2 (float): Coordinates of the second vertex.\n    x3, y3 (float): Coordinates of the third vertex.\n    Returns:\n    float: The absolute value of the area of the triangle.\n    Examples:\n    >>> triangle_area_by_coordinates(0, 0, 4, 0, 2, 3)\n    6.0", "Freq": 16, "TSR": 5, "experience_pool": "1. Problem: Find the area of the triangle with vertices $(3,-5),$ $(-2,0),$ and $(1,-6)$.\n   Solution: The correct area is $\\frac{15}{2}$.\n2. Problem: Find the area of the triangle with vertices $(-1,4),$ $(7,0),$ and $(11,5)$.\n   Solution: The correct area is $28$.\n3. Problem: Regular hexagon $ABCDEF$ has vertices $A$ and $C$ at $(0,0)$ and $(7,1)$, respectively. What is its area?\n   Solution: The correct area is $25\\sqrt{3}$.\n4. Problem: Point $P$ is selected at random from the interior of the pentagon with vertices $A=(0,2)$, $B= (4,0)$, $C = (2\\pi +1, 0)$, $D=(2\\pi +1,4)$, and $E=(0,4)$. What is the probability that $\\angle APB$ is obtuse? Express your answer as a common fraction.\n   Solution: The correct probability is $\\frac{5}{16}$.\n5. Problem: Find the area of the triangle with vertices $(0,7,10),$ $(-1,6,6),$ and $(-4,9,6)$.\n   Solution: The correct area is $9$.\n6. Problem: What is the area, in square units, of a triangle whose vertices are at $(4, -1)$, $(10, 3)$ and $(4, 5)$?\n   Solution: The correct area is $18$.\n7. Problem: The set of points $(x,y)$ such that $|x - 3| \\le y \\le 4 - |x - 1|$ defines a region in the $xy$-plane. Compute the area of this region.\n   Solution: The correct area is $6$.\n8. Problem: A triangle has vertices at $(-3,2),(6,-2),(3,5)$. How many square units are in the area of the triangle? Express your answer as a decimal to the nearest tenth.\n   Solution: The correct area is $25.5$."}, {"tool": "def distance_between_points(x1, y1, x2, y2):\n    \n    return math.sqrt((x2 - x1)**2 + (y2 - y1)**2)", "subfield": "Area Calculation", "tool_name": "distance_between_points", "tool_type": "function", "description": "Calculate the Euclidean distance between two points in the Cartesian plane.", "docstring": "Calculate the Euclidean distance between two points in the Cartesian plane.\n    Parameters:\n    x1, y1 (float): Coordinates of the first point.\n    x2, y2 (float): Coordinates of the second point.\n    Returns:\n    float: The distance between the points.\n    Examples:\n    >>> distance_between_points(0, 0, 3, 4)\n    5.0", "Freq": 4, "TSR": 1, "experience_pool": "- Make sure to pass float values as coordinates when using the distance_between_points function.\n- Check for typos or incorrect values in the input parameters before calling the distance_between_points function."}, {"tool": "def calculate_composite_area(*args):\n    \n    return sum(args)", "subfield": "Area Calculation", "tool_name": "calculate_composite_area", "tool_type": "function", "description": "Calculate the total area of multiple individual areas passed as arguments.", "docstring": "Calculate the total area of multiple individual areas passed as arguments.\n    Parameters:\n    - args (float): Individual areas to be summed.\n    Returns:\n    - float: The total area of all individual areas combined.\n    Examples:\n    >>> calculate_composite_area(10, 15, 5)\n    30", "Freq": 2, "TSR": 0, "experience_pool": "- Always provide correct input parameters when calling the `calculate_composite_area` function.\n- Ensure that the correct areas are passed as arguments to the `calculate_composite_area` function.\n- Double-check the calculations and logic in the calling code to avoid errors."}, {"tool": "def law_of_cosines(a, b, angle_degrees):\n    \n    angle_radians = math.radians(angle_degrees)\n    c = math.sqrt(a**2 + b**2 - 2 * a * b * math.cos(angle_radians))\n    return c", "subfield": "Area Calculation", "tool_name": "law_of_cosines", "tool_type": "function", "description": "Calculate the third side of a triangle using the Law of Cosines.", "docstring": "Calculate the third side of a triangle using the Law of Cosines.\n    Parameters:\n    a (float): Length of the first side.\n    b (float): Length of the second side.\n    angle_degrees (float): Angle between sides a and b in degrees.\n    Returns:\n    float: Length of the third side.\n    Example:\n    >>> law_of_cosines(5, 5, 90)\n    7.0710678118654755", "Freq": 1, "TSR": 0}, {"tool": "def line_equation_from_points(x1, y1, x2, y2):\n    \n    if x2 != x1:\n        slope = (y2 - y1) / (x2 - x1)\n        intercept = y1 - slope * x1\n        return slope, intercept\n    else:\n        return float('inf'), x1", "subfield": "Area Calculation", "tool_name": "line_equation_from_points", "tool_type": "function", "description": "Calculate the slope and y-intercept of the line passing through two points.", "docstring": "Calculate the slope and y-intercept of the line passing through two points.\n    Parameters:\n    x1, y1 (float): Coordinates of the first point.\n    x2, y2 (float): Coordinates of the second point.\n    Returns:\n    tuple: Slope and y-intercept of the line.\n    Examples:\n    >>> line_equation_from_points(0, 0, 2, 2)\n    (1.0, 0.0)\n    >>> line_equation_from_points(1, 2, 3, 8)\n    (3.0, -1.0)", "Freq": 0, "TSR": 0}, {"tool": "def pythagorean_triplet(a, b, c):\n    \n    return abs((a ** 2) + (b ** 2) - (c ** 2)) < 0.001", "subfield": "Area Calculation", "tool_name": "pythagorean_triplet", "tool_type": "function", "description": "Check if the three given lengths form a Pythagorean triplet.", "docstring": "Check if the three given lengths form a Pythagorean triplet.\n    Parameters\n    ----------\n    a : float\n        Length of the first side.\n    b : float\n        Length of the second side.\n    c : float\n        Length of the third side (hypotenuse).\n    Returns\n    -------\n    bool\n        `True` if the lengths form a Pythagorean triplet and `False` otherwise", "Freq": 0, "TSR": 0}, {"tool": "class CircleBasedCalculator:\n    \"\"\"\n    A class to calculate various geometrical properties and areas related to circles,\n    including full circles, sectors, and annuli (regions between two concentric circles).\n    \"\"\"\n    @staticmethod\n    def area_of_circle(radius):\n        \"\"\"\n        Calculate the area of a circle using the formula πr².\n        Parameters:\n            radius (float): The radius of the circle.\n        Returns:\n            float: The area of the circle.\n        Example:\n            >>> CircleBasedCalculator.area_of_circle(5)\n            78.53981633974483\n        \"\"\"\n        return math.pi * radius ** 2\n    @staticmethod\n    def area_of_sector(radius, angle_in_degrees):\n        \"\"\"\n        Calculate the area of a sector given the central angle and radius.\n        Parameters:\n            radius (float): The radius of the circle from which the sector is part.\n            angle_in_degrees (float): The angle of the sector in degrees.\n        Returns:\n            float: The area of the sector.\n        Example:\n            >>> CircleBasedCalculator.area_of_sector(5, 90)\n            19.634954084936208\n        \"\"\"\n        return (angle_in_degrees / 360) * math.pi * radius ** 2\n    @staticmethod\n    def area_of_annulus(outer_radius, inner_radius):\n        \"\"\"\n        Calculate the area of an annulus (the region between two concentric circles).\n        Parameters:\n            outer_radius (float): Radius of the outer circle.\n            inner_radius (float): Radius of the inner circle.\n        Returns:\n            float: The area of the annulus.\n        Example:\n            >>> CircleBasedCalculator.area_of_annulus(5, 3)\n            50.26548245743669\n        \"\"\"\n        return math.pi * (outer_radius ** 2 - inner_radius ** 2)\n    @staticmethod\n    def diameter_to_radius(diameter):\n        \"\"\"\n        Convert diameter to radius.\n        Parameters:\n            diameter (float): The diameter of the circle.\n        Returns:\n            float: The radius of the circle.\n        Example:\n            >>> CircleBasedCalculator.diameter_to_radius(10)\n            5.0\n        \"\"\"\n        return diameter / 2", "subfield": "Area Calculation", "tool_name": "CircleBasedCalculator:\n    \"\"\"\n    A class to calculate various geometrical properties and areas related to circles,\n    including full circles, sectors, and annuli", "tool_type": "class", "description": "A class to calculate various geometrical properties and areas related to circles,\n    including full circles, sectors, and annuli (regions between two concentric circles).", "docstring": "A class to calculate various geometrical properties and areas related to circles,\n    including full circles, sectors, and annuli (regions between two concentric circles).", "Freq": 0, "TSR": 0}, {"tool": "def centroid_polygon(vertices: List[Tuple[float, float]]) -> Tuple[float, float]:\n    \n    x_coordinates, y_coordinates = zip(*vertices)\n    num_vertices = len(vertices)\n    centroid_x = sum(x_coordinates) / num_vertices\n    centroid_y = sum(y_coordinates) / num_vertices\n    return (centroid_x, centroid_y)", "subfield": "Area Calculation", "tool_name": "centroid_polygon", "tool_type": "function", "description": "Calculates the centroid (geometric center) of a polygon given its vertices.", "docstring": "Calculates the centroid (geometric center) of a polygon given its vertices.\n    Parameters:\n    - vertices (List[Tuple[float, float]]): Coordinates of the vertices of the polygon.\n    Returns:\n    - Tuple[float, float]: The coordinates of the centroid.\n    Examples:\n    >>> print(centroid_polygon([(0, 0), (4, 0), (4, 4), (0, 4)]))\n    (2.0, 2.0)", "Freq": 0, "TSR": 0}, {"tool": "def TriangleAreaCalculator(base=None, height=None, vertices=None, sides=None):\n    \n    import math\n    if base is not None and height is not None:\n        # Simple calculation from base and height\n        return 0.5 * base * height\n    elif vertices is not None:\n        if len(vertices) != 3:\n            raise ValueError(\"Triangle vertices should have exactly 3 points.\")\n        \n        # Calculate area from vertices using shoelace formula\n        x1, y1 = vertices[0]\n        x2, y2 = vertices[1]\n        x3, y3 = vertices[2]\n        return 0.5 * abs(x1*(y2-y3) + x2*(y3-y1) + x3*(y1-y2))\n    elif sides is not None:\n        if len(sides) != 3:\n            raise ValueError(\"Triangle sides should have exactly 3 lengths.\")\n        \n        # Using Heron's formula to find area when sides are known\n        a, b, c = sides\n        s = 0.5 * sum(sides)\n        area = math.sqrt(s * (s - a) * (s - b) * (s - c))\n        return area\n    else:\n        raise ValueError(\"Insufficient information to calculate area.\")", "subfield": "Area Calculation", "tool_name": "TriangleAreaCalculator", "tool_type": "function", "description": "Calculate the area of a triangle given base and height, vertices, or side lengths.", "docstring": "Calculate the area of a triangle given base and height, vertices, or side lengths.\n    Parameters:\n    - base (float): The base of the triangle.\n    - height (float): The height of the triangle perpendicular to the base.\n    - vertices (list of tuples): List of coordinates for the triangle's vertices as (x, y).\n    - sides (tuple): The lengths of the three sides of the triangle.\n    Returns:\n    - float: The area of the triangle.\n    Examples:\n    - TriangleAreaCalculator(base=5, height=3)\n    - TriangleAreaCalculator(vertices=[(0, 0), (5, 0), (0, 3)])\n    - TriangleAreaCalculator(sides=(3, 4, 5))", "Freq": 1, "TSR": 1, "experience_pool": "- When providing vertices to the `TriangleAreaCalculator` function, ensure that exactly 3 points are included.\n- When providing sides to the `TriangleAreaCalculator` function, ensure that exactly 3 side lengths are included."}, {"tool": "def find_line_intersection(p1, p2, p3, p4):\n    \n    x1, y1 = p1\n    x2, y2 = p2\n    x3, y3 = p3\n    x4, y4 = p4\n    \n    # Calculate the determinants\n    denom = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4)\n    if denom == 0:\n        return 'No unique intersection or lines are collinear'\n    \n    px = ((x1 * y2 - y1 * x2) * (x3 - x4) - (x1 - x2) * (x3 * y4 - y3 * x4)) / denom\n    py = ((x1 * y2 - y1 * x2) * (y3 - y4) - (y1 - y2) * (x3 * y4 - y3 * x4)) / denom\n    return (px, py)", "subfield": "Area Calculation", "tool_name": "find_line_intersection", "tool_type": "function", "description": "Calculate the intersection point of two lines defined by two pairs of points.", "docstring": "Calculate the intersection point of two lines defined by two pairs of points.\n    Parameters:\n    p1, p2 (tuple): (x, y) coordinates for the first and the second point of the first line.\n    p3, p4 (tuple): (x, y) coordinates for the third and the fourth point of the second line.\n    Returns:\n    tuple or str: (x, y) coordinates of the intersection point, or 'No unique intersection' if lines are collinear or do not intersect.\n    Examples:\n    >>> find_line_intersection((0, 0), (1, 1), (1, 0), (0, 1))\n    (0.5, 0.5)\n    >>> find_line_intersection((0, 0), (1, 1), (2, 2), (3, 3))\n    'No unique intersection or lines are collinear'", "Freq": 1, "TSR": 0}, {"tool": "def circle_diameter(radius):\n    \n    return 2 * radius", "subfield": "Area Calculation", "tool_name": "circle_diameter", "tool_type": "function", "description": "The function takes radius of a circle as input \n    and returns its diameter.", "docstring": "The function takes radius of a circle as input \n    and returns its diameter.", "Freq": 0, "TSR": 0}, {"tool": "def derive_side_lengths(shape, **kwargs):\n    \n    if shape == 'triangle_cosine':\n        a, b, angle = kwargs['a'], kwargs['b'], kwargs['angle']\n        angle_rad = np.radians(angle)\n        return sqrt(a**2 + b**2 - 2*a*b*np.cos(angle_rad))\n    elif shape == 'polygon_diagonal':\n        side, n_sides = kwargs['side'], kwargs['n_sides']\n        if n_sides == 4:  # square or rectangle logic\n            return sqrt(2) * side\n        else:\n            raise ValueError(\"Diagonal calculation for this polygon not supported\")", "subfield": "Area Calculation", "tool_name": "derive_side_lengths", "tool_type": "function", "description": "Derive side lengths using geometric and trigonometric relations for various shapes.", "docstring": "Derive side lengths using geometric and trigonometric relations for various shapes.\n    \n    Parameters\n    ----------\n    shape : str\n        Type of geometric shape ('triangle_cosine', 'polygon_diagonal')\n    kwargs: various\n        Known lengths, angles, and other relevant properties depending on the shape.\n    \n    Returns\n    -------\n    float\n        The derived side length or lengths depending on the calculation.\n    \n    Examples\n    --------\n    >>> derive_side_lengths('triangle_cosine', a=5, b=5, angle=60)\n    5.0\n    >>> derive_side_lengths('polygon_diagonal', side=4, n_sides=4)  # Diagonal of a square\n    5.656854249492381", "Freq": 0, "TSR": 0}, {"tool": "def area_trapezoid(base1, base2, height):\n    \n    return 0.5 * (base1 + base2) * height", "subfield": "Area Calculation", "tool_name": "area_trapezoid", "tool_type": "function", "description": "Calculate the area of a trapezoid given the lengths of its two bases and its height.", "docstring": "Calculate the area of a trapezoid given the lengths of its two bases and its height.\n    \n    Parameters:\n        base1 (float): The length of the first base of the trapezoid.\n        base2 (float): The length of the second base of the trapezoid.\n        height (float): The height of the trapezoid, measured perpendicularly between the bases.\n        \n    Returns:\n        float: The area of the trapezoid.\n        \n    Example:\n        >>> area_trapezoid(5, 7, 4)\n        24.0", "Freq": 6, "TSR": 0, "experience_pool": "1. When using the area_trapezoid function, ensure that the input parameters are numerical values representing the lengths of the bases and the height of the trapezoid.\n2. Double-check the calculations of base lengths and height before calling the area_trapezoid function to avoid errors in the final result.\n3. Make sure to provide correct numerical values for base lengths and height when calling the area_trapezoid function to get accurate area calculations."}, {"tool": "def calculate_perimeter_and_area(shape_type, dimensions):\n    \n    import math\n    \n    def rectangle(length, width):\n        perimeter = 2 * (length + width)\n        area = length * width\n        return perimeter, area\n    def circle(radius):\n        perimeter = 2 * math.pi * radius\n        area = math.pi * radius ** 2\n        return perimeter, area\n    def square(side_length):\n        perimeter = 4 * side_length\n        area = side_length ** 2\n        return perimeter, area\n    def trapezoid(base1, base2, height):\n        perimeter = base1 + base2 + 2 * math.sqrt(height**2 + ((base2 - base1) / 2) ** 2)\n        area = 0.5 * (base1 + base2) * height\n        return perimeter, area\n    def complex_shape(squares, circles):\n        total_perimeter = 0\n        total_area = 0\n        \n        for side in squares:\n            total_perimeter += 4 * side\n            total_area += side ** 2\n        \n        for radius in circles:\n            total_perimeter += 2 * math.pi * radius\n            total_area += math.pi * radius ** 2\n            \n        return total_perimeter, total_area\n    if shape_type == 'rectangle':\n        return rectangle(dimensions['length'], dimensions['width'])\n    elif shape_type == 'circle':\n        return circle(dimensions['radius'])\n    elif shape_type == 'square':\n        return square(dimensions['side_length'])\n    elif shape_type == 'trapezoid':\n        return trapezoid(dimensions['base1'], dimensions['base2'], dimensions['height'])\n    elif shape_type == 'complex':\n        return complex_shape(dimensions['squares'], dimensions['circles'])\n    else:\n        raise ValueError(\"Unsupported shape type.\")", "subfield": "Area Calculation", "tool_name": "calculate_perimeter_and_area", "tool_type": "function", "description": "Calculate the perimeter and area of various geometric shapes based on the provided dimensions.", "docstring": "Calculate the perimeter and area of various geometric shapes based on the provided dimensions.\n    \n    Parameters:\n        shape_type (str): The type of shape ('rectangle', 'circle', 'square', 'trapezoid', 'complex').\n        dimensions (dict): A dictionary containing the necessary dimensions for the shape.\n                           For example:\n                           - Rectangle: {'length': 5, 'width': 3}\n                           - Circle: {'radius': 4}\n                           - Square: {'side_length': 2}\n                           - Trapezoid: {'base1': 4, 'base2': 6, 'height': 3}\n                           - Complex: {'squares': [1, 2, 3], 'circles': [1.5, 2]}\n    \n    Returns:\n        tuple: A tuple containing the perimeter and area of the shape.\n    \n    Example:\n        >>> calculate_perimeter_and_area('rectangle', {'length': 5, 'width': 3})\n        (16, 15)", "Freq": 1, "TSR": 0}, {"tool": "def composite_area_calculator(shapes):\n    \n    \n    import math\n    \n    def area_triangle(base, height):\n        return 0.5 * base * height\n    \n    def rectangle_area(length, width):\n        return length * width\n    \n    def area_circle(radius):\n        return math.pi * radius ** 2\n    \n    total_area = 0\n    \n    for shape in shapes:\n        if shape['type'] == 'triangle':\n            total_area += area_triangle(shape['base'], shape['height'])\n        elif shape['type'] == 'rectangle':\n            total_area += rectangle_area(shape['length'], shape['width'])\n        elif shape['type'] == 'circle':\n            total_area += area_circle(shape['radius'])\n        elif shape['type'] == 'trapezoid':\n            total_area += area_trapezoid(shape['base1'], shape['base2'], shape['height'])\n        # Add more shapes as needed\n    \n    return total_area", "subfield": "Area Calculation", "tool_name": "composite_area_calculator", "tool_type": "function", "description": "Calculate the total area of a composite shape formed by multiple geometric figures.", "docstring": "Calculate the total area of a composite shape formed by multiple geometric figures.\n    \n    Parameters:\n        shapes (list of dict): A list of dictionaries where each dictionary represents a shape\n                                and contains the shape type and its dimensions.\n                                Example:\n                                [\n                                    {'type': 'triangle', 'base': 4, 'height': 3},\n                                    {'type': 'rectangle', 'length': 5, 'width': 2},\n                                    {'type': 'circle', 'radius': 3}\n                                ]\n    \n    Returns:\n        float: The total area of the composite shape.\n    \n    Example:\n        >>> composite_area_calculator([\n                {'type': 'triangle', 'base': 4, 'height': 3},\n                {'type': 'rectangle', 'length': 5, 'width': 2}\n            ])\n        22.0", "Freq": 0, "TSR": 0}], "Triangles": [{"tool": "def triangle_area(base, height):\n    \n    return 0.5 * base * height", "subfield": "Triangles", "tool_name": "triangle_area", "tool_type": "function", "description": "Calculate the area of a triangle using base and height.", "docstring": "Calculate the area of a triangle using base and height.\n    \n    Parameters:\n    base (float): Base of the triangle.\n    height (float): Height of the triangle.\n    Returns:\n    float: Area of the triangle.", "Freq": 8, "TSR": 4, "experience_pool": "Tool for calculating the area of a triangle using base and height is accurate and effective."}, {"tool": "def herons_formula(a, b, c):\n    \n    s = (a + b + c) / 2\n    area = math.sqrt(s * (s - a) * (s - b) * (s - c))\n    return area", "subfield": "Triangles", "tool_name": "herons_formula", "tool_type": "function", "description": "Calculate the area of a triangle using Heron's formula given the sides.", "docstring": "Calculate the area of a triangle using Heron's formula given the sides.\n    \n    Parameters:\n    a, b, c (float): Sides of the triangle.\n    \n    Returns:\n    float: Area of the triangle.", "Freq": 14, "TSR": 5, "experience_pool": "- Make sure to provide the correct side lengths when calling the `herons_formula` function.\n- Double-check the calculations and input values in the calling code to ensure accurate results."}, {"tool": "def is_valid_triangle(a, b, c):\n    \n    return (a+b > c) and (a+c > b) and (b+c > a)", "subfield": "Triangles", "tool_name": "is_valid_triangle", "tool_type": "function", "description": "Determines if three side lengths can form a valid triangle based on the Triangle Inequality Theorem.", "docstring": "Determines if three side lengths can form a valid triangle based on the Triangle Inequality Theorem.\n    Parameters:\n        a (float): The length of the first side.\n        b (float): The length of the second with the limil side.\n        c (float): The length of the third side.\n    Returns:\n        bool: True if the side lengths can form a triangle, False otherwise.\n    Examples:\n    >>> is_valid_triangle(3, 4, 5)\n    True\n    >>> is_valid_triangle(1, 10, 12)\n    False", "Freq": 3, "TSR": 2, "experience_pool": "Tool has been used successfully with a 50.0% success rate."}, {"tool": "def calculate_triangle_area(base=None, height=None, side=None):\n    \n    if base is not None and height is not None:\n        return 0.5 * base * height\n    elif side is not None:\n        # Area of an equilateral triangle: sqrt(3)/4 * side^2\n        return (math.sqrt(3) / 4) * (side**2)\n    else:\n        raise ValueError(\"Invalid inputs given. Provide either base and height for a regular triangle or side for an equilateral triangle.\")", "subfield": "Triangles", "tool_name": "calculate_triangle_area", "tool_type": "function", "description": "Calculate the area of a triangle using base and height or by specifying the sides using Heron's formula for equilateral triangles.", "docstring": "Calculate the area of a triangle using base and height or by specifying the sides using Heron's formula for equilateral triangles.\n    \n    Parameters:\n    base (float, optional): The base of the triangle.\n    height (float, optional): The height of the triangle.\n    side (float, optional): The length of a side if the triangle is equilateral.\n    Returns:\n    float: The area of the triangle.\n    Example:\n    >>> calculate_triangle_area(base=10, height=5)\n    25.0\n    >>> calculate_triangle_area(side=8)  # Equilateral triangle\n    13.856", "Freq": 0, "TSR": 0}, {"tool": "def calculate_third_angle(angle1, angle2):\n    \n    if angle1 + angle2 >= 180 or angle1 <= 0 or angle2 <= 0:\n        return None\n    return 180 - angle1 - angle2", "subfield": "Triangles", "tool_name": "calculate_third_angle", "tool_type": "function", "description": "Calculate the third angle of a triangle given two angles.", "docstring": "Calculate the third angle of a triangle given two angles.\n    Parameters:\n    angle1 (float): The first angle of the triangle in degrees.\n    angle2 (float): The second angle of the triangle in degrees.\n    Returns:\n    float: The third angle of the triangle in degrees, or None if the input angles do not form a valid triangle.", "Freq": 9.5, "TSR": 6, "experience_pool": "- When using the tool to calculate the third angle of a triangle, ensure that the sum of the input angles is less than 180 degrees and that each angle is greater than 0 degrees to form a valid triangle."}, {"tool": "def valid_third_side_range(a, b):\n    \n    return (abs(a - b) + 1, a + b - 1)", "subfield": "Triangles", "tool_name": "valid_third_side_range", "tool_type": "function", "description": "Determines the valid range for potential third side of a triangle given two sides, based on the Triangle Inequality Theorem.", "docstring": "Determines the valid range for potential third side of a triangle given two sides, based on the Triangle Inequality Theorem.\n    \n    Parameters:\n        a (float or int): The length of the first side.\n        b (float or int): The length of the second side.\n        \n    Returns:\n        tuple: A tuple containing the minimum and maximum values for the third side that can still form a triangle.\n    \n    Examples:\n        >>> valid_third_side_range(8, 5)\n        (3, 13)\n        >>> valid_third_side_range(15, 10)\n        (6, 24)", "Freq": 5, "TSR": 3, "experience_pool": "- Make sure to provide the correct side lengths when calling the valid_third_side_range function.\n- Ensure that the calling code correctly interprets the output of the valid_third_side_range function to get the desired result."}, {"tool": "def midpoint(x1, y1, x2, y2):\n    \n    return ((x1 + x2) / 2, (y1 + y2) / 2)", "subfield": "Triangles", "tool_name": "midpoint", "tool_type": "function", "description": "Calculate the midpoint of a segment given the coordinates of its endpoints.", "docstring": "Calculate the midpoint of a segment given the coordinates of its endpoints.\n    \n    Parameters:\n        x1, y1 (float): Coordinates of the first endpoint.\n        x2, y2 (float): Coordinates of the second endpoint.\n    \n    Returns:\n        tuple: The coordinates of the midpoint.\n    \n    Examples:\n        >>> midpoint(1, 1, 4, 5)\n        (2.5, 3.0)", "Freq": 2, "TSR": 1}, {"tool": "def calculate_side_range_and_perimeter(a: float, b: float) -> Tuple[Tuple[int, int], int]:\n    \n    if a <= 0 or b <= 0:\n        raise ValueError(\"Side lengths must be positive numbers\")\n    min_c = max(abs(a - b) + 1, 1)\n    max_c = a + b - 1\n    max_perimeter = a + b + max_c\n    return ((min_c, max_c), max_perimeter)", "subfield": "Triangles", "tool_name": "calculate_side_range_and_perimeter", "tool_type": "function", "description": "Calculate the possible values for the third side of a triangle when two sides are known.\n    Also, returns the maximal possible integer perimeter.", "docstring": "Calculate the possible values for the third side of a triangle when two sides are known.\n    Also, returns the maximal possible integer perimeter.\n    \n    Parameters:\n    a (float): Length of the first known side of the triangle.\n    b (float): Length of the second known side of the triangle.\n    \n    Returns:\n    Tuple[Tuple[int, int], int]: Returns a tuple containing another tuple and an integer. \n    The inner tuple represents the minimum and maximum possible integer values for the third side,\n    while the integer represents the maximum possible integer perimeter if the maximum side length is used.\n    \n    Examples:\n    >>> calculate_side_range_and_perimeter(3, 4)\n    ((2, 6), 13)\n    >>> calculate_side_range_and_perimeter(5, 10)\n    ((6, 14), 29)", "Freq": 10, "TSR": 3, "experience_pool": "1. The tool `calculate_side_range_and_perimeter` accurately calculates the possible range for the third side of a triangle and the maximum perimeter.\n2. Ensure that the input parameters provided to the tool are correct and within the valid range of positive numbers.\n3. The tool handles cases where the input sides are positive numbers appropriately."}, {"tool": "def triangle_side_lengths(a, b, c):\n    \n    # Convert tuples to Points\n    p1, p2, p3 = Point(a), Point(b), Point(c)\n    # Create triangle ABC\n    triangle_abc = Triangle(p1, p2, p3)\n    \n    # Calculate side lengths\n    ab = triangle_abc.ab.length.evalf()\n    bc = triangle_abc.bc.length.evalf()\n    ca = triangle_abc.ca.length.evalf()\n    \n    return {'ab': ab, 'bc': bc, 'ca': ca}", "subfield": "Triangles", "tool_name": "triangle_side_lengths", "tool_type": "function", "description": "Calculate the triangle side lengths given vertices a, b, and c.", "docstring": "Calculate the triangle side lengths given vertices a, b, and c.\n    Parameters:\n        a (tuple): Coordinates of vertex a (x1, y1)\n        b (tuple): Coordinates of vertex b (x2, y2)\n        c (tuple): Coordinates of vertex c (x3, y3)\n    \n    Returns:\n        A dictionary with side lengths ab, bc, and ca.", "Freq": 1, "TSR": 0}, {"tool": "def solve_triangle(a, b, A):\n    \n    A = math.radians(A)  # Convert angle A from degrees to radians\n    sin_A = math.sin(A)\n    sin_B = (b * sin_A) / a\n    if sin_B > 1 or sin_B < -1:  # Check for invalid triangle configuration\n        return None\n    B = math.asin(sin_B)\n    C = math.pi - A - B\n    c = (a * math.sin(C)) / sin_A\n    return (c, math.degrees(B), math.degrees(C))", "subfield": "Triangles", "tool_name": "solve_triangle", "tool_type": "function", "description": "Calculate the missing side c and the remaining angles B and C in a triangle using the Law of Sines.\n    The provided angles must be in degrees.", "docstring": "Calculate the missing side c and the remaining angles B and C in a triangle using the Law of Sines.\n    The provided angles must be in degrees.\n    \n    Parameters:\n        a (float): The length of side a.\n        b (float): The length of side b.\n        A (float): The angle opposite to side a in degrees.\n    \n    Returns:\n        tuple: Returns the length of side c and the angles B and C in degrees.\n    \n    Example:\n        >>> solve_triangle(3, 4, 30)\n        (2.3094, 53.1301, 96.8699)", "Freq": 3, "TSR": 0, "experience_pool": "Tool for solving triangles using the Law of Sines is accurate and working as intended.\nEnsure correct input parameters and calculations in the calling code for accurate results."}, {"tool": "def is_right_triangle(a, b, c):\n    \n    sides = sorted([a, b, c])\n    return math.isclose(sides[0]**2 + sides[1]**2, sides[2]**2)", "subfield": "Triangles", "tool_name": "is_right_triangle", "tool_type": "function", "description": "Determine if a triangle with sides a, b, c is a right triangle.", "docstring": "Determine if a triangle with sides a, b, c is a right triangle.\n    \n    Parameters:\n    a, b, c (float): Sides of the triangle.\n    Returns:\n    bool: True if the triangle is right, False otherwise.", "Freq": 0, "TSR": 0}, {"tool": "def area_by_inradius_semiperimeter(inradius: float, semiperimeter: float) -> float:\n    \n    return inradius * semiperimeter", "subfield": "Triangles", "tool_name": "area_by_inradius_semiperimeter", "tool_type": "function", "description": "Calculate the area of a triangle given the inradius and the semiperimeter.", "docstring": "Calculate the area of a triangle given the inradius and the semiperimeter.\n    Parameters:\n    - inradius (float): The radius of the inscribed circle of the triangle.\n    - semiperimeter (float): The semiperimeter of the triangle.\n    Returns:\n    - float: The area of the triangle.\n    Examples:\n    >>> area_by_inradius_semiperimeter(1, 6)\n    6.0", "Freq": 2, "TSR": 2}, {"tool": "def calculate_distance(point1, point2):\n    \n    return math.sqrt((point2[0] - point1[0])**2 + (point2[1] - point1[1])**2)", "subfield": "Triangles", "tool_name": "calculate_distance", "tool_type": "function", "description": "Calculate the Euclidean distance between two points in 2D space.", "docstring": "Calculate the Euclidean distance between two points in 2D space.\n    \n    Parameters:\n        point1 (tuple): The (x, y) coordinates of the first point.\n        point2 (tuple): The (x, y) coordinates of the second point.\n    \n    Returns:\n        float: The distance between the two points.\n    \n    Example:\n        >>> calculate_distance((1, 1), (4, 5))\n        5.0", "Freq": 3, "TSR": 3}, {"tool": "def angle_between_vectors(x1, y1, x2, y2):\n    \n    dot_product = x1 * x2 + y1 * y2\n    magnitude1 = math.sqrt(x1**2 + y1**2)\n    magnitude2 = math.sqrt(x2**2 + y2**2)\n    angle_radians = math.acos(dot_product / (magnitude1 * magnitude2))\n    return math.degrees(angle_radians)", "subfield": "Triangles", "tool_name": "angle_between_vectors", "tool_type": "function", "description": "Calculate the angle (in degrees) between two vectors originating from the origin.", "docstring": "Calculate the angle (in degrees) between two vectors originating from the origin.\n    \n    Parameters:\n        x1, y1 (float): Components of the first vector.\n        x2, y2 (float): Components of the second vector.\n    \n    Returns:\n        float: The angle in degrees between two vectors.\n    \n    Examples:\n        >>> angle_between_vectors(1, 0, 0, 1)\n        90.0", "Freq": 2, "TSR": 0}, {"tool": "def triangle_similarity_by_sss(a_lengths, b_lengths):\n    \n    # Extracting lengths in sorted order\n    a_sorted = sorted(a_lengths.values())\n    b_sorted = sorted(b_lengths.values())\n    \n    # Checking proportionality\n    ratios = [a/b for a, b in zip(a_sorted, b_sorted)]\n    first_ratio = ratios[0]\n    \n    return all(abs(r - first_ratio) < 1e-9 for r in ratios)", "subfield": "Triangles", "tool_name": "triangle_similarity_by_sss", "tool_type": "function", "description": "Determine if two triangles are similar by Side-Side-Side (SSS) similarity criterion.", "docstring": "Determine if two triangles are similar by Side-Side-Side (SSS) similarity criterion.\n    Parameters:\n        a_lengths (dict): Side lengths of triangle A {'ab': length1, 'bc': length2, 'ca': length3}\n        b_lengths (dict): Side lengths of triangle B {'ab': length1, 'bc': length2, 'ca': length3}\n    \n    Returns:\n        bool: True if triangles are similar, False otherwise.", "Freq": 1, "TSR": 0}, {"tool": "def pythagorean_theorem(a=None, b=None, c=None):\n    \n    import math\n    \n    if a is None:\n        return math.sqrt(c**2 - b**2)\n    elif b is None:\n        return math.sqrt(c**2 - a**2)\n    elif c is None:\n        return math.sqrt(a**2 + b**2)\n    else:\n        raise ValueError(\"Exactly one side must be None to find its length\")", "subfield": "Triangles", "tool_name": "pythagorean_theorem", "tool_type": "function", "description": "Apply the Pythagorean theorem to find the missing side of a right triangle.", "docstring": "Apply the Pythagorean theorem to find the missing side of a right triangle.\n    Parameters:\n        a (float, optional): length of side a, leg of the triangle\n        b (float, optional): length of side b, leg of the triangle\n        c (float, optional): length of side c, hypotenuse of the triangle\n    Returns:\n        float: The length of the missing side.\n    Examples:\n    >>> pythagorean_theorem(a=3, b=4)\n    5.0\n    >>> pythagorean_theorem(c=10, b=6)\n    8.0", "Freq": 4, "TSR": 1}, {"tool": "def compute_pythagorean_side_length(side1, side2, target_side):\n    \n    if target_side == \"hypotenuse\":\n        return math.sqrt(side1**2 + side2**2)\n    else:\n        return math.sqrt(max(side1, side2)**2 - min(side1, side2)**2)", "subfield": "Triangles", "tool_name": "compute_pythagorean_side_length", "tool_type": "function", "description": "Applies the Pythagorean theorem to compute a side length in a right triangle.", "docstring": "Applies the Pythagorean theorem to compute a side length in a right triangle.\n    Parameters\n    ----------\n    side1 : float\n        Length of one side of the triangle.\n    side2 : float\n        Length of another side of the triangle.\n    target_side : str\n        The side to compute. It can either be \"leg\" if both given sides are legs, or \"hypotenuse\" if one of the given sides is the hypotenuse.\n    \n    Returns\n    -------\n    float\n        The length of the requested side.\n    Example\n    -------\n    >>> compute_pythagorean_side_length(3, 4, \"hypotenuse\")\n    5.0", "Freq": 0, "TSR": 0}, {"tool": "def triangle_side_length(coord1, coord2):\n    \n    x1, y1 = coord1\n    x2, y2 = coord2\n    return math.sqrt((x2 - x1)**2 + (y2 - y1)**2)", "subfield": "Triangles", "tool_name": "triangle_side_length", "tool_type": "function", "description": "Function that calculates the length of a side of a triangle given the coordinates of its endpoints.", "docstring": "Function that calculates the length of a side of a triangle given the coordinates of its endpoints.\n    Parameters:\n    coord1 (tuple): coordinates of the first endpoint of the side. coord1 is a tuple of two numbers (x1, y1)\n    coord2 (tuple): coordinates of the second endpoint of the side. coord2 is a tuple of two numbers (x2, y2)\n    \n    Returns:\n    float: length of the side calculated by the distance formula sqrt((x2 - x1)**2 + (y2 - y1)**2)\n    \n    Examples:\n    >>> triangle_side_length((0,0), (3,4))\n    5.0", "Freq": 0, "TSR": 0}, {"tool": "def calculate_right_triangle_sides(known_side, hypotenuse=None, other_side=None):\n    \n    if hypotenuse:\n        return math.sqrt(hypotenuse**2 - known_side**2)\n    elif other_side:\n        return math.sqrt(known_side**2 + other_side**2)\n    else:\n        raise ValueError('Either hypotenuse or the other side must be known.')", "subfield": "Triangles", "tool_name": "calculate_right_triangle_sides", "tool_type": "function", "description": "Given a side and either the hypotenuse or the other side, calculate the missing side using Pythagoras' theorem.", "docstring": "Given a side and either the hypotenuse or the other side, calculate the missing side using Pythagoras' theorem.\n    Parameters:\n    - known_side (float): Length of one known side of the right triangle.\n    - hypotenuse (float, optional): Hypotenuse of the triangle, if known.\n    - other_side (float, optional): The other side (leg) of the triangle, if known.\n    Returns:\n    float: The length of the missing side.\n    \n    Example:\n    >>> calculate_right_triangle_sides(3, hypotenuse=5)\n    4.0", "Freq": 1, "TSR": 0}, {"tool": "def equilateral_triangle_properties(side_length: float) -> dict:\n    \n    from math import sqrt\n    perimeter = 3 * side_length\n    area = (sqrt(3) / 4) * side_length**2\n    return {'perimeter': perimeter, 'area': area}", "subfield": "Triangles", "tool_name": "equilateral_triangle_properties", "tool_type": "function", "description": "Calculate the perimeter and area of an equilateral triangle given its side length.", "docstring": "Calculate the perimeter and area of an equilateral triangle given its side length.\n    Parameters\n    ----------\n    side_length : float\n        The length of one side of the equilateral triangle.\n    Returns\n    -------\n    dict\n        A dictionary containing the perimeter and area of the equilateral triangle.\n    Examples\n    --------\n    >>> equilateral_triangle_properties(5)\n    {'perimeter': 15.0, 'area': 10.825317547305486}", "Freq": 0, "TSR": 0}, {"tool": "def calculate_triangle_perimeter(sides):\n    \n    return sum(sides)", "subfield": "Triangles", "tool_name": "calculate_triangle_perimeter", "tool_type": "function", "description": "Calculate the perimeter of a triangle given the lengths of the sides.", "docstring": "Calculate the perimeter of a triangle given the lengths of the sides.\n    Parameters:\n    - sides (tuple/list): A collection of the three side lengths.\n    Returns:\n    float: The perimeter of the triangle.\n    \n    Example:\n    >>> calculate_triangle_perimeter((3, 4, 5))\n    12", "Freq": 1, "TSR": 1}, {"tool": "def triangle_angle_sum():\n    \n    return 180", "subfield": "Triangles", "tool_name": "triangle_angle_sum", "tool_type": "function", "description": "Return the sum of angles in any triangle, in degrees.\n    Returns:\n    int: The sum of the internal angles of a triangle, always 180 degrees.\n    \n    Example:\n    >>> triangle_angle_sum()\n    180", "docstring": "Return the sum of angles in any triangle, in degrees.\n    Returns:\n    int: The sum of the internal angles of a triangle, always 180 degrees.\n    \n    Example:\n    >>> triangle_angle_sum()\n    180", "Freq": 0, "TSR": 0}, {"tool": "def triangle_properties(base, height, side=None):\n    \n    import sympy\n    # Calculate Area\n    area = 0.5 * base * height\n    # Calculate Hypotenuse\n    if side is not None:\n        hypotenuse = sqrt(base**2 + side**2)\n    else:\n        hypotenuse = None\n    return area, hypotenuse", "subfield": "Triangles", "tool_name": "triangle_properties", "tool_type": "function", "description": "Given the base and height of a triangle, calculate and return the area and hypotenuse length.", "docstring": "Given the base and height of a triangle, calculate and return the area and hypotenuse length.\n    Parameters:\n    base (float): The length of the base of the triangle.\n    height (float): The length of the height of the triangle.\n    side (float, optional): The length of one of the side of a right triangle to calculate the length of the hypotenuse \n    Returns:\n    area (float): The area of the triangle.\n    hypotenuse (float or None): The length of the hypotenuse of the triangle if side length is provided. None otherwise.", "Freq": 0, "TSR": 0}, {"tool": "def centroid_triangle_area(A, B, C):\n    \n    def triangle_area(x1, y1, x2, y2, x3, y3):\n        \n        return abs((x1*(y2 - y3) + x2*(y3 - y1) + x3*(y1 - y2)) / 2.0)\n    # Calculate the centroid of triangle ABC\n    G = ((A[0] + B[0] + C[0]) / 3, (A[1] + B[1] + C[1]) / 3)\n    # Calculate the centroids of the sub-triangles\n    G1 = ((B[0] + C[0] + G[0]) / 3, (B[1] + C[1] + G[1]) / 3)\n    G2 = ((C[0] + A[0] + G[0]) / 3, (C[1] + A[1] + G[1]) / 3)\n    G3 = ((A[0] + B[0] + G[0]) / 3, (A[1] + B[1] + G[1]) / 3)\n    # Calculate the area of triangle G1G2G3\n    area_G1G2G3 = triangle_area(G1[0], G1[1], G2[0], G2[1], G3[0], G3[1])\n    \n    return area_G1G2G3", "subfield": "Triangles", "tool_name": "centroid_triangle_area", "tool_type": "function", "description": "Calculate the area of the triangle formed by the centroids of triangles PBC, PCA, and PAB,\n    where P is a point inside triangle ABC.", "docstring": "Calculate the area of the triangle formed by the centroids of triangles PBC, PCA, and PAB,\n    where P is a point inside triangle ABC.\n    Parameters:\n    A (tuple): Coordinates of point A (x1, y1).\n    B (tuple): Coordinates of point B (x2, y2).\n    C (tuple): Coordinates of point C (x3, y3).\n    Returns:\n    float: Area of the triangle formed by the centroids of the sub-triangles.", "Freq": 0, "TSR": 0}, {"tool": "def triangle_properties(a, b, c=None):\n    \n    import math\n    \n    def law_of_cosines(a, b, c):\n        \n        return math.degrees(math.acos((a**2 + b**2 - c**2) / (2 * a * b)))\n    if c is not None:\n        # Calculate the angles\n        angle_A = law_of_cosines(b, c, a)\n        angle_B = law_of_cosines(a, c, b)\n        angle_C = law_of_cosines(a, b, c)\n        return max(angle_A, angle_B, angle_C)\n    # If c is not provided, calculate the valid range for the third side\n    min_c = abs(a - b) + 1  # Must be greater than the difference of the two sides\n    max_c = a + b - 1       # Must be less than the sum of the two sides\n    return {'valid_range': (min_c, max_c)}", "subfield": "Triangles", "tool_name": "triangle_properties", "tool_type": "function", "description": "Calculate the largest angle of a triangle given two sides and optionally the third side.\n    Also determines the valid range for the third side based on the other two sides.", "docstring": "Calculate the largest angle of a triangle given two sides and optionally the third side.\n    Also determines the valid range for the third side based on the other two sides.\n    \n    Parameters:\n    a (float): Length of side a.\n    b (float): Length of side b.\n    c (float, optional): Length of side c. If not provided, the function will calculate the largest angle.\n    \n    Returns:\n    dict: A dictionary containing the largest angle in degrees if c is provided, \n           or the valid range for the third side if c is not provided.", "Freq": 1, "TSR": 0}], "Parabolas": [], "Polygons": [], "Right Triangles": [], "Lines and Angles": [], "Volume of Solids": [{"tool": "def cylinder_volume(radius, height):\n    \n    return math.pi * radius ** 2 * height", "subfield": "Volume of Solids", "tool_name": "cylinder_volume", "tool_type": "function", "description": "Calculate the volume of a cylinder given the radius and height.", "docstring": "Calculate the volume of a cylinder given the radius and height.\n    \n    Parameters:\n    radius (float): The radius of the base of the cylinder.\n    height (float): The height of the cylinder.\n    \n    Returns:\n    float: The volume of the cylinder.\n    \n    Examples:\n    >>> cylinder_volume(2, 4)\n    50.26548245743669", "Freq": 18, "TSR": 10, "experience_pool": "- When using the `cylinder_volume` function, make sure to pass in the correct parameters (radius and height) to calculate the volume of a cylinder.\n- If additional calculations are needed, consider creating helper functions like `volume_sphere` and `remaining_volume` separately to avoid errors in the main solution function."}, {"tool": "def volume_of_rectangular_prism(length, width, height):\n    \n    return length * width * height", "subfield": "Volume of Solids", "tool_name": "volume_of_rectangular_prism", "tool_type": "function", "description": "Calculate the volume of a rectangular prism.", "docstring": "Calculate the volume of a rectangular prism.\n    Parameters:\n    - length: The length of the prism (float or int).\n    - width: The width of the prism (float or int).\n    - height: The height of the prism (float or int).\n    Returns:\n    - The volume of the rectangular prism (float).\n    Example:\n    >>> volume_of_rectangular_prism(2, 3, 4)\n    24", "Freq": 13, "TSR": 12}, {"tool": "def volume_sphere(radius):\n    \n    return (4/3) * math.pi * (radius ** 3)", "subfield": "Volume of Solids", "tool_name": "volume_sphere", "tool_type": "function", "description": "Calculate the volume of a sphere given its radius.", "docstring": "Calculate the volume of a sphere given its radius.\n    Parameters:\n    radius (float): The radius of the sphere.\n    Returns:\n    float: The volume of the sphere.\n    Examples:\n    >>> volume_sphere(3)\n    113.09733552923255", "Freq": 32, "TSR": 8, "experience_pool": "1. Calculating the volume of a sphere using the `volume_sphere` function has been successful in various scenarios.\n2. The formula used in the `volume_sphere` function is mathematically correct and provides accurate results.\n3. The docstring of the `volume_sphere` function clearly explains its purpose and usage."}, {"tool": "def cone_volume(radius, height):\n    \n    return (1/3) * math.pi * pow(radius, 2) * height", "subfield": "Volume of Solids", "tool_name": "cone_volume", "tool_type": "function", "description": "Calculate the volume of a cone.", "docstring": "Calculate the volume of a cone.\n    \n    Parameters:\n        radius (float): The radius of the cone.\n        height (float): The height of the cone.\n    \n    Returns:\n        float: The volume of the cone.\n    \n    Example:\n        >>> cone_volume(3, 4)\n        37.69911184307752", "Freq": 19, "TSR": 9, "experience_pool": "1. Problem: The slant height of a cone is 13 cm, and the height from the vertex to the center of the base is 12 cm. What is the number of cubic centimeters in the volume of the cone? Express your answer in terms of $\\pi$.\n   Answer: 100\\pi\n   ```python\n   def solution():\n       \"\"\"Calculate the volume of the cone with given slant height and height.\"\"\"\n       slant_height = 13\n       height = 12\n       radius = 5  # Calculated using Pythagorean theorem\n       result = cone_volume(radius, height)\n       return result\n\n   # Calculate the volume of the cone\n   print(solution())\n   ```\n   Output: 314.15926535897927"}, {"tool": "def pyramid_volume(base_area, height):\n    \n    return (1/3) * base_area * height", "subfield": "Volume of Solids", "tool_name": "pyramid_volume", "tool_type": "function", "description": "Calculate the volume of a pyramid given the area of the base and the height from the base to the apex.", "docstring": "Calculate the volume of a pyramid given the area of the base and the height from the base to the apex.\n    Parameters:\n    base_area (float): The area of the pyramid's base.\n    height (float): The height from the base to the apex.\n    \n    Returns:\n    float: The volume of the pyramid.\n    Example:\n    >>> pyramid_volume(10, 15)\n    50.0", "Freq": 14, "TSR": 7, "experience_pool": "Tool for calculating the volume of a pyramid is accurate and working correctly."}, {"tool": "def volume_from_face_areas(area1, area2, area3):\n    \n    def equations(p):\n        L, W, H = p\n        return (L*W - area1, W*H - area2, L*H - area3)\n    \n    initial_guess = (np.sqrt(area1), np.sqrt(area2), np.sqrt(area3))\n    solution = fsolve(equations, initial_guess)\n    \n    # Check if all derived equations are almost close to zero for correctness\n    if np.allclose(np.array(equations(solution)), [0.0, 0.0, 0.0], atol=1e-6):\n        return solution[0] * solution[1] * solution[2]\n    else:\n        return None", "subfield": "Volume of Solids", "tool_name": "volume_from_face_areas", "tool_type": "function", "description": "Calculates the volume of a rectangular prism using the areas of its faces.\n    Here, it's assumed that:\n    - area1 = length * width\n    - area2 = width * height\n    - area3 = length * height", "docstring": "Calculates the volume of a rectangular prism using the areas of its faces.\n    Here, it's assumed that:\n    - area1 = length * width\n    - area2 = width * height\n    - area3 = length * height\n    Parameters:\n    - area1 (float): Area of the first face (length x width).\n    - area2 (float): Area of the second face (width x height).\n    - area3 (float): Area of the third face (length x height).\n    Returns:\n    - float: The calculated volume of the rectangular prism if the solution is found, otherwise None.\n    Example:\n    >>> volume_from_face_areas(24, 30, 20)\n    60.0", "Freq": 10, "TSR": 9}, {"tool": "def volume_cube(edge_length):\n    \n    return edge_length ** 3", "subfield": "Volume of Solids", "tool_name": "volume_cube", "tool_type": "function", "description": "Calculate the volume of a cube given its edge length.", "docstring": "Calculate the volume of a cube given its edge length.\n    Parameters:\n    edge_length (float): The edge length of the cube.\n    Returns:\n    float: The volume of the cube.\n    Examples:\n    >>> volume_cube(2)\n    8", "Freq": 29, "TSR": 21, "experience_pool": "1. Problem: A solid box is 15 cm by 10 cm by 8 cm. A new solid is formed by removing a cube 3 cm on a side from each corner of this box. What percent of the original volume is removed?\nAnswer: 18%\n2. Problem: A sphere is inscribed in a cube. What is the ratio of the volume of the inscribed sphere to the volume of the cube? Express your answer as a common fraction in terms of $\\pi$.\nAnswer: $\\frac{\\pi}{6}$\n3. Problem: A rectangular prism has dimensions 8 inches by 2 inches by 32 inches. If a cube has the same volume as the prism, what is the surface area of the cube, in square inches?\nAnswer: 384\n4. Problem: The cube below has sides of length 4 feet. If a cylindrical section of radius 2 feet is removed from the solid, what is the total remaining volume of the cube? Express your answer in cubic feet in terms of $\\pi$.\nAnswer: 64-16$\\pi$\n5. Problem: A rectangular box has interior dimensions 6-inches by 5-inches by 10-inches. The box is filled with as many solid 3-inch cubes as possible, with all of the cubes entirely inside the rectangular box. What percent of the volume of the box is taken up by the cubes?\nAnswer: 54\n6. Problem: A point in space $(x,y,z)$ is randomly selected so that $-1\\le x \\le 1$,$-1\\le y \\le 1$,$-1\\le z \\le 1$. What is the probability that $x^2+y^2+z^2\\le 1$?\nAnswer: $\\frac{\\pi}{6}$"}, {"tool": "def volume_of_regular_octahedron(edge_length):\n    \n    return (1/3) * math.sqrt(2) * edge_length**3", "subfield": "Volume of Solids", "tool_name": "volume_of_regular_octahedron", "tool_type": "function", "description": "Calculate the volume of a regular octahedron given its edge length.", "docstring": "Calculate the volume of a regular octahedron given its edge length.\n    Parameters:\n    - edge_length: The length of an edge of the octahedron (float or int).\n    Returns:\n    - The volume of the regular octahedron (float).\n    Example:\n    >>> volume_of_regular_octahedron(3)\n    3.181980515339464", "Freq": 1, "TSR": 1}, {"tool": "def volume_rectangular_parallelepiped(length, width, height):\n    \n    return length * width * height", "subfield": "Volume of Solids", "tool_name": "volume_rectangular_parallelepiped", "tool_type": "function", "description": "Calculates the volume of a rectangular parallelepiped (box).", "docstring": "Calculates the volume of a rectangular parallelepiped (box).\n    \n    Parameters:\n    - length (float): Length of the parallelepiped.\n    - width (float): Width of the parallelepiped.\n    - height (float): Height of the parallelepiped.\n    \n    Returns:\n    - float: The volume of the rectangular parallelepiped.\n    \n    Examples:\n    >>> volume_rectangular_parallelepiped(2, 3, 4)\n    24", "Freq": 11, "TSR": 3, "experience_pool": "1. When using the `volume_rectangular_parallelepiped` function, ensure that the input parameters are correctly provided.\n2. Make sure to define and implement any additional functions like `volume_cube` or `remaining_volume` before using them in calculations.\n3. Double-check the calculations and formulas used in the solution to avoid errors in the final output."}, {"tool": "def calculate_volume(shape_type, dimensions):\n    \n    if shape_type == \"sphere\":\n        radius = dimensions[\"radius\"]\n        return (4/3) * math.pi * radius ** 3\n    elif shape_type == \"rectangular_prism\":\n        length = dimensions[\"length\"]\n        width = dimensions[\"width\"]\n        height = dimensions[\"height\"]\n        return length * width * height\n    elif shape_type == \"cube\":\n        edge_length = dimensions[\"edge_length\"]\n        return edge_length ** 3\n    elif shape_type == \"octahedron\":\n        edge_length = dimensions[\"edge_length\"]\n        return (math.sqrt(2) / 3) * edge_length ** 3\n    else:\n        raise ValueError(\"Invalid shape type provided\")", "subfield": "Volume of Solids", "tool_name": "calculate_volume", "tool_type": "function", "description": "Calculate the volume of various geometric solids based on given parameters.", "docstring": "Calculate the volume of various geometric solids based on given parameters.\n    \n    Parameters:\n        shape_type (str): Type of shape (\"sphere\", \"rectangular_prism\", \"cube\", \"octahedron\")\n        dimensions (dict): A dictionary containing the required dimensions:\n                           For a sphere: {'radius': r}\n                           For a rectangular prism: {'length': l, 'width': w, 'height': h}\n                           For a cube: {'edge_length': a}\n                           For an octahedron: {'edge_length': a}\n    Returns:\n        float: The volume of the geometric solid.\n    \n    Examples:\n        calculate_volume(\"sphere\", {\"radius\": 3})\n        calculate_volume(\"rectangular_prism\", {\"length\": 5, \"width\": 3, \"height\": 2})\n        calculate_volume(\"cube\", {\"edge_length\": 4})\n        calculate_volume(\"octahedron\", {\"edge_length\": 5})", "Freq": 1, "TSR": 0}, {"tool": "def surface_area_of_rectangular_prism(length, width, height):\n    \n    return 2 * (length * width + width * height + height * length)", "subfield": "Volume of Solids", "tool_name": "surface_area_of_rectangular_prism", "tool_type": "function", "description": "Calculate the surface area of a rectangular prism.", "docstring": "Calculate the surface area of a rectangular prism.\n    Parameters:\n    length (float or int): Length of the rectangular prism.\n    width (float or int): Width of the rectangular prism.\n    height (float or int): Height of the rectangular prism.\n    Returns:\n    float: The surface area of the rectangular prism.\n    Examples:\n    >>> surface_area_of_rectangular_prism(10, 4, 5)\n    220.0\n    >>> surface_area_of_rectangular_prism(7.5, 3.5, 1.5)\n    82.5", "Freq": 3, "TSR": 3}, {"tool": "def volume_rectangular_box(length, width, height):\n    \n    return length * width * height", "subfield": "Volume of Solids", "tool_name": "volume_rectangular_box", "tool_type": "function", "description": "Calculate the volume of a rectangular box.", "docstring": "Calculate the volume of a rectangular box.\n    Parameters:\n    length (float): Length of the box.\n    width (float): Width of the box.\n    height (float): Height of the box.\n    Returns:\n    float: Volume of the rectangular box.\n    Examples:\n    >>> volume_rectangular_box(2, 3, 4)\n    24", "Freq": 2, "TSR": 2}, {"tool": "def volume_difference(volume1, volume2):\n    \n    return abs(volume1 - volume2)", "subfield": "Volume of Solids", "tool_name": "volume_difference", "tool_type": "function", "description": "Calculate the difference in volumes between two solids.", "docstring": "Calculate the difference in volumes between two solids.\n    \n    Parameters:\n    volume1 (float): Volume of the first solid.\n    volume2 (float): Volume of the second solid.\n    \n    Returns:\n    float: The difference in volumes, ensuring it's non-negative.\n    \n    Example:\n    >>> volume_difference(50, 27)\n    23.0", "Freq": 1, "TSR": 0}, {"tool": "def volume_frustum(total_volume, removed_volume):\n    \n    return total_volume - removed_volume", "subfield": "Volume of Solids", "tool_name": "volume_frustum", "tool_type": "function", "description": "Compute the volume of a frustum by subtracting the volume of a smaller shape removed from a larger solid.", "docstring": "Compute the volume of a frustum by subtracting the volume of a smaller shape removed from a larger solid.\n    Parameters:\n    total_volume (float): The original volume of the larger solid before the smaller volume was removed.\n    removed_volume (float): The volume of the smaller solid that was removed.\n    Returns:\n    float: The volume of the frustum.\n    Example:\n    >>> volume_frustum(200, 50)\n    150", "Freq": 4, "TSR": 0, "experience_pool": "- When using the volume_frustum function, make sure not to assign the result to a variable with the same name as the function to avoid reference errors."}, {"tool": "def dihedral_angle_between_planes(plane1_normal, plane2_normal):\n    \n    n1 = sp.Matrix(plane1_normal)\n    n2 = sp.Matrix(plane2_normal)\n    return sp.acos(n1.dot(n2) / (n1.norm() * n2.norm()))", "subfield": "Volume of Solids", "tool_name": "dihedral_angle_between_planes", "tool_type": "function", "description": "Calculate the dihedral angle between two planes given their normal vectors.", "docstring": "Calculate the dihedral angle between two planes given their normal vectors.\n    Parameters:\n        plane1_normal (list of float): the normal vector of the first plane.\n        plane2_normal (list of float): the normal vector of the second plane.\n    Returns:\n        float: the dihedral angle in radians between the two planes.\n    Examples:\n        >>> dihedral_angle_between_planes([0, 0, 1], [0, 1, 0])\n        1.5707963267948966", "Freq": 0, "TSR": 0}, {"tool": "def derive_dimensions_by_volume(total_volume, ratio, initial_dimension):\n    \n    import math\n    # Using the formula for volume of rectangular solids: V = lwh\n    # and for geometric progression if l = a, w = ar, h = ar^2 then V = a * ar * ar^2 = a^3 * r^3\n    # Solving for 'a' we get a = (V / r^3)^(1/3)\n    a = (total_volume / (ratio ** 3)) ** (1/3)\n    length = a\n    width = a * ratio\n    height = a * (ratio ** 2)\n    return (length, width, height)", "subfield": "Volume of Solids", "tool_name": "derive_dimensions_by_volume", "tool_type": "function", "description": "Derive the dimensions of a rectangular solid where the dimensions are in geometric progression,\n    given the total volume and a progression ratio.", "docstring": "Derive the dimensions of a rectangular solid where the dimensions are in geometric progression,\n    given the total volume and a progression ratio.\n    Parameters:\n    - total_volume (float): The total volume of the solid.\n    - ratio (float): The common ratio in the geometric progression of the dimensions.\n    - initial_dimension (float): The initial dimension for the geometric progression (commonly the smallest dimension).\n    Returns:\n    - tuple (float, float, float): Returns the dimensions (length, width, height) of the rectangular solid.\n    Example:\n    >>> derive_dimensions_by_volume(216.0, 2, 3.0)\n    (3.0, 6.0, 12.0)", "Freq": 2, "TSR": 0}, {"tool": "class SolidVolumeCalculator:\n    \"\"\" Class to calculate the volumes of various 3D solids.\n    Methods\n    -------\n    cylinder_volume(radius, height)\n        Calculate the volume of a cylinder.\n    \n    tetrahedron_volume(side_length)\n        Calculate the volume of a regular tetrahedron.\n    pyramid_volume(base_area, height)\n        Calculate the volume of a pyramid.\n    solid_of_revolution(f, a, b)\n        Calculate the volume of a solid of revolution of the function f from x=a to x=b about the x-axis.\n    \"\"\"\n    @staticmethod\n    def cylinder_volume(radius, height):\n        \"\"\"\n        Calculate the volume of a right circular cylinder.\n        Parameters:\n        radius (float or sympy.Symbol): The radius of the cylinder.\n        height (float or sympy.Symbol): The height of the cylinder.\n        Returns:\n        float or sympy.Expr: The volume of the cylinder.\n        Example:\n        >>> SolidVolumeCalculator.cylinder_volume(3, 5)\n        141.3716694115407\n        \"\"\"\n        return math.pi * radius**2 * height\n    @staticmethod\n    def tetrahedron_volume(side_length):\n        \"\"\"\n        Calculate the volume of a regular tetrahedron.\n        Parameters:\n        side_length (float or sympy.Symbol): The length of a side of the tetrahedron.\n        Returns:\n        float or sympy.Expr: The volume of the tetrahedron.\n        Example:\n        >>> SolidVolumeCalculator.tetrahedron_volume(2)\n        0.9428090415820632\n        \"\"\"\n        return side_length**3 / (6 * math.sqrt(2))\n    @staticmethod\n    def pyramid_volume(base_area, height):\n        \"\"\"\n        Calculate the volume of a pyramid with a given base area and height.\n        Parameters:\n        base_area (float or sympy.Symbol): The area of the pyramid's base.\n        height (float or sympy.Symbol): The height of the pyramid.\n        Returns:\n        float or sympy.Expr: The volume of the pyramid.\n        Example:\n        >>> SolidVolumeCalculator.pyramid_volume(10, 3)\n        10.0\n        \"\"\"\n        return base_area * height / 3\n    \n    @staticmethod\n    def solid_of_revolution(f, a, b):\n        \"\"\"\n        Calculate the volume of the solid of revolution of a function f from x=a to x=b about the x-axis.\n        Parameters:\n        f (sympy function): A sympy function of x.\n        a (float or sympo.Symbol): The start of the interval of revolution.\n        b (float or sympy.Symbol): The end of the interval of revolution.\n        Returns:\n        float or sympy.Expr: The volume of the solid of revolution.\n        Example:\n        >>> x = sympy.symbols('x')\n        >>> f = sympy.Lambda(x, sympy.sqrt(1 - x**2))\n        >>> SolidVolumeCalculator.solid_of_revolution(f, -1, 1)\n        (4/3)*pi\n        \"\"\"\n        x = sympy.symbols('x')\n        return sympy.pi * sympy.integrate(f(x)**2, (x, a, b))", "subfield": "Volume of Solids", "tool_name": "SolidVolumeCalculator:\n    \"\"\" Class to calculate the volumes of various 3D solids.\n    Methods\n    -------\n    cylinder_volume", "tool_type": "class", "description": "Class to calculate the volumes of various 3D solids.\n    Methods\n    -------\n    cylinder_volume(radius, height)\n        Calculate the volume of a cylinder.\n    \n    tetrahedron_volume(side_length)\n        Calculate the volume of a regular tetrahedron.\n    pyramid_volume(base_area, height)\n        Calculate the volume of a pyramid.\n    solid_of_revolution(f, a, b)\n        Calculate the volume of a solid of revolution of the function f from x=a to x=b about the x-axis.", "docstring": "Class to calculate the volumes of various 3D solids.\n    Methods\n    -------\n    cylinder_volume(radius, height)\n        Calculate the volume of a cylinder.\n    \n    tetrahedron_volume(side_length)\n        Calculate the volume of a regular tetrahedron.\n    pyramid_volume(base_area, height)\n        Calculate the volume of a pyramid.\n    solid_of_revolution(f, a, b)\n        Calculate the volume of a solid of revolution of the function f from x=a to x=b about the x-axis.", "Freq": 0, "TSR": 0}, {"tool": "def volume_of_revolution(func, axis, start, end):\n    \n    x = Symbol(\"x\")\n    if axis == 'x':\n        return pi * integrate(func**2, (x, start, end))\n    else:\n        # Assuming rotation around the y-axis is the integral of pi*r^2 dx where r = f^-1(y)\n        y = Symbol(\"y\")\n        inverse_func = func.subs(x, y)  # assuming func is invertible and expressed in terms of y\n        return pi * integrate(inverse_func**2, (y, start, end))", "subfield": "Volume of Solids", "tool_name": "volume_of_revolution", "tool_type": "function", "description": "Calculate the volume of a solid of revolution by rotating a function about an axis.", "docstring": "Calculate the volume of a solid of revolution by rotating a function about an axis.\n    Parameters:\n    - func (function): Function of x defining the shape to be revolved.\n    - axis (str): Axis about which the shape is revolved ('x' or 'y').\n    - start (float or Symbol): The start of the interval of revolution.\n    - end (float or Symbol): The end of the interval of revolution.\n    Returns:\n    - sympy expression: The volume of the solid of revolution.\n    Examples:\n    >>> x = symbols('x')\n    >>> f = x**2\n    >>> volume_of_revolution(f, 'x', 0, 2)\n    8*pi/5*2**5", "Freq": 0, "TSR": 0}, {"tool": "def pythagorean_theorem(a=None, b=None, c=None):\n    \n    import math\n    if c is None:  # if hypotenuse is missing\n        return math.sqrt(a**2 + b**2)\n    if a is None:  # if one side is missing\n        return math.sqrt(c**2 - b**2)\n    if b is None:  # if the other side is missing\n        return math.sqrt(c**2 - a**2)", "subfield": "Volume of Solids", "tool_name": "pythagorean_theorem", "tool_type": "function", "description": "Calculate the length of a side of a right triangle using the Pythagorean theorem given the lengths of the other two sides.", "docstring": "Calculate the length of a side of a right triangle using the Pythagorean theorem given the lengths of the other two sides.\n    Parameters:\n    a (float, optional): Length of one side of the right triangle.\n    b (float, optional): Length of the other side of the right triangle.\n    c (float, optional): Length of the hypotenuse of the right triangle.\n    Returns:\n    float: The length of the missing side.\n    Example:\n    >>> pythagorean_theorem(a=3, c=5)\n    4.0\n    >>> pythagorean_theorem(b=4, c=5)\n    3.0", "Freq": 1, "TSR": 1}, {"tool": "def find_missing_dimension(volume, length=None, width=None, height=None):\n    \n    if length is None:\n        missing_dimension = volume / (width * height)\n    elif width is None:\n        missing_dimension = volume / (length * height)\n    elif height is None:\n        missing_dimension = volume / (length * width)\n    else:\n        raise ValueError(\"Only one dimension should be missing.\")\n    return missing_dimension", "subfield": "Volume of Solids", "tool_name": "find_missing_dimension", "tool_type": "function", "description": "Given the volume and any two dimensions of a rectangular prism, calculate the missing dimension.", "docstring": "Given the volume and any two dimensions of a rectangular prism, calculate the missing dimension.\n    Parameters:\n    volume (float or int): The volume of the rectangular solid.\n    length (float or int, optional): The length of the rectangular solid. Defaults to None.\n    width (float or int, optional): The width of the rectangular solid. Defaults to None.\n    height (float or int, optional): The height of the rectangular solid. Defaults to None.\n    Returns:\n    float: The missing dimension of the rectangular solid.\n    Examples:\n    >>> find_missing_dimension(100, length=10, width=5)\n    2.0\n    >>> find_missing_dimension(36, height=1.5, width=3.2)\n    7.5", "Freq": 1, "TSR": 1}, {"tool": "def calculate_geometric_solid_volume(shape_type, dimensions):\n    \n    import math\n    def sphere_volume(radius):\n        \n        return (4/3) * math.pi * radius ** 3\n    def tetrahedron_volume(side_length):\n        \n        return (side_length ** 3) / (6 * math.sqrt(2))\n    def pyramid_volume(base_area, height):\n        \n        return (1/3) * base_area * height\n    if shape_type == \"sphere\":\n        radius = dimensions[\"radius\"]\n        return sphere_volume(radius)\n    elif shape_type == \"tetrahedron\":\n        side_length = dimensions[\"side_length\"]\n        return tetrahedron_volume(side_length)\n    elif shape_type == \"pyramid\":\n        base_area = dimensions[\"base_area\"]\n        height = dimensions[\"height\"]\n        return pyramid_volume(base_area, height)\n    else:\n        raise ValueError(\"Invalid shape type provided\")", "subfield": "Volume of Solids", "tool_name": "calculate_geometric_solid_volume", "tool_type": "function", "description": "Calculate the volume of various geometric solids based on given parameters.", "docstring": "Calculate the volume of various geometric solids based on given parameters.\n    \n    Parameters:\n    shape_type (str): The type of solid (\"sphere\", \"complex_solid\", \"tetrahedron\", \"pyramid\").\n    dimensions (dict): A dictionary containing the necessary dimensions for the calculation.\n    \n    Returns:\n    float: The volume of the specified solid.\n    \n    Example:\n    >>> calculate_geometric_solid_volume(\"sphere\", {\"radius\": 3})\n    113.09733552923255\n    >>> calculate_geometric_solid_volume(\"tetrahedron\", {\"side_length\": 4})\n    10.666666666666666", "Freq": 0, "TSR": 0}, {"tool": "def composite_volume_calculator(shapes):\n    \n    import math\n    \n    def cylinder_volume(radius, height):\n        return math.pi * radius ** 2 * height\n    \n    def cone_volume(radius, height):\n        return (1/3) * math.pi * radius ** 2 * height\n    \n    def pyramid_volume(base_area, height):\n        return (1/3) * base_area * height\n    \n    total_volume = 0\n    \n    for shape in shapes:\n        shape_type = shape['type']\n        dimensions = shape['dimensions']\n        scale = shape.get('scale', 1)  # Default scale to 1 if not provided\n        \n        if shape_type == 'cylinder':\n            volume = cylinder_volume(dimensions['radius'], dimensions['height'])\n        elif shape_type == 'cone':\n            volume = cone_volume(dimensions['radius'], dimensions['height'])\n        elif shape_type == 'pyramid':\n            volume = pyramid_volume(dimensions['base_area'], dimensions['height'])\n        else:\n            raise ValueError(\"Invalid shape type provided\")\n        \n        total_volume += volume * scale  # Apply scaling factor\n    \n    return total_volume", "subfield": "Volume of Solids", "tool_name": "composite_volume_calculator", "tool_type": "function", "description": "Calculate the total volume of a composite shape based on the volumes of its components.", "docstring": "Calculate the total volume of a composite shape based on the volumes of its components.\n    \n    Parameters:\n    shapes (list of dict): A list of dictionaries where each dictionary contains:\n        - 'type' (str): The type of shape (e.g., 'cylinder', 'cone', 'pyramid', etc.)\n        - 'dimensions' (dict): A dictionary of dimensions relevant to the shape type.\n        - 'scale' (float, optional): A scaling factor for the shape's volume.\n    \n    Returns:\n    float: The total volume of the composite shape.\n    \n    Example:\n    >>> shapes = [\n    ...     {'type': 'cylinder', 'dimensions': {'radius': 4, 'height': 10}},\n    ...     {'type': 'cone', 'dimensions': {'radius': 3, 'height': 5}, 'scale': 2}\n    ... ]\n    >>> composite_volume_calculator(shapes)\n    167.552", "Freq": 0, "TSR": 0}, {"tool": "def composite_volume_ratio(shape1, shape2, dimensions1, dimensions2):\n    \n    import math\n    \n    def volume_cone(radius, height):\n        return (1/3) * math.pi * radius ** 2 * height\n    \n    def volume_cylinder(radius, height):\n        return math.pi * radius ** 2 * height\n    \n    def volume_rectangular_prism(length, width, height):\n        return length * width * height\n    \n    volume1 = 0\n    volume2 = 0\n    \n    if shape1 == 'cone':\n        volume1 = volume_cone(dimensions1['radius'], dimensions1['height'])\n    elif shape1 == 'cylinder':\n        volume1 = volume_cylinder(dimensions1['radius'], dimensions1['height'])\n    elif shape1 == 'rectangular_prism':\n        volume1 = volume_rectangular_prism(dimensions1['length'], dimensions1['width'], dimensions1['height'])\n    \n    if shape2 == 'cone':\n        volume2 = volume_cone(dimensions2['radius'], dimensions2['height'])\n    elif shape2 == 'cylinder':\n        volume2 = volume_cylinder(dimensions2['radius'], dimensions2['height'])\n    elif shape2 == 'rectangular_prism':\n        volume2 = volume_rectangular_prism(dimensions2['length'], dimensions2['width'], dimensions2['height'])\n    \n    if volume2 == 0:\n        raise ValueError(\"Volume of shape2 cannot be zero.\")\n    \n    return volume1 / volume2", "subfield": "Volume of Solids", "tool_name": "composite_volume_ratio", "tool_type": "function", "description": "Calculate the ratio of the volumes of two geometric shapes based on their dimensions.", "docstring": "Calculate the ratio of the volumes of two geometric shapes based on their dimensions.\n    \n    Parameters:\n    shape1 (str): The type of the first shape (e.g., 'cone', 'cylinder', 'rectangular_prism').\n    shape2 (str): The type of the second shape (e.g., 'cone', 'cylinder', 'rectangular_prism').\n    dimensions1 (dict): A dictionary containing the dimensions of the first shape.\n    dimensions2 (dict): A dictionary containing the dimensions of the second shape.\n    \n    Returns:\n    float: The ratio of the volume of shape1 to the volume of shape2.\n    \n    Example:\n    >>> composite_volume_ratio('cone', 'cylinder', {'radius': 3, 'height': 5}, {'radius': 3, 'height': 5})\n    0.2", "Freq": 0, "TSR": 0}], "Perimeter": [], "3D Shapes": [], "Transformations": [], "Squares": [], "Planes in Three Dimensions": [], "Similar Triangles": [], "Pythagorean Theorem": [{"tool": "def pythagorean_tools(leg_a=None, leg_b=None, hypotenuse=None, radius=None, hemisphere_radius=None):\n    \n    \n    results = {}\n    \n    def calculate_hypotenuse(leg_a, leg_b):\n        \n        return (leg_a**2 + leg_b**2)**0.5\n    \n    def calculate_missing_leg(hypotenuse, leg_a):\n        \n        missing_leg_squared = hypotenuse**2 - leg_a**2\n        if missing_leg_squared < 0:\n            raise ValueError(\"Hypotenuse must be greater than the known leg.\")\n        return missing_leg_squared**0.5\n    \n    def calculate_cylinder_height(radius, hemisphere_radius):\n        \n        height_squared = hemisphere_radius**2 - radius**2\n        if height_squared < 0:\n            raise ValueError(\"The radius must be less than the hemisphere radius.\")\n        return height_squared**0.5\n    \n    # Calculate hypotenuse if both legs are provided\n    if leg_a is not None and leg_b is not None:\n        results['hypotenuse'] = calculate_hypotenuse(leg_a, leg_b)\n    \n    # Calculate missing leg if hypotenuse and one leg are provided\n    if hypotenuse is not None and leg_a is not None:\n        results['missing_leg'] = calculate_missing_leg(hypotenuse, leg_a)\n    \n    # Calculate height of the cylinder inscribed in a hemisphere\n    if radius is not None and hemisphere_radius is not None:\n        results['cylinder_height'] = calculate_cylinder_height(radius, hemisphere_radius)\n    \n    return results", "subfield": "Pythagorean Theorem", "tool_name": "pythagorean_tools", "tool_type": "function", "description": "A toolset for performing calculations related to the Pythagorean theorem and geometric shapes.", "docstring": "A toolset for performing calculations related to the Pythagorean theorem and geometric shapes.\n    \n    Parameters:\n    leg_a (float): Length of one leg of the right triangle.\n    leg_b (float): Length of the other leg of the right triangle.\n    hypotenuse (float): Length of the hypotenuse of the right triangle.\n    radius (float): Radius of the inscribed cylinder.\n    hemisphere_radius (float): Radius of the hemisphere in which the cylinder is inscribed.\n    \n    Returns:\n    dict: A dictionary containing the results of the calculations, which may include:\n        - 'hypotenuse': Length of the hypotenuse if both legs are provided.\n        - 'missing_leg': Length of the missing leg if one leg and the hypotenuse are provided.\n        - 'cylinder_height': Height of the inscribed cylinder if the radius and hemisphere radius are provided.", "Freq": 4, "TSR": 4}, {"tool": "def triangle_tools(leg_a=None, leg_b=None, hypotenuse=None, angle=None, tangent_ratio=None):\n    \n    \n    results = {}\n    def calculate_hypotenuse(leg_a, leg_b):\n        return (leg_a**2 + leg_b**2)**0.5\n    def calculate_missing_leg(hypotenuse, leg_a):\n        missing_leg_squared = hypotenuse**2 - leg_a**2\n        if missing_leg_squared < 0:\n            raise ValueError(\"Hypotenuse must be greater than the known leg.\")\n        return missing_leg_squared**0.5\n    def calculate_tangent_angle(opposite, adjacent):\n        import math\n        return math.degrees(math.atan(opposite / adjacent))\n    def calculate_hypotenuse_from_tangent(tangent_ratio):\n        opposite, adjacent = tangent_ratio\n        return (opposite**2 + adjacent**2)**0.5\n    # Calculate hypotenuse if both legs are provided\n    if leg_a is not None and leg_b is not None:\n        results['hypotenuse'] = calculate_hypotenuse(leg_a, leg_b)\n    \n    # Calculate missing leg if hypotenuse and one leg are provided\n    if hypotenuse is not None and leg_a is not None:\n        results['missing_leg'] = calculate_missing_leg(hypotenuse, leg_a)\n    \n    # Calculate angle if tangent ratio is provided\n    if tangent_ratio is not None:\n        results['angle'] = calculate_tangent_angle(tangent_ratio[0], tangent_ratio[1])\n    \n    # Calculate hypotenuse from tangent ratio\n    if tangent_ratio is not None:\n        results['hypotenuse_from_tangent'] = calculate_hypotenuse_from_tangent(tangent_ratio)\n    return results", "subfield": "Pythagorean Theorem", "tool_name": "triangle_tools", "tool_type": "function", "description": "A toolset for performing calculations related to right triangles, including finding missing sides,\n    calculating angles, and working with tangent ratios.", "docstring": "A toolset for performing calculations related to right triangles, including finding missing sides,\n    calculating angles, and working with tangent ratios.\n    Parameters:\n    leg_a (float): Length of leg A of the triangle.\n    leg_b (float): Length of leg B of the triangle.\n    hypotenuse (float): Length of the hypotenuse of the triangle.\n    angle (float): Angle in degrees for which calculations are to be performed.\n    tangent_ratio (tuple): A tuple containing the opposite and adjacent sides for tangent calculation.\n    Returns:\n    dict: A dictionary containing the results of the calculations.", "Freq": 2, "TSR": 1}], "Reflections": [], "Trapezoids": [], "Angles": [], "Similarity": [], "Parallelograms": [], "Coordinate Systems": [], "Conic Sections": [], "Quadrilaterals": [], "Ellipse": [{"tool": "def ellipse_area(a, b):\n    \n    return math.pi * a * b", "subfield": "Ellipse", "tool_name": "ellipse_area", "tool_type": "function", "description": "Calculate the area of an ellipse given the lengths of its semi-major and semi-minor axes.", "docstring": "Calculate the area of an ellipse given the lengths of its semi-major and semi-minor axes.\n    \n    Parameters:\n    a (float): length of the semi-major axis.\n    b (float): length of the semi-minor axis.\n    Returns:\n    float: Area of the ellipse.\n    Example:\n    >>> ellipse_area(5, 3)\n    47.12388980384689", "Freq": 0, "TSR": 0}, {"tool": "def ellipse_standard_form(coordinates, a, b, angle=0):\n    \n    if angle != 0:\n        return f\"Rotated by {angle} degrees: Standard equation not directly applicable.\"\n    h, k = coordinates\n    equation = f\"(x-{h})^2/{a**2} + (y-{k})^2/{b**2} = 1\"\n    return equation", "subfield": "Ellipse", "tool_name": "ellipse_standard_form", "tool_type": "function", "description": "Represents the equation of an ellipse in its standard form based on provided parameters.", "docstring": "Represents the equation of an ellipse in its standard form based on provided parameters.\n    \n    Parameters:\n    coordinates : tuple\n        The (x, y) coordinates of the center of the ellipse.\n    a : float\n        The length of the semi-major axis.\n    b : float\n        The length of the semi-minor axis.\n    angle : float, optional\n        The rotation angle of the ellipse in degrees (default is 0).\n    Returns:\n    str\n        A string representing the standard form equation of the ellipse.\n    Examples:\n    >>> ellipse_standard_form((0, 0), 5, 3)\n    'x^2/25 + y^2/9 = 1'\n    >>> ellipse_standard_form((0, 0), 5, 3, 45)\n    'Rotated by 45 degrees: Standard equation not directly applicable.'", "Freq": 0, "TSR": 0}, {"tool": "def ellipse_properties(h, k, a, b):\n    \n    \n    # Calculate the distance to the foci\n    c = math.sqrt(a**2 - b**2)\n    foci = [(h + c, k), (h - c, k)]\n    distance_between_foci = 2 * c\n    \n    # Calculate the area of the ellipse\n    area = math.pi * a * b\n    \n    # Standard form of the ellipse equation\n    standard_form = f\"(x - {h})^2/{a**2} + (y - {k})^2/{b**2} = 1\"\n    \n    return {\n        'foci': foci,\n        'distance_between_foci': distance_between_foci,\n        'area': area,\n        'standard_form': standard_form\n    }", "subfield": "Ellipse", "tool_name": "ellipse_properties", "tool_type": "function", "description": "Calculate various properties of an ellipse given its center (h, k),\n    semi-major axis length (a), and semi-minor axis length (b).", "docstring": "Calculate various properties of an ellipse given its center (h, k),\n    semi-major axis length (a), and semi-minor axis length (b).\n    \n    Parameters:\n    h (float): x-coordinate of the center of the ellipse.\n    k (float): y-coordinate of the center of the ellipse.\n    a (float): length of the semi-major axis.\n    b (float): length of the semi-minor axis.\n    \n    Returns:\n    dict: A dictionary containing the following properties:\n        - 'foci': coordinates of the foci of the ellipse.\n        - 'distance_between_foci': distance between the foci.\n        - 'area': area of the ellipse.\n        - 'standard_form': standard form of the ellipse equation.", "Freq": 2, "TSR": 1}]}