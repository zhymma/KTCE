{"Circles": [{"tool": "def circle_circumference(radius):\n    \n    return 2 * np.pi * radius", "subfield": "Circles", "tool_name": "circle_circumference", "tool_type": "function", "description": "Calculates the circumference of a circle given its radius.", "docstring": "Calculates the circumference of a circle given its radius.\n    \n    Parameters:\n        radius (float): The radius of the circle.\n    Returns:\n        float: The circumference of the circle.", "Freq": 2, "TSR": 0}, {"tool": "def circle_area(radius):\n    \n    return math.pi * radius ** 2", "subfield": "Circles", "tool_name": "circle_area", "tool_type": "function", "description": "Calculate the area of a circle given the radius.", "docstring": "Calculate the area of a circle given the radius.\n    \n    Parameters:\n    - radius (float): The radius of the circle.\n    \n    Returns:\n    - float: The area of the circle.", "Freq": 11.0, "TSR": 2.5}, {"tool": "def circle_standard_form(h, k, r):\n    \n    x, y = sympy.symbols('x y')\n    return sympy.Eq((x - h)**2 + (y - k)**2, r**2)", "subfield": "Circles", "tool_name": "circle_standard_form", "tool_type": "function", "description": "Create the standard form equation of a circle (x-h)^2 + (y-k)^2 = r^2.", "docstring": "Create the standard form equation of a circle (x-h)^2 + (y-k)^2 = r^2.\n    \n    Parameters:\n        h (float): The x-coordinate of the circle's center.\n        k (float): The y-coordinate of the circle's center.\n        r (float): The radius of the circle.\n        \n    Returns:\n        sympy.Eq: The equation of the circle in sympy equation format.\n        \n    Example:\n        >>> print(circle_standard_form(0, 0, 5))\n        Eq(x**2 + y**2, 25)", "Freq": 1, "TSR": 1}, {"tool": "def circle_properties_from_equation(h, k, r_squared):\n    \n    r = sqrt(r_squared)\n    area = pi * r**2\n    circumference = 2 * pi * r\n    return {\n        'center': (h, k),\n        'radius': r.evalf(),\n        'area': area.evalf(),\n        'circumference': circumference.evalf()\n    }", "subfield": "Circles", "tool_name": "circle_properties_from_equation", "tool_type": "function", "description": "Given the parameters h, k (center of the circle) and r_squared (radius squared),\n    returns the center, radius, area, and circumference of the circle.", "docstring": "Given the parameters h, k (center of the circle) and r_squared (radius squared),\n    returns the center, radius, area, and circumference of the circle.\n    \n    Parameters:\n        h (float): x-coordinate of the center of the circle\n        k (float): y-coordinate of the center of the circle\n        r_squared (float): square of the radius of the circle\n    Returns:\n        dict: Dictionary containing the center, radius, area, and circumference\n    \n    Examples:\n    >>> circle_properties_from_equation(0, 0, 25)\n    {'center': (0, 0), 'radius': 5.0, 'area': 78.5398, 'circumference': 31.4159}", "Freq": 4, "TSR": 2, "experience_pool": "Experience 1:\nProblem: What is the area of a circle with a radius of 7?\nAnswer: 153.93804002589985\n\nExperience 2:\nProblem: Calculate the circumference of a circle with a radius of 10.\nAnswer: 62.83185307179586"}, {"tool": "def point_inside_circle(center, radius, point):\n    \n    return np.sqrt((point[0] - center[0])**2 + (point[1] - center[1])**2) <= radius", "subfield": "Circles", "tool_name": "point_inside_circle", "tool_type": "function", "description": "Determine if a point is inside a given circle.", "docstring": "Determine if a point is inside a given circle.\n    \n    Parameters:\n    - center (tuple): The (x, y) coordinates of the circle's center.\n    - radius (float): The radius of the circle.\n    - point (tuple): The (x, y) coordinates of the point to check.\n    \n    Returns:\n    - bool: True if the point is inside the circle, False otherwise.", "Freq": 0, "TSR": 0}, {"tool": "def circle_properties(radius, chord_length=None, angle_radians=None):\n    area = math.pi * radius**2\n    circumference = 2 * math.pi * radius\n    properties = {\n        'Area': area,\n        'Circumference': circumference\n    }\n    if chord_length is not None:\n        if angle_radians is None:\n            angle_radians = 2 * math.acos(chord_length / (2 * radius))\n        sagitta = radius * (1 - math.cos(angle_radians / 2))\n        arc_length = radius * angle_radians\n        segment_area = (radius**2 / 2) * (angle_radians - math.sin(angle_radians))\n        \n        properties.update({\n            'Chord Length': chord_length,\n            'Sagitta': sagitta,\n            'Arc Length': arc_length,\n            'Segment Area': segment_area\n        })\n    return properties", "subfield": "Circles", "tool_name": "circle_properties", "tool_type": "function", "description": "None", "docstring": null, "Freq": 2.5, "TSR": 2}, {"tool": "def compute_triangle_properties(vertices):\n    \n    vertices = np.array(vertices)\n    side_lengths = np.linalg.norm(vertices - np.roll(vertices, -1, axis=0), axis=1)\n    s = np.sum(side_lengths) / 2  # semi-perimeter\n    area = np.sqrt(s * np.prod(s - side_lengths))  # Heron's formula\n    is_iso = np.any(side_lengths[0] == side_lengths[1]) or np.any(side_lengths[1] == side_lengths[2])\n    is_equi = np.all(side_lengths[0] == side_lengths[1])\n    properties = {\n        'Area': area,\n        'Perimeter': 2 * s,\n        'Side Lengths': side_lengths,\n        'Isosceles': is_iso,\n        'Equilateral': is_equi\n    }\n    return properties", "subfield": "Circles", "tool_name": "compute_triangle_properties", "tool_type": "function", "description": "Compute properties of a triangle given its vertices.", "docstring": "Compute properties of a triangle given its vertices.\n    Parameters:\n        vertices (array): An array of three tuples, each representing x, y coordinates of a vertex.\n    Returns:\n        dict: Properties including area, perimeter, side lengths, and types of triangle (isosceles, equilateral).", "Freq": 2, "TSR": 1, "experience_pool": "- Problem: Triangle $ABC$ has side lengths $AB=4$, $BC=5$, and $CA=6$. Points $D$ and $E$ are on ray $AB$ with $AB<AD<AE$. The point $F \\neq C$ is a point of intersection of the circumcircles of $\\triangle ACD$ and $\\triangle EBC$ satisfying $DF=2$ and $EF=7$. Then $BE$ can be expressed as $\\tfrac{a+b\\sqrt{c}}{d}$, where $a$, $b$, $c$, and $d$ are positive integers such that $a$ and $d$ are relatively prime, and $c$ is not divisible by the square of any prime. Find $a+b+c+d$.\n\n- Solution: The error in the solution code is due to the missing variables DF and EF. These variables need to be defined before using them in the equation for DE_squared. To fix the error, the solution code should include the definitions of DF and EF before calculating DE_squared.\n\n```python\n# Given side lengths of the triangle\nAB = 4\nBC = 5\nCA = 6\n\n# Compute the area of the triangle using Heron's formula\nvertices = [(0, 0), (AB, 0), (CA - (BC**2 - AB**2 - CA**2) / (2 * CA), (BC**2 - (CA - (BC**2 - AB**2 - CA**2) / (2 * CA))**2)**0.5)]\ntriangle_properties = compute_triangle_properties(vertices)\narea_ABC = triangle_properties['Area']\n\n# Define DF and EF\nDF = 2\nEF = 7\n\n# Compute DE using Law of Cosines\nDE_squared = DF**2 + EF**2 - 2 * DF * EF * cos(180 - B - A)\nDE = sqrt(DE_squared)\n\n# Compute a and b\na = symbols('a')\nb = a * sqrt(2)\neq = Eq(b * (a + 4), a * (b + 4 * sqrt(2)))\na_value = solve(eq, a)[0]\n\n# Compute BE\nBE = a_value + a_value * sqrt(2) + 4 * sqrt(2)\n\n# Calculate the final result\nresult = int(BE.as_numer_denom()[0]) + int(BE.as_numer_denom()[1]) + int(BE.as_numer_denom()[1].as_numer_denom()[0]) + int(BE.as_numer_denom()[1].as_numer_denom()[1])\nreturn result\n```"}, {"tool": "def find_curve_equation(radius):\n    \n    if radius == 0:\n        return \"Point\"\n    elif radius > 0:\n        return \"Circle\"\n    else:\n        return \"No curve\"", "subfield": "Circles", "tool_name": "find_curve_equation", "tool_type": "function", "description": "Find the curve defined by the equation r = radius.", "docstring": "Find the curve defined by the equation r = radius.\n    Parameters:\n    radius (float): The radius of the circle.\n    Returns:\n    str: The geometric shape based on the given equation.", "Freq": 0, "TSR": 0}], "Coordinate Geometry": [{"tool": "def distance_between_points(point1, point2):\n    \n    x1, y1 = point1\n    x2, y2 = point2\n    return ((x2 - x1)**2 + (y2 - y1)**2)**0.5", "subfield": "Coordinate Geometry", "tool_name": "distance_between_points", "tool_type": "function", "description": "Calculate the Euclidean distance between two points in the plane.", "docstring": "Calculate the Euclidean distance between two points in the plane.\n    \n    Parameters:\n    - point1 (tuple): The first point (x1, y1).\n    - point2 (tuple): The second point (x2, y2).\n    \n    Returns:\n    - float: The distance between the points.\n    \n    Examples:\n    >>> distance_between_points((1, 2), (4, 6))\n    5.0", "Freq": 82, "TSR": 55, "experience_pool": "Tool: distance_between_points\nField: Geometry\nSubfield: Coordinate Geometry\nTool Usage Frequency: 35\nTool Success Rate: 68.57%\nTool docstring: Calculate the Euclidean distance between two points in the plane.\n\nParameters:\n- point1 (tuple): The first point (x1, y1).\n- point2 (tuple): The second point (x2, y2).\n\nReturns:\n- float: The distance between the points.\n\nExamples:\n>>> distance_between_points((1, 2), (4, 6))\n5.0"}, {"tool": "def midpoint(p1, p2):\n    \n    return tuple((np.array(p1) + np.array(p2)) / 2)", "subfield": "Coordinate Geometry", "tool_name": "midpoint", "tool_type": "function", "description": "Calculates the midpoint between two points in a 2D coordinate system.", "docstring": "Calculates the midpoint between two points in a 2D coordinate system.\n    Parameters:\n    - p1: Tuple of coordinates (x1, y1) for the first point.\n    - p2: Tuple of coordinates (x2, y2) for the second point.\n    Returns:\n    - Tuple: Coordinates of the midpoint.\n    Example:\n    >>> midpoint((1, 2), (3, 4))\n    (2.0, 3.0)", "Freq": 37, "TSR": 26, "experience_pool": "- Problem: Point M(3,7) is the midpoint of line segment AB. If point A has coordinates (9,3), what is the sum of the coordinates of point B?\n  - Answer: 8\n  - The solution function correctly calculates the sum of the coordinates of point B using the midpoint formula.\n- Problem: Point M(4,4) is the midpoint of line segment AB. If point A has coordinates (8,4), what is the sum of the coordinates of point B?\n  - Answer: 4\n  - The solution function correctly calculates the sum of the coordinates of point B using the midpoint formula.\n- Problem: In a polar coordinate system, the midpoint of the line segment whose endpoints are (8, 5pi/12) and (8, -3pi/12) is the point (r, theta). Enter (r, theta), where r > 0 and 0 <= theta < 2pi.\n  - Answer: (4, pi/12)\n  - The solution function correctly calculates the midpoint coordinates using the given endpoints.\n- Problem: In convex quadrilateral ABCD, AB=BC=13, CD=DA=24, and angle D=60 degrees. Points X and Y are the midpoints of BC and DA respectively. Compute XY^2 (the square of the length of XY).\n  - Answer: 1033/4 + 30sqrt(3)\n  - The solution function correctly calculates the square of the length of XY using the midpoint formula and distance formula.\n- Problem: In square ABCD, AD is 4 centimeters, and M is the midpoint of CD. Let O be the intersection of AC and BM. What is the ratio of OC to OA? Express your answer as a common fraction.\n  - Answer: 1/2\n  - The solution function correctly calculates the ratio of OC to OA using the midpoint formula and line intersection formula."}, {"tool": "def slope_of_line(p1, p2):\n    \n    x1, y1 = p1\n    x2, y2 = p2\n    if x2 == x1:\n        raise ValueError(\"Vertical line segment has no slope.\")\n    return (y2 - y1) / (x2 - x1)", "subfield": "Coordinate Geometry", "tool_name": "slope_of_line", "tool_type": "function", "description": "Computes the slope of the line segment connecting two points. Raises exception if the line is vertical.", "docstring": "Computes the slope of the line segment connecting two points. Raises exception if the line is vertical.\n    Parameters:\n    - p1: Tuple of coordinates (x1, y1)\n    - p2: Tuple of coordinates (x2, y2)\n    Returns:\n    - float: Slope of the line.\n    Example:\n    >>> slope_of_line((1, 2), (3, 6))\n    2.0", "Freq": 31, "TSR": 20}, {"tool": "def area_of_triangle(p1, p2, p3):\n    if len(p1) == 2:\n        x1, y1 = p1\n        x2, y2 = p2\n        x3, y3 = p3\n        return 0.5 * abs(x1*(y2 - y3) + x2*(y3 - y1) + x3*(y1 - y2))\n    elif len(p1) == 3:\n        x1, y1, z1 = p1\n        x2, y2, z2 = p2\n        x3, y3, z3 = p3\n        return 0.5 * abs(x1*(y2*z3 - y3*z2) + x2*(y3*z1 - y1*z3) + x3*(y1*z2 - y2*z1))\n    else:\n        raise ValueError(\"Invalid number of coordinates for vertices.\")", "subfield": "Coordinate Geometry", "tool_name": "area_of_triangle", "tool_type": "function", "description": "None", "docstring": null, "Freq": 23.0, "TSR": 9.0}, {"tool": "def reflect(point, axis=\"x\"):\n    \n    x, y = point\n    if axis == \"x\":\n        return (x, -y)\n    elif axis == \"y\":\n        return (-x, y)\n    elif axis == \"origin\":\n        return (-x, -y)\n    elif axis == \"y=x\":\n        return (y, x)\n    else:\n        raise ValueError(\"Invalid axis specified.\")", "subfield": "Coordinate Geometry", "tool_name": "reflect", "tool_type": "function", "description": "Reflect a point across a specified axis in 2D.", "docstring": "Reflect a point across a specified axis in 2D.\n    \n    Parameters:\n        point (tuple): Coordinates (x, y) of the point.\n        axis (str): Axis you want to reflect over, \"x\", \"y\", or \"origin\". Additionally supports \"y=x\".\n    \n    Returns:\n        tuple: Coordinates of the reflected point.\n        \n    Examples:\n        reflect((2, 3), axis=\"x\")\n        reflect((2, 3), axis=\"y\")\n        reflect((2, 3), axis=\"origin\")\n        reflect((2, 3), axis=\"y=x\")", "Freq": 11, "TSR": 10, "experience_pool": "- Reflecting a point across the x-axis: reflect((2, 3), axis=\"x\") returns (2, -3)\n- Reflecting a point across the y-axis: reflect((2, 3), axis=\"y\") returns (-2, 3)\n- Reflecting a point across the origin: reflect((2, 3), axis=\"origin\") returns (-2, -3)\n- Reflecting a point across the line y=x: reflect((2, 3), axis=\"y=x\") returns (3, 2)"}, {"tool": "def convert_conic_to_standard_form(eq_type, coefficients):\n    \n    \n    import math\n    if eq_type in ['circle', 'ellipse']:\n        A = coefficients.get('x^2', 0)\n        B = coefficients.get('y^2', 0)\n        C = coefficients.get('x', 0)\n        D = coefficients.get('y', 0)\n        E = coefficients.get('constant', 0)\n        h = -C / (2 * A)\n        k = -D / (2 * B)\n        r_squared = -E + (C**2) / (4 * A) + (D**2) / (4 * B)\n        if eq_type == 'circle':\n            return {'center': (h, k), 'radius': math.sqrt(r_squared)}\n        elif eq_type == 'ellipse':\n            return {'center': (h, k), 'semi_major_axis': math.sqrt(r_squared / A), 'semi_minor_axis': math.sqrt(r_squared / B)}\n    elif eq_type == 'parabola':\n        # Assume coefficients of 'x^2' or 'y^2' and a linear term for directrix/vertex form conversion.\n        pass\n    elif eq_type == 'hyperbola':\n        A = coefficients.get('x^2', 0)\n        B = coefficients.get('y^2', 0)\n        C = coefficients.get('x', 0)\n        D = coefficients.get('y', 0)\n        E = coefficients.get('constant', 0)\n        h = -C / (2 * A)\n        k = -D / (2 * B)\n        r_squared = -E + (C**2) / (4 * A) - (D**2) / (4 * B)\n        return {'center': (h, k), 'semi_major_axis': math.sqrt(r_squared / A), 'semi_minor_axis': math.sqrt(r_squared / B)}\n    \n    return {}", "subfield": "Coordinate Geometry", "tool_name": "convert_conic_to_standard_form", "tool_type": "function", "description": "Converts a general equation of a conic section (circle, ellipse, parabola, hyperbola) to its standard form.", "docstring": "Converts a general equation of a conic section (circle, ellipse, parabola, hyperbola) to its standard form.\n    \n    Parameters:\n    - eq_type (str): Type of conic ('circle', 'ellipse', 'parabola', 'hyperbola').\n    - coefficients (dict): Coefficients of the equation. E.g., for a circle: {'x^2': 1, 'y^2': 1, 'x': -6, 'y': 4, 'constant': -3}\n    \n    Returns:\n    - dict: Standardized form parameters.\n    \n    Example:\n    >>> convert_conic_to_standard_form('circle', {'x^2': 1, 'y^2': 1, 'x': -6, 'y': 4, 'constant': -3})\n    {'center': (3, -2), 'radius': 4}", "Freq": 4.5, "TSR": 1}, {"tool": "def calculate_area_of_square(side_length):\n    \n    return side_length**2", "subfield": "Coordinate Geometry", "tool_name": "calculate_area_of_square", "tool_type": "function", "description": "Calculate the area of a square given the side length.", "docstring": "Calculate the area of a square given the side length.\n    \n    Parameters:\n        side_length (float or sympy expression): The length of the side of the square.\n    \n    Returns:\n        float or sympy expression: The area of the square.\n    Example:\n        area = calculate_area_of_square(5)\n        print(area)  # Output: 25", "Freq": 9, "TSR": 7, "experience_pool": "The side length of the square AE should be calculated as side_length_BE * sqrt(2) since AE is the diagonal of the square ABCD.\nThe sum_of_areas should be calculated as (area_AB + area_AE)**2."}, {"tool": "def calculate_area(shape, *args):\n    \n    if shape == 'circle':\n        radius = args[0]\n        return math.pi * radius**2\n    elif shape == 'rectangle':\n        length = args[0]\n        width = args[1]\n        return length * width\n    elif shape == 'triangle':\n        base = args[0]\n        height = args[1]\n        return 0.5 * base * height\n    else:\n        return \"Invalid shape\"", "subfield": "Coordinate Geometry", "tool_name": "calculate_area", "tool_type": "function", "description": "Calculates the area of a geometric shape.", "docstring": "Calculates the area of a geometric shape.\n    Parameters:\n    shape (str): The shape of the object ('circle', 'rectangle', 'triangle', etc.)\n    *args: Variable length arguments depending on the shape. For example, for a circle, pass the radius as the argument.\n    Returns:\n    float: The area of the geometric shape.", "Freq": 8.5, "TSR": 5, "experience_pool": "- Experience 1:\n    - Field: Geometry\n    - Subfield: Coordinate Geometry\n    - Tool Usage Frequency: 3\n    - Tool Success Rate: 66.66666666666666%\n    - Tool docstring: Calculates the area of a circle given its radius.\n    - Tool code:\n        ```python\n        def circle_area(radius):\n            return np.pi * radius**2\n        ```\n    - Problem: The graph of \\(r = -2 \\cos \\theta + 6 \\sin \\theta\\) is a circle. Find the area of the circle.\n    - Answer: 10 \\pi\n    - Solution:\n        ```python\n        from sympy import Symbol, sqrt\n\n        def solution():\n            # Calculate the radius of the circle\n            r = sqrt(10) / 2\n\n            # Calculate the area of the circle\n            area_circle = calculate_area('circle', r)\n\n            return area_circle\n\n        # Print the result\n        print(solution())\n        ```\n    - Output: 7.85398163397448"}, {"tool": "def vector_add(v1, v2):\n    \n    return np.add(v1, v2)", "subfield": "Coordinate Geometry", "tool_name": "vector_add", "tool_type": "function", "description": "Adds two vectors.", "docstring": "Adds two vectors.\n    Parameters:\n    v1 (ndarray): A numpy array representing the first vector.\n    v2 (ndarray): A numpy array representing the second vector.\n    Returns:\n    ndarray: The vector sum of v1 and v2.", "Freq": 0, "TSR": 0}, {"tool": "def circle_equation(h, k, r):\n    \n    return f\"(x - {h})^2 + (y - {k})^2 = {r}^2\"", "subfield": "Coordinate Geometry", "tool_name": "circle_equation", "tool_type": "function", "description": "Returns the standard form equation of a circle given the center (h, k) and radius r.", "docstring": "Returns the standard form equation of a circle given the center (h, k) and radius r.\n    Parameters:\n    h (float): The x-coordinate of the center.\n    k (float): The y-coordinate of the center.\n    r (float): The radius of the circle.\n    Returns:\n    str: The equation of the circle in standard form.\n    Examples:\n    >>> circle_equation(0, 0, 1)\n    '(x - 0)^2 + (y - 0)^2 = 1^2'", "Freq": 0, "TSR": 0}, {"tool": "def line_equation_from_point_slope(point, slope):\n    \n    x, y = point\n    c = y - slope * x\n    return slope, c", "subfield": "Coordinate Geometry", "tool_name": "line_equation_from_point_slope", "tool_type": "function", "description": "Find the equation of a line in slope-intercept form 'y = mx + c' given a point and a slope.", "docstring": "Find the equation of a line in slope-intercept form 'y = mx + c' given a point and a slope.\n    \n    Parameters:\n    - point (tuple): Point (x, y) through which the line passes.\n    - slope (float): Slope of the line.\n    \n    Returns:\n    - tuple: slope m and intercept c of the line 'y = mx + c'.\n    \n    Examples:\n    >>> line_equation_from_point_slope((1, 2), 3)\n    (3, -1)", "Freq": 10, "TSR": 7, "experience_pool": "Experience 1:\nProblem: Find the equation of a line passing through the points (2, 3) and (4, 5).\nSolution: We can use the line_equation_from_point_slope function to find the equation of the line.\n```python\npoint1 = (2, 3)\npoint2 = (4, 5)\nslope = (point2[1] - point1[1]) / (point2[0] - point1[0])\nequation = line_equation_from_point_slope(point1, slope)\nprint(equation)\n```\nOutput: (1, 1)\n\nExperience 2:\nProblem: Find the equation of a line passing through the points (-1, 2) and (3, 4).\nSolution: We can use the line_equation_from_point_slope function to find the equation of the line.\n```python\npoint1 = (-1, 2)\npoint2 = (3, 4)\nslope = (point2[1] - point1[1]) / (point2[0] - point1[0])\nequation = line_equation_from_point_slope(point1, slope)\nprint(equation)\n```\nOutput: (0.5, 2.5)"}, {"tool": "def vector_subtract(v1, v2):\n    \n    return np.subtract(v1, v2)", "subfield": "Coordinate Geometry", "tool_name": "vector_subtract", "tool_type": "function", "description": "Subtracts the second vector from the first.", "docstring": "Subtracts the second vector from the first.\n    Parameters:\n    v1 (ndarray): A numpy array representing the first vector.\n    v2 (ndarray): A numpy array representing the second vector.\n    Returns:\n    ndarray: The vector result of v1 - v2.", "Freq": 1, "TSR": 0}, {"tool": "def midpoint(point1, point2):\n    \n    return (np.array(point1) + np.array(point2)) / 2", "subfield": "Coordinate Geometry", "tool_name": "midpoint", "tool_type": "function", "description": "Calculate the midpoint between two points in n-dimensional space.", "docstring": "Calculate the midpoint between two points in n-dimensional space.\n    Parameters:\n        point1 (array-like): The first point coordinates.\n        point2 (array-like): The second point coordinates.\n    Returns:\n        ndarray: The coordinates of the midpoint.\n    Examples:\n        >>> midpoint([1, 2], [3, 4])\n        array([2., 3.])", "Freq": 1, "TSR": 0}, {"tool": "def point_line_position(point, line):\n    \n    x, y = point\n    m, c = line\n    line_y = m * x + c\n    if y > line_y:\n        return 'above'\n    elif y < line_y:\n        return 'below'\n    else:\n        return 'on'", "subfield": "Coordinate Geometry", "tool_name": "point_line_position", "tool_type": "function", "description": "Determine the relative position of a point with respect to a line.", "docstring": "Determine the relative position of a point with respect to a line.\n    \n    Parameters:\n    - point (tuple): The point (x, y).\n    - line (tuple): The slope and intercept (m, c) of the line.\n    \n    Returns:\n    - str: 'above', 'below' or 'on' the line\n    \n    Examples:\n    >>> point_line_position((3, 4), (1, 1))\n    'above'", "Freq": 1, "TSR": 1}, {"tool": "def vector_from_points(point1, point2):\n    \n    return np.array(point2) - np.array(point1)", "subfield": "Coordinate Geometry", "tool_name": "vector_from_points", "tool_type": "function", "description": "Calculate the vector from point1 to point2 in 3D.", "docstring": "Calculate the vector from point1 to point2 in 3D.\n    \n    Parameters:\n    - point1 (array-like): Coordinates of the first point.\n    - point2 (array-like): Coordinates of the second point.\n    \n    Returns:\n    - numpy.ndarray: The vector from point1 to point2.\n    \n    Example:\n    >>> vector_from_points([1, 2, 3], [4, 5, 6])\n    array([3, 3, 3])", "Freq": 2, "TSR": 2}, {"tool": "def circle_equation(center, radius):\n    \n    x, y = symbols('x y')\n    x0, y0 = center\n    return Eq((x - x0)**2 + (y - y0)**2, radius**2)", "subfield": "Coordinate Geometry", "tool_name": "circle_equation", "tool_type": "function", "description": "Generate the equation of a circle given the center and radius.", "docstring": "Generate the equation of a circle given the center and radius.\n    Parameters:\n        center (tuple): Coordinates of the center of the circle (x, y).\n        radius (float): The radius of the circle.\n    Returns:\n        sympy.Eq: The equation of the circle.\n    Examples:\n        >>> circle_equation((0, 0), 5)\n        Eq(x**2 + y**2, 25)", "Freq": 0, "TSR": 0}, {"tool": "def square_side_from_diagonal(diagonal):\n    \n    return diagonal / np.sqrt(2)", "subfield": "Coordinate Geometry", "tool_name": "square_side_from_diagonal", "tool_type": "function", "description": "Calculate the side length of a square given the diagonal, using the Pythagorean theorem.", "docstring": "Calculate the side length of a square given the diagonal, using the Pythagorean theorem.\n    Parameters:\n    diagonal (float): The length of the diagonal of the square.\n    Returns:\n    float: The length of one side of the square.\n    Examples:\n    >>> square_side_from_diagonal(5.656854249492381)\n    4.0", "Freq": 0, "TSR": 0}, {"tool": "def vector_magnitude(vector):\n    \n    return np.linalg.norm(vector)", "subfield": "Coordinate Geometry", "tool_name": "vector_magnitude", "tool_type": "function", "description": "Calculates the magnitude (norm) of a vector.", "docstring": "Calculates the magnitude (norm) of a vector.\n    Parameters:\n    vector (ndarray): The vector whose magnitude is to be calculated.\n    Returns:\n    float: The magnitude of the vector.", "Freq": 0, "TSR": 0}, {"tool": "def parametric_point_evaluation(param_eqs, t_values):\n    \n    results = []\n    for t_value in t_values:\n        point = {var: eq.subs('t', t_value) for var, eq in param_eqs.items()}\n        results.append(point)\n    return results", "subfield": "Coordinate Geometry", "tool_name": "parametric_point_evaluation", "tool_type": "function", "description": "Evaluate parametric equations at given parameter values.", "docstring": "Evaluate parametric equations at given parameter values.\n    \n    Parameters:\n        param_eqs (dict): A dictionary with variables as keys and their parametric equations as values.\n        t_values (list or scalar): A scalar or list of values to substitute into the parametric equations.\n    \n    Returns:\n        list or dict: Evaluated points at each parameter value.\n    \n    Example:\n        x, y, t = symbols('x y t')\n        param_eqs = {x: t**2, y: t + 1}\n        points = parametric_point_evaluation(param_eqs, [0, 1, 2])\n        print(points)  # Output: [{x: 0, y: 1}, {x: 1, y: 2}, {x: 4, y: 3}]", "Freq": 0, "TSR": 0}, {"tool": "def solve_linear_equations(A, b):\n    \n    try:\n        A = np.array(A)\n        b = np.array(b)\n        x = np.linalg.solve(A, b)\n        return x\n    except np.linalg.LinAlgError:\n        return \"Singular matrix\"", "subfield": "Coordinate Geometry", "tool_name": "solve_linear_equations", "tool_type": "function", "description": "Solve a system of linear equations Ax = b for x using NumPy.", "docstring": "Solve a system of linear equations Ax = b for x using NumPy.\n    Parameters:\n    - A (array-like): coefficient matrix.\n    - b (array-like): constant terms.\n    Returns:\n    - array: solution vector x.", "Freq": 3, "TSR": 1, "experience_pool": "- Problem: In triangle $ABC,$ $D$ lies on $\\overline{BC}$ extended past $C$ such that $BD:DC = 3:1,$ and $E$ lies on $\\overline{AC}$ such that $AE:EC = 5:3.$  Let $P$ be the intersection of lines $BE$ and $AD.$\n\n[asy]\nunitsize(0.8 cm);\n\npair A, B, C, D, E, F, P;\n\nA = (1,4);\nB = (0,0);\nC = (6,0);\nD = interp(B,C,3/2);\nE = interp(A,C,5/8);\nP = extension(A,D,B,E);\n\ndraw(A--B--C--cycle);\ndraw(A--D--C);\ndraw(B--P);\n\nlabel(\"$A$\", A, N);\nlabel(\"$B$\", B, SW);\nlabel(\"$C$\", C, S);\nlabel(\"$D$\", D, SE);\nlabel(\"$E$\", E, S);\nlabel(\"$P$\", P, NE);\n[/asy]\n\nThen\n\\[\\overrightarrow{P} = x \\overrightarrow{A} + y \\overrightarrow{B} + z \\overrightarrow{C},\\]where $x,$ $y,$ and $z$ are constants such that $x + y + z = 1.$  Enter the ordered triple $(x,y,z).$\nAnswer: \\left( \\frac{9}{19}, -\\frac{5}{19}, \\frac{15}{19} \\right)\n\n- Problem: For certain ordered pairs $(a,b)\\,$ of real numbers, the system of equations\n\\[\\begin{aligned} ax+by&=1 \\\\ x^2 + y^2 &= 50  \\end{aligned}\\]has at least one solution, and each solution is an ordered pair $(x,y)\\,$ of integers. How many such ordered pairs $(a,b)\\,$ are there?\nAnswer: 72"}, {"tool": "def point_on_line(line, point):\n    \n    m, c = line\n    x, y = point\n    return y == m * x + c", "subfield": "Coordinate Geometry", "tool_name": "point_on_line", "tool_type": "function", "description": "Determines whether a given point lies on a specified line.", "docstring": "Determines whether a given point lies on a specified line.\n    Parameters\n    ----------\n    line : tuple\n        Coefficients (m, c) of the line equation y = mx + c.\n    point : tuple\n        Coordinates of the point (x, y).\n    \n    Returns\n    -------\n    bool\n        True if the point lies on the line, False otherwise.\n    \n    Examples\n    --------\n    >>> point_on_line((2, 1), (1, 3))\n    True", "Freq": 0, "TSR": 0}, {"tool": "def reflection_point_across_line(line, point):\n    \n    m, c = line\n    x, y = point\n    d = (x + (y - c) * m) / (1 + m**2)\n    x_ref = 2*d - x\n    y_ref = 2*d*m - y + 2*c\n    return (x_ref, y_ref)", "subfield": "Coordinate Geometry", "tool_name": "reflection_point_across_line", "tool_type": "function", "description": "Finds the reflection of a point across a given line.", "docstring": "Finds the reflection of a point across a given line.\n    Parameters\n    ----------\n    line : tuple\n        Coefficients (m, c) of the line equation y = mx + c.\n    point : tuple\n        Coordinates of the point (x, y).\n    Returns\n    -------\n    tuple\n        Coordinates (x', y') of the reflected point.\n    Examples\n    --------\n    >>> reflection_point_across_line((1, 1), (2, 3))\n    (-1.0, 0.0)", "Freq": 2, "TSR": 1, "experience_pool": "- Experience 1:\n    - Problem: The reflect function is being used, which is not defined in the original tool code.\n    - Solution: Add a new reflect function to the tool code.\n- Experience 2:\n    - Problem: The line_translation parameter is being passed as a tuple (1, 0) to the reflection_point_across_line function, which expects the line equation coefficients (m, c).\n    - Solution: Update the code to handle the line_translation parameter correctly."}, {"tool": "def compute_conic_properties(eq_type, standard_params):\n    \n    import math\n    if eq_type == 'circle':\n        center = standard_params['center']\n        radius = standard_params['radius']\n        return {'center': center, 'foci': [center, center], 'radius': radius}\n    elif eq_type == 'ellipse':\n        # Calculate foci, vertices based on semi-major/minor axes.\n        pass\n    elif eq_type == 'parabola':\n        # Vertex, focus calculation.\n        pass\n    elif eq_type == 'hyperbola':\n        # Center, foci, vertices, and asymptotes.\n        pass\n    return {}", "subfield": "Coordinate Geometry", "tool_name": "compute_conic_properties", "tool_type": "function", "description": "Compute geometric properties such as center, foci, vertices, depending on the conic type.", "docstring": "Compute geometric properties such as center, foci, vertices, depending on the conic type.\n    Parameters:\n    - eq_type (str): Type of conic ('circle', 'ellipse', 'parabola', 'hyperbola').\n    - standard_params (dict): Parameters obtained from the standard form conversion.\n    Returns:\n    - dict: Detailed conic properties.\n    Example:\n    >>> compute_conic_properties('circle', {'center': (3, -2), 'radius': 4})\n    {'center': (3, -2), 'foci': [(3, -2), (3, -2)], 'radius': 4}", "Freq": 3, "TSR": 0}, {"tool": "def rectangle_properties(length, width):\n    \n    import math\n    perimeter = 2 * (length + width)\n    area = length * width\n    diagonal = math.sqrt(length**2 + width**2)\n    return {'perimeter': perimeter, 'area': area, 'diagonal': diagonal}", "subfield": "Coordinate Geometry", "tool_name": "rectangle_properties", "tool_type": "function", "description": "Calculate various properties of a rectangle given its length and width.", "docstring": "Calculate various properties of a rectangle given its length and width.\n    Parameters:\n    - length (float): The length of the rectangle.\n    - width (float): The width of the rectangle.\n    Returns:\n    - dict: Dictionary containing the perimeter, area, and diagonal of the rectangle.\n    Examples:\n    >>> rectangle_properties(4, 3)\n    {'perimeter': 14, 'area': 12, 'diagonal': 5.0}", "Freq": 0, "TSR": 0}, {"tool": "def circle_equation(cartesian_point_hk, radius):\n    \n    h, k = cartesian_point_hk\n    def equation(x, y):\n        return (x - h)**2 + (y - k)**2 - radius**2\n    return equation", "subfield": "Coordinate Geometry", "tool_name": "circle_equation", "tool_type": "function", "description": "Provides the equation of a circle in Cartesian coordinates.", "docstring": "Provides the equation of a circle in Cartesian coordinates.\n    Parameters:\n    cartesian_point_hk (tuple): (h, k) the center of the circle in Cartesian coordinates\n    radius (float): the radius of the circle\n    Returns:\n    function: Function that calculates (x - h)² + (y - k)² - r² for given x, y", "Freq": 1, "TSR": 1}, {"tool": "def distance(x1, y1, x2, y2):\n    \n    return sp.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2)", "subfield": "Coordinate Geometry", "tool_name": "distance", "tool_type": "function", "description": "Calculate the Euclidean distance between two points (x1, y1) and (x2, y2).", "docstring": "Calculate the Euclidean distance between two points (x1, y1) and (x2, y2).\n    \n    Parameters:\n        x1, y1, x2, y2 (float): Coordinates of the two points.\n        \n    Returns:\n        float: The distance between the two points.", "Freq": 0, "TSR": 0}, {"tool": "def area_of_circle(r):\n    \n    return np.pi * r**2", "subfield": "Coordinate Geometry", "tool_name": "area_of_circle", "tool_type": "function", "description": "Calculates the area of a circle given its radius.", "docstring": "Calculates the area of a circle given its radius.\n    Parameters:\n    r (float): The radius of the circle.\n    Returns:\n    float: The area of the circle.\n    Examples:\n    >>> area_of_circle(1)\n    3.141592653589793", "Freq": 2, "TSR": 2}, {"tool": "def is_collinear(points):\n    \n    if len(points) < 3:\n        return True  # Two points are always collinear\n    x1, y1 = points[0]\n    x2, y2 = points[1]\n    for (x, y) in points[2:]:\n        if (x2 - x1) * (y - y1) != (y2 - y1) * (x - x1):\n            return False\n    return True", "subfield": "Coordinate Geometry", "tool_name": "is_collinear", "tool_type": "function", "description": "Check if all points given are collinear.", "docstring": "Check if all points given are collinear.\n    \n    Parameters:\n    - points (list of tuples): List of points (x, y) to be checked.\n    \n    Returns:\n    - bool: True if all points are collinear, False otherwise.\n    Example:\n    >>> is_collinear([(1, 2), (2, 4), (3, 6)])\n    True", "Freq": 1, "TSR": 0}, {"tool": "def transform_coordinates(points, transformation_matrix):\n    \n    transformed = np.dot(transformation_matrix, np.array(points).T).T\n    return [tuple(point) for point in transformed]", "subfield": "Coordinate Geometry", "tool_name": "transform_coordinates", "tool_type": "function", "description": "Applies a transformation matrix to a list of point coordinates in 2D.", "docstring": "Applies a transformation matrix to a list of point coordinates in 2D.\n    Parameters:\n    - points: List of tuples representing the point coordinates.\n    - transformation_matrix: A 2x2 numpy array representing the transformation matrix.\n    Returns:\n    - List of tuples: New coordinates after transformation.\n    Example:\n    >>> transform_coordinates([(1, 2)], np.array([[2, 0], [0, 2]]))\n    [(2, 4)]", "Freq": 0, "TSR": 0}, {"tool": "def scalar_multiply(vector, scalar):\n    \n    return np.multiply(vector, scalar)", "subfield": "Coordinate Geometry", "tool_name": "scalar_multiply", "tool_type": "function", "description": "Multiplies a vector by a scalar.", "docstring": "Multiplies a vector by a scalar.\n    Parameters:\n    vector (ndarray): A numpy array representing the vector.\n    scalar (float): The scalar value to multiply with the vector.\n    Returns:\n    ndarray: The scaled vector.", "Freq": 0, "TSR": 0}, {"tool": "def get_line_equation(p1, p2):\n    \n    x1, y1 = p1\n    x2, y2 = p2\n    A = y2 - y1\n    B = x1 - x2\n    C = x2 * y1 - x1 * y2\n    return (A, B, C)", "subfield": "Coordinate Geometry", "tool_name": "get_line_equation", "tool_type": "function", "description": "Calculate the coefficients (A, B, C) of the line equation Ax + By + C = 0 passing through two points.", "docstring": "Calculate the coefficients (A, B, C) of the line equation Ax + By + C = 0 passing through two points.\n    Parameters:\n    - p1 (tuple): coordinates of the first point.\n    - p2 (tuple): coordinates of the second point.\n    Returns:\n    - tuple: coefficients (A, B, C) of the line.\n    Examples:\n    >>> get_line_equation((1, 2), (3, 4))\n    (2, -2, 0)", "Freq": 3, "TSR": 1}, {"tool": "class Point:\n    \"\"\"\n    This class represents a Point in 2D geometry.\n    \n    Attributes:\n        x (float): x-coordinate of the Point.\n        y (float): y-coordinate of the Point.\n    \"\"\"\n    \n    def __init__(self, x=0.0, y=0.0):\n        \"\"\"\n        The constructor for the Point class. It initializes the x and y coordinates of the point.\n        \n        Parameters:\n            x (float): The x-coordinate of the point.\n            y (float): The y-coordinate of the point.\n        \"\"\"\n        self.x = x\n        self.y = y\n    def __str__(self):\n        \"\"\"\n        This method returns the string representation of the Point.\n        \n        Returns:\n            str: A string in the format '(x, y)'.\n        \"\"\"\n        return '(' + str(self.x) + ', ' + str(self.y) + ')'\n    \n    def distance(self, other):\n        \"\"\"\n        This method calculates the Euclidean distance between this Point and another Point.\n        \n        Parameters:\n            other (Point): The other Point.\n            \n        Returns:\n            float: The Euclidean distance between the two points.\n        \"\"\"\n        return np.sqrt((self.x - other.x)**2 + (self.y - other.y)**2)", "subfield": "Coordinate Geometry", "tool_name": "Point:\n    \"\"\"\n    This class represents a Point in 2D geometry.\n    \n    Attributes:\n        x", "tool_type": "class", "description": "This class represents a Point in 2D geometry.\n    \n    Attributes:\n        x (float): x-coordinate of the Point.\n        y (float): y-coordinate of the Point.", "docstring": "This class represents a Point in 2D geometry.\n    \n    Attributes:\n        x (float): x-coordinate of the Point.\n        y (float): y-coordinate of the Point.", "Freq": 0, "TSR": 0}, {"tool": "def complete_square(expression, variable):\n    \n    a = expression.coeff(variable**2)\n    b = expression.coeff(variable)\n    completed_square = a * (variable + b/(2*a))**2 - (b**2)/(4*a)\n    return completed_square", "subfield": "Coordinate Geometry", "tool_name": "complete_square", "tool_type": "function", "description": "Complete the square for the given variable in a SymPy expression.", "docstring": "Complete the square for the given variable in a SymPy expression.", "Freq": 0, "TSR": 0}, {"tool": "def distance_point_plane(point, plane_coefficients):\n    \n    A, B, C, D = plane_coefficients\n    x, y, z = point\n    num = abs(A*x + B*y + C*z + D)\n    den = np.sqrt(A**2 + B**2 + C**2)\n    return num / den", "subfield": "Coordinate Geometry", "tool_name": "distance_point_plane", "tool_type": "function", "description": "Calculate the shortest distance from a point to a plane in 3D.", "docstring": "Calculate the shortest distance from a point to a plane in 3D.\n    \n    Parameters:\n    - point (array-like): The coordinates of the point.\n    - plane_coefficients (tuple): The coefficients (A, B, C, D) of the plane Ax + By + Cz + D = 0.\n    \n    Returns:\n    - float: The shortest distance from the point to the plane.\n    \n    Example:\n    >>> distance_point_plane([1, 2, 2], (1, 0, 0, -2))\n    1.0", "Freq": 2, "TSR": 0}, {"tool": "def distance_constraints_2d(points, distance):\n    \n    x, y = symbols('x y', real=True)\n    generated_eqs = []\n    for p1, p2 in zip(points, points[1:] + [points[0]]):\n        eq = Eq((x - p1[0]) ** 2 + (y - p1[1]) ** 2, distance ** 2)\n        generated_eqs.append(eq)\n    return generated_eqs", "subfield": "Coordinate Geometry", "tool_name": "distance_constraints_2d", "tool_type": "function", "description": "Formulate and solve a system of equations given distance constraints between multiple points in 2D.", "docstring": "Formulate and solve a system of equations given distance constraints between multiple points in 2D.\n    Parameters:\n    - points (list): List of tuples/lists where each tuple/list contains the (x, y) coordinates.\n    - distance (float): The distance that each pair of points should satisfy.\n    Returns:\n    - list: A list of sympy Eq objects expressing the distance constraints.\n    Examples:", "Freq": 0, "TSR": 0}, {"tool": "def solve_linear_system(coeff_matrix, const_vector):\n    \n    coeff_matrix = np.array(coeff_matrix)\n    const_vector = np.array(const_vector)\n    return np.linalg.solve(coeff_matrix, const_vector)", "subfield": "Coordinate Geometry", "tool_name": "solve_linear_system", "tool_type": "function", "description": "Solves a linear system of equations defined by a matrix of coefficients and a constant vector.", "docstring": "Solves a linear system of equations defined by a matrix of coefficients and a constant vector.\n    Parameters:\n    - coeff_matrix (list[list[float]]): Coefficient matrix where each row represents the coefficients of a linear equation.\n    - const_vector (list[float]): Constant terms for each equation.\n    Returns:\n    - ndarray: Solution to the system of equations.\n    Examples:\n    >>> solve_linear_system([[1, 1], [1, -1]], [5, 1])\n    array([3., 2.])", "Freq": 1, "TSR": 0}, {"tool": "def find_perpendicular_slope(slope):\n    \n    return -1 / slope", "subfield": "Coordinate Geometry", "tool_name": "find_perpendicular_slope", "tool_type": "function", "description": "Calculates the slope of a line perpendicular to a given slope.", "docstring": "Calculates the slope of a line perpendicular to a given slope.\n    \n    Parameters\n    ----------\n    slope : float\n        Slope of the given line.\n    \n    Returns\n    -------\n    float\n        Slope of the perpendicular line.\n    \n    Examples\n    --------\n    >>> find_perpendicular_slope(2)\n    -0.5", "Freq": 2, "TSR": 1}, {"tool": "class GeometryUtils:\n    \"\"\"\n    This class provides a set of utility functions for solving geometry problems.\n    \"\"\"\n    \n    def __init__(self):\n        pass\n    \n    def line_equation_from_two_points(self, point1, point2):\n        \"\"\"\n        This function calculates the equation of a line passing through two given points.\n        \n        Parameters:\n            point1 (tuple): The coordinates of the first point (x1, y1).\n            point2 (tuple): The coordinates of the second point (x2, y2).\n            \n        Returns:\n            tuple: The slope and y-intercept of the line in the form (m, c).\n        \"\"\"\n        x1, y1 = point1\n        x2, y2 = point2\n        slope = (y2 - y1) / (x2 - x1)\n        intercept = y1 - slope * x1\n        return slope, intercept\n    \n    def solve_linear_equations(self, coeff_matrix, const_vector):\n        \"\"\"\n        This function solves a system of linear equations defined by a matrix of coefficients and a constant vector.\n        \n        Parameters:\n            coeff_matrix (list): A list of lists representing the matrix of coefficients.\n            const_vector (list): A list representing the constant vector.\n            \n        Returns:\n            list: A list of solutions to the system of linear equations.\n        \"\"\"\n        coeff_matrix = np.array(coeff_matrix)\n        const_vector = np.array(const_vector)\n        solutions = np.linalg.solve(coeff_matrix, const_vector)\n        return solutions\n    \n    def distance_between_points(self, point1, point2):\n        \"\"\"\n        This function calculates the Euclidean distance between two points in a 2D coordinate system.\n        \n        Parameters:\n            point1 (tuple): The coordinates of the first point (x1, y1).\n            point2 (tuple): The coordinates of the second point (x2, y2).\n            \n        Returns:\n            float: The Euclidean distance between the two points.\n        \"\"\"\n        x1, y1 = point1\n        x2, y2 = point2\n        distance = np.sqrt((x2 - x1)**2 + (y2 - y1)**2)\n        return distance\n    \n    def line_intersection(self, line1, line2):\n        \"\"\"\n        This function calculates the intersection point of two lines in a 2D coordinate system.\n        \n        Parameters:\n            line1 (tuple): The equation of the first line in the form (m1, c1).\n            line2 (tuple): The equation of the second line in the form (m2, c2).\n            \n        Returns:\n            tuple: The coordinates of the intersection point (x, y).\n        \"\"\"\n        m1, c1 = line1\n        m2, c2 = line2\n        x = (c2 - c1) / (m1 - m2)\n        y = m1 * x + c1\n        return x, y", "subfield": "Coordinate Geometry", "tool_name": "GeometryUtils:\n    \"\"\"\n    This class provides a set of utility functions for solving geometry problems.\n    \"\"\"\n    \n    def __init__", "tool_type": "class", "description": "This class provides a set of utility functions for solving geometry problems.", "docstring": "This class provides a set of utility functions for solving geometry problems.", "Freq": 0, "TSR": 0}], "Rectangles": [{"tool": "def rectangle_area(length, width):\n    \n    return length * width", "subfield": "Rectangles", "tool_name": "rectangle_area", "tool_type": "function", "description": "Calculate the area of a rectangle.", "docstring": "Calculate the area of a rectangle.\n    Parameters:\n    length (float): the length of the rectangle.\n    width (float): the width of the rectangle.\n    Returns:\n    float: the calculated area of the rectangle.\n    \n    Example:\n    >>> rectangle_area(5, 3)\n    15", "Freq": 2, "TSR": 1}, {"tool": "def rectangle_diagonal(length, width):\n    \n    return math.sqrt(length**2 + width**2)", "subfield": "Rectangles", "tool_name": "rectangle_diagonal", "tool_type": "function", "description": "Calculates the length of the diagonal of a rectangle using Pythagoras' theorem.", "docstring": "Calculates the length of the diagonal of a rectangle using Pythagoras' theorem.\n    \n    Parameters:\n        length (float): The length of the rectangle.\n        width (float): The width of the rectangle.\n        \n    Returns:\n        float: The length of the diagonal.\n        \n    Examples:\n    >>> rectangle_diagonal(5, 4)\n    6.4031242374328485", "Freq": 2, "TSR": 0}, {"tool": "def calculate_square_perimeter(side_length):\n    \n    return 4 * side_length", "subfield": "Rectangles", "tool_name": "calculate_square_perimeter", "tool_type": "function", "description": "Calculate the perimeter of a square given the side length.", "docstring": "Calculate the perimeter of a square given the side length.\n    \n    Parameters:\n    side_length (float): The length of a side of the square.\n    \n    Returns:\n    float: The perimeter of the square.", "Freq": 3, "TSR": 2, "experience_pool": "- Experience 1:\n    - Problem: The area of a square plot of land is 325 square meters. What is the perimeter of the square, in meters? Express your answer in simplest radical form.\n    - Solution: \n        ```python\n        import math\n\n        def solution():\n            \"\"\"The area of a square plot of land is 325 square meters. What is the perimeter of the square, in meters?\"\"\"\n            area = 325\n            side_length = math.sqrt(area)\n            perimeter = calculate_square_perimeter(side_length)\n            return perimeter\n\n        # Calculate the perimeter of the square\n        print(solution())\n        ```\n    - Output: 72.11102550927978\n    - Feedback: The tool accurately calculates the perimeter of the square."}, {"tool": "def solve_rectangle_dimensions(perimeter, area=None, aspect_ratio=None, use_integers=False):\n    \n    import sympy\n    \n    length, width = sympy.symbols('length width')\n    eq1 = sympy.Eq(2 * (length + width), perimeter)\n    \n    solutions = []\n    \n    if area is not None:\n        eq2 = sympy.Eq(length * width, area)\n        sol = sympy.solve((eq1, eq2), (length, width))\n        solutions.extend(sol)\n    \n    if aspect_ratio is not None:\n        eq2 = sympy.Eq(length / width, aspect_ratio)\n        sol = sympy.solve((eq1, eq2), (length, width))\n        solutions.extend(sol)\n    \n    if not solutions:\n        solutions = sympy.solve(eq1, (length, width))\n    \n    # Filter for integer solutions if requested\n    if use_integers:\n        solutions = [(l, w) for l, w in solutions if l.is_integer and w.is_integer]\n    return solutions", "subfield": "Rectangles", "tool_name": "solve_rectangle_dimensions", "tool_type": "function", "description": "Solves for dimensions of a rectangle given constraints like perimeter, area or aspect ratio.", "docstring": "Solves for dimensions of a rectangle given constraints like perimeter, area or aspect ratio.\n    Parameters:\n    perimeter (float): The perimeter of the rectangle.\n    area (float, optional): The area of the rectangle.\n    aspect_ratio (float, optional): The ratio of length to width.\n    use_integers (bool, optional): If True, returns integer dimensions. Default is False.\n    Returns:\n    list of tuples: Possible (length, width) combinations.\n    \n    Examples:\n    >>> solve_rectangle_dimensions(20, area=24)\n    [(6, 4), (4, 6)]\n    >>> solve_rectangle_dimensions(20, aspect_ratio=1.5)\n    [(7.5, 5), (5, 7.5)]", "Freq": 15, "TSR": 4}, {"tool": "def calculate_shaded_area(length, width, shaded_length, shaded_width):\n    \n    rectangle_area = length * width\n    shaded_area = shaded_length * shaded_width\n    return rectangle_area - shaded_area", "subfield": "Rectangles", "tool_name": "calculate_shaded_area", "tool_type": "function", "description": "Calculate the area of a shaded region in a rectangle.\n    \n    Args:\n    length (float): The length of the rectangle.\n    width (float): The width of the rectangle.\n    shaded_length (float): The length of the shaded region.\n    shaded_width (float): The width of the shaded region.\n    \n    Returns:\n    float: The area of the shaded region.", "docstring": "Calculate the area of a shaded region in a rectangle.\n    \n    Args:\n    length (float): The length of the rectangle.\n    width (float): The width of the rectangle.\n    shaded_length (float): The length of the shaded region.\n    shaded_width (float): The width of the shaded region.\n    \n    Returns:\n    float: The area of the shaded region.", "Freq": 1, "TSR": 0}], "Midpoint Formula": [{"tool": "def compute_midpoint(point1, point2):\n    \n    # Ensure input is in the correct format and same dimension\n    if len(point1) != len(point2):\n        raise ValueError(\"Both points must have the same number of dimensions\")\n    # Calculate midpoint using tuple/list comprehension\n    midpoint = tuple((p1 + p2) / 2 for p1, p2 in zip(point1, point2))\n    \n    return midpoint", "subfield": "Midpoint Formula", "tool_name": "compute_midpoint", "tool_type": "function", "description": "Compute the midpoint between two points in n-dimensional space.", "docstring": "Compute the midpoint between two points in n-dimensional space.\n    Parameters:\n    point1 (tuple or list): Coordinates of the first point.\n    point2 (tuple or list): Coordinates of the second point.\n    Returns:\n    tuple: Coordinates of the midpoint.\n    Examples:\n    >>> compute_midpoint((1, 2), (3, 4))\n    (2.0, 3.0)\n    >>> compute_midpoint([0, 0, 0], [6, 8, 10])\n    (3.0, 4.0, 5.0)\n    Raises:\n    ValueError: If the dimensions of the two points are not equal.", "Freq": 21, "TSR": 20, "experience_pool": "- To calculate the value of b using the midpoint and one of the endpoints, you can directly access the coordinates of the midpoint tuple and add them together. There is no need to use the non-existent function find_endpoint_from_midpoint.\n\nExample:\nmidpoint = compute_midpoint((1, 3), (5, 7))\nb = midpoint[0] + midpoint[1]"}, {"tool": "def find_endpoint_from_midpoint(midpoint, known_point):\n    \n    import numpy as np\n    midpoint, known_point = np.array(midpoint), np.array(known_point)\n    unknown_point = 2 * midpoint - known_point\n    return unknown_point.tolist()", "subfield": "Midpoint Formula", "tool_name": "find_endpoint_from_midpoint", "tool_type": "function", "description": "Calculate the unknown endpoint of a line segment given the midpoint and the known endpoint.", "docstring": "Calculate the unknown endpoint of a line segment given the midpoint and the known endpoint.\n    Parameters:\n        midpoint (list or tuple of floats): Coordinates of the midpoint.\n        known_point (list or tuple of floats): Coordinates of the known endpoint.\n    Returns:\n        list: The coordinates of the unknown endpoint as a list of floats.\n    \n    Examples:\n        >>> find_endpoint_from_midpoint([1.0, 1.0], [0, 0])\n        [2.0, 2.0]\n        >>> find_endpoint_from_midpoint([4.0, 7.0, 9.0], [1, 3, 5])\n        [7.0, 11.0, 13.0]", "Freq": 8, "TSR": 6, "experience_pool": "- Problem: The graph of the line $x+y=b$ is a perpendicular bisector of the line segment from $(1,3)$ to $(5,7)$. What is the value of b?\n  - Answer: 8\n  - Solution:\n    ```python\n    def solution():\n        # Calculate the midpoint of the line segment\n        midpoint = compute_midpoint((1, 3), (5, 7))\n        \n        # Find the value of b using the midpoint and one of the endpoints\n        b = find_endpoint_from_midpoint(midpoint, [1, 3])[0] + find_endpoint_from_midpoint(midpoint, [1, 3])[1]\n        \n        return b\n\n    # Calculate the value of b\n    print(solution())\n    ```\n  - Output: 12.0\n\n- Problem: Let $\\mathbf{a}$ and $\\mathbf{b}$ be vectors, and let $\\mathbf{m}$ be the midpoint of $\\mathbf{a}$ and $\\mathbf{b}.$  Given $\\mathbf{m} = \\begin{pmatrix} 3 \\\\ 7 \\end{pmatrix}$ and $\\mathbf{a} \\cdot \\mathbf{b} = 6,$ find $\\|\\mathbf{a}\\|^2 + \\|\\mathbf{b}\\|^2.$\n  - Answer: 220\n  - Solution:\n    ```python\n    def solution():\n        # Given values\n        m = [3, 7]\n        ab_dot = 6\n        \n        # Calculate the known endpoint\n        a_plus_b = find_endpoint_from_midpoint(m, m)\n        \n        # Calculate the norm squared of a + b\n        norm_squared_a_plus_b = sum([x**2 for x in a_plus_b])\n        \n        # Calculate the norm squared of a + norm squared of b\n        norm_squared_a_plus_norm_squared_b = norm_squared_a_plus_b - 2 * ab_dot\n        \n        return norm_squared_a_plus_norm_squared_b\n\n    # Calculate the result\n    print(solution())\n    ```\n  - Output: 46\n\n- Problem: Let $\\mathbf{a}$ and $\\mathbf{b}$ be vectors, and let $\\mathbf{m}$ be the midpoint of $\\mathbf{a}$ and $\\mathbf{b}.$  Given $\\mathbf{m} = \\begin{pmatrix} 3 \\\\ 7 \\end{pmatrix}$ and $\\mathbf{a} \\cdot \\mathbf{b} = 6,$ find $\\|\\mathbf{a}\\|^2 + \\|\\mathbf{b}\\|^2.$\n  - Answer: 220\n  - Solution:\n    ```python\n    def solution():\n        # Given values\n        m = [3, 7]\n        ab_dot = 6\n        \n        # Calculate the known endpoint\n        a = find_endpoint_from_midpoint(m, [1, 3])\n        b = find_endpoint_from_midpoint(m, [5, 7])\n        \n        # Calculate the norm squared of a + norm squared of b\n        norm_squared_a_plus_norm_squared_b = sum([x**2 for x in a]) + sum([x**2 for x in b])\n        \n        return norm_squared_a_plus_norm_squared_b\n\n    # Calculate the result\n    print(solution())\n    ```\n  - Output: 196"}, {"tool": "def compute_distance(point1, point2):\n    \n    import math\n    # Ensure input is in the correct format and same dimension\n    if len(point1) != len(point2):\n        raise ValueError(\"Both points must have the same number of dimensions\")\n    # Calculate the squared difference for each dimension\n    squared_diff = [(p1 - p2) ** 2 for p1, p2 in zip(point1, point2)]\n    # Sum the squared differences and take the square root\n    distance = math.sqrt(sum(squared_diff))\n    return distance", "subfield": "Midpoint Formula", "tool_name": "compute_distance", "tool_type": "function", "description": "Compute the distance between two points in n-dimensional space.", "docstring": "Compute the distance between two points in n-dimensional space.\n    Parameters:\n    point1 (tuple/list): The coordinates of the first point.\n    point2 (tuple/list): The coordinates of the second point.\n    Returns:\n    float: The distance between the two points.", "Freq": 0, "TSR": 0}], "Distance Formula": [{"tool": "def distance_formula_symbolic(point1, point2):\n    \n    if len(point1) != len(point2):\n        raise ValueError(\"Points must have the same dimensions\")\n    distance_expr = sqrt(sum((p1 - p2)**2 for p1, p2 in zip(point1, point2)))\n    return simplify(distance_expr)", "subfield": "Distance Formula", "tool_name": "distance_formula_symbolic", "tool_type": "function", "description": "Construct a symbolic distance formula between two points, supporting symbolic and numerical computation.", "docstring": "Construct a symbolic distance formula between two points, supporting symbolic and numerical computation.\n    Parameters:\n    - point1: array-like, the coordinates of the first point, can contain symbols or numbers\n    - point2: array-like, the coordinates of the second point, can contain symbols or numbers\n    Returns:\n    - distance_expr: sympy expression, the symbolic expression for the distance between point1 and point2\n    Examples:\n    - Using numerical coordinates:\n    >>> distance_formula_symbolic((1, 2), (4, 6))\n    sqrt(13)\n    \n    - Using symbolic coordinates:\n    >>> x, y = symbols('x y')\n    >>> distance_formula_symbolic((x, 0), (0, y))\n    sqrt(x**2 + y**2)", "Freq": 82, "TSR": 54, "experience_pool": "- To use the solve function, you need to import it from sympy: `from sympy import solve`\n- To use the pi constant, you need to import it from sympy: `from sympy import pi`\n- To use the Eq function, you need to import it from sympy: `from sympy import Eq`\n- To use the symbols function, you need to import it from sympy: `from sympy import symbols`"}, {"tool": "def pythagorean_theorem(leg_a=None, leg_b=None, hypotenuse=None):\n    \n    if hypotenuse is None and leg_a is not None and leg_b is not None:\n        return math.sqrt(leg_a**2 + leg_b**2)\n    elif leg_a is None and hypotenuse is not None and leg_b is not None:\n        return math.sqrt(hypotenuse**2 - leg_b**2)\n    elif leg_b is None and hypotenuse is not None and leg_a is not None:\n        return math.sqrt(hypotenuse**2 - leg_a**2)\n    elif leg_a is not None and leg_b is not None and hypotenuse is None:\n        return math.sqrt(leg_a**2 + leg_b**2)\n    else:\n        raise ValueError(\"Invalid input: provide exactly one missing side.\")", "subfield": "Distance Formula", "tool_name": "pythagorean_theorem", "tool_type": "function", "description": "Calculate the missing side of a right triangle using the Pythagorean theorem.", "docstring": "Calculate the missing side of a right triangle using the Pythagorean theorem.\n    Parameters:\n    -----------\n    leg_a : float, optional\n        The length of one leg of the triangle.\n    leg_b : float, optional\n        The length of the other leg of the triangle.\n    hypotenuse : float, optional\n        The length of the hypotenuse of the triangle.\n    \n    Returns:\n    --------\n    float\n        The length of the missing side of the triangle.\n    \n    Examples:\n    ---------\n    >>> pythagorean_theorem(leg_a=3, leg_b=4)\n    5.0\n    >>> pythagorean_theorem(hypotenuse=5, leg_b=4)\n    3.0\n    \n    Raises:\n    -------\n    ValueError\n        If insufficient data is provided or too many sides are known.", "Freq": 6.0, "TSR": 3.0, "experience_pool": "Experience 1:\nProblem: Adam and Simon start on bicycle trips from the same point at the same time. Adam travels east at 8mph and Simon travels south at 6mph. After how many hours are they 60 miles apart?\nAnswer: 6\n\nExperience 2:\nProblem: In convex quadrilateral $ABCD$, $AB=BC=13$, $CD=DA=24$, and $\\angle D=60^\\circ$.  Points $X$ and $Y$ are the midpoints of $\\overline{BC}$ and $\\overline{DA}$ respectively.  Compute $XY^2$ (the square of the length of $XY$).\nAnswer: \\frac{1033}{4}+30\\sqrt{3}\n\nExperience 3:\nProblem: A circle of radius $2$ has center at $(2,0)$. A circle of radius $1$ has center at $(5,0)$.  A line is tangent to the two circles at points in the first quadrant.  What is the $y$-intercept of the line?\nAnswer: 2\\sqrt{2}\n\nExperience 4:\nProblem: What is the $x$-coordinate of the point on the $x$-axis that is equidistant from points $A( -2, 0)$ and $B(0,4)$?\nAnswer: 3"}, {"tool": "def calculate_median_length(side_a, side_b):\n    \n    hypotenuse = math.sqrt(side_a**2 + side_b**2)\n    return hypotenuse / 2", "subfield": "Distance Formula", "tool_name": "calculate_median_length", "tool_type": "function", "description": "Calculate the length of the median to the hypotenuse of a right triangle, based on the other two sides.\n    The median on the hypotenuse divides it into two equal segments, each half the length of the hypotenuse.", "docstring": "Calculate the length of the median to the hypotenuse of a right triangle, based on the other two sides.\n    The median on the hypotenuse divides it into two equal segments, each half the length of the hypotenuse.\n    \n    Parameters:\n    - side_a (float): Length of one side of the right triangle.\n    - side_b (float): Length of the other side of the right triangle.\n    \n    Returns:\n    - float: The length of the median to the hypotenuse.\n    \n    Example:\n    >>> calculate_median_length(3, 4)\n    2.5", "Freq": 1, "TSR": 1}, {"tool": "def distance_formula_3D(point1, point2):\n    \n    x1, y1, z1 = point1\n    x2, y2, z2 = point2\n    distance = sqrt((x2 - x1)**2 + (y2 - y1)**2 + (z2 - z1)**2)\n    return distance", "subfield": "Distance Formula", "tool_name": "distance_formula_3D", "tool_type": "function", "description": "Calculate the distance between two points in three-dimensional space using the distance formula.\n    Args:\n        point1 (tuple): The coordinates of the first point (x1, y1, z1).\n        point2 (tuple): The coordinates of the second point (x2, y2, z2).\n    Returns:\n        float: The distance between the two points.", "docstring": "Calculate the distance between two points in three-dimensional space using the distance formula.\n    Args:\n        point1 (tuple): The coordinates of the first point (x1, y1, z1).\n        point2 (tuple): The coordinates of the second point (x2, y2, z2).\n    Returns:\n        float: The distance between the two points.", "Freq": 13, "TSR": 11, "experience_pool": "- Experience: Calculating the distance between two points in three-dimensional space.\n  - Problem: In coordinate space, a particle starts at the point $(2,3,4)$ and ends at the point $(-1,-3,-3),$ along the line connecting the two points. Along the way, the particle intersects the unit sphere centered at the origin at two points. Then the distance between these two points can be expressed in the form $\\frac{a}{\\sqrt{b}},$ where $a$ and $b$ are positive integers, and $b$ is not divisible by the square of a prime. Find $a + b.$\n  - Solution: The distance between the two points can be calculated using the distance_formula_3D function.\n    ```python\n    def solution():\n        point1 = (2, 3, 4)\n        point2 = (-1, -3, -3)\n        \n        distance = distance_formula_3D(point1, point2)\n        \n        result = distance\n        return result\n    \n    print(solution())\n    ```\n  - Output: 12*sqrt(47)/47"}, {"tool": "def solve_for_x(a, b, c, d, point):\n    \n    x0, y0, z0 = point\n    x = (d - b*y0 - c*z0) / a\n    return x", "subfield": "Distance Formula", "tool_name": "solve_for_x", "tool_type": "function", "description": "Solve for x in the equation ax + by + cz = d, given the coefficients and a point.\n    Args:\n        a (float): The coefficient of x.\n        b (float): The coefficient of y.\n        c (float): The coefficient of z.\n        d (float): The constant term.\n        point (tuple): The coordinates of the given point (x0, y0, z0).\n    Returns:\n        float: The value of x.", "docstring": "Solve for x in the equation ax + by + cz = d, given the coefficients and a point.\n    Args:\n        a (float): The coefficient of x.\n        b (float): The coefficient of y.\n        c (float): The coefficient of z.\n        d (float): The constant term.\n        point (tuple): The coordinates of the given point (x0, y0, z0).\n    Returns:\n        float: The value of x.", "Freq": 0, "TSR": 0}, {"tool": "def solve_for_y(a, b, c, d, point):\n    \n    x0, y0, z0 = point\n    y = (d - a*x0 - c*z0) / b\n    return y", "subfield": "Distance Formula", "tool_name": "solve_for_y", "tool_type": "function", "description": "Solve for y in the equation ax + by + cz = d, given the coefficients and a point.\n    Args:\n        a (float): The coefficient of x.\n        b (float): The coefficient of y.\n        c (float): The coefficient of z.\n        d (float): The constant term.\n        point (tuple): The coordinates of the given point (x0, y0, z0).\n    Returns:\n        float: The value of y.", "docstring": "Solve for y in the equation ax + by + cz = d, given the coefficients and a point.\n    Args:\n        a (float): The coefficient of x.\n        b (float): The coefficient of y.\n        c (float): The coefficient of z.\n        d (float): The constant term.\n        point (tuple): The coordinates of the given point (x0, y0, z0).\n    Returns:\n        float: The value of y.", "Freq": 0, "TSR": 0}, {"tool": "def solve_for_z(a, b, c, d, point):\n    \n    x0, y0, z0 = point\n    z = (d - a*x0 - b*y0) / c\n    return z", "subfield": "Distance Formula", "tool_name": "solve_for_z", "tool_type": "function", "description": "Solve for z in the equation ax + by + cz = d, given the coefficients and a point.\n    Args:\n        a (float): The coefficient of x.\n        b (float): The coefficient of y.\n        c (float): The coefficient of z.\n        d (float): The constant term.\n        point (tuple): The coordinates of the given point (x0, y0, z0).\n    Returns:\n        float: The value of z.", "docstring": "Solve for z in the equation ax + by + cz = d, given the coefficients and a point.\n    Args:\n        a (float): The coefficient of x.\n        b (float): The coefficient of y.\n        c (float): The coefficient of z.\n        d (float): The constant term.\n        point (tuple): The coordinates of the given point (x0, y0, z0).\n    Returns:\n        float: The value of z.", "Freq": 0, "TSR": 0}], "Area Calculation": [{"tool": "def area_triangle(base, height):\n    \n    return 0.5 * base * height", "subfield": "Area Calculation", "tool_name": "area_triangle", "tool_type": "function", "description": "Calculate area of a triangle given its base and height.", "docstring": "Calculate area of a triangle given its base and height.\n    Parameters:\n    base (float): the length of the base of the triangle.\n    height (float): the height of the triangle perpendicular to the base.\n    Returns:\n    float: the area of the triangle", "Freq": 15, "TSR": 1, "experience_pool": "1. Make sure to provide the correct base and height values when using the tool for calculating the area of a triangle.\n2. Pay attention to the specific requirements of each problem and ensure that the input parameters match those requirements.\n3. Double-check the calculations involving triangles to avoid errors in the final result."}, {"tool": "def area_circle(radius):\n    \n    import math\n    return math.pi * radius ** 2", "subfield": "Area Calculation", "tool_name": "area_circle", "tool_type": "function", "description": "Calculate the area of a circle given its radius.", "docstring": "Calculate the area of a circle given its radius.\n    Parameters:\n    radius (float): the radius of the circle.\n    Returns:\n    float: the area of the circle calculated as pi*r^2", "Freq": 15, "TSR": 2, "experience_pool": "- Make sure to call the correct function `area_circle` instead of `area_square` when calculating the area of a circle.\n- Ensure that the correct parameters are passed to the function when calculating the area of a circle."}, {"tool": "def rectangle_area(length, width):\n    \n    return length * width", "subfield": "Area Calculation", "tool_name": "rectangle_area", "tool_type": "function", "description": "Calculate the area of a rectangle from length and width.", "docstring": "Calculate the area of a rectangle from length and width.\n    Parameters:\n    length (float): The length of the rectangle.\n    width (float): The width of the rectangle.\n    Returns:\n    float: The area of the rectangle.\n    \n    Examples:\n    >>> rectangle_area(4, 3)\n    12", "Freq": 15, "TSR": 11, "experience_pool": "- The tool `rectangle_area` is used to calculate the area of a rectangle from its length and width, and it is functioning correctly.\n- Ensure to provide the correct length and width values when calling the `rectangle_area` function to get the accurate area of the rectangle."}, {"tool": "def triangle_area_by_sides(a, b, c):\n    \n    s = (a + b + c) / 2\n    area = sqrt(s * (s - a) * (s - b) * (s - c))\n    return area", "subfield": "Area Calculation", "tool_name": "triangle_area_by_sides", "tool_type": "function", "description": "Calculate the area of a triangle given the lengths of its sides using Heron's formula.", "docstring": "Calculate the area of a triangle given the lengths of its sides using Heron's formula.\n    Parameters:\n    - a, b, c (float): Lengths of the sides of the triangle.\n    Returns:\n    - float: The area of the triangle.\n    Examples:\n    >>> triangle_area_by_sides(3, 4, 5)\n    6.0", "Freq": 3, "TSR": 2, "experience_pool": "- Always ensure that the input parameters for the `triangle_area_by_sides` function are the lengths of the sides of the triangle.\n- Make sure to correctly calculate the lengths of the medians or other geometric properties based on the triangle sides before using the `triangle_area_by_sides` function."}, {"tool": "def area_sector(radius, angle_deg):\n    \n    angle_rad = math.radians(angle_deg)\n    return 0.5 * radius**2 * angle_rad", "subfield": "Area Calculation", "tool_name": "area_sector", "tool_type": "function", "description": "Calculate the area of a sector of a circle given its radius and central angle in degrees.", "docstring": "Calculate the area of a sector of a circle given its radius and central angle in degrees.\n    Parameters:\n    - radius (float): The radius of the circle.\n    - angle_deg (float): The angle of the sector in degrees.\n    \n    Returns:\n    - float: The area of the sector.\n    \n    Example:\n    >>> area_sector(4, 90)\n    12.566370614359172", "Freq": 4, "TSR": 0, "experience_pool": "- Make sure to correctly calculate the area of figures or shapes using the area_sector function.\n- Double-check the angle values and radius when calling the area_sector function to ensure accurate results.\n- Verify the calculations and logic in the calling code to avoid errors in determining the area of complex shapes."}, {"tool": "def area_polygon(vertices):\n    \n    x = np.array([vertex[0] for vertex in vertices])\n    y = np.array([vertex[1] for vertex in vertices])\n    return 0.5 * np.abs(np.dot(x, np.roll(y, 1)) - np.dot(y, np.roll(x, 1)))", "subfield": "Area Calculation", "tool_name": "area_polygon", "tool_type": "function", "description": "Calculate the area of a simple polygon given its vertices.", "docstring": "Calculate the area of a simple polygon given its vertices.\n    Parameters:\n        vertices (list of tuples): List of (x, y) tuples, each representing a vertex of the polygon.\n    Returns:\n        float: The area of the polygon.\n    Examples:\n    >>> area_polygon([(0, 0), (4, 0), (4, 4), (0, 4)])  # Square with side 4\n    16.0", "Freq": 6, "TSR": 0, "experience_pool": "Tool for calculating the area of a polygon is accurate and functional. Issues with tool usage are mainly due to incorrect input parameters in the calling code."}, {"tool": "def area_square(side_length):\n    \n    return side_length ** 2", "subfield": "Area Calculation", "tool_name": "area_square", "tool_type": "function", "description": "Calculates the area of a square.", "docstring": "Calculates the area of a square.\n    Parameters:\n        side_length (float): The length of the side of the square.\n    Returns:\n        float: The area of the square.\n    Example:\n        >>> area_square(4)\n        16", "Freq": 20, "TSR": 3, "experience_pool": "1. When using the `area_square` function, ensure that the correct side length of the square is provided as a parameter.\n2. Make sure that all necessary functions like `area_circle`, `area_triangle`, `triangle_side_lengths`, and `calculate_composite_area` are defined and implemented correctly when working with different shapes.\n3. Double-check the input parameters and function calls to avoid errors related to missing parameters.\n4. Verify the existence and correctness of all required functions before executing the code that uses them.\n5. Pay attention to failed tasks and corresponding error information to identify the root cause of the issue."}, {"tool": "def triangle_area_by_coordinates(x1, y1, x2, y2, x3, y3):\n    \n    return abs(x1*(y2-y3) + x2*(y3-y1) + x3*(y1-y2)) / 2", "subfield": "Area Calculation", "tool_name": "triangle_area_by_coordinates", "tool_type": "function", "description": "Calculate the area of a triangle given the coordinates of its vertices.", "docstring": "Calculate the area of a triangle given the coordinates of its vertices.\n    Parameters:\n    x1, y1 (float): Coordinates of the first vertex.\n    x2, y2 (float): Coordinates of the second vertex.\n    x3, y3 (float): Coordinates of the third vertex.\n    Returns:\n    float: The absolute value of the area of the triangle.\n    Examples:\n    >>> triangle_area_by_coordinates(0, 0, 4, 0, 2, 3)\n    6.0", "Freq": 11, "TSR": 1, "experience_pool": "1. Problem: Find the area of the triangle with vertices $(3,-5),$ $(-2,0),$ and $(1,-6)$.\n   Solution: The correct area is $\\frac{15}{2}$.\n2. Problem: Find the area of the triangle with vertices $(-1,4),$ $(7,0),$ and $(11,5)$.\n   Solution: The correct area is $28$.\n3. Problem: Regular hexagon $ABCDEF$ has vertices $A$ and $C$ at $(0,0)$ and $(7,1)$, respectively. What is its area?\n   Solution: The correct area is $25\\sqrt{3}$.\n4. Problem: Point $P$ is selected at random from the interior of the pentagon with vertices $A=(0,2)$, $B= (4,0)$, $C = (2\\pi +1, 0)$, $D=(2\\pi +1,4)$, and $E=(0,4)$. What is the probability that $\\angle APB$ is obtuse? Express your answer as a common fraction.\n   Solution: The correct probability is $\\frac{5}{16}$.\n5. Problem: Find the area of the triangle with vertices $(0,7,10),$ $(-1,6,6),$ and $(-4,9,6)$.\n   Solution: The correct area is $9$.\n6. Problem: What is the area, in square units, of a triangle whose vertices are at $(4, -1)$, $(10, 3)$ and $(4, 5)$?\n   Solution: The correct area is $18$.\n7. Problem: The set of points $(x,y)$ such that $|x - 3| \\le y \\le 4 - |x - 1|$ defines a region in the $xy$-plane. Compute the area of this region.\n   Solution: The correct area is $6$.\n8. Problem: A triangle has vertices at $(-3,2),(6,-2),(3,5)$. How many square units are in the area of the triangle? Express your answer as a decimal to the nearest tenth.\n   Solution: The correct area is $25.5$."}, {"tool": "def distance_between_points(x1, y1, x2, y2):\n    \n    return math.sqrt((x2 - x1)**2 + (y2 - y1)**2)", "subfield": "Area Calculation", "tool_name": "distance_between_points", "tool_type": "function", "description": "Calculate the Euclidean distance between two points in the Cartesian plane.", "docstring": "Calculate the Euclidean distance between two points in the Cartesian plane.\n    Parameters:\n    x1, y1 (float): Coordinates of the first point.\n    x2, y2 (float): Coordinates of the second point.\n    Returns:\n    float: The distance between the points.\n    Examples:\n    >>> distance_between_points(0, 0, 3, 4)\n    5.0", "Freq": 4, "TSR": 1, "experience_pool": "- Make sure to pass float values as coordinates when using the distance_between_points function.\n- Check for typos or incorrect values in the input parameters before calling the distance_between_points function."}, {"tool": "def calculate_composite_area(*args):\n    \n    return sum(args)", "subfield": "Area Calculation", "tool_name": "calculate_composite_area", "tool_type": "function", "description": "Calculate the total area of multiple individual areas passed as arguments.", "docstring": "Calculate the total area of multiple individual areas passed as arguments.\n    Parameters:\n    - args (float): Individual areas to be summed.\n    Returns:\n    - float: The total area of all individual areas combined.\n    Examples:\n    >>> calculate_composite_area(10, 15, 5)\n    30", "Freq": 2, "TSR": 0, "experience_pool": "- Always provide correct input parameters when calling the `calculate_composite_area` function.\n- Ensure that the correct areas are passed as arguments to the `calculate_composite_area` function.\n- Double-check the calculations and logic in the calling code to avoid errors."}, {"tool": "def law_of_cosines(a, b, angle_degrees):\n    \n    angle_radians = math.radians(angle_degrees)\n    c = math.sqrt(a**2 + b**2 - 2 * a * b * math.cos(angle_radians))\n    return c", "subfield": "Area Calculation", "tool_name": "law_of_cosines", "tool_type": "function", "description": "Calculate the third side of a triangle using the Law of Cosines.", "docstring": "Calculate the third side of a triangle using the Law of Cosines.\n    Parameters:\n    a (float): Length of the first side.\n    b (float): Length of the second side.\n    angle_degrees (float): Angle between sides a and b in degrees.\n    Returns:\n    float: Length of the third side.\n    Example:\n    >>> law_of_cosines(5, 5, 90)\n    7.0710678118654755", "Freq": 1, "TSR": 0}, {"tool": "def triangle_side_lengths(angle, *dimensions):\n    \n    \n    import sympy as sp\n    def right_triangle_sides(a, b):\n        # Use the Pythagorean theorem\n        return a, b, sp.sqrt(a**2 + b**2)\n    def special_triangle_sides(angle, a):\n        if angle == 30:\n            return a, a * sp.sqrt(3), 2*a\n        elif angle == 45:\n            return a, a, a * sp.sqrt(2)\n        else:\n            raise ValueError('This tool only covers 30-60-90 and 45-45-90 triangles.')\n    if angle == 90:\n        return right_triangle_sides(*dimensions)\n    else:\n        return special_triangle_sides(angle, *dimensions)", "subfield": "Area Calculation", "tool_name": "triangle_side_lengths", "tool_type": "function", "description": "Calculate the length of sides in common triangle types (right, 30-60-90, 45-45-90).", "docstring": "Calculate the length of sides in common triangle types (right, 30-60-90, 45-45-90).\n    Parameters\n    ----------\n    angle : int\n        Internal angle in degrees of the triangle.\n    dimensions : tuple\n        Lengths of known sides.\n    Returns\n    -------\n    tuple\n        Lengths of all sides of the triangle.\n    Examples\n    --------\n    >>> triangle_side_lengths(90, 3, 4)\n    (3, 4, 5)\n    >>> triangle_side_lengths(30, 5)\n    (5, 5*sqrt(3), 10)\n    >>> triangle_side_lengths(45, 5)\n    (5, 5, 5*sqrt(2))", "Freq": 0, "TSR": 0}, {"tool": "def rectangle_area_dynamic(L, W):\n    \n    from sympy import simplify\n    return simplify(L * W)", "subfield": "Area Calculation", "tool_name": "rectangle_area_dynamic", "tool_type": "function", "description": "Calculate the area of a rectangle while allowing the sides, L and W, to be expressions.", "docstring": "Calculate the area of a rectangle while allowing the sides, L and W, to be expressions.\n    \n    Parameters:\n    - L, W (expressions or floats): The expressions or numbers representing the length and width.\n    \n    Returns:\n    - Expression or float: The calculated area.\n    \n    Example:\n    >>> from sympy import symbols, Eq, solve\n    >>> l = symbols('l')\n    >>> rectangle_area_dynamic(l, l+2)\n    l*(l + 2)", "Freq": 0, "TSR": 0}, {"tool": "def composite_area_calculations(*areas, subtract=False):\n    \n    if subtract:\n        return areas[0] - sum(areas[1:])\n    else:\n        return sum(areas)", "subfield": "Area Calculation", "tool_name": "composite_area_calculations", "tool_type": "function", "description": "Compute the total or net area of multiple individual areas, supporting both sum and subtraction operations.", "docstring": "Compute the total or net area of multiple individual areas, supporting both sum and subtraction operations.\n    Parameters:\n        areas (list of floats): A list of individual areas.\n        subtract (bool): If True, subtracts areas instead of summing them.\n    Returns:\n        float: Total or net area after performing the sum or subtraction.\n    Example:\n        >>> composite_area_calculations(10, 5, 15)\n        30\n        >>> composite_area_calculations(10, 3, subtract=True)\n        7", "Freq": 0, "TSR": 0}, {"tool": "def line_equation_from_points(x1, y1, x2, y2):\n    \n    if x2 != x1:\n        slope = (y2 - y1) / (x2 - x1)\n        intercept = y1 - slope * x1\n        return slope, intercept\n    else:\n        return float('inf'), x1", "subfield": "Area Calculation", "tool_name": "line_equation_from_points", "tool_type": "function", "description": "Calculate the slope and y-intercept of the line passing through two points.", "docstring": "Calculate the slope and y-intercept of the line passing through two points.\n    Parameters:\n    x1, y1 (float): Coordinates of the first point.\n    x2, y2 (float): Coordinates of the second point.\n    Returns:\n    tuple: Slope and y-intercept of the line.\n    Examples:\n    >>> line_equation_from_points(0, 0, 2, 2)\n    (1.0, 0.0)\n    >>> line_equation_from_points(1, 2, 3, 8)\n    (3.0, -1.0)", "Freq": 0, "TSR": 0}, {"tool": "def pythagorean_triplet(a, b, c):\n    \n    return abs((a ** 2) + (b ** 2) - (c ** 2)) < 0.001", "subfield": "Area Calculation", "tool_name": "pythagorean_triplet", "tool_type": "function", "description": "Check if the three given lengths form a Pythagorean triplet.", "docstring": "Check if the three given lengths form a Pythagorean triplet.\n    Parameters\n    ----------\n    a : float\n        Length of the first side.\n    b : float\n        Length of the second side.\n    c : float\n        Length of the third side (hypotenuse).\n    Returns\n    -------\n    bool\n        `True` if the lengths form a Pythagorean triplet and `False` otherwise", "Freq": 0, "TSR": 0}, {"tool": "class CircleBasedCalculator:\n    \"\"\"\n    A class to calculate various geometrical properties and areas related to circles,\n    including full circles, sectors, and annuli (regions between two concentric circles).\n    \"\"\"\n    @staticmethod\n    def area_of_circle(radius):\n        \"\"\"\n        Calculate the area of a circle using the formula πr².\n        Parameters:\n            radius (float): The radius of the circle.\n        Returns:\n            float: The area of the circle.\n        Example:\n            >>> CircleBasedCalculator.area_of_circle(5)\n            78.53981633974483\n        \"\"\"\n        return math.pi * radius ** 2\n    @staticmethod\n    def area_of_sector(radius, angle_in_degrees):\n        \"\"\"\n        Calculate the area of a sector given the central angle and radius.\n        Parameters:\n            radius (float): The radius of the circle from which the sector is part.\n            angle_in_degrees (float): The angle of the sector in degrees.\n        Returns:\n            float: The area of the sector.\n        Example:\n            >>> CircleBasedCalculator.area_of_sector(5, 90)\n            19.634954084936208\n        \"\"\"\n        return (angle_in_degrees / 360) * math.pi * radius ** 2\n    @staticmethod\n    def area_of_annulus(outer_radius, inner_radius):\n        \"\"\"\n        Calculate the area of an annulus (the region between two concentric circles).\n        Parameters:\n            outer_radius (float): Radius of the outer circle.\n            inner_radius (float): Radius of the inner circle.\n        Returns:\n            float: The area of the annulus.\n        Example:\n            >>> CircleBasedCalculator.area_of_annulus(5, 3)\n            50.26548245743669\n        \"\"\"\n        return math.pi * (outer_radius ** 2 - inner_radius ** 2)\n    @staticmethod\n    def diameter_to_radius(diameter):\n        \"\"\"\n        Convert diameter to radius.\n        Parameters:\n            diameter (float): The diameter of the circle.\n        Returns:\n            float: The radius of the circle.\n        Example:\n            >>> CircleBasedCalculator.diameter_to_radius(10)\n            5.0\n        \"\"\"\n        return diameter / 2", "subfield": "Area Calculation", "tool_name": "CircleBasedCalculator:\n    \"\"\"\n    A class to calculate various geometrical properties and areas related to circles,\n    including full circles, sectors, and annuli", "tool_type": "class", "description": "A class to calculate various geometrical properties and areas related to circles,\n    including full circles, sectors, and annuli (regions between two concentric circles).", "docstring": "A class to calculate various geometrical properties and areas related to circles,\n    including full circles, sectors, and annuli (regions between two concentric circles).", "Freq": 0, "TSR": 0}, {"tool": "def centroid_polygon(vertices: List[Tuple[float, float]]) -> Tuple[float, float]:\n    \n    x_coordinates, y_coordinates = zip(*vertices)\n    num_vertices = len(vertices)\n    centroid_x = sum(x_coordinates) / num_vertices\n    centroid_y = sum(y_coordinates) / num_vertices\n    return (centroid_x, centroid_y)", "subfield": "Area Calculation", "tool_name": "centroid_polygon", "tool_type": "function", "description": "Calculates the centroid (geometric center) of a polygon given its vertices.", "docstring": "Calculates the centroid (geometric center) of a polygon given its vertices.\n    Parameters:\n    - vertices (List[Tuple[float, float]]): Coordinates of the vertices of the polygon.\n    Returns:\n    - Tuple[float, float]: The coordinates of the centroid.\n    Examples:\n    >>> print(centroid_polygon([(0, 0), (4, 0), (4, 4), (0, 4)]))\n    (2.0, 2.0)", "Freq": 0, "TSR": 0}, {"tool": "def TriangleAreaCalculator(base=None, height=None, vertices=None, sides=None):\n    \n    import math\n    if base is not None and height is not None:\n        # Simple calculation from base and height\n        return 0.5 * base * height\n    elif vertices is not None:\n        if len(vertices) != 3:\n            raise ValueError(\"Triangle vertices should have exactly 3 points.\")\n        \n        # Calculate area from vertices using shoelace formula\n        x1, y1 = vertices[0]\n        x2, y2 = vertices[1]\n        x3, y3 = vertices[2]\n        return 0.5 * abs(x1*(y2-y3) + x2*(y3-y1) + x3*(y1-y2))\n    elif sides is not None:\n        if len(sides) != 3:\n            raise ValueError(\"Triangle sides should have exactly 3 lengths.\")\n        \n        # Using Heron's formula to find area when sides are known\n        a, b, c = sides\n        s = 0.5 * sum(sides)\n        area = math.sqrt(s * (s - a) * (s - b) * (s - c))\n        return area\n    else:\n        raise ValueError(\"Insufficient information to calculate area.\")", "subfield": "Area Calculation", "tool_name": "TriangleAreaCalculator", "tool_type": "function", "description": "Calculate the area of a triangle given base and height, vertices, or side lengths.", "docstring": "Calculate the area of a triangle given base and height, vertices, or side lengths.\n    Parameters:\n    - base (float): The base of the triangle.\n    - height (float): The height of the triangle perpendicular to the base.\n    - vertices (list of tuples): List of coordinates for the triangle's vertices as (x, y).\n    - sides (tuple): The lengths of the three sides of the triangle.\n    Returns:\n    - float: The area of the triangle.\n    Examples:\n    - TriangleAreaCalculator(base=5, height=3)\n    - TriangleAreaCalculator(vertices=[(0, 0), (5, 0), (0, 3)])\n    - TriangleAreaCalculator(sides=(3, 4, 5))", "Freq": 1, "TSR": 1, "experience_pool": "- When providing vertices to the `TriangleAreaCalculator` function, ensure that exactly 3 points are included.\n- When providing sides to the `TriangleAreaCalculator` function, ensure that exactly 3 side lengths are included."}, {"tool": "def find_line_intersection(p1, p2, p3, p4):\n    \n    x1, y1 = p1\n    x2, y2 = p2\n    x3, y3 = p3\n    x4, y4 = p4\n    \n    # Calculate the determinants\n    denom = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4)\n    if denom == 0:\n        return 'No unique intersection or lines are collinear'\n    \n    px = ((x1 * y2 - y1 * x2) * (x3 - x4) - (x1 - x2) * (x3 * y4 - y3 * x4)) / denom\n    py = ((x1 * y2 - y1 * x2) * (y3 - y4) - (y1 - y2) * (x3 * y4 - y3 * x4)) / denom\n    return (px, py)", "subfield": "Area Calculation", "tool_name": "find_line_intersection", "tool_type": "function", "description": "Calculate the intersection point of two lines defined by two pairs of points.", "docstring": "Calculate the intersection point of two lines defined by two pairs of points.\n    Parameters:\n    p1, p2 (tuple): (x, y) coordinates for the first and the second point of the first line.\n    p3, p4 (tuple): (x, y) coordinates for the third and the fourth point of the second line.\n    Returns:\n    tuple or str: (x, y) coordinates of the intersection point, or 'No unique intersection' if lines are collinear or do not intersect.\n    Examples:\n    >>> find_line_intersection((0, 0), (1, 1), (1, 0), (0, 1))\n    (0.5, 0.5)\n    >>> find_line_intersection((0, 0), (1, 1), (2, 2), (3, 3))\n    'No unique intersection or lines are collinear'", "Freq": 1, "TSR": 0}, {"tool": "def circle_diameter(radius):\n    \n    return 2 * radius", "subfield": "Area Calculation", "tool_name": "circle_diameter", "tool_type": "function", "description": "The function takes radius of a circle as input \n    and returns its diameter.", "docstring": "The function takes radius of a circle as input \n    and returns its diameter.", "Freq": 0, "TSR": 0}, {"tool": "def derive_side_lengths(shape, **kwargs):\n    \n    if shape == 'triangle_cosine':\n        a, b, angle = kwargs['a'], kwargs['b'], kwargs['angle']\n        angle_rad = np.radians(angle)\n        return sqrt(a**2 + b**2 - 2*a*b*np.cos(angle_rad))\n    elif shape == 'polygon_diagonal':\n        side, n_sides = kwargs['side'], kwargs['n_sides']\n        if n_sides == 4:  # square or rectangle logic\n            return sqrt(2) * side\n        else:\n            raise ValueError(\"Diagonal calculation for this polygon not supported\")", "subfield": "Area Calculation", "tool_name": "derive_side_lengths", "tool_type": "function", "description": "Derive side lengths using geometric and trigonometric relations for various shapes.", "docstring": "Derive side lengths using geometric and trigonometric relations for various shapes.\n    \n    Parameters\n    ----------\n    shape : str\n        Type of geometric shape ('triangle_cosine', 'polygon_diagonal')\n    kwargs: various\n        Known lengths, angles, and other relevant properties depending on the shape.\n    \n    Returns\n    -------\n    float\n        The derived side length or lengths depending on the calculation.\n    \n    Examples\n    --------\n    >>> derive_side_lengths('triangle_cosine', a=5, b=5, angle=60)\n    5.0\n    >>> derive_side_lengths('polygon_diagonal', side=4, n_sides=4)  # Diagonal of a square\n    5.656854249492381", "Freq": 0, "TSR": 0}, {"tool": "def area_trapezoid(base1, base2, height):\n    \n    return 0.5 * (base1 + base2) * height", "subfield": "Area Calculation", "tool_name": "area_trapezoid", "tool_type": "function", "description": "Calculate the area of a trapezoid given the lengths of its two bases and its height.", "docstring": "Calculate the area of a trapezoid given the lengths of its two bases and its height.\n    \n    Parameters:\n        base1 (float): The length of the first base of the trapezoid.\n        base2 (float): The length of the second base of the trapezoid.\n        height (float): The height of the trapezoid, measured perpendicularly between the bases.\n        \n    Returns:\n        float: The area of the trapezoid.\n        \n    Example:\n        >>> area_trapezoid(5, 7, 4)\n        24.0", "Freq": 5, "TSR": 0}, {"tool": "def calculate_perimeter_and_area(shape_type, dimensions):\n    \n    import math\n    \n    def rectangle(length, width):\n        perimeter = 2 * (length + width)\n        area = length * width\n        return perimeter, area\n    def circle(radius):\n        perimeter = 2 * math.pi * radius\n        area = math.pi * radius ** 2\n        return perimeter, area\n    def square(side_length):\n        perimeter = 4 * side_length\n        area = side_length ** 2\n        return perimeter, area\n    def trapezoid(base1, base2, height):\n        perimeter = base1 + base2 + 2 * math.sqrt(height**2 + ((base2 - base1) / 2) ** 2)\n        area = 0.5 * (base1 + base2) * height\n        return perimeter, area\n    def complex_shape(squares, circles):\n        total_perimeter = 0\n        total_area = 0\n        \n        for side in squares:\n            total_perimeter += 4 * side\n            total_area += side ** 2\n        \n        for radius in circles:\n            total_perimeter += 2 * math.pi * radius\n            total_area += math.pi * radius ** 2\n            \n        return total_perimeter, total_area\n    if shape_type == 'rectangle':\n        return rectangle(dimensions['length'], dimensions['width'])\n    elif shape_type == 'circle':\n        return circle(dimensions['radius'])\n    elif shape_type == 'square':\n        return square(dimensions['side_length'])\n    elif shape_type == 'trapezoid':\n        return trapezoid(dimensions['base1'], dimensions['base2'], dimensions['height'])\n    elif shape_type == 'complex':\n        return complex_shape(dimensions['squares'], dimensions['circles'])\n    else:\n        raise ValueError(\"Unsupported shape type.\")", "subfield": "Area Calculation", "tool_name": "calculate_perimeter_and_area", "tool_type": "function", "description": "Calculate the perimeter and area of various geometric shapes based on the provided dimensions.", "docstring": "Calculate the perimeter and area of various geometric shapes based on the provided dimensions.\n    \n    Parameters:\n        shape_type (str): The type of shape ('rectangle', 'circle', 'square', 'trapezoid', 'complex').\n        dimensions (dict): A dictionary containing the necessary dimensions for the shape.\n                           For example:\n                           - Rectangle: {'length': 5, 'width': 3}\n                           - Circle: {'radius': 4}\n                           - Square: {'side_length': 2}\n                           - Trapezoid: {'base1': 4, 'base2': 6, 'height': 3}\n                           - Complex: {'squares': [1, 2, 3], 'circles': [1.5, 2]}\n    \n    Returns:\n        tuple: A tuple containing the perimeter and area of the shape.\n    \n    Example:\n        >>> calculate_perimeter_and_area('rectangle', {'length': 5, 'width': 3})\n        (16, 15)", "Freq": 1, "TSR": 0}], "Triangles": [{"tool": "def triangle_area(base, height):\n    \n    return 0.5 * base * height", "subfield": "Triangles", "tool_name": "triangle_area", "tool_type": "function", "description": "Calculate the area of a triangle using base and height.", "docstring": "Calculate the area of a triangle using base and height.\n    \n    Parameters:\n    base (float): Base of the triangle.\n    height (float): Height of the triangle.\n    Returns:\n    float: Area of the triangle.", "Freq": 8, "TSR": 4, "experience_pool": "Tool for calculating the area of a triangle using base and height is accurate and effective."}, {"tool": "def herons_formula(a, b, c):\n    \n    s = (a + b + c) / 2\n    area = math.sqrt(s * (s - a) * (s - b) * (s - c))\n    return area", "subfield": "Triangles", "tool_name": "herons_formula", "tool_type": "function", "description": "Calculate the area of a triangle using Heron's formula given the sides.", "docstring": "Calculate the area of a triangle using Heron's formula given the sides.\n    \n    Parameters:\n    a, b, c (float): Sides of the triangle.\n    \n    Returns:\n    float: Area of the triangle.", "Freq": 14, "TSR": 5, "experience_pool": "- Make sure to provide the correct side lengths when calling the `herons_formula` function.\n- Double-check the calculations and input values in the calling code to ensure accurate results."}, {"tool": "def is_valid_triangle(a, b, c):\n    \n    return (a+b > c) and (a+c > b) and (b+c > a)", "subfield": "Triangles", "tool_name": "is_valid_triangle", "tool_type": "function", "description": "Determines if three side lengths can form a valid triangle based on the Triangle Inequality Theorem.", "docstring": "Determines if three side lengths can form a valid triangle based on the Triangle Inequality Theorem.\n    Parameters:\n        a (float): The length of the first side.\n        b (float): The length of the second with the limil side.\n        c (float): The length of the third side.\n    Returns:\n        bool: True if the side lengths can form a triangle, False otherwise.\n    Examples:\n    >>> is_valid_triangle(3, 4, 5)\n    True\n    >>> is_valid_triangle(1, 10, 12)\n    False", "Freq": 3, "TSR": 2, "experience_pool": "Tool has been used successfully with a 50.0% success rate."}, {"tool": "def calculate_triangle_area(base=None, height=None, side=None):\n    \n    if base is not None and height is not None:\n        return 0.5 * base * height\n    elif side is not None:\n        # Area of an equilateral triangle: sqrt(3)/4 * side^2\n        return (math.sqrt(3) / 4) * (side**2)\n    else:\n        raise ValueError(\"Invalid inputs given. Provide either base and height for a regular triangle or side for an equilateral triangle.\")", "subfield": "Triangles", "tool_name": "calculate_triangle_area", "tool_type": "function", "description": "Calculate the area of a triangle using base and height or by specifying the sides using Heron's formula for equilateral triangles.", "docstring": "Calculate the area of a triangle using base and height or by specifying the sides using Heron's formula for equilateral triangles.\n    \n    Parameters:\n    base (float, optional): The base of the triangle.\n    height (float, optional): The height of the triangle.\n    side (float, optional): The length of a side if the triangle is equilateral.\n    Returns:\n    float: The area of the triangle.\n    Example:\n    >>> calculate_triangle_area(base=10, height=5)\n    25.0\n    >>> calculate_triangle_area(side=8)  # Equilateral triangle\n    13.856", "Freq": 0, "TSR": 0}, {"tool": "def calculate_third_angle(angle1, angle2):\n    \n    if angle1 + angle2 >= 180 or angle1 <= 0 or angle2 <= 0:\n        return None\n    return 180 - angle1 - angle2", "subfield": "Triangles", "tool_name": "calculate_third_angle", "tool_type": "function", "description": "Calculate the third angle of a triangle given two angles.", "docstring": "Calculate the third angle of a triangle given two angles.\n    Parameters:\n    angle1 (float): The first angle of the triangle in degrees.\n    angle2 (float): The second angle of the triangle in degrees.\n    Returns:\n    float: The third angle of the triangle in degrees, or None if the input angles do not form a valid triangle.", "Freq": 9.5, "TSR": 6, "experience_pool": "- When using the tool to calculate the third angle of a triangle, ensure that the sum of the input angles is less than 180 degrees and that each angle is greater than 0 degrees to form a valid triangle."}, {"tool": "def valid_third_side_range(a, b):\n    \n    return (abs(a - b) + 1, a + b - 1)", "subfield": "Triangles", "tool_name": "valid_third_side_range", "tool_type": "function", "description": "Determines the valid range for potential third side of a triangle given two sides, based on the Triangle Inequality Theorem.", "docstring": "Determines the valid range for potential third side of a triangle given two sides, based on the Triangle Inequality Theorem.\n    \n    Parameters:\n        a (float or int): The length of the first side.\n        b (float or int): The length of the second side.\n        \n    Returns:\n        tuple: A tuple containing the minimum and maximum values for the third side that can still form a triangle.\n    \n    Examples:\n        >>> valid_third_side_range(8, 5)\n        (3, 13)\n        >>> valid_third_side_range(15, 10)\n        (6, 24)", "Freq": 5, "TSR": 3, "experience_pool": "- Make sure to provide the correct side lengths when calling the valid_third_side_range function.\n- Ensure that the calling code correctly interprets the output of the valid_third_side_range function to get the desired result."}, {"tool": "def midpoint(x1, y1, x2, y2):\n    \n    return ((x1 + x2) / 2, (y1 + y2) / 2)", "subfield": "Triangles", "tool_name": "midpoint", "tool_type": "function", "description": "Calculate the midpoint of a segment given the coordinates of its endpoints.", "docstring": "Calculate the midpoint of a segment given the coordinates of its endpoints.\n    \n    Parameters:\n        x1, y1 (float): Coordinates of the first endpoint.\n        x2, y2 (float): Coordinates of the second endpoint.\n    \n    Returns:\n        tuple: The coordinates of the midpoint.\n    \n    Examples:\n        >>> midpoint(1, 1, 4, 5)\n        (2.5, 3.0)", "Freq": 2, "TSR": 1}, {"tool": "def calculate_side_range_and_perimeter(a: float, b: float) -> Tuple[Tuple[int, int], int]:\n    \n    if a <= 0 or b <= 0:\n        raise ValueError(\"Side lengths must be positive numbers\")\n    min_c = max(abs(a - b) + 1, 1)\n    max_c = a + b - 1\n    max_perimeter = a + b + max_c\n    return ((min_c, max_c), max_perimeter)", "subfield": "Triangles", "tool_name": "calculate_side_range_and_perimeter", "tool_type": "function", "description": "Calculate the possible values for the third side of a triangle when two sides are known.\n    Also, returns the maximal possible integer perimeter.", "docstring": "Calculate the possible values for the third side of a triangle when two sides are known.\n    Also, returns the maximal possible integer perimeter.\n    \n    Parameters:\n    a (float): Length of the first known side of the triangle.\n    b (float): Length of the second known side of the triangle.\n    \n    Returns:\n    Tuple[Tuple[int, int], int]: Returns a tuple containing another tuple and an integer. \n    The inner tuple represents the minimum and maximum possible integer values for the third side,\n    while the integer represents the maximum possible integer perimeter if the maximum side length is used.\n    \n    Examples:\n    >>> calculate_side_range_and_perimeter(3, 4)\n    ((2, 6), 13)\n    >>> calculate_side_range_and_perimeter(5, 10)\n    ((6, 14), 29)", "Freq": 10, "TSR": 3, "experience_pool": "1. The tool `calculate_side_range_and_perimeter` accurately calculates the possible range for the third side of a triangle and the maximum perimeter.\n2. Ensure that the input parameters provided to the tool are correct and within the valid range of positive numbers.\n3. The tool handles cases where the input sides are positive numbers appropriately."}, {"tool": "def triangle_side_lengths(a, b, c):\n    \n    # Convert tuples to Points\n    p1, p2, p3 = Point(a), Point(b), Point(c)\n    # Create triangle ABC\n    triangle_abc = Triangle(p1, p2, p3)\n    \n    # Calculate side lengths\n    ab = triangle_abc.ab.length.evalf()\n    bc = triangle_abc.bc.length.evalf()\n    ca = triangle_abc.ca.length.evalf()\n    \n    return {'ab': ab, 'bc': bc, 'ca': ca}", "subfield": "Triangles", "tool_name": "triangle_side_lengths", "tool_type": "function", "description": "Calculate the triangle side lengths given vertices a, b, and c.", "docstring": "Calculate the triangle side lengths given vertices a, b, and c.\n    Parameters:\n        a (tuple): Coordinates of vertex a (x1, y1)\n        b (tuple): Coordinates of vertex b (x2, y2)\n        c (tuple): Coordinates of vertex c (x3, y3)\n    \n    Returns:\n        A dictionary with side lengths ab, bc, and ca.", "Freq": 1, "TSR": 0}, {"tool": "def solve_triangle(a, b, A):\n    \n    A = math.radians(A)  # Convert angle A from degrees to radians\n    sin_A = math.sin(A)\n    sin_B = (b * sin_A) / a\n    if sin_B > 1 or sin_B < -1:  # Check for invalid triangle configuration\n        return None\n    B = math.asin(sin_B)\n    C = math.pi - A - B\n    c = (a * math.sin(C)) / sin_A\n    return (c, math.degrees(B), math.degrees(C))", "subfield": "Triangles", "tool_name": "solve_triangle", "tool_type": "function", "description": "Calculate the missing side c and the remaining angles B and C in a triangle using the Law of Sines.\n    The provided angles must be in degrees.", "docstring": "Calculate the missing side c and the remaining angles B and C in a triangle using the Law of Sines.\n    The provided angles must be in degrees.\n    \n    Parameters:\n        a (float): The length of side a.\n        b (float): The length of side b.\n        A (float): The angle opposite to side a in degrees.\n    \n    Returns:\n        tuple: Returns the length of side c and the angles B and C in degrees.\n    \n    Example:\n        >>> solve_triangle(3, 4, 30)\n        (2.3094, 53.1301, 96.8699)", "Freq": 3, "TSR": 0, "experience_pool": "Tool for solving triangles using the Law of Sines is accurate and working as intended.\nEnsure correct input parameters and calculations in the calling code for accurate results."}, {"tool": "def is_right_triangle(a, b, c):\n    \n    sides = sorted([a, b, c])\n    return math.isclose(sides[0]**2 + sides[1]**2, sides[2]**2)", "subfield": "Triangles", "tool_name": "is_right_triangle", "tool_type": "function", "description": "Determine if a triangle with sides a, b, c is a right triangle.", "docstring": "Determine if a triangle with sides a, b, c is a right triangle.\n    \n    Parameters:\n    a, b, c (float): Sides of the triangle.\n    Returns:\n    bool: True if the triangle is right, False otherwise.", "Freq": 0, "TSR": 0}, {"tool": "def area_by_inradius_semiperimeter(inradius: float, semiperimeter: float) -> float:\n    \n    return inradius * semiperimeter", "subfield": "Triangles", "tool_name": "area_by_inradius_semiperimeter", "tool_type": "function", "description": "Calculate the area of a triangle given the inradius and the semiperimeter.", "docstring": "Calculate the area of a triangle given the inradius and the semiperimeter.\n    Parameters:\n    - inradius (float): The radius of the inscribed circle of the triangle.\n    - semiperimeter (float): The semiperimeter of the triangle.\n    Returns:\n    - float: The area of the triangle.\n    Examples:\n    >>> area_by_inradius_semiperimeter(1, 6)\n    6.0", "Freq": 2, "TSR": 2}, {"tool": "def calculate_distance(point1, point2):\n    \n    return math.sqrt((point2[0] - point1[0])**2 + (point2[1] - point1[1])**2)", "subfield": "Triangles", "tool_name": "calculate_distance", "tool_type": "function", "description": "Calculate the Euclidean distance between two points in 2D space.", "docstring": "Calculate the Euclidean distance between two points in 2D space.\n    \n    Parameters:\n        point1 (tuple): The (x, y) coordinates of the first point.\n        point2 (tuple): The (x, y) coordinates of the second point.\n    \n    Returns:\n        float: The distance between the two points.\n    \n    Example:\n        >>> calculate_distance((1, 1), (4, 5))\n        5.0", "Freq": 3, "TSR": 3}, {"tool": "def angle_between_vectors(x1, y1, x2, y2):\n    \n    dot_product = x1 * x2 + y1 * y2\n    magnitude1 = math.sqrt(x1**2 + y1**2)\n    magnitude2 = math.sqrt(x2**2 + y2**2)\n    angle_radians = math.acos(dot_product / (magnitude1 * magnitude2))\n    return math.degrees(angle_radians)", "subfield": "Triangles", "tool_name": "angle_between_vectors", "tool_type": "function", "description": "Calculate the angle (in degrees) between two vectors originating from the origin.", "docstring": "Calculate the angle (in degrees) between two vectors originating from the origin.\n    \n    Parameters:\n        x1, y1 (float): Components of the first vector.\n        x2, y2 (float): Components of the second vector.\n    \n    Returns:\n        float: The angle in degrees between two vectors.\n    \n    Examples:\n        >>> angle_between_vectors(1, 0, 0, 1)\n        90.0", "Freq": 2, "TSR": 0}, {"tool": "def triangle_similarity_by_sss(a_lengths, b_lengths):\n    \n    # Extracting lengths in sorted order\n    a_sorted = sorted(a_lengths.values())\n    b_sorted = sorted(b_lengths.values())\n    \n    # Checking proportionality\n    ratios = [a/b for a, b in zip(a_sorted, b_sorted)]\n    first_ratio = ratios[0]\n    \n    return all(abs(r - first_ratio) < 1e-9 for r in ratios)", "subfield": "Triangles", "tool_name": "triangle_similarity_by_sss", "tool_type": "function", "description": "Determine if two triangles are similar by Side-Side-Side (SSS) similarity criterion.", "docstring": "Determine if two triangles are similar by Side-Side-Side (SSS) similarity criterion.\n    Parameters:\n        a_lengths (dict): Side lengths of triangle A {'ab': length1, 'bc': length2, 'ca': length3}\n        b_lengths (dict): Side lengths of triangle B {'ab': length1, 'bc': length2, 'ca': length3}\n    \n    Returns:\n        bool: True if triangles are similar, False otherwise.", "Freq": 1, "TSR": 0}, {"tool": "def pythagorean_theorem(a=None, b=None, c=None):\n    \n    import math\n    \n    if a is None:\n        return math.sqrt(c**2 - b**2)\n    elif b is None:\n        return math.sqrt(c**2 - a**2)\n    elif c is None:\n        return math.sqrt(a**2 + b**2)\n    else:\n        raise ValueError(\"Exactly one side must be None to find its length\")", "subfield": "Triangles", "tool_name": "pythagorean_theorem", "tool_type": "function", "description": "Apply the Pythagorean theorem to find the missing side of a right triangle.", "docstring": "Apply the Pythagorean theorem to find the missing side of a right triangle.\n    Parameters:\n        a (float, optional): length of side a, leg of the triangle\n        b (float, optional): length of side b, leg of the triangle\n        c (float, optional): length of side c, hypotenuse of the triangle\n    Returns:\n        float: The length of the missing side.\n    Examples:\n    >>> pythagorean_theorem(a=3, b=4)\n    5.0\n    >>> pythagorean_theorem(c=10, b=6)\n    8.0", "Freq": 4, "TSR": 1}, {"tool": "def compute_pythagorean_side_length(side1, side2, target_side):\n    \n    if target_side == \"hypotenuse\":\n        return math.sqrt(side1**2 + side2**2)\n    else:\n        return math.sqrt(max(side1, side2)**2 - min(side1, side2)**2)", "subfield": "Triangles", "tool_name": "compute_pythagorean_side_length", "tool_type": "function", "description": "Applies the Pythagorean theorem to compute a side length in a right triangle.", "docstring": "Applies the Pythagorean theorem to compute a side length in a right triangle.\n    Parameters\n    ----------\n    side1 : float\n        Length of one side of the triangle.\n    side2 : float\n        Length of another side of the triangle.\n    target_side : str\n        The side to compute. It can either be \"leg\" if both given sides are legs, or \"hypotenuse\" if one of the given sides is the hypotenuse.\n    \n    Returns\n    -------\n    float\n        The length of the requested side.\n    Example\n    -------\n    >>> compute_pythagorean_side_length(3, 4, \"hypotenuse\")\n    5.0", "Freq": 0, "TSR": 0}, {"tool": "def triangle_side_length(coord1, coord2):\n    \n    x1, y1 = coord1\n    x2, y2 = coord2\n    return math.sqrt((x2 - x1)**2 + (y2 - y1)**2)", "subfield": "Triangles", "tool_name": "triangle_side_length", "tool_type": "function", "description": "Function that calculates the length of a side of a triangle given the coordinates of its endpoints.", "docstring": "Function that calculates the length of a side of a triangle given the coordinates of its endpoints.\n    Parameters:\n    coord1 (tuple): coordinates of the first endpoint of the side. coord1 is a tuple of two numbers (x1, y1)\n    coord2 (tuple): coordinates of the second endpoint of the side. coord2 is a tuple of two numbers (x2, y2)\n    \n    Returns:\n    float: length of the side calculated by the distance formula sqrt((x2 - x1)**2 + (y2 - y1)**2)\n    \n    Examples:\n    >>> triangle_side_length((0,0), (3,4))\n    5.0", "Freq": 0, "TSR": 0}, {"tool": "def calculate_right_triangle_sides(known_side, hypotenuse=None, other_side=None):\n    \n    if hypotenuse:\n        return math.sqrt(hypotenuse**2 - known_side**2)\n    elif other_side:\n        return math.sqrt(known_side**2 + other_side**2)\n    else:\n        raise ValueError('Either hypotenuse or the other side must be known.')", "subfield": "Triangles", "tool_name": "calculate_right_triangle_sides", "tool_type": "function", "description": "Given a side and either the hypotenuse or the other side, calculate the missing side using Pythagoras' theorem.", "docstring": "Given a side and either the hypotenuse or the other side, calculate the missing side using Pythagoras' theorem.\n    Parameters:\n    - known_side (float): Length of one known side of the right triangle.\n    - hypotenuse (float, optional): Hypotenuse of the triangle, if known.\n    - other_side (float, optional): The other side (leg) of the triangle, if known.\n    Returns:\n    float: The length of the missing side.\n    \n    Example:\n    >>> calculate_right_triangle_sides(3, hypotenuse=5)\n    4.0", "Freq": 1, "TSR": 0}, {"tool": "def equilateral_triangle_properties(side_length: float) -> dict:\n    \n    from math import sqrt\n    perimeter = 3 * side_length\n    area = (sqrt(3) / 4) * side_length**2\n    return {'perimeter': perimeter, 'area': area}", "subfield": "Triangles", "tool_name": "equilateral_triangle_properties", "tool_type": "function", "description": "Calculate the perimeter and area of an equilateral triangle given its side length.", "docstring": "Calculate the perimeter and area of an equilateral triangle given its side length.\n    Parameters\n    ----------\n    side_length : float\n        The length of one side of the equilateral triangle.\n    Returns\n    -------\n    dict\n        A dictionary containing the perimeter and area of the equilateral triangle.\n    Examples\n    --------\n    >>> equilateral_triangle_properties(5)\n    {'perimeter': 15.0, 'area': 10.825317547305486}", "Freq": 0, "TSR": 0}, {"tool": "def calculate_triangle_perimeter(sides):\n    \n    return sum(sides)", "subfield": "Triangles", "tool_name": "calculate_triangle_perimeter", "tool_type": "function", "description": "Calculate the perimeter of a triangle given the lengths of the sides.", "docstring": "Calculate the perimeter of a triangle given the lengths of the sides.\n    Parameters:\n    - sides (tuple/list): A collection of the three side lengths.\n    Returns:\n    float: The perimeter of the triangle.\n    \n    Example:\n    >>> calculate_triangle_perimeter((3, 4, 5))\n    12", "Freq": 1, "TSR": 1}, {"tool": "def triangle_angle_sum():\n    \n    return 180", "subfield": "Triangles", "tool_name": "triangle_angle_sum", "tool_type": "function", "description": "Return the sum of angles in any triangle, in degrees.\n    Returns:\n    int: The sum of the internal angles of a triangle, always 180 degrees.\n    \n    Example:\n    >>> triangle_angle_sum()\n    180", "docstring": "Return the sum of angles in any triangle, in degrees.\n    Returns:\n    int: The sum of the internal angles of a triangle, always 180 degrees.\n    \n    Example:\n    >>> triangle_angle_sum()\n    180", "Freq": 0, "TSR": 0}, {"tool": "def triangle_properties(base, height, side=None):\n    \n    import sympy\n    # Calculate Area\n    area = 0.5 * base * height\n    # Calculate Hypotenuse\n    if side is not None:\n        hypotenuse = sqrt(base**2 + side**2)\n    else:\n        hypotenuse = None\n    return area, hypotenuse", "subfield": "Triangles", "tool_name": "triangle_properties", "tool_type": "function", "description": "Given the base and height of a triangle, calculate and return the area and hypotenuse length.", "docstring": "Given the base and height of a triangle, calculate and return the area and hypotenuse length.\n    Parameters:\n    base (float): The length of the base of the triangle.\n    height (float): The length of the height of the triangle.\n    side (float, optional): The length of one of the side of a right triangle to calculate the length of the hypotenuse \n    Returns:\n    area (float): The area of the triangle.\n    hypotenuse (float or None): The length of the hypotenuse of the triangle if side length is provided. None otherwise.", "Freq": 0, "TSR": 0}, {"tool": "def centroid_triangle_area(A, B, C):\n    \n    def triangle_area(x1, y1, x2, y2, x3, y3):\n        \n        return abs((x1*(y2 - y3) + x2*(y3 - y1) + x3*(y1 - y2)) / 2.0)\n    # Calculate the centroid of triangle ABC\n    G = ((A[0] + B[0] + C[0]) / 3, (A[1] + B[1] + C[1]) / 3)\n    # Calculate the centroids of the sub-triangles\n    G1 = ((B[0] + C[0] + G[0]) / 3, (B[1] + C[1] + G[1]) / 3)\n    G2 = ((C[0] + A[0] + G[0]) / 3, (C[1] + A[1] + G[1]) / 3)\n    G3 = ((A[0] + B[0] + G[0]) / 3, (A[1] + B[1] + G[1]) / 3)\n    # Calculate the area of triangle G1G2G3\n    area_G1G2G3 = triangle_area(G1[0], G1[1], G2[0], G2[1], G3[0], G3[1])\n    \n    return area_G1G2G3", "subfield": "Triangles", "tool_name": "centroid_triangle_area", "tool_type": "function", "description": "Calculate the area of the triangle formed by the centroids of triangles PBC, PCA, and PAB,\n    where P is a point inside triangle ABC.", "docstring": "Calculate the area of the triangle formed by the centroids of triangles PBC, PCA, and PAB,\n    where P is a point inside triangle ABC.\n    Parameters:\n    A (tuple): Coordinates of point A (x1, y1).\n    B (tuple): Coordinates of point B (x2, y2).\n    C (tuple): Coordinates of point C (x3, y3).\n    Returns:\n    float: Area of the triangle formed by the centroids of the sub-triangles.", "Freq": 0, "TSR": 0}, {"tool": "def triangle_properties(a, b, c=None):\n    \n    import math\n    \n    def law_of_cosines(a, b, c):\n        \n        return math.degrees(math.acos((a**2 + b**2 - c**2) / (2 * a * b)))\n    if c is not None:\n        # Calculate the angles\n        angle_A = law_of_cosines(b, c, a)\n        angle_B = law_of_cosines(a, c, b)\n        angle_C = law_of_cosines(a, b, c)\n        return max(angle_A, angle_B, angle_C)\n    # If c is not provided, calculate the valid range for the third side\n    min_c = abs(a - b) + 1  # Must be greater than the difference of the two sides\n    max_c = a + b - 1       # Must be less than the sum of the two sides\n    return {'valid_range': (min_c, max_c)}", "subfield": "Triangles", "tool_name": "triangle_properties", "tool_type": "function", "description": "Calculate the largest angle of a triangle given two sides and optionally the third side.\n    Also determines the valid range for the third side based on the other two sides.", "docstring": "Calculate the largest angle of a triangle given two sides and optionally the third side.\n    Also determines the valid range for the third side based on the other two sides.\n    \n    Parameters:\n    a (float): Length of side a.\n    b (float): Length of side b.\n    c (float, optional): Length of side c. If not provided, the function will calculate the largest angle.\n    \n    Returns:\n    dict: A dictionary containing the largest angle in degrees if c is provided, \n           or the valid range for the third side if c is not provided.", "Freq": 1, "TSR": 0}], "Parabolas": [{"tool": "def vertex_from_quadratic(a, b, c):\n    \n    h = -b / (2 * a)\n    k = a * h**2 + b * h + c\n    return h, k", "subfield": "Parabolas", "tool_name": "vertex_from_quadratic", "tool_type": "function", "description": "Calculates the vertex (h, k) of a parabola given its quadratic coefficients.", "docstring": "Calculates the vertex (h, k) of a parabola given its quadratic coefficients.\n    Parameters:\n        a (float): Coefficient of x^2.\n        b (float): Coefficient of x.\n        c (float): Constant term.\n    Returns:\n        tuple: The vertex (h, k) of the parabola.\n    Example:\n        >>> vertex_from_quadratic(1, -4, 4)\n        (2, 0)", "Freq": 2, "TSR": 1}, {"tool": "def parabola_properties(equation):\n    \n    x = sp.symbols('x')\n    a = equation.expand().coeff(x, 2)\n    b = equation.expand().coeff(x, 1)\n    c = equation.expand().coeff(x, 0)\n    # Vertex formula\n    xv = -b / (2 * a)\n    yv = equation.subs(x, xv)\n    vertex = (xv, yv)\n    # Focus and directrix\n    focus_x = xv\n    focus_y = yv + 1/(4*a)\n    focus = (focus_x, focus_y)\n    directrix = yv - 1/(4*a)\n    return {\n        \"vertex\": vertex,\n        \"focus\": focus,\n        \"directrix\": directrix,\n        \"axis of symmetry\": xv\n    }", "subfield": "Parabolas", "tool_name": "parabola_properties", "tool_type": "function", "description": "Given a quadratic equation, compute key properties of the corresponding parabola.", "docstring": "Given a quadratic equation, compute key properties of the corresponding parabola.\n    Parameters:\n    equation (sp.Expr): A sympy expression representing the quadratic equation y = ax^2 + bx + c.\n    Returns:\n    dict: A dictionary containing the vertex, focus, directrix, and axis of symmetry of the parabola.\n    Examples:\n    >>> x, y = sp.symbols('x y')\n    >>> eq = x**2 - 4*x + 4\n    >>> properties = parabola_properties(eq)\n    >>> print(properties[\"vertex\"])\n    (2, 0)\n    >>> print(properties[\"focus\"])\n    (2, 0.25)", "Freq": 6, "TSR": 4}, {"tool": "def tangent_to_parabola(point, equation):\n    \n    x, y = sp.symbols('x y')\n    x0, y0 = point\n    \n    # Derivative to find slope\n    dy_dx = sp.diff(equation, x)\n    slope = dy_dx.subs(x, x0)\n    tangent_eq = y - y0 - slope * (x - x0)\n    \n    return tangent_eq", "subfield": "Parabolas", "tool_name": "tangent_to_parabola", "tool_type": "function", "description": "Find the equation of the tangent line at a given point on the parabola y = ax^2 + bx + c.", "docstring": "Find the equation of the tangent line at a given point on the parabola y = ax^2 + bx + c.\n    Parameters:\n    point (tuple): A tuple (x0, y0) representing the point of tangency.\n    equation (sp.Expr): A sympy expression representing the quadratic parabola.\n    Returns:\n    sp.Expr: An equation representing the tangent line at the given point.\n    Examples:\n    >>> x, y = sp.symbols('x y')\n    >>> eq = x**2 - 6*x + 9\n    >>> point = (3, 0)\n    >>> tangent_line = tangent_to_parabola(point, eq)\n    >>> print(tangent_line)\n    y - 0 = 0*(x - 3)", "Freq": 0, "TSR": 0}, {"tool": "def parabola_line_intersection(a, b, c, line_slope, line_intercept):\n    \n    from numpy import roots\n    from numpy import array\n    \n    # Finding roots of the quadratic equation formed by setting y values equal\n    quadratic = [a, b - line_slope, c - line_intercept]\n    x_roots = roots(quadratic)\n    \n    # Filter only real roots\n    x_roots = x_roots[abs(x_roots.imag) < 1e-6].real\n    y_roots = line_slope * x_roots + line_intercept\n    \n    # Construct the result array\n    points = array(list(zip(x_roots, y_roots)))\n    return points", "subfield": "Parabolas", "tool_name": "parabola_line_intersection", "tool_type": "function", "description": "Computes the intersection points of a parabola y = ax^2 + bx + c with a line y = mx + n.", "docstring": "Computes the intersection points of a parabola y = ax^2 + bx + c with a line y = mx + n.\n    Parameters:\n    a : float\n        Coefficient 'a' of the parabola.\n    b : float\n        Coefficient 'b' of the parabola.\n    c : float\n        Coefficient 'c' of the parabola.\n    line_slope : float\n        Slope 'm' of the line.\n    line_intercept : float\n        Intercept 'n' of the line.\n    Returns:\n    numpy.array\n        Array containing the intersection points (x, y). Can be empty if there are no real intersections.\n    Examples:\n    >>> parabola_line_intersection(1, 0, -1, 1, 0)\n    array([[-1.61803399, -1.61803399], [0.61803399, 0.61803399]])", "Freq": 1, "TSR": 1}, {"tool": "def distance_point_to_line(px, py, a, b, c):\n    \n    return abs(a*px + b*py + c) / np.sqrt(a**2 + b**2)", "subfield": "Parabolas", "tool_name": "distance_point_to_line", "tool_type": "function", "description": "Calculates the distance from a point (px, py) to a line ax + by + c = 0.", "docstring": "Calculates the distance from a point (px, py) to a line ax + by + c = 0.\n    Parameters:\n    px (float): x-coordinate of the point\n    py (float): y-coordinate of the point\n    a (float): coefficient of x in the line equation\n    b (float): coefficient of y in the line equation\n    c (float): constant term of the line equation\n    Returns:\n    float: The distance from the point to the line.\n    Examples:\n    >>> distance_point_to_classes(1, 2, 1, -1, 0)\n    0.7071067811865476", "Freq": 1, "TSR": 1}, {"tool": "def parabola_equation(vertex, point=None, focus=None):\n    \n    x, y = sp.symbols('x y')\n    xv, yv = vertex\n    if point:\n        xp, yp = point\n        a = (yp - yv) / ((xp - xv)**2)\n        return a * (x - xv)**2 + yv\n    if focus:\n        xf, yf = focus\n        a = 1 / (4 * (yf - yv))\n        return a * (x - xv)**2 + yv", "subfield": "Parabolas", "tool_name": "parabola_equation", "tool_type": "function", "description": "Given a vertex and either a point on the parabola or the focus, this function returns the parabola's equation.", "docstring": "Given a vertex and either a point on the parabola or the focus, this function returns the parabola's equation.\n    Parameters:\n    vertex (tuple): A tuple (xv, yv) representing the vertex of the parabola.\n    point (tuple, optional): A tuple (x, y) representing another point on the parabola.\n    focus (tuple, optional): A tuple (xf, yf) representing the focus of the parabola.\n    Returns:\n    sp.Expr: A sympy expression representing the quadratic equation y = ax^2 + bx + c.\n    Examples:\n    >>> vertex = (2, 3)\n    >>> point = (0, 7)\n    >>> equation = parabola_equation(vertex, point=point)\n    >>> print(equation)\n    y = (x - 2)**2 + 3", "Freq": 2, "TSR": 1}, {"tool": "def curve_intersection(eq1, eq2, var1='x', var2='y'):\n    \n    x, y = sp.symbols(var1 + ' ' + var2)\n    intersection_points = sp.solve((eq1, eq2), (x, y))\n    return intersection_points", "subfield": "Parabolas", "tool_name": "curve_intersection", "tool_type": "function", "description": "Calculate intersection points between two curves given by their equations.", "docstring": "Calculate intersection points between two curves given by their equations.\n    \n    Parameters:\n    - eq1 (sp.Expr): The first curve equation in symbols.\n    - eq2 (sp.Expr): The second curve equation in symbols.\n    - var1 (str): The primary variable in the equations (default: 'x').\n    - var2 (str): The secondary variable in the equations (default: 'y').\n    Returns:\n    - list of tuples: List of intersection points.\n    Examples:\n    >>> x, y = sp.symbols('x y')\n    >>> parabola = y - x**2\n    >>> circle = x**2 + y**2 - 5\n    >>> curve_intersection(parabola, circle)\n    [(sqrt(5)/sqrt(3), 5/3), (-sqrt(5)/sqrt(3), 5/3)]", "Freq": 2, "TSR": 2}], "Polygons": [{"tool": "def sum_of_interior_angles(n):\n    \n    return 180 * (n - 2)", "subfield": "Polygons", "tool_name": "sum_of_interior_angles", "tool_type": "function", "description": "Calculate the sum of the interior angles of an n-sided polygon.", "docstring": "Calculate the sum of the interior angles of an n-sided polygon.\n    \n    Parameters\n    ----------\n    n : int\n        Number of sides of the polygon\n    \n    Returns\n    -------\n    int\n        Sum of the interior angles in degrees\n    \n    Examples\n    --------\n    >>> sum_of_interior_angles(4)\n    360\n    \n    >>> sum_of_interior_angles(5)\n    540", "Freq": 12, "TSR": 6}, {"tool": "def exterior_angle_from_interior(interior_angle):\n    \n    return 180 - interior_angle", "subfield": "Polygons", "tool_name": "exterior_angle_from_interior", "tool_type": "function", "description": "Calculate the exterior angle of a polygon from its interior angle.", "docstring": "Calculate the exterior angle of a polygon from its interior angle.\n    Parameters:\n    - interior_angle (float or int): Interior angle of the polygon in degrees.\n    Returns:\n    - float: Exterior angle corresponding to the given interior angle.\n    Examples:\n    >>> exterior_angle_from_interior(90)\n    90.0\n    >>> exterior_angle_from_interior(120)\n    60.0", "Freq": 1, "TSR": 0}, {"tool": "def distance_between_points(p1, p2):\n    \n    return math.sqrt((p2[0] - p1[0])**2 + (p2[1] - p1[1])**2)", "subfield": "Polygons", "tool_name": "distance_between_points", "tool_type": "function", "description": "Calculate the Euclidean distance between two points in the Cartesian plane.", "docstring": "Calculate the Euclidean distance between two points in the Cartesian plane.\n    Parameters\n    ----------\n    p1 : tuple of float\n        Coordinates (x, y) of the first point.\n    p2 : tuple of float\n        Coordinates (x, y) of the second point.\n    Returns\n    -------\n    float\n        Distance between the two points.\n    Examples\n    --------\n    >>> distance_between_points((1, 2), (4, 6))\n    5.0", "Freq": 1, "TSR": 1}, {"tool": "def polygon_exterior_angle(n):\n    \n    if n < 3:\n        raise ValueError(\"A polygon must have at least 3 sides.\")\n    return 360 / n", "subfield": "Polygons", "tool_name": "polygon_exterior_angle", "tool_type": "function", "description": "Calculate the exterior angle of an n-sided regular polygon.", "docstring": "Calculate the exterior angle of an n-sided regular polygon.\n    \n    Parameters:\n    - n: int, number of sides of the polygon\n    \n    Returns:\n    - float, measure of the exterior angle in degrees", "Freq": 3, "TSR": 0}, {"tool": "def polygon_angle_properties(n, angle_type='interior'):\n    \n    import math\n    if angle_type == 'interior':\n        if n < 3:\n            raise ValueError(\"A polygon must have at least 3 sides.\")\n        return (n - 2) * 180.0 / n\n    elif angle_type == 'exterior':\n        if n < 3:\n            raise ValueError(\"A polygon must have at least 3 sides.\")\n        return 360.0 / n\n    elif angle_type == 'solve_for_n_interior':\n        # 180(n - 2) / n = angle\n        # 180n - 360 = n * angle\n        # 180n - n * angle = 360\n        # n(180 - angle) = 360\n        # n = 360 / (180 - angle)\n        return round(360 / (180 - n))\n    elif angle_type == 'solve_for_n_exterior':\n        # 360 / n = angle\n        # n = 360 / angle\n        return round(360 / n)\n    else:\n        raise ValueError(\"Invalid angle_type specified. Choose 'interior', 'exterior', 'solve_for_n_interior' or 'solve_for_n_exterior'.\")\n    return None", "subfield": "Polygons", "tool_name": "polygon_angle_properties", "tool_type": "function", "description": "Calculate properties of angles in a regular polygon, including each individual angle and solving for 'n' given an angle.", "docstring": "Calculate properties of angles in a regular polygon, including each individual angle and solving for 'n' given an angle.\n    Parameters:\n    - n (int or float): Number of sides of the polygon, or an interior/exterior angle degree if solving for 'n'.\n    - angle_type (str): Type of calculation - 'interior', 'exterior', or 'solve_for_n_interior','solve_for_n_exterior'.\n    Returns:\n    - float or int: Depending on the angle_type, returns the degree of each angle or the number of sides.\n    Examples:\n    >>> polygon_angle_properties(4)\n    90.0\n    >>> polygon_angle_properties(90, 'solve_for_n_interior')\n    4\n    >>> polygon_angle_properties(45, 'solve_for_n_exterior')\n    8", "Freq": 6, "TSR": 2}, {"tool": "def polygon_diagonals(n):\n    \n    if n < 3:\n        raise ValueError(\"A polygon must have at least 3 sides.\")\n    return n * (n - 3) // 2", "subfield": "Polygons", "tool_name": "polygon_diagonals", "tool_type": "function", "description": "Calculate the number of diagonals in an n-sided polygon.", "docstring": "Calculate the number of diagonals in an n-sided polygon.\n    \n    Parameters:\n    - n: int, number of sides of the polygon\n    \n    Returns:\n    - int, number of diagonals", "Freq": 3, "TSR": 2}, {"tool": "def area_hexagon(side_length):\n    \"\"\"\n    Calculate the area of a regular hexagon given the side length.\n    \n    Parameters:\n    - side_length: float, the length of each side of the hexagle", "subfield": "Polygons", "tool_name": "area_hexagon", "tool_type": "function", "description": "Calculate the area of a regular hexagon given the side length.", "docstring": "Calculate the area of a regular hexagon given the side length.\n    \n    Parameters:\n    - side_length: float, the length of each side of the hexagle", "Freq": 0, "TSR": 0}, {"tool": "def area_square(side_length):\n    \n    return side_length ** 2", "subfield": "Polygons", "tool_name": "area_square", "tool_type": "function", "description": "Calculate the area of a square given the side length.", "docstring": "Calculate the area of a square given the side length.\n    \n    Parameters:\n    - side_length: float, the length of each side of the square\n    \n    Returns:\n    - float, the area of the square", "Freq": 0, "TSR": 0}, {"tool": "def polygon_area(n, side_length):\n    \n    if n < 3 or side_length <= 0:\n        raise ValueError(\"Invalid number of sides or side length.\")\n    apothem = side_length / (2 * tan(pi / n))\n    return 0.5 * n * side_length * apothem", "subfield": "Polygons", "tool_name": "polygon_area", "tool_type": "function", "description": "Calculate the area of a regular n-sided polygon given the side length.", "docstring": "Calculate the area of a regular n-sided polygon given the side length.\n    \n    Parameters:\n    - n: int, number of sides of the polygon\n    - side_length: float, length of one side of the polygon\n    \n    Returns:\n    - float, area of the polygon", "Freq": 0, "TSR": 0}, {"tool": "def calculate_triangle_area(base, height):\n    \n    return 0.5 * base * height", "subfield": "Polygons", "tool_name": "calculate_triangle_area", "tool_type": "function", "description": "Calculate the area of a triangle.", "docstring": "Calculate the area of a triangle.\n    Parameters\n    ----------\n    base: float\n        The length of the base.\n    height: float\n        The length of the height.\n    Returns\n    -------\n    float\n        The area of the triangle.\n    Example\n    -------\n        >>> calculate_triangle_area(10, 5)\n        25.0", "Freq": 0, "TSR": 0}, {"tool": "def calculate_hypotenuse(a, b):\n    \n    return math.sqrt(a**2 + b**2)", "subfield": "Polygons", "tool_name": "calculate_hypotenuse", "tool_type": "function", "description": "Calculate the hypotenuse of a right-angle triangle.", "docstring": "Calculate the hypotenuse of a right-angle triangle.\n    Parameters\n    ----------\n    a: float\n        The length of one leg of the triangle.\n    b: float\n        The length of the other leg of the triangle.\n    Returns\n    -------\n    float\n        The length of the hypotenuse.\n    Example\n    -------\n        >>> calculate_hypotenuse(3, 4)\n        5.0", "Freq": 0, "TSR": 0}], "Right Triangles": [{"tool": "def calculate_hypotenuse(leg1, leg2):\n    \n    return math.sqrt(leg1**2 + leg2**2)", "subfield": "Right Triangles", "tool_name": "calculate_hypotenuse", "tool_type": "function", "description": "Computes the length of the hypotenuse of a right triangle given the lengths of the other two legs.", "docstring": "Computes the length of the hypotenuse of a right triangle given the lengths of the other two legs.\n    Parameters:\n    leg1 (float): Length of the first leg of the triangle.\n    leg2 (float): Length of the second leg of the triangle.\n    Returns:\n    float: The length of the hypotenuse.\n    Examples:\n    >>> calculate_hypotenuse(3, 4)\n    5.0", "Freq": 4, "TSR": 4}, {"tool": "def calculate_right_triangle_side(a=None, b=None, c=None):\n    \n    import math\n    if c is None:\n        # Calculate hypotenuse\n        return math.sqrt(a ** 2 + b ** 2)\n    elif a is None:\n        # Calculate missing side a\n        return math.sqrt(c ** 2 - b ** 2)\n    elif b is None:\n        # Calculate missing side b\n        return math.sqrt(c ** 2 - a ** 2)\n    else:\n        raise ValueError(\"One and only one side length must be None.\")", "subfield": "Right Triangles", "tool_name": "calculate_right_triangle_side", "tool_type": "function", "description": "Calculate the missing side of a right triangle using the Pythagorean Theorem.", "docstring": "Calculate the missing side of a right triangle using the Pythagorean Theorem.\n    \n    Parameters:\n        a (float): The length of side a, or None if it is the unknown side.\n        b (float): The length of side b, or None if it is the unknown side.\n        c (float): The length of the hypotenuse c, or None if it is the unknown side.\n    \n    Returns:\n        float: The length of the missing side.\n        \n    Examples:\n        calculate_right_triangle_side(a=3, b=4)  # Should return 5 as the hypotenuse\n        calculate_right_triangle_side(a=3, c=5)  # Should return 4 as the other side\n        calculate_right_triangle_side(b=4, c=5)  # Should return 3 as the other side", "Freq": 11, "TSR": 7, "experience_pool": "- When finding the distance between two points, ensure that the coordinates are correctly assigned before calling the tool function.\n- When calculating the value of x in a line segment, make sure to calculate the missing side correctly before assigning it to the variable x.\n- When solving trigonometric problems, ensure that the input parameters are correctly used in the calculations."}, {"tool": "def calculate_area(leg1, leg2):\n    \n    return 0.5 * leg1 * leg2", "subfield": "Right Triangles", "tool_name": "calculate_area", "tool_type": "function", "description": "Computes the area of a right triangle.", "docstring": "Computes the area of a right triangle.\n    Parameters:\n    leg1 (float): Length of the first leg of the triangle.\n    leg2 (float): Length of the second leg of the triangle.\n    Returns:\n    float: The area of the right triangle.\n    Examples:\n    >>> calculate_area(3, 4)\n    6.0", "Freq": 1, "TSR": 0}, {"tool": "def is_right_triangle(x1, y1, x2, y2, x3, y3):\n    \n    def distance_sq(xa, ya, xb, yb):\n        return (xb - xa) ** 2 + (yb - ya) ** 2\n    d1_sq = distance_sq(x1, y1, x2, y2)\n    d2_sq = distance_sq(x2, y2, x3, y3)\n    d3_sq = distance_sq(x3, y3, x1, y1)\n    if (d1_sq + d2_sq == d3_sq) or (d2_sq + d3_sq == d1_sq) or (d1_sq + d3_sq == d2_sq):\n        return True\n    else:\n        return False", "subfield": "Right Triangles", "tool_name": "is_right_triangle", "tool_type": "function", "description": "Determines if the points (x1, y1), (x2, y2), (x3, y3) form a right triangle in a 2D plane.", "docstring": "Determines if the points (x1, y1), (x2, y2), (x3, y3) form a right triangle in a 2D plane.\n    \n    Parameters:\n    - x1, y1 (float): Coordinates of the first point.\n    - x2, y2 (float): Coordinates of the second point.\n    - x3, y3 (float): Coordinates of the third point.\n    \n    Returns:\n    - bool: True if the points form a right triangle, False otherwise.\n    \n    Examples:\n    - is_right_triangle(0, 0, 3, 0, 0, 4) -> True\n    - is_right_triangle(1, 1, 1, 5, 1, 9) -> False", "Freq": 0, "TSR": 0}, {"tool": "def is_right_triangle(ax, ay, bx, by, cx, cy):\n    \n    # Calculate squared distances between points\n    AB2 = (bx - ax)**2 + (by - ay)**2\n    AC2 = (cx - ax)**2 + (cy - ay)**2\n    BC2 = (cx - bx)**2 + (cy - by)**2\n    \n    # Check for the Pythagorean relationship between the sides\n    return (AB2 + AC2 == BC2) or (AB2 + BC2 == AC2) or (AC2 + BC2 == AB2)", "subfield": "Right Triangles", "tool_name": "is_right_triangle", "tool_type": "function", "description": "Determines if a triangle formed by three points is a right triangle using distance formula.", "docstring": "Determines if a triangle formed by three points is a right triangle using distance formula.\n    \n    Parameters:\n        ax, ay (float): Coordinates of the first vertex A.\n        bx, by (float): Coordinates of the second vertex B.\n        cx, cy (float): Coordinates of the third vertex C.\n    \n    Returns:\n        bool: True if the triangle is a right triangle, False otherwise.\n    \n    Examples:\n        >>> is_right_triangle(0, 0, 3, 0, 0, 4)\n        True\n        >>> is_right_triangle(0, 0, 2, 2, 4, 0)\n        False", "Freq": 0, "TSR": 0}, {"tool": "def is_right_triangle(side1, side2, side3):\n    \n    sides = sorted([side1, side2, side3])\n    return math.isclose(sides[2]**2, sides[0]**2 + sides[1]**2)", "subfield": "Right Triangles", "tool_name": "is_right_triangle", "tool_type": "function", "description": "Determines whether the given sides can form a right triangle.", "docstring": "Determines whether the given sides can form a right triangle.\n    Parameters:\n    side1, side2, side3 (float): The lengths of the sides of the triangle.\n    Returns:\n    bool: True if the given sides can form a right triangle, False otherwise.\n    Examples:\n    >>> is_right_triangle(3, 4, 5)\n    True\n    >>> is_right_riangle(1, 2, 3)\n    False", "Freq": 0, "TSR": 0}, {"tool": "def pythagorean_theorem(known_side1, known_side2, find='hypotenuse'):\n    \n    if find == 'hypotenuse':\n        return math.sqrt(known_side1**2 + known_side2**2)\n    elif find == 'leg':\n        if known_side1 > known_side2:\n            return math.sqrt(known_side1**2 - known_side2**2)\n        else:\n            return math.sqrt(known_side2**2 - known_side1**2)\n    else:\n        raise ValueError(\"Invalid option for 'find'. Choose 'hypotenuse' or 'leg'.\")", "subfield": "Right Triangles", "tool_name": "pythagorean_theorem", "tool_type": "function", "description": "Solves for a side of a right triangle using the Pythagorean theorem.", "docstring": "Solves for a side of a right triangle using the Pythagorean theorem.\n    \n    Parameters:\n        known_side1 (float): Length of first known side.\n        known_side2 (float): Length of second known side.\n        find (str, optional): Which side to find; choices are 'hypotenuse' or 'leg'. Default is 'hypotenuse'.\n    \n    Returns:\n        float: Length of the unknown side.\n        \n    Examples:\n        >>> pythagorean_theorem(3, 4)\n        5.0\n        >>> pythagorean_theorem(5, 4, find='leg')\n        3.0", "Freq": 2, "TSR": 1}, {"tool": "def find_missing_side(known_sides):\n    \n    a, b, c = known_sides\n    if a is None:\n        return math.sqrt(c**2 - b**2)\n    elif b is None:\n        return math.sqrt(c**2 - a**2)\n    else:  # c is None\n        return math.sqrt(a**2 + b**2)", "subfield": "Right Triangles", "tool_name": "find_missing_side", "tool_type": "function", "description": "Finds the missing side of a right triangle given the other two sides.", "docstring": "Finds the missing side of a right triangle given the other two sides.\n    \n    Parameters:\n    known_sides (list of float or None): List of two known sides and one None indicating the missing side.\n    \n    Returns:\n    float: The missing side of the right triangle.\n    \n    Examples:\n    >>> find_missing_side([3, 4, None])\n    5.0\n    >>> find_missing_side([None, 4, 5])\n    3.0", "Freq": 0, "TSR": 0}, {"tool": "def has_right_angles(ax, ay, bx, by, cx, cy, dx, dy):\n    \n    def dot_product_zero(x1, y1, x2, y2):\n        return x1 * x2 + y1 * y2 == 0\n    # Vectors for AB, BC, CD, DA\n    ABx, ABy = bx - ax, by - ay\n    BCx, BCy = cx - bx, cy - by\n    CDx, CDy = dx - cx, dy - cy\n    DAx, DAy = ax - dx, ay - dy\n    \n    # Check right angles at B, C, D respectively using dot product\n    return (dot_product_zero(ABx, ABy, BCx, BCy) and \n            dot_product_zero(BCx, BCy, CDx, CDy) and \n            dot_product_zero(CDx, CDy, DAx, DAy))", "subfield": "Right Triangles", "tool_name": "has_right_angles", "tool_type": "function", "description": "Checks whether a quadrilateral has right angles at every vertex based on coordinates.", "docstring": "Checks whether a quadrilateral has right angles at every vertex based on coordinates.\n    Parameters:\n        ax, ay (float): Coordinates of the first vertex A.\n        bx, by (float): Coordinates of the second vertex B.\n        cx, cy (float): Coordinates of the third vertex C.\n        dx, dy (float): Coordinates of the fourth vertex D.\n    \n    Returns:\n        bool: True if all angles in the quadrilateral are right angles, False otherwise.\n    \n    Examples:\n        >>> has_right_angles(0, 0, 4, 0, 4, 3, 0, 3)\n        True\n        >>> has_right_angles(0, 0, 4, 0, 5, 3, 1, 3)\n        False", "Freq": 0, "TSR": 0}, {"tool": "def right_triangle_solver(leg1=None, leg2=None, hypotenose=None):\n    \n    if hypotenose and leg1 and leg2 is None:\n        leg2 = sqrt(pow(hypotenose, 2) - pow(leg1, 2))\n        return leg1, leg2, hypotenose\n    elif hypotenose and leg2 and leg1 is None:\n        leg1 = sqrt(pow(hypotenose, 2) - pow(leg2, 2))\n        return leg1, leg2, hypotenose\n    elif leg1 and leg2 and hypotenose is None:\n        hypotenose = sqrt(pow(leg1, 2) + pow(leg2, 2))\n        return leg1, leg2, hypotenose\n    else:\n        raise ValueError(\"Two sides must be provided to solve for the third.\")", "subfield": "Right Triangles", "tool_name": "right_triangle_solver", "tool_type": "function", "description": "Solve any right triangle by determining missing side lengths.", "docstring": "Solve any right triangle by determining missing side lengths.\n    Parameters:\n    leg1 (float, optional): First leg of the triangle.\n    leg2 (float, optional): Second leg of the triangle.\n    hypotenose (float, optional): Hypotenose of the triangle.\n    Returns:\n    tuple: A tuple containing the values (leg1, leg2, hypotenose).\n    Examples:\n    >>> right_triangle_solver(leg1=3, leg2=4)\n    (3, 4, 5.0)\n    >>> right_triangle_solver(leg1=3, hypotenose=5)\n    (3, 4.0, 5)\n    >>> right_triangle_solver(leg2=4, hypotenose=5)\n    (3.0, 4, 5)", "Freq": 0, "TSR": 0}, {"tool": "def triangle_and_rectangle_solver(opposite=None, hypotenuse=None, adjacent=None, rectangle_length=None, rectangle_diagonal=None):\n    \n    \n    import math\n    \n    results = {}\n    \n    # Calculate cosine from sine if opposite and hypotenuse are provided\n    if opposite is not None and hypotenuse is not None:\n        cosine_value = math.sqrt(1 - (opposite / hypotenuse) ** 2)\n        results['cosine'] = cosine_value\n    \n    # Calculate the area of the rectangle if length and diagonal are provided\n    if rectangle_length is not None and rectangle_diagonal is not None:\n        # Use the Pythagorean theorem to find the width of the rectangle\n        width = math.sqrt(rectangle_diagonal ** 2 - rectangle_length ** 2)\n        area = rectangle_length * width\n        results['rectangle_area'] = area\n    \n    return results", "subfield": "Right Triangles", "tool_name": "triangle_and_rectangle_solver", "tool_type": "function", "description": "This function computes trigonometric values based on the sides of a right triangle\n    and calculates the area of a rectangle given its length and diagonal.", "docstring": "This function computes trigonometric values based on the sides of a right triangle\n    and calculates the area of a rectangle given its length and diagonal.\n    \n    Parameters:\n    - opposite: Length of the side opposite the angle (for sine calculations).\n    - hypotenuse: Length of the hypotenuse (for sine and cosine calculations).\n    - adjacent: Length of the side adjacent to the angle (for cosine calculations).\n    - rectangle_length: Length of the rectangle.\n    - rectangle_diagonal: Diagonal of the rectangle.\n    \n    Returns:\n    - A dictionary containing the cosine of the angle if sufficient information is provided,\n      and the area of the rectangle if its dimensions are provided.", "Freq": 1, "TSR": 1}], "Lines and Angles": [{"tool": "def line_equation(point1, point2):\n    \n    x1, y1 = point1\n    x2, y2 = point2\n    A = y2 - y1\n    B = x1 - x2\n    C = A*x1 + B*y1\n    return (A, -B, C)", "subfield": "Lines and Angles", "tool_name": "line_equation", "tool_type": "function", "description": "Return the coefficients of the line equation in the form Ax + By = C using two points.", "docstring": "Return the coefficients of the line equation in the form Ax + By = C using two points.\n    Parameters:\n    point1 (tuple): (x1, y1) coordinates of the first point.\n    point2 (tuple): (x2, y2) coordinates of the second point.\n    \n    Returns:\n    tuple: Coefficients (A, B, C) representing the line Ax + By = C.\n    \n    Examples:\n    >>> line_equation((1, 2), (3, 4))\n    (2, -2, 0)", "Freq": 3, "TSR": 1, "experience_pool": "Tool for calculating line equation is working correctly based on the provided code and examples."}, {"tool": "def find_intersection_of_lines(line1, line2):\n    \n    x, y = symbols('x y')\n    result = solve((line1, line2), (x, y))\n    if result:\n        return (result[x], result[y])\n    return None", "subfield": "Lines and Angles", "tool_name": "find_intersection_of_lines", "tool_type": "function", "description": "Finds the intersection point of two lines, if they intersect.", "docstring": "Finds the intersection point of two lines, if they intersect.\n    \n    Parameters:\n    - line1: sympy.Eq, the equation of the first line.\n    - line2: sympy.Eq, the equation of the second line.\n    Returns:\n    - tuple or None: The (x, y) coordinates of the intersection point or None if no intersection.\n    Example:\n    >>> find_intersection_of_lines(Eq(y, 2*x + 1), Eq(y, -x + 4))\n    (1, 3)", "Freq": 5, "TSR": 0, "experience_pool": "Tool code updated to handle the intersection of lines correctly and prevent dimension errors."}, {"tool": "def calculate_side_length(a, b, angle_C):\n    \n    # Converting angle from degrees to radians\n    angle_C_rad = np.deg2rad(angle_C)\n    \n    # Using Law of Cosines: c^2 = a^2 + b^2 - 2ab*cos(C)\n    c = np.sqrt(a**2 + b**2 - 2*a*b*np.cos(angle_C_rad))\n    return c", "subfield": "Lines and Angles", "tool_name": "calculate_side_length", "tool_type": "function", "description": "Calculate the length of a side in a triangle using the Law of Cosines.", "docstring": "Calculate the length of a side in a triangle using the Law of Cosines.\n    Parameters:\n    a (float): Length of the first side of the triangle.\n    b (float): Length of the second side of the triangle.\n    angle_C (float): Angle opposite the side to be calculated, in degrees.\n    Returns:\n    float: The length of the third side.\n    Examples:\n    >>> calculate_side_length(5, 7, 45)\n    3.80788655293", "Freq": 3, "TSR": 0, "experience_pool": "Tool for calculating side length in a triangle using the Law of Cosines is accurate and efficient."}, {"tool": "def calculate_distance(x1, y1, x2, y2):\n    \n    return math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2)", "subfield": "Lines and Angles", "tool_name": "calculate_distance", "tool_type": "function", "description": "Calculate the Euclidean distance between two points in the 2D coordinate plane.", "docstring": "Calculate the Euclidean distance between two points in the 2D coordinate plane.\n    Parameters:\n    x1, y1 (float): Coordinates of the first point.\n    x2, y2 (float): Coordinates of the second point.\n    Returns:\n    float: The distance between the two points.\n    Examples:\n    >>> calculate_distance(0, 0, 3, 4)\n    5.0", "Freq": 2, "TSR": 2}, {"tool": "def find_midpoint(point1, point2):\n    \n    midpoint = ((point1[0] + point2[0]) / 2, (point1[1] + point2[1]) / 2)\n    return midpoint", "subfield": "Lines and Angles", "tool_name": "find_midpoint", "tool_type": "function", "description": "Calculate the midpoint between two points in a 2D space.", "docstring": "Calculate the midpoint between two points in a 2D space.\n    Parameters:\n    point1 (tuple): The (x, y) coordinates of the first point.\n    point2 (tuple): The (x, y) coordinates of the second point.\n    Returns:\n    tuple: The (x, y) coordinates of the midpoint.\n    Example:\n    >>> find_midpoint((0, 0), (2, 2))\n    (1.0, 1.0)", "Freq": 2, "TSR": 0}, {"tool": "def calculate_supplementary_angle(angle):\n    \n    return 180 - angle", "subfield": "Lines and Angles", "tool_name": "calculate_supplementary_angle", "tool_type": "function", "description": "Calculate the supplementary angle to the given angle (Adds up to 180 degrees).", "docstring": "Calculate the supplementary angle to the given angle (Adds up to 180 degrees).\n    Parameters:\n    angle (float): An angle in degrees.\n    Returns:\n    float: The supplementary angle.\n    Examples:\n    >>> calculate_supplementray_angle(30)\n    150.0\n    >>> calculate_supplementary_angle(90)\n    90.0", "Freq": 3, "TSR": 3}, {"tool": "def find_linear_equation(x1, y1, x2, y2):\n    \n    slope = (y2 - y1) / (x2 - x1) if x2 != x1 else float('inf')\n    intercept = y1 - slope * x1\n    return (slope, intercept)", "subfield": "Lines and Angles", "tool_name": "find_linear_equation", "tool_type": "function", "description": "Calculate the slope-intercept form equation of a line given two points (x1, y1) and (x2, y2).", "docstring": "Calculate the slope-intercept form equation of a line given two points (x1, y1) and (x2, y2).\n    Parameters:\n    - x1, y1, x2, y2 (float): Coordinates of two points on the line.\n    Returns:\n    - tuple: coefficients of slope and constant (m, c) of the line y = mx + c\n    Examples:\n    - find_linear_equation(1, 2, 3, 8)", "Freq": 2, "TSR": 1}, {"tool": "def angle_between_vectors(vector1, vector2):\n    \n    dot_product = np.dot(vector1, vector2)\n    magnitude_product = np.linalg.norm(vector1) * np.linalg.norm(vector2)\n    angle_rad = math.acos(dot_product / magnitude_product)\n    angle_deg = math.degrees(angle_rad)\n    return angle_deg", "subfield": "Lines and Angles", "tool_name": "angle_between_vectors", "tool_type": "function", "description": "Calculate the angle in degrees between two vectors in 2D space.", "docstring": "Calculate the angle in degrees between two vectors in 2D space.\n    Parameters:\n    vector1 (tuple): The components (x, y) of the first vector.\n    vector2 (tuple): The components (x, y) of the second vector.\n    Returns:\n    float: The angle in degrees.\n    Example:\n    >>> angle_between_vectors((1, 0), (0, 1))\n    90.0", "Freq": 2, "TSR": 0}, {"tool": "def check_parallelism(line1_coeffs, line2_coeffs):\n    \n    A1, B1 = line1_coeffs\n    A2, B2 = line2_coeffs\n    return np.isclose(A1 * B2, A2 * B1)", "subfield": "Lines and Angles", "tool_name": "check_parallelism", "tool_type": "function", "description": "Checks whether two lines are parallel.", "docstring": "Checks whether two lines are parallel.\n    Parameters:\n    line1_coeffs (tuple/list): Coefficients (A, B) of the first line (Ax + By = C).\n    line2_coeffs (tuple/list): Coefficients (A, B) of the second line (Ax + By = C).\n    Returns:\n    bool: True if lines are parallel, False otherwise.\n    Example:\n    >>> check_parallelism((1, -2), (2, -4))\n    True\n    >>> check_parallelism((1, 2), (2, -5))\n    False", "Freq": 2, "TSR": 1}, {"tool": "def radians_to_degrees(radians):\n    \n    return math.degrees(radians)", "subfield": "Lines and Angles", "tool_name": "radians_to_degrees", "tool_type": "function", "description": "Converts an angle from radians to degrees.", "docstring": "Converts an angle from radians to degrees.\n    Parameters:\n    radians (float): The angle in radians.\n    Returns:\n    degrees (float): The angle in degrees.\n    Examples:\n    >>> radians_to_degrees(math.pi)\n    180.0", "Freq": 0, "TSR": 0}, {"tool": "def angle_between_lines(line1, line2):\n    \n    # Extract coefficients\n    a1, b1, _ = line1\n    a2, b2, _ = line2\n    # Calculating angle using the formula:\n    # tan(theta) = |(m2-m1)/(1+m1*m2)|  where m = -a/b for each line\n    numerator = np.abs(a2 * b1 - a1 * b2)\n    denominator = np.abs(a1 * b2 + a2 * b1)\n    angle_rad = np.arctan(numerator / denominator)\n    angle_deg = np.degrees(angle_rad)\n    return angle_deg", "subfield": "Lines and Angles", "tool_name": "angle_between_lines", "tool_type": "function", "description": "Calculate the angle in degrees between two lines given their coefficients.", "docstring": "Calculate the angle in degrees between two lines given their coefficients.\n    Parameters:\n    line1 (tuple): Coefficients (a, b, c) of the first line in the form ax + by + c = 0.\n    line2 (tuple): Coefficients (a, b, c) of the second line in the form ax + by + c = 0.\n    Returns:\n    float: Angle in degrees between the two lines.\n    Example:\n    >>> angle_between_lines((1, -1, 0), (1, 1, 0))\n    90.0", "Freq": 1, "TSR": 0}, {"tool": "def are_complementary(*angles):\n    \n    import numpy as np  # Importing Numpy for numerical operations\n    if np.isclose(sum(angles), 90):\n        return True\n    else:\n        return False", "subfield": "Lines and Angles", "tool_name": "are_complementary", "tool_type": "function", "description": "Check if the provided angles sum up to 90 degrees, thus are complementary.", "docstring": "Check if the provided angles sum up to 90 degrees, thus are complementary.\n    \n    Parameters:\n        angles (float or int): a variable number of angle measures\n    \n    Returns:\n        bool: True if the sum of angles is 90 degrees, False otherwise.\n        \n    Examples:\n        >>> are_complementary(30, 60)\n        True\n        >>> are_complementary(45, 45)\n        True\n        >>> are_complementary(90, 0)\n        True\n        >>> are_complementary(50, 40, 10)\n        False", "Freq": 0, "TSR": 0}, {"tool": "def calculate_angle_relations(parallel, transversal, known_angle, angle_type):\n    \n    from math import fmod\n    if not transversal:\n        return \"No transversal line present!\"\n    if parallel:\n        if angle_type == 'corresponding' or angle_type == 'alternate':\n            return known_angle\n        elif angle_type == 'supplementary':\n            return 180 - known_angle\n    else:\n        if angle_type == 'corresponding':\n            # Non-parallel lines can have non-equal corresponding angles, dependent on geometry.\n            return None\n        elif angle_type == 'alternate':\n            # Still equal if the lines aren't intersected by a curve or such.\n            return known_angle\n        elif angle_type == 'supplementary':\n            return 180 - known_angle\n    return None", "subfield": "Lines and Angles", "tool_name": "calculate_angle_relations", "tool_type": "function", "description": "Calculate angles such as corresponding, supplementary, or alternate when dealing\n    with two lines and a transversal, focusing on situations where lines might be parallel.", "docstring": "Calculate angles such as corresponding, supplementary, or alternate when dealing\n    with two lines and a transversal, focusing on situations where lines might be parallel.\n    \n    Parameters:\n        parallel (bool): A flag indicating whether the two lines are parallel.\n        transversal (bool): A flag indicating if there is a transversal intersecting the two lines.\n        known_angle (int or float): A known angle measurement in degrees.\n        angle_type (str): A descriptive type of the angle relation to compute:\n                          'corresponding', 'supplementary', or 'alternate'.\n    Returns:\n        float: The calculated angle in degrees based upon the type and parallelism.\n    Examples:\n        >>> calculate_angle_relations(True, True, 30, 'corresponding')\n        30\n        >>> calculate_angle_relations(True, True, 150, 'supplementary')\n        30\n        >>> calculate_angle_relations(True, True, 60, 'alternate')\n        60", "Freq": 2, "TSR": 2}, {"tool": "def triangle_angle_solver(angle1, angle2=None, angle3=None):\n    \n    if angle1 is not None and angle2 is not None:\n        angle3 = 180 - angle1 - angle2\n    elif angle1 is not None and angle3 is not None:\n        angle2 = 180 - angle1 - angle3\n    elif angle2 is not None and angle3 is not None:\n        angle1 = 180 - angle2 - angle3\n    else:\n        raise ValueError(\"At least two angles must be provided\")\n      \n    return angle1, angle2, angle3", "subfield": "Lines and Angles", "tool_name": "triangle_angle_solver", "tool_type": "function", "description": "Calculates the missing angles in a triangle given at least one known angle.", "docstring": "Calculates the missing angles in a triangle given at least one known angle.\n    \n    Parameters:\n    angle1: float or None\n        The degree of the first angle. If set to None, it's considered unknown.\n    angle2: float or None\n        The degree of the second angle. If None, calculated from other angles.\n    angle3: float or None\n        The degree of the third angle. If None, calculated from other angles.\n    \n    Returns:\n    tuple\n        A tuple (a1, a2, a3) representing the angles of the triangle.\n        \n    Examples:\n    >>> triangle_angle_solver(90, 30)\n    (90, 30, 60)\n    >>> triangle_angle_solver(45, 45)\n    (45, 45, 90)", "Freq": 3, "TSR": 0}, {"tool": "def angle_between_parallel_lines(angle_one, is_supplementary=False):\n    \n    if is_supplementary:\n        return angle_one\n    else:\n        return 180 - angle_one", "subfield": "Lines and Angles", "tool_name": "angle_between_parallel_lines", "tool_type": "function", "description": "Determines angles formed when two parallel lines are intersected by a transversal.", "docstring": "Determines angles formed when two parallel lines are intersected by a transversal.\n    \n    Parameters:\n        angle_one : float or sympy.Expr\n            The measure of one of the given angles in degrees.\n        is_supplementary : bool, optional\n            Determines if the function should return the supplementary angle (default is False).\n            \n    Returns:\n        float or sympy.Expr\n            Returns the corresponding angle measure based on properties of parallel lines.\n            If `is_supplementary` is True, returns the supplementary angle to angle_one.\n    \n    Examples:\n        >>> angle_between_parallel_lines(50)\n        130\n        >>> angle_between_parallel_lines(50, True)\n        50\n        >>> angle_between_parallel_lines(sp.Symbol('x') + 10)\n        170 - x", "Freq": 2, "TSR": 2}, {"tool": "def calculate_vertical_angle(given_angle):\n    \n    return given_angle", "subfield": "Lines and Angles", "tool_name": "calculate_vertical_angle", "tool_type": "function", "description": "Calculate the vertical angle given one angle. Vertical angles are equal when two lines intersect.", "docstring": "Calculate the vertical angle given one angle. Vertical angles are equal when two lines intersect.\n    Parameters:\n    given_angle (float): The given angle in degrees.\n    Returns:\n    float: The vertical angle which is equal to the given angle.\n    Example:\n    >>> calculate_vertical_angle(45)\n    45.0", "Freq": 0, "TSR": 0}, {"tool": "def check_line_properties(line1_coeff, line2_coeff, check_type='parallel'):\n    \n    A1, B1, C1 = line1_coeff\n    A2, B2, C2 = line2_coeff\n    \n    if check_type == 'parallel':\n        return A1*B2 == A2*B1\n    elif check_type == 'perpendicular':\n        return -A1*A2 == B1*B2\n    elif check_type == 'intersection':\n        determinant = A1*B2 - A2*B1\n        if determinant == 0:\n            return False  # Lines are parallel or coincident, no single intersection\n        else:\n            x = (B2*C1 - B1*C2) / determinant\n            y = (A1*C2 - A2*C1) / determinant\n            return (x, y)\n    return False", "subfield": "Lines and Angles", "tool_name": "check_line_properties", "tool_type": "function", "description": "Determine if two lines are parallel or perpendicular, or find the intersection point.", "docstring": "Determine if two lines are parallel or perpendicular, or find the intersection point.\n    \n    Parameters:\n        line1_coeff (tuple): Coefficients (A, B, C) of the first line in the form Ax + By = C.\n        line2_coeff (tuple): Coefficients (A, B, C) of the second line.\n        check_type (str): Type of property to check: 'parallel', 'perpendicular', 'intersection'.\n    Returns:\n        bool or tuple: Depending on 'check_type', returns boolean for parallel or perpendicular,\n                       and tuple (x, y) for intersection point if lines intersect.\n                       \n    Examples:\n        >>> check_line_properties((1, -1, 0), (2, -2, 0))\n        True  # Lines are parallel\n        >>> check_line_properties((1, -1, 0), (1, 1, 0), 'perpendicular')\n        True  # Lines are perpendicular\n        >>> check_line_properties((1, -1, 0), (1, 1, 2), 'intersection')\n        (1, 1)  # Intersection point", "Freq": 5, "TSR": 2, "experience_pool": "The tool for checking line properties is functioning correctly. The issues in the code provided are due to incorrect usage in the calling code, not the tool itself."}, {"tool": "def angle_between_tangent_and_radius(point_of_tangency, center_of_circle):\n    \n    # For a circle, the angle between the radius to the point of tangency and the tangent at that point is always 90 degrees.\n    return 90.0", "subfield": "Lines and Angles", "tool_name": "angle_between_tangent_and_radius", "tool_type": "function", "description": "Calculate the angle formed at the point of tangency between the tangent to a circle and the radius.", "docstring": "Calculate the angle formed at the point of tangency between the tangent to a circle and the radius.\n    Parameters:\n    point_of_tangency (tuple): A tuple (x, y) representing the coordinates of the point where the tangent touches the circle.\n    center_of_circle (tuple): A tuple (x, y) representing the coordinates of the circle's center.\n    Returns:\n    angle (float): The angle in degrees between the tangent and the radius at the point of tangency, which is always 90 degrees for a circle.\n    Examples:\n    >>> angle_between_tangent_and_radius((2, 4), (1, 1))\n    90.0", "Freq": 0, "TSR": 0}, {"tool": "def check_vertical_angles(angle1, angle2):\n    \n    return angle1 == angle2", "subfield": "Lines and Angles", "tool_name": "check_vertical_angles", "tool_type": "function", "description": "Checks if two given angles are vertical angles. Vertical angles are always congruent.", "docstring": "Checks if two given angles are vertical angles. Vertical angles are always congruent.\n    \n    Parameters:\n        angle1 (float or int): The measure of the first angle in degrees.\n        angle2 (float or int): The measure of the second angle in degrees.\n        \n    Returns:\n        bool: True if the angles are congruent (equal), False otherwise.\n    \n    Examples:\n        >>> check_vertical_angles(45, 45)\n        True\n        >>> check_vertical_angles(130, 130)\n        True\n        >>> check_vertical_angles(110, 120)\n        False", "Freq": 0, "TSR": 0}, {"tool": "def check_line_relationship(point1, point2, point3, point4):\n    \n    # Calculate direction vectors\n    dir1 = np.array([point2[0] - point1[0], point2[1] - point1[1]])\n    dir2 = np.array([point4[0] - point3[0], point4[1] - point3[1]])\n    \n    # Check parallelism (cross product == 0)\n    if np.cross(dir1, dir2) == 0:\n        return 'parallel'\n    \n    # Check perpendicularity (dot product == 0)\n    if np.dot(dir1, dir2) == 0:\n        return 'perpendicular'\n    return 'none'", "subfield": "Lines and Angles", "tool_name": "check_line_relationship", "tool_type": "function", "description": "Check if two lines described by two points each (points on the first line and points on the second line) are parallel or perpendicular.", "docstring": "Check if two lines described by two points each (points on the first line and points on the second line) are parallel or perpendicular.\n    Parameters:\n    - point1, point2 (tuple): Coordinates of the first and second point (x, y) on the first line.\n    - point3, point4 (tuple): Coordinates of the first and second point (x, y) on the second line.\n    Returns:\n    - str: 'parallel', 'perpendicular', or 'none' indicating the relationship between the two lines.\n    \n    Examples:\n    - check_line_relationship((0,0), (1,1), (0,1), (1,2)) returns 'parallel'.\n    - check_line_relationship((0,0), (1,0), (0,0), (0,1)) returns 'perpendicular'.", "Freq": 0, "TSR": 0}, {"tool": "def line_perpendicular_to(line, point):\n    \n    x, y = sp.symbols('x y')\n    A, B, _ = sp.poly(line).coeffs()\n    px, py = point\n    # For line Ax + By + C = 0, the perpendicular line is Bx - Ay + (Ay1 - Bx1)\n    perp_line_expr = B*x - A*y + (A*py - B*px)\n    return sp.simplify(perp_line_expr)", "subfield": "Lines and Angles", "tool_name": "line_perpendicular_to", "tool_type": "function", "description": "Creates the equation of a line that is perpendicular to the given line and passes through the specified point.", "docstring": "Creates the equation of a line that is perpendicular to the given line and passes through the specified point.\n    \n    Parameters:\n    - line (sympy.Expr): The equation of the initial line in form `Ax + By + C = 0`.\n    - point (tuple): A tuple (px, py) representing the point through which the perpendicular line must pass.\n    \n    Returns:\n    - sympy.Expr: The equation of the perpendicular line.\n    \n    Example:\n    >>> line = create_line_equation((0, 0), (1, 1))\n    >>> perp_line = line_perpendicular_to(line, (1, 0))\n    >>> print(perp_line)\n    x + y - 1", "Freq": 0, "TSR": 0}, {"tool": "def identify_line_type(point1, point2):\n    \n    if point1[0] == point2[0]:\n        return 'vertical'\n    elif point1[1] == point2[1]:\n        return 'horizontal'\n    else:\n        return 'diagonal'", "subfield": "Lines and Angles", "tool_name": "identify_line_type", "tool_type": "function", "description": "Identifies the type of line (horizontal, vertical, or diagonal) formed by two given points.", "docstring": "Identifies the type of line (horizontal, vertical, or diagonal) formed by two given points.\n    Parameters:\n        point1 (tuple): The (x, y) coordinate of the first point.\n        point2 (tuple): The (x, y) coordinate of the second point.\n    Returns:\n        str: Returns \"horizontal\" if line is horizontal, \"vertical\" if vertical, and \"diagonal\" otherwise.\n    Example:\n        >>> identify_line_type((0, 0), (5, 0))\n        'horizontal'\n        >>> identify_line_range((1, 1), (1, 3))\n        'vertical'\n        >>> identify_line_range((1, 1), (3, 3))\n        'diagonal'", "Freq": 0, "TSR": 0}, {"tool": "def line_length(point1, point2):\n    \n    point1 = np.array(point1)\n    point2 = np.array(point2)\n    return np.linalg.norm(point1 - point2)", "subfield": "Lines and Angles", "tool_name": "line_length", "tool_type": "function", "description": "Calculate the Euclidean distance between two points.", "docstring": "Calculate the Euclidean distance between two points.\n    Parameters:\n    point1 (tuple): A tuple (x, y) representing the coordinates of the first point.\n    point2 (tuple): A tuple (x, y) representing the coordinates of the second point.\n    Returns:\n    length (float): The length of the line segment between the two points.\n    Examples:\n    >>> line_length((1, 1), (4, 5))\n    5.0", "Freq": 1, "TSR": 0}, {"tool": "def compute_slope(x1, y1, x2, y2):\n    \n    # Utilizing sympy points computation to avoid division by zero\n    p1, p2 = Point(x1, y1), Point(x2, y2)\n    line = Line(p1, p2)\n    return line.slope", "subfield": "Lines and Angles", "tool_name": "compute_slope", "tool_type": "function", "description": "Compute the slope of a line passing through points (x1, y1) and (x2, y2).", "docstring": "Compute the slope of a line passing through points (x1, y1) and (x2, y2).\n    \n    Parameters:\n        x1, y1, x2, y2 (int or float): Coordinates of two points.\n    \n    Returns:\n        slope (int or float or sympy object): The slope of the line.\n        \n    Examples:\n        slope = compute_slope(1, 2, 3, 8)\n        print(slope)  # 3", "Freq": 0, "TSR": 0}, {"tool": "def cyclic_quadrilateral_angles(angle1, angle2=None):\n    \n    if angle2 is None:\n        angle2 = 180 - angle1\n    else:\n        if angle1 + angle2 != 180:\n            raise ValueError(\"Opposite angles in a cyclic quadrilateral must sum up to 180 degrees.\")\n      \n    return angle1, angle2", "subfield": "Lines and Angles", "tool_name": "cyclic_quadrilateral_angles", "tool_type": "function", "description": "Determines the missing angles in a cyclic quadrilateral given two opposite angles.", "docstring": "Determines the missing angles in a cyclic quadrilateral given two opposite angles.\n    \n    Parameters:\n    angle1: float\n        The degree of one angle of the cyclic quadrilateral.\n    angle2: float or None\n        The degree of the opposite angle. If None, it's calculated.\n    \n    Returns:\n    tuple\n        A tuple (a1, a2) representing the angles of two opposite pairs in the cyclic quadrilateral.\n        \n    Examples:\n    >>> cyclic_quadrilateral_angles(110)\n    (110, 70)\n    >>> cyclic_quadrilateral_angles(80, 100)\n    (80, 100)", "Freq": 1, "TSR": 0}, {"tool": "def check_parallel(line1, line2):\n    \n    return calculate_slope(line1) == calculate_slope(line2)", "subfield": "Lines and Angles", "tool_name": "check_parallel", "tool_type": "function", "description": "Check if two lines are parallel.", "docstring": "Check if two lines are parallel.\n    \n    Parameters:\n    line1 (tuple): Coefficients (a, b, c) for the first line ax + by + c = 0.\n    line2 (tuple): Coefficients (a, b, c) for the second line ax + by + c = 0.\n    \n    Returns:\n    bool: True if the lines are parallel, False otherwise.", "Freq": 0, "TSR": 0}, {"tool": "def segment_length(point1, point2):\n    \n    length = np.sqrt((point2[0] - point1[0])**2 + (point2[1] - point1[1])**2)\n    return length", "subfield": "Lines and Angles", "tool_name": "segment_length", "tool_type": "function", "description": "Calculate the length of the segment connecting two points in 2D space.", "docstring": "Calculate the length of the segment connecting two points in 2D space.\n    Parameters:\n    point1 (tuple): The (x, y) coordinates of the first point.\n    point2 (tuple): The (x, y) coordinates of the second point.\n    Returns:\n    float: The length of the segment.\n    Example:\n    >>> segment_length((0, 0), (4, 3))\n    5.0", "Freq": 1, "TSR": 0}, {"tool": "def slope_between_points(point1, point2):\n    \n    x1, y1 = point1\n    x2, y2 = point2\n    try:\n        return (y2 - y1) / (x2 - x1)\n    except ZeroDivisionError:\n        return 'undefined'", "subfield": "Lines and Angles", "tool_name": "slope_between_points", "tool_type": "function", "description": "Calculates the slope between two given points.", "docstring": "Calculates the slope between two given points.\n    \n    Parameters:\n        point1 : tuple of two floats or sympy.Expr\n            Coordinates of the first point (x1, y1).\n        point2 : tuple of two floats or sympa.Expressions\n            Coordinates of the second point (x2, y2).\n    Returns:\n        float or sympy.Expr\n            The slope value between the two points.\n    \n    Example:\n        >>> slope_between_points((1, 2), (3, 8))\n        3\n        >>> slope_between_keys((1, 2), (1, 8))\n        'undefined'  # Division by zero, or handle with symbolics if used in equations.", "Freq": 0, "TSR": 0}, {"tool": "def sum_of_triangle_angles():\n    \n    return 180", "subfield": "Lines and Angles", "tool_name": "sum_of_triangle_angles", "tool_type": "function", "description": "Returns the sum of the internal angles of a triangle, which is always 180 degrees.\n    Returns:\n    int: Sum of angles in a triangle.\n    \n    Examples:\n    >>> sum_of_triangle_angles()\n    180", "docstring": "Returns the sum of the internal angles of a triangle, which is always 180 degrees.\n    Returns:\n    int: Sum of angles in a triangle.\n    \n    Examples:\n    >>> sum_of_triangle_angles()\n    180", "Freq": 0, "TSR": 0}, {"tool": "def calculate_polygon_angle(n_sides, internal_or_external=True):\n    \n    if internal_or_external:\n        # Interior angle calculation\n        return (n_sides - 2) * 180 / n_sides\n    else:\n        # Exterior angle calculation (regular polygon)\n        return 360 / n_sides", "subfield": "Lines and Angles", "tool_name": "calculate_polygon_angle", "tool_type": "function", "description": "Calculate the interior or exterior angles of a regular polygon given the number of sides.", "docstring": "Calculate the interior or exterior angles of a regular polygon given the number of sides.\n    \n    Parameters:\n        n_sides (int): The number of sides in the polygon.\n        internal_or_external (bool): True for internal angle calculation, False for external angles.\n        \n    Returns:\n        float: The angle in degrees.\n        \n    Example:\n        >>> calculate_polygon_angle(4)\n        90.0\n        >>> calculate_polygon_angle(4, False)\n        90.0", "Freq": 0, "TSR": 0}, {"tool": "def find_line_equation(x1, y1, x2, y2):\n    \n    p1, p2 = Point(x1, y1), Point(x2, y2)\n    line = Line(p1, p2)\n    return Eq(line.equation(), 0)", "subfield": "Lines and Angles", "tool_name": "find_line_equation", "tool_type": "function", "description": "Generate the equation of a line passing through points (x1, y1) and (x2, y2).", "docstring": "Generate the equation of a line passing through points (x1, y1) and (x2, y2).\n    \n    Parameters:\n        x1, y1, x2, y2 (int or float): Coordinates of two points.\n    \n    Returns:\n        sympy Eq: The equation of the line in the format `Eq(line expression, 0)`\n        \n    Examples:\n        equation = find_line_equation(0, 0, 1, 1)\n        print(equation)  # Eq(-x + y, 0)", "Freq": 0, "TSR": 0}, {"tool": "def check_parallel(angle1, angle2):\n    \n    return math.isclose(angle1, angle2, abs_tol=1e-9)", "subfield": "Lines and Angles", "tool_name": "check_parallel", "tool_type": "function", "description": "Determine if two lines are parallel based on their corresponding or alternate angles.", "docstring": "Determine if two lines are parallel based on their corresponding or alternate angles.\n    Parameters:\n    angle1 (float): The angle formed between the first line and the transversal.\n    angle2 (float): The angle formed between the second line and the transversal.\n    Returns:\n    bool: True if lines are parallel, False otherwise.\n    \n    Examples:\n    >>> check_parallel(120, 120)\n    True\n    >>> check_parallel(120, 130)\n    False", "Freq": 0, "TSR": 0}, {"tool": "def check_triangle_inequality(a, b, c):\n    \n    return a + b > c and a + c > b and b + c > a", "subfield": "Lines and Angles", "tool_name": "check_triangle_inequality", "tool_type": "function", "description": "Determine if three lengths can form a triangle based on the triangle inequality theorem.", "docstring": "Determine if three lengths can form a triangle based on the triangle inequality theorem.\n    Parameters:\n    a, b, c (float): Lengths of the sides of a potential triangle.\n    Returns:\n    bool: True if the lengths satisfy the triangle inequality, False otherwise.\n    Examples:\n    >>> check_triangle_inequality(3, 4, 5)\n    True\n    >>> check_triangle_inequality(1, 10, 12)\n    False", "Freq": 0, "TSR": 0}, {"tool": "def calculate_slope(line):\n    \n    a, b, c = line\n    if b == 0:\n        raise ValueError(\"Slope is undefined for vertical lines.\")\n    return -a / b", "subfield": "Lines and Angles", "tool_name": "calculate_slope", "tool_type": "function", "description": "Calculate the slope of a line given in the form ax + by + c = 0.", "docstring": "Calculate the slope of a line given in the form ax + by + c = 0.\n    Parameters:\n    line (tuple): Coefficients (a, b, c) representing the line ax + by + c = 0.\n    Returns:\n    float: Slope of the line.", "Freq": 0, "TSR": 0}, {"tool": "def angle_bisector_theorem(a, b, angle):\n    \n    theta = sp.rad(angle)\n    return (a / b)", "subfield": "Lines and Angles", "tool_name": "angle_bisector_theorem", "tool_type": "function", "description": "Applies the angle bisector theorem within a triangle to find the relationships of segments.", "docstring": "Applies the angle bisector theorem within a triangle to find the relationships of segments.\n    Parameters:\n        a (float): The length of one side of the triangle.\n        b (float): The length of the adjacent side of the triangle.\n        angle (float): The angle being bisected in degrees.\n        \n    Returns:\n        float: The ratio of the two segments created by bisecting the given angle.\n    Examples:\n        >>> angle_bisector_theorem(4, 6, 60)\n        0.8", "Freq": 0, "TSR": 0}, {"tool": "def distance_between_parallel_lines(slope, intercept1, intercept2):\n    \n    return abs(intercept2 - intercept1) / math.sqrt(slope**2 + 1)", "subfield": "Lines and Angles", "tool_name": "distance_between_parallel_lines", "tool_type": "function", "description": "Calculate the distance between two parallel lines given by y = mx + c1 and y = mx + c2.", "docstring": "Calculate the distance between two parallel lines given by y = mx + c1 and y = mx + c2.\n    Parameters:\n    - slope (float): Slope of the parallel lines.\n    - intercept1, intercept2 (float): Y-intercepts of the two lines.\n    Returns:\n    - float: The distance between the two parallel lines.\n    Examples:\n    - distance_between_parallel_lines(1, 2, 5)", "Freq": 0, "TSR": 0}, {"tool": "def angle_in_cyclic_quadrilateral(adjacent_sum):\n    \n    # In a cyclic quadrilateral, the sum of opposite angles is 180 degrees\n    return 180 - adjacent_sum", "subfield": "Lines and Angles", "tool_name": "angle_in_cyclic_quadrilateral", "tool_type": "function", "description": "Calculate the opposite angle in a cyclic quadrilateral given the sum of two adjacent angles.", "docstring": "Calculate the opposite angle in a cyclic quadrilateral given the sum of two adjacent angles.\n    \n    Parameters:\n        adjacent_sum (float): Sum of two adjacent angles in degrees.\n        \n    Returns:\n        float: Each of the opposite angles in degrees.\n        \n    Example:\n        >>> angle_in_cyclic_quadrilateral(90)\n        90.0", "Freq": 0, "TSR": 0}, {"tool": "def sum_of_angles_around_point():\n    \n    return 360", "subfield": "Lines and Angles", "tool_name": "sum_of_angles_around_point", "tool_type": "function", "description": "Returns the sum of the angles around a point, which is always 360 degrees.\n    Returns:\n    int: Sum of angles around a point.\n    \n    Examples:\n    >>> sum_of_angles_roud_point()\n    360", "docstring": "Returns the sum of the angles around a point, which is always 360 degrees.\n    Returns:\n    int: Sum of angles around a point.\n    \n    Examples:\n    >>> sum_of_angles_roud_point()\n    360", "Freq": 0, "TSR": 0}, {"tool": "def calculate_missing_angle(known_angle, relation_type='supplementary'):\n    \n    if relation_type == 'supplementary':\n        return 180 - known_angle\n    elif relation_type == 'complementary':\n        return 90 - known_angle\n    else:\n        raise ValueError(\"relation_type must be 'supplementary' or 'complementary'\")", "subfield": "Lines and Angles", "tool_name": "calculate_missing_angle", "tool_type": "function", "description": "Calculate the missing angle based on the type of angle relation.", "docstring": "Calculate the missing angle based on the type of angle relation.\n    Parameters:\n    known_angle (float): The known angle in degrees.\n    relation_type (str): Type of angle relation, 'supplementary' or 'complementary'.\n    Returns:\n    float: The missing angle in degrees.\n    Example:\n    >>> calculate_missing_angle(150, 'supplementary')\n    30.0\n    >>> calculate_missingHandler(30, 'complementary')\n    60.0", "Freq": 1, "TSR": 1}, {"tool": "def perpendicular_slope(slope):\n    \n    if slope == 0:\n        return np.inf\n    elif slope == np.inf:\n        return 0\n    else:\n        return -1 / slope", "subfield": "Lines and Angles", "tool_name": "perpendicular_slope", "tool_type": "function", "description": "Calculates the slope of a line perpendicular to the line with a given slope.", "docstring": "Calculates the slope of a line perpendicular to the line with a given slope.\n    \n    Parameters:\n        slope (float): Slope of the original line.\n    \n    Returns:\n        float: Slope of the line that is perpendicular to the given line.\n    \n    Examples:\n        >>> perpendicular_slope(4)\n        -0.25\n        >>> perpendicular_slope(0)\n        inf", "Freq": 0, "TSR": 0}, {"tool": "def are_corresponding_angles_equal(angle_set1, angle_set2):\n    \n    return np.allclose(angle_set1, angle_set2)", "subfield": "Lines and Angles", "tool_name": "are_corresponding_angles_equal", "tool_type": "function", "description": "Check if corresponding angles in two sets are equal, useful for parallel lines crossed by a transversal.", "docstring": "Check if corresponding angles in two sets are equal, useful for parallel lines crossed by a transversal.\n    Parameters:\n    angle_set1 (list of float): Angles in the first set.\n    angle_set2 (list of float): Angles in the second set.\n    \n    Returns:\n    bool: True if each corresponding angle in the sets are equal, False otherwise.\n    \n    Examples:\n    >>> are_corresponding_angles_equal([110, 70], [110, 70])\n    True\n    >>> are_corresponding_angles_equal([110, 70], [70, 110])\n    False", "Freq": 0, "TSR": 0}, {"tool": "def distance_from_point_to_line(px, py, slope, intercept):\n    \n    return abs(slope * px - py + intercept) / math.sqrt(slope**2 + 1)", "subfield": "Lines and Angles", "tool_name": "distance_from_point_to_line", "tool_type": "function", "description": "Calculate the perpendicular distance from a point to a line given by y = mx + c.", "docstring": "Calculate the perpendicular distance from a point to a line given by y = mx + c.\n    Parameters:\n    - px, py (float): Coordinates of the point.\n    - slope, intercept (float): Coefficients of the line y = mx + c.\n    Returns:\n    - float: The perpendicular distance from (px, py) to the line.\n    Examples:\n    - distance_from_point_to_line(1, 2, 1, 0)  # Line y = x", "Freq": 0, "TSR": 0}, {"tool": "def solve_linear_equations(eq_list):\n    \n    variables = set().union(*(eq.free_symbols for eq in eq_list))\n    solution = solve(eq_list, list(variables))\n    return solution", "subfield": "Lines and Angles", "tool_name": "solve_linear_equations", "tool_type": "function", "description": "Solves a system of linear equations.", "docstring": "Solves a system of linear equations.\n    \n    Parameters:\n        eq_list (list): A list of sympy Eq objects representing equations.\n    \n    Returns:\n        dict: A dictionary containing the solution for the variables in the equations.\n        \n    Examples:\n        x, y = symbols('x y')\n        eq1 = Eq(x + y, 10)\n        eq2 = Eq(2*x - y, 0)\n        solutions = solve_linear_equations([eq1, eq2])\n        print(solutions)  # {x: 10/3, y: 20/3}", "Freq": 0, "TSR": 0}, {"tool": "def calculate_triangle_angle_sum(angle1, angle2):\n    \n    return 180.0 - angle1 - angle2", "subfield": "Lines and Angles", "tool_name": "calculate_triangle_angle_sum", "tool_type": "function", "description": "Given two angles of a triangle, returns the third angle using the fact\n    that sum of angles in a triangle is always 180 degrees.", "docstring": "Given two angles of a triangle, returns the third angle using the fact\n    that sum of angles in a triangle is always 180 degrees.\n    Parameters:\n    - angle1 (float): First angle in degrees\n    - angle2 (float): Second angle in degrees\n    Returns:\n    - float: Third angle in the triangle\n    Example:\n    >>> calculate_triangle_angle_sum(90, 30)\n    60.0", "Freq": 3, "TSR": 1, "experience_pool": "Tool `calculate_triangle_angle_sum` is used to find the third angle of a triangle by subtracting the sum of the given two angles from 180 degrees."}, {"tool": "def check_symmetry(x1, y1, x2, y2, line_x):\n    \n    return x1 + x2 == 2 * line_x and y1 == y2", "subfield": "Lines and Angles", "tool_name": "check_symmetry", "tool_type": "function", "description": "Checks whether two points are symmetric with respect to a vertical line x = line_x.", "docstring": "Checks whether two points are symmetric with respect to a vertical line x = line_x.\n    Parameters:\n        x1, y1 (float, float): Coordinates of the first point.\n        x2, y2 (float, float): Coordinates of the second point.\n        line_x (float): x-coordinate of the vertical line of symmetry.\n    Returns:\n        bool: Returns True if the points are symmetric with respect to the line, otherwise False.\n    \n    Examples:\n        >>> check_symmetry(3, 4, 7, 4, 5)\n        True\n        >>> check_symmetry(1, 2, 3, 4, 5)\n        False", "Freq": 0, "TSR": 0}, {"tool": "def calculate_line_segment_length(coord1, coord2):\n    \n    return math.hypot(coord2[0] - coord1[0], coord2[1] - coord1[1])", "subfield": "Lines and Angles", "tool_name": "calculate_line_segment_length", "tool_type": "function", "description": "Calculates the length of the line segment between two coordinates.", "docstring": "Calculates the length of the line segment between two coordinates.\n    Parameters:\n    - coord1 (tuple of float): The (x, y) coordinates of the first point\n    - coord2 (tuple of float): The (x, y) coordinates of the second point\n    Returns:\n    - float: The length of the line segment between the given points\n    Example:\n    >>> calculate_line_segment_length((0, 0), (3, 4))\n    5.0", "Freq": 0, "TSR": 0}], "Volume of Solids": [{"tool": "def cylinder_volume(radius, height):\n    \n    return math.pi * radius ** 2 * height", "subfield": "Volume of Solids", "tool_name": "cylinder_volume", "tool_type": "function", "description": "Calculate the volume of a cylinder given the radius and height.", "docstring": "Calculate the volume of a cylinder given the radius and height.\n    \n    Parameters:\n    radius (float): The radius of the base of the cylinder.\n    height (float): The height of the cylinder.\n    \n    Returns:\n    float: The volume of the cylinder.\n    \n    Examples:\n    >>> cylinder_volume(2, 4)\n    50.26548245743669", "Freq": 18, "TSR": 10, "experience_pool": "- When using the `cylinder_volume` function, make sure to pass in the correct parameters (radius and height) to calculate the volume of a cylinder.\n- If additional calculations are needed, consider creating helper functions like `volume_sphere` and `remaining_volume` separately to avoid errors in the main solution function."}, {"tool": "def volume_of_rectangular_prism(length, width, height):\n    \n    return length * width * height", "subfield": "Volume of Solids", "tool_name": "volume_of_rectangular_prism", "tool_type": "function", "description": "Calculate the volume of a rectangular prism.", "docstring": "Calculate the volume of a rectangular prism.\n    Parameters:\n    - length: The length of the prism (float or int).\n    - width: The width of the prism (float or int).\n    - height: The height of the prism (float or int).\n    Returns:\n    - The volume of the rectangular prism (float).\n    Example:\n    >>> volume_of_rectangular_prism(2, 3, 4)\n    24", "Freq": 13, "TSR": 12}, {"tool": "def volume_sphere(radius):\n    \n    return (4/3) * math.pi * (radius ** 3)", "subfield": "Volume of Solids", "tool_name": "volume_sphere", "tool_type": "function", "description": "Calculate the volume of a sphere given its radius.", "docstring": "Calculate the volume of a sphere given its radius.\n    Parameters:\n    radius (float): The radius of the sphere.\n    Returns:\n    float: The volume of the sphere.\n    Examples:\n    >>> volume_sphere(3)\n    113.09733552923255", "Freq": 32, "TSR": 8, "experience_pool": "1. Calculating the volume of a sphere using the `volume_sphere` function has been successful in various scenarios.\n2. The formula used in the `volume_sphere` function is mathematically correct and provides accurate results.\n3. The docstring of the `volume_sphere` function clearly explains its purpose and usage."}, {"tool": "def cone_volume(radius, height):\n    \n    return (1/3) * math.pi * pow(radius, 2) * height", "subfield": "Volume of Solids", "tool_name": "cone_volume", "tool_type": "function", "description": "Calculate the volume of a cone.", "docstring": "Calculate the volume of a cone.\n    \n    Parameters:\n        radius (float): The radius of the cone.\n        height (float): The height of the cone.\n    \n    Returns:\n        float: The volume of the cone.\n    \n    Example:\n        >>> cone_volume(3, 4)\n        37.69911184307752", "Freq": 19, "TSR": 9, "experience_pool": "1. Problem: The slant height of a cone is 13 cm, and the height from the vertex to the center of the base is 12 cm. What is the number of cubic centimeters in the volume of the cone? Express your answer in terms of $\\pi$.\n   Answer: 100\\pi\n   ```python\n   def solution():\n       \"\"\"Calculate the volume of the cone with given slant height and height.\"\"\"\n       slant_height = 13\n       height = 12\n       radius = 5  # Calculated using Pythagorean theorem\n       result = cone_volume(radius, height)\n       return result\n\n   # Calculate the volume of the cone\n   print(solution())\n   ```\n   Output: 314.15926535897927"}, {"tool": "def pyramid_volume(base_area, height):\n    \n    return (1/3) * base_area * height", "subfield": "Volume of Solids", "tool_name": "pyramid_volume", "tool_type": "function", "description": "Calculate the volume of a pyramid given the area of the base and the height from the base to the apex.", "docstring": "Calculate the volume of a pyramid given the area of the base and the height from the base to the apex.\n    Parameters:\n    base_area (float): The area of the pyramid's base.\n    height (float): The height from the base to the apex.\n    \n    Returns:\n    float: The volume of the pyramid.\n    Example:\n    >>> pyramid_volume(10, 15)\n    50.0", "Freq": 14, "TSR": 7, "experience_pool": "Tool for calculating the volume of a pyramid is accurate and working correctly."}, {"tool": "def volume_from_face_areas(area1, area2, area3):\n    \n    def equations(p):\n        L, W, H = p\n        return (L*W - area1, W*H - area2, L*H - area3)\n    \n    initial_guess = (np.sqrt(area1), np.sqrt(area2), np.sqrt(area3))\n    solution = fsolve(equations, initial_guess)\n    \n    # Check if all derived equations are almost close to zero for correctness\n    if np.allclose(np.array(equations(solution)), [0.0, 0.0, 0.0], atol=1e-6):\n        return solution[0] * solution[1] * solution[2]\n    else:\n        return None", "subfield": "Volume of Solids", "tool_name": "volume_from_face_areas", "tool_type": "function", "description": "Calculates the volume of a rectangular prism using the areas of its faces.\n    Here, it's assumed that:\n    - area1 = length * width\n    - area2 = width * height\n    - area3 = length * height", "docstring": "Calculates the volume of a rectangular prism using the areas of its faces.\n    Here, it's assumed that:\n    - area1 = length * width\n    - area2 = width * height\n    - area3 = length * height\n    Parameters:\n    - area1 (float): Area of the first face (length x width).\n    - area2 (float): Area of the second face (width x height).\n    - area3 (float): Area of the third face (length x height).\n    Returns:\n    - float: The calculated volume of the rectangular prism if the solution is found, otherwise None.\n    Example:\n    >>> volume_from_face_areas(24, 30, 20)\n    60.0", "Freq": 10, "TSR": 9}, {"tool": "def volume_cube(edge_length):\n    \n    return edge_length ** 3", "subfield": "Volume of Solids", "tool_name": "volume_cube", "tool_type": "function", "description": "Calculate the volume of a cube given its edge length.", "docstring": "Calculate the volume of a cube given its edge length.\n    Parameters:\n    edge_length (float): The edge length of the cube.\n    Returns:\n    float: The volume of the cube.\n    Examples:\n    >>> volume_cube(2)\n    8", "Freq": 29, "TSR": 21, "experience_pool": "1. Problem: A solid box is 15 cm by 10 cm by 8 cm. A new solid is formed by removing a cube 3 cm on a side from each corner of this box. What percent of the original volume is removed?\nAnswer: 18%\n2. Problem: A sphere is inscribed in a cube. What is the ratio of the volume of the inscribed sphere to the volume of the cube? Express your answer as a common fraction in terms of $\\pi$.\nAnswer: $\\frac{\\pi}{6}$\n3. Problem: A rectangular prism has dimensions 8 inches by 2 inches by 32 inches. If a cube has the same volume as the prism, what is the surface area of the cube, in square inches?\nAnswer: 384\n4. Problem: The cube below has sides of length 4 feet. If a cylindrical section of radius 2 feet is removed from the solid, what is the total remaining volume of the cube? Express your answer in cubic feet in terms of $\\pi$.\nAnswer: 64-16$\\pi$\n5. Problem: A rectangular box has interior dimensions 6-inches by 5-inches by 10-inches. The box is filled with as many solid 3-inch cubes as possible, with all of the cubes entirely inside the rectangular box. What percent of the volume of the box is taken up by the cubes?\nAnswer: 54\n6. Problem: A point in space $(x,y,z)$ is randomly selected so that $-1\\le x \\le 1$,$-1\\le y \\le 1$,$-1\\le z \\le 1$. What is the probability that $x^2+y^2+z^2\\le 1$?\nAnswer: $\\frac{\\pi}{6}$"}, {"tool": "def volume_of_regular_octahedron(edge_length):\n    \n    return (1/3) * math.sqrt(2) * edge_length**3", "subfield": "Volume of Solids", "tool_name": "volume_of_regular_octahedron", "tool_type": "function", "description": "Calculate the volume of a regular octahedron given its edge length.", "docstring": "Calculate the volume of a regular octahedron given its edge length.\n    Parameters:\n    - edge_length: The length of an edge of the octahedron (float or int).\n    Returns:\n    - The volume of the regular octahedron (float).\n    Example:\n    >>> volume_of_regular_octahedron(3)\n    3.181980515339464", "Freq": 1, "TSR": 1}, {"tool": "def volume_rectangular_parallelepiped(length, width, height):\n    \n    return length * width * height", "subfield": "Volume of Solids", "tool_name": "volume_rectangular_parallelepiped", "tool_type": "function", "description": "Calculates the volume of a rectangular parallelepiped (box).", "docstring": "Calculates the volume of a rectangular parallelepiped (box).\n    \n    Parameters:\n    - length (float): Length of the parallelepiped.\n    - width (float): Width of the parallelepiped.\n    - height (float): Height of the parallelepiped.\n    \n    Returns:\n    - float: The volume of the rectangular parallelepiped.\n    \n    Examples:\n    >>> volume_rectangular_parallelepiped(2, 3, 4)\n    24", "Freq": 11, "TSR": 3, "experience_pool": "1. When using the `volume_rectangular_parallelepiped` function, ensure that the input parameters are correctly provided.\n2. Make sure to define and implement any additional functions like `volume_cube` or `remaining_volume` before using them in calculations.\n3. Double-check the calculations and formulas used in the solution to avoid errors in the final output."}, {"tool": "def calculate_volume(shape_type, dimensions):\n    \n    if shape_type == \"sphere\":\n        radius = dimensions[\"radius\"]\n        return (4/3) * math.pi * radius ** 3\n    elif shape_type == \"rectangular_prism\":\n        length = dimensions[\"length\"]\n        width = dimensions[\"width\"]\n        height = dimensions[\"height\"]\n        return length * width * height\n    elif shape_type == \"cube\":\n        edge_length = dimensions[\"edge_length\"]\n        return edge_length ** 3\n    elif shape_type == \"octahedron\":\n        edge_length = dimensions[\"edge_length\"]\n        return (math.sqrt(2) / 3) * edge_length ** 3\n    else:\n        raise ValueError(\"Invalid shape type provided\")", "subfield": "Volume of Solids", "tool_name": "calculate_volume", "tool_type": "function", "description": "Calculate the volume of various geometric solids based on given parameters.", "docstring": "Calculate the volume of various geometric solids based on given parameters.\n    \n    Parameters:\n        shape_type (str): Type of shape (\"sphere\", \"rectangular_prism\", \"cube\", \"octahedron\")\n        dimensions (dict): A dictionary containing the required dimensions:\n                           For a sphere: {'radius': r}\n                           For a rectangular prism: {'length': l, 'width': w, 'height': h}\n                           For a cube: {'edge_length': a}\n                           For an octahedron: {'edge_length': a}\n    Returns:\n        float: The volume of the geometric solid.\n    \n    Examples:\n        calculate_volume(\"sphere\", {\"radius\": 3})\n        calculate_volume(\"rectangular_prism\", {\"length\": 5, \"width\": 3, \"height\": 2})\n        calculate_volume(\"cube\", {\"edge_length\": 4})\n        calculate_volume(\"octahedron\", {\"edge_length\": 5})", "Freq": 1, "TSR": 0}, {"tool": "def surface_area_of_rectangular_prism(length, width, height):\n    \n    return 2 * (length * width + width * height + height * length)", "subfield": "Volume of Solids", "tool_name": "surface_area_of_rectangular_prism", "tool_type": "function", "description": "Calculate the surface area of a rectangular prism.", "docstring": "Calculate the surface area of a rectangular prism.\n    Parameters:\n    length (float or int): Length of the rectangular prism.\n    width (float or int): Width of the rectangular prism.\n    height (float or int): Height of the rectangular prism.\n    Returns:\n    float: The surface area of the rectangular prism.\n    Examples:\n    >>> surface_area_of_rectangular_prism(10, 4, 5)\n    220.0\n    >>> surface_area_of_rectangular_prism(7.5, 3.5, 1.5)\n    82.5", "Freq": 3, "TSR": 3}, {"tool": "def volume_rectangular_box(length, width, height):\n    \n    return length * width * height", "subfield": "Volume of Solids", "tool_name": "volume_rectangular_box", "tool_type": "function", "description": "Calculate the volume of a rectangular box.", "docstring": "Calculate the volume of a rectangular box.\n    Parameters:\n    length (float): Length of the box.\n    width (float): Width of the box.\n    height (float): Height of the box.\n    Returns:\n    float: Volume of the rectangular box.\n    Examples:\n    >>> volume_rectangular_box(2, 3, 4)\n    24", "Freq": 2, "TSR": 2}, {"tool": "def volume_difference(volume1, volume2):\n    \n    return abs(volume1 - volume2)", "subfield": "Volume of Solids", "tool_name": "volume_difference", "tool_type": "function", "description": "Calculate the difference in volumes between two solids.", "docstring": "Calculate the difference in volumes between two solids.\n    \n    Parameters:\n    volume1 (float): Volume of the first solid.\n    volume2 (float): Volume of the second solid.\n    \n    Returns:\n    float: The difference in volumes, ensuring it's non-negative.\n    \n    Example:\n    >>> volume_difference(50, 27)\n    23.0", "Freq": 1, "TSR": 0}, {"tool": "def volume_frustum(total_volume, removed_volume):\n    \n    return total_volume - removed_volume", "subfield": "Volume of Solids", "tool_name": "volume_frustum", "tool_type": "function", "description": "Compute the volume of a frustum by subtracting the volume of a smaller shape removed from a larger solid.", "docstring": "Compute the volume of a frustum by subtracting the volume of a smaller shape removed from a larger solid.\n    Parameters:\n    total_volume (float): The original volume of the larger solid before the smaller volume was removed.\n    removed_volume (float): The volume of the smaller solid that was removed.\n    Returns:\n    float: The volume of the frustum.\n    Example:\n    >>> volume_frustum(200, 50)\n    150", "Freq": 4, "TSR": 0, "experience_pool": "- When using the volume_frustum function, make sure not to assign the result to a variable with the same name as the function to avoid reference errors."}, {"tool": "def dihedral_angle_between_planes(plane1_normal, plane2_normal):\n    \n    n1 = sp.Matrix(plane1_normal)\n    n2 = sp.Matrix(plane2_normal)\n    return sp.acos(n1.dot(n2) / (n1.norm() * n2.norm()))", "subfield": "Volume of Solids", "tool_name": "dihedral_angle_between_planes", "tool_type": "function", "description": "Calculate the dihedral angle between two planes given their normal vectors.", "docstring": "Calculate the dihedral angle between two planes given their normal vectors.\n    Parameters:\n        plane1_normal (list of float): the normal vector of the first plane.\n        plane2_normal (list of float): the normal vector of the second plane.\n    Returns:\n        float: the dihedral angle in radians between the two planes.\n    Examples:\n        >>> dihedral_angle_between_planes([0, 0, 1], [0, 1, 0])\n        1.5707963267948966", "Freq": 0, "TSR": 0}, {"tool": "def derive_dimensions_by_volume(total_volume, ratio, initial_dimension):\n    \n    import math\n    # Using the formula for volume of rectangular solids: V = lwh\n    # and for geometric progression if l = a, w = ar, h = ar^2 then V = a * ar * ar^2 = a^3 * r^3\n    # Solving for 'a' we get a = (V / r^3)^(1/3)\n    a = (total_volume / (ratio ** 3)) ** (1/3)\n    length = a\n    width = a * ratio\n    height = a * (ratio ** 2)\n    return (length, width, height)", "subfield": "Volume of Solids", "tool_name": "derive_dimensions_by_volume", "tool_type": "function", "description": "Derive the dimensions of a rectangular solid where the dimensions are in geometric progression,\n    given the total volume and a progression ratio.", "docstring": "Derive the dimensions of a rectangular solid where the dimensions are in geometric progression,\n    given the total volume and a progression ratio.\n    Parameters:\n    - total_volume (float): The total volume of the solid.\n    - ratio (float): The common ratio in the geometric progression of the dimensions.\n    - initial_dimension (float): The initial dimension for the geometric progression (commonly the smallest dimension).\n    Returns:\n    - tuple (float, float, float): Returns the dimensions (length, width, height) of the rectangular solid.\n    Example:\n    >>> derive_dimensions_by_volume(216.0, 2, 3.0)\n    (3.0, 6.0, 12.0)", "Freq": 2, "TSR": 0}, {"tool": "class SolidVolumeCalculator:\n    \"\"\" Class to calculate the volumes of various 3D solids.\n    Methods\n    -------\n    cylinder_volume(radius, height)\n        Calculate the volume of a cylinder.\n    \n    tetrahedron_volume(side_length)\n        Calculate the volume of a regular tetrahedron.\n    pyramid_volume(base_area, height)\n        Calculate the volume of a pyramid.\n    solid_of_revolution(f, a, b)\n        Calculate the volume of a solid of revolution of the function f from x=a to x=b about the x-axis.\n    \"\"\"\n    @staticmethod\n    def cylinder_volume(radius, height):\n        \"\"\"\n        Calculate the volume of a right circular cylinder.\n        Parameters:\n        radius (float or sympy.Symbol): The radius of the cylinder.\n        height (float or sympy.Symbol): The height of the cylinder.\n        Returns:\n        float or sympy.Expr: The volume of the cylinder.\n        Example:\n        >>> SolidVolumeCalculator.cylinder_volume(3, 5)\n        141.3716694115407\n        \"\"\"\n        return math.pi * radius**2 * height\n    @staticmethod\n    def tetrahedron_volume(side_length):\n        \"\"\"\n        Calculate the volume of a regular tetrahedron.\n        Parameters:\n        side_length (float or sympy.Symbol): The length of a side of the tetrahedron.\n        Returns:\n        float or sympy.Expr: The volume of the tetrahedron.\n        Example:\n        >>> SolidVolumeCalculator.tetrahedron_volume(2)\n        0.9428090415820632\n        \"\"\"\n        return side_length**3 / (6 * math.sqrt(2))\n    @staticmethod\n    def pyramid_volume(base_area, height):\n        \"\"\"\n        Calculate the volume of a pyramid with a given base area and height.\n        Parameters:\n        base_area (float or sympy.Symbol): The area of the pyramid's base.\n        height (float or sympy.Symbol): The height of the pyramid.\n        Returns:\n        float or sympy.Expr: The volume of the pyramid.\n        Example:\n        >>> SolidVolumeCalculator.pyramid_volume(10, 3)\n        10.0\n        \"\"\"\n        return base_area * height / 3\n    \n    @staticmethod\n    def solid_of_revolution(f, a, b):\n        \"\"\"\n        Calculate the volume of the solid of revolution of a function f from x=a to x=b about the x-axis.\n        Parameters:\n        f (sympy function): A sympy function of x.\n        a (float or sympo.Symbol): The start of the interval of revolution.\n        b (float or sympy.Symbol): The end of the interval of revolution.\n        Returns:\n        float or sympy.Expr: The volume of the solid of revolution.\n        Example:\n        >>> x = sympy.symbols('x')\n        >>> f = sympy.Lambda(x, sympy.sqrt(1 - x**2))\n        >>> SolidVolumeCalculator.solid_of_revolution(f, -1, 1)\n        (4/3)*pi\n        \"\"\"\n        x = sympy.symbols('x')\n        return sympy.pi * sympy.integrate(f(x)**2, (x, a, b))", "subfield": "Volume of Solids", "tool_name": "SolidVolumeCalculator:\n    \"\"\" Class to calculate the volumes of various 3D solids.\n    Methods\n    -------\n    cylinder_volume", "tool_type": "class", "description": "Class to calculate the volumes of various 3D solids.\n    Methods\n    -------\n    cylinder_volume(radius, height)\n        Calculate the volume of a cylinder.\n    \n    tetrahedron_volume(side_length)\n        Calculate the volume of a regular tetrahedron.\n    pyramid_volume(base_area, height)\n        Calculate the volume of a pyramid.\n    solid_of_revolution(f, a, b)\n        Calculate the volume of a solid of revolution of the function f from x=a to x=b about the x-axis.", "docstring": "Class to calculate the volumes of various 3D solids.\n    Methods\n    -------\n    cylinder_volume(radius, height)\n        Calculate the volume of a cylinder.\n    \n    tetrahedron_volume(side_length)\n        Calculate the volume of a regular tetrahedron.\n    pyramid_volume(base_area, height)\n        Calculate the volume of a pyramid.\n    solid_of_revolution(f, a, b)\n        Calculate the volume of a solid of revolution of the function f from x=a to x=b about the x-axis.", "Freq": 0, "TSR": 0}, {"tool": "def volume_of_revolution(func, axis, start, end):\n    \n    x = Symbol(\"x\")\n    if axis == 'x':\n        return pi * integrate(func**2, (x, start, end))\n    else:\n        # Assuming rotation around the y-axis is the integral of pi*r^2 dx where r = f^-1(y)\n        y = Symbol(\"y\")\n        inverse_func = func.subs(x, y)  # assuming func is invertible and expressed in terms of y\n        return pi * integrate(inverse_func**2, (y, start, end))", "subfield": "Volume of Solids", "tool_name": "volume_of_revolution", "tool_type": "function", "description": "Calculate the volume of a solid of revolution by rotating a function about an axis.", "docstring": "Calculate the volume of a solid of revolution by rotating a function about an axis.\n    Parameters:\n    - func (function): Function of x defining the shape to be revolved.\n    - axis (str): Axis about which the shape is revolved ('x' or 'y').\n    - start (float or Symbol): The start of the interval of revolution.\n    - end (float or Symbol): The end of the interval of revolution.\n    Returns:\n    - sympy expression: The volume of the solid of revolution.\n    Examples:\n    >>> x = symbols('x')\n    >>> f = x**2\n    >>> volume_of_revolution(f, 'x', 0, 2)\n    8*pi/5*2**5", "Freq": 0, "TSR": 0}, {"tool": "def pythagorean_theorem(a=None, b=None, c=None):\n    \n    import math\n    if c is None:  # if hypotenuse is missing\n        return math.sqrt(a**2 + b**2)\n    if a is None:  # if one side is missing\n        return math.sqrt(c**2 - b**2)\n    if b is None:  # if the other side is missing\n        return math.sqrt(c**2 - a**2)", "subfield": "Volume of Solids", "tool_name": "pythagorean_theorem", "tool_type": "function", "description": "Calculate the length of a side of a right triangle using the Pythagorean theorem given the lengths of the other two sides.", "docstring": "Calculate the length of a side of a right triangle using the Pythagorean theorem given the lengths of the other two sides.\n    Parameters:\n    a (float, optional): Length of one side of the right triangle.\n    b (float, optional): Length of the other side of the right triangle.\n    c (float, optional): Length of the hypotenuse of the right triangle.\n    Returns:\n    float: The length of the missing side.\n    Example:\n    >>> pythagorean_theorem(a=3, c=5)\n    4.0\n    >>> pythagorean_theorem(b=4, c=5)\n    3.0", "Freq": 1, "TSR": 1}, {"tool": "def find_missing_dimension(volume, length=None, width=None, height=None):\n    \n    if length is None:\n        missing_dimension = volume / (width * height)\n    elif width is None:\n        missing_dimension = volume / (length * height)\n    elif height is None:\n        missing_dimension = volume / (length * width)\n    else:\n        raise ValueError(\"Only one dimension should be missing.\")\n    return missing_dimension", "subfield": "Volume of Solids", "tool_name": "find_missing_dimension", "tool_type": "function", "description": "Given the volume and any two dimensions of a rectangular prism, calculate the missing dimension.", "docstring": "Given the volume and any two dimensions of a rectangular prism, calculate the missing dimension.\n    Parameters:\n    volume (float or int): The volume of the rectangular solid.\n    length (float or int, optional): The length of the rectangular solid. Defaults to None.\n    width (float or int, optional): The width of the rectangular solid. Defaults to None.\n    height (float or int, optional): The height of the rectangular solid. Defaults to None.\n    Returns:\n    float: The missing dimension of the rectangular solid.\n    Examples:\n    >>> find_missing_dimension(100, length=10, width=5)\n    2.0\n    >>> find_missing_dimension(36, height=1.5, width=3.2)\n    7.5", "Freq": 1, "TSR": 1}, {"tool": "def calculate_geometric_solid_volume(shape_type, dimensions):\n    \n    import math\n    def sphere_volume(radius):\n        \n        return (4/3) * math.pi * radius ** 3\n    def tetrahedron_volume(side_length):\n        \n        return (side_length ** 3) / (6 * math.sqrt(2))\n    def pyramid_volume(base_area, height):\n        \n        return (1/3) * base_area * height\n    if shape_type == \"sphere\":\n        radius = dimensions[\"radius\"]\n        return sphere_volume(radius)\n    elif shape_type == \"tetrahedron\":\n        side_length = dimensions[\"side_length\"]\n        return tetrahedron_volume(side_length)\n    elif shape_type == \"pyramid\":\n        base_area = dimensions[\"base_area\"]\n        height = dimensions[\"height\"]\n        return pyramid_volume(base_area, height)\n    else:\n        raise ValueError(\"Invalid shape type provided\")", "subfield": "Volume of Solids", "tool_name": "calculate_geometric_solid_volume", "tool_type": "function", "description": "Calculate the volume of various geometric solids based on given parameters.", "docstring": "Calculate the volume of various geometric solids based on given parameters.\n    \n    Parameters:\n    shape_type (str): The type of solid (\"sphere\", \"complex_solid\", \"tetrahedron\", \"pyramid\").\n    dimensions (dict): A dictionary containing the necessary dimensions for the calculation.\n    \n    Returns:\n    float: The volume of the specified solid.\n    \n    Example:\n    >>> calculate_geometric_solid_volume(\"sphere\", {\"radius\": 3})\n    113.09733552923255\n    >>> calculate_geometric_solid_volume(\"tetrahedron\", {\"side_length\": 4})\n    10.666666666666666", "Freq": 0, "TSR": 0}, {"tool": "def composite_volume_calculator(shapes):\n    \n    import math\n    \n    def cylinder_volume(radius, height):\n        return math.pi * radius ** 2 * height\n    \n    def cone_volume(radius, height):\n        return (1/3) * math.pi * radius ** 2 * height\n    \n    def pyramid_volume(base_area, height):\n        return (1/3) * base_area * height\n    \n    total_volume = 0\n    \n    for shape in shapes:\n        shape_type = shape['type']\n        dimensions = shape['dimensions']\n        scale = shape.get('scale', 1)  # Default scale to 1 if not provided\n        \n        if shape_type == 'cylinder':\n            volume = cylinder_volume(dimensions['radius'], dimensions['height'])\n        elif shape_type == 'cone':\n            volume = cone_volume(dimensions['radius'], dimensions['height'])\n        elif shape_type == 'pyramid':\n            volume = pyramid_volume(dimensions['base_area'], dimensions['height'])\n        else:\n            raise ValueError(\"Invalid shape type provided\")\n        \n        total_volume += volume * scale  # Apply scaling factor\n    \n    return total_volume", "subfield": "Volume of Solids", "tool_name": "composite_volume_calculator", "tool_type": "function", "description": "Calculate the total volume of a composite shape based on the volumes of its components.", "docstring": "Calculate the total volume of a composite shape based on the volumes of its components.\n    \n    Parameters:\n    shapes (list of dict): A list of dictionaries where each dictionary contains:\n        - 'type' (str): The type of shape (e.g., 'cylinder', 'cone', 'pyramid', etc.)\n        - 'dimensions' (dict): A dictionary of dimensions relevant to the shape type.\n        - 'scale' (float, optional): A scaling factor for the shape's volume.\n    \n    Returns:\n    float: The total volume of the composite shape.\n    \n    Example:\n    >>> shapes = [\n    ...     {'type': 'cylinder', 'dimensions': {'radius': 4, 'height': 10}},\n    ...     {'type': 'cone', 'dimensions': {'radius': 3, 'height': 5}, 'scale': 2}\n    ... ]\n    >>> composite_volume_calculator(shapes)\n    167.552", "Freq": 0, "TSR": 0}, {"tool": "def composite_volume_ratio(shape1, shape2, dimensions1, dimensions2):\n    \n    import math\n    \n    def volume_cone(radius, height):\n        return (1/3) * math.pi * radius ** 2 * height\n    \n    def volume_cylinder(radius, height):\n        return math.pi * radius ** 2 * height\n    \n    def volume_rectangular_prism(length, width, height):\n        return length * width * height\n    \n    volume1 = 0\n    volume2 = 0\n    \n    if shape1 == 'cone':\n        volume1 = volume_cone(dimensions1['radius'], dimensions1['height'])\n    elif shape1 == 'cylinder':\n        volume1 = volume_cylinder(dimensions1['radius'], dimensions1['height'])\n    elif shape1 == 'rectangular_prism':\n        volume1 = volume_rectangular_prism(dimensions1['length'], dimensions1['width'], dimensions1['height'])\n    \n    if shape2 == 'cone':\n        volume2 = volume_cone(dimensions2['radius'], dimensions2['height'])\n    elif shape2 == 'cylinder':\n        volume2 = volume_cylinder(dimensions2['radius'], dimensions2['height'])\n    elif shape2 == 'rectangular_prism':\n        volume2 = volume_rectangular_prism(dimensions2['length'], dimensions2['width'], dimensions2['height'])\n    \n    if volume2 == 0:\n        raise ValueError(\"Volume of shape2 cannot be zero.\")\n    \n    return volume1 / volume2", "subfield": "Volume of Solids", "tool_name": "composite_volume_ratio", "tool_type": "function", "description": "Calculate the ratio of the volumes of two geometric shapes based on their dimensions.", "docstring": "Calculate the ratio of the volumes of two geometric shapes based on their dimensions.\n    \n    Parameters:\n    shape1 (str): The type of the first shape (e.g., 'cone', 'cylinder', 'rectangular_prism').\n    shape2 (str): The type of the second shape (e.g., 'cone', 'cylinder', 'rectangular_prism').\n    dimensions1 (dict): A dictionary containing the dimensions of the first shape.\n    dimensions2 (dict): A dictionary containing the dimensions of the second shape.\n    \n    Returns:\n    float: The ratio of the volume of shape1 to the volume of shape2.\n    \n    Example:\n    >>> composite_volume_ratio('cone', 'cylinder', {'radius': 3, 'height': 5}, {'radius': 3, 'height': 5})\n    0.2", "Freq": 0, "TSR": 0}], "Perimeter": [], "3D Shapes": [{"tool": "def point_distance(p1, p2):\n    \n    return np.linalg.norm(np.array(p1) - np.array(p2))", "subfield": "3D Shapes", "tool_name": "point_distance", "tool_type": "function", "description": "Calculate Euclidean distance between points p1 and p2 in 3D space.", "docstring": "Calculate Euclidean distance between points p1 and p2 in 3D space.\n    \n    Parameters:\n    - p1, p2 (iterable with three numbers - list, tuple): Coordinates of the points p1 and p2.\n    \n    Returns:\n    - float: Euclidean distance between points p1 and p2.\n    \n    Example:\n    >>> point_distance((1, 2, 3), (4, 6, 8))\n    7.483314773547883", "Freq": 4, "TSR": 3, "experience_pool": "- When using the tool, ensure that the input parameters are correctly provided as iterable with three numbers (list, tuple) for both points p1 and p2.\n- Double-check the coordinates of the points and the calculations involved in determining the distances between them to avoid errors in the final results."}, {"tool": "def volume_cylinder(radius, height):\n    \n    return pi * radius ** 2 * height", "subfield": "3D Shapes", "tool_name": "volume_cylinder", "tool_type": "function", "description": "Calculate the volume of a cylinder.", "docstring": "Calculate the volume of a cylinder.\n    \n    Parameters:\n    - radius (float): The radius of the cylinder.\n    - height (float): The height of the cylinder.\n    \n    Returns:\n    - float: The volume of the cylinder.\n    \n    Example:\n    >>> volume_cylinder(1, 2)\n    6.283185307179586", "Freq": 4, "TSR": 4}, {"tool": "def cylinder_lateral_surface_area(radius, height):\n    \n    return 2 * math.pi * radius * height", "subfield": "3D Shapes", "tool_name": "cylinder_lateral_surface_area", "tool_type": "function", "description": "Calculate the lateral surface area of a cylinder.", "docstring": "Calculate the lateral surface area of a cylinder.\n    \n    Parameters:\n    radius (float): The radius of the cylinder.\n    height (float): The height of the cylinder.\n    \n    Returns:\n    float: The lateral surface area of the cylinder.\n    Example:\n    >>> cylinder_lateral_surface_area(3, 5)\n    94.24777960769379", "Freq": 1, "TSR": 1}, {"tool": "def cube_properties(side_length):\n    \n    volume = side_length ** 3\n    surface_area = 6 * (side_length ** 2)\n    face_diagonal = np.sqrt(2) * side_length\n    space_diagonal = np.sqrt(3) * side_length\n    return {\n        \"volume\": volume,\n        \"surface_area\": surface_area,\n        \"face_diagonal\": round(face_diagonal, 2),\n        \"space_diagonal\": round(space_diagonal, 2)\n    }", "subfield": "3D Shapes", "tool_name": "cube_properties", "tool_type": "function", "description": "Calculate properties of a cube given its side length.", "docstring": "Calculate properties of a cube given its side length.\n    Parameters:\n    - side_length (float): The length of a side of the cube.\n    Returns:\n    - dict: Dictionary containing properties like volume, surface area, face diagonal, and space diagonal.\n    \n    Examples:\n    >>> cube_properties(2)\n    {'volume': 8, 'surface_area': 24, 'face_diagonal': 2.83, 'space_diagonal': 3.46}", "Freq": 5, "TSR": 4}, {"tool": "def geometric_properties_3d(shape_type, dimensions):\n    \n    if shape_type in ['triangular_prism', 'rectangular_prism', 'square_prism']:\n        base_edges = dimensions['base_edges']\n        faces = 2 + base_edges\n        edges = 3 * base_edges\n        vertices = 2 * base_edges\n    elif shape_type == 'pyramid':\n        base_edges = dimensions['base_edges']\n        faces = base_edges + 1\n        edges = 2 * base_edges\n        vertices = base_edges + 1\n    else:\n        raise ValueError(\"Unsupported shape_type provided.\")\n    \n    return {'faces': faces, 'edges': edges, 'vertices': vertices}", "subfield": "3D Shapes", "tool_name": "geometric_properties_3d", "tool_type": "function", "description": "Calculate basic geometric properties (faces, edges, vertices) for 3D shapes such as various prisms and pyramids.", "docstring": "Calculate basic geometric properties (faces, edges, vertices) for 3D shapes such as various prisms and pyramids.\n    Parameters:\n    shape_type (str): Type of the 3D shape ('triangular_prism', 'rectangular_prism', 'square_prism', 'pyramid').\n    dimensions (dict): Dimensions of the 3D shape. For prisms: {'base_edges': int, 'height': float}.\n                       For pyramids: {'base_edges': int, 'side_edges': int, 'height': float}.\n    \n    Returns:\n    dict: Dictionary containing number of faces, edges, and vertices.\n    \n    Examples:\n    >>> geometric_properties_3d('triangular_prism', {'base_edges': 3, 'height': 10})\n    {'faces': 5, 'edges': 9, 'vertices': 6}\n    \n    >>> geometric_properties_3d('pyramid', {'base_edges': 4, 'side_edges': 4, 'height': 9})\n    {'faces': 5, 'edges': 8, 'vertices': 5}", "Freq": 4, "TSR": 4}, {"tool": "def surface_area_volume(shape_type, dimensions):\n    \n    if shape_type == 'rectangular_prism':\n        l, w, h = dimensions['length'], dimensions['width'], dimensions['height']\n        surface_area = 2 * (l * w + l * h + w * h)\n        volume = l * w * h\n    elif shape_type == 'pyramid':\n        l, w, h = dimensions['base_length'], dimensions['width'], dimensions['height']\n        base_area = l * w\n        surface_area = l * w + l * sqrt((w/2)**2 + h**2) + w * sqrt((l/2)**2 + h**2)\n        volume = (l * w * h) / 3\n    else:\n        raise ValueError(\"Invalid shape type provided.\")\n    return {'surface_area': surface_area, 'volume': volume}", "subfield": "3D Shapes", "tool_name": "surface_area_volume", "tool_type": "function", "description": "Calculate the surface area and volume for common 3D shapes such as prisms and pyramids based on provided dimensions.", "docstring": "Calculate the surface area and volume for common 3D shapes such as prisms and pyramids based on provided dimensions.\n    Parameters:\n    shape_type (str): Type of the 3D shape ('triangular_prism', 'rectangular_prism', 'pyramid').\n    dimensions (dict): Dimensions necessary for calculations. Prisms: {'length': float, 'width': float, 'height': float}.\n                       Pyramid: {'base_length': float, 'base_width': float, 'height': float}.\n    Returns:\n    dict: Dictionary containing 'surface_area' and 'volume' of the shape.\n    Examples:\n    >>> surface_area_volume('rectangular_prism', {'length': 2, 'width': 3, 'height': 4})\n    {'surface_area': 52.0, 'volume': 24.0}\n    \n    >>> surface_area_volume('pyramid', {'base_length': 4, 'base_width': 4, 'height': 6})\n    {'surface_area': 52.624, 'volume': 32.0}", "Freq": 1, "TSR": 1}, {"tool": "def cube_volume(side_length):\n    \n    return side_length ** 3", "subfield": "3D Shapes", "tool_name": "cube_volume", "tool_type": "function", "description": "Calculate the volume of a cube.", "docstring": "Calculate the volume of a cube.\n    \n    Parameters:\n    side_length (float): The length of a side of the cube.\n    \n    Returns:\n    float: The volume of the cube.\n    \n    Example:\n    >>> cube_volume(3)\n    27", "Freq": 3, "TSR": 1, "experience_pool": "- When calculating the side length of a cube inscribed in a sphere, use the formula: cube_side_length = sphere_diameter / math.sqrt(3)\n- Ensure that the correct formula for calculating the inscribed cube volume is used: inscribed_cube_volume = cube_volume(cube_side_length)"}, {"tool": "def pyramid_properties(base_side, height):\n    \n    base_area = base_side ** 2\n    volume = (1/3) * base_area * height\n    slant_height = np.sqrt((base_side/2) ** 2 + height ** 2)\n    return {\n        \"volume\": volume,\n        \"slant_height\": round(slant_height, 2)\n    }", "subfield": "3D Shapes", "tool_name": "pyramid_properties", "tool_type": "function", "description": "Calculate properties of a square base pyramid.", "docstring": "Calculate properties of a square base pyramid.\n    Parameters:\n    - base_side (float): The length of one side of the square base.\n    - height (float): The height of the pyramid from the base to the apex.\n    Returns:\n    - dict: Dictionary containing properties like volume and slant height.\n    \n    Examples:\n    >>> pyramid_properties(3, 4)\n    {'volume': 12.0, 'slant_height': 5.0}", "Freq": 2, "TSR": 0}, {"tool": "def calculate_frustum_properties(r1, r2, h):\n    \n    lateral_area = math.pi * (r1 + r2) * math.sqrt((r2 - r1) ** 2 + h ** 2)\n    total_area = lateral_area + math.pi * (r1 ** 2 + r2 ** 2)\n    volume = (1 / 3) * math.pi * h * (r1 ** 2 + r2 ** 2 + r1 * r2)\n    \n    return {\n        'lateral_surface_area': lateral_area,\n        'total_surface_area': total_area,\n        'volume': volume,\n    }", "subfield": "3D Shapes", "tool_name": "calculate_frustum_properties", "tool_type": "function", "description": "Calculate properties of a frustum formed by truncation of a right circular cone.", "docstring": "Calculate properties of a frustum formed by truncation of a right circular cone.\n    Parameters\n    ----------\n    r1 : float\n        Radius of the smaller circular base.\n    r2 : float\n        Radius of the larger circular base.\n    h : float\n        Height of the frustum (the distance between the two bases).\n    Returns\n    -------\n    dict :\n        A dictionary containing:\n            - lateral_surface_area : float\n                The lateral surface area of the frustum.\n            - total_surface_area : float\n                The total surface area of the frustum (including the areas of the two bases).\n            - volume : float\n                The volume of the frustum.\n    Examples\n    --------\n    >>> calculate_frustum_properties(3, 5, 7)\n    {\n        'lateral_surface_area': 150.079644737231,\n        'total_surface_area': 276.46015351590174,\n        'volume': 345.5774616441417\n    }", "Freq": 2, "TSR": 0, "experience_pool": "- Make sure to provide the correct input parameters (r1, r2, h) when calling the calculate_frustum_properties function.\n- Double-check the calculations and formulas used in the calling code to ensure they align with the properties of a frustum."}, {"tool": "def midpoint(p1, p2):\n    \n    return ((p1[0] + p2[0]) / 2, (p1[1] + p2[1]) / 2, (p1[2] + p2[2]) / 2)", "subfield": "3D Shapes", "tool_name": "midpoint", "tool_type": "function", "description": "Calculate the midpoint between two points in 3D space.", "docstring": "Calculate the midpoint between two points in 3D space.\n    Parameters:\n    - p1 : tuple of floats\n        Coordinates of the first point (x1, y1, z1).\n    - p2 : tuple of floats\n        Coordinates of the second point (x2, y2, z2).\n    Returns:\n    - tuple of floats\n        The midpoint coordinates (mx, my, mz).\n    Examples:\n    >>> midpoint((1, 1, 1), (3, 5, 3))\n    (2.0, 3.0, 2.0)", "Freq": 3, "TSR": 3}, {"tool": "def rotate_point(point, axis, theta):\n    \n    axis = np.array(axis)\n    theta = np.radians(theta)\n    axis = axis / np.linalg.norm(axis)\n    a = np.cos(theta / 2)\n    b, c, d = -axis * np.sin(theta / 2)\n    aa, bb, cc, dd = a**2, b**2, c**2, d**2\n    bc, ad, ac, ab, bd, cd = b*c, a*d, a*c, a*b, b*d, c*d\n    rot_matrix = np.array([[aa+bb-cc-dd, 2*(bc+ad), 2*(bd-ac)],\n                           [2*(bc-ad), aa+cc-bb-dd, 2*(cd+ab)],\n                           [2*(bd+ac), 2*(cd-ab), aa+dd-bb-cc]])\n    return np.dot(rot_matrix, point)", "subfield": "3D Shapes", "tool_name": "rotate_point", "tool_type": "function", "description": "Rotate a point around a given axis by theta degrees in 3D space.", "docstring": "Rotate a point around a given axis by theta degrees in 3D space.\n    Parameters:\n        point (array-like): The [x, y, z] coordinates of the point to rotate.\n        axis (array-like): The [x, y, z] coordinates of the axis to rotate about.\n        theta (float): The rotation angle in degrees.\n    Returns:\n        array: The new [x, y, z] coordinates of the rotated point.\n    Examples:\n        >>> rotate_point([1, 0, 0], [0, 0, 1], 90)\n        array([6.123234e-17, 1.000000e+00, 0.000000e+00])", "Freq": 0, "TSR": 0}, {"tool": "def count_unit_cubes_with_painted_faces(n, faces_painted):\n    \n    if faces_painted == 0:\n        return 0\n    elif faces_painted == 1:\n        return 6 * (n - 2)**2\n    elif faces_painted == 2:\n        return 12 * (n - 2)\n    elif faces_painted == 3:\n        return 8\n    return 0", "subfield": "3D Shapes", "tool_name": "count_unit_cubes_with_painted_faces", "tool_type": "function", "description": "Calculate the number of unit cubes with a certain number of painted faces in an n x n x n cube.", "docstring": "Calculate the number of unit cubes with a certain number of painted faces in an n x n x n cube.\n    Parameters:\n    n (int): The side length of the cube in terms of number of unit cubes.\n    faces_painted (int): The number of faces that are painted on the unit cubes.\n    Returns:\n    int: The count of unit cubes with exactly the specified number of painted faces.", "Freq": 3.5, "TSR": 1, "experience_pool": "Tool has been evolved to handle different scenarios and provide correct results."}, {"tool": "def line_plane_intersection(plane_normal, plane_point, line_point, line_dir):\n    \n    plane_normal = np.array(plane_normal)\n    plane_point = np.array(plane_point)\n    line_point = np.array(line_point)\n    line_dir = np.array(line_dir)\n    denom = np.dot(plane_normal, line_dir)\n    if np.abs(denom) < 1e-6:\n        return None  # No intersection, the line is parallel to the plane\n    t = (np.dot(plane_normal, plane_point - line_point)) / denom\n    return line_point + t * line_dir", "subfield": "3D Shapes", "tool_name": "line_plane_intersection", "tool_type": "function", "description": "Calculate the intersection point of a line and a plane in 3D.", "docstring": "Calculate the intersection point of a line and a plane in 3D.\n    \n    Parameters:\n    - plane_normal (iterable with three numbers): Normal vector of the plane.\n    - plane_point (iterable with three numbers): A point on the plane.\n    - line_point (iterable with three numbers): A point on the line.\n    - line_dir (iterable with three numbers): Direction vector of the line.\n    \n    Returns:\n    - array: The coordinates of the intersection point or None if no intersection exists.\n    \n    Example:\n    >>> line_plane_intersection([0, 0, 1], [0, 0, 5], [1, 1, 0], [0, 1, 1])\n    array([1., 4., 5.])", "Freq": 3, "TSR": 0, "experience_pool": "- Make sure to provide the correct input parameters (plane_normal, plane_point, line_point, line_dir) when calling the line_plane_intersection function.\n- Double-check the calculations and coordinates of points when using the line_plane_intersection function."}, {"tool": "def surface_area_cube(edge_length):\n    \n    return 6 * (edge_length ** 2)", "subfield": "3D Shapes", "tool_name": "surface_area_cube", "tool_type": "function", "description": "Calculate the surface area of a cube given the length of its edge.", "docstring": "Calculate the surface area of a cube given the length of its edge.\n    \n    Parameters:\n    - edge_length (float/int): The length of one edge of the cube.\n    \n    Returns:\n    - float: The surface area of the cube.\n    \n    Example:\n    >>> surface_area_cube(2)\n    24", "Freq": 1, "TSR": 1}, {"tool": "def prism_properties(num_bases, base_vertices, height_exists=True):\n    \n    vertices = num_bases * base_vertices\n    edges = num_bases * base_vertices + base_vertices * (num_bases - 1)\n    faces = num_bases + (height_exists * base_vertices)\n    return {\n        'vertices': vertices,\n        'edges': edges,\n        'faces': faces\n    }", "subfield": "3D Shapes", "tool_name": "prism_properties", "tool_type": "function", "description": "Calculate the properties (vertices, edges, faces) of a prism given \n    the properties of the base and whether it includes a height (for right prisms).", "docstring": "Calculate the properties (vertices, edges, faces) of a prism given \n    the properties of the base and whether it includes a height (for right prisms).\n    Parameters:\n    - num_bases (int): The number of identical bases the prism has (usually 2).\n    - base_vertices (int): The number of vertices on each base.\n    - height_exists (bool): True if the prism has a distinct height dimension (right prism), otherwise False.\n    Returns:\n    - dict: Dictionary containing number of vertices, edges, and faces.\n    Examples:\n    >>> prism_properties(2, 4)  # Rectangular prism\n    {'vertices': 8, 'edges': 12, 'faces': 6}\n    >>> prism_properties(2, 3)  # Triangular prism\n    {'vertices': 6, 'edges': 9, 'faces': 5}", "Freq": 0, "TSR": 0}, {"tool": "def volume_pyramid(base_area, height):\n    \n    return (1/3) * base_area * height", "subfield": "3D Shapes", "tool_name": "volume_pyramid", "tool_type": "function", "description": "Calculate the volume of a pyramid.", "docstring": "Calculate the volume of a pyramid.\n    Parameters:\n    - base_area : float\n        The area of the pyramid's base.\n    - height : float\n        The height of the pyramid from the base to the apex.\n    Returns:\n    - float\n        The volume of the pyramid.\n    Examples:\n    >>> volume_pyramid(9, 12)\n    36", "Freq": 2, "TSR": 2}, {"tool": "def find_centroid_of_tetrahedron(vertex1, vertex2, vertex3, vertex4):\n    \n    x = (vertex1[0] + vertex2[0] + vertex3[0] + vertex4[0]) / 4\n    y = (vertex1[1] + vertex2[1] + vertex3[1] + vertex4[1]) / 4\n    z = (vertex1[2] + vertex2[2] + vertex3[2] + vertex4[2]) / 4\n    \n    return (x, y, z)", "subfield": "3D Shapes", "tool_name": "find_centroid_of_tetrahedron", "tool_type": "function", "description": "Find the centroid of a tetrahedron given its vertices.", "docstring": "Find the centroid of a tetrahedron given its vertices.\n    Parameters\n    ----------\n    vertex1 : tuple of float\n        Coordinates of the first vertex (x1, y1, z1).\n    vertex2 : tuple of float\n        Coordinates of the second vertex (x2, y2, z2).\n    vertex3 : tuple of float\n        Coordinates of the third vertex (x3, y3, z3).\n    vertex4 : tuple of float\n        Coordinates of the fourth vertex (x4, y4, z4).\n    Returns\n    -------\n    tuple :\n        The coordinates of the centroid.\n    Examples\n    --------\n    >>> find_centroid_of_tetrahedron((0, 0, 0), (1, 0, 0), (0, 1, 0), (0, 0, 1))\n    (0.25, 0.25, 0.25)", "Freq": 2, "TSR": 2}, {"tool": "def pythagoras_theorem(a, b):\n    \n    return np.sqrt(a**2 + b**2)", "subfield": "3D Shapes", "tool_name": "pythagoras_theorem", "tool_type": "function", "description": "Calculate the hypotenuse of a right triangle given the other two sides.", "docstring": "Calculate the hypotenuse of a right triangle given the other two sides.\n    Parameters:\n    a : float\n        Length of one side of the right triangle.\n    b : float\n        Length of the other side of the right triangle.\n    Returns:\n    float\n        Length of the hypotenuse.\n        \n    Examples:\n    >>> pythagoras_theorem(3, 4)\n    5.0", "Freq": 2, "TSR": 2}, {"tool": "def sphere_surface_area(radius):\n    \n    return 4 * pi * radius ** 2", "subfield": "3D Shapes", "tool_name": "sphere_surface_area", "tool_type": "function", "description": "Calculate the surface area of a sphere.", "docstring": "Calculate the surface area of a sphere.\n    \n    Parameters:\n    - radius (float): The radius of the sphere.\n    \n    Returns:\n    - float: The total surface area of the sphere.\n    \n    Example:\n    >>> sphere_surface_area(2)\n    50.26548245743669", "Freq": 1, "TSR": 0}, {"tool": "def volume_polyhedron(points):\n    \n    hull = ConvexHull(points)\n    return hull.volume", "subfield": "3D Shapes", "tool_name": "volume_polyhedron", "tool_type": "function", "description": "Calculate the volume of a convex polyhedron defined by its vertices.", "docstring": "Calculate the volume of a convex polyhedron defined by its vertices.\n    Parameters:\n        points (array-like): A list of vertices of the polyhedron, where each vertex is a list [x, y, z].\n    Returns:\n        float: Volume of the polyhedron.\n    \n    Examples:\n        >>> volume_polyhedron([[0, 0, 0], [1, 0, 0], [0, 1, 0], [0, 0, 1]])\n        0.16666666666666666", "Freq": 0, "TSR": 0}, {"tool": "def relations_between_cube_and_sphere(cube_side):\n    \n    return cube_side / 2", "subfield": "3D Shapes", "tool_name": "relations_between_cube_and_sphere", "tool_type": "function", "description": "Calculate the relationship between a cube and an inscribed sphere.", "docstring": "Calculate the relationship between a cube and an inscribed sphere.\n    Parameters:\n        cube_side (float): The length of the side of the cube.\n    Returns:\n        float: The radius of the sphere inscribed in the cube.\n    Example:\n        >>> relations_between_cube_and_sphere(4)\n        2.0", "Freq": 1, "TSR": 0}, {"tool": "def calculate_tetrahedron_properties(edge_length):\n    \n    face_area = (math.sqrt(3) / 4) * edge_length ** 2\n    total_surface_area = 4 * face_area\n    volume = (edge_length ** 3) / (6 * math.sqrt(2))\n    \n    return {\n        'face_area': face_area,\n        'total_surface_area': total_surface_area,\n        'volume': volume,\n    }", "subfield": "3D Shapes", "tool_name": "calculate_tetrahedron_properties", "tool_type": "function", "description": "Calculate properties of a regular tetrahedron.", "docstring": "Calculate properties of a regular tetrahedron.\n    Parameters\n    ----------\n    edge_length : float\n        The length of one edge of the tetrahedron.\n    Returns\n    -------\n    dict :\n        A dictionary containing:\n            - face_area : float\n                The area of one of the triangular faces.\n            - total_surface_area : float\n                The total surface area of the tetrahedron.\n            - volume : float\n                The volume of the tetrahedron.\n    Examples\n    --------\n    >>> calculate_tetrahedron_properties(3)\n    {\n        'face_area': 3.8971143170299753,\n        'total_surface_area': 15.588457268119901,\n        'volume': 3.1819805153394633\n    }", "Freq": 2, "TSR": 0}, {"tool": "def inscribed_sphere_diameter(side_length):\n    \n    return side_length  # Diameter of inscribed sphere is equal to the side length of the cube.", "subfield": "3D Shapes", "tool_name": "inscribed_sphere_diameter", "tool_type": "function", "description": "Calculate the diameter of a sphere inscribed in a cube.", "docstring": "Calculate the diameter of a sphere inscribed in a cube.\n    \n    Parameters:\n    side_length : float\n        The length of a side of the cube.\n    \n    Returns:\n    float\n        The diameter of the inscribed sphere.\n    Examples:\n    >>> diameter = inscribed_sphere_diameter(10)\n    >>> print(diameter)\n    10.0", "Freq": 0, "TSR": 0}, {"tool": "def plane_from_points(p1, p2, p3):\n    \n    p1, p2, p3 = np.array(p1), np.array(p2), np.array(p3)\n    v1 = p2 - p1\n    v2 = p3 - p1\n    normal = np.cross(v1, v2)\n    d = -np.dot(normal, p1)\n    return normal, d", "subfield": "3D Shapes", "tool_name": "plane_from_points", "tool_type": "function", "description": "Determine the equation of a plane given three points in 3D space.", "docstring": "Determine the equation of a plane given three points in 3D space.\n    \n    Parameters:\n        p1, p2, p3 (array-like): Coordinates of three points in the plane.\n    Returns:\n        array: Coefficients of the plane equation ax + by + cz + d = 0\n    \n    Examples:\n        >>> plane_from_points([0, 0, 0], [1, 0, 0], [0, 1, 0])\n        (array([0., 0., 1.]), -0.0)", "Freq": 1, "TSR": 0}, {"tool": "def cube_cut_paint_faces(total_cubes, painted_cubes, side_cubes):\n    \n    # Assuming the large cube is painted on all faces and then cut.\n    # Cubes at the center of a face only have one painted face.\n    face_center_cubes = 6 * (side_cubes - 2)**2\n    # Cubes at the edge but not corners have 2 painted faces.\n    edge_cubes = 12 * (side_cubes - 2)\n    # Corner cubes", "subfield": "3D Shapes", "tool_name": "cube_cut_paint_faces", "tool_type": "function", "description": "Calculate the total faces painted after cutting a larger cube into\n    smaller unit cubes.", "docstring": "Calculate the total faces painted after cutting a larger cube into\n    smaller unit cubes.\n    \n    Parameters:\n    total_cubes : int\n        Total number of smaller cubes after cutting.\n    painted_cubes : int\n        Number of painted cubes.\n    side_cubes : int\n        Number of cubes along one edge of the cube.\n    \n    Returns:\n    int\n        The number of faces that are painted.\n    \n    Examples:\n    >>> faces_painted = cube_cut_paint_faces(27, 26, 3)\n    >>> print(faces_painted)\n    54", "Freq": 0, "TSR": 0}, {"tool": "def subtask_reconstruction_from_projections(projections):\n    \n    # For simplicity and lack of context, I'll return the sum of the maximums of each projection\n    return sum(max(proj) for proj in projections)", "subfield": "3D Shapes", "tool_name": "subtask_reconstruction_from_projections", "tool_type": "function", "description": "Estimate the minimum number of unit cubes needed to match given 2D projections.", "docstring": "Estimate the minimum number of unit cubes needed to match given 2D projections.\n    Parameters:\n        projections (list of list): Projections of the 3D object in terms of unit cubes per axis.\n    Returns:\n        int: Minimum number of unit cubes necessary to form the 3D shape.\n    Example:\n        >>> subtask_reconstruction_from_projections([[1, 2], [2, 1], [1, 3]])\n        6", "Freq": 0, "TSR": 0}, {"tool": "def geometric_calculations(shape_type, dimensions):\n    \n    \n    def count_diagonals_cube():\n        # A cube has 12 edges and 8 vertices\n        vertices = 8\n        edges = 12\n        # Diagonals = Total connections - edges - vertices\n        diagonals = (vertices * (vertices - 1) // 2) - edges - vertices\n        return diagonals\n    \n    def orthocenter_triangle(A, B, C):\n        # Calculate the orthocenter of triangle ABC\n        # A, B, C are tuples representing the coordinates of the vertices\n        A = np.array(A)\n        B = np.array(B)\n        C = np.array(C)\n        \n        # Calculate the midpoints of sides\n        D = (A + B) / 2\n        E = (B + C) / 2\n        F = (C + A) / 2\n        \n        # Calculate the slopes of the altitudes\n        slope_AB = (B[1] - A[1]) / (B[0] - A[0]) if (B[0] - A[0]) != 0 else float('inf')\n        slope_BC = (C[1] - B[1]) / (C[0] - B[0]) if (C[0] - B[0]) != 0 else float('inf')\n        \n        # Calculate the perpendicular slopes\n        perp_slope_AB = -1 / slope_AB if slope_AB != 0 else 0\n        perp_slope_BC = -1 / slope_BC if slope_BC != 0 else 0\n        \n        # Calculate the equations of the altitudes\n        # Using point-slope form: y - y1 = m(x - x1)\n        # For altitude from C to AB\n        altitude_C = lambda x: perp_slope_AB * (x - C[0]) + C[1]\n        # For altitude from A to BC\n        altitude_A = lambda x: perp_slope_BC * (x - A[0]) + A[1]\n        \n        # Solve for intersection (orthocenter)\n        # This requires solving altitude_C(x) = altitude_A(x)\n        # This can be done numerically or symbolically depending on the slopes\n        \n        # Here we will use a numerical approach to find the intersection\n        from scipy.optimize import fsolve\n        \n        def equations(x):\n            return altitude_C(x) - altitude_A(x)\n        \n        x_orthocenter = fsolve(equations, A[0])[0]\n        y_orthocenter = altitude_C(x_orthocenter)\n        \n        return (x_orthocenter, y_orthocenter)\n    \n    def cylinder_in_hemisphere(radius_cylinder, radius_hemisphere):\n        # Calculate the height of a cylinder inscribed in a hemisphere\n        height = np.sqrt(radius_hemisphere**2 - radius_cylinder**2)\n        return height\n    \n    if shape_type == 'cube':\n        return {'number_of_diagonals': count_diagonals_cube()}\n    elif shape_type == 'triangle':\n        return {'orthocenter': orthocenter_triangle(**dimensions)}\n    elif shape_type == 'cylinder_in_hemisphere':\n        return {'height': cylinder_in_hemisphere(dimensions['radius_cylinder'], dimensions['radius_hemisphere'])}\n    else:\n        raise ValueError(\"Unsupported shape_type provided.\")", "subfield": "3D Shapes", "tool_name": "geometric_calculations", "tool_type": "function", "description": "Perform various geometric calculations based on the shape type and dimensions provided.", "docstring": "Perform various geometric calculations based on the shape type and dimensions provided.\n    Parameters:\n    shape_type (str): The type of geometric shape ('cube', 'triangle', 'cylinder_in_hemisphere').\n    dimensions (dict): A dictionary containing the necessary dimensions for the calculation.\n    Returns:\n    dict: A dictionary containing the results of the calculations.", "Freq": 3, "TSR": 1}], "Transformations": [], "Squares": [], "Planes in Three Dimensions": [], "Similar Triangles": [], "Pythagorean Theorem": [{"tool": "def pythagorean_tools(leg_a=None, leg_b=None, hypotenuse=None, radius=None, hemisphere_radius=None):\n    \n    \n    results = {}\n    \n    def calculate_hypotenuse(leg_a, leg_b):\n        \n        return (leg_a**2 + leg_b**2)**0.5\n    \n    def calculate_missing_leg(hypotenuse, leg_a):\n        \n        missing_leg_squared = hypotenuse**2 - leg_a**2\n        if missing_leg_squared < 0:\n            raise ValueError(\"Hypotenuse must be greater than the known leg.\")\n        return missing_leg_squared**0.5\n    \n    def calculate_cylinder_height(radius, hemisphere_radius):\n        \n        height_squared = hemisphere_radius**2 - radius**2\n        if height_squared < 0:\n            raise ValueError(\"The radius must be less than the hemisphere radius.\")\n        return height_squared**0.5\n    \n    # Calculate hypotenuse if both legs are provided\n    if leg_a is not None and leg_b is not None:\n        results['hypotenuse'] = calculate_hypotenuse(leg_a, leg_b)\n    \n    # Calculate missing leg if hypotenuse and one leg are provided\n    if hypotenuse is not None and leg_a is not None:\n        results['missing_leg'] = calculate_missing_leg(hypotenuse, leg_a)\n    \n    # Calculate height of the cylinder inscribed in a hemisphere\n    if radius is not None and hemisphere_radius is not None:\n        results['cylinder_height'] = calculate_cylinder_height(radius, hemisphere_radius)\n    \n    return results", "subfield": "Pythagorean Theorem", "tool_name": "pythagorean_tools", "tool_type": "function", "description": "A toolset for performing calculations related to the Pythagorean theorem and geometric shapes.", "docstring": "A toolset for performing calculations related to the Pythagorean theorem and geometric shapes.\n    \n    Parameters:\n    leg_a (float): Length of one leg of the right triangle.\n    leg_b (float): Length of the other leg of the right triangle.\n    hypotenuse (float): Length of the hypotenuse of the right triangle.\n    radius (float): Radius of the inscribed cylinder.\n    hemisphere_radius (float): Radius of the hemisphere in which the cylinder is inscribed.\n    \n    Returns:\n    dict: A dictionary containing the results of the calculations, which may include:\n        - 'hypotenuse': Length of the hypotenuse if both legs are provided.\n        - 'missing_leg': Length of the missing leg if one leg and the hypotenuse are provided.\n        - 'cylinder_height': Height of the inscribed cylinder if the radius and hemisphere radius are provided.", "Freq": 4, "TSR": 4}, {"tool": "def triangle_tools(leg_a=None, leg_b=None, hypotenuse=None, angle=None, tangent_ratio=None):\n    \n    \n    results = {}\n    def calculate_hypotenuse(leg_a, leg_b):\n        return (leg_a**2 + leg_b**2)**0.5\n    def calculate_missing_leg(hypotenuse, leg_a):\n        missing_leg_squared = hypotenuse**2 - leg_a**2\n        if missing_leg_squared < 0:\n            raise ValueError(\"Hypotenuse must be greater than the known leg.\")\n        return missing_leg_squared**0.5\n    def calculate_tangent_angle(opposite, adjacent):\n        import math\n        return math.degrees(math.atan(opposite / adjacent))\n    def calculate_hypotenuse_from_tangent(tangent_ratio):\n        opposite, adjacent = tangent_ratio\n        return (opposite**2 + adjacent**2)**0.5\n    # Calculate hypotenuse if both legs are provided\n    if leg_a is not None and leg_b is not None:\n        results['hypotenuse'] = calculate_hypotenuse(leg_a, leg_b)\n    \n    # Calculate missing leg if hypotenuse and one leg are provided\n    if hypotenuse is not None and leg_a is not None:\n        results['missing_leg'] = calculate_missing_leg(hypotenuse, leg_a)\n    \n    # Calculate angle if tangent ratio is provided\n    if tangent_ratio is not None:\n        results['angle'] = calculate_tangent_angle(tangent_ratio[0], tangent_ratio[1])\n    \n    # Calculate hypotenuse from tangent ratio\n    if tangent_ratio is not None:\n        results['hypotenuse_from_tangent'] = calculate_hypotenuse_from_tangent(tangent_ratio)\n    return results", "subfield": "Pythagorean Theorem", "tool_name": "triangle_tools", "tool_type": "function", "description": "A toolset for performing calculations related to right triangles, including finding missing sides,\n    calculating angles, and working with tangent ratios.", "docstring": "A toolset for performing calculations related to right triangles, including finding missing sides,\n    calculating angles, and working with tangent ratios.\n    Parameters:\n    leg_a (float): Length of leg A of the triangle.\n    leg_b (float): Length of leg B of the triangle.\n    hypotenuse (float): Length of the hypotenuse of the triangle.\n    angle (float): Angle in degrees for which calculations are to be performed.\n    tangent_ratio (tuple): A tuple containing the opposite and adjacent sides for tangent calculation.\n    Returns:\n    dict: A dictionary containing the results of the calculations.", "Freq": 2, "TSR": 1}], "Reflections": [], "Trapezoids": [], "Angles": [], "Similarity": [], "Parallelograms": [], "Coordinate Systems": [], "Conic Sections": [], "Quadrilaterals": [], "Ellipse": [{"tool": "def ellipse_standard_to_general(h, k, a, b):\n    \n    x, y = sp.symbols('x y')\n    eq = (x - h)**2/a**2 + (y - k)**2/b**2 - 1\n    return sp.simplify(eq)", "subfield": "Ellipse", "tool_name": "ellipse_standard_to_general", "tool_type": "function", "description": "Convert the standard equation of an ellipse to its general form.", "docstring": "Convert the standard equation of an ellipse to its general form.\n    Parameters:\n        h (float): The x-coordinate of the ellipse's center.\n        k (float): The y-coordinate of the ellipse's center.\n        a (float): Length of the semi-major axis.\n        b (float): Length of the semi-minor axis.\n    Returns:\n        sympy expression: The general form of the ellipse equation.\n    Examples:\n        >>> ellipse_standard_to_general(1, 2, 5, 3)\n        Eq(x**2/25 - x*2/5 + y**2/9 - y*4/9 + 5, 0)", "Freq": 0, "TSR": 0}, {"tool": "def ellipse_area(a, b):\n    \n    return math.pi * a * b", "subfield": "Ellipse", "tool_name": "ellipse_area", "tool_type": "function", "description": "Calculate the area of an ellipse given the lengths of its semi-major and semi-minor axes.", "docstring": "Calculate the area of an ellipse given the lengths of its semi-major and semi-minor axes.\n    \n    Parameters:\n    a (float): length of the semi-major axis.\n    b (float): length of the semi-minor axis.\n    Returns:\n    float: Area of the ellipse.\n    Example:\n    >>> ellipse_area(5, 3)\n    47.12388980384689", "Freq": 0, "TSR": 0}, {"tool": "def ellipse_standard_form(coordinates, a, b, angle=0):\n    \n    if angle != 0:\n        return f\"Rotated by {angle} degrees: Standard equation not directly applicable.\"\n    h, k = coordinates\n    equation = f\"(x-{h})^2/{a**2} + (y-{k})^2/{b**2} = 1\"\n    return equation", "subfield": "Ellipse", "tool_name": "ellipse_standard_form", "tool_type": "function", "description": "Represents the equation of an ellipse in its standard form based on provided parameters.", "docstring": "Represents the equation of an ellipse in its standard form based on provided parameters.\n    \n    Parameters:\n    coordinates : tuple\n        The (x, y) coordinates of the center of the ellipse.\n    a : float\n        The length of the semi-major axis.\n    b : float\n        The length of the semi-minor axis.\n    angle : float, optional\n        The rotation angle of the ellipse in degrees (default is 0).\n    Returns:\n    str\n        A string representing the standard form equation of the ellipse.\n    Examples:\n    >>> ellipse_standard_form((0, 0), 5, 3)\n    'x^2/25 + y^2/9 = 1'\n    >>> ellipse_standard_form((0, 0), 5, 3, 45)\n    'Rotated by 45 degrees: Standard equation not directly applicable.'", "Freq": 0, "TSR": 0}]}