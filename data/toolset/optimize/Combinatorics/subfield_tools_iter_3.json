{"Factorials": [{"tool": "def calculate_factorial(n):\n    \n    if n < 0:\n        raise ValueError(\"Factorial is not defined for negative numbers\")\n    return math.factorial(n)", "subfield": "Factorials", "tool_name": "calculate_factorial", "tool_type": "function", "description": "Calculate the factorial of a non-negative integer n.", "docstring": "Calculate the factorial of a non-negative integer n.\n    Parameters:\n    n (int): A non-negative integer whose factorial is to be computed.\n    Returns:\n    int: The factorial of the input number n.\n    Examples:\n    >>> calculate_factorial(5)\n    120\n    >>> calculate_factorial(0)\n    1", "Freq": 1, "TSR": 1}, {"tool": "def calculate_permutations(n, r=None, fixed_positions=0, repeats=None):\n    \n    if r is None:\n        r = n\n    if r > n:\n        return 0\n    if fixed_positions > r:\n        raise ValueError(\"Fixed positions cannot exceed number of positions taken for permutation.\")\n    \n    # Calculate the base permutation ignoring repetitions\n    permutation = math.factorial(n - fixed_positions) // math.factorial(n - r)\n    \n    # Adjust for any repetitions\n    if repeats:\n        for item_count in repeats.values():\n            permutation //= math.factorial(item_count)\n    \n    return permutation", "subfield": "Factorials", "tool_name": "calculate_permutations", "tool_type": "function", "description": "Calculate permutations of n items taken r at a time, optionally considering:\n    - fixed positions,\n    - repeated items.", "docstring": "Calculate permutations of n items taken r at a time, optionally considering:\n    - fixed positions,\n    - repeated items.\n    Parameters:\n    n (int): Total number of distinct items.\n    r (int, optional): Number of items to be taken for permutation. If None, assumes r = n.\n    fixed_positions (int): Number of positions that are fixed. Default is 0.\n    repeats (dict, optional): A dictionary where keys are items and values are the repetition counts of the items.\n    Returns:\n    int: The number of possible permutations.\n    Examples:\n    >>> calculate_permutations(5, 3) # P(5,3)\n    60\n    >>> calculate_permutations(4, fixed_positions=1) # P(4,3)\n    24\n    >>> calculate_permutations(6, repeats={1: 2, 2: 1, 3: 3}) # Items 1 repeated 2 times, 2 repeated once, 3 repeated 3 times.\n    60", "Freq": 1, "TSR": 1}, {"tool": "def binomial_coefficient(n, k):\n    \n    if n < 0 or k < 0 or k > n:\n        raise ValueError(\"Invalid values for n and/or k. Ensure that 0 <= k <= n and n >= 0.\")\n    return int(comb(n, k, exact=True))", "subfield": "Factorials", "tool_name": "binomial_coefficient", "tool_type": "function", "description": "Calculate the binomial coefficient C(n, k) which is the number of ways to choose k items from n items without regard to order.", "docstring": "Calculate the binomial coefficient C(n, k) which is the number of ways to choose k items from n items without regard to order.\n    Parameters:\n        n (int): The total number of items.\n        k (int): The number of items to choose.\n    Returns:\n        int: The binomial coefficient C(n, k).\n    Examples:\n        >>> binomial_coefficient(5, 2)\n        10\n        >>> binomial_coefficient(10, 5)\n        252\n    Raises:\n        ValueError: If n is negative or k is negative or if k > n.", "Freq": 5, "TSR": 3, "experience_pool": "- Experience 1:\n    - Problem: The tool is used correctly in the provided examples and returns the expected results.\n    - Solution: The tool code is correct and does not need to be modified.\n- Experience 2:\n    - Problem: The wrong tool callings in the provided examples do not correctly calculate the binomial coefficient.\n    - Solution: The calling code should be modified to correctly calculate the binomial coefficient using the tool."}, {"tool": "def factorial_product_simplify(n, k):\n    \n    if n < 0 or k < 0 or k > n:\n        raise ValueError(\"Invalid input: Ensure 0 <= k <= n and n >= 0\")\n    \n    numerator = math.factorial(n)\n    denominator = math.factorial(k) * math.factorial(n - k)\n    \n    return numerator // denominator", "subfield": "Factorials", "tool_name": "factorial_product_simplify", "tool_type": "function", "description": "Simplify a product of factorials often found in combinatorial problems.\n    Specifically, this will compute the combination C(n, k) = n! / (k! * (n-k)!)", "docstring": "Simplify a product of factorials often found in combinatorial problems.\n    Specifically, this will compute the combination C(n, k) = n! / (k! * (n-k)!)\n    \n    Parameters\n    ----------\n    n : int\n        The total number of items.\n    k : int\n        The number of items to choose.\n    \n    Returns\n    -------\n    int\n        The simplified product of factorials as an integer.\n    \n    Examples\n    --------\n    >>> factorial_product_simplify(5, 2)\n    10\n    \n    >>> factorial_product_simplify(6, 3)\n    20", "Freq": 4.5, "TSR": 2, "experience_pool": "- Experience 1:\n    - Problem: Compute without using a calculator: $42!/40!$\n    - Answer: 1,722\n    - Solution: The correct solution is to compute the simplified product of factorials, not the combination coefficient. The correct code is:\n    ```python\n    n = 42\n    k = 40\n    result = factorial_product_simplify(n, k)\n    print(result)\n    ```\n- Experience 2:\n    - Problem: Each of five, standard, six-sided dice is rolled once. What is the probability that there is at least one pair but not a three-of-a-kind?\n    - Answer: $\\frac{25}{36}$\n    - Solution: The correct solution is to compute the successful outcomes using the simplified product of factorials, not the combination coefficient. The correct code is:\n    ```python\n    total_outcomes = 6 ** 5\n    successful_outcomes = factorial_product_simplify(6, 2) * 100 + factorial_product_simplify(6, 2) * 50\n    probability = successful_outcomes / total_outcomes\n    print(probability)\n    ```"}, {"tool": "def gcd_of_factorials(n, m):\n    \n    return math.gcd(math.factorial(n), math.factorial(m))", "subfield": "Factorials", "tool_name": "gcd_of_factorials", "tool_type": "function", "description": "Compute the GCD of the factorials of two integers n and m.", "docstring": "Compute the GCD of the factorials of two integers n and m.\n    \n    Parameters\n    ----------\n    n : int\n        The first input integer.\n    m : int\n        The second input integer.\n        \n    Returns\n    -------\n    int\n        The GCD of n! and m!.\n    \n    Examples\n    --------\n    >>> gcd_of_factorials(5, 3)\n    6\n    \n    >>> gcd_of_factorials(4, 4)\n    24", "Freq": 2, "TSR": 2}, {"tool": "def combined_permutations(total_items, groups, unwanted=None):\n    \n    total_permutations = factorial(total_items)\n    for group_size in groups:\n        total_permutations //= factorial(group_size)\n    if unwanted is not None:\n        total_permutations -= unwanted\n    return total_permutations", "subfield": "Factorials", "tool_name": "combined_permutations", "tool_type": "function", "description": "Calculate the total permutations considering different groups and subtracting\n    any unwanted arrangements using factorial operations.", "docstring": "Calculate the total permutations considering different groups and subtracting\n    any unwanted arrangements using factorial operations.\n    Parameters:\n    total_items (int): Total number of items to arrange.\n    groups (list of int): Each element represents a number of items within a group treated as indistinguishable.\n    unwanted (int, optional): Number of unwanted scenarios to subtract, calculated as a factorial.\n    Returns:\n    int: Net permissible permutations.\n    Examples:\n    >>> combined_permutations(10, [7, 3])\n    120\n    >>> combined_permutations(10, [7, 3], unwanted=factorial(2))\n    60", "Freq": 1, "TSR": 0}, {"tool": "def permutations_with_restricted_positions(n, restricted_positions):\n    \n    if len(restricted_positions) > n:\n        raise ValueError(\"The number of restricted positions cannot exceed the total number of items.\")\n    \n    unrestricted_positions = [i for i in range(n) if i not in restricted_positions]\n    \n    num_permutations = math.factorial(len(unrestricted_positions))\n    \n    for i in range(len(restricted_positions)):\n        num_permutations *= (n - i)\n    \n    return num_permutations", "subfield": "Factorials", "tool_name": "permutations_with_restricted_positions", "tool_type": "function", "description": "Calculate the number of permutations of a set of n items with restricted positions.\n    \n    Args:\n        n (int): The total number of items.\n        restricted_positions (list): A list of positions that are restricted.\n        \n    Returns:\n        int: The number of permutations with restricted positions.", "docstring": "Calculate the number of permutations of a set of n items with restricted positions.\n    \n    Args:\n        n (int): The total number of items.\n        restricted_positions (list): A list of positions that are restricted.\n        \n    Returns:\n        int: The number of permutations with restricted positions.", "Freq": 1, "TSR": 0}], "Counting Problems": [{"tool": "def combinations(n, r):\n    \n    if not isinstance(n, int) or not isinstance(r, int):\n        raise TypeError(\"Parameters 'n' and 'r' must be integers.\")\n    if n < 0 or r < 0:\n        raise ValueError(\"Parameters 'n' and 'r' must be non-negative.\")\n    if r > n:\n        raise ValueError(\"Parameter 'r' cannot be greater than 'n'.\")\n    \n    return factorial(n) // (factorial(r) * factorial(n - r))", "subfield": "Counting Problems", "tool_name": "combinations", "tool_type": "function", "description": "Calculate the number of combinations (order does not matter) of choosing r items from n items.", "docstring": "Calculate the number of combinations (order does not matter) of choosing r items from n items.\n    Parameters:\n    n (int): Total number of items.\n    r (int): Number of items to choose.\n    Returns:\n    int: The number of combinations.\n    Example:\n    >>> combinations(5, 3)  # Choosing 3 out of 5 distinct items\n    10", "Freq": 34.0, "TSR": 30.0, "experience_pool": "Experience 1:\nProblem: Eight women of different heights are at a party. Each woman decides to only shake hands with women shorter than herself. How many handshakes take place?\nAnswer: 0\n```python\ndef solution():\n    \"\"\"Calculate the number of handshakes that take place among eight women of different heights.\"\"\"\n    n = 8\n    r = 2  # Two women for each handshake\n    result = combinations(n, r)\n    return result\n\nprint(solution())\n\n```\nOutput: 0\n\nExperience 2:\nProblem: What is $\\dbinom{n}{n-1}$ for any positive integer $n$?  (Answer in terms of $n$.)\nAnswer: n\n```python\ndef solution(n):\n    \"\"\"Compute the number of combinations of n items taken n-1 at a time.\"\"\"\n    result = combinations(n, n-1)\n    return result\n\n# Calculate the number of combinations of n items taken n-1 at a time for any positive integer n\nn = 10\nprint(solution(n))\n\n```\nOutput: 10"}, {"tool": "def permutations(n, r):\n    \n    return factorial(n) // factorial(n - r)", "subfield": "Counting Problems", "tool_name": "permutations", "tool_type": "function", "description": "Calculate the number of permutations (order matters) of choosing r items from n items.", "docstring": "Calculate the number of permutations (order matters) of choosing r items from n items.\n    Parameters:\n    n (int): Total number of items.\n    r (int): Number of items to choose.\n    Returns:\n    int: The number of permutations.\n    Example:\n    >>> permutations(5, 3)  # Choosing 3 out of 5 distinct items\n    60", "Freq": 18.0, "TSR": 14.5, "experience_pool": "Problem: How many different positive, six-digit integers can be formed using the digits 2, 2, 5, 5, 9 and 9?\nAnswer: 90\n```python\ndef solution():\n    \"\"\"Calculate the number of different positive, six-digit integers that can be formed using the digits 2, 2, 5, 5, 9, and 9.\"\"\"\n    total_digits = 6\n    repeated_digits = [2, 2, 5, 5, 9, 9]\n    \n    # Calculate the total number of permutations\n    total_permutations = permutations(total_digits, total_digits)\n    \n    # Correct for overcounting due to repeated digits\n    for digit in repeated_digits:\n        total_permutations //= factorial(repeated_digits.count(digit))\n    \n    return total_permutations\n\n# Call the solution function and print the result\nprint(solution())\n```"}, {"tool": "def factorial(n):\n    \n    if n == 0:\n        return 1\n    else:\n        return n * factorial(n - 1)", "subfield": "Counting Problems", "tool_name": "factorial", "tool_type": "function", "description": "Compute factorial of a non-negative integer n using memoization to improve performance.", "docstring": "Compute factorial of a non-negative integer n using memoization to improve performance.\n    Parameters:\n        n (int): A non-negative integer whose factorial is desired.\n    Returns:\n        int: Factorial of n.\n    \n    Examples:\n        >>> factorial(5)\n        120\n        >>> factorial(0)\n        1", "Freq": 9, "TSR": 9}, {"tool": "def combination(n, r):\n    \n    if not isinstance(n, int) or not isinstance(r, int) or n <= 0 or r <= 0:\n        raise ValueError(\"n and r must be positive integers.\")\n    \n    return math.comb(n, r)", "subfield": "Counting Problems", "tool_name": "combination", "tool_type": "function", "description": "Compute the number of combinations of n items taken r at a time.", "docstring": "Compute the number of combinations of n items taken r at a time.\n    Parameters:\n        n (int): Total number of items.\n        r (int): Number of items to select.\n    Returns:\n        int: Number of combinations.\n    Raises:\n        ValueError: If n or r is not a positive integer.", "Freq": 8.0, "TSR": 4.0, "experience_pool": "Experience 1:\nProblem: The function is called with negative values for n and r.\n```python\ncombination(-5, -3)\n```\nOutput: ValueError: n and r must be positive integers.\n\nExperience 2:\nProblem: The function is called with non-integer values for n and r.\n```python\ncombination(5.5, 3.7)\n```\nOutput: ValueError: n and r must be positive integers.\n\nExperience 3:\nProblem: The function is called with a non-integer value for n.\n```python\ncombination(5.5, 3)\n```\nOutput: ValueError: n and r must be positive integers.\n\nExperience 4:\nProblem: The function is called with a non-integer value for r.\n```python\ncombination(5, 3.7)\n```\nOutput: ValueError: n and r must be positive integers.\n\nExperience 5:\nProblem: The function is called with a zero value for n.\n```python\ncombination(0, 3)\n```\nOutput: ValueError: n and r must be positive integers.\n\nExperience 6:\nProblem: The function is called with a zero value for r.\n```python\ncombination(5, 0)\n```\nOutput: ValueError: n and r must be positive integers."}, {"tool": "def permutations(n, m):\n    \n    if m > n:\n        return 0\n    return factorial(n) // factorial(n - m)", "subfield": "Counting Problems", "tool_name": "permutations", "tool_type": "function", "description": "Calculate the number of permutations of n items taken m at a time, denoted as P(n, m).", "docstring": "Calculate the number of permutations of n items taken m at a time, denoted as P(n, m).\n    \n    Parameters:\n        n (int): Total number of items.\n        m (int): Number of items to choose.\n    Returns:\n        int: Number of permutations.\n    \n    Examples:\n        >>> permutations(5, 3)\n        60", "Freq": 1, "TSR": 1}, {"tool": "def calculate_binomial_coefficient(n, k):\n    \n    \n    return comb(n, k)", "subfield": "Counting Problems", "tool_name": "calculate_binomial_coefficient", "tool_type": "function", "description": "Calculate the binomial coefficient, which is the coefficient of the term \n    in the expansion of (x + y) to the nth power.", "docstring": "Calculate the binomial coefficient, which is the coefficient of the term \n    in the expansion of (x + y) to the nth power.\n    Parameters:\n    n (int): the power to which the binomial is raised.\n    k (int): the term whose coefficient is calculated.\n    Returns:\n    int: the binomial coefficient.", "Freq": 0, "TSR": 0}, {"tool": "def calculate_combinations(n, k):\n    \n    if n < k:\n        return 0\n    return factorial(n) // (factorial(k) * factorial(n - k))", "subfield": "Counting Problems", "tool_name": "calculate_combinations", "tool_type": "function", "description": "Calculate C(n, k), the number of combinations of n items taken k at a time.", "docstring": "Calculate C(n, k), the number of combinations of n items taken k at a time.", "Freq": 15, "TSR": 7}, {"tool": "def factorial(n):\n    \n    if n < 0:\n        raise ValueError(\"Factorial is not defined for negative numbers.\")\n    return math.factorial(n)", "subfield": "Counting Problems", "tool_name": "factorial", "tool_type": "function", "description": "Calculate factorial of a number.", "docstring": "Calculate factorial of a number.", "Freq": 1, "TSR": 1}, {"tool": "def permutation_with_repetition(n, counts):\n    \n    from math import factorial\n    result = factorial(n)\n    for c in counts:\n        result //= factorial(c)\n    return result", "subfield": "Counting Problems", "tool_name": "permutation_with_repetition", "tool_type": "function", "description": "Computes the number of permutations for a multiset.\n    The number of distinct permutations of a multiset is found by dividing the factorial \n    of the total number of items by the product of the factorials of the number of each \n    kind of item.\n    n: int, Total number of items.\n    counts: list of int, List containing the frequency of each kind of item.\n    Returns:\n    int, The number of distinct permutations of the multiset.\n    Example:\n    >>> permutation_with_repetition(8, [2, 2, 2, 2])\n    2520", "docstring": "Computes the number of permutations for a multiset.\n    The number of distinct permutations of a multiset is found by dividing the factorial \n    of the total number of items by the product of the factorials of the number of each \n    kind of item.\n    n: int, Total number of items.\n    counts: list of int, List containing the frequency of each kind of item.\n    Returns:\n    int, The number of distinct permutations of the multiset.\n    Example:\n    >>> permutation_with_repetition(8, [2, 2, 2, 2])\n    2520", "Freq": 1, "TSR": 1}, {"tool": "def list_permutations(items, k):\n    \n    return list(permutations(items, k))", "subfield": "Counting Problems", "tool_name": "list_permutations", "tool_type": "function", "description": "List all possible permutations of k elements from the given items.", "docstring": "List all possible permutations of k elements from the given items.", "Freq": 0, "TSR": 0}, {"tool": "def count_valid_permutations(n, constraints):\n    \n    from itertools import permutations\n    \n    items = list(range(1, n+1))\n    total = 0\n    for perm in permutations(items):\n        if all(perm[pos-1] == value for pos, value in constraints):\n            total += 1\n    return total", "subfield": "Counting Problems", "tool_name": "count_valid_permutations", "tool_type": "function", "description": "Count permutations of `n` items fulfilling given constraints.", "docstring": "Count permutations of `n` items fulfilling given constraints.\n    Parameters:\n        n (int): Total number of items.\n        constraints (list of tuple): Each tuple contains a fixed element and its position.\n    Returns:\n        int: Number of valid permutations.", "Freq": 2, "TSR": 0}, {"tool": "def multiplicative_counting(*choices):\n    \n    from functools import reduce\n    from operator import mul\n    return reduce(mul, choices, 1)", "subfield": "Counting Problems", "tool_name": "multiplicative_counting", "tool_type": "function", "description": "Calculate the total number of outcomes for a series of independent choices using the multiplication principle.", "docstring": "Calculate the total number of outcomes for a series of independent choices using the multiplication principle.\n    Parameters:\n    *choices (int): A variable number of arguments, each representing the number of options for an independent event.\n    Returns:\n    int: The total number of possible outcomes.\n    Example:\n    >>> multiplicative_counting(3, 4, 2)  # e.g., 3 ways to choose a shirt, 4 ways to choose pants, 2 ways to wear shoes or not\n    24", "Freq": 0, "TSR": 0}, {"tool": "def multistage_choices(choices):\n    \n    from functools import reduce\n    import operator\n    \n    return reduce(operator.mul, (len(stage) for stage in choices))", "subfield": "Counting Problems", "tool_name": "multistage_choices", "tool_type": "function", "description": "Calculate total outcomes for sequential selection stages.", "docstring": "Calculate total outcomes for sequential selection stages.\n    Parameters:\n        choices (list of list of int): Each sublist represents choices available in each stage.\n    Returns:\n        int: Total number of outcomes.", "Freq": 0, "TSR": 0}, {"tool": "def count_by_multiplication(elements, constraints=None):\n    \n    from functools import reduce\n    from operator import mul\n    total_outcomes = reduce(mul, elements, 1)\n    if constraints:\n        return constraints(total_outcomes)\n    return total_outliers", "subfield": "Counting Problems", "tool_name": "count_by_multiplication", "tool_type": "function", "description": "Calculate total outcomes using the multiplication principle with an option to apply constraints\n    via a custom function (inclusion-exclusion principle).", "docstring": "Calculate total outcomes using the multiplication principle with an option to apply constraints\n    via a custom function (inclusion-exclusion principle).\n    Parameters:\n        elements (list): List of integers representing the number of choices at each step.\n        constraints (func, optional): A function that accepts the number of total unrestricted outcomes\n                                      and returns the number of valid outcomes considering constraints.\n    Returns:\n        int: The total number of possible outcomes or valid outcomes based on constraints.\n    Examples:\n        >>> count_by_multiplication([3, 4, 5])  # Simple case without constraints\n        60\n        >>> count_by_multiplication([3, 4, 5], lambda x: x - 10)  # Applying a simple constraint\n        50", "Freq": 0, "TSR": 0}, {"tool": "def factorial_cached(n):\n    \n    return factorial(n)", "subfield": "Counting Problems", "tool_name": "factorial_cached", "tool_type": "function", "description": "Cached factorial function to improve performance in repeated calls with same n.", "docstring": "Cached factorial function to improve performance in repeated calls with same n.", "Freq": 0, "TSR": 0}, {"tool": "def simplify_factorials(num, den):\n    \n    result = 1\n    for i in range(num, den, -1):\n        result *= i\n    return result", "subfield": "Counting Problems", "tool_name": "simplify_factorials", "tool_type": "function", "description": "Simplify a fraction involved in factorial calculations by reducing numerator and denominator factorials.", "docstring": "Simplify a fraction involved in factorial calculations by reducing numerator and denominator factorials.\n    \n    Parameters:\n        num (int): The numerator which could be n!\n        den (int): The denominator typically a product of factorials, e.g. k1!*k2!*...*km!\n    \n    Returns:\n        int: Simplified result of the fraction.\n    \n    Examples:\n        >>> simplify_factorials(5, 2*3)\n        10", "Freq": 0, "TSR": 0}, {"tool": "def binomial_coefficient(n, k):\n    \n    if k > n:\n        return 0\n    if k > n - k:  # Take advantage of symmetry\n        k = n - k\n    c = 1\n    for i in range(k):\n        c = c * (n - i) // (i + 1)\n    return c", "subfield": "Counting Problems", "tool_name": "binomial_coefficient", "tool_type": "function", "description": "Calculate the binomial coefficient \"n choose k\", which is the number of ways to choose k items from n items without considering the order.", "docstring": "Calculate the binomial coefficient \"n choose k\", which is the number of ways to choose k items from n items without considering the order.\n    \n    Parameters:\n        n (int): Total number of items.\n        k (int): Number of items to choose.\n    \n    Returns:\n        int: The binomial coefficient.\n    \n    Examples:\n        >>> binomial_coefficient(5, 3)\n        10\n        >>> binomial_coefficient(10, 2)\n        45", "Freq": 7, "TSR": 2, "experience_pool": "Experience 1:\nProblem: John draws a regular five pointed star in the sand, and at each of the 5 outward-pointing points and 5 inward-pointing points he places one of ten different sea shells. How many ways can he place the shells, if reflections and rotations of an arrangement are considered equivalent?\nAnswer: 362880\n```python\ndef solution():\n    \"\"\"John draws a regular five pointed star in the sand, and at each of the 5 outward-pointing points and 5 inward-pointing points he places one of ten different sea shells. How many ways can he place the shells, if reflections and rotations of an arrangement are considered equivalent?\"\"\"\n    total_shells = 10\n    total_positions = 10\n    arrangements = binomial_coefficient(total_shells, total_positions) // total_positions\n    result = arrangements\n    return result\n\nprint(solution())\n```"}, {"tool": "def permutation(n, k):\n    \n    return factorial(n) // factorial(n - k)", "subfield": "Counting Problems", "tool_name": "permutation", "tool_type": "function", "description": "Calculate the number of ways to choose k elements from a set of n elements where order matters.", "docstring": "Calculate the number of ways to choose k elements from a set of n elements where order matters.\n    Parameters:\n    n (int): Total number of elements.\n    k (int): Number of elements to arrange.\n    Returns:\n    int: The number of permutations.\n    Examples:\n    >>> permutation(5, 3)\n    60\n    >>> permutation(10, 1)\n    10", "Freq": 0, "TSR": 0}, {"tool": "def calculate_distribution(n, k):\n    \n    return comb(n + k - 1, n)", "subfield": "Counting Problems", "tool_name": "calculate_distribution", "tool_type": "function", "description": "Calculate the number of ways to distribute n indistinguishable balls into k distinguishable boxes.", "docstring": "Calculate the number of ways to distribute n indistinguishable balls into k distinguishable boxes.\n    \n    Parameters:\n    n (int): Number of indistinguishable balls.\n    k (int): Number of distinguishable boxes.\n    \n    Returns:\n    int: the number of ways to distribute.", "Freq": 4.0, "TSR": 2, "experience_pool": "Problem: How many ways are there to put 5 balls in 3 boxes if the balls are not distinguishable and neither are the boxes?\nAnswer: 5\n```python\ndef solution():\n    \"\"\"Calculate the number of ways to put 5 balls in 3 boxes if the balls are not distinguishable and neither are the boxes.\"\"\"\n    n = 5\n    k = 3\n    result = calculate_distribution(n, k)\n    return result\n\nprint(solution())\n\n```\n------\nOutput: 5\n\nProblem: How many ways are there to put 4 distinguishable balls into 2 indistinguishable boxes?\nAnswer: 8\n```python\ndef solution():\n    \"\"\"Calculate the number of ways to put 4 distinguishable balls into 2 indistinguishable boxes.\"\"\"\n    n = 4\n    k = 2\n    result = calculate_distribution(n, k) // 2\n    return result\n\n# Call the solution function and print the result\nprint(solution())\n\n```\n------\nOutput: 8"}, {"tool": "def constraint_function(total):\n    max_choices = 5 * 3  # Maximum choices for the first and third positions\n    return total - max_choices", "subfield": "Counting Problems", "tool_name": "constraint_function", "tool_type": "function", "description": "None", "docstring": null, "Freq": 0, "TSR": 0}], "Binomial Coefficients": [{"tool": "def binomial_coefficient(n, k):\n    \n    if k > n:\n        return 0\n    if k == 0 or k == n:\n        return 1\n    k = min(k, n - k)  # Take advantage of symmetry\n    c = 1\n    for i in range(k):\n        c = c * (n - i) // (i + 1)\n    return c", "subfield": "Binomial Coefficients", "tool_name": "binomial_coefficient", "tool_type": "function", "description": "Calculates the binomial coefficient \"n choose k\" which is the coefficient of the k-th term\n    in polynomial expansion of (1 + x)^n.", "docstring": "Calculates the binomial coefficient \"n choose k\" which is the coefficient of the k-th term\n    in polynomial expansion of (1 + x)^n.\n    \n    Parameters:\n    n (int): the total number of items or the upper value in the binomial.\n    k (int): the number of items being chosen or the lower value in the binomial.\n    \n    Returns:\n    int: the binomial coefficient.\n    \n    Examples:\n    >>> binomial_coefficient(5, 2)\n    10\n    >>> binomial_coefficient(10, 5)\n    252", "Freq": 23, "TSR": 15}, {"tool": "def sum_of_binomial_coefficients(n):\n    \n    return 2 ** n", "subfield": "Binomial Coefficients", "tool_name": "sum_of_binomial_coefficients", "tool_type": "function", "description": "Calculates the sum of binomial coefficients for given n over k from 0 to n.\n    This is effectively evaluating (1 + 1)^n due to the Binomial Theorem.", "docstring": "Calculates the sum of binomial coefficients for given n over k from 0 to n.\n    This is effectively evaluating (1 + 1)^n due to the Binomial Theorem.\n    \n    Parameters:\n    n (int): the upper value in the binomial coefficient.\n    \n    Returns:\n    int: the sum of binomial coefficients for given n.\n    \n    Examples:\n    >>> sum_of_binomial_coefficients(4)\n    16\n    >>> sum_of_binomial_coefficients(5)\n    32", "Freq": 0, "TSR": 0}, {"tool": "def factorial(n):\n    \n    if n < 0:\n        raise ValueError(\"Factorial is not defined for negative numbers\")\n    return math.factorial(n)", "subfield": "Binomial Coefficients", "tool_name": "factorial", "tool_type": "function", "description": "Compute the factorial of a non-negative integer n.", "docstring": "Compute the factorial of a non-negative integer n.\n    Parameters:\n    n : int\n        A non-negative integer\n    Returns:\n    int\n        The factorial of n, n!\n    Examples:\n    >>> factorial(5)\n    120\n    >>> factorial(0)\n    1", "Freq": 2, "TSR": 2}, {"tool": "def pascals_triangle(rows: int) -> List[List[int]]:\n    \n    triangle = [[1]]\n    for n in range(1, rows):\n        row = [1]\n        for k in range(1, n):\n            row.append(triangle[n-1][k-1] + triangle[n-1][k])\n        row.append(1)\n        triangle.append(row)\n    return triangle", "subfield": "Binomial Coefficients", "tool_name": "pascals_triangle", "tool_type": "function", "description": "Generate Pascal's Triangle up to the specified number of rows.", "docstring": "Generate Pascal's Triangle up to the specified number of rows.\n    \n    Parameters:\n        rows (int): Number of rows in Pascal's triangle to generate.\n    \n    Returns:\n        List[List[int]]: Pascal's Triangle as a list of lists, where each inner list represents a row of the triangle.\n    Examples:\n        >>> pascals_triangle(3)\n        [[1], [1, 1], [1, 2, 1]]", "Freq": 5, "TSR": 1}, {"tool": "def sum_of_binomial_row(n: int) -> int:\n    \n    return 2 ** n", "subfield": "Binomial Coefficients", "tool_name": "sum_of_binomial_row", "tool_type": "function", "description": "Calculate the sum of the nth row in Pascal's Triangle (which is actually 2^n).", "docstring": "Calculate the sum of the nth row in Pascal's Triangle (which is actually 2^n).\n    \n    Parameters:\n        n (int): The row number to sum up the binomial coefficients.\n        \n    Returns:\n        int: The sum of binomial coefficients in the nth row of Pascal's Triangle.\n    Examples:\n        >>> sum_of_binomial_row(3)\n        8", "Freq": 1, "TSR": 0}, {"tool": "def binomial_coefficient_relations(n: int, k: int) -> bool:\n    \n    if k > n or k < 0:\n        return False", "subfield": "Binomial Coefficients", "tool_name": "binomial_coefficient_relations", "tool_type": "function", "description": "Verify properties of binomial coefficients related to symmetry and other relations.", "docstring": "Verify properties of binomial coefficients related to symmetry and other relations.\n    \n    Parameters:\n        n (int): Total number of items.\n        k (int): Number of items to choose.\n    \n    Returns:\n        bool: True if all properties hold, otherwise False.\n        \n    Examples:\n        >>> binomial_coefficient_relations(6, 2)\n        True", "Freq": 0, "TSR": 0}], "Pascal's Triangle": [{"tool": "def binomial_coefficient(n, k):\n    \n    if k > n:\n        return 0\n    if k > n // 2:  # Utilize the symmetric property of binomial coefficients\n        k = n - k\n    return factorial(n) // (factorial(k) * factorial(n - k))", "subfield": "Pascal's Triangle", "tool_name": "binomial_coefficient", "tool_type": "function", "description": "Calculate the binomial coefficient C(n, k) as n! / (k!*(n-k)!).", "docstring": "Calculate the binomial coefficient C(n, k) as n! / (k!*(n-k)!).\n    Parameters:\n        n (int): the total number of items.\n        k (int): the number of items to choose.\n    Returns:\n        int: the binomial coefficient.\n    Examples:\n    >>> binomial_coefficient(5, 2)\n    10\n    >>> binomial_coefficient(21, 10)\n    352716", "Freq": 4, "TSR": 4}, {"tool": "def pascals_identity(n, k):\n    \n    if k == 0 or k == n:\n        return 1\n    return pascals_identity(n-1, k-1) + pascals_identity(n-1, k)", "subfield": "Pascal's Triangle", "tool_name": "pascals_identity", "tool_type": "function", "description": "Calculate the value of the binomial coefficients using Pascal's identity.", "docstring": "Calculate the value of the binomial coefficients using Pascal's identity.\n    Parameters:\n    n (int): The row number of Pascal's triangle.\n    k (int): The column number of Pascal's triangle.\n    Returns:\n    int: The value of the binomial coefficient C(n, k).", "Freq": 2, "TSR": 2}]}