{"Basic Concepts": [{"Iter": 0, "delete": [{"tool": "def calculate_permutations(n, k):\n    \n    return math.perm(n, k)", "subfield": "Basic Concepts", "tool_name": "calculate_permutations", "tool_type": "function", "description": "Calculate the number of ways to arrange k items from n items using permutations.", "docstring": "Calculate the number of ways to arrange k items from n items using permutations.\n    \n    Parameters:\n        n (int): Total number of items.\n        k (int): Number of items to arrange.\n    \n    Returns:\n        int: The number of permutations of k items from n items.\n    \n    Examples:\n        >>> calculate_permutations(10, 2)\n        90\n        >>> calculate_permutations(5, 3)\n        60", "Freq": 0, "TSR": 0}, {"tool": "def permutation(n, r):\n    \n    return factorial(n) / factorial(n - r)", "subfield": "Basic Concepts", "tool_name": "permutation", "tool_type": "function", "description": "This function calculates permutations (arrangements) of r items chosen from n distinct items.", "docstring": "This function calculates permutations (arrangements) of r items chosen from n distinct items.\n    Parameters:\n        n (int): size of the item set\n        r (int): the number of items to choose\n    Returns:\n        int: number of permutations of r items chosen from n items", "Freq": 0, "TSR": 0}, {"tool": "def calculate_probability_geometric_area(favorable_area, total_area):\n    \n    return favorable_area / total_area", "subfield": "Basic Concepts", "tool_name": "calculate_probability_geometric_area", "tool_type": "function", "description": "This function calculates the probability of an event in geometrical context, given the area \n    representing the favorable outcomes and the total area.", "docstring": "This function calculates the probability of an event in geometrical context, given the area \n    representing the favorable outcomes and the total area.\n    Parameters:\n        favorable_area (float): area representing the favorable outcomes\n        total_area (float): total area\n    Returns:\n        float: the probability of favorable event", "Freq": 0, "TSR": 0}], "add": [{"tool": "def probability_of_specific_outcome(total_outcomes, favorable_outcomes):\n    \n    if total_outcomes == 0:\n        raise ValueError(\"Total outcomes cannot be zero.\")\n    return favorable_outcomes / total_outcomes", "subfield": "Basic Concepts", "tool_name": "probability_of_specific_outcome", "tool_type": "function", "description": "Calculate the probability of a specific outcome given the total number of outcomes and the number of favorable outcomes.\n    \n    Args:\n        total_outcomes (int): The total number of possible outcomes.\n        favorable_outcomes (int): The number of favorable outcomes.\n        \n    Returns:\n        float: The probability of the specific outcome.", "docstring": "Calculate the probability of a specific outcome given the total number of outcomes and the number of favorable outcomes.\n    \n    Args:\n        total_outcomes (int): The total number of possible outcomes.\n        favorable_outcomes (int): The number of favorable outcomes.\n        \n    Returns:\n        float: The probability of the specific outcome.", "Freq": 0, "TSR": 0}], "update": []}, {"Iter": 1, "delete": [{"tool": "def probability_intersection(p_a, p_b, p_a_intersection_b):\n    \n    return p_a * p_b * p_a_intersection_b", "subfield": "Basic Concepts", "tool_name": "probability_intersection", "tool_type": "function", "description": "This function calculates the probability of the intersection of two events A and B.", "docstring": "This function calculates the probability of the intersection of two events A and B.\n    Parameters:\n        p_a (float): Probability of event A\n        p_b (float): Probability of event B\n        p_a_intersection_b (float): Probability of both A and B occurring\n    Returns:\n        float: Probability of the intersection of A and B", "Freq": 1, "TSR": 0}, {"tool": "def independent_events_probability(*args):\n    \n    probability = 1\n    for event_probability in args:\n        probability *= event_probability\n    return probability", "subfield": "Basic Concepts", "tool_name": "independent_events_probability", "tool_type": "function", "description": "Calculate the probability of multiple independent events all occurring.", "docstring": "Calculate the probability of multiple independent events all occurring.\n    \n    Parameters\n    ----------\n    *args : list of float\n        A variable number of probabilities representing independent events.\n    \n    Returns\n    -------\n    float\n        The probability of all independent events occurring.\n    \n    Examples\n    --------\n    >>> independent_events_probability(0.5, 0.5)\n    0.25   # Probability of two independent events both with P=0.5", "Freq": 0, "TSR": 0}, {"tool": "def is_prime(num):\n    \n    return isprime(num)", "subfield": "Basic Concepts", "tool_name": "is_prime", "tool_type": "function", "description": "Determine if a number is prime.", "docstring": "Determine if a number is prime.\n    Parameters\n    ----------\n    num : int\n    \n    Returns\n    -------\n    bool\n        True if num is prime, otherwise False.\n    \n    Examples\n    --------\n    >>> is_prime(7)\n    True\n    >>> is_prime(8)\n    False", "Freq": 0, "TSR": 0}], "add": [{"tool": "def probability_of_exclusive_events(*probabilities):\n    \n    return sum(probabilities)", "subfield": "Basic Concepts", "tool_name": "probability_of_exclusive_events", "tool_type": "function", "description": "Calculate the probability of exclusive events occurring.\n    Args:\n        probabilities (float): The probabilities of the events.\n    Returns:\n        float: The probability of the exclusive events.", "docstring": "Calculate the probability of exclusive events occurring.\n    Args:\n        probabilities (float): The probabilities of the events.\n    Returns:\n        float: The probability of the exclusive events.", "Freq": 0, "TSR": 0}], "update": []}, {"Iter": 2, "delete": [{"tool": "def multijective_count(n, r):\n    \n    return comb(r + n - 1, r)", "subfield": "Basic Concepts", "tool_name": "multijective_count", "tool_type": "function", "description": "This function calculates the number of multijective (or multiple) ways to map (or choose) r items \n    from n categories. This is calculated using the stars and bars method in combinatorics, \n    where there are r+ n-1 total slots, and r of them must be 'stars' (representing chosen items).", "docstring": "This function calculates the number of multijective (or multiple) ways to map (or choose) r items \n    from n categories. This is calculated using the stars and bars method in combinatorics, \n    where there are r+ n-1 total slots, and r of them must be 'stars' (representing chosen items). \n    Parameters:\n        n (int): number of distinct categories \n        r (int): number of items to be chosen \n    Returns:\n        int: number of multijective ways", "Freq": 0, "TSR": 0}, {"tool": "def simplify_fraction(a, b, return_sum=False):\n    \n    fraction = Fraction(a, b).limit_denominator()\n    if return_sum:\n        return fraction.numerator + fraction.denominator\n    return fraction", "subfield": "Basic Concepts", "tool_name": "simplify_fraction", "tool_type": "function", "description": "Simplify a fraction given by numerator a and denominator b, and optionally return the sum of the simplified numerator and denominator.", "docstring": "Simplify a fraction given by numerator a and denominator b, and optionally return the sum of the simplified numerator and denominator.\n    \n    Parameters:\n        a (int): Numerator of the fraction.\n        b (int): Denominator of the fraction.\n        return_sum (bool): If True, returns the sum of the simplified numerator and denominator.\n    \n    Returns:\n        Fraction or int: The simplified fraction or its sum depending on return_sum.\n    \n    Examples:\n        >>> simplify_fraction(50, 100)\n        Fraction(1, 2)\n        >>> simplify_fraction(50, 100, return_sum=True)\n        3", "Freq": 0, "TSR": 0}, {"tool": "def conditional_probability(P_A_given_B, P_B):\n    \n    return P_A_given_B * P_B", "subfield": "Basic Concepts", "tool_name": "conditional_probability", "tool_type": "function", "description": "Calculate the probability of A happening given that B has happened using the conditional probability formula.", "docstring": "Calculate the probability of A happening given that B has happened using the conditional probability formula.\n    \n    Parameters:\n        P_A_given_B (float): Probability of A given B.\n        P_B (float): Probability of B occurring.\n    \n    Returns:\n        float: The conditional probability P(A ∩ B).\n    \n    Examples:\n        >>> conditional_probability(0.4, 0.5)\n        0.2\n        >>> conditional_probability(0.9, 0.1)\n        0.09", "Freq": 0, "TSR": 0}], "add": [{"tool": "def probability_of_mutually_exclusive_events(*probabilities):\n    \n    return sum(probabilities)", "subfield": "Basic Concepts", "tool_name": "probability_of_mutually_exclusive_events", "tool_type": "function", "description": "Calculate the probability of mutually exclusive events occurring.\n    Args:\n        probabilities (float): The probabilities of the events.\n    Returns:\n        float: The probability of the mutually exclusive events.", "docstring": "Calculate the probability of mutually exclusive events occurring.\n    Args:\n        probabilities (float): The probabilities of the events.\n    Returns:\n        float: The probability of the mutually exclusive events.", "Freq": 0, "TSR": 0}], "update": []}, {"Iter": 3, "delete": [{"tool": "def multijective_count(n, r):\n    \n    return comb(r + n - 1, r)", "subfield": "Basic Concepts", "tool_name": "multijective_count", "tool_type": "function", "description": "This function calculates the number of multijective (or multiple) ways to map (or choose) r items \n    from n categories. This is calculated using the stars and bars method in combinatorics, \n    where there are r+ n-1 total slots, and r of them must be 'stars' (representing chosen items).", "docstring": "This function calculates the number of multijective (or multiple) ways to map (or choose) r items \n    from n categories. This is calculated using the stars and bars method in combinatorics, \n    where there are r+ n-1 total slots, and r of them must be 'stars' (representing chosen items). \n    Parameters:\n        n (int): number of distinct categories \n        r (int): number of items to be chosen \n    Returns:\n        int: number of multijective ways", "Freq": 0, "TSR": 0}, {"tool": "def simplify_fraction(a, b, return_sum=False):\n    \n    fraction = Fraction(a, b).limit_denominator()\n    if return_sum:\n        return fraction.numerator + fraction.denominator\n    return fraction", "subfield": "Basic Concepts", "tool_name": "simplify_fraction", "tool_type": "function", "description": "Simplify a fraction given by numerator a and denominator b, and optionally return the sum of the simplified numerator and denominator.", "docstring": "Simplify a fraction given by numerator a and denominator b, and optionally return the sum of the simplified numerator and denominator.\n    \n    Parameters:\n        a (int): Numerator of the fraction.\n        b (int): Denominator of the fraction.\n        return_sum (bool): If True, returns the sum of the simplified numerator and denominator.\n    \n    Returns:\n        Fraction or int: The simplified fraction or its sum depending on return_sum.\n    \n    Examples:\n        >>> simplify_fraction(50, 100)\n        Fraction(1, 2)\n        >>> simplify_fraction(50, 100, return_sum=True)\n        3", "Freq": 0, "TSR": 0}, {"tool": "def conditional_probability(P_A_given_B, P_B):\n    \n    return P_A_given_B * P_B", "subfield": "Basic Concepts", "tool_name": "conditional_probability", "tool_type": "function", "description": "Calculate the probability of A happening given that B has happened using the conditional probability formula.", "docstring": "Calculate the probability of A happening given that B has happened using the conditional probability formula.\n    \n    Parameters:\n        P_A_given_B (float): Probability of A given B.\n        P_B (float): Probability of B occurring.\n    \n    Returns:\n        float: The conditional probability P(A ∩ B).\n    \n    Examples:\n        >>> conditional_probability(0.4, 0.5)\n        0.2\n        >>> conditional_probability(0.9, 0.1)\n        0.09", "Freq": 0, "TSR": 0}, {"tool": "def expected_value(outcomes, probabilities):\n    \n    return sum(o * p for o, p in zip(outcomes, probabilities))", "subfield": "Basic Concepts", "tool_name": "expected_value", "tool_type": "function", "description": "Calculate the expected value (mean) of a list of outcomes weighted by their probabilities.", "docstring": "Calculate the expected value (mean) of a list of outcomes weighted by their probabilities.\n    \n    Parameters:\n        outcomes (list of float): List of possible outcomes.\n        probabilities (list of float): List of probabilities associated with each outcome.\n    \n    Returns:\n        float: The expected value of the outcomes.\n    Example:\n        >>> outcomes = [0, 1]\n        >>> probabilities = [0.5, 0.5]\n        >>> expected_value(outcomes, probabilities)\n        0.5", "Freq": 0, "TSR": 0}, {"tool": "def probability_of_exclusive_events(*probabilities):\n    \n    return sum(probabilities)", "subfield": "Basic Concepts", "tool_name": "probability_of_exclusive_events", "tool_type": "function", "description": "Calculate the probability of exclusive events occurring.\n    Args:\n        probabilities (float): The probabilities of the events.\n    Returns:\n        float: The probability of the exclusive events.", "docstring": "Calculate the probability of exclusive events occurring.\n    Args:\n        probabilities (float): The probabilities of the events.\n    Returns:\n        float: The probability of the exclusive events.", "Freq": 0, "TSR": 0}], "add": [{"tool": "def probability_of_exclusive_events(*probabilities):\n    \n    return sum(probabilities)", "subfield": "Basic Concepts", "tool_name": "probability_of_exclusive_events", "tool_type": "function", "description": "Calculate the probability of exclusive events occurring.\n    Args:\n        probabilities (float): The probabilities of the events.\n    Returns:\n        float: The probability of the exclusive events.", "docstring": "Calculate the probability of exclusive events occurring.\n    Args:\n        probabilities (float): The probabilities of the events.\n    Returns:\n        float: The probability of the exclusive events.", "Freq": 0, "TSR": 0}], "update": [[{"tool": "def combinations(n, k):\n    \n    return factorial(n) // (factorial(k) * factorial(n - k))", "subfield": "Basic Concepts", "tool_name": "combinations", "tool_type": "function", "description": "Calculate the number of combinations of `n` items taken `k` at a time.", "docstring": "Calculate the number of combinations of `n` items taken `k` at a time.\n    \n    Parameters\n    ----------\n    n : int\n        Number of items.\n    k : int\n        Number of items to take.\n    \n    Returns\n    -------\n    int\n        Number of combinations.\n    \n    Examples\n    --------\n    >>> combinations(5, 3)\n    10", "Freq": 6, "TSR": 5}, {"tool": "def combinations(n, k):\n    \n    return factorial(n) // (factorial(k) * factorial(n - k))", "subfield": "Basic Concepts", "tool_name": "combinations", "tool_type": "function", "description": "Calculate the number of combinations of `n` items taken `k` at a time.", "docstring": "Calculate the number of combinations of `n` items taken `k` at a time.\n    Parameters\n    ----------\n    n : int\n        Number of items.\n    k : int\n        Number of items to take.\n    Returns\n    -------\n    int\n        Number of combinations.\n    Examples\n    --------\n    >>> combinations(5, 3)\n    10", "Freq": 3.0, "TSR": 2.5, "experience_pool": "The combinations function can be used to calculate the number of combinations of n items taken k at a time.\nTo calculate the probability of an event, divide the number of favorable outcomes by the total number of possible outcomes."}]]}, {"Iter": 4, "delete": [{"tool": "def multijective_count(n, r):\n    \n    return comb(r + n - 1, r)", "subfield": "Basic Concepts", "tool_name": "multijective_count", "tool_type": "function", "description": "This function calculates the number of multijective (or multiple) ways to map (or choose) r items \n    from n categories. This is calculated using the stars and bars method in combinatorics, \n    where there are r+ n-1 total slots, and r of them must be 'stars' (representing chosen items).", "docstring": "This function calculates the number of multijective (or multiple) ways to map (or choose) r items \n    from n categories. This is calculated using the stars and bars method in combinatorics, \n    where there are r+ n-1 total slots, and r of them must be 'stars' (representing chosen items). \n    Parameters:\n        n (int): number of distinct categories \n        r (int): number of items to be chosen \n    Returns:\n        int: number of multijective ways", "Freq": 0, "TSR": 0}, {"tool": "def simplify_fraction(a, b, return_sum=False):\n    \n    fraction = Fraction(a, b).limit_denominator()\n    if return_sum:\n        return fraction.numerator + fraction.denominator\n    return fraction", "subfield": "Basic Concepts", "tool_name": "simplify_fraction", "tool_type": "function", "description": "Simplify a fraction given by numerator a and denominator b, and optionally return the sum of the simplified numerator and denominator.", "docstring": "Simplify a fraction given by numerator a and denominator b, and optionally return the sum of the simplified numerator and denominator.\n    \n    Parameters:\n        a (int): Numerator of the fraction.\n        b (int): Denominator of the fraction.\n        return_sum (bool): If True, returns the sum of the simplified numerator and denominator.\n    \n    Returns:\n        Fraction or int: The simplified fraction or its sum depending on return_sum.\n    \n    Examples:\n        >>> simplify_fraction(50, 100)\n        Fraction(1, 2)\n        >>> simplify_fraction(50, 100, return_sum=True)\n        3", "Freq": 0, "TSR": 0}, {"tool": "def conditional_probability(P_A_given_B, P_B):\n    \n    return P_A_given_B * P_B", "subfield": "Basic Concepts", "tool_name": "conditional_probability", "tool_type": "function", "description": "Calculate the probability of A happening given that B has happened using the conditional probability formula.", "docstring": "Calculate the probability of A happening given that B has happened using the conditional probability formula.\n    \n    Parameters:\n        P_A_given_B (float): Probability of A given B.\n        P_B (float): Probability of B occurring.\n    \n    Returns:\n        float: The conditional probability P(A ∩ B).\n    \n    Examples:\n        >>> conditional_probability(0.4, 0.5)\n        0.2\n        >>> conditional_probability(0.9, 0.1)\n        0.09", "Freq": 0, "TSR": 0}, {"tool": "def expected_value(outcomes, probabilities):\n    \n    return sum(o * p for o, p in zip(outcomes, probabilities))", "subfield": "Basic Concepts", "tool_name": "expected_value", "tool_type": "function", "description": "Calculate the expected value (mean) of a list of outcomes weighted by their probabilities.", "docstring": "Calculate the expected value (mean) of a list of outcomes weighted by their probabilities.\n    \n    Parameters:\n        outcomes (list of float): List of possible outcomes.\n        probabilities (list of float): List of probabilities associated with each outcome.\n    \n    Returns:\n        float: The expected value of the outcomes.\n    Example:\n        >>> outcomes = [0, 1]\n        >>> probabilities = [0.5, 0.5]\n        >>> expected_value(outcomes, probabilities)\n        0.5", "Freq": 0, "TSR": 0}, {"tool": "def probability_of_exclusive_events(*probabilities):\n    \n    return sum(probabilities)", "subfield": "Basic Concepts", "tool_name": "probability_of_exclusive_events", "tool_type": "function", "description": "Calculate the probability of exclusive events occurring.\n    Args:\n        probabilities (float): The probabilities of the events.\n    Returns:\n        float: The probability of the exclusive events.", "docstring": "Calculate the probability of exclusive events occurring.\n    Args:\n        probabilities (float): The probabilities of the events.\n    Returns:\n        float: The probability of the exclusive events.", "Freq": 0, "TSR": 0}], "add": [{"tool": "def probability_of_exclusive_events(*probabilities):\n    \n    return sum(probabilities)", "subfield": "Basic Concepts", "tool_name": "probability_of_exclusive_events", "tool_type": "function", "description": "Calculate the probability of exclusive events occurring.\n    \n    Args:\n        probabilities (float): The probabilities of the events.\n        \n    Returns:\n        float: The probability of the exclusive events.", "docstring": "Calculate the probability of exclusive events occurring.\n    \n    Args:\n        probabilities (float): The probabilities of the events.\n        \n    Returns:\n        float: The probability of the exclusive events.", "Freq": 0, "TSR": 0}], "update": [[{"tool": "def combinations(n, k):\n    \n    return factorial(n) // (factorial(k) * factorial(n - k))", "subfield": "Basic Concepts", "tool_name": "combinations", "tool_type": "function", "description": "Calculate the number of combinations of `n` items taken `k` at a time.", "docstring": "Calculate the number of combinations of `n` items taken `k` at a time.\n    \n    Parameters\n    ----------\n    n : int\n        Number of items.\n    k : int\n        Number of items to take.\n    \n    Returns\n    -------\n    int\n        Number of combinations.\n    \n    Examples\n    --------\n    >>> combinations(5, 3)\n    10", "Freq": 6, "TSR": 5}, {"tool": "def combinations(n, k):\n    \n    return factorial(n) // (factorial(k) * factorial(n - k))", "subfield": "Basic Concepts", "tool_name": "combinations", "tool_type": "function", "description": "Calculate the number of combinations of `n` items taken `k` at a time.", "docstring": "Calculate the number of combinations of `n` items taken `k` at a time.\n    \n    Parameters\n    ----------\n    n : int\n        Number of items.\n    k : int\n        Number of items to take.\n    \n    Returns\n    -------\n    int\n        Number of combinations.\n    \n    Examples\n    --------\n    >>> combinations(5, 3)\n    10", "Freq": 3.0, "TSR": 2.5, "experience_pool": "The combinations function can be used to calculate the number of combinations of `n` items taken `k` at a time. It is important to ensure that the values of `n` and `k` are valid and within the appropriate range. The function returns the number of combinations as an integer.\n\nThe probability function can be used to calculate the probability of selecting `k` items from a set of `n` items. It uses the combinations function to calculate the total number of outcomes and the total possible outcomes. The function returns the probability as a float.\n\nThe solution function calculates the probability that the sum of two numbers is less than their product. It uses the combinations and probability functions to perform the necessary calculations. The function returns the probability as a float."}]]}, {"Iter": 5, "delete": [{"tool": "def multijective_count(n, r):\n    \n    return comb(r + n - 1, r)", "subfield": "Basic Concepts", "tool_name": "multijective_count", "tool_type": "function", "description": "This function calculates the number of multijective (or multiple) ways to map (or choose) r items \n    from n categories. This is calculated using the stars and bars method in combinatorics, \n    where there are r+ n-1 total slots, and r of them must be 'stars' (representing chosen items).", "docstring": "This function calculates the number of multijective (or multiple) ways to map (or choose) r items \n    from n categories. This is calculated using the stars and bars method in combinatorics, \n    where there are r+ n-1 total slots, and r of them must be 'stars' (representing chosen items). \n    Parameters:\n        n (int): number of distinct categories \n        r (int): number of items to be chosen \n    Returns:\n        int: number of multijective ways", "Freq": 0, "TSR": 0}, {"tool": "def simplify_fraction(a, b, return_sum=False):\n    \n    fraction = Fraction(a, b).limit_denominator()\n    if return_sum:\n        return fraction.numerator + fraction.denominator\n    return fraction", "subfield": "Basic Concepts", "tool_name": "simplify_fraction", "tool_type": "function", "description": "Simplify a fraction given by numerator a and denominator b, and optionally return the sum of the simplified numerator and denominator.", "docstring": "Simplify a fraction given by numerator a and denominator b, and optionally return the sum of the simplified numerator and denominator.\n    \n    Parameters:\n        a (int): Numerator of the fraction.\n        b (int): Denominator of the fraction.\n        return_sum (bool): If True, returns the sum of the simplified numerator and denominator.\n    \n    Returns:\n        Fraction or int: The simplified fraction or its sum depending on return_sum.\n    \n    Examples:\n        >>> simplify_fraction(50, 100)\n        Fraction(1, 2)\n        >>> simplify_fraction(50, 100, return_sum=True)\n        3", "Freq": 0, "TSR": 0}, {"tool": "def conditional_probability(P_A_given_B, P_B):\n    \n    return P_A_given_B * P_B", "subfield": "Basic Concepts", "tool_name": "conditional_probability", "tool_type": "function", "description": "Calculate the probability of A happening given that B has happened using the conditional probability formula.", "docstring": "Calculate the probability of A happening given that B has happened using the conditional probability formula.\n    \n    Parameters:\n        P_A_given_B (float): Probability of A given B.\n        P_B (float): Probability of B occurring.\n    \n    Returns:\n        float: The conditional probability P(A ∩ B).\n    \n    Examples:\n        >>> conditional_probability(0.4, 0.5)\n        0.2\n        >>> conditional_probability(0.9, 0.1)\n        0.09", "Freq": 0, "TSR": 0}, {"tool": "def expected_value(outcomes, probabilities):\n    \n    return sum(o * p for o, p in zip(outcomes, probabilities))", "subfield": "Basic Concepts", "tool_name": "expected_value", "tool_type": "function", "description": "Calculate the expected value (mean) of a list of outcomes weighted by their probabilities.", "docstring": "Calculate the expected value (mean) of a list of outcomes weighted by their probabilities.\n    \n    Parameters:\n        outcomes (list of float): List of possible outcomes.\n        probabilities (list of float): List of probabilities associated with each outcome.\n    \n    Returns:\n        float: The expected value of the outcomes.\n    Example:\n        >>> outcomes = [0, 1]\n        >>> probabilities = [0.5, 0.5]\n        >>> expected_value(outcomes, probabilities)\n        0.5", "Freq": 0, "TSR": 0}, {"tool": "def probability_of_exclusive_events(*probabilities):\n    \n    return sum(probabilities)", "subfield": "Basic Concepts", "tool_name": "probability_of_exclusive_events", "tool_type": "function", "description": "Calculate the probability of exclusive events occurring.\n    Args:\n        probabilities (float): The probabilities of the events.\n    Returns:\n        float: The probability of the exclusive events.", "docstring": "Calculate the probability of exclusive events occurring.\n    Args:\n        probabilities (float): The probabilities of the events.\n    Returns:\n        float: The probability of the exclusive events.", "Freq": 0, "TSR": 0}], "add": [{"tool": "def probability_of_exclusive_events(*probabilities):\n    \n    return 1 - sum(probabilities)", "subfield": "Basic Concepts", "tool_name": "probability_of_exclusive_events", "tool_type": "function", "description": "Calculate the probability of exclusive events occurring.\n    \n    Args:\n        probabilities (float): The probabilities of the events.\n        \n    Returns:\n        float: The probability of the exclusive events.", "docstring": "Calculate the probability of exclusive events occurring.\n    \n    Args:\n        probabilities (float): The probabilities of the events.\n        \n    Returns:\n        float: The probability of the exclusive events.", "Freq": 0, "TSR": 0}], "update": []}], "Expected Value": [{"Iter": 0, "delete": [{"tool": "def expected_value_binomial(n, p):\n    \n    return n * p", "subfield": "Expected Value", "tool_name": "expected_value_binomial", "tool_type": "function", "description": "Calculate the expected value of a binomial distribution.", "docstring": "Calculate the expected value of a binomial distribution.\n    Parameters:\n    n (int): The number of trials.\n    p (float): The probability of success on any given trial.\n    Returns:\n    float: The expected value of the binomial distribution, which is n*p.\n    Examples:\n    >>> expected_value_binomial(10, 0.5)\n    5.0\n    >>> expected_value_binomial(20, 0.3)\n    6.0", "Freq": 0, "TSR": 0}, {"tool": "def dice_roll_stats(dice_count, sides=6):\n    \n    from sympy import Rational\n    \n    min_sum = dice_count * 1\n    max_sum = dice_count * sides\n    expected_sum = dice_count * (sides + 1) / 2\n    return {\n        'min_sum': min_sum,\n        'max_sum': max_sum,\n        'expected_sum': Rational(expected_sum).limit_denominator()\n    }", "subfield": "Expected Value", "tool_name": "dice_roll_stats", "tool_type": "function", "description": "Compute the minimum, maximum, and expected sum when rolling a certain number of dice each having a given number of sides.", "docstring": "Compute the minimum, maximum, and expected sum when rolling a certain number of dice each having a given number of sides.\n    Parameters\n    ----------\n    dice_count : int\n        Number of dice to roll.\n    sides : int, optional\n        Number of sides on each die (default is 6 for a standard die).\n    Returns\n    -------\n    dict\n        A dictionary containing 'min_sum', 'max_sum', and 'expected_sum'\n    \n    Example\n    -------\n    >>> dice_roll_stats(dice_count=3, sides=6)\n    {'min_sum': 3, 'max_sum': 18, 'expected_sum': 10.5}", "Freq": 0, "TSR": 0}, {"tool": "def validate_and_normalize_probabilities(probabilities):\n    \n    prob_sum = np.sum(probabilities)\n    if prob_sum == 0:\n        raise ValueError(\"Sum of probabilities should not be zero.\")\n    return probabilities / prob_sum", "subfield": "Expected Value", "tool_name": "validate_and_normalize_probabilities", "tool_type": "function", "description": "Validate and, if necessary, normalize an array of probabilities so they sum to 1.", "docstring": "Validate and, if necessary, normalize an array of probabilities so they sum to 1.\n    Parameters:\n    - probabilities (np.ndarray): An array of raw probability values that might not sum to 1.\n    Returns:\n    - np.ndarray: Normalized probability array.\n    Examples:\n    >>> validate_and_normalize_probabilities(np.array([0.1, 0.2, 0.3]))\n    np.array([0.1667, 0.3333, 0.5])\n    >>> validate_and_normalize_probabilities(np.array([0.5, 0.5]))\n    np.array([0.5, 0.5])", "Freq": 0, "TSR": 0}], "add": [{"tool": "def probability_of_even_dice(total_dice, even_dice):\n    \n    probability_of_even = 1/2  # Probability of a single die showing an even number\n    probability_of_odd = 1 - probability_of_even  # Probability of a single die showing an odd number\n    # Calculate the number of ways the event can occur\n    ways = math.comb(total_dice, even_dice)\n    # Calculate the probability of each way occurring\n    probability = (probability_of_even ** even_dice) * (probability_of_odd ** (total_dice - even_dice))\n    # Calculate the final probability\n    final_probability = ways * probability\n    return final_probability", "subfield": "Expected Value", "tool_name": "probability_of_even_dice", "tool_type": "function", "description": "Calculate the probability of exactly two dice showing an even number.", "docstring": "Calculate the probability of exactly two dice showing an even number.\n    Parameters:\n    total_dice (int): The total number of dice rolled.\n    even_dice (int): The number of dice that show an even number.\n    Returns:\n    float: The probability of exactly two dice showing an even number.", "Freq": 0, "TSR": 0}], "update": [[{"tool": "def expected_value(outcomes, probabilities):\n    \n    if len(outcomes) != len(probabilities):\n        raise ValueError(\"The lists of outcomes and probabilities must have the same length.\")\n    \n    return sum(o * p for o, p in zip(outcomes, probabilities))", "subfield": "Expected Value", "tool_name": "expected_value", "tool_type": "function", "description": "Calculate the expected value given a list of outcomes and their corresponding probabilities.", "docstring": "Calculate the expected value given a list of outcomes and their corresponding probabilities.\n    \n    Parameters:\n    - outcomes (list of float): A list of potential outcomes.\n    - probabilities (list of float): A list of probabilities corresponding to each outcome.\n    \n    Returns:\n    - float: The expected value calculated as the sum of all outcomes multiplied by their probabilities.\n    \n    Examples:\n    >>> expected_value([10, 20, 30], [0.3, 0.4, 0.3])\n    20.0", "Freq": 4, "TSR": 3}, {"tool": "def expected_value(outcomes, probabilities):\n    \n    if len(outcomes) != len(probabilities):\n        raise ValueError(\"The lists of outcomes and probabilities must have the same length.\")\n    return sum(o * p for o, p in zip(outcomes, probabilities))", "subfield": "Expected Value", "tool_name": "expected_value", "tool_type": "function", "description": "Calculate the expected value given a list of outcomes and their corresponding probabilities.", "docstring": "Calculate the expected value given a list of outcomes and their corresponding probabilities.\n    Parameters:\n    - outcomes (list of float): A list of potential outcomes.\n    - probabilities (list of float): A list of probabilities corresponding to each outcome.\n    Returns:\n    - float: The expected value calculated as the sum of all outcomes multiplied by their probabilities.\n    Raises:\n    - ValueError: If the lists of outcomes and probabilities have different lengths.", "Freq": 2.0, "TSR": 1.5, "experience_pool": "The error in the wrong tool calling code is due to the variable 'x' not being defined before it is used. To fix this error, you can modify the wrong tool calling code to directly assign the expected value to the variable 'x'. For example:\n\n```python\noutcomes = [2, 7]\nprobabilities = [x/12, (12-x)/12]\nexpected_val = 3.25\nx = expected_value(outcomes, probabilities)\nresult = x\n```"}]]}, {"Iter": 1, "delete": [{"tool": "def expected_value_binomial(n, p):\n    \n    return n * p", "subfield": "Expected Value", "tool_name": "expected_value_binomial", "tool_type": "function", "description": "Calculate the expected value of a binomial distribution.", "docstring": "Calculate the expected value of a binomial distribution.\n    Parameters:\n    n (int): The number of trials.\n    p (float): The probability of success on any given trial.\n    Returns:\n    float: The expected value of the binomial distribution, which is n*p.\n    Examples:\n    >>> expected_value_binomial(10, 0.5)\n    5.0\n    >>> expected_value_binomial(20, 0.3)\n    6.0", "Freq": 0, "TSR": 0}, {"tool": "def dice_roll_stats(dice_count, sides=6):\n    \n    from sympy import Rational\n    \n    min_sum = dice_count * 1\n    max_sum = dice_count * sides\n    expected_sum = dice_count * (sides + 1) / 2\n    return {\n        'min_sum': min_sum,\n        'max_sum': max_sum,\n        'expected_sum': Rational(expected_sum).limit_denominator()\n    }", "subfield": "Expected Value", "tool_name": "dice_roll_stats", "tool_type": "function", "description": "Compute the minimum, maximum, and expected sum when rolling a certain number of dice each having a given number of sides.", "docstring": "Compute the minimum, maximum, and expected sum when rolling a certain number of dice each having a given number of sides.\n    Parameters\n    ----------\n    dice_count : int\n        Number of dice to roll.\n    sides : int, optional\n        Number of sides on each die (default is 6 for a standard die).\n    Returns\n    -------\n    dict\n        A dictionary containing 'min_sum', 'max_sum', and 'expected_sum'\n    \n    Example\n    -------\n    >>> dice_roll_stats(dice_count=3, sides=6)\n    {'min_sum': 3, 'max_sum': 18, 'expected_sum': 10.5}", "Freq": 0, "TSR": 0}], "add": [{"tool": "def probability_of_even_dice(total_dice, even_dice):\n    \n    probability_of_even = 1/2  # Probability of a single die showing an even number\n    probability_of_odd = 1 - probability_of_even  # Probability of a single die showing an odd number\n    # Calculate the number of ways the event can occur\n    ways = math.comb(total_dice, even_dice)\n    # Calculate the probability of each way occurring\n    probability = (probability_of_even ** even_dice) * (probability_of_odd ** (total_dice - even_dice))\n    # Calculate the final probability\n    final_probability = ways * probability\n    return final_probability", "subfield": "Expected Value", "tool_name": "probability_of_even_dice", "tool_type": "function", "description": "Calculate the probability of exactly two dice showing an even number.", "docstring": "Calculate the probability of exactly two dice showing an even number.\n    Parameters:\n    total_dice (int): The total number of dice rolled.\n    even_dice (int): The number of dice that should show an even number.\n    Returns:\n    float: The probability of exactly two dice showing an even number.", "Freq": 0, "TSR": 0}], "update": [[{"tool": "def expected_value(outcomes, probabilities):\n    \n    if len(outcomes) != len(probabilities):\n        raise ValueError(\"The lists of outcomes and probabilities must have the same length.\")\n    \n    return sum(o * p for o, p in zip(outcomes, probabilities))", "subfield": "Expected Value", "tool_name": "expected_value", "tool_type": "function", "description": "Calculate the expected value given a list of outcomes and their corresponding probabilities.", "docstring": "Calculate the expected value given a list of outcomes and their corresponding probabilities.\n    \n    Parameters:\n    - outcomes (list of float): A list of potential outcomes.\n    - probabilities (list of float): A list of probabilities corresponding to each outcome.\n    \n    Returns:\n    - float: The expected value calculated as the sum of all outcomes multiplied by their probabilities.\n    \n    Examples:\n    >>> expected_value([10, 20, 30], [0.3, 0.4, 0.3])\n    20.0", "Freq": 4, "TSR": 3}, {"tool": "def expected_value(outcomes, probabilities):\n    \n    if len(outcomes) != len(probabilities):\n        raise ValueError(\"The lists of outcomes and probabilities must have the same length.\")\n    return sum(o * p for o, p in zip(outcomes, probabilities))", "subfield": "Expected Value", "tool_name": "expected_value", "tool_type": "function", "description": "Calculate the expected value given a list of outcomes and their corresponding probabilities.", "docstring": "Calculate the expected value given a list of outcomes and their corresponding probabilities.\n    Parameters:\n    - outcomes (list of float): A list of potential outcomes.\n    - probabilities (list of float): A list of probabilities corresponding to each outcome.\n    Returns:\n    - float: The expected value calculated as the sum of all outcomes multiplied by their probabilities.", "Freq": 2.0, "TSR": 1.5, "experience_pool": "The variable 'x' in the wrong tool calling code was not defined before it was used. To fix this error, 'x' can be defined as the expected value calculated using the 'expected_value' function."}]]}, {"Iter": 2, "delete": [{"tool": "def min_trials_for_repeat(total_outcomes):\n    \n    return total_outcomes + 1", "subfield": "Expected Value", "tool_name": "min_trials_for_repeat", "tool_type": "function", "description": "Calculate the minimum number of trials needed to ensure at least one repetition\n    according to the Pigeonhole Principle.", "docstring": "Calculate the minimum number of trials needed to ensure at least one repetition\n    according to the Pigeonhole Principle.\n    Parameters:\n    - total_outcomes (int): The total number of unique possible outcomes.\n    Returns:\n    - int: The minimum number of trials to ensure at least one repeat.\n    Example:\n    >>> min_trials_for_repeat(365)\n    366", "Freq": 1, "TSR": 1}, {"tool": "def dice_roll_stats(dice_count, sides=6):\n    \n    from sympy import Rational\n    \n    min_sum = dice_count * 1\n    max_sum = dice_count * sides\n    expected_sum = dice_count * (sides + 1) / 2\n    return {\n        'min_sum': min_sum,\n        'max_sum': max_sum,\n        'expected_sum': Rational(expected_sum).limit_denominator()\n    }", "subfield": "Expected Value", "tool_name": "dice_roll_stats", "tool_type": "function", "description": "Compute the minimum, maximum, and expected sum when rolling a certain number of dice each having a given number of sides.", "docstring": "Compute the minimum, maximum, and expected sum when rolling a certain number of dice each having a given number of sides.\n    Parameters\n    ----------\n    dice_count : int\n        Number of dice to roll.\n    sides : int, optional\n        Number of sides on each die (default is 6 for a standard die).\n    Returns\n    -------\n    dict\n        A dictionary containing 'min_sum', 'max_sum', and 'expected_sum'\n    \n    Example\n    -------\n    >>> dice_roll_stats(dice_count=3, sides=6)\n    {'min_sum': 3, 'max_sum': 18, 'expected_sum': 10.5}", "Freq": 0, "TSR": 0}, {"tool": "def validate_and_normalize_probabilities(probabilities):\n    \n    prob_sum = np.sum(probabilities)\n    if prob_sum == 0:\n        raise ValueError(\"Sum of probabilities should not be zero.\")\n    return probabilities / prob_sum", "subfield": "Expected Value", "tool_name": "validate_and_normalize_probabilities", "tool_type": "function", "description": "Validate and, if necessary, normalize an array of probabilities so they sum to 1.", "docstring": "Validate and, if necessary, normalize an array of probabilities so they sum to 1.\n    Parameters:\n    - probabilities (np.ndarray): An array of raw probability values that might not sum to 1.\n    Returns:\n    - np.ndarray: Normalized probability array.\n    Examples:\n    >>> validate_and_normalize_probabilities(np.array([0.1, 0.2, 0.3]))\n    np.array([0.1667, 0.3333, 0.5])\n    >>> validate_and_normalize_probabilities(np.array([0.5, 0.5]))\n    np.array([0.5, 0.5])", "Freq": 0, "TSR": 0}, {"tool": "def expected_value_combinatorial(n, k, success_probability):\n    \n    return n * success_probability", "subfield": "Expected Value", "tool_name": "expected_value_combinatorial", "tool_type": "function", "description": "Calculate the expected value for combinatorial probability problems, like Bernoulli trials.", "docstring": "Calculate the expected value for combinatorial probability problems, like Bernoulli trials.\n    Parameters:\n    n (int): Total number of trials or elements.\n    k (int): Number of successful trials.\n    success_probability (float): The probability of success in each trial.\n    Returns:\n    float: Expected value calculated as `E[X] = n * p` where `p` is the success probability.\n    Examples:\n    >>> expected_value_combinatorial(10, 3, 0.5)\n    5.0", "Freq": 0, "TSR": 0}], "add": [{"tool": "def probability_of_same_color(total_marbles, colors):\n    \n    # Calculate the total number of ways the event can occur\n    ways = sum(math.comb(count, 3) for count in colors.values())\n    \n    # Calculate the total number of ways to draw 3 marbles from the bag\n    total_ways = math.comb(total_marbles, 3)\n    \n    # Calculate the probability of each way occurring\n    probability = ways / total_ways\n    \n    return probability", "subfield": "Expected Value", "tool_name": "probability_of_same_color", "tool_type": "function", "description": "Calculate the probability of drawing marbles of the same color from a bag.\n    \n    Args:\n    - total_marbles: Total number of marbles in the bag.\n    - colors: Dictionary containing the count of marbles for each color.\n    \n    Returns:\n    - The probability of drawing marbles of the same color.", "docstring": "Calculate the probability of drawing marbles of the same color from a bag.\n    \n    Args:\n    - total_marbles: Total number of marbles in the bag.\n    - colors: Dictionary containing the count of marbles for each color.\n    \n    Returns:\n    - The probability of drawing marbles of the same color.", "Freq": 0, "TSR": 0}], "update": [[{"tool": "def expected_value(outcomes, probabilities):\n    \n    if len(outcomes) != len(probabilities):\n        raise ValueError(\"The lists of outcomes and probabilities must have the same length.\")\n    \n    return sum(o * p for o, p in zip(outcomes, probabilities))", "subfield": "Expected Value", "tool_name": "expected_value", "tool_type": "function", "description": "Calculate the expected value given a list of outcomes and their corresponding probabilities.", "docstring": "Calculate the expected value given a list of outcomes and their corresponding probabilities.\n    \n    Parameters:\n    - outcomes (list of float): A list of potential outcomes.\n    - probabilities (list of float): A list of probabilities corresponding to each outcome.\n    \n    Returns:\n    - float: The expected value calculated as the sum of all outcomes multiplied by their probabilities.\n    \n    Examples:\n    >>> expected_value([10, 20, 30], [0.3, 0.4, 0.3])\n    20.0", "Freq": 4, "TSR": 3}, {"tool": "def expected_value(outcomes, probabilities):\n    \n    if len(outcomes) != len(probabilities):\n        raise ValueError(\"The lists of outcomes and probabilities must have the same length.\")\n    return sum(o * p for o, p in zip(outcomes, probabilities))", "subfield": "Expected Value", "tool_name": "expected_value", "tool_type": "function", "description": "Calculate the expected value given a list of outcomes and their corresponding probabilities.", "docstring": "Calculate the expected value given a list of outcomes and their corresponding probabilities.\n    Parameters:\n    - outcomes (list of float): A list of potential outcomes.\n    - probabilities (list of float): A list of probabilities corresponding to each outcome.\n    Returns:\n    - float: The expected value calculated as the sum of all outcomes multiplied by their probabilities.", "Freq": 2.0, "TSR": 1.5, "experience_pool": "The error in the wrong tool calling code is due to the incorrect usage of the `expected_value` function. The variable `x` is referenced before it is assigned a value, causing the `UnboundLocalError`. To fix this, we can directly assign the expected value to `x` without calling the `expected_value` function."}]]}, {"Iter": 3, "delete": [{"tool": "def expected_value_binomial(n, p):\n    \n    return n * p", "subfield": "Expected Value", "tool_name": "expected_value_binomial", "tool_type": "function", "description": "Calculate the expected value of a binomial distribution.", "docstring": "Calculate the expected value of a binomial distribution.\n    Parameters:\n    n (int): The number of trials.\n    p (float): The probability of success on any given trial.\n    Returns:\n    float: The expected value of the binomial distribution, which is n*p.\n    Examples:\n    >>> expected_value_binomial(10, 0.5)\n    5.0\n    >>> expected_value_binomial(20, 0.3)\n    6.0", "Freq": 0, "TSR": 0}, {"tool": "def dice_roll_stats(dice_count, sides=6):\n    \n    from sympy import Rational\n    \n    min_sum = dice_count * 1\n    max_sum = dice_count * sides\n    expected_sum = dice_count * (sides + 1) / 2\n    return {\n        'min_sum': min_sum,\n        'max_sum': max_sum,\n        'expected_sum': Rational(expected_sum).limit_denominator()\n    }", "subfield": "Expected Value", "tool_name": "dice_roll_stats", "tool_type": "function", "description": "Compute the minimum, maximum, and expected sum when rolling a certain number of dice each having a given number of sides.", "docstring": "Compute the minimum, maximum, and expected sum when rolling a certain number of dice each having a given number of sides.\n    Parameters\n    ----------\n    dice_count : int\n        Number of dice to roll.\n    sides : int, optional\n        Number of sides on each die (default is 6 for a standard die).\n    Returns\n    -------\n    dict\n        A dictionary containing 'min_sum', 'max_sum', and 'expected_sum'\n    \n    Example\n    -------\n    >>> dice_roll_stats(dice_count=3, sides=6)\n    {'min_sum': 3, 'max_sum': 18, 'expected_sum': 10.5}", "Freq": 0, "TSR": 0}, {"tool": "def validate_and_normalize_probabilities(probabilities):\n    \n    prob_sum = np.sum(probabilities)\n    if prob_sum == 0:\n        raise ValueError(\"Sum of probabilities should not be zero.\")\n    return probabilities / prob_sum", "subfield": "Expected Value", "tool_name": "validate_and_normalize_probabilities", "tool_type": "function", "description": "Validate and, if necessary, normalize an array of probabilities so they sum to 1.", "docstring": "Validate and, if necessary, normalize an array of probabilities so they sum to 1.\n    Parameters:\n    - probabilities (np.ndarray): An array of raw probability values that might not sum to 1.\n    Returns:\n    - np.ndarray: Normalized probability array.\n    Examples:\n    >>> validate_and_normalize_probabilities(np.array([0.1, 0.2, 0.3]))\n    np.array([0.1667, 0.3333, 0.5])\n    >>> validate_and_normalize_probabilities(np.array([0.5, 0.5]))\n    np.array([0.5, 0.5])", "Freq": 0, "TSR": 0}, {"tool": "def expected_value_combinatorial(n, k, success_probability):\n    \n    return n * success_probability", "subfield": "Expected Value", "tool_name": "expected_value_combinatorial", "tool_type": "function", "description": "Calculate the expected value for combinatorial probability problems, like Bernoulli trials.", "docstring": "Calculate the expected value for combinatorial probability problems, like Bernoulli trials.\n    Parameters:\n    n (int): Total number of trials or elements.\n    k (int): Number of successful trials.\n    success_probability (float): The probability of success in each trial.\n    Returns:\n    float: Expected value calculated as `E[X] = n * p` where `p` is the success probability.\n    Examples:\n    >>> expected_value_combinatorial(10, 3, 0.5)\n    5.0", "Freq": 0, "TSR": 0}, {"tool": "def expected_value_from_pmf(pmf):\n    \n    return sum(outcome * probability for outcome, probability in pmf.items())", "subfield": "Expected Value", "tool_name": "expected_value_from_pmf", "tool_type": "function", "description": "Calculate the expected value from a probability mass function.", "docstring": "Calculate the expected value from a probability mass function.\n    Parameters:\n    pmf (dict): A dictionary where keys are outcomes and values are the probabilities of these outcomes.\n    Returns:\n    float: The expected value calculated as the sum of all outcomes weighted by their probabilities.\n    Examples:\n    >>> pmf = {0: 0.5, 1: 0.3, 2: 0.2}\n    >>> expected_value_from_pmf(pmf)\n    0.7", "Freq": 2, "TSR": 2}], "add": [{"tool": "def calculate_probability(event_occurrences, total_outcomes):\n    \n    probability = event_occurrences / total_outcomes\n    return probability", "subfield": "Expected Value", "tool_name": "calculate_probability", "tool_type": "function", "description": "Calculate the probability of specific events occurring in a given scenario.\n    Args:\n    - event_occurrences: Number of times the event occurs.\n    - total_outcomes: Total number of possible outcomes.\n    Returns:\n    - The probability of the event occurring.", "docstring": "Calculate the probability of specific events occurring in a given scenario.\n    Args:\n    - event_occurrences: Number of times the event occurs.\n    - total_outcomes: Total number of possible outcomes.\n    Returns:\n    - The probability of the event occurring.", "Freq": 0, "TSR": 0}], "update": [[{"tool": "def expected_value(outcomes, probabilities):\n    \n    if len(outcomes) != len(probabilities):\n        raise ValueError(\"The lists of outcomes and probabilities must have the same length.\")\n    \n    return sum(o * p for o, p in zip(outcomes, probabilities))", "subfield": "Expected Value", "tool_name": "expected_value", "tool_type": "function", "description": "Calculate the expected value given a list of outcomes and their corresponding probabilities.", "docstring": "Calculate the expected value given a list of outcomes and their corresponding probabilities.\n    \n    Parameters:\n    - outcomes (list of float): A list of potential outcomes.\n    - probabilities (list of float): A list of probabilities corresponding to each outcome.\n    \n    Returns:\n    - float: The expected value calculated as the sum of all outcomes multiplied by their probabilities.\n    \n    Examples:\n    >>> expected_value([10, 20, 30], [0.3, 0.4, 0.3])\n    20.0", "Freq": 4, "TSR": 3}, {"tool": "def expected_value(outcomes, probabilities):\n    if len(outcomes) != len(probabilities):\n        raise ValueError(\"The lists of outcomes and probabilities must have the same length.\")\n    \n    if sum(probabilities) != 1:\n        raise ValueError(\"The probabilities must sum up to 1.\")\n    \n    return sum(o * p for o, p in zip(outcomes, probabilities))", "subfield": "Expected Value", "tool_name": "expected_value", "tool_type": "function", "description": "None", "docstring": null, "Freq": 2.0, "TSR": 1.5, "experience_pool": "The tool code has been updated to include input validation for the probabilities. The probabilities must sum up to 1, and if they don't, a ValueError is raised. This validation can help prevent potential errors and ensure accurate calculations."}]]}]}