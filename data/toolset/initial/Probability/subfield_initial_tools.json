{"Basic Concepts": ["def calculate_probability(favorable_outcomes, total_outcomes):\n    \"\"\"\n    Calculate the probability of an event given the number of favorable and total outcomes.\n    \n    Parameters:\n        favorable_outcomes (int): The number of favorable outcomes for the event.\n        total_outcomes (int): The total number of possible outcomes.\n    \n    Returns:\n        float: The probability of the event.\n    \n    Examples:\n        >>> calculate_probability(20, 100)\n        0.2\n        >>> calculate_probability(5, 50)\n        0.1\n    \"\"\"\n    if total_outcomes == 0:\n        raise ValueError(\"Total outcomes cannot be zero.\")\n    return favorable_outcomes / total_outcomes", "def calculate_permutations(n, k):\n    \"\"\"\n    Calculate the number of ways to arrange k items from n items using permutations.\n    \n    Parameters:\n        n (int): Total number of items.\n        k (int): Number of items to arrange.\n    \n    Returns:\n        int: The number of permutations of k items from n items.\n    \n    Examples:\n        >>> calculate_permutations(10, 2)\n        90\n        >>> calculate_permutations(5, 3)\n        60\n    \"\"\"\n    return math.perm(n, k)", "def combinations(n, k):\n    \"\"\"Calculate the number of combinations of `n` items taken `k` at a time.\n    \n    Parameters\n    ----------\n    n : int\n        Number of items.\n    k : int\n        Number of items to take.\n    \n    Returns\n    -------\n    int\n        Number of combinations.\n    \n    Examples\n    --------\n    >>> combinations(5, 3)\n    10\n    \"\"\"\n    return factorial(n) // (factorial(k) * factorial(n - k))", "def permutation(n, r):\n    \"\"\"\n    This function calculates permutations (arrangements) of r items chosen from n distinct items.\n    Parameters:\n        n (int): size of the item set\n        r (int): the number of items to choose\n    Returns:\n        int: number of permutations of r items chosen from n items\n    \"\"\"\n    return factorial(n) / factorial(n - r)", "def calculate_probability_geometric_area(favorable_area, total_area):\n    \"\"\"\n    This function calculates the probability of an event in geometrical context, given the area \n    representing the favorable outcomes and the total area.\n    Parameters:\n        favorable_area (float): area representing the favorable outcomes\n        total_area (float): total area\n    Returns:\n        float: the probability of favorable event \n    \"\"\"\n    return favorable_area / total_area", "def binomial_coefficient(n, k):\n    \"\"\"\n    Calculate the binomial coefficient (n choose k), which is the number of ways to choose k elements from a set of n elements.\n    \n    Parameters:\n        n (int): total number of items.\n        k (int): number of items to choose.\n    \n    Returns:\n        int: The binomial coefficient C(n, k).\n    Example:\n        >>> binomial_coefficient(5, 3)\n        10\n    \"\"\"\n    if k > n:\n        return 0\n    if k == 0 or k == n:\n        return 1\n    k = min(k, n - k)  # Take advantage of symmetry\n    c = 1\n    for i in range(k):\n        c = c * (n - i) // (i + 1)\n    return c", "def probability_intersection(p_a, p_b, p_a_intersection_b):\n    \"\"\"\n    This function calculates the probability of the intersection of two events A and B.\n    Parameters:\n        p_a (float): Probability of event A\n        p_b (float): Probability of event B\n        p_a_intersection_b (float): Probability of both A and B occurring\n    Returns:\n        float: Probability of the intersection of A and B\n    \"\"\"\n    return p_a * p_b * p_a_intersection_b", "def probability_of_independent_events(*probabilities):\n    \"\"\"\n    Calculate the probability of multiple independent events occurring together.\n    \n    Parameters:\n        probabilities (list of float): A list of probabilities of each independent event.\n    \n    Returns:\n        float: The total probability of all events occurring together.\n    \n    Examples:\n        >>> probability_of_independent_events(0.5, 0.5, 0.5)  # Probability of flipping three heads in a row\n        0.125\n        >>> probability_of_independent_events(0.3, 0.7)  # Probability of two independent events\n        0.21\n    \"\"\"\n    from functools import reduce\n    import operator\n    return reduce(operator.mul, probabilities, 1)", "def complement_probability(event_probability):\n    \"\"\"\n    Calculate the probability of the complement of an event.\n    \n    Parameters:\n        event_probability (float): Probability of the event for which to find the complement.\n    \n    Returns:\n        float: Probability of the complement of the event.\n    Example:\n        >>> complement_probability(0.3)\n        0.7\n    \"\"\"\n    return 1 - event_probability", "def independent_events_probability(*args):\n    \"\"\"Calculate the probability of multiple independent events all occurring.\n    \n    Parameters\n    ----------\n    *args : list of float\n        A variable number of probabilities representing independent events.\n    \n    Returns\n    -------\n    float\n        The probability of all independent events occurring.\n    \n    Examples\n    --------\n    >>> independent_events_probability(0.5, 0.5)\n    0.25   # Probability of two independent events both with P=0.5\n    \"\"\"\n    probability = 1\n    for event_probability in args:\n        probability *= event_probability\n    return probability", "def is_prime(num):\n    \"\"\"\n    Determine if a number is prime.\n    Parameters\n    ----------\n    num : int\n    \n    Returns\n    -------\n    bool\n        True if num is prime, otherwise False.\n    \n    Examples\n    --------\n    >>> is_prime(7)\n    True\n    >>> is_prime(8)\n    False\n    \"\"\"\n    return isprime(num)", "def multijective_count(n, r):\n    \"\"\"\n    This function calculates the number of multijective (or multiple) ways to map (or choose) r items \n    from n categories. This is calculated using the stars and bars method in combinatorics, \n    where there are r+ n-1 total slots, and r of them must be 'stars' (representing chosen items). \n    Parameters:\n        n (int): number of distinct categories \n        r (int): number of items to be chosen \n    Returns:\n        int: number of multijective ways\n    \"\"\"\n    return comb(r + n - 1, r)", "def simplify_fraction(a, b, return_sum=False):\n    \"\"\"\n    Simplify a fraction given by numerator a and denominator b, and optionally return the sum of the simplified numerator and denominator.\n    \n    Parameters:\n        a (int): Numerator of the fraction.\n        b (int): Denominator of the fraction.\n        return_sum (bool): If True, returns the sum of the simplified numerator and denominator.\n    \n    Returns:\n        Fraction or int: The simplified fraction or its sum depending on return_sum.\n    \n    Examples:\n        >>> simplify_fraction(50, 100)\n        Fraction(1, 2)\n        >>> simplify_fraction(50, 100, return_sum=True)\n        3\n    \"\"\"\n    fraction = Fraction(a, b).limit_denominator()\n    if return_sum:\n        return fraction.numerator + fraction.denominator\n    return fraction", "def conditional_probability(P_A_given_B, P_B):\n    \"\"\"\n    Calculate the probability of A happening given that B has happened using the conditional probability formula.\n    \n    Parameters:\n        P_A_given_B (float): Probability of A given B.\n        P_B (float): Probability of B occurring.\n    \n    Returns:\n        float: The conditional probability P(A âˆ© B).\n    \n    Examples:\n        >>> conditional_probability(0.4, 0.5)\n        0.2\n        >>> conditional_probability(0.9, 0.1)\n        0.09\n    \"\"\"\n    return P_A_given_B * P_B", "def expected_value(outcomes, probabilities):\n    \"\"\"\n    Calculate the expected value (mean) of a list of outcomes weighted by their probabilities.\n    \n    Parameters:\n        outcomes (list of float): List of possible outcomes.\n        probabilities (list of float): List of probabilities associated with each outcome.\n    \n    Returns:\n        float: The expected value of the outcomes.\n    Example:\n        >>> outcomes = [0, 1]\n        >>> probabilities = [0.5, 0.5]\n        >>> expected_value(outcomes, probabilities)\n        0.5\n    \"\"\"\n    return sum(o * p for o, p in zip(outcomes, probabilities))"], "Expected Value": ["def expected_value(outcomes, probabilities):\n    \"\"\"\n    Calculate the expected value given a list of outcomes and their corresponding probabilities.\n    \n    Parameters:\n    - outcomes (list of float): A list of potential outcomes.\n    - probabilities (list of float): A list of probabilities corresponding to each outcome.\n    \n    Returns:\n    - float: The expected value calculated as the sum of all outcomes multiplied by their probabilities.\n    \n    Examples:\n    >>> expected_value([10, 20, 30], [0.3, 0.4, 0.3])\n    20.0\n    \"\"\"\n    if len(outcomes) != len(probabilities):\n        raise ValueError(\"The lists of outcomes and probabilities must have the same length.\")\n    \n    return sum(o * p for o, p in zip(outcomes, probabilities))", "def min_trials_for_repeat(total_outcomes):\n    \"\"\"\n    Calculate the minimum number of trials needed to ensure at least one repetition\n    according to the Pigeonhole Principle.\n    Parameters:\n    - total_outcomes (int): The total number of unique possible outcomes.\n    Returns:\n    - int: The minimum number of trials to ensure at least one repeat.\n    Example:\n    >>> min_trials_for_repeat(365)\n    366\n    \"\"\"\n    return total_outcomes + 1", "def expected_value_binomial(n, p):\n    \"\"\"\n    Calculate the expected value of a binomial distribution.\n    Parameters:\n    n (int): The number of trials.\n    p (float): The probability of success on any given trial.\n    Returns:\n    float: The expected value of the binomial distribution, which is n*p.\n    Examples:\n    >>> expected_value_binomial(10, 0.5)\n    5.0\n    >>> expected_value_binomial(20, 0.3)\n    6.0\n    \"\"\"\n    return n * p", "def dice_roll_stats(dice_count, sides=6):\n    \"\"\"\n    Compute the minimum, maximum, and expected sum when rolling a certain number of dice each having a given number of sides.\n    Parameters\n    ----------\n    dice_count : int\n        Number of dice to roll.\n    sides : int, optional\n        Number of sides on each die (default is 6 for a standard die).\n    Returns\n    -------\n    dict\n        A dictionary containing 'min_sum', 'max_sum', and 'expected_sum'\n    \n    Example\n    -------\n    >>> dice_roll_stats(dice_count=3, sides=6)\n    {'min_sum': 3, 'max_sum': 18, 'expected_sum': 10.5}\n    \"\"\"\n    from sympy import Rational\n    \n    min_sum = dice_count * 1\n    max_sum = dice_count * sides\n    expected_sum = dice_count * (sides + 1) / 2\n    return {\n        'min_sum': min_sum,\n        'max_sum': max_sum,\n        'expected_sum': Rational(expected_sum).limit_denominator()\n    }", "def validate_and_normalize_probabilities(probabilities):\n    \"\"\"\n    Validate and, if necessary, normalize an array of probabilities so they sum to 1.\n    Parameters:\n    - probabilities (np.ndarray): An array of raw probability values that might not sum to 1.\n    Returns:\n    - np.ndarray: Normalized probability array.\n    Examples:\n    >>> validate_and_normalize_probabilities(np.array([0.1, 0.2, 0.3]))\n    np.array([0.1667, 0.3333, 0.5])\n    >>> validate_and_normalize_probabilities(np.array([0.5, 0.5]))\n    np.array([0.5, 0.5])\n    \"\"\"\n    prob_sum = np.sum(probabilities)\n    if prob_sum == 0:\n        raise ValueError(\"Sum of probabilities should not be zero.\")\n    return probabilities / prob_sum", "def expected_value_combinatorial(n, k, success_probability):\n    \"\"\"\n    Calculate the expected value for combinatorial probability problems, like Bernoulli trials.\n    Parameters:\n    n (int): Total number of trials or elements.\n    k (int): Number of successful trials.\n    success_probability (float): The probability of success in each trial.\n    Returns:\n    float: Expected value calculated as `E[X] = n * p` where `p` is the success probability.\n    Examples:\n    >>> expected_value_combinatorial(10, 3, 0.5)\n    5.0\n    \"\"\"\n    return n * success_probability", "def expected_value_from_pmf(pmf):\n    \"\"\"\n    Calculate the expected value from a probability mass function.\n    Parameters:\n    pmf (dict): A dictionary where keys are outcomes and values are the probabilities of these outcomes.\n    Returns:\n    float: The expected value calculated as the sum of all outcomes weighted by their probabilities.\n    Examples:\n    >>> pmf = {0: 0.5, 1: 0.3, 2: 0.2}\n    >>> expected_value_from_pmf(pmf)\n    0.7\n    \"\"\"\n    return sum(outcome * probability for outcome, probability in pmf.items())", "def probability_of_mutually_exclusive_events(*probabilities):\n    \"\"\"\n    Calculate the total probability of the occurrence of any one of several mutually exclusive events.\n    \n    Parameters:\n    - probabilities (floats): A sequence of probabilities for each event, each being independent and mutually exclusive.\n    \n    Returns:\n    - float: The total probability of occurring at least one of the events.\n    \n    Examples:\n    >>> probability_of_mutually_exclusive_events(0.1, 0.2, 0.05)\n    0.35\n    \"\"\"\n    return sum(probabilities)"]}