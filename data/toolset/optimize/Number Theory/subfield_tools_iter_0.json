{"Properties of Integers": [{"tool": "def is_prime(n):\n    \n    return isprime(n)", "subfield": "Properties of Integers", "tool_name": "is_prime", "tool_type": "function", "description": "Determine if the input integer is a prime number.", "docstring": "Determine if the input integer is a prime number.\n    Parameters:\n        n (int): The integer to check for primality.\n    Returns:\n        bool: True if n is prime, otherwise False.\n    \n    Examples:\n    >>> is_prime(29)\n    True", "Freq": 2, "TSR": 2}, {"tool": "def prime_factors(n):\n    \n    i = 2\n    factors = []\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n            factors.append(i)\n    if n > 1:\n        factors.append(n)\n    return factors", "subfield": "Properties of Integers", "tool_name": "prime_factors", "tool_type": "function", "description": "Returns the list of prime factors of a given positive integer n.", "docstring": "Returns the list of prime factors of a given positive integer n.\n    Parameters:\n    - n (int): Positive integer to factorize.\n    \n    Returns:\n    - list: Prime factors of integer n.\n    Examples:\n    >>> prime_factors(18)\n    [2, 3, 3]\n    >>> prime_factors(17)\n    [17]", "Freq": 2, "TSR": 0}, {"tool": "def modular_inverse(a, n):\n    \n    if is_relatively_prime(a, n):\n        for x in range(1, n):\n            if (a * x) % n == 1:\n                return x\n    raise ValueError(f\"No modular inverse exists for {a} under modulo {n}, since they are not relatively prime.\")", "subfield": "Properties of Integers", "tool_name": "modular_inverse", "tool_type": "function", "description": "Find the modular inverse of a under modulo n if it exists. The inverse exists if and only if a and n are relatively prime.", "docstring": "Find the modular inverse of a under modulo n if it exists. The inverse exists if and only if a and n are relatively prime.\n    \n    Parameters:\n    - a: int, the number to find an inverse for.\n    - n: int, the modulo.\n    \n    Returns:\n    - int, the modular inverse of a mod n if it exists, otherwise raises an exception.\n    \n    Example:\n    >>> modular_inverse(3, 11)\n    4", "Freq": 0, "TSR": 0}, {"tool": "def is_divisible(n, divisor):\n    \n    return n % divisor == 0", "subfield": "Properties of Integers", "tool_name": "is_divisible", "tool_type": "function", "description": "Checks if the first number is divisible by the second number.", "docstring": "Checks if the first number is divisible by the second number.\n    Parameters:\n    - n (int): Number to be checked.\n    - divisor (int): Divisor.\n    Returns:\n    bool: True if n is divisible by divisor, else False.\n    Example:\n    >>> is_divisible(10, 2)\n    True\n    >>> is_divisible(10, 3)\n    False", "Freq": 3, "TSR": 3}, {"tool": "def integer_squares(n):\n    \n    root = int(n**0.5)\n    return root * root == n", "subfield": "Properties of Integers", "tool_name": "integer_squares", "tool_type": "function", "description": "Check if a number is a perfect square.", "docstring": "Check if a number is a perfect square.\n    Parameters:\n    - n (int): The integer to check.\n    \n    Returns:\n    - bool: True if n is a perfect square, False otherwise.\n    \n    Examples:\n    >>> integer_squares(16)\n    True\n    >>> integer_squares(14)\n    False", "Freq": 3, "TSR": 1}, {"tool": "def is_coprime(a, b):\n    \n    return gcd(a, b) == 1", "subfield": "Properties of Integers", "tool_name": "is_coprime", "tool_type": "function", "description": "Checks if two numbers a and b are coprime (gcd is 1).", "docstring": "Checks if two numbers a and b are coprime (gcd is 1).\n    Parameters:\n    - a (int): First number.\n    - b (int): Second number.\n    Returns:\n    - bool: True if gcd(a, b) == 1, otherwise False.\n    Examples:\n    >>> is_coprime(14, 15)\n    True\n    >>> is_coprime(14, 21)\n    False", "Freq": 3, "TSR": 2}, {"tool": "def find_divisors(n):\n    \n    divisors = []\n    for i in range(1, int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            divisors.append(i)\n            if i != n // i:\n                divisors.append(n // i)\n    divisors.sort()\n    return divisors", "subfield": "Properties of Integers", "tool_name": "find_divisors", "tool_type": "function", "description": "Find all divisors of a given integer n.", "docstring": "Find all divisors of a given integer n.\n    Parameters:\n    n (int): The integer to find divisors of.\n    Returns:\n    list of int: List of all divisors of n.\n    Example:\n    >>> find_divisors(28)\n    [1, 2, 4, 7, 14, 28]", "Freq": 2, "TSR": 1}, {"tool": "def count_divisors(n):\n    \n    total = 0\n    root = int(math.sqrt(n))\n    for i in range(1, root + 1):\n        if n % i == 0:\n            total += 1 + (i != n // i)\n    return total", "subfield": "Properties of Integers", "tool_name": "count_divisors", "tool_type": "function", "description": "Count the divisors of an integer n.\n    :param n: The integer to count divisors for.\n    :return: The count of divisors of n.\n    \n    Examples:\n    >>> count_divisors(36)\n    9\n    >>> count_divisors(37)\n    2", "docstring": "Count the divisors of an integer n.\n    :param n: The integer to count divisors for.\n    :return: The count of divisors of n.\n    \n    Examples:\n    >>> count_divisors(36)\n    9\n    >>> count_divisors(37)\n    2", "Freq": 1, "TSR": 0}, {"tool": "def mod_multiply(a, b, n):\n    \n    return (a * b) % n", "subfield": "Properties of Integers", "tool_name": "mod_multiply", "tool_type": "function", "description": "Perform modular multiplication.", "docstring": "Perform modular multiplication.\n    Parameters:\n    a (int): First factor.\n    b (int): Second factor.\n    n (int): Modulus.\n    Returns:\n    int: Result of (a * b) % n.\n    Examples:\n    >>> mod_multiply(3, 4, 5)\n    2", "Freq": 0, "TSR": 0}, {"tool": "def nth_root(n, r):\n    \n    return n ** (1/r)", "subfield": "Properties of Integers", "tool_name": "nth_root", "tool_type": "function", "description": "Computes the nth root of a number n.", "docstring": "Computes the nth root of a number n.\n    Parameters:\n    - n (int): The number to find the root of.\n    - r (int): The root degree.\n    Returns:\n    - float: The nth root of n.\n    Examples:\n    >>> nth_root(16, 2)\n    4.0\n    >>> nth_root(27, 3)\n    3.0", "Freq": 1, "TSR": 0}, {"tool": "def is_even(number):\n    \n    return number % 2 == 0", "subfield": "Properties of Integers", "tool_name": "is_even", "tool_type": "function", "description": "Determine if a number is even.", "docstring": "Determine if a number is even.\n    Parameters:\n    - number (int): The number to check.\n    Returns:\n    - bool: True if the number is even, otherwise False.\n    Examples:\n    >>> is_even(4)\n    True\n    >>> is_even(5)\n    False", "Freq": 0, "TSR": 0}, {"tool": "def is_odd(number):\n    \n    return number % 2 != 0", "subfield": "Properties of Integers", "tool_name": "is_odd", "tool_type": "function", "description": "Determine if a number is odd.", "docstring": "Determine if a number is odd.\n    Parameters:\n    - number (int): The number to check.\n    Returns:\n    - bool: True if the number is odd, otherwise False.\n    Examples:\n    >>> is_odd(3)\n    True\n    >>> is_odd(10)\n    False", "Freq": 2, "TSR": 1}, {"tool": "def count_perfect_squares(start, end):\n    \n    import math\n    return math.isqrt(end) - math.isqrt(start - 1)", "subfield": "Properties of Integers", "tool_name": "count_perfect_squares", "tool_type": "function", "description": "Count the number of perfect squares in a given range [start, end].", "docstring": "Count the number of perfect squares in a given range [start, end].\n    \n    Parameters:\n    start (int): The start of the range (inclusive).\n    end (int): The end of the range (inclusive).\n    Returns:\n    int: The count of perfect squares in the range.\n    Examples:\n    >>> count_perfect_squares(1, 100)\n    10", "Freq": 1, "TSR": 0}, {"tool": "def absolute_value(n):\n    \n    return abs(n)", "subfield": "Properties of Integers", "tool_name": "absolute_value", "tool_type": "function", "description": "Calculate the absolute value of an integer.", "docstring": "Calculate the absolute value of an integer.\n    Parameters:\n    - n (int): The integer.\n    \n    Returns:\n    - int: The absolute value of n.\n    \n    Examples:\n    >>> absolute_value(-5)\n    5\n    >>> absolute_endcode_point(3)\n    3", "Freq": 1, "TSR": 0}, {"tool": "def check_divisibility(n, div):\n    \n    return n % div == 0", "subfield": "Properties of Integers", "tool_name": "check_divisibility", "tool_type": "function", "description": "Determines if n is divisible by div.", "docstring": "Determines if n is divisible by div.\n    Parameters:\n    - n (int): The number to be checked.\n    - div (int): The divisor.\n    Returns:\n    - bool: True if n is divisible by div, False otherwise.", "Freq": 0, "TSR": 0}, {"tool": "def modular_add(a, b, mod):\n    \n    return (a + b) % mod", "subfield": "Properties of Integers", "tool_name": "modular_add", "tool_type": "function", "description": "Perform modular addition.", "docstring": "Perform modular addition.\n    \n    Parameters:\n        a (int): The first operand.\n        b (int): The second operand.\n        mod (int): The modulus.\n    Returns:\n        int: The result of (a + b) % mod.\n    Examples:\n        >>> modular_add(3, 4, 5)\n        2", "Freq": 4, "TSR": 3}, {"tool": "def mod_subtract(a, b, n):\n    \n    return (a - b) % n", "subfield": "Properties of Integers", "tool_name": "mod_subtract", "tool_type": "function", "description": "Perform modular subtraction.", "docstring": "Perform modular subtraction.\n    Parameters:\n    a (int): Minuend.\n    b (int): Subtrahend.\n    n (int): Modulus.\n    Returns:\n    int: Result of (a - b) % n.\n    Examples:\n    >>> mod_subtract(5, 3, 7)\n    2", "Freq": 3, "TSR": 1}, {"tool": "def mod_exponent(base, exponent, modulus):\n    \n    return pow(base, exponent, modulus)", "subfield": "Properties of Integers", "tool_name": "mod_exponent", "tool_type": "function", "description": "Computes (base^exponent) % modulus using efficient exponentiation.", "docstring": "Computes (base^exponent) % modulus using efficient exponentiation.\n    Parameters:\n    base (int): Base of the exponentiation.\n    exponent (int): Exponent.\n    modulus (int): Modulus.\n    Returns:\n    int: Result of (base^exponent) % modulus.\n    Examples:\n    >>> mod_exponent(2, 10, 1000)\n    24", "Freq": 3, "TSR": 2}, {"tool": "def gcd_lcm_calculator(a, b):\n    \n    from math import gcd\n    \n    gcd_value = gcd(a, b)\n    lcm_value = abs(a * b) // gcd_value\n    \n    return gcd_value, lcm_value", "subfield": "Properties of Integers", "tool_name": "gcd_lcm_calculator", "tool_type": "function", "description": "Calculate the Greatest Common Divisor (GCD) and Least Common Multiple (LCM)\n    of two integers using Euclid's algorithm for GCD and the relation LCM * GCD = a * b.", "docstring": "Calculate the Greatest Common Divisor (GCD) and Least Common Multiple (LCM)\n    of two integers using Euclid's algorithm for GCD and the relation LCM * GCD = a * b.\n    Parameters:\n    - a (int): First integer\n    - b (int): Second integer\n    \n    Returns:\n    - tuple: (gcd, lcm) of the integers a and b\n    Examples:\n    >>> gcd_lcm_calculator(12, 15)\n    (3, 60)\n    >>> gcd_lcm_calculator(100, 80)\n    (20, 400)", "Freq": 2, "TSR": 1}, {"tool": "def is_divisible(n, k):\n    \n    return n % k == 0", "subfield": "Properties of Integers", "tool_name": "is_divisible", "tool_type": "function", "description": "Check if integer n is divisible by integer k.", "docstring": "Check if integer n is divisible by integer k.\n    Parameters:\n        n (int): The number to be divided.\n        k (int): The divisor.\n    Returns:\n        bool: True if n is divisible by k, False otherwise.\n    Examples:\n        >>> is_divisible(10, 5)\n        True\n        >>> is_divisible(10, 3)\n        False", "Freq": 0, "TSR": 0}, {"tool": "def list_primes(a, b):\n    \n    return list(primerange(a, b))", "subfield": "Properties of Integers", "tool_name": "list_primes", "tool_type": "function", "description": "Lists all primes in the range [a, b)", "docstring": "Lists all primes in the range [a, b)\n    Parameters:\n    - a (int): Start of the range (inclusive).\n    - b (int): End of the range (exclusive).\n    Returns:\n    - list: List of prime numbers between a and b.\n    Examples:\n    >>> list_primes(10, 20)\n    [11, 13, 17, 19]", "Freq": 0, "TSR": 0}, {"tool": "def integer_sign(n):\n    \n    if n < 0:\n        return -1\n    elif n > 0:\n        return 1\n    else:\n        return 0", "subfield": "Properties of Integers", "tool_name": "integer_sign", "tool_type": "function", "description": "Determine the sign of an integer.", "docstring": "Determine the sign of an integer.\n    Parameters:\n        n (int): The integer to check.\n    Returns:\n        int: -1 if negative, 1 if positive, 0 if zero.\n    Examples:\n        >>> integer_sign(-20)\n        -1\n        >>> integer_sign(15)\n        1", "Freq": 0, "TSR": 0}, {"tool": "def product_of_integers(numbers):\n    \n    product = 1\n    for num in numbers:\n        product *= num\n    return product", "subfield": "Properties of Integers", "tool_name": "product_of_integers", "tool_type": "function", "description": "Compute the product of a sequence of integers.", "docstring": "Compute the product of a sequence of integers.\n    Parameters:\n         numbers (list): A list of integers.\n    Returns:\n        int: The product of the integers in the list.\n    Examples:\n        >>> product_of_integers([1, 2, 3])\n        6", "Freq": 2, "TSR": 1}, {"tool": "def consecutive_primes(n):\n    \n    return list(sympy.primerange(1, sympy.prime(n)+1))", "subfield": "Properties of Integers", "tool_name": "consecutive_primes", "tool_type": "function", "description": "Generate a list of the first n prime numbers.", "docstring": "Generate a list of the first n prime numbers.\n    Parameters:\n        n (int): The number of primes to generate.\n    Returns:\n        list: A list of the first n primes.\n    Examples:\n        >>> consecutive_primes(5)\n        [2, 3, 5, 7, 11]", "Freq": 0, "TSR": 0}, {"tool": "def count_factors(n):\n    \n    if n <= 0:\n        raise ValueError(\"n must be a positive integer\")\n    factors = sympy.divisors(n)\n    return len(factors)", "subfield": "Properties of Integers", "tool_name": "count_factors", "tool_type": "function", "description": "Count the number of factors of an integer.", "docstring": "Count the number of factors of an integer.\n    Parameters:\n    - n (int): The integer to count factors for.\n    \n    Returns:\n    - int: Number of factors of n.\n    \n    Examples:\n    >>> count_factors(12)\n    6", "Freq": 0, "TSR": 0}, {"tool": "def calculate_lcm(numbers):\n    \n    return int(np.lcm.reduce(numbers))", "subfield": "Properties of Integers", "tool_name": "calculate_lcm", "tool_type": "function", "description": "Calculate least common multiple of a list of numbers.", "docstring": "Calculate least common multiple of a list of numbers.\n    Parameters:\n    - numbers : list of int\n        The list of integers for which to calculate the LCM.\n    \n    Returns:\n    - int\n        The least common multiple of the numbers.\n    \n    Examples:\n    >>> calculate_lcm([12, 15, 20])\n    60", "Freq": 0, "TSR": 0}, {"tool": "def integer_close_to_sqrt(n):\n    \n    return round(math.sqrt(n))", "subfield": "Properties of Integers", "tool_name": "integer_close_to_sqrt", "tool_type": "function", "description": "Finds the closest integer to the square root of n.", "docstring": "Finds the closest integer to the square root of n.\n    Parameters:\n    - n (int): The number to find the square root of.\n    Returns:\n    - int: The integer closest to the square root of n.\n    Examples:\n    >>> integer_close_to_sqrt(10)\n    3\n    >>> integer_close_to_sqrt(15)\n    4", "Freq": 1, "TSR": 0}, {"tool": "def gcd(a, b):\n    \n    from math import gcd as compute_gcd\n    return compute_gcd(a, b)", "subfield": "Properties of Integers", "tool_name": "gcd", "tool_type": "function", "description": "Compute the greatest common divisor of two integers.", "docstring": "Compute the greatest common divisor of two integers.\n    \n    Parameters:\n    - a (int): First integer.\n    - b (int): Second integer.\n    Returns:\n    int: The greatest common divisor of a and b.\n    \n    Examples:\n    >>> gcd(12, 15)\n    3\n    >>> gcd(3, 7)\n    1", "Freq": 2, "TSR": 2}, {"tool": "def solve_diophantine(a, b, c):\n    \n    from math import gcd\n    if c % gcd(a, b) != 0:\n        return None\n    x, y = 0, c // b\n    while True:\n        if (c - b * y) % a == 0:\n            x = (c - b * y) // a\n            return (x, y)\n        y -= 1", "subfield": "Properties of Integers", "tool_name": "solve_diophantine", "tool_type": "function", "description": "Solve the linear Diophantine equation a*x + b*y = c for integers x and y.\n    Returns a single solution (x, y) if it exists.", "docstring": "Solve the linear Diophantine equation a*x + b*y = c for integers x and y.\n    Returns a single solution (x, y) if it exists.\n    Parameters:\n        a (int): Coefficient of x.\n        b (int): Coefficient of y.\n        c (int): Constant term.\n    Returns:\n        tuple: a tuple (x, y) representing a solution, if it exists.\n        None: if no integer solution exists.\n    Examples:\n        >>> solve_diophanine(3, -9, 12)\n        None\n        >>> solve_diophanine(2, 3, 5)\n        (1, 1)", "Freq": 0, "TSR": 0}, {"tool": "def arithmetic_sequence_sum(a, d, n):\n    \n    return n * (2 * a + (n - 1) * d) // 2", "subfield": "Properties of Integers", "tool_name": "arithmetic_sequence_sum", "tool_type": "function", "description": "Calculate the sum of the first n terms of an arithmetic sequence.", "docstring": "Calculate the sum of the first n terms of an arithmetic sequence.\n    Parameters:\n        a (int): The first term of the sequence.\n        d (int): The common difference between consecutive terms.\n        n (int): The number of terms.\n    Returns:\n        int: The sum of the first n terms of the sequence.\n    Examples:\n        >>> arithmetic_sequence_sum(1, 1, 5)\n        15", "Freq": 1, "TSR": 1}, {"tool": "def lcm(x, y):\n    \n    return abs(x*y) // gcd(x, y)", "subfield": "Properties of Integers", "tool_name": "lcm", "tool_type": "function", "description": "Compute the least common multiple (LCM) of two numbers based on their GCD.", "docstring": "Compute the least common multiple (LCM) of two numbers based on their GCD.\n    \n    Parameters:\n    - x: int, the first number.\n    - y: int, the second number.\n    \n    Returns:\n    - int, the LCM of the two numbers.\n    \n    Example:\n    >>> lcm(4, 5)\n    20", "Freq": 0, "TSR": 0}, {"tool": "def reverse_digits(n):\n    \n    return int(str(n)[::-1]) if n >= 0 else -int(str(-n)[::-1])", "subfield": "Properties of Integers", "tool_name": "reverse_digits", "tool_type": "function", "description": "Reverse the digits of an integer.", "docstring": "Reverse the digits of an integer.\n    \n    Parameters:\n        n (int): The integer to be reversed.\n    \n    Returns:\n        int: The integer formed by reversing the digits of `n`.\n    \n    Example:\n        >>> reverse_digits(123)\n        321", "Freq": 0, "TSR": 0}, {"tool": "def arithmetic_modulo_n(a, b, mod, operation='add'):\n    \n    operations = {\n        'add': (a + b) % mod,\n        'subtract': (a - b) % mod,\n        'multiply': (a * b) % mod\n    }\n    return operations.get(operation, None)", "subfield": "Properties of Integers", "tool_name": "arithmetic_modulo_n", "tool_type": "function", "description": "Perform arithmetic operations on two integers modulo `n`.", "docstring": "Perform arithmetic operations on two integers modulo `n`.\n    Parameters:\n    a : int\n        The first operand.\n    b : int\n        The second operand.\n    mod : int\n        The modulo value.\n    operation : str\n        The operation to perform ('add', 'subtract', 'multiply').\n    Returns:\n    int\n        The result of the operation performed modulo `n`.\n    Examples:\n    >>> arithmetic_modulo_n(3, 5, 6, 'add')\n    2\n    >>> arithmetic_modulo_n(4, 3, 5, 'multiply')\n    2", "Freq": 0, "TSR": 0}, {"tool": "def integer_base_conversion_and_divisibility():\n    \n    from sympy import isprime\n    import math\n    def convert_base(n, from_base, to_base):\n        \n        if from_base != 10:\n            n = int(n, from_base)\n        if to_base == 10:\n            return str(n)\n        else:\n            digits = \"0123456789ABCDEF\"\n            result = \"\"\n            while n > 0:\n                result = digits[n % to_base] + result\n                n //= to_base\n            return result or \"0\"\n    def is_divisible(n, divisor):\n        \n        return n % divisor == 0\n    \n    def repeating_decimal_period(n):\n        \n        remainders = {}\n        remainder = 1\n        position = 0\n        while remainder and remainder not in remainders:\n            remainders[remainder] = position\n            remainder = (remainder * 10) % n\n            position += 1\n        return 0 if not remainder else position - remainders[remainder]\n    base_utils = {\n        'convert_base': convert_base,\n        'is_divisible': is_divisible,\n        'repeating_decimal_period': repeating_decimal_period\n    }\n    return base_utils", "subfield": "Properties of Integers", "tool_name": "integer_base_conversion_and_divisibility", "tool_type": "function", "description": "A collection of utility functions for base conversion and checking divisibility rules.\n    Includes functions for converting numbers between different bases, checking divisibility,\n    and analyzing repeating decimals.", "docstring": "A collection of utility functions for base conversion and checking divisibility rules.\n    Includes functions for converting numbers between different bases, checking divisibility,\n    and analyzing repeating decimals.", "Freq": 0, "TSR": 0}, {"tool": "def basic_modular_operations(a, b, m, operation):\n    \n    if operation == 'add':\n        return (a + b) % m\n    elif operation == 'subtract':\n        return (a - b) % m\n    elif operation == 'multiply':\n        return (a * b) % m\n    else:\n        raise ValueError(\"Unsupported operation\")", "subfield": "Properties of Integers", "tool_name": "basic_modular_operations", "tool_type": "function", "description": "Performs basic modular arithmetic operations between two numbers.", "docstring": "Performs basic modular arithmetic operations between two numbers.\n    Parameters:\n    - a (int): The first number.\n    - b (int): The second number.\n    - m (int): The modulus.\n    - operation (str): The operation to perform ('add', 'subtract', 'multiply').\n    Returns:\n    - int: The result of the operation under modulo m.", "Freq": 0, "TSR": 0}, {"tool": "def gcd(x, y):\n    \n    while y:\n        x, y = y, x % y\n    return x", "subfield": "Properties of Integers", "tool_name": "gcd", "tool_type": "function", "description": "Compute the greatest common divisor (GCD) of two numbers using the Euclidean algorithm.", "docstring": "Compute the greatest common divisor (GCD) of two numbers using the Euclidean algorithm.\n    \n    Parameters:\n    - x: int, the first number.\n    - y: int, the second number.\n    \n    Returns:\n    - int, the GCD of x and y.\n    \n    Example:\n    >>> gcd(48, 18)\n    6", "Freq": 0, "TSR": 0}, {"tool": "def count_fourth_powers(a, b):\n    \n    # Finding the floor of the fourth root of `a` and `b`.\n    low_n = int(math.pow(a, 0.25))\n    high_n = int(math.pow(b, 1/4))\n    \n    count = 0\n    for n in range(low_n, high_n + 1):\n        if n**4 >= a and n**4 <= b:\n            count += 1\n    return count", "subfield": "Properties of Integers", "tool_name": "count_fourth_powers", "tool_type": "function", "description": "Count the number of fourth powers in the range [a, b].\n    x is considered a fourth power if x = n^4 for some integer n.", "docstring": "Count the number of fourth powers in the range [a, b].\n    x is considered a fourth power if x = n^4 for some integer n.\n    \n    Parameters:\n        a (int): Start of the range.\n        b (int): End of the range.\n        \n    Returns:\n        int: Count of fourth powers in the given range.\n        \n    Examples:\n        >>> count_fourth_powers(1, 1000)\n        3\n        >>> count_fourth_powers(1, 10000)\n        4", "Freq": 2, "TSR": 0}, {"tool": "def extended_gcd(a, b):\n    \n    if a == 0:\n        return (b, 0, 1)\n    else:\n        gcd, x1, y1 = extended_gcd(b % a, a)\n        x = y1 - (b // a) * x1\n        y = x1\n        return (gcd, x, y)", "subfield": "Properties of Integers", "tool_name": "extended_gcd", "tool_type": "function", "description": "Compute the extended greatest common divisor of a and b, and return the coefficients of Bezout's identity.", "docstring": "Compute the extended greatest common divisor of a and b, and return the coefficients of Bezout's identity.\n    \n    Parameters:\n        a (int): First number.\n        b (int): Second number.\n    Returns:\n        (gcd, x, y) (tuple): gcd is the greatest common divisor of a and b.\n                             x and y are the coefficients of Bezout's identity, i.e., ax + by = gcd\n    Examples:\n        >>> extended_gcd(12, 15)\n        (3, -1, 1)", "Freq": 0, "TSR": 0}, {"tool": "def modulus_divisibility(num, base, mod):\n    \n    return (num % base) % mod == 0", "subfield": "Properties of Integers", "tool_name": "modulus_divisibility", "tool_type": "function", "description": "Checks divisibility of the number num with respect to a base after applying modulus operation.", "docstring": "Checks divisibility of the number num with respect to a base after applying modulus operation.\n    Parameters:\n        num (int): The number to check.\n        base (int): The base for modulus operation.\n        mod (int): The modulus divisor.\n    Returns:\n        bool: True if the number's modulus in the given base is divisible by mod, else False.\n    Examples:\n        >>> modulus_divisibility(20, 10, 2)\n        True\n        >>> modulus_divisibility(21, 10, 2)\n        False", "Freq": 0, "TSR": 0}, {"tool": "def digit_sum(n):\n    \n    return sum(int(digit) for digit in str(abs(n)))", "subfield": "Properties of Integers", "tool_name": "digit_sum", "tool_type": "function", "description": "Calculate the sum of the digits of an integer.", "docstring": "Calculate the sum of the digits of an integer.\n    \n    Parameters:\n        n (int): The integer whose digits will be summed.\n    \n    Returns:\n        int: The sum of the digits of `n`.\n    \n    Example:\n        >>> digit_sum(123)\n        6", "Freq": 0, "TSR": 0}, {"tool": "def count_digits(n):\n    \n    return len(str(abs(n)))", "subfield": "Properties of Integers", "tool_name": "count_digits", "tool_type": "function", "description": "Count the number of digits in an integer.", "docstring": "Count the number of digits in an integer.\n    \n    Parameters:\n        n (int): The integer to count digits.\n    \n    Returns:\n        int: The number of digits in `n`.\n    \n    Example:\n        >>> count_digits(12345)\n        5", "Freq": 0, "TSR": 0}, {"tool": "def count_even_odd_in_range(start, end):\n    \n    count_even = len([num for num in range(start, end) if num % 2 == 0])\n    count_odd = (end - start) - count_even\n    return (count_even, count_odd)", "subfield": "Properties of Integers", "tool_name": "count_even_odd_in_range", "tool_type": "function", "description": "Count even and odd numbers within a given range [start, end).", "docstring": "Count even and odd numbers within a given range [start, end).\n    Parameters:\n    - start (int): The starting integer value of the range (inclusive).\n    - end (int): The ending integer value of the range (exclusive).\n    Returns:\n    tuple: A tuple (count_even, count_odd) representing the number of even and odd numbers respectively.\n    \n    Examples:\n    >>> count_even_odd_in_range(1, 10)\n    (4, 5)", "Freq": 2, "TSR": 1}, {"tool": "def is_perfect_power(n, power):\n    \n    import sympy\n    root, perfect = sympy.ntheory.primetest.integer_nthroot(n, power)\n    return perfect", "subfield": "Properties of Integers", "tool_name": "is_perfect_power", "tool_type": "function", "description": "Checks if a number is a perfect power of another integer.", "docstring": "Checks if a number is a perfect power of another integer.\n    Parameters:\n    - n (int): The number to check.\n    - power (int): The power to test.\n    Returns:\n    bool: True if n is a perfect power of 'power', else False.\n    Example:\n    >>> is_perfect_power(64, 2)\n    True\n    >>> is_perfect_power(65, 2)\n    False", "Freq": 0, "TSR": 0}, {"tool": "def list_perfect_squares(limit):\n    \n    return [i * i for i in range(int(math.sqrt(limit)) + 1)]", "subfield": "Properties of Integers", "tool_name": "list_perfect_squares", "tool_type": "function", "description": "Lists all perfect squares up to a given limit.\n    :param limit: The upper limit (inclusive) for listing perfect squares.\n    :return: A list of all perfect squares up to 'limit'.\n    \n    Examples:\n    >>> list_perfect_squares(30)\n    [0, 1, 4, 9, 16, 25]", "docstring": "Lists all perfect squares up to a given limit.\n    :param limit: The upper limit (inclusive) for listing perfect squares.\n    :return: A list of all perfect squares up to 'limit'.\n    \n    Examples:\n    >>> list_perfect_squares(30)\n    [0, 1, 4, 9, 16, 25]", "Freq": 1, "TSR": 1}, {"tool": "def filter_divisible_numbers(start, end, divisor):\n    \n    return [x for x in range(start, end + 1) if x % divisor == 0]", "subfield": "Properties of Integers", "tool_name": "filter_divisible_numbers", "tool_type": "function", "description": "Generates a list of numbers within the specified range that are divisible by the given divisor.", "docstring": "Generates a list of numbers within the specified range that are divisible by the given divisor.\n    Parameters:\n    start : int\n        The starting value of the range (inclusive).\n    end : int\n        The ending value of the range (inclusive).\n    divisor : int\n        The divisor used for filtering numbers.\n    Returns:\n    list of int\n        List of integers within the specified range that are divisible by the divisor.\n    Examples:\n    >>> filter_divisible_numbers(1, 10, 2)\n    [2, 4, 6, 8, 10]\n    >>> filter_divisible_numbers(1, 10, 3)\n    [3, 6, 9]", "Freq": 0, "TSR": 0}, {"tool": "def extended_euclidean_algorithm(a, b):\n    \n    if a == 0:\n        return (b, 0, 1)\n    else:\n        gcd, x1, y1 = extended_euclidean_algorithm(b % a, a)\n        x = y1 - (b // a) * x1\n        y = x1\n        return (gcd, x, y)", "subfield": "Properties of Integers", "tool_name": "extended_euclidean_algorithm", "tool_type": "function", "description": "Applies the Extended Euclidean Algorithm to find integers x, y such that ax + by = gcd(a, b).", "docstring": "Applies the Extended Euclidean Algorithm to find integers x, y such that ax + by = gcd(a, b).\n    Parameters:\n    - a (int): First integer\n    - b (int): Second integer\n    \n    Returns:\n    - tuple: gcd of a and b, and coefficients x, y such that ax + by = gcd(a, b)\n    Examples:\n    >>> extended_euclidean_algorithm(10, 6)\n    (2, 1, -1)\n    >>> extended_euclidean_algorithm(113, 57)\n    (1, 5, -10)", "Freq": 0, "TSR": 0}, {"tool": "def next_prime(n):\n    \n    test_num = n + 1\n    while True:\n        if is_prime(test_num):\n            return test_num\n        test_num += 1", "subfield": "Properties of Integers", "tool_name": "next_prime", "tool_type": "function", "description": "Find the smallest prime number greater than n.", "docstring": "Find the smallest prime number greater than n.\n    Parameters:\n    n (int): Starting number to find the next prime.\n    Returns:\n    int: The next prime number after n.\n    Example:\n    >>> next_prime(28)\n    29", "Freq": 0, "TSR": 0}, {"tool": "def classify_integer(n):\n    \n    if n > 0:\n        return \"positive\"\n    elif n < 0:\n        return \"negative\"\n    else:\n        return \"zero\"", "subfield": "Properties of Integers", "tool_name": "classify_integer", "tool_type": "function", "description": "Classifies an integer as positive, negative, or zero.", "docstring": "Classifies an integer as positive, negative, or zero.\n    Parameters:\n    - n (int): The integer to classify.\n    \n    Returns:\n    - str: \"positive\", \"negative\", or \"zero\" based on the value of n.\n    \n    Examples:\n    >>> classify_integer(10)\n    'positive'\n    >>> classify_integer(-5)\n    'negative'\n    >>> classify_integer(0)\n    'zero'", "Freq": 0, "TSR": 0}, {"tool": "def is_relatively_prime(x, y):\n    \n    return gcd(x, y) == 1", "subfield": "Properties of Integers", "tool_name": "is_relatively_prime", "tool_type": "function", "description": "Check if two numbers are relatively prime.", "docstring": "Check if two numbers are relatively prime.\n    \n    Parameters:\n    - x: int, the first number.\n    - y: int, the second number.\n    \n    Returns:\n    - bool, True if x and y are relatively prime, False otherwise.\n    \n    Example:\n    >>> is_relatively_prime(35, 18)\n    True", "Freq": 2, "TSR": 0}, {"tool": "def units_digit(number):\n    \n    return abs(number) % 10", "subfield": "Properties of Integers", "tool_name": "units_digit", "tool_type": "function", "description": "Return the units digit of a number.", "docstring": "Return the units digit of a number.\n    Parameters:\n    - number (int): The number to get the units digit from.\n    Returns:\n    - int: The units digit of the number.\n    Examples:\n    >>> units_digit(123)\n    3\n    >>> units_digit(-476)\n    6", "Freq": 1, "TSR": 0}, {"tool": "def integer_digit_manipulation():\n    \n    import numpy as np\n    from sympy import isprime\n    def reverse_digits(n):\n        \n        return int(str(n)[::-1])\n    def sum_digits(n):\n        \n        return sum(map(int, str(n)))\n    \n    def is_palindrome(n):\n        \n        s = str(n)\n        return s == s[::-1]\n    def get_digit(n, position):\n        \n        return int(str(n)[::-1][position])\n    \n    def count_digits(n):\n        \n        return len(str(n))\n    \n    def is_prime(n):\n        \n        return isprime(n)\n    \n    digit_utils = {\n        'reverse_digits': reverse_digits,\n        'sum_digits': sum_digits,\n        'is_palindrome': is_palindrome,\n        'get_digit': get_digit,\n        'count_digits': count_digits,\n        'is_prime': is_prime\n    }\n    return digit_utils", "subfield": "Properties of Integers", "tool_name": "integer_digit_manipulation", "tool_type": "function", "description": "A collection of utility functions for manipulating and analyzing digits of integers.\n    Includes functions like reversing digits, extracting specific digits, summing digits, \n    and checking if a number is a palindrome.", "docstring": "A collection of utility functions for manipulating and analyzing digits of integers.\n    Includes functions like reversing digits, extracting specific digits, summing digits, \n    and checking if a number is a palindrome.", "Freq": 2, "TSR": 1}, {"tool": "def check_congruence(a, b, m):\n    \n    return (a - b) % m == 0", "subfield": "Properties of Integers", "tool_name": "check_congruence", "tool_type": "function", "description": "Checks if two numbers are congruent modulo another number.\n    :param a: The first integer.\n    :param b: The second integer.\n    :param m: The modulus.\n    :return: True if a ≡ b (mod m), False otherwise.\n    \n    Examples:\n    >>> check_congruence(37, 57, 10)\n    True\n    >>> check_congruence(35, 57, 10)\n    False", "docstring": "Checks if two numbers are congruent modulo another number.\n    :param a: The first integer.\n    :param b: The second integer.\n    :param m: The modulus.\n    :return: True if a ≡ b (mod m), False otherwise.\n    \n    Examples:\n    >>> check_congruence(37, 57, 10)\n    True\n    >>> check_congruence(35, 57, 10)\n    False", "Freq": 2, "TSR": 1}, {"tool": "def is_whole_number(n):\n    \n    return n == int(n) and n >= 0", "subfield": "Properties of Integers", "tool_name": "is_whole_number", "tool_type": "function", "description": "Check if a number is a whole number (non-negative integer).", "docstring": "Check if a number is a whole number (non-negative integer).\n    Parameters:\n    - n (int/float): The number to check.\n    \n    Returns:\n    - bool: True if n is a whole number, False otherwise.\n    \n    Examples:\n    >>> is_whole_number(5)\n    True\n    >>> is_whole_number(-1)\n    False\n    >>> is_whole_number(3.5)\n    False", "Freq": 1, "TSR": 0}, {"tool": "def extract_digits(num):\n    \n    from math import floor, log10\n    if num == 0:\n        return [0]\n    digits = []\n    while num:\n        digits.append(num % 10)\n        num = num // 10\n    return digits[::-1]", "subfield": "Properties of Integers", "tool_name": "extract_digits", "tool_type": "function", "description": "Extracts and returns the digits of the given integer as a list.", "docstring": "Extracts and returns the digits of the given integer as a list.\n    Parameters:\n        num (int): The integer from which to extract the digits.\n    Returns:\n        list: Digits of the integer.\n    Examples:\n        >>> extract_digits(1234)\n        [1, 2, 3, 4]\n        >>> extract_digits(9075)\n        [9, 0, 7, 5]", "Freq": 0, "TSR": 0}, {"tool": "def is_divisible_by(n, d):\n    \n    if d == 0:\n        raise ValueError(\"Denominator must not be zero.\")\n    return n % d == 0", "subfield": "Properties of Integers", "tool_name": "is_divisible_by", "tool_type": "function", "description": "Determine if integer n is divisible by d.", "docstring": "Determine if integer n is divisible by d.\n    Parameters:\n    n (int): Numerator integer.\n    d (int): Denominator integer (must not be zero).\n    Returns:\n    bool: True if n is divisible by d, False otherwise.\n    Example:\n    >>> is_divisible_by(10, 2)\n    True", "Freq": 2, "TSR": 1}, {"tool": "def calculate_power(base, exponent):\n    \n    return base ** exponent", "subfield": "Properties of Integers", "tool_name": "calculate_power", "tool_type": "function", "description": "Compute the power of a base raised to an exponent.", "docstring": "Compute the power of a base raised to an exponent.\n    Parameters:\n        base (float or int): The base number.\n        exponent (int): The power to raise the base to.\n    Returns:\n        float: The result of the exponentiation.\n    \n    Examples:\n    >>> calculate_power(2, 10)\n    1024", "Freq": 2, "TSR": 1}], "Floor and Ceiling Functions": [{"tool": "def floor_value(x):\n    \n    return math.floor(x)", "subfield": "Floor and Ceiling Functions", "tool_name": "floor_value", "tool_type": "function", "description": "Computes the floor of a given number.", "docstring": "Computes the floor of a given number.\n    Parameters:\n        x (float or int): The number from which the floor will be calculated.\n    Returns:\n        int: The floor value of x.\n    Examples:\n        >>> floor_value(3.7)\n        3\n        >>> floor_value(-1.2)\n        -2", "Freq": 11, "TSR": 9}, {"tool": "def ceiling_value(x):\n    \n    return math.ceil(x)", "subfield": "Floor and Ceiling Functions", "tool_name": "ceiling_value", "tool_type": "function", "description": "Computes the ceiling of a given number.", "docstring": "Computes the ceiling of a given number.\n    Parameters:\n        x (float or int): The number from which the ceiling will be calculated.\n    Returns:\n        int: The ceiling value of x.\n    Examples:\n        >>> ceiling_value(3.7)\n        4\n        >>> ceiling_value(-1.2)\n        -1", "Freq": 11, "TSR": 11}, {"tool": "def floor_ceil(value):\n    \n    from math import floor, ceil\n    return (floor(value), ceil(value))", "subfield": "Floor and Ceiling Functions", "tool_name": "floor_ceil", "tool_type": "function", "description": "Calculate the floor and ceiling of a given numerical value.", "docstring": "Calculate the floor and ceiling of a given numerical value.\n    Parameters:\n    - value (float): The real number from which the floor and ceiling values are to be computed.\n    Returns:\n    - tuple: A tuple containing the floor value and the ceiling value respectively.\n    Examples:\n    >>> floor_ceil(3.7)\n    (3, 4)\n    >>> floor_ceil(-2.5)\n    (-3, -2)", "Freq": 0, "TSR": 0}, {"tool": "def floor_ceiling_expression_evaluator(expression):\n    \n    allowed_builtins = {\"math\": math}\n    result = eval(expression, {\"__builtins__\": None}, allowed_builtins)\n    return result", "subfield": "Floor and Ceiling Functions", "tool_name": "floor_ceiling_expression_evaluator", "tool_type": "function", "description": "Evaluate an expression involving floor or ceiling functions.", "docstring": "Evaluate an expression involving floor or ceiling functions.\n    Parameters:\n    - expression (str): The string of the expression involving floor and ceiling operations.\n    Returns:\n    - float: The result of the evaluated expression.\n    Examples:\n    >>> floor_ceiling_expression_evaluator(\"math.floor(3.7) + math.ceil(-2.3)\")\n    1\n    >>> floor_ceiling_expression_evaluator(\"math.floor(math.sqrt(10)) * 2\")\n    6", "Freq": 3, "TSR": 3}, {"tool": "def arithmetic_with_floor_ceil(a, b, operation):\n    \n    from math import floor, ceil\n    methods = {\n        'add': lambda x, y: floor(x) + ceil(y),\n        'subtract': lambda x, y: ceil(x) - floor(y),\n        'multiply': lambda x, y: ceil(x) * floor(y)\n    }\n    if operation in methods:\n        return methods[operation](a, b)\n    else:\n        raise ValueError(\"Unsupported operation. Use 'add', 'subtract', or 'multiply'.\")", "subfield": "Floor and Ceiling Functions", "tool_name": "arithmetic_with_floor_ceil", "tool_type": "function", "description": "Perform arithmetic operations using floor and ceiling values of the provided numbers.", "docstring": "Perform arithmetic operations using floor and ceiling values of the provided numbers.\n    \n    Parameters:\n    - a (float): The first real number.\n    - b (float): The second real number.\n    - operation (str): The arithmetic operation to perform. Supported operations are 'add', 'subtract', 'multiply'.\n    Returns:\n    - int: The result of the arithmetic operation applied using the floor/ceil values of the given numbers.\n    Examples:\n    >>> arithmetic_with_floor_ceil(3.2, 5.8, 'add')\n    (floor(3.2) + ceil(5.8)) = 3 + 6 = 9\n    >>> arithmetic_with_floor_ceil(-2.5, 4.1, 'multiply')\n    (ceil(-2.5) * floor(4.1)) = -2 * 4 = -8", "Freq": 2, "TSR": 0}, {"tool": "def calculate_fractional_part(number):\n    \n    \n    return number - math.floor(number)", "subfield": "Floor and Ceiling Functions", "tool_name": "calculate_fractional_part", "tool_type": "function", "description": "This function calculates and returns the fractional part of a given number.", "docstring": "This function calculates and returns the fractional part of a given number.\n    \n    Parameters:\n    -----------\n    number : float\n        The number for which the fractional part is to be calculated.\n        \n    Returns:\n    --------\n    float :\n        The fractional part of the given number.\n        \n    Examples:\n    ---------\n    >>> calculate_fractional_part(4.2)\n    0.2\n    >>> calculate_fractional_part(-3.9)\n    0.1", "Freq": 1, "TSR": 0}, {"tool": "def calculate_floor(number):\n    \n    \n    return math.floor(number)", "subfield": "Floor and Ceiling Functions", "tool_name": "calculate_floor", "tool_type": "function", "description": "This function calculates and returns the floor value of a given number.", "docstring": "This function calculates and returns the floor value of a given number.\n    \n    Parameters:\n    -----------\n    number : float\n        The number for which the floor value is to be calculated.\n        \n    Returns:\n    --------\n    float :\n        The floor value of the given number.\n        \n    Examples:\n    ---------\n    >>> calculate_floor(4.2)\n    4\n    >>> calculate_floor(-3.9)\n    -4", "Freq": 2, "TSR": 2}, {"tool": "def calculate_ceiling(number):\n    \n    \n    return math.ceil(number)", "subfield": "Floor and Ceiling Functions", "tool_name": "calculate_ceiling", "tool_type": "function", "description": "This function calculates and returns the ceiling value of a given number.", "docstring": "This function calculates and returns the ceiling value of a given number.\n    \n    Parameters:\n    -----------\n    number : float\n        The number for which the ceiling value is to be calculated.\n        \n    Returns:\n    --------\n    float :\n        The ceiling value of the given number.\n        \n    Examples:\n    ---------\n    >>> calculate_ceiling(4.2)\n    5\n    >>> calculate_ceiling(-3.9)\n    -3", "Freq": 0, "TSR": 0}], "Integer Properties": [{"tool": "def is_prime(n):\n    \n    return sympy.isprime(n)", "subfield": "Integer Properties", "tool_name": "is_prime", "tool_type": "function", "description": "Check if an integer is a prime number.", "docstring": "Check if an integer is a prime number.\n    Parameters:\n    n : int\n        The integer to check for primality.\n    Returns:\n    bool\n        True if n is a prime number, else False.\n    Examples:\n    >>> is_prime(29)\n    True", "Freq": 7, "TSR": 1}, {"tool": "def is_even(n):\n    \n    return n % 2 == 0", "subfield": "Integer Properties", "tool_name": "is_even", "tool_type": "function", "description": "Check if a number is even.", "docstring": "Check if a number is even.\n    \n    Parameters:\n    n (int): The number to check.\n    \n    Returns:\n    bool: True if the number is even, False otherwise.\n    \n    Example:\n    >>> is_even(4)\n    True\n    >>> is_even(5)\n    False", "Freq": 1, "TSR": 1}, {"tool": "def sum_of_digits(n):\n    \n    return sum(int(digit) for digit in str(abs(n)))", "subfield": "Integer Properties", "tool_name": "sum_of_digits", "tool_type": "function", "description": "Calculate the sum of digits of a given integer.", "docstring": "Calculate the sum of digits of a given integer.\n    Parameters:\n        n (int): The integer to calculate the sum of digits.\n    Returns:\n        int: Sum of the digits of n.", "Freq": 3, "TSR": 3}, {"tool": "def find_divisors(n):\n    \n    return sympy.divisors(n)", "subfield": "Integer Properties", "tool_name": "find_divisors", "tool_type": "function", "description": "Find all divisors of a given integer n.", "docstring": "Find all divisors of a given integer n.\n    Parameters:\n        n (int): The integer to find divisors of.\n    Returns:\n        list: A list of all divisors of n.", "Freq": 5, "TSR": 1}, {"tool": "def prime_factors(n):\n    \n    return factorint(n)", "subfield": "Integer Properties", "tool_name": "prime_factors", "tool_type": "function", "description": "Return the prime factorization of an integer n as a dictionary {prime: exponent}.", "docstring": "Return the prime factorization of an integer n as a dictionary {prime: exponent}.\n    Parameters:\n    - n (int): The number to factorize.\n    Returns:\n    - dict: A dictionary with primes as keys and their respective exponents as values.\n    Examples:\n    >>> prime_factors(18)\n    {2: 1, 3: 2}", "Freq": 4, "TSR": 2}, {"tool": "def is_perfect_cube(n):\n    \n    croot = int(round(n ** (1/3)))\n    return croot**3 == n", "subfield": "Integer Properties", "tool_name": "is_perfect_cube", "tool_type": "function", "description": "Check if a given integer n is a perfect cube.", "docstring": "Check if a given integer n is a perfect cube.\n    Parameters:\n    - n (int): The number to check.\n    Returns:\n    - bool: True if n is a perfect cube, False otherwise.\n    Examples:\n    >>> is_perfect_cube(27)\n    True\n    >>> is_perfect_cube(26)\n    False", "Freq": 0, "TSR": 0}, {"tool": "def compute_lcm(a, b):\n    \n    return abs(a*b) // gcd(a, b)", "subfield": "Integer Properties", "tool_name": "compute_lcm", "tool_type": "function", "description": "Compute the least common multiple of two integers a and b.", "docstring": "Compute the least common multiple of two integers a and b.\n    \n    Parameters:\n        a (int): First integer\n        b (int): Second integer\n    \n    Returns:\n        int: Least common multiple of a and b\n    \n    Examples:\n        >>> compute_lcm(6, 8)\n        24\n        >>> compute_lcm(5, 10)\n        10", "Freq": 0, "TSR": 0}, {"tool": "def is_perfect_square(n):\n    \n    sqrt_n = int(math.sqrt(n))\n    return sqrt_n * sqrt_n == n", "subfield": "Integer Properties", "tool_name": "is_perfect_square", "tool_type": "function", "description": "Check if a number is a perfect square.", "docstring": "Check if a number is a perfect square.\n    \n    Parameters:\n    - n: int, the number to check\n    \n    Returns:\n    - bool, True if n is a perfect square, False otherwise\n    \n    Examples:\n    >>> is_perfect_square(25)\n    True\n    >>> is_perfect_square(10)\n    False", "Freq": 1, "TSR": 1}, {"tool": "def is_odd(n):\n    \n    return n % 2 != 0", "subfield": "Integer Properties", "tool_name": "is_odd", "tool_type": "function", "description": "Check if a number is odd.", "docstring": "Check if a number is odd.\n    \n    Parameters:\n    n (int): The number to check.\n    \n    Returns:\n    bool: True if the number is odd, False otherwise.\n    \n    Example:\n    >>> is_odd(3)\n    True\n    >>> is_odd(4)\n    False", "Freq": 3, "TSR": 3}, {"tool": "def modular_inverse(a, m):\n    \n    from sympy import mod_inverse\n    try:\n        return mod_inverse(a, m)\n    except ValueError:\n        return None", "subfield": "Integer Properties", "tool_name": "modular_inverse", "tool_type": "function", "description": "Find the modular inverse of a under modulo m.", "docstring": "Find the modular inverse of a under modulo m.\n    Parameters:\n    - a (int): The number to find the inverse of.\n    - m (int): The modulus.\n    Returns:\n    - int/None: The modular inverse if it exists, otherwise None.\n    Examples:\n    - modular_inverse(3, 11) -> 4 (because (3*4) % 11 == 1)\n    - modular_inverse(10, 20) -> None (because 10 and 20 are not coprime)", "Freq": 3, "TSR": 2}, {"tool": "def is_valid_triangle(a, b, c):\n    \n    return (a + b > c) and (a + c > b) and (b + c > a)", "subfield": "Integer Properties", "tool_name": "is_valid_triangle", "tool_type": "function", "description": "Determines if three side lengths can form a triangle based on the triangle inequality theorem.", "docstring": "Determines if three side lengths can form a triangle based on the triangle inequality theorem.\n    \n    Parameters:\n    - a (int): length of side a\n    - b (int): length of side b\n    - c (int): length of side c\n    \n    Returns:\n    - bool: True if the sides can form a triangle, False otherwise\n    Examples:\n    >>> is_valid_triangle(3, 4, 5)\n    True\n    >>> is_valid_triangle(1, 2, 3)\n    False", "Freq": 0, "TSR": 0}, {"tool": "def triangle_combinations(max_side: int):\n    \n    from itertools import combinations_with_replacement\n    \n    valid_triangles = set()\n    for a, b, c in combinations_with_replacement(range(1, max_side + 1), 3):\n        if a + b > c and a + c > b and b + c > a:\n            valid_triangles.add(tuple(sorted([a, b, c])))\n    \n    return valid_triangles", "subfield": "Integer Properties", "tool_name": "triangle_combinations", "tool_type": "function", "description": "Generates all combinations of integer side lengths (a, b, c) such that they satisfy the triangle inequality.", "docstring": "Generates all combinations of integer side lengths (a, b, c) such that they satisfy the triangle inequality.\n    \n    Parameters:\n    - max_side (int): Maximum length for any side of the triangle.\n    \n    Returns:\n    - set of tuples: a set containing tuples (a, b, c), each being a valid triangle with sides a, b, and c.\n    \n    Example:\n    >>> triangle_combinations(5)\n    {(3, 4, 5), (2, 3, 4), (2, 2, 3), ...}", "Freq": 4, "TSR": 3}, {"tool": "def gcd(a, b):\n    \n    while b:\n        a, b = b, a % b\n    return a", "subfield": "Integer Properties", "tool_name": "gcd", "tool_type": "function", "description": "Compute the greatest common divisor of a and b.", "docstring": "Compute the greatest common divisor of a and b.\n    Parameters:\n    - a (int): First number.\n    - b (int): Second number.\n    Returns:\n    - int: The greatest common divisor of a and b.\n    \n    Example:\n    >>> gcd(48, 18)\n    6", "Freq": 3, "TSR": 2}, {"tool": "def is_divisible(n, m):\n    \n    return n % m == 0", "subfield": "Integer Properties", "tool_name": "is_divisible", "tool_type": "function", "description": "Checks if n is divisible by m.", "docstring": "Checks if n is divisible by m.\n    Parameters:\n    - n (int): The dividend.\n    - m (int): The divisor.\n    Returns:\n    - bool: True if n is divisible by m, False otherwise.\n    \n    Examples:\n    >>> is_divisible(20, 4)\n    True", "Freq": 2, "TSR": 0}, {"tool": "def extract_digits(n):\n    \n    return [int(x) for x in str(abs(n))]", "subfield": "Integer Properties", "tool_name": "extract_digits", "tool_type": "function", "description": "Extract digits of an integer n as a list.", "docstring": "Extract digits of an integer n as a list.\n    \n    Parameters:\n        n (int): The integer from which digits are to be extracted.\n        \n    Returns:\n        list: Digits of the given integer.\n    \n    Examples:\n        >>> extract_digits(123)\n        [1, 2, 3]", "Freq": 7, "TSR": 5}, {"tool": "def list_factors(n):\n    \n    return [i for i in range(1, n+1) if n % i == 0]", "subfield": "Integer Properties", "tool_name": "list_factors", "tool_type": "function", "description": "List all positive factors of a given integer.", "docstring": "List all positive factors of a given integer.\n    Parameters:\n    - n (int): The integer to find factors of.\n    Returns:\n    - list: A list of all positive factors of n.\n    Examples:\n    - list_factors(36) -> [1, 2, 3, 4, 6, 9, 12, 18, 36]", "Freq": 6, "TSR": 2}, {"tool": "def check_prime(number):\n    \n    return sympy.isprime(number)", "subfield": "Integer Properties", "tool_name": "check_prime", "tool_type": "function", "description": "Check if a number is prime using the sympy library.", "docstring": "Check if a number is prime using the sympy library.\n    Parameters:\n        number (int): The number to check for primality.\n    Returns:\n        bool: True if the number is prime, False otherwise.", "Freq": 0, "TSR": 0}, {"tool": "def sum_of_integers(n):\n    \n    return n * (n + 1) // 2", "subfield": "Integer Properties", "tool_name": "sum_of_integers", "tool_type": "function", "description": "Calculate the sum of the first n positive integers.", "docstring": "Calculate the sum of the first n positive integers.\n    \n    Parameters:\n    n : int\n        The number of terms.\n    \n    Returns:\n    int\n        The sum of the first n positive integers.\n    \n    Example:\n    >>> sum_of_integers(10)\n    55", "Freq": 2, "TSR": 2}, {"tool": "def is_square_free(n):\n    \n    if n < 2:\n        return True\n    for p in range(2, int(math.sqrt(n)) + 1):\n        if n % (p * p) == 0:\n            return False\n    return True", "subfield": "Integer Properties", "tool_name": "is_square_free", "tool_type": "function", "description": "Check if a number is square-free (not divisible by any perfect square other than 1).", "docstring": "Check if a number is square-free (not divisible by any perfect square other than 1).\n    \n    Parameters:\n    - n: int, the number to check\n    \n    Returns:\n    - bool, True if n is square-free, False otherwise\n    \n    Examples:\n    >>> is_square_free(30)\n    True\n    >>> is_square_free(12)\n    False", "Freq": 2, "TSR": 1}, {"tool": "def count_digit(n, digit):\n    \n    return str(n).count(str(digit))", "subfield": "Integer Properties", "tool_name": "count_digit", "tool_type": "function", "description": "Count occurrences of a specific digit in an integer.", "docstring": "Count occurrences of a specific digit in an integer.\n    \n    Parameters:\n        n (int): Integer to search within.\n        digit (int): Digit to count.\n        \n    Returns:\n        int: Number of times digit occurs in n.\n    \n    Examples:\n        >>> count_digit(1223, 2)\n        2", "Freq": 0, "TSR": 0}, {"tool": "def integer_solution_counter(func, lower_bound, upper_bound):\n    \n    import sympy as sp\n    \n    solutions = []\n    for x in sp.solveset(func(sp.symbols('x')), domain=sp.S.Integers):\n        if lower_bound <= x <= upper_bound:\n            solutions.append(int(x))\n    \n    return len(solutions), solutions", "subfield": "Integer Properties", "tool_name": "integer_solution_counter", "tool_type": "function", "description": "Counts and lists integer solutions for a given function within specified bounds.", "docstring": "Counts and lists integer solutions for a given function within specified bounds.\n    \n    Parameters:\n        func (function): A Python function that should return a boolean.\n                         It defines the conditions under which an integer is considered a solution.\n        lower_bound (int): The lower inclusive bound of the range to test.\n        upper_bound (int): The upper inclusive bound of the range to test.\n    \n    Returns:\n        tuple: First element is the count of solutions, the second element is a list of solutions.\n    \n    Examples:\n        >>> integer_solution_counter(lambda x: x % 2 == 0, 1, 10)\n        (5, [2, 4, 6, 8, 10])\n        >>> integer_solution_counter(lambda x: x**2 <= 50, -10, 10)\n        (15, [-7, -6, -5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7])", "Freq": 1, "TSR": 0}, {"tool": "def are_consecutive(numbers):\n    \n    sorted_numbers = sorted(numbers)\n    return all((sorted_numbers[i] + 1 == sorted_numbers[i + 1]\n                for i in range(len(sorted_numbers) - 1)))", "subfield": "Integer Properties", "tool_name": "are_consecutive", "tool_type": "function", "description": "Determine if a list of numbers consists of consecutive integers.", "docstring": "Determine if a list of numbers consists of consecutive integers.\n    Parameters\n    ----------\n    numbers : list of int\n        The list of integers to check.\n    Returns\n    -------\n    bool\n        True if integers are consecutive, otherwise False.\n    Examples\n    --------\n    >>> are_consecutive([1, 2, 3, 4])\n    True\n    >>> are_consecutive([1, 2, 4])\n    False", "Freq": 0, "TSR": 0}, {"tool": "def get_divisors(number):\n    \n    return divisors(number)", "subfield": "Integer Properties", "tool_name": "get_divisors", "tool_type": "function", "description": "Get all positive divisors of a given number.", "docstring": "Get all positive divisors of a given number.\n    \n    Parameters:\n    - number (int): The number to get divisors for.\n    \n    Returns:\n    - list: A list of all positive divisors.\n    \n    Examples:\n    >>> get_divisors(12)\n    [1, 2, 3, 4, 6, 12]", "Freq": 0, "TSR": 0}, {"tool": "def count_digit_combinations(digits, length, leading_zeros=False):\n    \n    if leading_zeros:\n        return product(digits, repeat=length)\n    return product([d for d in digits if d != 0], *[digits for _ in range(length - 1)])", "subfield": "Integer Properties", "tool_name": "count_digit_combinations", "tool_type": "function", "description": "Count possible numbers of a given length with specified digit constraints and optional leading zeros.", "docstring": "Count possible numbers of a given length with specified digit constraints and optional leading zeros.\n    \n    Parameters:\n    - digits (list): Allowed digits.\n    - length (int): Desired length of numbers.\n    - leading_zeros (bool): Whether leading zeros are allowed.\n    \n    Returns:\n    Iterator over all valid number combinations as strings.\n    \n    Examples:\n    >>> len(list(count_digit_combinations([1, 2, 3], 2, leading_zeros=False)))\n    9", "Freq": 2, "TSR": 1}, {"tool": "def find_factors(number):\n    \n    return list(sympy.divisors(number))", "subfield": "Integer Properties", "tool_name": "find_factors", "tool_type": "function", "description": "Find all positive factors of a given number.", "docstring": "Find all positive factors of a given number.\n    Parameters:\n        number (int): The number to factorize.\n    Returns:\n        list: A list of all positive factors of the number.", "Freq": 1, "TSR": 0}, {"tool": "def solve_sum_of_squares(target, limit=None):\n    \n    import math\n    if limit is None:\n        limit = int(math.sqrt(target))\n    solutions = []\n    for a in range(-limit, limit + 1):\n        for b in range(-limit, limit + 1):\n            if a**2 + b**2 == target:\n                solutions.append((a, b))\n    return solutions", "subfield": "Integer Properties", "tool_name": "solve_sum_of_squares", "tool_type": "function", "description": "Find pairs of integers (a, b) such that a^2 + b^2 = target, with an optional limit on values of a and b.", "docstring": "Find pairs of integers (a, b) such that a^2 + b^2 = target, with an optional limit on values of a and b.\n    \n    Parameters:\n        target (int): The target integer sum of squares.\n        limit (int, optional): Maximum absolute value for a and b. If not specified, it uses sqrt(target).\n    \n    Returns:\n        List[Tuple[int, int]]: A list of tuples (a, b) where both a^2 + b^2 equals to the target.\n    \n    Examples:\n        # Find integer solutions for a^2 + b^2 = 50\n        print(solve_sum_of_squares(50))\n        # Find integer solutions for a^2 + b^2 = 25 with |a|,|b| <= 5\n        print(solve_sum_of_squares(25, 5))", "Freq": 2, "TSR": 2}, {"tool": "def possible_numbers(digits, length, unique=False):\n    \n    if unique:\n        return [''.join(map(str, comb)) for comb in itertools.permutations(digits, length)]\n    else:\n                return [''.join(map(str, comb)) for comb in itertools.product(digits, repeat=length)]", "subfield": "Integer Properties", "tool_name": "possible_numbers", "tool_type": "function", "description": "Generate all possible numbers of a given length from specified digits.", "docstring": "Generate all possible numbers of a given length from specified digits.\n    \n    Parameters:\n        digits (list): Possible digits to use.\n        length (int): The length of numbers to generate.\n        unique (bool): If True, all digits in the number must be unique.\n        \n    Returns:\n        list: All possible numbers as strings.\n    \n    Examples:\n        >>> possible_numbers([1, 2, 3], 2)\n        ['11', '12', '13', '21', '22', '23', '31', '32', '33']\n        >>> possible_numbers([1, 2, 3], 2, unique=True)\n        ['12', '13', '21', '23', '31', '32']", "Freq": 1, "TSR": 1}, {"tool": "def basic_integer_operations(x, operation='floor', modulus=None, check_prime=False, get_divisors=False):\n    \n    if operation == 'floor':\n        result = floor(x)\n    elif operation == 'ceil':\n        result = ceil(x)\n    else:\n        result = x\n    \n    if modulus is not None:\n        result = x % modulus\n    \n    prime_status = isprime(x) if check_prime else None\n    divisor_list = divisors(x) if get_divisors else None\n    \n    return {'result': result, 'is_prime': prime_status, 'divisors': divisor_list}", "subfield": "Integer Properties", "tool_name": "basic_integer_operations", "tool_type": "function", "description": "Perform basic operations on an integer including floor, ceiling, modular arithmetic, \n    checking for primality, and getting divisors.", "docstring": "Perform basic operations on an integer including floor, ceiling, modular arithmetic, \n    checking for primality, and getting divisors.\n    \n    Parameters:\n        x (int): The integer on which to perform operations.\n        operation (str, optional): The type of mathematical floor/ceiling operation (`floor`, `ceil`). Defaults to 'floor'.\n        modulus (int, optional): For modulus operation. If provided, function returns x % modulus.\n        check_prime (bool, optional): If True, checks whether the integer is prime. Defaults to False.\n        get_divisors (bool, optional): If True, returns all divisors of x. Defaults to False.\n    \n    Returns:\n        Various outputs depending on inputs: transformed integer, boolean for primality, list of divisors.\n    \n    Examples:\n        >> basic_integer_operations(17.7, 'floor')\n        17\n        >> basic_integer_operations(28, modulus=5)\n        3\n        >> basic_integer_operations(11, check_prime=True)\n        True\n        >> basic_integer_operations(12, get_divisors=True)\n        [1, 2, 3, 4, 6, 12]", "Freq": 0, "TSR": 0}, {"tool": "def prime_factors(n):\n    \n    return sympy.ntheory.factorint(n).items()", "subfield": "Integer Properties", "tool_name": "prime_factors", "tool_type": "function", "description": "Compute the prime factors of an integer.", "docstring": "Compute the prime factors of an integer.\n    Parameters:\n    n : int\n        The integer to be factorized.\n    Returns:\n    list\n        A list of tuples representing prime factors and their exponents.\n    Examples:\n    >>> prime_factors(18)\n    [(2, 1), (3, 2)]", "Freq": 0, "TSR": 0}, {"tool": "def generate_arithmetic_sequence(start, diff, n):\n    \n    return [start + i * diff for i in range(n)]", "subfield": "Integer Properties", "tool_name": "generate_arithmetic_sequence", "tool_type": "function", "description": "Generate an arithmetic sequence from a start value with a fixed difference over n terms.", "docstring": "Generate an arithmetic sequence from a start value with a fixed difference over n terms.\n    \n    Parameters:\n    start : int\n        Starting value of the arithmetic sequence.\n    diff : int\n        Common difference between consecutive terms.\n    n : int\n        Number of terms to generate.\n    \n    Returns:\n    list\n        The list of n terms in the arithmetic sequence.\n    \n    Example:\n    >>> generate_arithmetic_sequence(1, 3, 4)\n    [1, 4, 7, 10]", "Freq": 1, "TSR": 0}, {"tool": "def filter_triangles(triangles, perimeter=None, odd_even=None):\n    \n    filtered = set()\n    for a, b, c in triangles:\n        if perimeter is not None and (a + b + c) != perimeter:\n            continue\n        if odd_even is not None:\n            if odd_even == 'odd' and (a % 2 == 0 or b % 2 == 0 or c % 2 == 0):\n                continue\n            elif odd_even == 'even' and (a % 2 != 0 or b % 2 != 0 or c % 2 != 0):\n                continue\n        filtered.add((a, b, c))\n    \n    return filtered", "subfield": "Integer Properties", "tool_name": "filter_triangles", "tool_type": "function", "description": "Filters a set of triangles based on the perimeter and/or parity conditions.", "docstring": "Filters a set of triangles based on the perimeter and/or parity conditions.\n    Parameters:\n    - triangles (set of tuples): Set of tuples (a, b, c) representing sides of the triangles.\n    - perimeter (int, optional): The exact perimeter that the triangles must have.\n    - odd_even (str, optional): 'odd' for triangles with all odd sides; 'even' for all even sides; None for no parity filter.\n    \n    Returns:\n    - set of tuples: a set of triangles that pass all filters.\n    \n    Example:\n    >>> triangles = {(3, 4, 5), (2, 3, 4), (5, 5, 5)}\n    >>> filter_triangles(triangles, perimeter=12)\n    {(3, 4, 5)}\n    >>> filter_triangles(triangles, odd_even='odd')\n    {(5, 5, 5)}", "Freq": 4, "TSR": 3}, {"tool": "def list_perfect_cubes(limit):\n    \n    cubes = [i**3 for i in range(int(round(limit ** (1/3))) + 1)]\n    return cubes", "subfield": "Integer Properties", "tool_name": "list_perfect_cubes", "tool_type": "function", "description": "Generates all perfect cubes less than or equal to the given limit.", "docstring": "Generates all perfect cubes less than or equal to the given limit.\n    \n    Parameters\n    ----------\n    limit : int\n        The upper limit for the perfect cubes.\n    Returns\n    -------\n    list\n        A list of all perfect cubes up to `limit`.\n    Examples\n    --------\n    >>> list_perfect_cubes(30)\n    [0, 1, 8, 27]", "Freq": 0, "TSR": 0}, {"tool": "def count_valid_numbers_in_range(start, end, criteria_func):\n    \n    return sum(1 for n in range(start, end + 1) if criteria_func(n))", "subfield": "Integer Properties", "tool_name": "count_valid_numbers_in_range", "tool_type": "function", "description": "Count integers within a specified range that meet a given criteria.", "docstring": "Count integers within a specified range that meet a given criteria.\n    \n    Parameters:\n        start (int): The start of the range (inclusive).\n        end (int): The end of the range (inclusive).\n        criteria_func (function): A function that takes an integer and returns a boolean.\n    \n    Returns:\n        int: The count of integers satisfying the criteria within the specified range.\n    \n    Examples:\n        >>> def is_even(n):\n        ...     return n % 2 == 0\n        >>> count_valid_numbers_in_range(1, 10, is_even)\n        5", "Freq": 0, "TSR": 0}, {"tool": "def calculate_gcd(num1, num2):\n    \n    return sympy.gcd(num1, num2)", "subfield": "Integer Properties", "tool_name": "calculate_gcd", "tool_type": "function", "description": "Calculate the greatest common divisor of two numbers.", "docstring": "Calculate the greatest common divisor of two numbers.\n    Parameters:\n        num1 (int): First integer.\n        num2 (int): Second integer.\n    Returns:\n        int: The greatest common divisor of num1 and num2.", "Freq": 0, "TSR": 0}, {"tool": "def check_digit_inclusion(n, include_digits=None, exclude_digits=None):\n    \n    str_n = str(n)\n    if include_digits and not all(str(digit) in str_n for digit in include_digits):\n        return False\n    if exclude_digits and any(str(digit) in str_n for digit in exclude_digits):\n        return False\n    return True", "subfield": "Integer Properties", "tool_name": "check_digit_inclusion", "tool_type": "function", "description": "Check whether the integer `n` includes or excludes certain digits.", "docstring": "Check whether the integer `n` includes or excludes certain digits.\n    \n    Parameters:\n        n (int): The integer to check.\n        include_digits (set of int, optional): Digits that should be included in `n`.\n        exclude_digits (set of int, optional): Digits that should be excluded from `n`.\n    \n    Returns:\n        bool: True if `n` meets the criteria, False otherwise.\n    \n    Examples:\n        >>> check_digit_inclusion(567, include_digits={5, 6}, exclude_digits={1})\n        True\n        >>> check_digit_inclusion(560, include_digits={1}, exclude_digits={0})\n        False", "Freq": 0, "TSR": 0}, {"tool": "def integer_floor(x):\n    \n    return math.floor(x)", "subfield": "Integer Properties", "tool_name": "integer_floor", "tool_type": "function", "description": "Find the floor of a real number, rounding down to the nearest integer.", "docstring": "Find the floor of a real number, rounding down to the nearest integer.\n    \n    Parameters:\n    x : float\n        The real number to find the floor of.\n    \n    Returns:\n    int\n        The floor of x.\n    \n    Example:\n    >>> integer_floor(3.7)\n    3\n    >>> integer_floor(-1.2)\n    -2", "Freq": 0, "TSR": 0}, {"tool": "def list_perfect_squares(limit):\n    \n    squares = [i*i for i in range(int(math.sqrt(limit)) + 1)]\n    return squares", "subfield": "Integer Properties", "tool_name": "list_perfect_squares", "tool_type": "function", "description": "Generates all perfect squares less than or equal to the given limit.", "docstring": "Generates all perfect squares less than or equal to the given limit.\n    \n    Parameters\n    ----------\n    limit : int\n        The upper limit for the perfect squares.\n    Returns\n    -------\n    list\n        A list of all perfect squares up to `limit`.\n    Examples\n    --------\n    >>> list_perfect_squares(30)\n    [0, 1, 4, 9, 16, 25]", "Freq": 0, "TSR": 0}, {"tool": "def is_divisible(a, b):\n    \n    if b == 0:\n        raise ValueError(\"Division by zero is not supported.\")\n    return a % b == 0", "subfield": "Integer Properties", "tool_name": "is_divisible", "tool_type": "function", "description": "Check if integer a is divisible by integer b.", "docstring": "Check if integer a is divisible by integer b.\n    Parameters:\n        a (int): The dividend.\n        b (int): The divisor.\n    Returns:\n        bool: True if a is divisible by b, False otherwise.", "Freq": 0, "TSR": 0}, {"tool": "def solve_linear_inequality(a, b, c):\n    \n    if a == 0:\n        if b <= c:\n            return float('-inf'), float('inf')  # Indeterminate case or all x satisfy\n        else:\n            return ()  # No solution\n    x = (c - b) / a\n    if a > 0:\n        return float('-inf'), x\n    else:\n        return x, float('inf')", "subfield": "Integer Properties", "tool_name": "solve_linear_inequality", "tool_type": "function", "description": "Solve a linear inequality of the form a*x + b <= c", "docstring": "Solve a linear inequality of the form a*x + b <= c\n    \n    Parameters:\n    a : int\n        The coefficient of x.\n    b : int\n        Constant term.\n    c : int\n        Right side of the inequality.\n    \n    Returns:\n    tuple\n        The range of x that satisfies the inequality.\n    \n    Example:\n    >>> solve_linear_inequality(3, -6, 12)\n    (-inf, 6.0)", "Freq": 1, "TSR": 0}, {"tool": "def polynomial_integer_values(polynomial, values):\n    \n    results = {}\n    for val in values:\n        result = polynomial.subs(sympy.Symbol('x'), val)\n        results[val] = {'value': result, 'is_integer': sympy.sympify(result).is_integer}\n    return results", "subfield": "Integer Properties", "tool_name": "polynomial_integer_values", "tool_type": "function", "description": "Evaluate a polynomial at given values and check if results are integers.", "docstring": "Evaluate a polynomial at given values and check if results are integers.\n    Parameters:\n        polynomial (sympy.Poly): The polynomial to evaluate.\n        values (list): Values at which to evaluate the polynomial.\n    Returns:\n        dict: A dictionary mapping values to their evaluation results and whether those are integers.", "Freq": 0, "TSR": 0}, {"tool": "def integer_properties_checker(n, check='prime'):\n    \n    if check == 'prime':\n        return sympy.isprime(n)\n    elif check == 'perfect_square':\n        return n == sympy.Integer(sympy.sqrt(n))**2\n    else:\n        raise ValueError(\"Unsupported check type provided. Supported types are 'prime', 'perfect_square'.\")", "subfield": "Integer Properties", "tool_name": "integer_properties_checker", "tool_type": "function", "description": "Check specific properties of an integer such as primality or perfect square.", "docstring": "Check specific properties of an integer such as primality or perfect square.\n    Parameters:\n    n (int): the integer to check\n    check (str): What to check, supported values are 'prime', 'perfect_square'\n    Returns:\n    bool: True if the property is satisfied, False otherwise\n    Examples:\n    >>> integer_properties_checker(29, 'prime')\n    True\n    >>> integer_properties_checker(28, 'perfect_square')\n    False", "Freq": 0, "TSR": 0}, {"tool": "def arithmetic_sum(a, d, n):\n    \n    return n * (2 * a + (n - 1) * d) // 2", "subfield": "Integer Properties", "tool_name": "arithmetic_sum", "tool_type": "function", "description": "Calculate the sum of the first `n` terms of an arithmetic sequence.", "docstring": "Calculate the sum of the first `n` terms of an arithmetic sequence.\n    Parameters\n    ----------\n    a : int\n        The first term of the sequence.\n    d : int\n        The common difference of the sequence.\n    n : int\n        The number of terms.\n    Returns\n    -------\n    int\n        The sum of the first `n` terms.\n    Examples\n    --------\n    >>> arithmetic_sum(1, 1, 100)  # Sum of first 100 natural numbers\n    5050\n    >>> arithmetic_sum(2, 2, 10)  # Sum of first 10 even numbers starting from 2\n    110", "Freq": 0, "TSR": 0}, {"tool": "def is_abundant(n):\n    \n    proper_factors = sum(all_factors(n)[:-1])\n    return proper_factors > n", "subfield": "Integer Properties", "tool_name": "is_abundant", "tool_type": "function", "description": "Determine if a number is abundant (sum of proper divisors greater than the number itself).", "docstring": "Determine if a number is abundant (sum of proper divisors greater than the number itself).\n    Parameters:\n    n : int\n        The number to check for abundance.\n    Returns:\n    bool\n        True if n is abundant, False otherwise.\n    Examples:\n    >>> is_abundant(12)\n    True", "Freq": 1, "TSR": 0}, {"tool": "def count_integers_within_bounds(lower_bound, upper_bound, inclusive=True):\n    \n    if inclusive:\n        return (upper_bound - lower_bound + 1)\n    else:\n        return (upper_bound - lower_bound - 1)", "subfield": "Integer Properties", "tool_name": "count_integers_within_bounds", "tool_type": "function", "description": "Calculate the total count of integers between two bounds.", "docstring": "Calculate the total count of integers between two bounds.\n    Parameters:\n    lower_bound (int): the lower bound of the range\n    upper_bound (int): the upper bound of the range\n    inclusive (bool): if True, include both bounds, else exclude bounds\n    \n    Returns:\n    int: count of integers within the specified bounds\n    Examples:\n    >>> count_integers_within_bounds(1, 10)\n    10\n    >>> count_integers_within_bounds(1, 10, inclusive=False)\n    8", "Freq": 0, "TSR": 0}, {"tool": "def find_integers_in_range(start, end, condition=lambda x: True):\n    \n    return [n for n in range(start, end + 1) if condition(n)]", "subfield": "Integer Properties", "tool_name": "find_integers_in_range", "tool_type": "function", "description": "Generates a list of integers within a specified range that meet a certain condition.", "docstring": "Generates a list of integers within a specified range that meet a certain condition.\n    \n    Parameters:\n        start (int): The start of the range (inclusive).\n        end (int): The end of the range (inclusive).\n        condition (callable): A function that takes an integer as an argument and returns\n                              a boolean indicating whether the integer meets the specified condition.\n                              Default checks if every integer in the range is valid.\n    \n    Returns:\n        List[int]: A list containing all integers in the range [start, end] that meet the condition.\n    \n    Examples:\n        # Find all integers between 1 and 100\n        print(find_integers_in_range(1, 100))\n        # Find all even integers between 1 and 100\n        print(find_integers_in_range(1, 100, lambda x: x % 2 == 0))\n        # Find all prime integers between 1 and 100\n        from sympy import isprime\n        print(find_integers_in_range(1, 100, isprime))", "Freq": 2, "TSR": 2}, {"tool": "def integer_ceiling(x):\n    \n    return math.ceil(x)", "subfield": "Integer Properties", "tool_name": "integer_ceiling", "tool_type": "function", "description": "Find the ceiling of a real number, rounding up to the nearest integer.", "docstring": "Find the ceiling of a real number, rounding up to the nearest integer.\n    \n    Parameters:\n    x : float\n        The real number to find the ceiling of.\n    \n    Returns:\n    int\n        The ceiling of x.\n    \n    Example:\n    >>> integer_ceiling(3.2)\n    4\n    >>> integer_ceiling(-2.3)\n    -2", "Freq": 0, "TSR": 0}, {"tool": "def calculate_lcm(num1, num2):\n    \n    return sympy.lcm(num1, num2)", "subfield": "Integer Properties", "tool_name": "calculate_lcm", "tool_type": "function", "description": "Calculate the least common multiple of two numbers.", "docstring": "Calculate the least common multiple of two numbers.\n    Parameters:\n        num1 (int): First integer.\n        num2 (int): Second integer.\n    Returns:\n        int: The least common multiple of num1 and num2.", "Freq": 0, "TSR": 0}, {"tool": "def polynomial_coefficients_integer(polynomial):\n    \n    return all(coeff.is_Integer for coeff in polynomial.all_coeffs())", "subfield": "Integer Properties", "tool_name": "polynomial_coefficients_integer", "tool_type": "function", "description": "Check if a polynomial expression has all integer coefficients.", "docstring": "Check if a polynomial expression has all integer coefficients.\n    Parameters:\n        polynomial (sympy.Poly): A polynomial expression.\n    Returns:\n        bool: True if all coefficients of the polynomial are integers, False otherwise.", "Freq": 0, "TSR": 0}, {"tool": "def evaluate_expression(values, operation='sum'):\n    \n    import functools\n    import operator\n    if operation == 'sum':\n        return sum(values)\n    elif operation == 'product':\n        return functools.reduce(operator.mul, values, 1)\n    else:\n        raise ValueError(\"Unsupported operation type. Supported types: 'sum', 'product'\")", "subfield": "Integer Properties", "tool_name": "evaluate_expression", "tool_type": "function", "description": "Evaluate a mathematical expression with a list of values based on operation type like sum or product.", "docstring": "Evaluate a mathematical expression with a list of values based on operation type like sum or product.\n    \n    Parameters:\n    values (list[int]): List of integer values.\n    operation (str): Type of operation ('sum', 'product').\n    \n    Returns:\n    int: Result of the operation.\n    \n    Example:\n    >>> evaluate_expression([1, 3, 5], 'sum')\n    9\n    >>> evaluate_expression([1, 3, 5], 'product')\n    15", "Freq": 0, "TSR": 0}, {"tool": "def polynomial_factors(f, var):\n    \n    from sympy import factor_list\n    return factor_list(f, gens=var)", "subfield": "Integer Properties", "tool_name": "polynomial_factors", "tool_type": "function", "description": "Find the factors of a polynomial expression.", "docstring": "Find the factors of a polynomial expression.\n    Parameters:\n    - f (sympy.Expr): Polynomial expression.\n    - var (sympy.Symbol): The variable in the polynomial.\n    Returns:\n    - List of factors.\n    Examples:\n    - polynomial_factors(x**2 - 1, x) -> [x - 1, x + 1]", "Freq": 0, "TSR": 0}], "Powers and Roots": [{"tool": "def power_mod(base, exponent, mod):\n    \n    return pow(base, exponent, mod)", "subfield": "Powers and Roots", "tool_name": "power_mod", "tool_type": "function", "description": "Calculate the base raised to the exponent modulo mod.", "docstring": "Calculate the base raised to the exponent modulo mod.\n    \n    Parameters:\n    base (int): The base number.\n    exponent (int): The power to which the base is raised.\n    mod (int): The modulus to use for the calculation.\n    \n    Returns:\n    int: The result of (base ** exponent) % mod\n    \n    Examples:\n    >>> power_mod(2, 5, 3)\n    2\n    >>> power_mod(3, 2, 4)\n    1", "Freq": 3, "TSR": 3}, {"tool": "def compute_power(base, exponent):\n    \n    return base ** exponent", "subfield": "Powers and Roots", "tool_name": "compute_power", "tool_type": "function", "description": "Computes the power of a given base raised to an exponent.", "docstring": "Computes the power of a given base raised to an exponent.\n    \n    Parameters:\n    - base (int or float or complex): The base of the exponentiation.\n    - exponent (int or float or complex): The exponent to which the base is raised.\n    \n    Returns:\n    - int or float or complex: The result of base ** exponent.\n    \n    Example:\n    >>> compute_power(2, 3)\n    8\n    >>> compute_power(3 + 4j, 2)\n    (5+24j)", "Freq": 2, "TSR": 2}, {"tool": "def estimate_square_root(n):\n    \n    return int(n**0.5)", "subfield": "Powers and Roots", "tool_name": "estimate_square_root", "tool_type": "function", "description": "Estimating the square root of n to the nearest integer.", "docstring": "Estimating the square root of n to the nearest integer.\n    Parameters:\n    n (float): The number to take the root from.\n    Returns:\n    int: The nearest integer of the square root of n.\n    Example:\n     >>> estimate_square_root(200)\n    14", "Freq": 1, "TSR": 1}, {"tool": "def simplify_expression_with_root(base, exponent, root_degree):\n    \n    return base ** (exponent / root_degree)", "subfield": "Powers and Roots", "tool_name": "simplify_expression_with_root", "tool_type": "function", "description": "Simplify an expression involving roots and exponents.", "docstring": "Simplify an expression involving roots and exponents.\n    \n    Parameters:\n    base (int or float): The base number.\n    exponent (int): The exponent, can be negative for roots.\n    root_degree (int): The degree of the root to apply.\n    \n    Returns:\n    float: The simplified result of (base ** (exponent / root_degree)).\n    \n    Examples:\n    >>> simplify_expression_with_root(8, 1, 3)\n    2.0\n    >>> simplify_expression_with_root(16, 1, 4)\n    2.0", "Freq": 1, "TSR": 1}, {"tool": "def compute_nth_root(n, r):\n    \n    return r**(1/n)", "subfield": "Powers and Roots", "tool_name": "compute_nth_root", "tool_type": "function", "description": "Computes the nth root of a number r.", "docstring": "Computes the nth root of a number r.\n    Parameters:\n    n (int): The root to compute.\n    r (float): The number to take the root from.\n    Returns:\n    float: The nth root of r.\n    Example:\n    >>> compute_nth_root(3, 27)\n    3.0", "Freq": 4, "TSR": 3}, {"tool": "def perfect_squares_in_range(start, end):\n    \n    squares = []\n    for num in range(start, end+1):\n        root = math.sqrt(num)\n        if int(root + 0.5) ** 2 == num:\n            squares.append(num)\n    return squares", "subfield": "Powers and Roots", "tool_name": "perfect_squares_in_range", "tool_type": "function", "description": "Find all perfect squares within a range.", "docstring": "Find all perfect squares within a range.\n    Parameters:\n    start (int): the start of the range.\n    end (int): the end of the range.\n    Returns:\n    list: List of all perfect squares within the range.\n    Example:\n    >>> perfect_squares_in_range(1, 10)\n    [1, 4, 9]", "Freq": 0, "TSR": 0}, {"tool": "def list_powers_within_range(min_val, max_val, power):\n    \n    from math import pow\n    n = 1\n    results = []\n    while pow(n, power) <= max_val:\n        if pow(n, power) >= min_val:\n            results.append(int(pow(n, power)))\n        n += 1\n    return results", "subfield": "Powers and Roots", "tool_name": "list_powers_within_range", "tool_type": "function", "description": "Generates a list of numbers that are perfect powers (such as squares, cubes) within a specified range.", "docstring": "Generates a list of numbers that are perfect powers (such as squares, cubes) within a specified range.\n    \n    Parameters:\n    min_val (int): Minimum value of the range.\n    max_val (int): Maximum value of the range.\n    power (int): The power to consider (2 for squares, 3 for cubes, etc.)\n    \n    Returns:\n    list: A list of integers that are perfect powers within the given range.\n    \n    Examples:\n    >>> list_powers_within_range(1, 100, 2)\n    [1, 4, 9, 16, 25, 36, 49, 64, 81, 100]\n    \n    >>> list_powers_within_range(1, 100, 3)\n    [1, 8, 27, 64]", "Freq": 3, "TSR": 2}, {"tool": "def calculate_root(value, root_degree, symbolic=False):\n    \n    if symbolic:\n        from sympy import root, N\n        return root(value, root_degree)\n    else:\n        from math import pow\n        return pow(value, 1 / root_degree)", "subfield": "Powers and Roots", "tool_name": "calculate_root", "tool_type": "function", "description": "Calculates the nth root of a specified number and optionally returns a symbolic expression.", "docstring": "Calculates the nth root of a specified number and optionally returns a symbolic expression.\n    Parameters:\n    value (float or int): The number from which to extract the root.\n    root_degree (int): The degree of the root (e.g., 2 for square root, 3 for cube root).\n    symbolic (bool): Whether to return the result as a symbolic expression (default is False).\n    \n    Returns:\n    float or sympy.core.expr.Expr: The numerical or symbolic nth root of the value.\n    Examples:\n    >>> calculate_root(16, 2)\n    4.0\n    >>> calculate_root(27, 3, symbolic=True)\n    3", "Freq": 0, "TSR": 0}, {"tool": "def compute_square_root(n):\n    \n    if n < 0:\n        raise ValueError(\"Cannot compute square root of a negative number.\")\n    return math.sqrt(n)", "subfield": "Powers and Roots", "tool_name": "compute_square_root", "tool_type": "function", "description": "Compute the square root of a number.", "docstring": "Compute the square root of a number.\n    \n    Parameters:\n        n (float|int): The number to find the square root of. Must be non-negative.\n        \n    Returns:\n        float: The square root of the number.\n    \n    Examples:\n        >>> compute_square_root(16)\n        4.0\n        >>> compute_square_root(15)\n        3.872983346207417", "Freq": 0, "TSR": 0}, {"tool": "def calculate_square_and_square_root(n):\n    \n    return n**2, sqrt(n)", "subfield": "Powers and Roots", "tool_name": "calculate_square_and_square_root", "tool_type": "function", "description": "Find the square and square root of n.", "docstring": "Find the square and square root of n.\n    Parameters:\n    n (int): Integer input to be checked.\n    Returns:\n    tuple: a tuple of square and square root of n.\n    Example:\n    >>> calculate_square_and_square_root(4)\n    (16, 2.0)", "Freq": 0, "TSR": 0}, {"tool": "def nth_root_of_unity(degree, k=1):\n    \n    return cmath.exp(2j * cmath.pi * k / degree)", "subfield": "Powers and Roots", "tool_name": "nth_root_of_unity", "tool_type": "function", "description": "Computes the k-th nth root of unity using Euler's formula.", "docstring": "Computes the k-th nth root of unity using Euler's formula.\n    \n    Parameters:\n    - degree (int): The degree of the root of unity.\n    - k (int): Specifies which nth root of unity to compute.\n    \n    Returns:\n    - complex: The k-th nth root of unity.\n    \n    Example:\n    >>> nth_root_of_unity(4)\n    (1+0j)\n    >>> nth_root_of_unity(3, 1)\n    (-0.4999999999999998+0.8660254037844387j)", "Freq": 0, "TSR": 0}, {"tool": "def find_units_digit(base, exponent):\n    \n    # Only last digit of base raised to the power affects the unit's digit.\n    return (base % 10) ** exponent % 10", "subfield": "Powers and Roots", "tool_name": "find_units_digit", "tool_type": "function", "description": "Find the unit's digit of a number raised to an exponent.", "docstring": "Find the unit's digit of a number raised to an exponent.\n    \n    Parameters:\n    base (int): The base number.\n    exponent (int): The exponent.\n    \n    Returns:\n    int: The unit's digit.\n    \n    Examples:\n    >>> find_units_digit(12, 2)\n    4\n    >>> find_units_digit(7, 3)\n    3", "Freq": 1, "TSR": 1}, {"tool": "def compute_cube_root(n):\n    \n    if n < 0:\n        return -(-n) ** (1. / 3)\n    return n ** (1. / 3)", "subfield": "Powers and Roots", "tool_name": "compute_cube_root", "tool_type": "function", "description": "Compute the cube root of a number.", "docstring": "Compute the cube root of a number.\n    \n    Parameters:\n        n (float|int): The number to find the cube root of.\n        \n    Returns:\n        float: The cube root of the number.\n    \n    Examples:\n        >>> compute_cube_root(27)\n        3.0\n        >>> compute_cube_root(-8)\n        -2.0", "Freq": 2, "TSR": 2}, {"tool": "def prime_factorization(n):\n    \n    import sympy\n    factors = sympy.factorint(n)\n    return factors", "subfield": "Powers and Roots", "tool_name": "prime_factorization", "tool_type": "function", "description": "Perform prime factorization of a number.\n    Parameter:\n    n (int): An integer to factorize into primes.\n    Returns:\n    factors (dict): A dictionary where the keys are prime factors and values are their frequencies in the factorization.\n    Example:\n    >>> prime_factorization(20)\n    {2: 2, 5: 1}", "docstring": "Perform prime factorization of a number.\n    Parameter:\n    n (int): An integer to factorize into primes.\n    Returns:\n    factors (dict): A dictionary where the keys are prime factors and values are their frequencies in the factorization.\n    Example:\n    >>> prime_factorization(20)\n    {2: 2, 5: 1}", "Freq": 0, "TSR": 0}, {"tool": "def calculate_root(n, degree):\n    \n    import numpy as np\n    result = np.power(n, 1.0/degree)\n    return result", "subfield": "Powers and Roots", "tool_name": "calculate_root", "tool_type": "function", "description": "Calculate the nth root of a number.", "docstring": "Calculate the nth root of a number.\n    Parameters:\n    n (int, float): The base number.\n    degree (int, float): The degree of root to be calculated.\n    Returns:\n    result (int, float): The calculated nth root.\n    Example:\n    >>> calculate_root(81, 4)\n    3.0", "Freq": 0, "TSR": 0}, {"tool": "def simplify_expression(expression):\n    \n    from sympy import simplify, sympify\n    expr = sympify(expression)\n    return simplify(expr)", "subfield": "Powers and Roots", "tool_name": "simplify_expression", "tool_type": "function", "description": "Simplifies mathematical expressions involving powers and roots using symbolic math.", "docstring": "Simplifies mathematical expressions involving powers and roots using symbolic math.\n    \n    Parameters:\n    expression (str): The mathematical expression in string form to be simplified.\n    \n    Returns:\n    sympy.core.expr.Expr: The simplified expression.\n    \n    Examples:\n    >>> str(simplify_expression(\"sqrt(x)**2\"))\n    'x'\n    >>> str(simplify_expression(\"x**3 * x**4\"))\n    'x**7'", "Freq": 0, "TSR": 0}, {"tool": "def simplfy_square_root(n):\n    \n    return sqrt(n)", "subfield": "Powers and Roots", "tool_name": "simplfy_square_root", "tool_type": "function", "description": "Find the simplified form of square root of n.", "docstring": "Find the simplified form of square root of n.\n    Parameters:\n    n (int): Integer input to be checked.\n    Returns:\n    str: Simplified form of square root of n.\n    Example:\n    >>> simplify_square_root(50)\n    '5*sqrt(2)'", "Freq": 0, "TSR": 0}, {"tool": "def simplify_radical_expression(a, b):\n    \n    factor = math.gcd(a, b)\n    a //= factor\n    b //= factor\n    sqrt_a = int(math.sqrt(a))\n    sqrt_b = int(math.sqrt(b))\n    if sqrt_a ** 2 == a and sqrt_b ** 2 == b:\n        return f\"{sqrt_a * sqrt_b}\"\n    elif sqrt_a ** 2 == a:\n        return f\"{sqrt_a}*sqrt({b})\"\n    elif sqrt_b ** 2 == b:\n        return f\"sqrt({a})/{sqrt_b}\"\n    else:\n        return f\"sqrt({a}/{b})\"", "subfield": "Powers and Roots", "tool_name": "simplify_radical_expression", "tool_type": "function", "description": "Simplifies the radical expression sqrt(a / b).", "docstring": "Simplifies the radical expression sqrt(a / b).\n    \n    Parameters:\n        a (int): The numerator.\n        b (int): The denominator.\n    \n    Returns:\n        str: A string representing the simplified radical form.\n    \n    Examples:\n        >>> simplify_radical_expression(50, 2)\n        '5*sqrt(2)'\n        >>> simplify_radical_expression(18, 9)\n        'sqrt(2)'", "Freq": 0, "TSR": 0}, {"tool": "def find_pattern(seq):\n    \n    # Iterate over lengths of potential repeats\n    for i in range(1, len(seq)//2 + 1):\n        if len(seq) % i == 0: # Repeat length must divide sequence length\n            pattern = seq[:i]\n            if pattern * (len(seq) // i) == seq:\n                return pattern\n    return []", "subfield": "Powers and Roots", "tool_name": "find_pattern", "tool_type": "function", "description": "Detect a pattern in a sequence.\n    Parameter:\n    seq (list): Sequence of numbers in which to detect a pattern.\n    Returns:\n    pattern (list): Detected repeating pattern. Return empty list if no pattern is found.\n    Example:\n    >>> find_pattern([1, 2, 3, 1, 2, 3, 1, 2, 3])\n    [1, 2, 3]", "docstring": "Detect a pattern in a sequence.\n    Parameter:\n    seq (list): Sequence of numbers in which to detect a pattern.\n    Returns:\n    pattern (list): Detected repeating pattern. Return empty list if no pattern is found.\n    Example:\n    >>> find_pattern([1, 2, 3, 1, 2, 3, 1, 2, 3])\n    [1, 2, 3]", "Freq": 0, "TSR": 0}], "Fractions and Decimals": [{"tool": "def add_fractions(frac1, frac2):\n    \n    return frac1 + frac2", "subfield": "Fractions and Decimals", "tool_name": "add_fractions", "tool_type": "function", "description": "Add two fractions and return the result in its simplest form.", "docstring": "Add two fractions and return the result in its simplest form.\n    Parameters:\n    - frac1 (Fraction): First fraction.\n    - frac2 (Fraction): Second fraction.\n    Returns:\n    - Fraction: Sum of the two fractions in simplest form.\n    Examples:\n    >>> add_fractions(Fraction(1, 3), Fraction(1, 6))\n    Fraction(1, 2)\n    >>> add_fractions(Fraction(1, 2), Fraction(1, 3))\n    Fraction(5, 6)", "Freq": 0, "TSR": 0}, {"tool": "def simplify_fraction(numerator, denominator):\n    \n    return Rational(numerator, denominator)", "subfield": "Fractions and Decimals", "tool_name": "simplify_fraction", "tool_type": "function", "description": "Simplify a fraction using its numerator and denominator.", "docstring": "Simplify a fraction using its numerator and denominator.\n    Parameters:\n    - numerator (int): the numerator of the fraction.\n    - denominator (int): the denominator of the short division.\n    Returns:\n    - sympy.Rational: the simplified fraction.\n    Examples:\n    >>> simplify_fraction(10, 100)\n    1/10\n    >>> simplify_fraction(22, 7)\n    22/7", "Freq": 2, "TSR": 2}, {"tool": "def convert_repeating_decimal_to_fraction(decimal_str):\n    \n    if '...' not in decimal_str:\n        # No repeating part, simple conversion        \n        return sympy.Rational(decimal_str)\n    \n    non_repeating, repeating = decimal_str.replace('...', '').split('.')\n    repeat_length = len(repeating)\n    non_repeat_length = len(non_repeating) - 1  # Excludes point\n    \n    denominator = 10**repeat_length - 1\n    numerator = int(repeating) + int(non_repeating)*10**repeat_length\n    return sympy.Rational(numerator, denominator * 10**non_repeat, 10)", "subfield": "Fractions and Decimals", "tool_name": "convert_repeating_decimal_to_fraction", "tool_type": "function", "description": "Convert a repeating decimal given as a string to its simplest fractional form.", "docstring": "Convert a repeating decimal given as a string to its simplest fractional form.\n    Parameters:\n    - decimal_str (str): The repeating decimal as a string, e.g., \"0.333...\", \"1.256...\"\n    Returns:\n    - sympy.Rational: The fraction form of the repeating decimal.\n    Examples:\n    >>> convert_repeating_decimal_to_fraction('0.333...')\n    1/3\n    >>> convert_repeating_decimal_to_fraction('1.256...')\n    sympy.Rational(1256, 999) - simplified form", "Freq": 10, "TSR": 0}, {"tool": "def fraction_operations(fraction1, fraction2, operation='add'):\n    \n    if operation == 'add':\n        return fraction1 + fraction2\n    elif operation == 'subtract':\n        return fraction1 - fraction2\n    elif operation == 'multiply':\n        return fraction1 * fraction2\n    elif operation == 'divide':\n        return fraction1 / fraction2", "subfield": "Fractions and Decimals", "tool_name": "fraction_operations", "tool_type": "function", "description": "Perform operations (add, subtract, multiply, divide) on two fractions.", "docstring": "Perform operations (add, subtract, multiply, divide) on two fractions.\n    Parameters:\n    - fraction1 (sympy.Rational): First fraction operand.\n    - fraction2 (sympy.Rational): Second fraction operand.\n    - operation (str): Operation to perform ('add', 'subtract', 'multiply', 'divide').\n    Returns:\n    - sympy.Rational: The result of the operation.\n    Examples:\n    >>> fraction_operations(Rational(1, 3), Rational(1, 6), 'add')\n    1/2\n    >>> fraction_operations(Rational(1, 2), Rational(1, 4), 'subtract')\n    1/4", "Freq": 0, "TSR": 0}, {"tool": "def does_fraction_terminate(numerator, denominator):\n    \n    # Prime factorization only contains 2's or 5's\n    while denominator % 2 == 0:\n        denominator //= 2\n    while denominator % 5 == 0:\n        denominator //= 5\n    return denominator == 1", "subfield": "Fractions and Decimals", "tool_name": "does_fraction_terminate", "tool_type": "function", "description": "Determines if a fraction will terminate or have infinite repeating decimals.", "docstring": "Determines if a fraction will terminate or have infinite repeating decimals.\n    \n    Parameters:\n    - numerator (int): Numerator of the fraction.\n    - denominator (int): Denominator of the fraction.\n    \n    Returns:\n    - bool: True if the fraction terminates, False otherwise.\n    \n    Examples:\n    - does_fraction_terminate(1, 2) --> True\n    - does_fraction_terminate(1, 3) --> False", "Freq": 1, "TSR": 0}, {"tool": "def prime_factorization(n):\n    \n    factors = []\n    for prime in primefactors(n):\n        count = 0\n        while n % prime == 0:\n            n //= prime\n            count += 1\n        factors.extend([prime] * count)\n    return factors", "subfield": "Fractions and Decimals", "tool_name": "prime_factorization", "tool_type": "function", "description": "Returns the prime factors of a given integer.", "docstring": "Returns the prime factors of a given integer.\n    Parameters:\n        n (int): The number to factorize.\n    Returns:\n        list: A list of prime factors.\n    Examples:\n        >>> prime_factorization(18)\n        [2, 3, 3]", "Freq": 0, "TSR": 0}, {"tool": "def modular_exponent(base, exponent, mod):\n    \n    return pow(base, exponent, mod)", "subfield": "Fractions and Decimals", "tool_name": "modular_exponent", "tool_type": "function", "description": "Calculate base raised to exponent modulo mod using efficient modular exponentiation.", "docstring": "Calculate base raised to exponent modulo mod using efficient modular exponentiation.\n    Parameters:\n        base (int): The base of the expression.\n        exponent (int): The exponent.\n        mod (int): The modulus for the operation.\n    Returns:\n        int: The result of (base^exponent) % mod.\n    Examples:\n        >>> modular_exponent(2, 10, 1000)\n        24", "Freq": 1, "TSR": 0}, {"tool": "def is_prime(num):\n    \n    return isprime(num)", "subfield": "Fractions and Decimals", "tool_name": "is_prime", "tool_type": "function", "description": "Check if a number is a prime number.", "docstring": "Check if a number is a prime number.\n    Parameters:\n        num (int): The number to check.\n    Returns:\n        bool: True if the number is a prime, else False.\n    Examples:\n        >>> is_prime(11)\n        True\n        >>> is_prime(4)\n        False", "Freq": 1, "TSR": 0}, {"tool": "def lcm(*numbers):\n    \n    return np.lcm.reduce(numbers)", "subfield": "Fractions and Decimals", "tool_name": "lcm", "tool_type": "function", "description": "Calculate the least common multiple of a series of integers.", "docstring": "Calculate the least common multiple of a series of integers.\n    Parameters:\n        numbers (int): A series of integer numbers.\n    Returns:\n        int: The least common multiple of the numbers.\n    Examples:\n        >>> lcm(5, 10, 20)\n        20", "Freq": 1, "TSR": 1}, {"tool": "def gcd(*numbers):\n    \n    return np.gcd.reduce(numbers)", "subfield": "Fractions and Decimals", "tool_name": "gcd", "tool_type": "function", "description": "Calculate the greatest common divisor of a series of integers.", "docstring": "Calculate the greatest common divisor of a series of integers.\n    Parameters:\n        numbers (int): A series of integer numbers.\n    Returns:\n        int: The greatest common divisor of the numbers.\n    Examples:\n        >>> gcd(8, 12, 16)\n        4", "Freq": 1, "TSR": 1}], "Floor Function": [{"tool": "def compute_floor(x):\n    \n    return math.floor(x)", "subfield": "Floor Function", "tool_name": "compute_floor", "tool_type": "function", "description": "Compute the floor of a given real number.", "docstring": "Compute the floor of a given real number.\n    Parameters:\n    - x (float): The number for which the floor value is to be computed.\n    Returns:\n    - int: The floor value of the input number.\n    Examples:\n    >>> compute_floor(3.7)\n    3\n    >>> compute_floor(-1.2)\n    -2", "Freq": 8, "TSR": 7}, {"tool": "def iterative_floor_application(start_value, iteration_function, iterations):\n    \n    from math import floor\n    current_value = start_value\n    for _ in range(iterations):\n        current_value = floor(iteration_function(current_value))\n    return current_value", "subfield": "Floor Function", "tool_name": "iterative_floor_application", "tool_type": "function", "description": "Repeatedly apply a transformation involving the floor function and observe the result after a defined number of iterations.", "docstring": "Repeatedly apply a transformation involving the floor function and observe the result after a defined number of iterations.\n    Parameters\n    ----------\n    start_value : float\n        Initial value where the transformation begins.\n    iteration_function : callable\n        A function that defines the transformation involving the floor to apply.\n    iterations : int\n        Number of times the iteration is applied.\n    Returns\n    -------\n    float\n        Result after applying the defined transformation the number of times specified by 'iterations'.\n    Examples\n    --------\n    >>> iterative_floor_application(4.5, lambda x: x/2, 5)\n    0.140625", "Freq": 1, "TSR": 1}, {"tool": "def calculate_floor_mixed_fraction(value):\n    \n    whole, fraction = value.split('_')\n    fractional_value = Fraction(fraction)\n    total_value = int(whole) + fractional_value\n    return int(total_value)", "subfield": "Floor Function", "tool_name": "calculate_floor_mixed_fraction", "tool_type": "function", "description": "This function is used to calculate the floor value of a mixed number.\n    The floor function is the integer part of the mixed number.", "docstring": "This function is used to calculate the floor value of a mixed number.\n    The floor function is the integer part of the mixed number.\n    Parameters:\n    value (str): Input mixed number to calculate the floor value (format \"whole_numerator/denominator\")\n    Returns:\n    int: floor of the mixed number\n    Examples:\n    >>> calculate_floor_mixed_fraction(\"1_3/2\")\n    1\n    >>> calculate_floor_mixed_fraction(\"5_1/8\")\n    5", "Freq": 0, "TSR": 0}, {"tool": "def calculate_floor_negative_fraction(value):\n    \n    fractional_part = Fraction(value)\n    return math.floor(fractional_part)", "subfield": "Floor Function", "tool_name": "calculate_floor_negative_fraction", "tool_type": "function", "description": "This function is used to calculate the floor value of a negative fraction.\n    The floor function is the integer less than the negative fraction.", "docstring": "This function is used to calculate the floor value of a negative fraction.\n    The floor function is the integer less than the negative fraction.\n    Parameters:\n    value (str): Input negative fraction to calculate the floor value (format \"-numerator/denominator\")\n    Returns:\n    int: floor of the given negative fraction.\n    Examples:\n    >>> calculate_floor_negative_fraction(\"-3/2\")\n    -2\n    >>> calculate_floor_negative_fraction(\"-1/8\")\n    -1", "Freq": 0, "TSR": 0}, {"tool": "def evaluate_floor_inequality(x, expected_value, inequality_type):\n    \n    from math import floor\n    floor_x = floor(x)\n    inequalities = {\n        '<=': floor_x <= expected_value,\n        '>=': floor_x >= expected_value,\n        '=': floor_x == expected_value,\n        '<': floor_x < expected_value,\n        '>': floor_x > expected_value\n    }\n    return inequalities[inequality_type]", "subfield": "Floor Function", "tool_name": "evaluate_floor_inequality", "tool_type": "function", "description": "Evaluate whether an inequality involving the floor of a number holds.", "docstring": "Evaluate whether an inequality involving the floor of a number holds.\n    Parameters\n    ----------\n    x : float\n        The real number input to the floor function.\n    expected_value : int\n        The integer against which the floor of x is compared.\n    inequality_type : str\n        Type of inequality used for comparison {'<=', '>=', '=', '<', '>'}.\n    Returns\n    -------\n    bool\n        True if the inequality holds, False otherwise.\n    Examples\n    --------\n    >>> evaluate_floor_inequality(5.5, 5, '=')\n    True\n    >>> evaluate_floor_inequality(3.2, 3, '<')\n    False", "Freq": 1, "TSR": 0}, {"tool": "def floor_product(a, b):\n    \n    return math.floor(a) * math.floor(b)", "subfield": "Floor Function", "tool_name": "floor_product", "tool_type": "function", "description": "Calculate the product of the floors of two numbers.", "docstring": "Calculate the product of the floors of two numbers.\n    Parameters:\n    a (float): The first number.\n    b (float): The second number.\n    Returns:\n    int: The product of the floor values of the two numbers.\n    Examples:\n    >>> floor_product(3.7, 4.1)\n    12\n    >>> floor_product(-1.2, -2.5)\n    2", "Freq": 2, "TSR": 0}, {"tool": "def enhanced_floor_arithmetic(expression, function=None):\n    \n    result = eval(expression)\n    floor_result = math.floor(result)\n    if function:\n        return function(floor_result)\n    return floor_result", "subfield": "Floor Function", "tool_name": "enhanced_floor_arithmetic", "tool_type": "function", "description": "Evaluates a complex mathematical expression potentially involving other functions,\n    and then computes the floor value of the result. Optionally, a function could be applied outside the floor.", "docstring": "Evaluates a complex mathematical expression potentially involving other functions,\n    and then computes the floor value of the result. Optionally, a function could be applied outside the floor.\n    Parameters:\n    - expression (str): The mathematical expression as a string.\n    - function (callable, optional): A function to be applied after taking the floor.\n    Returns:\n    - int: The floor value of the evaluated expression or the final result after applying another function.\n    Examples:\n    >>> enhanced_floor_arithmetic(\"math.sqrt(65)\")\n    8\n    >>> enhanced_floor_arithmetic(\"(5*3 + 2)/3\")\n    5\n    >>> enhanced_floor_arithmetic(\"3.5 + 4*1.1\")\n    7\n    >>> enhanced_floor_arithmetic(\"math.sqrt(81)\", math.sin)  # Since sin(9) = 0.412\n    0", "Freq": 0, "TSR": 0}, {"tool": "def floor_of_expression(expr):\n    \n    return math.floor(eval(expr))", "subfield": "Floor Function", "tool_name": "floor_of_expression", "tool_type": "function", "description": "Evaluate the floor of an expression, potentially including more complex operations like factorials.\n    `expr` should be a string that Python can evaluate directly using the `eval` function.", "docstring": "Evaluate the floor of an expression, potentially including more complex operations like factorials.\n    `expr` should be a string that Python can evaluate directly using the `eval` function.\n    Parameters:\n    expr (str): The string representation of the mathematical expression to floor.\n    Returns:\n    int: The floor of the evaluated expression.\n    Examples:\n    >>> floor_of_expression('5/3')\n    1\n    >>> floor_of_expression('math.sqrt(64) + 0.9')\n    8", "Freq": 1, "TSR": 1}, {"tool": "def floor_of_square_root(x):\n    \n    return math.floor(math.sqrt(x))", "subfield": "Floor Function", "tool_name": "floor_of_square_root", "tool_type": "function", "description": "Calculate the floor of the square root of a number.", "docstring": "Calculate the floor of the square root of a number.\n    Parameters:\n    x (float): A real number from which the square root is calculated, and then floored.\n    Returns:\n    int: The floor of the square root of x.\n    Examples:\n    >>> floor_of_square_root(67)\n    8\n    >>> floor_of_square_root(81)\n    9", "Freq": 6, "TSR": 5}, {"tool": "def floor_function_bounds(value, lower_bound, upper_bound):\n    \n    from math import floor\n    floor_value = floor(value)\n    return lower_bound <= floor_value <= upper_bound", "subfield": "Floor Function", "tool_name": "floor_function_bounds", "tool_type": "function", "description": "Determines if the floor of a value falls within a specified integer bounds.", "docstring": "Determines if the floor of a value falls within a specified integer bounds.\n    Parameters:\n        value (float): The number to check.\n        lower_bound (int): The lower integer boundary.\n        upper_bound (int): The upper integer boundary.\n    \n    Returns:\n        bool: True if the floor of the value is within the bounds, False otherwise.\n    \n    Examples:\n    >>> floor_function_bounds(3.2, 3, 5)\n    True\n    >>> floor_function_bounds(-2.6, -1, 2)\n    False", "Freq": 0, "TSR": 0}], "Prime Numbers": [{"tool": "def is_prime(number):\n    \n    return sympy.isprime(number)", "subfield": "Prime Numbers", "tool_name": "is_prime", "tool_type": "function", "description": "Determine if the provided number is a prime.", "docstring": "Determine if the provided number is a prime.\n    \n    Parameters:\n    number (int): The number to test for primality.\n    \n    Returns:\n    bool: True if `number` is a prime, otherwise False.\n    \n    Examples:\n    >>> is_prime(11)\n    True\n    >>> is_prime(4)\n    False", "Freq": 2, "TSR": 0}, {"tool": "def prime_factors(n):\n    \n    from sympy import primefactors\n    return primefactors(n)", "subfield": "Prime Numbers", "tool_name": "prime_factors", "tool_type": "function", "description": "Compute the prime factors of a given integer n.", "docstring": "Compute the prime factors of a given integer n.\n    \n    Parameters:\n    n : int\n        Integer to factorize into its prime factors.\n        \n    Returns:\n    list\n        A list containing the prime factors of the integer n.\n    \n    Examples:\n    >>> prime_factors(18)\n    [2, 3, 3]\n    >>> prime_factors(17)\n    [17]", "Freq": 16, "TSR": 12}, {"tool": "def generate_primes(min_val, max_val):\n    \n    def sieve(n):\n        is_prime = [True] * (n+1)\n        p = 2\n        while (p * p <= n):\n            if (is_prime[p] == True):\n                for i in range(p * p, n+1, p):\n                    is_prime[i] = False\n            p += 1\n        return [p for p in range(2, n+1) if is_prime[p]]\n    return [p for p in sieve(max_val) if p >= min_val]", "subfield": "Prime Numbers", "tool_name": "generate_primes", "tool_type": "function", "description": "Generate all prime numbers in a specified range.", "docstring": "Generate all prime numbers in a specified range.\n    \n    Parameters:\n    min_val (int): The minimum value of the range.\n    max_val (int): The maximum value of the range.\n    \n    Returns:\n    list: A list of prime numbers within the specified range.\n    \n    Examples:\n    >>> generate_primes(10, 20)\n    [11, 13, 17, 19]", "Freq": 5, "TSR": 4}, {"tool": "def prime_factors(n):\n    \n    from collections import defaultdict\n    factors = defaultdict(int)\n    # Check for number of 2s that divide n\n    while n % 2 == 0:\n        factors[2] += 1\n        n //= 2\n    # n must be odd at this point\n    for i in range(3, int(math.sqrt(n)) + 1, 2):\n        # While i divides n, add i and divide n\n        while n % i == 0:\n            factors[i] += 1\n            n //= i\n    # This condition is to check if n is a prime number\n    # greater than 2\n    if n > 2:\n        factors[n] += 1\n    return dict(factors)", "subfield": "Prime Numbers", "tool_name": "prime_factors", "tool_type": "function", "description": "Generate the prime factors of an integer n along with their respective powers.", "docstring": "Generate the prime factors of an integer n along with their respective powers.\n    \n    Parameters:\n        n (int): The number to factorize.\n    Returns:\n        dict: A dictionary where the keys are the prime factors and the values are their powers.\n    \n    Examples:\n        >>> prime_factors(18)\n        {2: 1, 3: 2}\n        >>> prime_factors(360)\n        {2: 3, 3: 2, 5: 1}", "Freq": 6, "TSR": 3}], "Powers and Exponents": [{"tool": "def power_mod(base, exponent, modulus=None):\n    \n    if modulus is not None:\n        return pow(base, exponent, modulus)\n    else:\n        return pow(base, exponent)", "subfield": "Powers and Exponents", "tool_name": "power_mod", "tool_type": "function", "description": "Computes the power of a base raised to an exponent, optionally modulo a number.", "docstring": "Computes the power of a base raised to an exponent, optionally modulo a number.\n    \n    Parameters:\n    - base (int or float): The base of the exponentiation.\n    - exponent (int): The exponent to raise the base to.\n    - modulus (int, optional): The modulus to perform the operation under. Defaults to None.\n    Returns:\n    - result (int or float): The result of `base` raised to the power `exponent`, possibly modulo `modulus`.\n    \n    Examples:\n    >>> power_mod(2, 10)\n    1024\n    >>> power_mod(2, 10, 1000)\n    24", "Freq": 5, "TSR": 4}, {"tool": "def decimal_to_base(num, base):\n    \n    if num == 0:\n        return \"0\"\n    digits = []\n    while num:\n        digits.append(int(num % base))\n        num //= base\n    digits = digits[::-1]\n    return ''.join(str(x) for x in digits)", "subfield": "Powers and Exponents", "tool_name": "decimal_to_base", "tool_type": "function", "description": "Convert a decimal number to a given base.", "docstring": "Convert a decimal number to a given base.\n    \n    Parameters:\n        num (int): The decimal number to convert.\n        base (int): The base to convert the number to.\n        \n    Returns:\n        A string representing the number in the target base.\n    \n    Examples:\n        >>> decimal_to_base(10, 2)\n        '1010'\n        >>> decimal_to_base(255, 16)\n        'FF'", "Freq": 2, "TSR": 0}, {"tool": "def power_of_number(base, exponent):\n    \n    return base ** exponent", "subfield": "Powers and Exponents", "tool_name": "power_of_number", "tool_type": "function", "description": "Calculate the power of a given number.", "docstring": "Calculate the power of a given number.\n    \n    Parameters:\n        base (int or float or complex): The base of the power.\n        exponent (int): The exponent to which the base is raised.\n        \n    Returns:\n        The result of base raised to the power of exponent.\n    \n    Examples:\n        >>> power_of_number(2, 5)\n        32\n        >>> power_of_number(3, -1)\n        0.3333", "Freq": 5, "TSR": 5}, {"tool": "def sum_geometric_sequence(start, ratio, n):\n    \n    if ratio == 1:\n        return start * n\n    else:\n        return start * (1 - ratio ** n) / (1 - ratio)", "subfield": "Powers and Exponents", "tool_name": "sum_geometric_sequence", "tool_type": "function", "description": "Calculates the sum of the first n terms of a geometric sequence.", "docstring": "Calculates the sum of the first n terms of a geometric sequence.\n    Parameters:\n    - start (float): The first term of the sequence.\n    - ratio (float): The common ratio between terms of the sequence.\n    - n (int): The number of terms to sum.\n    Returns:\n    - float: The sum of the first n terms of the geometric sequence.\n    \n    Examples:\n    >>> sum_geometric_sequence(1, 2, 10)\n    1023.0", "Freq": 3, "TSR": 1}, {"tool": "def binary_representation(number):\n    \n    return bin(number)[2:]", "subfield": "Powers and Exponents", "tool_name": "binary_representation", "tool_type": "function", "description": "Return the binary representation of a number.", "docstring": "Return the binary representation of a number.\n    \n    Parameters:\n    number (int): The number to represent in binary.\n    Returns:\n    str: Binary string representation of the number.\n    Examples:\n    >>> binary_representation(10)\n    '1010'\n    >>> binary_representation(31)\n    '11111'", "Freq": 1, "TSR": 1}, {"tool": "def geometric_series_sum(a, r, n):\n    \n    if r == 1:\n        return n * a\n    else:\n        return a * (1 - r ** n) / (1 - r)", "subfield": "Powers and Exponents", "tool_name": "geometric_series_sum", "tool_type": "function", "description": "Calculate the sum of the first n terms of a geometric series.", "docstring": "Calculate the sum of the first n terms of a geometric series.\n    \n    Parameters:\n    a (int, float): The first term of the series.\n    r (int, float): The common ratio between successive terms.\n    n (int): The number of terms to sum.\n    Returns:\n    int or float: The sum of the first n terms of the geometric series.\n    Examples:\n    >>> geometric_series_sum(1, 2, 4)\n    15\n    >>> geometric_series_r_sum(3, 3, 3)\n    39", "Freq": 1, "TSR": 1}, {"tool": "def totient(n):\n    \n    return sp.totient(n)", "subfield": "Powers and Exponents", "tool_name": "totient", "tool_type": "function", "description": "Compute Euler's Totient function φ(n), the count of integers up to n that are coprime with n.", "docstring": "Compute Euler's Totient function φ(n), the count of integers up to n that are coprime with n.\n    \n    Parameters:\n    - n (int): The number for which to calculate the totient function.\n    \n    Returns:\n    - int: The value of φ(n).\n    \n    Examples:\n    >>> totient(9)\n    6", "Freq": 0, "TSR": 0}, {"tool": "def algebraic_power(expression, exponent):\n    \n    x = symbols('x')\n    expanded_expr = (eval(expression))**exponent\n    return simplify(expanded_expr)", "subfield": "Powers and Exponents", "tool_name": "algebraic_power", "tool_type": "function", "description": "Calculate and simplify high powers of algebraic expressions.", "docstring": "Calculate and simplify high powers of algebraic expressions.\n    \n    Parameters:\n        expression (str): The algebraic expression as a string.\n        exponent (int): The power to which the expression is raised.\n        \n    Returns:\n        Simplified form of the expression raised to the given power.\n    \n    Examples:\n        >>> algebraic_power(\"x + 1\", 2)\n        x**2 + 2*x + 1", "Freq": 0, "TSR": 0}, {"tool": "def power_properties(base, exponent, cycle_length=None):\n    \n    results = {}\n    if cycle_length:\n        periodicity = [(base**i) % 10 for i in range(1, cycle_length + 1)]\n        results['periodicity'] = periodicity\n    last_digit = (base**exponent) % 10\n    results['last_digit'] = last_digit\n    return results", "subfield": "Powers and Exponents", "tool_name": "power_properties", "tool_type": "function", "description": "Determines properties of powers like last digit or cycles in the power sequence.", "docstring": "Determines properties of powers like last digit or cycles in the power sequence.\n    \n    Parameters:\n    - base (int): The base of the expression.\n    - exponent (int): The exponent to which the base is raised.\n    - cycle_length (int, optional): The length of the cycle to explore for powers properties.\n    Returns:\n    - properties (dict): A dictionary containing properties such as last_digit and periodicity.\n    \n    Examples:\n    >>> power_properties(2, 13)\n    {'last_digit': 2}\n    >>> power_properties(3, 10, 4)\n    {'last_digit': 1, 'periodicity': ['3', '9', '7', '1']}", "Freq": 9, "TSR": 6}, {"tool": "def simplify_exponential_expression(base, exponent):\n    \n    import fractions\n    if isinstance(base, fractions.Fraction) or isinstance(exponent, fractions.Fraction):\n        result = fractions.Fraction(base) ** fractions.Fraction(exponent)\n    else:\n        result = base ** exponent\n    return result", "subfield": "Powers and Exponents", "tool_name": "simplify_exponential_expression", "tool_type": "function", "description": "Simplifies expressions involving powers using properties of exponents.", "docstring": "Simplifies expressions involving powers using properties of exponents.\n    Parameters:\n    - base (int, float, Fraction): The base of the operation.\n    - exponent (int, float, Fraction): The power to which the base is raised.\n    Returns:\n    - simplified result based on the exponent rules.\n    Examples:\n    >>> simplify_exponential_expression(2, -3)\n    0.125\n    >>> simplify_exponential_expression(-3, 2)\n    9", "Freq": 0, "TSR": 0}], "Perfect Squares": [{"tool": "def is_perfect_square(n):\n    \n    if n < 0:\n        return False\n    root = math.isqrt(n)\n    return root * root == n", "subfield": "Perfect Squares", "tool_name": "is_perfect_square", "tool_type": "function", "description": "Check if a number is a perfect square.", "docstring": "Check if a number is a perfect square.\n    Parameters:\n        n (int): The number to check.\n    Returns:\n        bool: True if n is a perfect square, False otherwise.", "Freq": 5, "TSR": 1}, {"tool": "def generate_perfect_squares(start, end):\n    \n    root_start = math.ceil(math.sqrt(start))\n    root_end = math.floor(math.sqrt(end))\n    return [x * x for x in range(root_start, root_end + 1)]", "subfield": "Perfect Squares", "tool_name": "generate_perfect_squares", "tool_type": "function", "description": "Generate a list of perfect squares between start and end (inclusive).", "docstring": "Generate a list of perfect squares between start and end (inclusive).\n    \n    Parameters:\n        start (int): The start of the range.\n        end (int): The end of the range.\n    \n    Returns:\n        list: List of perfect squares within the given range.\n    \n    Example:\n        >>> generate_perfect_squares(1, 100)\n        [1, 4, 9, 16, 25, 36, 49, 64, 81, 100]", "Freq": 1, "TSR": 0}, {"tool": "def generate_pythagorean_triples(limit):\n    \n    triples = []\n    for c in range(5, limit + 1):\n        for a in range(3, int(c/2) + 1):\n            b = math.sqrt(c * c - a * a)\n            if b == int(b):\n                triples.append((a, int(b), c))\n    return triples", "subfield": "Perfect Squares", "tool_name": "generate_pythagorean_triples", "tool_type": "function", "description": "Generate a list of Pythagorean triples up to a given limit.", "docstring": "Generate a list of Pythagorean triples up to a given limit.\n    Parameters:\n    - limit (int): The maximum value for the hypotenuse.\n    Returns:\n    - List[tuple]: A list of tuples, each containing a Pythagorean triple (a, b, c).\n    Examples:\n    >>> generate_pythagorean_triples(15)\n    [(3, 4, 5), (6, 8, 10), (5, 12, 13)]", "Freq": 1, "TSR": 0}, {"tool": "def find_next_perfect_square(n):\n    \n    root = int(math.sqrt(n)) + 1\n    return root ** 2", "subfield": "Perfect Squares", "tool_name": "find_next_perfect_square", "tool_type": "function", "description": "Find the smallest perfect square greater than a given number.", "docstring": "Find the smallest perfect square greater than a given number.\n    Parameters:\n    - n (int): The number to exceed.\n    Returns:\n    - int: The next perfect square.\n    Examples:\n    >>> find_next_perfect_square(15)\n    16\n    >>> find_next_perfect_square(25)\n    36", "Freq": 1, "TSR": 0}, {"tool": "def is_product_perfect_square(*args):\n    \n    product = math.prod(args)\n    root = math.isqrt(product)\n    return root * root == product", "subfield": "Perfect Squares", "tool_name": "is_product_perfect_square", "tool_type": "function", "description": "Check if the product of given integers is a perfect square.", "docstring": "Check if the product of given integers is a perfect square.\n    Parameters:\n        *args (int): A variable-length list of integers.\n    Returns:\n        bool: True if the product is a perfect square, False otherwise.\n    Example:\n        >>> is_product_perfect_square(2, 8)\n        True\n        >>> is_product_perfect_square(3, 5, 2)\n        False", "Freq": 0, "TSR": 0}, {"tool": "def consecutive_square_difference(n):\n    \n    return [(x, (x+1)**2 - x**2) for x in range(1, n)]", "subfield": "Perfect Squares", "tool_name": "consecutive_square_difference", "tool_type": "function", "description": "Calculate the difference between squares of consecutive integers up to n.", "docstring": "Calculate the difference between squares of consecutive integers up to n.\n    \n    Parameters:\n        n (int): The upper limit of the integer range (inclusive).\n    \n    Returns:\n        list of tuples: Each tuple contains (n, (n+1)^2 - n^2).", "Freq": 0, "TSR": 0}, {"tool": "def perfect_square_proximity(number, tolerance):\n    \n    root = math.isqrt(number)\n    proximal_square_low = root * root\n    proximal_square_high = (root + 1) * (root + 1)\n    return abs(proximal_square_low - number) <= tolerance or abs(proximal_square_high - number) <= tolerance", "subfield": "Perfect Squares", "tool_name": "perfect_square_proximity", "tool_type": "function", "description": "Identify if the given number is within the specified tolerance of being a perfect square.", "docstring": "Identify if the given number is within the specified tolerance of being a perfect square.\n    \n    Parameters:\n    number (int): The target number.\n    tolerance (int): The tolerance within which the proximity to a perfect square is acceptable.\n    \n    Returns:\n    bool: True if the number is within the specified tolerance to being a perfect square, False otherwise.\n    \n    Examples:\n    >>> perfect_square_proximity(27, 2)\n    True  # Since 25 is a perfect square and |27-25| <= 2\n    >>> perfect_square_proximity(50, 1)\n    False  # Since the nearest perfect square (49 or 64) has a difference greater than 1", "Freq": 0, "TSR": 0}, {"tool": "def last_digit_perfect_squares(limit):\n    \n    from collections import defaultdict\n    result = defaultdict(list)\n    for i in range(math.isqrt(limit) + 1):\n        sq = i * i\n        d = sq % 10\n        result[d].append(sq)\n    return dict(result)", "subfield": "Perfect Squares", "tool_name": "last_digit_perfect_squares", "tool_type": "function", "description": "Identify perfect squares up to a certain limit and their last digits.", "docstring": "Identify perfect squares up to a certain limit and their last digits.\n    Parameters:\n    - limit (int): The upper limit to which calculation is done.\n    Returns:\n    - dict: A dictionary with keys as the last digit and values as lists of perfect squares up to `limit` sharing that last digit.\n    \n    Examples:\n    >>> last_digit_perfect_squares(20)\n    {0: [0, 4, 9, 16], 1: [1], 4: [], 5: [25], 6: [36], 9: []}", "Freq": 1, "TSR": 0}, {"tool": "def difference_of_consecutive_squares(n):\n    \n    return [2 * i + 1 for i in range(1, n)]", "subfield": "Perfect Squares", "tool_name": "difference_of_consecutive_squares", "tool_type": "function", "description": "Compute the difference between squares of consecutive integers up to n.", "docstring": "Compute the difference between squares of consecutive integers up to n.\n    \n    Parameters:\n        n (int): The limit of the consecutive numbers.\n    \n    Returns:\n        list: Differences between the squares of each pair of consecutive integers.\n        \n    Examples:\n        >>> difference_of_consecutive_squares(10)\n        [3, 5, 7, 9, 11, 13, 15, 17, 19]", "Freq": 0, "TSR": 0}, {"tool": "def perfect_squares_up_to(n):\n    \n    from math import isqrt\n    return [i*i for i in range(1, isqrt(n)+1)]", "subfield": "Perfect Squares", "tool_name": "perfect_squares_up_to", "tool_type": "function", "description": "Generate all perfect squares less than or equal to `n`.", "docstring": "Generate all perfect squares less than or equal to `n`.\n    \n    Parameters:\n    -----------\n    n : int\n        Upper limit for the perfect square values.\n        \n    Returns:\n    --------\n    list\n        A list of all perfect squares ≤ `n`.\n    \n    Example:\n    --------\n    >>> perfect_squares_up_to(10)\n    [1, 4, 9]", "Freq": 2, "TSR": 2}, {"tool": "def perfect_square_divisors(n):\n    \n    factors = factorint(n)\n    divisors = {1}\n    for p, exp in factors.items():\n        # Since we want perfect squares, consider only even exponents\n        for e in range(2, exp+1, 2):  # Step by 2 to maintain even exponents\n            divisors.add(p ** e)\n    return sorted(divisors)", "subfield": "Perfect Squares", "tool_name": "perfect_square_divisors", "tool_type": "function", "description": "Find all perfect square divisors of n based on its prime factorization.", "docstring": "Find all perfect square divisors of n based on its prime factorization.\n    Parameters:\n        n (int): The number for which to find perfect square divisors.\n    \n    Returns:\n        list: List of all perfect square divisors of n.\n    \n    Example:\n        >>> perfect_square_divisors(72)\n        [1, 4, 9, 36]", "Freq": 1, "TSR": 0}, {"tool": "def consecutive_perfect_squares_difference(n):\n    \n    squares = [i * i for i in range(1, n + 1)]\n    differences = [squares[i] - squares[i-1] for i in range(1, n)]\n    return differences", "subfield": "Perfect Squares", "tool_name": "consecutive_perfect_squares_difference", "tool_type": "function", "description": "Calculate and return differences between the first `n` consecutive perfect squares.", "docstring": "Calculate and return differences between the first `n` consecutive perfect squares.\n    \n    Parameters:\n        n (int): Number of consecutive perfect squares to consider.\n        \n    Returns:\n        list: Differences between consecutive perfect squares.\n    \n    Examples:\n        >>> consecutive_perfect_squares_difference(5)\n        [3, 5, 7, 9]", "Freq": 0, "TSR": 0}, {"tool": "def list_perfect_squares(a, b):\n    \n    if a > b:\n        return []\n    # Find smallest square number >= a\n    start = math.ceil(math.sqrt(a))\n    end = math.floor(math.sqrt(b))\n    return [i * i for i in range(start, end + 1)]", "subfield": "Perfect Squares", "tool_name": "list_perfect_squares", "tool_type": "function", "description": "List all perfect squares within the range [a, b].", "docstring": "List all perfect squares within the range [a, b].\n    Parameters:\n        a (int): The lower bound of the range (inclusive).\n        b (int): The upper bound of the range (inclusive).\n    Returns:\n        List[int]: A list containing all the perfect squares within the range.", "Freq": 1, "TSR": 1}, {"tool": "def perfect_squares_range(lower, upper):\n    \n    from math import isqrt\n    lower_bound = isqrt(lower)\n    upper_bound = isqrt(upper)\n    if lower_bound * lower_bound < lower:\n        lower_bound += 1\n    return max(0, upper_bound - lower_bound + 1)", "subfield": "Perfect Squares", "tool_name": "perfect_squares_range", "tool_type": "function", "description": "Compute the number of perfect squares between two integer bounds using properties of consecutive squares.", "docstring": "Compute the number of perfect squares between two integer bounds using properties of consecutive squares.\n    \n    Parameters:\n    -----------\n    lower : int\n        The lower inclusive bound of the range.\n    upper : int\n        The upper inclusive bound of the range.\n    \n    Returns:\n    --------\n    int\n        The number of perfect squares in the range [lower, upper].\n    \n    Example:\n    --------\n    >>> perfect_squares_range(1, 100)\n    10", "Freq": 4, "TSR": 1}, {"tool": "def last_digit_of_squares():\n    \n    return {i * i % 10 for i in range(10)}", "subfield": "Perfect Squares", "tool_name": "last_digit_of_squares", "tool_type": "function", "description": "Lists the possible last digits of perfect squares in a decimal system.\n    Returns:\n        set: A set containing digits that are the last digits of a perfect square.", "docstring": "Lists the possible last digits of perfect squares in a decimal system.\n    Returns:\n        set: A set containing digits that are the last digits of a perfect square.", "Freq": 0, "TSR": 0}], "Factors and Multiples": [{"tool": "def prime_factors(n):\n    \n    return factorint(n)", "subfield": "Factors and Multiples", "tool_name": "prime_factors", "tool_type": "function", "description": "Compute the prime factors of a given number along with their exponents.", "docstring": "Compute the prime factors of a given number along with their exponents.\n    Parameters:\n        n (int): The integer to be factorized.\n    \n    Returns:\n        dict: Dictionary with prime factors as keys and their exponents as values.\n    \n    Examples:\n        >>> prime_factors(56)\n        {2: 3, 7: 1}\n        >>> prime_factors(360)\n        {2: 3, 3: 2, 5: 1}", "Freq": 5, "TSR": 2}, {"tool": "def lcm(a, b):\n    \n    return abs(a * b) // gcd(a, b)", "subfield": "Factors and Multiples", "tool_name": "lcm", "tool_type": "function", "description": "Compute the least common multiple of two numbers.", "docstring": "Compute the least common multiple of two numbers.\n    Parameters:\n        a (int): The first integer.\n        b (int): The second integer.\n    \n    Returns:\n        int: The least common multiple of a and b.\n    \n    Examples:\n        >>> lcm(12, 15)\n        60\n        >>> lcm(5, 7)\n        35", "Freq": 10, "TSR": 9}, {"tool": "def compute_gcd(a, b):\n    \n    from math import gcd\n    return gcd(a, b)", "subfield": "Factors and Multiples", "tool_name": "compute_gcd", "tool_type": "function", "description": "Compute the greatest common divisor (GCD) of two numbers a and b.", "docstring": "Compute the greatest common divisor (GCD) of two numbers a and b.\n    \n    Parameters:\n        a (int): First number.\n        b (int): Second number.\n    \n    Returns:\n        int: The GCD of a and b.\n    \n    Examples:\n        >>> compute_gcd(48, 180)\n        12", "Freq": 8, "TSR": 6}, {"tool": "def list_divisors(n):\n    \n    from math import isqrt\n    divisors = set()\n    for i in range(1, isqrt(n) + 1):\n        if n % i == 0:\n            divisors.add(i)\n            divisors.add(n // i)\n    return sorted(divisors)", "subfield": "Factors and Multiples", "tool_name": "list_divisors", "tool_type": "function", "description": "List all divisors of the given integer n.", "docstring": "List all divisors of the given integer n.\n    \n    Parameters:\n        n (int): The number to find divisors for.\n    \n    Returns:\n        List[int]: List containing all the divisors of n.\n    \n    Examples:\n        >>> list_divisors(28)\n        [1, 2, 4, 7, 14, 28]", "Freq": 7, "TSR": 3}, {"tool": "def gcd(x, y):\n    \n    while y:\n        x, y = y, x % y\n    return x", "subfield": "Factors and Multiples", "tool_name": "gcd", "tool_type": "function", "description": "Compute the greatest common divisor of two numbers x and y.", "docstring": "Compute the greatest common divisor of two numbers x and y.\n    \n    Parameters:\n    x : int\n        First number.\n    y : int\n        Second number.\n    \n    Returns:\n    int\n        The greatest common divisor of x and y.\n    \n    Examples:\n    >>> gcd(12, 18)\n    6\n    >>> gcd(5, 13)\n    1", "Freq": 2, "TSR": 1}, {"tool": "def check_prime(number):\n    \n    return isprime(number)", "subfield": "Factors and Multiples", "tool_name": "check_prime", "tool_type": "function", "description": "Check if a number is a prime number.", "docstring": "Check if a number is a prime number.\n    Parameters\n    ----------\n    number : int\n        The integer to check for primality.\n    Returns\n    -------\n    is_prime : bool\n        True if number is prime, False otherwise.\n    \n    Examples\n    --------\n    >>> check_prime(29)\n    True\n    \n    >>> check_prime(30)\n    False", "Freq": 0, "TSR": 0}, {"tool": "def gcd_lcm_calculator(*numbers):\n    \n    from math import gcd\n    from functools import reduce\n    \n    def lcm(a, b):\n        return abs(a*b) // gcd(a, b)\n    \n    overall_gcd = reduce(gcd, numbers)\n    overall_lcm = reduce(lcm, numbers, 1)\n    \n    return (overall_gcd, overall_lcm)", "subfield": "Factors and Multiples", "tool_name": "gcd_lcm_calculator", "tool_type": "function", "description": "Calculate the Greatest Common Divisor (GCD) and the Least Common Multiple (LCM) for a set of integers.", "docstring": "Calculate the Greatest Common Divisor (GCD) and the Least Common Multiple (LCM) for a set of integers.\n    \n    Parameters:\n        numbers (int): A sequence of integers for which to compute the GCD and LCM.\n    \n    Returns:\n        tuple: A tuple containing two elements; the first is the GCD and the second is the LCM of the given integers.\n    Examples:\n        >>> gcd_lcm_calculator(8, 12)\n        (4, 24)\n        >>> gcd_lcm_calculator(18, 34, 56)\n        (2, 2856)", "Freq": 0, "TSR": 0}, {"tool": "def list_prime_factors(n):\n    \n    from sympy import primefactors\n    return primefactors(n)", "subfield": "Factors and Multiples", "tool_name": "list_prime_factors", "tool_type": "function", "description": "List all prime factors of the given integer n.", "docstring": "List all prime factors of the given integer n.\n    \n    Parameters:\n        n (int): The number to find prime factors for.\n    \n    Returns:\n        List[int]: List containing all the prime factors of n.\n    \n    Examples:\n        >>> list_prime_factors(360)\n        [2, 3, 5]", "Freq": 6, "TSR": 5}, {"tool": "def are_coprime(x, y):\n    \n    return gcd(x, y) == 1", "subfield": "Factors and Multiples", "tool_name": "are_coprime", "tool_type": "function", "description": "Check if two numbers are coprime (i.e., their GCD is 1).", "docstring": "Check if two numbers are coprime (i.e., their GCD is 1).\n    \n    Parameters:\n    x : int\n        First number.\n    y : int\n        Second number.\n    \n    Returns:\n    bool\n        True if the numbers are coprime, else False.\n    \n    Examples:\n    >>> are_coprime(5, 9)\n    True\n    >>> are_coprime(12, 18)\n    False", "Freq": 0, "TSR": 0}, {"tool": "def is_perfect_square(n):\n    \n    sqrt_n = int(math.sqrt(n))\n    return sqrt_n * sqrt_n == n", "subfield": "Factors and Multiples", "tool_name": "is_perfect_square", "tool_type": "function", "description": "Determine if a number is a perfect square.", "docstring": "Determine if a number is a perfect square.\n    Parameters:\n    n (int): The number to check.\n    Returns:\n    bool: True if n is a perfect square, otherwise False.\n    Examples:\n    >>> is_perfect_square(16)\n    True\n    >>> is_perfect_square(14)\n    False", "Freq": 0, "TSR": 0}, {"tool": "def get_factors(n):\n    \n    factors = set()\n    for i in range(1, int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            factors.add(i)\n            factors.add(n // i)\n    return sorted(factors)", "subfield": "Factors and Multiples", "tool_name": "get_factors", "tool_type": "function", "description": "Compute all factors of a given number.", "docstring": "Compute all factors of a given number.\n    Parameters:\n    n (int): The number to find factors for.\n    Returns:\n    List[int]: A list of all positive factors of n.\n    Examples:\n    >>> get_factors(28)\n    [1, 2, 4, 7, 14, 28]", "Freq": 1, "TSR": 0}, {"tool": "def gcd_multiple(*numbers):\n    \n    return reduce(gcd, numbers)", "subfield": "Factors and Multiples", "tool_name": "gcd_multiple", "tool_type": "function", "description": "Compute the greatest common divisor (GCD) of multiple numbers.", "docstring": "Compute the greatest common divisor (GCD) of multiple numbers.\n    \n    Parameters:\n    numbers : tuple\n        A tuple containing the numbers.\n    \n    Returns:\n    int\n        The GCD of the provided numbers.\n    \n    Examples:\n    >>> gcd_multiple(24, 36, 48)\n    12\n    >>> gcd_multiple(21, 35)\n    7", "Freq": 0, "TSR": 0}, {"tool": "def get_multiples_in_range(base, start, end):\n    \n    start = ((start + base - 1) // base) * base  # Round start up to the nearest multiple of base\n    return list(range(start, end + 1, base))", "subfield": "Factors and Multiples", "tool_name": "get_multiples_in_range", "tool_type": "function", "description": "List all multiples of a given base number within a specified range.", "docstring": "List all multiples of a given base number within a specified range.\n    Parameters:\n    base (int): The base number whose multiples are to be found.\n    start (int): The starting point of the range (inclusive).\n    end (int): The ending point of the range (inclusive).\n    Returns:\n    List[int]: A list of all multiples of base within the range [start, end].\n    Examples:\n    >>> get_multiples_in_range(3, 1, 20)\n    [3, 6, 9, 12, 15, 18]", "Freq": 1, "TSR": 0}, {"tool": "def lcm_multiple(*numbers):\n    \n    return reduce(lcm, numbers)", "subfield": "Factors and Multiples", "tool_name": "lcm_multiple", "tool_type": "function", "description": "Compute the least common multiple (LCM) of multiple numbers.", "docstring": "Compute the least common multiple (LCM) of multiple numbers.\n    \n    Parameters:\n    numbers : tuple\n        A tuple containing the numbers.\n    \n    Returns:\n    int\n        The LCM of the provided numbers.\n    \n    Examples:\n    >>> lcm_multiple(5, 10, 20)\n    20\n    >>> lcm_multiple(7, 11)\n    77", "Freq": 3, "TSR": 3}, {"tool": "def prime_factors(n):\n    \n    factors = {}\n    # Check the number of 2s in n\n    while n % 2 == 0:\n        factors[2] = factors.get(2, 0) + 1\n        n //= 2\n    # n must be odd at this point, thus a skip of 2 is possible\n    for i in range(3, int(math.sqrt(n)) + 1, 2):\n        while (n % i == 0):\n            factors[i] = factors.get(i, 0) + 1\n            n //= i\n    # This condition is to check if n is a prime number greater than 2\n    if n > 2:\n        factors[n] = 1\n    return factors", "subfield": "Factors and Multiples", "tool_name": "prime_factors", "tool_type": "function", "description": "Returns the prime factorization of the given integer `n` as a dictionary\n    where keys are the prime factors and values are the corresponding exponents.", "docstring": "Returns the prime factorization of the given integer `n` as a dictionary\n    where keys are the prime factors and values are the corresponding exponents.\n    \n    Parameters:\n    n : int\n        The integer to factorize.\n    \n    Returns:\n    dict\n        A dictionary of prime factors with their exponents.\n    \n    Examples:\n    >>> prime_factors(18)\n    {2: 1, 3: 2}\n    >>> prime_factors(100)\n    {2: 2, 5: 2}", "Freq": 3, "TSR": 2}, {"tool": "def extended_gcd_lcm_calc(numbers):\n    \n    gcd_result = reduce(gcd, numbers)\n    lcm_result = reduce(lcm, numbers)\n    return gcd_result, lcm_result", "subfield": "Factors and Multiples", "tool_name": "extended_gcd_lcm_calc", "tool_type": "function", "description": "Calculate the gcd and lcm of a list of numbers using the reduce function.", "docstring": "Calculate the gcd and lcm of a list of numbers using the reduce function.\n    Parameters:\n        numbers (list): List of integers.\n    \n    Returns:\n        tuple: (gcd, lcm) of the list of numbers.\n    \n    Examples:\n        >>> extended_gcd_lcm_calc([48, 180, 640])\n        (4, 5760)\n        >>> extended_gcd_lcm_calc([21, 7, 14])\n        (7, 42)", "Freq": 0, "TSR": 0}], "Integers Properties": [{"tool": "def modular_inverse(a, m):\n    \n    from sympy.core.numbers import igcdex\n    g, x, y = igcdex(a, m)\n    if g != 1:\n        return None  # No modular inverse if a and m are not coprime\n    else:\n        return x % m", "subfield": "Integers Properties", "tool_name": "modular_inverse", "tool_type": "function", "description": "Computes the modular inverse of a under modulo m using the Extended Euclidean Algorithm.", "docstring": "Computes the modular inverse of a under modulo m using the Extended Euclidean Algorithm.\n    Parameters:\n        a (int): The number to find the inverse of.\n        m (int): The modulus.\n    Returns:\n        int: The modular inverse of a modulo m if it exists. Returns None if the modular inverse does not exist.\n    Example:\n        >>> modular_inverse(3, 11)\n        4", "Freq": 0, "TSR": 0}, {"tool": "def check_primality(number):\n    \n    return isprime(number)", "subfield": "Integers Properties", "tool_name": "check_primality", "tool_type": "function", "description": "Checks if an integer is a prime number.", "docstring": "Checks if an integer is a prime number.\n    Parameters:\n        number (int): The integer to check for primality.\n    Returns:\n        bool: True if the integer is prime, otherwise False.\n    Example:\n        >>> check_primality(29)\n        True", "Freq": 0, "TSR": 0}, {"tool": "def all_factors(n):\n    \n    return sorted(list(sympy.divisors(n)))", "subfield": "Integers Properties", "tool_name": "all_factors", "tool_type": "function", "description": "Generate all factors of a given integer.", "docstring": "Generate all factors of a given integer.\n    \n    Parameters:\n        n (int): The integer to find factors of.\n    \n    Returns:\n        list: A sorted list of all factors of n.\n    \n    Examples:\n        >>> all_factors(30)\n        [1, 2, 3, 5, 6, 10, 15, 30]", "Freq": 0, "TSR": 0}, {"tool": "def all_divisors(number):\n    \n    return divisors(number)", "subfield": "Integers Properties", "tool_name": "all_divisors", "tool_type": "function", "description": "Returns all divisors of a given integer.", "docstring": "Returns all divisors of a given integer.\n    Parameters:\n        number (int): The integer to find divisors for.\n    Returns:\n        list: A list of all divisors of the integer.\n    Example:\n        >>> all_divisors(28)\n        [1, 2, 4, 7, 14, 28]", "Freq": 1, "TSR": 1}, {"tool": "def prime_factors(number):\n    \n    i = 2\n    factors = []\n    while i * i <= number:\n        if number % i:\n            i += 1\n        else:\n            number //= i\n            factors.append(i)\n    if number > 1:\n        factors.append(number)\n    return factors", "subfield": "Integers Properties", "tool_name": "prime_factors", "tool_type": "function", "description": "Returns the prime factors of a given integer.", "docstring": "Returns the prime factors of a given integer.\n    Parameters:\n        number (int): The integer to factorize.\n    \n    Returns:\n        list: A list of prime factors of the integer.\n    Example:\n        >>> prime_factors(60)\n        [2, 2, 3, 5]", "Freq": 1, "TSR": 1}, {"tool": "def count_modular_solutions(f, g, modulus):\n    \n    count = 0\n    for x in range(modulus):\n        if f(x) % modulus == g(x) % modulus:\n            count += 1\n    return count", "subfield": "Integers Properties", "tool_name": "count_modular_solutions", "tool_type": "function", "description": "Counts the number of solutions to the equation f(x) ≡ g(x) (mod modulus).", "docstring": "Counts the number of solutions to the equation f(x) ≡ g(x) (mod modulus).\n    Parameters:\n        f (function): A Python function representing the left-hand side of the equation.\n        g (function): A Python function representing the right-hand side of the equation.\n        modulus (int): The modulus for the equivalence.\n    Returns:\n        int: The number of solutions x that satisfy the equation under the given modulus.\n    Example:\n        >>> f = lambda x: x**2\n        >>> g = lambda x: 1\n        >>> count_modular_solutions(f, g, 10)\n        3", "Freq": 0, "TSR": 0}, {"tool": "def modular_exponentiation(base, exponent, modulus):\n    \n    return pow(base, exponent, modulus)", "subfield": "Integers Properties", "tool_name": "modular_exponentiation", "tool_type": "function", "description": "Perform modular exponentiation (base^exponent % modulus).", "docstring": "Perform modular exponentiation (base^exponent % modulus).\n    Parameters:\n        base (int): The base of the expression.\n        exponent (int): The exponent of the expression.\n        modulus (int): The modulus to apply.\n    Returns:\n        int: Result of (base^exponent) % modulus.\n    Example:\n        >>> modular_exponentiation(2, 10, 1000)\n        24", "Freq": 0, "TSR": 0}, {"tool": "def digit_analysis(n):\n    \n    digits = [int(d) for d in str(n)]\n    return {\n        'digit_count': len(digits),\n        'even_digit_count': sum(1 for d in digits if d % 2 == 0),\n        'odd_digit_count': sum(1 for d in digits if d % 2 != 0),\n        'max_digit': max(digits),\n        'min_digit': min(digits)\n    }", "subfield": "Integers Properties", "tool_name": "digit_analysis", "tool_type": "function", "description": "Analyze the digits of a number and return various properties.", "docstring": "Analyze the digits of a number and return various properties.\n    \n    Parameters:\n        n (int): The integer to analyze.\n    \n    Returns:\n        dict: A dictionary with keys 'digit_count', 'even_digit_count', 'odd_digit_count', 'max_digit', 'min_digit'.\n    \n    Examples:\n        >>> digit_analysis(4562)\n        {'digit_count': 4, 'even_digit_count': 3, 'odd_digit_count': 1, 'max_digit': 6, 'min_digit': 2}", "Freq": 0, "TSR": 0}, {"tool": "def get_all_divisors(n):\n    \n    return divisors(n)", "subfield": "Integers Properties", "tool_name": "get_all_divisors", "tool_type": "function", "description": "List all divisors of a given integer.", "docstring": "List all divisors of a given integer.\n    Parameters:\n        n (int): The integer to find divisors for.\n    Returns:\n        list: A list of all divisors of n.\n    Example:\n        >>> get_all_divisors(30)\n        [1, 2, 3, 5, 6, 10, 15, 30]", "Freq": 0, "TSR": 0}], "Perfect Squares and Cubes": [{"tool": "def is_perfect_square(n):\n    \n    root = math.isqrt(n)\n    return root * root == n", "subfield": "Perfect Squares and Cubes", "tool_name": "is_perfect_square", "tool_type": "function", "description": "Check if a number is a perfect square.", "docstring": "Check if a number is a perfect square.\n    Parameters:\n    n (int): The number to check.\n    Returns:\n    bool: True if n is a perfect square, False otherwise.\n    Examples:\n    >>> is_perfect_square(16)\n    True\n    >>> is_perfect_square(17)\n    False", "Freq": 7, "TSR": 5}, {"tool": "def is_perfect_cube(n):\n    \n    root = round(n ** (1/3))\n    return root ** 3 == n", "subfield": "Perfect Squares and Cubes", "tool_name": "is_perfect_cube", "tool_type": "function", "description": "Check if a number is a perfect cube.", "docstring": "Check if a number is a perfect cube.\n    Parameters:\n    n (int): The number to check.\n    Returns:\n    bool: True if n is a perfect cube, False otherwise.\n    Examples:\n    >>> is_perfect_cube(27)\n    True\n    >>> is_perfect_cube(28)\n    False", "Freq": 5, "TSR": 5}, {"tool": "def find_perfect_squares(min_val, max_val):\n    \n    start = int(math.ceil(math.sqrt(min_val)))\n    end = int(math.floor(math.sqrt(max_val)))\n    return [i**2 for i in range(start, end + 1)]", "subfield": "Perfect Squares and Cubes", "tool_name": "find_perfect_squares", "tool_type": "function", "description": "Finds all perfect squares in a specified inclusive range.", "docstring": "Finds all perfect squares in a specified inclusive range.\n    \n    Parameters:\n        min_val (int): The minimum value of the range.\n        max_val (int): The maximum value of the range.\n    \n    Returns:\n        list: A list of all perfect squares within the given range [min_val, max_val].\n    \n    Examples:\n        >>> find_perfect_squares(1, 100)\n        [1, 4, 9, 16, 25, 36, 49, 64, 81, 100]", "Freq": 4, "TSR": 2}, {"tool": "def list_perfect_powers(upper_limit, power):\n    \n    results = []\n    num = 1\n    while (result := num ** power) < upper_limit:\n        results.append(result)\n        num += 1\n    return results", "subfield": "Perfect Squares and Cubes", "tool_name": "list_perfect_powers", "tool_type": "function", "description": "Lists all perfect powers less than an upper limit.", "docstring": "Lists all perfect powers less than an upper limit.\n    Parameters:\n    upper_limit (int): The upper boundary for checking the numbers.\n    power (int): The power to check for (2 for squares, 3 for cubes, etc.).\n    Returns:\n    list: A list of all perfect powers under the specified upper limit.", "Freq": 0, "TSR": 0}, {"tool": "def is_perfect_power(n, power):\n    \n    root = round(n ** (1 / power))\n    return root ** power == n", "subfield": "Perfect Squares and Cubes", "tool_name": "is_perfect_power", "tool_type": "function", "description": "Checks if a given number is a perfect power (e.g. square, cube).", "docstring": "Checks if a given number is a perfect power (e.g. square, cube).\n    Parameters:\n    n (int): The number to check.\n    power (int): The power to check against (e.g. 2 for squares, 3 for cubes).\n    Returns:\n    bool: True if n is a perfect power of the specified type, otherwise False.", "Freq": 0, "TSR": 0}, {"tool": "def is_perfect_sixth_power(n):\n    \n    sixth_root = round(n ** (1/6))\n    return sixth_root ** 6 == n", "subfield": "Perfect Squares and Cubes", "tool_name": "is_perfect_sixth_power", "tool_type": "function", "description": "Check if a number is a perfect sixth power.", "docstring": "Check if a number is a perfect sixth power.\n    Parameters:\n    n (int): The number to check.\n    Returns:\n    bool: True if n is a perfect sixth power, False otherwise.\n    Examples:\n    >>> is_perfect_sixth_power(64)\n    True\n    >>> is_perfect_sixth_power(65)\n    False", "Freq": 0, "TSR": 0}, {"tool": "def generate_squares(n):\n    \n    import math\n    return [i*i for i in range(int(math.sqrt(n)) + 1)]", "subfield": "Perfect Squares and Cubes", "tool_name": "generate_squares", "tool_type": "function", "description": "Generates a list of all perfect squares less than or equal to `n`.", "docstring": "Generates a list of all perfect squares less than or equal to `n`.\n    Parameters:\n        n (int): Upper bound for generating perfect squares.\n    Returns:\n    list: List of all perfect squares ≤ `n`.\n    Examples:\n        >>> generate_squares(10)\n        [0, 1, 4, 9]", "Freq": 0, "TSR": 0}, {"tool": "def perfect_powers(limit, power_type='square'):\n    \n    if power_type == 'square':\n        exponent = 2\n    elif power_type == 'cube':\n        exponent = 3\n    elif power_type == 'sixth':\n        exponent = 6\n    else:\n        raise ValueError(\"Unsupported power_type. Choose 'square', 'cube', or 'sixth'.\")\n    result = []\n    number = 1\n    while number**exponent <= limit:\n        result.append(number**exponent)\n        number += 1\n    return result", "subfield": "Perfect Squares and Cubes", "tool_name": "perfect_powers", "tool_type": "function", "description": "Identifies and lists all perfect power numbers up to a specified limit.", "docstring": "Identifies and lists all perfect power numbers up to a specified limit.\n    Parameters:\n    - limit (int): The upper boundary for numbers to check for being perfect powers.\n    - power_type (str): The type of power to check for ('square', 'cube', 'sixth').\n    Returns:\n    - list: A list of all perfect powers up to the specified limit.\n    Example:\n    >>> perfect_powers(100, 'square')\n    [1, 4, 9, 16, 25, 36, 49, 64, 81, 100]\n    >>> perfect_powers(100, 'cube')\n    [1, 8, 27, 64]\n    >>> perfect_powers(100, 'sixth')\n    [1, 64]", "Freq": 0, "TSR": 0}, {"tool": "def generate_cubes(n):\n    \n    return [i**3 for i in range(int(round(n**(1/3), 10)) + 1)]", "subfield": "Perfect Squares and Cubes", "tool_name": "generate_cubes", "tool_type": "function", "description": "Generates a list of all perfect cubes less than or equal to `n`.", "docstring": "Generates a list of all perfect cubes less than or equal to `n`.\n    Parameters:\n        n (int): Upper bound for generating perfect cubes.\n    Returns:\n    list: List of all perfect cubes ≤ `n`.\n    Examples:\n        >>> generate_cubes(30)\n        [0, 1, 8, 27]", "Freq": 1, "TSR": 1}, {"tool": "def nearest_perfect_power(n, direction=\"next\", power=2):\n    \n    increment = 0 if direction == \"previous\" else 1\n    candidate_root = round(n**(1/power)) + increment\n    candidate_power = candidate_root**power\n    if direction == \"previous\" and candidate_power > n:\n        candidate_root -= 1\n        candidate_power = candidate_root**power\n    return candidate_power", "subfield": "Perfect Squares and Cubes", "tool_name": "nearest_perfect_power", "tool_type": "function", "description": "Find the nearest perfect power greater ('next') or smaller ('previous') than a given number.", "docstring": "Find the nearest perfect power greater ('next') or smaller ('previous') than a given number.\n    Parameters:\n    - n (int): The reference number.\n    - direction (str): 'next' for next perfect power, 'previous' for previous (default 'next').\n    - power (int): The power to consider (default 2 for squares, 3 for cubes, etc.).\n    Returns:\n    - int: The nearest perfect power in the specified direction.\n    Examples:\n    >>> nearest_perfect_power(15)\n    16\n    >>> nearest_perfect_power(28, direction='previous', power=3)\n    27", "Freq": 0, "TSR": 0}, {"tool": "def adjusted_perfect_squares(limit, adjustment):\n    \n    results = []\n    num = 1\n    while (square := num ** 2) - adjustment < limit:\n        results.append(square - adjustment)\n        num += 1\n    return results", "subfield": "Perfect Squares and Cubes", "tool_name": "adjusted_perfect_squares", "tool_type": "function", "description": "Computes and returns perfect squares with a constant adjustment under a specified limit.", "docstring": "Computes and returns perfect squares with a constant adjustment under a specified limit.\n    Parameters:\n    limit (int): The upper limit for checking perfect squares.\n    adjustment (int): The number to subtract from each square before checking.\n    Returns:\n    list: Perfect squares with adjustment under the specified limit.", "Freq": 0, "TSR": 0}], "Divisibility": [{"tool": "def is_divisible(n, div):\n    \n    return n % div == 0", "subfield": "Divisibility", "tool_name": "is_divisible", "tool_type": "function", "description": "Check if the number `n` is divisible by the number `div`.", "docstring": "Check if the number `n` is divisible by the number `div`.\n    Parameters:\n    n (int): Number to check divisibility for.\n    div (int): Divisor.\n    Returns:\n    bool: True if `n` is divisible by `div`, False otherwise.\n    Examples:\n    >>> is_divisible(10, 5)\n    True\n    >>> is_divisible(13, 3)\n    False", "Freq": 1, "TSR": 1}, {"tool": "def prime_factors(n):\n    \n    return {int(p): e for p, e in sp.factorint(n).items()}", "subfield": "Divisibility", "tool_name": "prime_factors", "tool_type": "function", "description": "Determine prime factors of a given integer with their respective exponents.", "docstring": "Determine prime factors of a given integer with their respective exponents.\n    Parameters:\n    n : int\n        The integer to factorize.\n    Returns:\n    dict\n        A dictionary where keys are the prime factors and values are their respective exponents.\n    Example:\n    >>> prime_factors(360)\n    {2: 3, 3: 2, 5: 1}", "Freq": 0, "TSR": 0}, {"tool": "def lcm(*numbers):\n    \n    def lcm_pair(a, b):\n        return abs(a*b) // gcd(a, b)\n    \n    return reduce(lcm_pair, numbers, 1)", "subfield": "Divisibility", "tool_name": "lcm", "tool_type": "function", "description": "Calculate the least common multiple (LCM) of a list of integers.", "docstring": "Calculate the least common multiple (LCM) of a list of integers.\n    Parameters:\n        numbers (int): A series of integers for which the LCM is to be calculated.\n    Returns:\n        int: The least common multiple of the input numbers.\n    Examples:\n        >>> lcm(12, 15)\n        60\n        >>> lcm(2, 3, 5)\n        30", "Freq": 7, "TSR": 2}, {"tool": "def find_divisors(n):\n    \n    return [x for x in range(1, n+1) if n % x == 0]", "subfield": "Divisibility", "tool_name": "find_divisors", "tool_type": "function", "description": "Determine divisors of a given number.", "docstring": "Determine divisors of a given number.\n    Parameters:\n    n : int\n        The number to find divisors of\n    Returns:\n    list\n        List of divisors of n.\n    Example:\n    >>> find_divisors(12)\n    [1, 2, 3, 4, 6, 12]", "Freq": 10, "TSR": 5}, {"tool": "def count_multiples_of_lcm(lcm_value, start, end):\n    \n    if lcm_value == 0:\n        return 0\n    \n    count_start = (start + lcm_value - 1) // lcm_value\n    count_end = end // lcm_value\n    return count_end - count_start + 1", "subfield": "Divisibility", "tool_name": "count_multiples_of_lcm", "tool_type": "function", "description": "Count the number of multiples of LCM within a specified range.", "docstring": "Count the number of multiples of LCM within a specified range.\n    Parameters:\n        lcm_value (int): The LCM value to use for counting multiples.\n        start (int): The start of the range (inclusive).\n        end (int): The end of the range (inclusive).\n    Returns:\n        int: The count of multiples of the LCM within the specified range.\n    Examples:\n        >>> count_multiples_of_lcm(24, 1, 100)\n        4\n        >>> count_multiples_of_lcm(15, 1, 45)\n        3", "Freq": 3, "TSR": 2}, {"tool": "def count_trailing_zeros_factorial(n):\n    \n    i, zeros = 5, 0\n    while n >= i:\n        zeros += n // i\n        i *= 5\n    return zeros", "subfield": "Divisibility", "tool_name": "count_trailing_zeros_factorial", "tool_type": "function", "description": "Counts the number of trailing zeros in n!.", "docstring": "Counts the number of trailing zeros in n!.\n    Parameters:\n    n (int): The factorial number n! to analyze.\n    Returns:\n    int: The number of trailing zeros in `n!`.\n    Examples:\n    >>> count_trailing_zeros_factorial(5)\n    1", "Freq": 1, "TSR": 1}, {"tool": "def lcm(x, y):\n    \n    return abs(x * y) // gcd(x, y)", "subfield": "Divisibility", "tool_name": "lcm", "tool_type": "function", "description": "Compute the least common multiple of two integers.", "docstring": "Compute the least common multiple of two integers.\n    Parameters:\n    x : int\n        First integer.\n    y : int\n        Second integer.\n        \n    Returns:\n    int\n        The least common multiple of x and y.\n    Examples:\n    >>> lcm(12, 15)\n    60", "Freq": 0, "TSR": 0}, {"tool": "def sum_of_digits(number):\n    \n    return sum(int(digit) for digit in str(abs(number)))", "subfield": "Divisibility", "tool_name": "sum_of_digits", "tool_type": "function", "description": "Calculates the sum of all digits in the given integer number.", "docstring": "Calculates the sum of all digits in the given integer number.\n    Parameters:\n        number (int): The number whose digits will be summed.\n    Returns:\n        int: The sum of the digits.\n    Examples:\n    >>> sum_of_digits(123)\n    6\n    >>> sum_of_digits(104)\n    5", "Freq": 0, "TSR": 0}, {"tool": "def gcd(x, y):\n    \n    while y != 0:\n        (x, y) = (y, x % y)\n    return abs(x)", "subfield": "Divisibility", "tool_name": "gcd", "tool_type": "function", "description": "Compute the greatest common divisor of two integers.", "docstring": "Compute the greatest common divisor of two integers.\n    Parameters:\n    x : int\n        First integer.\n    y : int\n        Second integer.\n        \n    Returns:\n    int\n        The greatest common divisor of x and y.\n    Examples:\n    >>> gcd(48, 18)\n    6", "Freq": 4, "TSR": 1}, {"tool": "def modular_power(base, exponent, modulus):\n    \n    return pow(base, exponent, modulus)", "subfield": "Divisibility", "tool_name": "modular_power", "tool_type": "function", "description": "Compute the power of a base number raised to an exponent under a given modulus using an efficient method.", "docstring": "Compute the power of a base number raised to an exponent under a given modulus using an efficient method.\n    Parameters:\n    base (int): The base number to be raised to the power.\n    exponent (int): The exponent to raise the base to.\n    modulus (int): The modulus under which to perform the operation.\n    Returns:\n    int: The result of (base ** exponent) % modulus.\n    Example:\n    >>> modular_power(2, 3, 5)\n    3", "Freq": 1, "TSR": 1}, {"tool": "def extended_euclidean(a, b):\n    \n    x0, x1, y0, y1 = 0, 1, 1, 0\n    while b != 0:\n        q = a // b\n        a, b = b, a % b\n        x0, x1 = x1, x0 - q * x1\n        y0, y1 = y1, y0 - q * y1\n    return (a, x0, y0)", "subfield": "Divisibility", "tool_name": "extended_euclidean", "tool_type": "function", "description": "Extended Euclidean Algorithm to find integers x and y such that ax + by = gcd(a, b).", "docstring": "Extended Euclidean Algorithm to find integers x and y such that ax + by = gcd(a, b).\n    Parameters:\n    a : int\n        First integer.\n    b : int\n        Second integer.\n        \n    Returns:\n    tuple\n        Returns gcd(a, b), x, y where ax + by = gcd(a, b).\n    Examples:\n    >>> extended_euclidean(18, 30)\n    (6, -1, 1)", "Freq": 0, "TSR": 0}, {"tool": "def is_divisible(dividend, divisor):\n    \n    if divisor == 0:\n        raise ValueError(\"Divisor cannot be zero.\")\n    return dividend % divisor == 0", "subfield": "Divisibility", "tool_name": "is_divisible", "tool_type": "function", "description": "Determine if one number divides another without leaving a remainder.", "docstring": "Determine if one number divides another without leaving a remainder.\n    \n    Parameters:\n    - dividend (int): The number to be divided.\n    - divisor (int): The number with which to divide the dividend.\n    \n    Returns:\n    - bool: True if dividend is divisible by divisor, False otherwise.\n    \n    Examples:\n    - is_divisible(10, 2) -> True\n    - is_divisible(10, 3) -> False", "Freq": 0, "TSR": 0}, {"tool": "def divisors_from_factors(factor_dict):\n    \n    from functools import reduce\n    from itertools import product\n    # Generate lists of powers for each prime factor\n    factors_powers = [\n        [factor ** exp for exp in range(power + 1)]\n        for factor, power in factor_dict.items()\n    ]\n    # Generate all combinations of these powers\n    all_combinations = product(*factors_powers)\n    # Multiply out each combination to get the divisors\n    divisors = sorted({reduce(lambda x, y: x * y, combination, 1) for combination in all_combinations})\n    return divisors", "subfield": "Divisibility", "tool_name": "divisors_from_factors", "tool_type": "function", "description": "Calculate all divisors of a number given its prime factorization.", "docstring": "Calculate all divisors of a number given its prime factorization.\n    Parameters:\n    factor_dict : dict\n        A dictionary of prime factors and their respective exponents.\n    Returns:\n    list\n        Sorted list of all divisors of the number.\n    Examples:\n    >>> divisors_from_factors({2: 2, 3: 1, 5: 1})\n    [1, 2, 3, 4, 5, 6, 10, 12, 15, 20, 30, 60]", "Freq": 1, "TSR": 0}, {"tool": "def find_lcm(num1, num2):\n    \n    return abs(num1 * num2) // gcd(num1, num2)", "subfield": "Divisibility", "tool_name": "find_lcm", "tool_type": "function", "description": "Find the least common multiple of two numbers.", "docstring": "Find the least common multiple of two numbers.\n    \n    Parameters:\n    - num1 (int): First number.\n    - num2 (int): Second number.\n    \n    Returns:\n    - int: Least common multiple of num1 and num2.\n    \n    Examples:\n    - find_lcm(4, 6) -> 12", "Freq": 0, "TSR": 0}, {"tool": "def is_prime(n):\n    \n    if n == 1:\n        return False\n    elif n == 2:\n        return True\n    else:\n        for x in range(2, n):\n            if n % x == 0:\n                return False\n        return True", "subfield": "Divisibility", "tool_name": "is_prime", "tool_type": "function", "description": "Check if a given number is a prime number.", "docstring": "Check if a given number is a prime number.\n    Parameters:\n    n : int\n        The number to check\n    Returns:\n    bool\n        True if n is prime, False otherwise.\n        \n    Example:\n    >>> is_prime(2)\n    True\n    >>> is_prime(4)\n    False", "Freq": 1, "TSR": 0}, {"tool": "def find_factors(num):\n    \n    factors = []\n    for potential_factor in range(1, int(num**0.5) + 1):\n        if num % potential_factor == 0:\n            factors.append(potential_factor)\n            if potential_factor != num // potential_factor:\n                factors.append(num // potential_factor)\n    factors.sort()\n    return factors", "subfield": "Divisibility", "tool_name": "find_factors", "tool_type": "function", "description": "Finds all factors of a given number.", "docstring": "Finds all factors of a given number.\n    \n    Parameters:\n    - num (int): The number to find factors for.\n    Returns:\n    - List[int]: A list of all factors of num.\n    \n    Examples:\n    - find_factors(12) -> [1, 2, 3, 4, 6, 12]", "Freq": 1, "TSR": 1}, {"tool": "def extract_last_n_digits(number, n):\n    \n    return abs(number) % (10 ** n)", "subfield": "Divisibility", "tool_name": "extract_last_n_digits", "tool_type": "function", "description": "Extracts the last n digits of an integer.", "docstring": "Extracts the last n digits of an integer.\n    Parameters:\n    - number (int): The number from which to extract digits.\n    - n (int): The number of last digits to extract.\n    Returns:\n    - int: The last n digits of the number.\n    \n    Examples:\n    >>> extract_last_n_digits(12345, 2)\n    45\n    >>> extract_last_n_digits(98765, 3)\n    765", "Freq": 0, "TSR": 0}, {"tool": "def prime_factors(number):\n    \n    factors = []\n    for prime in primefactors(number):\n        count = 0\n        temp = number\n        while temp % prime == 0:\n            temp //= prime\n            count += 1\n        factors.extend([prime] * count)\n    return factors", "subfield": "Divisibility", "tool_name": "prime_factors", "tool_type": "function", "description": "Return the prime factors of a given number as a list.", "docstring": "Return the prime factors of a given number as a list.\n    Parameters:\n        number (int): The integer to factorize.\n    Returns:\n        list: A list containing the prime factors of the number.\n    Examples:\n        >>> prime_factors(100)\n        [2, 2, 5, 5]\n        >>> prime_formatted_factors(36)\n        [2, 2, 3, 3]", "Freq": 0, "TSR": 0}, {"tool": "def factorial_divisor_properties(n):\n    \n    trailing_zeros = 0\n    power_of_five = 5\n    while n >= power_of_five:\n        trailing_zeros += n // power_of_five\n        power_of_five *= 5\n    return {'trailing_zeros': trailing_zeros}", "subfield": "Divisibility", "tool_name": "factorial_divisor_properties", "tool_type": "function", "description": "Analyze properties related to the divisors of n factorial, like the number of trailing zeros.", "docstring": "Analyze properties related to the divisors of n factorial, like the number of trailing zeros.\n    \n    Parameters:\n        n (int): The number to calculate factorial of.\n    \n    Returns:\n        dict: A dictionary with keys 'trailing_zeros'.\n        \n    Examples:\n        >>> factorial_divisor_properties(5)\n        {'trailing_zeros': 1}\n        >>> factorial_divisor_properties(10)\n        {'trailing_zeros': 2}", "Freq": 0, "TSR": 0}, {"tool": "def modulo_operation(n, m):\n    \n    return n % m", "subfield": "Divisibility", "tool_name": "modulo_operation", "tool_type": "function", "description": "Perform modulo operations.", "docstring": "Perform modulo operations.\n    Parameters:\n    n : int\n        Numerator in division\n    m : int\n        Denominator in division\n    Returns:\n    int\n        Remainder when n is divided by m.\n    Example:\n    >>> modulo_operation(10, 3)\n    1", "Freq": 0, "TSR": 0}, {"tool": "def find_multiples(number, limit):\n    \n    return [number * i for i in range(1, limit // number + 1)]", "subfield": "Divisibility", "tool_name": "find_multiples", "tool_type": "function", "description": "Returns a list of multiples of a given number up to a specified limit.", "docstring": "Returns a list of multiples of a given number up to a specified limit.\n    \n    Parameters:\n    - number (int): The base number of which multiples are desired.\n    - limit (int): The upper bound for multiples.\n    \n    Returns:\n    - List[int]: A list containing multiples of the number up to the limit.\n    \n    Examples:\n    - find_multiples(3, 10) -> [3, 6, 9]", "Freq": 0, "TSR": 0}, {"tool": "def divisibility_check(n, m):\n    \n    return n % m == 0", "subfield": "Divisibility", "tool_name": "divisibility_check", "tool_type": "function", "description": "Check if the number n is divisible by m.", "docstring": "Check if the number n is divisible by m.\n    Parameters:\n    n : int\n        Numerator in division\n    m : int\n        Denominator in division\n    Returns:\n    bool\n        True if n is divisible by m, False otherwise.\n    Example:\n    >>> divisibility_check(10, 2)\n    True\n    >>> divisibility_check(11, 2)\n    False", "Freq": 0, "TSR": 0}, {"tool": "def is_even(n):\n    \n    return n % 2 == 0", "subfield": "Divisibility", "tool_name": "is_even", "tool_type": "function", "description": "Check if a number is even.", "docstring": "Check if a number is even.\n    Parameters:\n    n : int\n        The number to check\n    Returns:\n    bool\n        True if n is even, False otherwise.\n        \n    Example:\n    >>> is_even(2)\n    True\n    >>> is_even(3)\n    False", "Freq": 0, "TSR": 0}, {"tool": "def satisfies_all_conditions(number, *divisors):\n    \n    return all(number % divisor == 0 for divisor in divisors)", "subfield": "Divisibility", "tool_name": "satisfies_all_conditions", "tool_type": "function", "description": "Check if a given number is divisible by all provided divisors.", "docstring": "Check if a given number is divisible by all provided divisors.\n    \n    Parameters:\n    - number (int): the number to check.\n    - divisors (int): a sequence of divisors to check against.\n    \n    Returns:\n    - bool: True if the number is divisible by all of the divisors, False otherwise.\n    \n    Example:\n    >>> satisfies_all_conditions(120, 4, 5, 6)\n    True\n    >>> satisfies_all_conditions(17, 4, 3)\n    False", "Freq": 0, "TSR": 0}, {"tool": "def factorization(n):\n    \n    i = 2\n    factors = []\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n            factors.append(i)\n    if n > 1:\n        factors.append(n)\n    return factors", "subfield": "Divisibility", "tool_name": "factorization", "tool_type": "function", "description": "Factorize a given number into prime factors.", "docstring": "Factorize a given number into prime factors.\n    Parameters:\n    n : int\n        The number to factorize\n    Returns:\n    list\n        List of prime factors of n.\n        \n    Example:\n    >>> factorization(12)\n    [2, 2, 3]", "Freq": 0, "TSR": 0}, {"tool": "def integer_division(n, m):\n    \n    quotient = n // m\n    remainder = n % m\n    return quotient, remainder", "subfield": "Divisibility", "tool_name": "integer_division", "tool_type": "function", "description": "Perform integer division and return quotient and remainder.", "docstring": "Perform integer division and return quotient and remainder.\n    Parameters:\n    n : int\n        Numerator in division\n    m : int\n        Denominator in division\n    Returns:\n    tuple\n        Quotient when n is divided by m and remainder.\n    Example:\n    >>> integer_division(10, 3)\n    (3, 1)", "Freq": 0, "TSR": 0}, {"tool": "def lcm(a, b):\n    \n    from math import gcd\n    return abs(a * b) // gcd(a, b)", "subfield": "Divisibility", "tool_name": "lcm", "tool_type": "function", "description": "Compute the Least Common Multiple of two integers a and b.", "docstring": "Compute the Least Common Multiple of two integers a and b.\n    Parameters:\n        a (int): First integer.\n        b (int): Second integer.\n    Returns:\n        int: LCM of a and b.\n    Example:\n        >>> lcm(4, 5)\n        20", "Freq": 0, "TSR": 0}, {"tool": "def compute_factorial(n):\n    \n    return factorial(n)", "subfield": "Divisibility", "tool_name": "compute_factorial", "tool_type": "function", "description": "Compute n!.", "docstring": "Compute n!.\n    Parameters:\n    n : int\n        The integer to compute the factorial of.\n    Returns:\n    int\n        n!.\n    Example:\n    >>> compute_factorial(5)\n    120", "Freq": 0, "TSR": 0}, {"tool": "def gcd(a, b):\n    \n    from math import gcd\n    return gcd(a, b)", "subfield": "Divisibility", "tool_name": "gcd", "tool_type": "function", "description": "Calculate the Greatest Common Divisor of two integers, a and b.", "docstring": "Calculate the Greatest Common Divisor of two integers, a and b.\n    Parameters:\n        a (int): First integer.\n        b (int): Second integer.\n    Returns:\n        int: GCD of a and b.\n    Example:\n        >>> gcd(8, 12)\n        4", "Freq": 0, "TSR": 0}, {"tool": "def divisor_properties(n):\n    \n    divs = divisors(n)\n    num = len(divs)\n    sum_divs = sum(divs)\n    prod_divs = sympy.prod(divs)\n    return {'number_of_divisors': num, 'sum_of_divisors': sum_divs, 'product_of_divisors': prod_divs}", "subfield": "Divisibility", "tool_name": "divisor_properties", "tool_type": "function", "description": "Calculate properties of divisors for n such as total number, sum, and product.", "docstring": "Calculate properties of divisors for n such as total number, sum, and product.\n    \n    Parameters:\n        n (int): The integer to analyze divisors for.\n    \n    Returns:\n        dict: A dictionary with keys 'number_of_divisors', 'sum_of_divisors', and 'product_of_divisors'.\n    \n    Examples:\n        >>> divisor_properties(30)\n        {'number_of_divisors': 8, 'sum_of_divisors': 72, 'product_of_divisors': 810000}", "Freq": 0, "TSR": 0}, {"tool": "def list_divisors(number):\n    \n    if number <= 0:\n        raise ValueError(\"Number must be positive.\")\n    divisors = [1]\n    for i in range(2, int(number**0.5) + 1):\n        if number % i == 0:\n            divisors.extend([i, number // i])\n    if number != 1:\n        divisors.append(number)\n    return sorted(list(set(divisors)))", "subfield": "Divisibility", "tool_name": "list_divisors", "tool_type": "function", "description": "List all divisors of a given number.", "docstring": "List all divisors of a given number.\n    Parameters:\n    number (int): The number whose divisors are to be found.\n    Returns:\n    list: A list of all divisors of the number.\n    Example:\n    >>> list_divisors(10)\n    [1, 2, 5, 10]", "Freq": 0, "TSR": 0}], "Multiples": [{"tool": "def find_multiples_in_range(base, start, end):\n    \n    if base == 0:\n        raise ValueError(\"Base cannot be zero.\")\n    return [i for i in range(max(base, start - start % base), end + 1, base) if i >= start]", "subfield": "Multiples", "tool_name": "find_multiples_in_range", "tool_type": "function", "description": "Generate all multiples of a base number within a specified range.", "docstring": "Generate all multiples of a base number within a specified range.\n    \n    Parameters:\n    - base (int): The base number of which multiples are to be found.\n    - start (int): The start of the range.\n    - end (int): The end of the range (inclusive).\n    \n    Returns:\n    - list: A list of multiples of the base number within the specified range.\n    \n    Examples:\n    >>> find_multiples_in_range(3, 100, 200)\n    [102, 105, 108, ..., 198]\n    >>> find_multiples_in_range(5, 1, 25)\n    [5, 10, 15, 20, 25]", "Freq": 10, "TSR": 10}, {"tool": "def lcm_two_numbers(a, b):\n    \n    return abs(a*b) // math.gcd(a, b)", "subfield": "Multiples", "tool_name": "lcm_two_numbers", "tool_type": "function", "description": "Compute the Least Common Multiple (LCM) of two integers using the Greatest Common Divisor (GCD).", "docstring": "Compute the Least Common Multiple (LCM) of two integers using the Greatest Common Divisor (GCD).\n    \n    Parameters:\n    - a (int): The first integer.\n    - b (int): The second integer.\n    \n    Returns:\n    - int: The LCM of the two integers.\n    \n    Examples:\n    --------\n    >>> lcm_two_numbers(12, 15)\n    60\n    >>> lcm_two_numbers(5, 10)\n    10", "Freq": 0, "TSR": 0}, {"tool": "def list_multiples(base, lower_bound, upper_bound):\n    \n    from math import ceil\n    start = ceil(lower_bound / base) * base\n    return [n for n in range(start, upper_bound + 1, base) if n >= lower_bound]", "subfield": "Multiples", "tool_name": "list_multiples", "tool_type": "function", "description": "Generates a list of multiples of the given number within a specified range.", "docstring": "Generates a list of multiples of the given number within a specified range.\n    Parameters:\n    -----------\n    base : int\n        The base number whose multiples are to be found.\n    lower_bound : int\n        The lower boundary of the range (inclusive).\n    upper_bound : int\n        The upper boundary of the range (inclusive).\n    Returns:\n    --------\n    list\n        A list of multiples of the base number within the specified range.\n    Examples:\n    ---------\n    >>> list_multiples(7, 1, 100)\n    [7, 14, 21, 28, 35, 42, 49, 56, 63, 70, 77, 84, 91, 98]", "Freq": 2, "TSR": 2}, {"tool": "def nearest_multiple(number, base):\n    \n    lower = number - (number % base)\n    higher = lower + base if number % base != 0 else lower\n    return (lower, higher)", "subfield": "Multiples", "tool_name": "nearest_multiple", "tool_type": "function", "description": "Find the nearest multiple of 'base' for the given 'number'.", "docstring": "Find the nearest multiple of 'base' for the given 'number'.\n    \n    Parameters:\n    - number (int): The number to find the nearest multiple to.\n    - base (int): The base number.\n    \n    Returns:\n    - tuple: The nearest lower and higher multiples of 'base' to 'number'.\n    \n    Examples:\n    >>> nearest_multiple(28, 5)\n    (25, 30)", "Freq": 0, "TSR": 0}, {"tool": "def generate_multiples(base, limit):\n    \n    return list(range(base, limit+1, base))", "subfield": "Multiples", "tool_name": "generate_multiples", "tool_type": "function", "description": "Generate a list of multiples of a given number up to a specified limit.", "docstring": "Generate a list of multiples of a given number up to a specified limit.\n    Parameters\n    ----------\n    base : int\n        The number for which multiples are to be generated.\n    limit : int\n        The maximum value upto which multiples should be calculated.\n    Returns\n    -------\n    list of ints\n        List containing the multiples of the base number up to the limit.\n    Examples\n    --------\n    >>> generate_multiples(3, 30)\n    [3, 6, 9, 12, 15, 18, 21, 24, 27, 30]\n    >>> generate_multiples(5, 50)\n    [5, 10, 15, 20, 25, 30, 35, 40, 45, 50]", "Freq": 4, "TSR": 3}, {"tool": "def nth_multiple(n, base):\n    \n    return n * base", "subfield": "Multiples", "tool_name": "nth_multiple", "tool_type": "function", "description": "Calculate the nth multiple of the base number.", "docstring": "Calculate the nth multiple of the base number.\n    \n    Parameters:\n    - n (int): The nth multiple to find.\n    - base (int): The base number.\n    \n    Returns:\n    - int: The nth multiple of the base number.\n    \n    Examples:\n    >>> nth_multiple(4, 3)\n    12\n    >>> nth_multiple(5, 10)\n    50", "Freq": 0, "TSR": 0}, {"tool": "def is_multiple(base, factor):\n    \n    return base % factor == 0", "subfield": "Multiples", "tool_name": "is_multiple", "tool_type": "function", "description": "Check if the first integer is a multiple of the second integer.", "docstring": "Check if the first integer is a multiple of the second integer.\n    \n    Parameters:\n        base (int): The number to be checked.\n        factor (int): The potential factor of the base number.\n    \n    Returns:\n        bool: True if base is a multiple of factor, False otherwise.\n    \n    Examples:\n        >>> is_multiple(20, 5)\n        True\n        >>> is_multiple(14, 5)\n        False\n        \n    Notes:\n        A number A is considered a multiple of number B if there exists an integer X such that B * X = A.", "Freq": 0, "TSR": 0}], "Modular Arithmetic": [{"tool": "def modular_add(a, b, m):\n    \n    return (a + b) % m", "subfield": "Modular Arithmetic", "tool_name": "modular_add", "tool_type": "function", "description": "Perform modular addition.", "docstring": "Perform modular addition.\n    Parameters:\n    - a (int): The first operand.\n    - b (int): The second operand.\n    - m (int): The modulus.\n    Returns:\n    int: The result of (a + b) % m.", "Freq": 1, "TSR": 1}, {"tool": "def mod_pow(base, exponent, modulus):\n    \n    return pow(base, exponent, modulus)", "subfield": "Modular Arithmetic", "tool_name": "mod_pow", "tool_type": "function", "description": "Compute the power of a number with a modulus using efficient exponentiation.", "docstring": "Compute the power of a number with a modulus using efficient exponentiation.\n    \n    Parameters:\n        base (int): Base of the power.\n        exponent (int): Exponent of the power.\n        modulus (int): Modulus to use.\n    \n    Returns:\n        int: The result of (base^exponent) mod modulus.\n    \n    Example:\n        mod_pow(2, 5, 13) returns 6 because (2^5) % 13 = 32 % 13 = 6.", "Freq": 11, "TSR": 10}, {"tool": "def get_modular_inverse(a, m):\n    \n    return mod_inverse(a, m)", "subfield": "Modular Arithmetic", "tool_name": "get_modular_inverse", "tool_type": "function", "description": "Computes the modular inverse of `a` under the modulus `m` using the Extended Euclidean Algorithm.", "docstring": "Computes the modular inverse of `a` under the modulus `m` using the Extended Euclidean Algorithm.\n    Parameters:\n    a (int): The number to find the inverse for.\n    m (int): The modulus.\n    Returns:\n    int: The modular inverse of `a` under `m`.\n    Raises:\n    ValueError: If no modular inverse exists, which occurs if `a` and `m` are not coprime.\n    Example:\n    >>> get_modular_inverse(3, 11)\n    4", "Freq": 6, "TSR": 4}, {"tool": "def mod_add(a, b, modulus):\n    \n    return (a + b) % modulus", "subfield": "Modular Arithmetic", "tool_name": "mod_add", "tool_type": "function", "description": "Perform modular addition.", "docstring": "Perform modular addition.\n    \n    Parameters:\n        a (int): First operand.\n        b (int): Second operand.\n        modulus (int): Modulus to use for the operation.\n    \n    Returns:\n        int: The result of (a + b) mod modulus.\n    \n    Example:\n        mod_add(5, 3, 7) returns 1 because (5 + 3) % 7 = 8 % 7 = 1.", "Freq": 0, "TSR": 0}, {"tool": "def modular_add(a, b, mod):\n    \n    return (a + b) % mod", "subfield": "Modular Arithmetic", "tool_name": "modular_add", "tool_type": "function", "description": "Calculate the sum of two numbers under a given modulus.", "docstring": "Calculate the sum of two numbers under a given modulus.\n    \n    Parameters:\n    a (int): The first number.\n    b (int): The second number.\n    mod (int): The modulus to apply.\n    \n    Returns:\n    int: The result of (a + b) % mod.\n    \n    Examples:\n    >>> modular_add(3, 5, 7)\n    1\n    >>> modular_add(6, 7, 5)\n    3", "Freq": 0, "TSR": 0}, {"tool": "def check_cyclic_pattern(base, mod):\n    \n    pattern = []\n    result = 1\n    for _ in range(mod):\n        result = (result * base) % mod\n        if result in pattern:\n            break\n        pattern.append(result)\n    return pattern", "subfield": "Modular Arithmetic", "tool_name": "check_cyclic_pattern", "tool_type": "function", "description": "Check for a cyclic pattern in modulo operations with a given base and modulus.", "docstring": "Check for a cyclic pattern in modulo operations with a given base and modulus.\n    Parameters\n    ----------\n    base : int\n        The base number.\n    mod : int\n        The modulus.\n    Returns\n    -------\n    List[int]\n        The repeating pattern in the sequence base^k (mod m) for k = 1, 2, ...\n    Examples\n    --------\n    >>> check_cyclic_pattern(2, 3)\n    [2, 1]", "Freq": 1, "TSR": 1}, {"tool": "def solve_congruence(expression_1, expression_2, mod):\n    \n    expression_1 = simplify(expression_1)\n    expression_2 = simplify(expression_2)\n    return (expression_2 - expression_1) % mod", "subfield": "Modular Arithmetic", "tool_name": "solve_congruence", "tool_type": "function", "description": "Solve for a variable in a congruence equation.", "docstring": "Solve for a variable in a congruence equation.\n    Parameters\n    ----------\n    expression_1 : int or str\n        The first expression of the congruence equation.\n    expression_2 : int or str\n        The second expression of the congruence equation.\n    mod : int\n        The modulus.\n    Returns\n    -------\n    int\n        The solution to the congruence equation.\n    Examples\n    --------\n    >>> solve_congruence('x', 1, 3)\n    1", "Freq": 2, "TSR": 0}, {"tool": "def simplify_modular_expression(expression):\n    \n    return simplify(expression)", "subfield": "Modular Arithmetic", "tool_name": "simplify_modular_expression", "tool_type": "function", "description": "Simplify a numerical expression with respect to mod.", "docstring": "Simplify a numerical expression with respect to mod.\n    \n    Parameters\n    ----------\n    expression : str\n        The expression to simplify.\n        \n    Returns\n    -------\n    int\n        The simplified result.\n        \n    Examples\n    --------\n    >>> simplify_modular_expression('2+3')\n    5", "Freq": 0, "TSR": 0}, {"tool": "def sum_modulo(elements, m):\n    \n    return sum(elements) % m", "subfield": "Modular Arithmetic", "tool_name": "sum_modulo", "tool_type": "function", "description": "Calculate the sum of elements under modulo m.", "docstring": "Calculate the sum of elements under modulo m.\n    Parameters:\n    - elements (list of int): The elements to sum.\n    - m (int): The modulus.\n    Returns:\n    - int: The sum of the given elements modulo m.\n    Examples:\n    >>> sum_modulo([1, 2, 3, 4], 5)\n    0", "Freq": 2, "TSR": 2}, {"tool": "def calculate_modular_inverse(num, mod):\n    \n    return mod_inverse(num, mod)", "subfield": "Modular Arithmetic", "tool_name": "calculate_modular_inverse", "tool_type": "function", "description": "Calculate the modular inverse of a number under a certain modulus.", "docstring": "Calculate the modular inverse of a number under a certain modulus.\n    Parameters\n    ----------\n    num : int\n        The number to find the inverse of.\n    mod : int\n        The modulus.\n    Returns\n    -------\n    int\n        The modular inverse of the number.\n    Examples\n    --------\n    >>> calculate_modular_inverse(3, 7)\n    5", "Freq": 0, "TSR": 0}, {"tool": "def calculate_power_modulo(base, power, mod):\n    \n    return pow(base, power, mod)", "subfield": "Modular Arithmetic", "tool_name": "calculate_power_modulo", "tool_type": "function", "description": "Calculate the power of a number modulo a certain number.", "docstring": "Calculate the power of a number modulo a certain number.\n    Parameters\n    ----------\n    base : int\n        The base number.\n    power : int\n        The power to raise the base number to.\n    mod : int\n        The modulus.\n    Returns\n    -------\n    int\n        The result of base^power modulo mod.\n    Examples\n    --------\n    >>> calculate_power_modulo(5, 3, 2)\n    1", "Freq": 0, "TSR": 0}, {"tool": "def find_factors(num):\n    \n    return [i for i in range(1, num + 1) if num % i == 0]", "subfield": "Modular Arithmetic", "tool_name": "find_factors", "tool_type": "function", "description": "Find all factors of a number.", "docstring": "Find all factors of a number.\n    Parameters\n    ----------\n    num : int\n        The number to find factors of.\n    Returns\n    -------\n    List[int]\n        The list of factors of the number.\n    Examples\n    --------\n    >>> find_factors(20)\n    [1, 2, 4, 5, 10, 20]", "Freq": 1, "TSR": 0}, {"tool": "def modular_operations(a, b, op='mod', m=1):\n    \n    if op == 'add':\n        return (a + b) % m\n    elif op == 'sub':\n        return (a - b) % m\n    elif op == 'mul':\n        return (a * b) % m\n    elif op == 'mod':\n        return a % b\n    elif op == 'div' and b != 0:  # division mod might need to use multiplicative inverse\n        from sympy import mod_inverse\n        inv_b = mod_inverse(b, m)\n        return (a * inv_b) % m\n    else:\n        raise ValueError(\"Operation not supported or division by zero\")", "subfield": "Modular Arithmetic", "tool_name": "modular_operations", "tool_type": "function", "description": "Perform modular arithmetic operations such as addition, subtraction, multiplication, \n    and modulus between two numbers under a modulo m.", "docstring": "Perform modular arithmetic operations such as addition, subtraction, multiplication, \n    and modulus between two numbers under a modulo m.\n    Parameters:\n    - a (int or float): The first operand.\n    - b (int or float): The second operand or the modulus.\n    - op (str): The operation type ('add', 'sub', 'mul', 'mod', 'div').\n    - m (int, optional): The modulo for the operation. Default is 1 for standard operations.\n    Returns:\n    - int or float: Result of the specified operation under modulo m.\n    Examples:\n    >>> modular_operations(10, 3, 'mod')\n    1\n    >>> modular_operations(5, 3, 'add', 7)\n    1\n    >>> modular_operations(4, 3, 'mul', 5)\n    2", "Freq": 0, "TSR": 0}, {"tool": "def calculate_gcd(num1, num2):\n    \n    return gcd(num1, num2)", "subfield": "Modular Arithmetic", "tool_name": "calculate_gcd", "tool_type": "function", "description": "Calculate the greatest common divisor (gcd) between two numbers.", "docstring": "Calculate the greatest common divisor (gcd) between two numbers.\n    Parameters\n    ----------\n    num1 : int\n        The first number.\n    num2 : int\n        The second number.\n    Returns\n    -------\n    int\n        The greatest common divisor of the two numbers.\n    Examples\n    --------\n    >>> calculate_gcd(20, 30)\n    10", "Freq": 2, "TSR": 1}], "Factorials": [{"tool": "def compute_factorial(n):\n    \n    if n < 0:\n        raise ValueError(\"Factorial is not defined for negative numbers.\")\n    return factorial(n)", "subfield": "Factorials", "tool_name": "compute_factorial", "tool_type": "function", "description": "Compute the factorial of a given non-negative integer n.", "docstring": "Compute the factorial of a given non-negative integer n.\n    Parameters:\n    - n (int): A non-negative integer whose factorial is to be calculated.\n    Returns:\n    - int: The factorial of the integer n.\n    Example:\n    >>> compute_factorial(5)\n    120\n    >>> compute_factorial(0)\n    1", "Freq": 3, "TSR": 1}, {"tool": "def factorial_properties(n, analysis_type=\"trailing_zeros\"):\n    \n    if analysis_type == \"trailing_zeros\":\n        # Count trailing zeros in n!\n        count = 0\n        i = 5\n        while n // i >= 1:\n            count += n // i\n            i *= 5\n        return count\n    else:\n        raise ValueError(\"Unsupported analysis type. Supported types: 'trailing_zeros'.\")", "subfield": "Factorials", "tool_name": "factorial_properties", "tool_type": "function", "description": "Analyze certain properties of factorial of a number n, such as calculating trailing zeros.", "docstring": "Analyze certain properties of factorial of a number n, such as calculating trailing zeros.\n    Parameters:\n    - n (int): The number whose factorial's properties are to be analyzed.\n    - analysis_type (str): Type of analysis to perform on factorial. Supported values are 'trailing_zeros'.\n    Returns:\n    - int: Result of the analysis based on the type specified.\n    Example:\n    >>> factorial_properties(5, \"trailing_zeros\")\n    1\n    >>> factorial_properties(20, \"trailing_zeros\")\n    4", "Freq": 1, "TSR": 0}, {"tool": "def simplify_factorial_expression(n, m):\n    \n    if n < m:\n        raise ValueError(\"Numerator factorial base must be greater than the denominator factorial base\")\n    if m < 0:\n        raise ValueError(\"Factorial base must be non-negative\")\n    result = 1\n    for i in range(m + 1, n + 1):\n        result *= i\n    return result", "subfield": "Factorials", "tool_name": "simplify_factorial_expression", "tool_type": "function", "description": "Simplifies an expression of the form n! / m! given that n > m.", "docstring": "Simplifies an expression of the form n! / m! given that n > m.\n    Parameters:\n    n (int): The numerator's factorial base, should be greater than m.\n    m (int): The denominator's factorial base, should be non-negative and less than n.\n    Returns:\n    int: The simplified result of n! / m!.\n    Examples:\n    >>> simplify_factorial_expression(5, 3)\n    20\n    >>> simplify_factorial_expression(6, 1)\n    720\n    Notes:\n    - If n == m, the result of the expression is 1 (since n! / n! = 1).\n    - This function uses an efficient method by only multiplying numbers from m+1 to n.", "Freq": 7, "TSR": 0}, {"tool": "def factorial_gcd(a, b):\n    \n    return factorial(min(a, b))  # GCD of a! and b! is min(a, b)!", "subfield": "Factorials", "tool_name": "factorial_gcd", "tool_type": "function", "description": "Compute the greatest common divisor (GCD) of the factorials of two non-negative integers.", "docstring": "Compute the greatest common divisor (GCD) of the factorials of two non-negative integers.\n    Parameters:\n    a : int\n        The first non-negative integer.\n    b : int\n        The second non-negative integer.\n    Returns:\n    int\n        GCD of the factorials of a and b.\n    Examples:\n    >>> factorial_gcd(5, 3)\n    6\n    >>> factorial_gcd(7, 7)\n    5040", "Freq": 1, "TSR": 1}, {"tool": "def compute_double_factorial(n):\n    \n    if not isinstance(n, int) or n < 0:\n        raise ValueError(\"n must be a non-negative integer\")\n    if n == 0 or n == 1:\n        return 1\n    return n * compute_double_factorial(n-2)", "subfield": "Factorials", "tool_name": "compute_double_factorial", "tool_type": "function", "description": "Compute the double factorial of a non-negative integer, denoted as n!!,\n    which is the product of positive integers up to n that have the same parity as n.", "docstring": "Compute the double factorial of a non-negative integer, denoted as n!!,\n    which is the product of positive integers up to n that have the same parity as n.\n    Parameters:\n    n : int\n        A non-negative integer to compute the double factorial for.\n    Returns:\n    int\n        Double factorial of the integer n.\n    Examples:\n    >>> compute_double_factorial(5)\n    15\n    >>> compute_double_factorial(6)\n    48", "Freq": 1, "TSR": 0}, {"tool": "def simplify_factorial_expression(expression):\n    \n    expr = simplify(expression)\n    return expr", "subfield": "Factorials", "tool_name": "simplify_factorial_expression", "tool_type": "function", "description": "Simplifies an expression involving factorials, particularly useful for expressions\n    that include division and multiplication of multiple factorial terms.", "docstring": "Simplifies an expression involving factorials, particularly useful for expressions\n    that include division and multiplication of multiple factorial terms.\n    \n    Parameters:\n    expression (str): A string representing the mathematical expression to simplify,\n                      which can include factorial notation as `factorial(n)` where `n` can be any integer.\n    \n    Returns:\n    sympy.core.expr.Expr: The simplified form of the input expression.\n    \n    Examples:\n    >>> simplify_factorial_expression(\"factorial(5)/factorial(3)\")\n    20\n    \n    >>> simplify_factorial_expression(\"factorial(n)*factorial(n-1)/factorial(n+1)\")\n    factorial(n - 1)\n    \n    Notes:\n    The function uses SymPy's simplification utilities, which can handle symbolic expressions.\n    This function assumes a correct mathematical expression is passed as input.", "Freq": 0, "TSR": 0}], "Counting Digits": [{"tool": "def count_digits(number):\n    \n    return len(str(abs(number)))", "subfield": "Counting Digits", "tool_name": "count_digits", "tool_type": "function", "description": "Count the number of digits in the given number.", "docstring": "Count the number of digits in the given number.\n    Parameters:\n    number (int): The number whose digits are to be counted.\n    Returns:\n    int: The number of digits in the given number.\n    Examples:\n    >>> count_digits(123)\n    3\n    >>> count_digits(-12345)\n    5", "Freq": 1, "TSR": 1}, {"tool": "def count_specific_digit_numbers(start, end, allowed_digits):\n    \n    allowed_digits = set(map(str, allowed_digits))  # Convert digits to strings for comparison\n    count = 0\n    for num in range(start, end + 1):\n        if set(str(num)).issubset(allowed_digits):\n            count += 1\n    return count", "subfield": "Counting Digits", "tool_name": "count_specific_digit_numbers", "tool_type": "function", "description": "Counts numbers within a range [start, end] that consist exclusively of the allowed digits.", "docstring": "Counts numbers within a range [start, end] that consist exclusively of the allowed digits.\n    \n    Parameters:\n    start (int): Starting value of the range.\n    end (int): Ending value of the range.\n    allowed_digits (set): A set of digits that are allowed in the numbers.\n    Returns:\n    int: Count of numbers only containing the allowed digits.\n    Examples:\n    >>> count_specific_digit_numbers(100, 500, {1, 2, 5})\n    31", "Freq": 3, "TSR": 3}, {"tool": "def count_digit_palindromes(start, end):\n    \n    count = 0\n    for number in range(start, end + 1):\n        if str(number) == str(number)[::-1]:\n            count += 1\n    return count", "subfield": "Counting Digits", "tool_name": "count_digit_palindromes", "tool_type": "function", "description": "Count the palindromic numbers within a specified numeric range.", "docstring": "Count the palindromic numbers within a specified numeric range.\n    Parameters:\n    start (int): The starting number of the range.\n    end (int): The ending number of the range.\n    Returns:\n    int: The count of palindromic numbers in the range.\n    Examples:\n    >>> count_digit_palindromes(100, 300)\n    9  # Example output, exact computation needs implementation.", "Freq": 0, "TSR": 0}, {"tool": "def count_numbers_in_range_with_property(min_value, max_value, property_checker):\n    \n    return sum(1 for x in range(min_value, max_value + 1) if property_checker(x))", "subfield": "Counting Digits", "tool_name": "count_numbers_in_range_with_property", "tool_type": "function", "description": "Counts the numbers in a given range that satisfy a specified property.", "docstring": "Counts the numbers in a given range that satisfy a specified property.\n    Parameters:\n    min_value (int): The minimum value of the range.\n    max_value (int): The maximum value of the range.\n    property_checker (callable): A function that applies a property to check on each number.\n    Returns:\n    int: The count of numbers satisfying 'property_checker'.\n    Examples:\n    >>> count_numbers_in_range_with_property(1, 600, lambda x: x % 2 == 0)\n    300", "Freq": 0, "TSR": 0}, {"tool": "def is_palindrome(number):\n    \n    num_str = str(number)\n    return num_str == num_str[::-1]", "subfield": "Counting Digits", "tool_name": "is_palindrome", "tool_type": "function", "description": "Checks if a given integer is a palindrome.", "docstring": "Checks if a given integer is a palindrome.\n    Parameters:\n    number (int): The number to check.\n    Returns:\n    bool: True if 'number' is a palindrome, False otherwise.\n    Examples:\n    >>> is_palindrome(12321)\n    True\n    >>> is_palindrome(12345)\n    False", "Freq": 0, "TSR": 0}, {"tool": "def count_palindromic_times(limit_hour, limit_minute):\n    \n    def is_palindrome(s):\n        return s == s[::-1]\n    count = 0\n    for hour in range(limit_hour):\n        for min in range(limit_minute):\n            time_str = f\"{hour:02d}:{min:02d}\"\n            time_str = time_str.replace(\":\", \"\")\n            if is_palindrome(time_str):\n                count += 1\n    return count", "subfield": "Counting Digits", "tool_name": "count_palindromic_times", "tool_type": "function", "description": "Counts all the valid time combinations on a digital clock that are palindromes up to given hour and minute limits.", "docstring": "Counts all the valid time combinations on a digital clock that are palindromes up to given hour and minute limits.\n    Parameters:\n    - limit_hour (int): Maximum hour limit (24-based or 12-based).\n    - limit_minute (int): Maximum minute limit (typically 60).\n    Returns:\n    - int: Count of valid palindromic times.\n    Examples:\n    >>> count_palindromic_times(24, 60)\n    16\n    >>> count_palindromic_times(12, 60)\n    34", "Freq": 1, "TSR": 0}, {"tool": "def range_by_digit_count(digit_count):\n    \n    if digit_count < 1:\n        raise ValueError(\"digit_count must be at least 1\")\n    min_number = 10**(digit_count - 1)\n    max_number = 10**digit_count - 1\n    return (min_number, max_number)", "subfield": "Counting Digits", "tool_name": "range_by_digit_count", "tool_type": "function", "description": "Provides the minimum and maximum numbers that comprise the range of numbers with the specified digit count.", "docstring": "Provides the minimum and maximum numbers that comprise the range of numbers with the specified digit count.\n    Parameters:\n    digit_count (int): The specific digit count.\n    Returns:\n    tuple: A tuple containing the minimum and maximum numbers that have the specified digit count.\n    Examples:\n    >>> range_by_limit_count(3)\n    (100, 999)", "Freq": 0, "TSR": 0}], "Division and Remainders": [{"tool": "def calculate_division_properties(dividend, divisor):\n    \n    if divisor == 0:\n        raise ValueError(\"Divisor cannot be zero.\")\n    quotient = dividend // divisor\n    remainder = dividend % divisor\n    return quotient, remainder", "subfield": "Division and Remainders", "tool_name": "calculate_division_properties", "tool_type": "function", "description": "Calculates the quotient and remainder of integer division.", "docstring": "Calculates the quotient and remainder of integer division.\n    Parameters:\n        dividend (int): The number to be divided.\n        divisor (int): The number by which to divide.\n    Returns:\n        tuple:\n        - quotient (int): Result of the integer division.\n        - remainder (int): The remainder left over when dividend is divided by divisor.\n    Examples:\n    >>> calculate_division_properties(10, 3)\n    (3, 1)\n    >>> calculate_division_properties(25, 4)\n    (6, 1)", "Freq": 1, "TSR": 1}, {"tool": "def modular_sub(a, b, modulus):\n    \n    return (a - b) % modulus", "subfield": "Division and Remainders", "tool_name": "modular_sub", "tool_type": "function", "description": "Perform modular subtraction between two numbers.", "docstring": "Perform modular subtraction between two numbers.\n    Parameters:\n    a (int): First number.\n    b (int): Second number.\n    modulus (int): Modulus to be applied.\n    Returns:\n    int: Result of (a - b) % modulus\n    Examples:\n    >>> modular_sub(5, 3, 7)\n    2", "Freq": 0, "TSR": 0}, {"tool": "def find_remainder(n, m):\n    \n    return n % m", "subfield": "Division and Remainders", "tool_name": "find_remainder", "tool_type": "function", "description": "Calculate the remainder when n is divided by m (n % m).", "docstring": "Calculate the remainder when n is divided by m (n % m).\n    Parameters\n    ----------\n    n : int\n        The dividend.\n    m : int\n        The divisor.\n    Returns\n    -------\n    int\n        The remainder of the division of n by m (0 <= remainder < m).\n    Examples\n    --------\n    >>> find_remainder(10, 3)\n    1\n    >>> find_remainder(-10, 3)\n    2", "Freq": 7, "TSR": 3}, {"tool": "def modular_pow(base, exp, modulus):\n    \n    result = 1\n    base = base % modulus\n    while exp > 0:\n        if exp % 2 == 1:\n            result = (result * base) % modulus\n        exp = exp >> 1\n        base = (base * base) % modulus\n    return result", "subfield": "Division and Remainders", "tool_name": "modular_pow", "tool_type": "function", "description": "Efficiently compute (base ** exp) % modulus using exponentiation by squaring.", "docstring": "Efficiently compute (base ** exp) % modulus using exponentiation by squaring.\n    Parameters:\n    base (int): The base number.\n    exp (int): The exponent.\n    modulus (int): Modulus to be applied.\n    Returns:\n    int: Result of (base ** exp) % modulus\n    Examples:\n    >>> modular_pow(2, 10, 1000)\n    24", "Freq": 2, "TSR": 1}, {"tool": "def factorial_mod(n, modulus):\n    \n    result = 1\n    for i in range(2, n + 1):\n        result = (result * i) % modulus\n    return result\n    print(modular_add(5, 3, 7))   # Outputs 1\n    print(modular_sub(5, 3, 7))   # Outputs 2\n    print(modular_mult(3, 4, 5))  # Outputs 2\n    print(modular_div(8, 3, 5))   # Outputs 1\n    print(modular_pow(2, 10, 1000)) # Outputs 24\n    print(factorial_mod(5, 7))    # Outputs 1", "subfield": "Division and Remainders", "tool_name": "factorial_mod", "tool_type": "function", "description": "Compute factorial of n modulo a given modulus.", "docstring": "Compute factorial of n modulo a given modulus.\n    Parameters:\n    n (int): Number to compute factorial of.\n    modulus (int): Modulus to be applied to the factorial result.\n    Returns:\n    int: n! % modulus\n    Examples:\n    >>> factorial_mod(5, 7)\n    1", "Freq": 1, "TSR": 1}, {"tool": "def positive_modular(a, b):\n    \n    return a % b", "subfield": "Division and Remainders", "tool_name": "positive_modular", "tool_type": "function", "description": "Ensure the result of modular operation is positive.", "docstring": "Ensure the result of modular operation is positive.\n    \n    Parameters:\n        a (int): The number to be taken modulo of.\n        b (int): The modulus.\n        \n    Returns:\n        int: A positive remainder after division.\n        \n    Examples:\n        >>> positive_modular(-10, 3)\n        2", "Freq": 0, "TSR": 0}, {"tool": "def find_extreme_remainder(dividend, divisors, mode='max'):\n    \n    if not divisors:\n        raise ValueError(\"Divisors list cannot be empty.\")\n    best_match = None\n    extreme_value = None\n    for divisor in divisors:\n        if divisor == 0:\n            continue\n        remainder = dividend % divisor\n        if (mode == 'max' and (extreme_value is None or remainder > extreme_value)) or (mode == 'min' and (extreme_value is None or remainder < extreme_value)):\n            best_match = divisor\n            extreme_value = remainder\n    return {'divisor': best_match, 'remainder': extreme_value, 'extreme_value': extreme_value}", "subfield": "Division and Remainders", "tool_name": "find_extreme_remainder", "tool_type": "function", "description": "For a given dividend and list of divisors, find the divisor which yields the maximum or minimum remainder.", "docstring": "For a given dividend and list of divisors, find the divisor which yields the maximum or minimum remainder.\n    \n    Parameters:\n    dividend (int): The number to be divided.\n    divisors (list of int): A list of divisors.\n    mode (str): Either 'max' or 'min', determines whether to find the maximum or minimum remainder.\n    Returns:\n    dict: A dictionary with keys 'divisor', 'remainder', and 'extreme_value' showing the selected divisor, its remainder, and the value of the remainder.\n    Examples:\n    >>> find_extreme_remainder(10, [1, 2, 3, 4])\n    {'divisor': 3, 'remainder': 1, 'extreme_value': 1}\n    >>> find_extreme_remainder(10, [2, 3, 4], mode='min')\n    {'divisor': 2, 'remainder': 0, 'extreme_value': 0}\n    >>> find_extreme_remainder(10, [2, 3, 4], mode='max')\n    {'divisor': 3, 'remainder': 1, 'extreme_value': 1}", "Freq": 6, "TSR": 1}, {"tool": "def modular_remainder(a, b):\n    \n    return a % b", "subfield": "Division and Remainders", "tool_name": "modular_remainder", "tool_type": "function", "description": "Calculate the remainder when one number is divided by another using modular arithmetic.", "docstring": "Calculate the remainder when one number is divided by another using modular arithmetic.\n    \n    Parameters:\n        a (int): The dividend\n        b (int): The divisor (non-zero)\n        \n    Returns:\n        int: The remainder after division\n        \n    Examples:\n        >>> modular_remainder(10, 3)\n        1\n        >>> modular_remainder(-10, 3)\n        2", "Freq": 1, "TSR": 0}, {"tool": "def modular_div(a, b, modulus):\n    \n    from sympy import mod_inverse\n    return (a * mod_inverse(b, modulus)) % modulus", "subfield": "Division and Remainders", "tool_name": "modular_div", "tool_type": "function", "description": "Perform modular division where result is a * (inverse of b modulo modulus).", "docstring": "Perform modular division where result is a * (inverse of b modulo modulus).\n    Parameters:\n    a (int): Numerator.\n    b (int): Denominator to find the modular inverse of.\n    modulus (int): Modulus to be applied.\n    Returns:\n    int: Result of (a * modular_inverse(b, modulus)) % modulus\n    Examples:\n    >>> modular_div(8, 3, 5)\n    1\n    Note:\n    This function assumes that b has a modular inverse under the given modulus (modulus and b are coprime).", "Freq": 0, "TSR": 0}, {"tool": "def modular_power(base, exponent, modulus):\n    \n    return pow(base, exponent, modulus)", "subfield": "Division and Remainders", "tool_name": "modular_power", "tool_type": "function", "description": "Calculate the result of base raised to the power exponent, all under modulo of a specified number.", "docstring": "Calculate the result of base raised to the power exponent, all under modulo of a specified number.\n    \n    Parameters:\n        base (int): The base of the exponentiation.\n        exponent (int): The exponent.\n        modulus (int): The modulus to reduce the large number.\n        \n    Returns:\n        int: The result of (base ** exponent) % modulus\n    \n    Examples:\n        >>> modular_power(2, 10, 1000)\n        24", "Freq": 0, "TSR": 0}, {"tool": "def find_modular_inverses(n, modulus):\n    \n    if modulus <= 0:\n        raise ValueError(\"Modulus must be a positive integer.\")\n    inverses = [x for x in range(1, modulus) if (n * x) % modulus == 1]\n    return inverses", "subfield": "Division and Remainders", "tool_name": "find_modular_inverses", "tool_type": "function", "description": "Finds all values x such that (x * n) % modulus == 1, i.e., modular inverses under a given modulus.", "docstring": "Finds all values x such that (x * n) % modulus == 1, i.e., modular inverses under a given modulus.\n    Parameters:\n        n (int): The integer number for which to find the modular inverses.\n        modulus (int): The modulus under which the inverses are calculated.\n    Returns:\n        list: List of all integers x such that x is an inverse of n under modulus.\n    Examples:\n    >>> find_modular_inverses(3, 11)\n    [4]\n    >>> find_modular_inverses(2, 5)\n    [3]", "Freq": 0, "TSR": 0}], "Greatest Common Divisor (GCD)": [{"tool": "def gcd_multiple(numbers):\n    \n    return reduce(math.gcd, numbers)", "subfield": "Greatest Common Divisor (GCD)", "tool_name": "gcd_multiple", "tool_type": "function", "description": "Compute the Greatest Common Divisor (GCD) of a list of numbers.", "docstring": "Compute the Greatest Common Divisor (GCD) of a list of numbers.\n    \n    Parameters:\n        numbers (list of int): A list of integers for which the GCD is required.\n    \n    Returns:\n        int: The greatest common divisor of the provided numbers.\n    \n    Examples:\n        >>> gcd_multiple([42, 56, 98])\n        14\n        >>> gcd_multiple([20, 40])\n        20", "Freq": 1, "TSR": 1}, {"tool": "def calculate_gcd(a, b):\n    \n    return gcd(a, b)", "subfield": "Greatest Common Divisor (GCD)", "tool_name": "calculate_gcd", "tool_type": "function", "description": "Calculate the Greatest Common Divisor (GCD) of two numbers.", "docstring": "Calculate the Greatest Common Divisor (GCD) of two numbers.\n    Parameters:\n    a (int): The first number.\n    b (int): The second number.\n    Returns:\n    int: The GCD of the two numbers.\n    Examples:\n    >>> calculate_gcd(12, 18)\n    6\n    >>> calculate_gcd(100, 25)\n    25", "Freq": 24, "TSR": 22}, {"tool": "def calculate_lcm(a, b):\n    \n    return abs(a*b) // gcd(a, b)", "subfield": "Greatest Common Divisor (GCD)", "tool_name": "calculate_lcm", "tool_type": "function", "description": "Calculate the Least Common Multiple (LCM) using the relationship with GCD.", "docstring": "Calculate the Least Common Multiple (LCM) using the relationship with GCD.\n    Parameters:\n    a (int): The first number.\n    b (int): The second number.\n    Returns:\n    int: The LCM of the two numbers.\n    Examples:\n    >>> calculate_lcm(12, 18)\n    36\n    >>> calculate_lcm(5, 7)\n    35", "Freq": 3, "TSR": 3}, {"tool": "def prime_factors(n):\n    \n    from sympy import primefactors\n    factors = {}\n    for p in primefactors(n):\n        count = 0\n        x = n\n        while x % p == 0:\n            x //= p\n            count += 1\n        factors[p] = count\n    return factors", "subfield": "Greatest Common Divisor (GCD)", "tool_name": "prime_factors", "tool_type": "function", "description": "Calculate the prime factors of a given number.", "docstring": "Calculate the prime factors of a given number.\n    Parameters:\n    n (int): The integer to factorize.\n    Returns:\n    dict: Dictionary of prime factors and their exponents.\n    Example:\n    >>> prime_factors(60)\n    {2: 2, 3: 1, 5: 1}", "Freq": 0, "TSR": 0}, {"tool": "def _extended_gcd(a, b):\n    \n    if a == 0:\n        return (0, 1)\n    else:\n        x1, y1 = _extended_gcd(b % a, a)\n        return (y1 - (b // a) * x1, x1)", "subfield": "Greatest Common Divisor (GCD)", "tool_name": "_extended_gcd", "tool_type": "function", "description": "A helper function that returns integers x, y such that ax + by = gcd(a, b).", "docstring": "A helper function that returns integers x, y such that ax + by = gcd(a, b).", "Freq": 0, "TSR": 0}, {"tool": "def calculate_gcd_multiple(numbers):\n    \n    return reduce(gcd, numbers)", "subfield": "Greatest Common Divisor (GCD)", "tool_name": "calculate_gcd_multiple", "tool_type": "function", "description": "Calculate the GCD of a list of numbers.", "docstring": "Calculate the GCD of a list of numbers.\n    Parameters:\n    numbers (list of int): A list of integers.\n    Returns:\n    int: The GCD of the list of numbers.\n    Examples:\n    >>> calculate_gcd_multiple([24, 36, 48])\n    12\n    >>> calculate_gcd_multiple([20, 100, 200])\n    20", "Freq": 0, "TSR": 0}, {"tool": "def gcd_of_factorials(a, b):\n    \n    factorial_a = factorial(a)\n    factorial_b = factorial(b)\n    return gcd(factorial_a, factorial_b)", "subfield": "Greatest Common Divisor (GCD)", "tool_name": "gcd_of_factorials", "tool_type": "function", "description": "Computes the GCD of the factorials of two integers.", "docstring": "Computes the GCD of the factorials of two integers.\n    Parameters:\n        a (int): The first number whose factorial is considered.\n        b (int): The second number whose factorial is considered.\n    \n    Returns:\n        int: The GCD of the factorials of two integers.\n    \n    Examples:\n        >>> gcd_of_factorials(5, 6)\n        120  # Since 5! = 120 and 6! = 720; gcd(120, 720) = 120\n        >>> gcd_of_factorials(3, 4)\n        6    # Since 3! = 6 and 4! = 24; gcd(6, 24) = 6", "Freq": 4, "TSR": 3}, {"tool": "def gcd_of_polynomials(poly1, poly2):\n    \n    from numpy import gcd, polymul\n    # Convert polynomial tuples to a form usable for gcd computation\n    def poly_gcd(poly1, poly2):\n        result = [gcd(a, b) for a, b in zip(poly1, poly2)]\n        return tuple(result)\n    return poly_gcd(poly1, poly2)", "subfield": "Greatest Common Divisor (GCD)", "tool_name": "gcd_of_polynomials", "tool_type": "function", "description": "Computes the GCD of two polynomials represented as tuples of coefficients.", "docstring": "Computes the GCD of two polynomials represented as tuples of coefficients.\n    Parameters:\n        poly1 (tuple): The coefficients of the first polynomial.\n        poly2 (tuple): The coefficients of the second polynomial.\n    \n    Returns:\n        tuple: The GCD of the two polynomials in tuple format.\n    \n    Examples:\n        >>> gcd_of_polynomials((2, 4), (4, 8))\n        (2, 4)  # Equivalent to x + 2 where gcd is computed as tuple (1, 2)", "Freq": 0, "TSR": 0}, {"tool": "def factorial(n):\n    if n == 0:\n        return 1\n    else:\n        return n * factorial(n-1)", "subfield": "Greatest Common Divisor (GCD)", "tool_name": "factorial", "tool_type": "function", "description": "None", "docstring": null, "Freq": 0, "TSR": 0}], "Factorials and Multiples": [{"tool": "def compute_factorial(n):\n    \n    if n < 0:\n        raise ValueError(\"Factorial is not defined for negative numbers\")\n    return math.factorial(n)", "subfield": "Factorials and Multiples", "tool_name": "compute_factorial", "tool_type": "function", "description": "Compute the factorial of a non-negative integer n.", "docstring": "Compute the factorial of a non-negative integer n.\n    \n    Parameters:\n        n (int): A non-negative integer whose factorial is to be computed.\n        \n    Returns:\n        int: The factorial of n.\n        \n    Examples:\n        >>> compute_factorial(5)\n        120\n        >>> compute_factorial(0)\n        1", "Freq": 1, "TSR": 1}, {"tool": "def smallest_factorial_multiple(k):\n    \n    from sympy import factorint\n    factors = factorint(k)\n    return max(factors.keys())", "subfield": "Factorials and Multiples", "tool_name": "smallest_factorial_multiple", "tool_type": "function", "description": "Finds the smallest non-negative integer n such that k is a divisor of n!.", "docstring": "Finds the smallest non-negative integer n such that k is a divisor of n!.\n    \n    Parameters:\n    k : int\n        The target divisor.\n        \n    Returns:\n    int\n        The smallest n such that k divides n!.\n        \n    Example:\n    >>> smallest_factorial_multiple(7)\n    7", "Freq": 0, "TSR": 0}, {"tool": "def factorial_trailing_zeros(n):\n    \n    count = 0\n    if n < 0:\n        raise ValueError(\"Negative numbers do not have factorial trailing zeros.\")\n    i = 5\n    while n // i > 0:\n        count += n // i\n        i *= 5\n    return count", "subfield": "Factorials and Multiples", "tool_name": "factorial_trailing_zeros", "tool_type": "function", "description": "Count trailing zeros in n factorial.", "docstring": "Count trailing zeros in n factorial.\n    \n    Parameters:\n    n : int\n        The non-negative integer to find the factorial trailing zeros of.\n        \n    Returns:\n    int\n        Number of trailing zeros in n!.\n        \n    Example:\n    >>> factorial_tralterial_zeros(5)\n    1", "Freq": 1, "TSR": 0}, {"tool": "def factorial_binomial_coefficient(n, k):\n    \n    if k < 0 or k > n:\n        return 0\n    if k == 0 or k == n:\n        return 1\n    k = min(k, n - k)  # Take advantage of symmetry\n    c = 1\n    for i in range(k):\n        c = c * (n - i) // (i + 1)\n    return c", "subfield": "Factorials and Multiples", "tool_name": "factorial_binomial_coefficient", "tool_type": "function", "description": "Calculate the binomial coefficient, C(n, k) = n! / (k! (n-k)!), representing combinations of n objects taken k at a time.", "docstring": "Calculate the binomial coefficient, C(n, k) = n! / (k! (n-k)!), representing combinations of n objects taken k at a time.\n    \n    Parameters:\n        n (int): Total number of objects.\n        k (int): Number of objects to choose.\n    \n    Returns:\n        int: The binomial coefficient of n and k.\n    \n    Examples:\n        >>> factorial_binomial_coefficient(5, 2)\n        10\n        >>> factorial_binomial_coefficient(10, 3)\n        120", "Freq": 0, "TSR": 0}, {"tool": "def cancel_factorials(n, k):\n    \n    if n < k:\n        raise ValueError(\"n should be greater than or equal to k for cancellation.\")\n    result = 1\n    for i in range(k+1, n+1):\n        result *= i\n    return result", "subfield": "Factorials and Multiples", "tool_name": "cancel_factorials", "tool_type": "function", "description": "Simplify the expression n! / k! when n >= k by calculating the product from (k+1) to n.", "docstring": "Simplify the expression n! / k! when n >= k by calculating the product from (k+1) to n.\n    \n    Parameters:\n    - n (int): Numerator factorial.\n    - k (int): Denominator factorial.\n    \n    Returns:\n    int: The result of the simplification of n! / k!.\n    Examples:\n    >>> cancel_factorials(5, 3)\n    20", "Freq": 1, "TSR": 0}, {"tool": "def factorial_divisibility(n, k):\n    \n    count = 0\n    i = k\n    while i <= n:\n        count += n // i\n        i *= k\n    return count", "subfield": "Factorials and Multiples", "tool_name": "factorial_divisibility", "tool_type": "function", "description": "Determine the largest power of k that divides n! (n factorial) without a remainder.", "docstring": "Determine the largest power of k that divides n! (n factorial) without a remainder.\n    \n    Parameters:\n        n (int): A non-negative integer representing the factorial to be analyzed.\n        k (int): A positive integer to check for divisibility into n!.\n    \n    Returns:\n        int: The largest exponent such that k^exponent divides n! without remainder.\n        \n    Examples:\n        >>> factorial_divisibility(5, 2)\n        3\n        >>> factorial_divisibility(10, 5)\n        2", "Freq": 1, "TSR": 0}, {"tool": "def factorial_division(numerator, denominator):\n    \n    if denominator > numerator:\n        raise ValueError(\"Denominator must be less than or equal to numerator.\")\n    product = 1\n    for i in range(denominator + 1, numerator + 1):\n        product *= i\n    return product", "subfield": "Factorials and Multiples", "tool_name": "factorial_division", "tool_type": "function", "description": "Simplifies the division of two factorials using cancellation of common terms.", "docstring": "Simplifies the division of two factorials using cancellation of common terms.\n    \n    Parameters:\n    numerator : int\n        The numerator factorial.\n    denominator : int\n        The denominator factorial, should be less than or equal to numerator.\n        \n    Returns:\n    int\n        The simplified result of `numerator! / denominator!`.\n        \n    Example:\n    >>> factorial_division(5, 3)\n    20", "Freq": 0, "TSR": 0}, {"tool": "def calculate_combinations(n, k):\n    \n    return comb(n, k)", "subfield": "Factorials and Multiples", "tool_name": "calculate_combinations", "tool_type": "function", "description": "Calculate the number of combinations (also known as \"n choose k\") which is the way to select k items from n items without considering the order.", "docstring": "Calculate the number of combinations (also known as \"n choose k\") which is the way to select k items from n items without considering the order.\n    \n    Parameters:\n    - n (int): Total number of items.\n    - k (int): Number of items to choose.\n    \n    Returns:\n    int: The number of possible combinations.\n    Examples:\n    >>> calculate_combinations(5, 2)\n    10\n    >>> calculate_combinations(10, 3)\n    120", "Freq": 0, "TSR": 0}], "Digit Sums": [{"tool": "def digit_sum(number):\n    \n    return sum(int(digit) for digit in str(abs(number)))", "subfield": "Digit Sums", "tool_name": "digit_sum", "tool_type": "function", "description": "Calculate the sum of the digits of a number.", "docstring": "Calculate the sum of the digits of a number.\n    \n    Parameters:\n    number (int): The number whose digits will be summed.\n    Returns:\n    int: The sum of the digits of the number.\n    Examples:\n    >>> digit_sum(123)\n    6\n    >>> digit_sum(104)\n    5", "Freq": 1, "TSR": 1}, {"tool": "def reverse_digits(n):\n    \n    return int(str(n)[::-1]) if n >= 0 else -int(str(-n)[::-1])", "subfield": "Digit Sums", "tool_name": "reverse_digits", "tool_type": "function", "description": "Reverse the digits of the number `n` and return the resulting integer.", "docstring": "Reverse the digits of the number `n` and return the resulting integer.\n    \n    Parameters:\n        n (int): The number to be reversed.\n    \n    Returns:\n        int: The integer formed by the reverse order of the digits of `n`.\n    Examples:\n        >>> reverse_digits(123)\n        321\n        >>> reverse_digits(100)\n        1", "Freq": 0, "TSR": 0}, {"tool": "def digit_count(n):\n    \n    return len(str(abs(n)))", "subfield": "Digit Sums", "tool_name": "digit_count", "tool_type": "function", "description": "Count the number of digits in an integer.", "docstring": "Count the number of digits in an integer.\n    Parameters:\n    -----------\n    n : int\n        The number to count the digits of.\n    Returns:\n    --------\n    int\n        Number of digits in `n`.\n    Examples:\n    ---------\n    >>> digit_count(12345)\n    5\n    >>> digit_count(-123)\n    3", "Freq": 2, "TSR": 1}, {"tool": "def digit_sum(n, filter_divisor=None):\n    \n    s = sum(int(digit) for digit in str(abs(n)))\n    if filter_divisor is not None and s % filter_divisor != 0:\n        return 0\n    return s", "subfield": "Digit Sums", "tool_name": "digit_sum", "tool_type": "function", "description": "Calculate the sum of the digits of an integer `n`. Optionally, only consider the sum if it is divisible by `filter_divisor`.", "docstring": "Calculate the sum of the digits of an integer `n`. Optionally, only consider the sum if it is divisible by `filter_divisor`.\n    \n    Parameters:\n        n (int): The number whose digit sum is calculated.\n        filter_divisor (int, optional): If specified, the function will check if the digit sum is divisible by this number and return the sum if true, otherwise 0.\n    Returns:\n        int: The sum of the digits of `n` if `filter_divisor` is None or if the sum is divisible by `filter_divisor`, otherwise 0.\n    Examples:\n        >>> digit_sum(123)\n        6\n        >>> digit_sum(123, filter_divisor=3)\n        6\n        >>> digit_sum(124, filter_divisor=3)\n        0", "Freq": 0, "TSR": 0}, {"tool": "def is_palindrome(n):\n    \n    s = str(n)\n    return s == s[::-1]", "subfield": "Digit Sums", "tool_name": "is_palindrome", "tool_type": "function", "description": "Checks whether a given number is a palindrome.", "docstring": "Checks whether a given number is a palindrome.\n    Parameters:\n    - n (int): The number to check.\n    Returns:\n    - bool: True if n is a palindrome; otherwise False.\n    Examples:\n    >>> is_palindrome(121)\n    True\n    >>> is_palindrome(123)\n    False", "Freq": 3, "TSR": 2}, {"tool": "def max_digit_sum_ordering(digits, desired_sum):\n    \n    from itertools import permutations\n    valid_numbers = []\n    for perm in permutations(digits):\n        if sum(perm) == desired_sum:\n            valid_numbers.append(int(''.join(map(str, perm))))\n    return max(valid_numbers, default=None)", "subfield": "Digit Sums", "tool_name": "max_digit_sum_ordering", "tool_type": "function", "description": "Find the largest number formed by arranging digits to achieve a specified sum of digits.", "docstring": "Find the largest number formed by arranging digits to achieve a specified sum of digits.\n    Parameters:\n    -----------\n    digits : list of int\n        List of individual digits available.\n    desired_sum : int\n        The desired sum of the digits of the resulting number.\n    Returns:\n    --------\n    int or None\n        The largest number possible with the desired digit sum, or None if no such arrangement exists.\n    Examples:\n    ---------\n    >>> max_digit_sum_ordering([1, 2, 3, 9], 14)\n    9321", "Freq": 1, "TSR": 1}, {"tool": "def digit_counter(number):\n    \n    counts = {}\n    for digit in str(abs(number)):\n        dig = int(digit)\n        if dig in counts:\n            counts[dig] += 1\n        else:\n            counts[dig] = 1\n    return counts", "subfield": "Digit Sums", "tool_name": "digit_counter", "tool_type": "function", "description": "Counts the occurrence of each digit in a number.", "docstring": "Counts the occurrence of each digit in a number.\n    Parameters:\n    number (int): The number to count digits from.\n    Returns:\n    dict: A dictionary with digits as keys and their counts as values.\n    Examples:\n    >>> digit_counter(112233)\n    {1: 2, 2: 2, 3: 2}\n    >>> digit_counter(456789)\n    {4: 1, 5: 1, 6: 1, 7: 1, 8: 1, 9: 1}", "Freq": 0, "TSR": 0}, {"tool": "def sum_of_digit_powers(n, power):\n    \n    return sum(int(d)**power for d in str(abs(n)))", "subfield": "Digit Sums", "tool_name": "sum_of_digit_powers", "tool_type": "function", "description": "Calculate the sum of the digits of a number raised to a specific power.", "docstring": "Calculate the sum of the digits of a number raised to a specific power.\n    Parameters:\n    -----------\n    n : int\n        The number whose digits will be raised to the power and summed.\n    power : int\n        The power to raise each digit.\n    Returns:\n    --------\n    int\n        Sum of the digits of `n` raised to the `power`.\n    Examples:\n    ---------\n    >>> sum_of_digit_powers(123, 2)\n    14  # 1^2 + 2^2 + 3^2\n    >>> sum_of_digit_powers(321, 3)\n    36  # 3^3 + 2^3 + 1^3", "Freq": 1, "TSR": 1}, {"tool": "def valid_digit_combinations(range_digits, check_evenness=True):\n    \n    from itertools import product\n    if check_evenness:\n        pairs = [(d1, d2) for d1 in range_digits for d2 in range_digits if (d1 % 2 == d2 % 2)]\n    else:\n        pairs = list(product(range_digits, repeat=2))\n    return len(pairs) * len(range_digits)", "subfield": "Digit Sums", "tool_name": "valid_digit_combinations", "tool_type": "function", "description": "Count combinations of digits from the range where first and last digits follow specific rules.", "docstring": "Count combinations of digits from the range where first and last digits follow specific rules.\n    Parameters:\n    -----------\n    range_digits : list of int\n        The digits available for forming combinations.\n    check_evenness : bool\n        If true, checks that the first and last digits must both be even or both be odd.\n    Returns:\n    --------\n    int\n        Count of valid combinations of digits given the conditions.\n    Examples:\n    ---------\n    >>> valid_digit_combinations([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])\n    30  # 10 possible even-even or odd-odd pairs with 10 choices in between", "Freq": 0, "TSR": 0}, {"tool": "def is_palindrome(number, base=10):\n    \n    original = number\n    reversed_num = 0\n    while number > 0:\n        reversed_num = reversed_num * base + number % base\n        number //= base\n    return original == reversed_num", "subfield": "Digit Sums", "tool_name": "is_palindrome", "tool_type": "function", "description": "Check if a given number is a palindrome in the specified base.", "docstring": "Check if a given number is a palindrome in the specified base.\n    Parameters:\n    - number (int): The number to check.\n    - base (int): The numerical base in which the number's palindromic nature is to be assessed.\n    Returns:\n    - bool: True if the number is a palindrome, False otherwise.\n    Examples:\n    >>> is_palindrome(121)\n    True\n    >>> is_palindrome(123, 10)\n    False\n    >>> is_palindrome(0b101, 2)\n    True", "Freq": 0, "TSR": 0}, {"tool": "def count_digit_occurrences_in_range(start, end, digit):\n    \n    count = 0\n    for num in range(start, end + 1):\n        count += str(num).count(digit)\n    return count", "subfield": "Digit Sums", "tool_name": "count_digit_occurrences_in_range", "tool_type": "function", "description": "Counts how many times a specific digit appears within a range of numbers.", "docstring": "Counts how many times a specific digit appears within a range of numbers.\n    Parameters:\n    start (int): Start of the range (inclusive).\n    end (int): End of the range (inclusive).\n    digit (str): The digit to count occurrences of.\n    Returns:\n    int: Total count of the digit's occurrences within the specified range.\n    Examples:\n    >>> count_digit_occurrences_in_range(10, 30, '1')\n    12\n    >>> count_digit_occurrences_in_range(1, 100, '0')\n    9", "Freq": 3, "TSR": 1}, {"tool": "def is_palindromic_number(n):\n    \n    str_n = str(n)\n    return str_n == str_n[::-1]", "subfield": "Digit Sums", "tool_name": "is_palindromic_number", "tool_type": "function", "description": "Check if the given integer is a palindromic number.\n    \n    A palindromic number is a number that remains the same when its digits are reversed.", "docstring": "Check if the given integer is a palindromic number.\n    \n    A palindromic number is a number that remains the same when its digits are reversed.\n    Parameters:\n    - n (int): The number to check.\n    Returns:\n    - bool: True if n is a palindromic number, otherwise False.\n    Examples:\n    >>> is_palindromic_number(121)\n    True\n    >>> is_palindromic_number(123)\n    False", "Freq": 0, "TSR": 0}], "Modulo Arithmetic": [{"tool": "def modular_add(a, b, mod):\n    \n    return (a + b) % mod", "subfield": "Modulo Arithmetic", "tool_name": "modular_add", "tool_type": "function", "description": "Perform modular addition between two numbers.", "docstring": "Perform modular addition between two numbers.\n    Parameters:\n        a (int): The first integer.\n        b (int): The second integer.\n        mod (int): The modulus.\n    Returns:\n        int: The result of (a + b) % mod\n    Examples:\n        >>> modular_add(5, 3, 7)\n        1", "Freq": 5, "TSR": 5}, {"tool": "def solve_linear_congruence(a, b, m):\n    \n    from sympy.ntheory.modular import solve_congruence\n    \n    # Transforming into the format required by solve_congruence ((a, m), (b, n))\n    cong = ((b, m),)\n    solution = solve_congruence(*cong)\n    \n    if solution is None:\n        return None\n    else:\n        return solution[0]", "subfield": "Modulo Arithmetic", "tool_name": "solve_linear_congruence", "tool_type": "function", "description": "Solve the linear congruence of the form ax ≡ b (mod m).", "docstring": "Solve the linear congruence of the form ax ≡ b (mod m).\n    Parameters:\n    - a: Coefficient of x in the congruence.\n    - b: The right-hand side of the congruence.\n    - m: The modulus.\n    Returns:\n    - The smallest non-negative solution x of the congruence. If no solution, returns None.\n    \n    Examples:\n    >>> solve_linear_congruence(7, 1, 26)\n    15", "Freq": 16, "TSR": 6}, {"tool": "def modular_inverse(a, m):\n    \n    try:\n        return mod_inverse(a, m)\n    except ValueError:\n        return \"No Inverse Exists\"", "subfield": "Modulo Arithmetic", "tool_name": "modular_inverse", "tool_type": "function", "description": "Compute the modular inverse of a mod m.\n    \n    Args:\n        a : int\n            The number whose modular inverse is to be calculated.\n        m : int\n            The modular value.\n   \n    Returns:\n        int\n            Returns the modular inverse of a mod m.", "docstring": "Compute the modular inverse of a mod m.\n    \n    Args:\n        a : int\n            The number whose modular inverse is to be calculated.\n        m : int\n            The modular value.\n   \n    Returns:\n        int\n            Returns the modular inverse of a mod m.", "Freq": 2, "TSR": 2}, {"tool": "def modular_inverse(a, mod):\n    \n    try:\n        return pow(a, -1, mod)\n    except ValueError:\n        return None", "subfield": "Modulo Arithmetic", "tool_name": "modular_inverse", "tool_type": "function", "description": "Find the modular multiplicative inverse of a under modulo mod.", "docstring": "Find the modular multiplicative inverse of a under modulo mod.\n    Parameters:\n        a (int): The integer to find the inverse.\n        mod (int): The modulus.\n    Returns:\n        int or None: The modular inverse of a modulo mod if it exists, otherwise None.\n    Examples:\n        >>> modular_inverse(3, 11)\n        4", "Freq": 2, "TSR": 2}, {"tool": "def calc_modulo(number, mod):\n    \n    return number % mod", "subfield": "Modulo Arithmetic", "tool_name": "calc_modulo", "tool_type": "function", "description": "Calculate the remainder of a division by `mod`.", "docstring": "Calculate the remainder of a division by `mod`.\n    Parameters:\n    - number (int): The number to be divided.\n    - mod (int): The divisor (modulus) to divide by.\n    Returns:\n    int: The remainder when `number` is divided by `mod`.\n    Example:\n    >>> calc_modulo(10, 3)\n    1", "Freq": 10, "TSR": 8}, {"tool": "def is_congruent(a, b, m):\n    \n    return a % m == b % m", "subfield": "Modulo Arithmetic", "tool_name": "is_congruent", "tool_type": "function", "description": "Determine if 'a' and 'b' are congruent modulo 'm'.\n    Args:\n        a : int\n            First integer.\n        b : int\n            Second integer.\n        m : int\n            The modular value.\n    Returns:\n        bool\n            Returns True if 'a' and 'b' are congruent modulo 'm', else False.", "docstring": "Determine if 'a' and 'b' are congruent modulo 'm'.\n    Args:\n        a : int\n            First integer.\n        b : int\n            Second integer.\n        m : int\n            The modular value.\n    Returns:\n        bool\n            Returns True if 'a' and 'b' are congruent modulo 'm', else False.", "Freq": 2, "TSR": 2}, {"tool": "def extended_gcd(a, b):\n    \n    if a == 0:\n        return (b, 0, 1)\n    else:\n        gcd, x, y = extended_gcd(b % a, a)\n        return (gcd, y - (b // a) * x, x)", "subfield": "Modulo Arithmetic", "tool_name": "extended_gcd", "tool_type": "function", "description": "Extended Euclidean Algorithm to find x, y such that ax + by = gcd(a, b)", "docstring": "Extended Euclidean Algorithm to find x, y such that ax + by = gcd(a, b)\n    Parameters:\n        a (int): First number\n        b (int): Second number\n    Returns:\n        tuple: (gcd, x, y), where gcd is the greatest common divisor and x, y are the coefficients of a and b respectively in the equation ax + by = gcd\n    Examples:\n        >>> extended_gcd(18, 12)\n        (6, 1, -1)", "Freq": 0, "TSR": 0}, {"tool": "def modular_exponentiation(base, exponent, modulus):\n    \n    if gcd(base, modulus) == 1:  # If base and modulus are coprime, Fermat's little theorem can be applied.\n        exponent = exponent % (modulus - 1)\n    result = pow(base, exponent, modulus)\n    return result", "subfield": "Modulo Arithmetic", "tool_name": "modular_exponentiation", "tool_type": "function", "description": "Calculate base^exponent mod modulus efficiently.", "docstring": "Calculate base^exponent mod modulus efficiently.\n    Parameters:\n    - base: The base of the exponentiation.\n    - exponent: The exponent.\n    - modulus: The modulus.\n    Returns:\n    - The result of (base^exponent) mod modulus.\n    \n    Examples:\n    >>> modular_exponentiation(2, 10, 1000)\n    24", "Freq": 4, "TSR": 3}, {"tool": "def reduce_modulo(a, m):\n    \n    return a % m", "subfield": "Modulo Arithmetic", "tool_name": "reduce_modulo", "tool_type": "function", "description": "Reduce a number 'a' modulo 'm'.\n    Args:\n        a : int\n            The number which is to be reduced.\n        m : int\n            The modular value.\n    Returns:\n        int\n            Returns 'a' modulo 'm'.", "docstring": "Reduce a number 'a' modulo 'm'.\n    Args:\n        a : int\n            The number which is to be reduced.\n        m : int\n            The modular value.\n    Returns:\n        int\n            Returns 'a' modulo 'm'.", "Freq": 0, "TSR": 0}, {"tool": "def calculate_mod_inverse(a, m):\n    \n    try:\n        return mod_inverse(a, m)\n    except ValueError as ve:\n        print(f\"No modular multiplicative inverse for {a} under modulo {m}\")\n        return None", "subfield": "Modulo Arithmetic", "tool_name": "calculate_mod_inverse", "tool_type": "function", "description": "This function calculates the modular multiplicative inverse of 'a' under modulo 'm'. \n    i.e., it finds an integer 'b' such that (ab)mod m == 1.", "docstring": "This function calculates the modular multiplicative inverse of 'a' under modulo 'm'. \n    i.e., it finds an integer 'b' such that (ab)mod m == 1.\n    \n    Parameters:\n        a (int): integer to compute the modular inverse for \n        m (int): modulo to consider \n        \n    Returns:\n        int: modular inverse of `a` under modulo `m`\n        \n    Example:\n        >>> calculate_mod_inverse(3, 7)\n        5 #because (3*5)%7 == 1", "Freq": 0, "TSR": 0}, {"tool": "def mod_reduce(number, modulus):\n    \n    return number % modulus", "subfield": "Modulo Arithmetic", "tool_name": "mod_reduce", "tool_type": "function", "description": "Reduces a number modulo a given modulus.", "docstring": "Reduces a number modulo a given modulus.\n    \n    Parameters:\n        number (int): The number to be reduced.\n        modulus (int): The modulus to be used for reduction.\n        \n    Returns:\n        int: The equivalent number in the range [0, modulus-1].\n        \n    Examples:\n        >>> mod_reduce(10, 3)\n        1\n        >>> mod_reduce(-4, 3)\n        2", "Freq": 0, "TSR": 0}, {"tool": "def least_non_negative_residue(a, mod):\n    \n    return a % mod", "subfield": "Modulo Arithmetic", "tool_name": "least_non_negative_residue", "tool_type": "function", "description": "Compute the least non-negative residue of a under modulo mod.", "docstring": "Compute the least non-negative residue of a under modulo mod.\n    Parameters:\n        a (int): The integer.\n        mod (int): The modulus.\n    Returns:\n        int: The least non-negative residue of a modulo mod.\n    Examples:\n        >>> least_non_negative_residue(-3, 5)\n        2", "Freq": 0, "TSR": 0}, {"tool": "def simplifying_arithmetic_modulo(a, operator, b, modulo):\n    \n    if operator == '+':\n        return (a + b) % modulo\n    elif operator == '-':\n        return (a - b) % modulo\n    elif operator == '*':\n        return (a * b) % modulo\n    elif operator == '/':\n        b_inverse = calculate_mod_inverse(b, modulo)\n        if b_inverse is not None:\n            return (a * b_inverse) % modulo\n        return None", "subfield": "Modulo Arithmetic", "tool_name": "simplifying_arithmetic_modulo", "tool_type": "function", "description": "This function takes two integers a and b, an operator (either '+', '-', '*', '/') and a modulus. \n    It applies the operator to the numbers and reduces the result modulo the given modulus.", "docstring": "This function takes two integers a and b, an operator (either '+', '-', '*', '/') and a modulus. \n    It applies the operator to the numbers and reduces the result modulo the given modulus.\n    Parameters:\n        a (int): The first operand\n        operator (str): The operator to use. Possible values: '+', '-', '*', '/'\n        b (int): The second operand\n        modulo (int): The modulus to use for the calculation\n    Returns:\n        int: The simplified value of the operation\n    Example:\n        >>> simplifying_arithmetic_modulo(10, '+', 15, 7)\n        4 # because (10 + 15) = 25, and 25 modulo 7 equals 4", "Freq": 0, "TSR": 0}, {"tool": "def is_equivalent_modulo(a, b, mod):\n    \n    return (a % mod) == (b % mod)", "subfield": "Modulo Arithmetic", "tool_name": "is_equivalent_modulo", "tool_type": "function", "description": "Check if two numbers are equivalent under a specified modulo.", "docstring": "Check if two numbers are equivalent under a specified modulo.\n    Parameters:\n    - a (int): The first number.\n    - b (int): The second number.\n    - mod (int): The modulus to test equivalence under.\n    Returns:\n    bool: True if `a` is equivalent to `b` under modulo `mod`, otherwise False.\n    Example:\n    >>> is_equivalent_modulo(14, 3, 11)\n    True", "Freq": 0, "TSR": 0}, {"tool": "def sum_modulo(numbers, mod):\n    \n    return sum(numbers) % mod", "subfield": "Modulo Arithmetic", "tool_name": "sum_modulo", "tool_type": "function", "description": "Calculate the sum of a list of numbers under a specified modulo.", "docstring": "Calculate the sum of a list of numbers under a specified modulo.\n    Parameters:\n    - numbers (list of int): List of integers to be summed.\n    - mod (int): The modulus for the sum operation.\n    Returns:\n    int: The result of the sum modulo `mod`.\n    Example:\n    >>> sum_modulo([1, 2, 3, 4], 3)\n    1", "Freq": 1, "TSR": 1}], "Base Conversion": [{"tool": "def convert_base(number, source_base, target_base):\n    \n    import numpy as np\n    # Convert the number from any base to base 10\n    base10 = int(number, source_base)\n    # Convert from base 10 to the target base\n    if target_base == 10:\n        return str(base10)\n    else:\n        return np.base_repr(base10, base=target_base)", "subfield": "Base Conversion", "tool_name": "convert_base", "tool_type": "function", "description": "Convert a number from a specific source base to a target base.", "docstring": "Convert a number from a specific source base to a target base.\n    Parameters:\n    - number (str): The number in string format in the source base.\n    - source_base (int): The base of the input number.\n    - target_base (int): The base to which the number needs to be converted.\n    Returns:\n    - str: The number converted into the target base.\n    Examples:\n    >>> convert_base('101', 2, 10)\n    '5'\n    >>> convert_base('FF', 16, 2)\n    '11111111'", "Freq": 5, "TSR": 3}, {"tool": "def binary_to_decimal(binary_str):\n    \n    return int(binary_str, 2)", "subfield": "Base Conversion", "tool_name": "binary_to_decimal", "tool_type": "function", "description": "Convert a binary number (as a string) to its decimal (base 10) representation.", "docstring": "Convert a binary number (as a string) to its decimal (base 10) representation.\n    \n    Parameters:\n    - binary_str (str): The binary number as a string.\n    \n    Returns:\n    - int: The decimal representation of the binary number.\n    \n    Examples:\n    >>> binary_to_decimal('101')\n    5\n    >>> binary_to.getValueOfKey('1101')\n    13", "Freq": 0, "TSR": 0}, {"tool": "def smallest_palindrome_of_length(length, base):\n    \n    if length == 1:\n        return '1'\n    elif length == 2:\n        return '11'\n    \n    # Start with the minimal number consisting of \"1\" followed by zeroes and closing with \"1\"\n    start = '1' + '0' * (length - 2) + '1'\n    return start", "subfield": "Base Conversion", "tool_name": "smallest_palindrome_of_length", "tool_type": "function", "description": "Finds the smallest palindromic number with the specified length in the given base.", "docstring": "Finds the smallest palindromic number with the specified length in the given base.\n    \n    Parameters:\n        length (int): The length of the palindromic number.\n        base (int): The base in which the palindrome should exist.\n    Returns:\n        str: The smallest palindrome of the given length in the specified base.\n        \n    Examples:\n        >>> smallest_palindrome_of_length(5, 2)\n        '10001'\n        >>> smallest_palindrome_of_length(3, 10)\n        '101'", "Freq": 1, "TSR": 0}, {"tool": "def smallest_binary_palindrome(length):\n    \n    # Must at least be of length 1 and has to be odd for a singular smallest palindromic number\n    if length < 1:\n        raise ValueError(\"Length must be at least 1.\")\n    \n    if length == 1:\n        return \"1\"\n    \n    half = \"1\" + \"0\" * (length // 2 - 1)\n    return half + half[::-1]  # mirror the first half to form a palindrome", "subfield": "Base Conversion", "tool_name": "smallest_binary_palindrome", "tool_type": "function", "description": "Find the smallest palindromic number in binary with a specified length.", "docstring": "Find the smallest palindromic number in binary with a specified length.\n    Parameters:\n    length : int\n        The length of the binary palindrome.\n    Returns:\n    str:\n        The smallest binary palindromic number of the specified length.\n    Examples:\n    >>> smallest_binary_palindrome(5)\n    '10001'", "Freq": 0, "TSR": 0}], "Least Common Multiple": [{"tool": "def lcm_multiple(numbers):\n    \n    return reduce(lcm, numbers)", "subfield": "Least Common Multiple", "tool_name": "lcm_multiple", "tool_type": "function", "description": "Calculate the LCM of a list of integers using the lcm function defined above through reduction.", "docstring": "Calculate the LCM of a list of integers using the lcm function defined above through reduction.\n    Parameters:\n    - numbers (list of int): List of integers to find the LCM for.\n    Returns:\n    - int: LCM of the given list of integers.\n    Examples:\n    >>> lcm_multiple([12, 15, 18])\n    180\n    >>> lcm_multiple([4, 6, 8, 12])\n    24", "Freq": 6, "TSR": 4}, {"tool": "def lcm(x, y):\n    \n    return abs(x * y) // gcd(x, y)", "subfield": "Least Common Multiple", "tool_name": "lcm", "tool_type": "function", "description": "Calculate the Least Common Multiple (LCM) of two integers.", "docstring": "Calculate the Least Common Multiple (LCM) of two integers.\n    Parameters:\n    - x (int): First integer.\n    - y (int): Second integer.\n    Returns:\n    - int: LCM of the two integers.\n    Examples:\n    >>> lcm(12, 18)\n    36\n    >>> lcm(5, 11)\n    55", "Freq": 2, "TSR": 2}, {"tool": "def prime_factorization(number):\n    \n    if number <= 0:\n        raise ValueError(\"Number must be a positive integer.\")\n    factors = []\n    for factor in primefactors(number):\n        count = 0\n        temp = number\n        while temp % factor == 0:\n            temp //= factor\n            count += 1\n        factors.extend([factor] * count)\n    return factors", "subfield": "Least Common Multiple", "tool_name": "prime_factorization", "tool_type": "function", "description": "Computes the prime factorization of a given integer.", "docstring": "Computes the prime factorization of a given integer.\n    Parameters:\n    - number (int): The integer to be factorized.\n    \n    Returns:\n    - List[int]: A list containing the prime factors of the input integer.\n    \n    Examples:\n    >>> prime_factorization(60)\n    [2, 2, 3, 5]\n    \n    >>> prime_factorization(13)\n    [13]", "Freq": 0, "TSR": 0}, {"tool": "def prime_factorization(n):\n    \n    return primefactors(n)", "subfield": "Least Common Multiple", "tool_name": "prime_factorization", "tool_type": "function", "description": "Compute the prime factors of a given positive integer n using the sympy library.", "docstring": "Compute the prime factors of a given positive integer n using the sympy library.\n    Parameters\n    ----------\n    n : int\n        The integer to factorize.\n    Returns\n    -------\n    list\n        A list of the prime factors of the integer.\n    Examples\n    --------\n    >>> prime_factorization(18)\n    [2, 3]\n    >>> prime_factorization(100)\n    [2, 5]", "Freq": 0, "TSR": 0}], "Integers": [{"tool": "def find_factors(n):\n    \n    factors = []\n    for i in range(1, int(n ** 0.5) + 1):\n        if n % i == 0:\n            factors.append(i)\n            if i != n // i:\n                factors.append(n // i)\n    factors.sort()\n    return factors", "subfield": "Integers", "tool_name": "find_factors", "tool_type": "function", "description": "Finds all factors of the given integer.", "docstring": "Finds all factors of the given integer.\n    Parameters:\n    n (int): The integer to find factors of.\n    Returns:\n    list: A list containing all the factors of n.\n    Examples:\n    >>> find_factors(36)\n    [1, 2, 3, 4, 6, 9, 12, 18, 36]\n    >>> find_factors(101)\n    [1, 101]", "Freq": 0, "TSR": 0}, {"tool": "def gcd_multiple(numbers: List[int]) -> int:\n    \n    from functools import reduce\n    return reduce(math.gcd, numbers)", "subfield": "Integers", "tool_name": "gcd_multiple", "tool_type": "function", "description": "Compute the greatest common divisor of a list of integers.", "docstring": "Compute the greatest common divisor of a list of integers.\n    \n    Parameters:\n    - numbers (List[int]): A list of integers to find the GCD.\n    \n    Returns:\n    int: The greatest common divisor of the provided numbers.\n    \n    Example:\n    >>> gcd_multiple([8, 12, 16])\n    4", "Freq": 0, "TSR": 0}, {"tool": "def multiples(n, limit):\n    \n    return [i * n for i in range(1, limit // n + 1)]", "subfield": "Integers", "tool_name": "multiples", "tool_type": "function", "description": "Find all multiples of the given integer up to a specified limit.", "docstring": "Find all multiples of the given integer up to a specified limit.\n    Parameters:\n    n (int): Integer to find multiples of.\n    limit (int): Upper limit to search for multiples.\n    Returns:\n    list: List of multiples of n up to limit.\n    Examples:\n    >>> multiples(3, 10)\n    [3, 6, 9]", "Freq": 0, "TSR": 0}, {"tool": "def unique_mode(integers):\n    \n    counts = Counter(integers)\n    if len(set(counts.values())) == 1:  # check for tie in frequency\n        return None\n    mode = max(counts, key=counts.get)\n    return (mode, counts[mode])", "subfield": "Integers", "tool_name": "unique_mode", "tool_type": "function", "description": "Finds the mode of a list of integers that appears most frequently.", "docstring": "Finds the mode of a list of integers that appears most frequently.\n    Parameters:\n    integers (list): List of integers.\n    Returns:\n    tuple: mode of the list and its frequency, or None if no unique mode exists.\n    Examples:\n    >>> unique_mode([1, 2, 2, 3, 4])\n    (2, 2)\n    >>> unique_message([1, 1, 2, 2, 3, 3])\n    None", "Freq": 0, "TSR": 0}, {"tool": "def integer_solutions(poly, domain_range):\n    \n    return [(x, poly(x)) for x in domain_range if isinstance(poly(x), int)]", "subfield": "Integers", "tool_name": "integer_solutions", "tool_type": "function", "description": "Identify integer solutions for a polynomial within a specified domain.", "docstring": "Identify integer solutions for a polynomial within a specified domain.\n    Parameters:\n    poly (function): Polynomial function.\n    domain_range (range): Range of domain to check for integer solutions.\n    Returns:\n    list: List of tuples where each tuple contains (x, y) such that poly(x) == y and y is an integer.\n    Examples:\n    >>> poly = lambda x: x**2 - 4*x + 6\n    >>> integer_solutions(poly, range(-10, 10))\n    [(-8, 70), (-7, 56), (-6, 44), ..., (6, 6), (7, 8), (8, 14), (9, 22)]", "Freq": 1, "TSR": 0}, {"tool": "def is_coprime(a, b):\n    \n    return gcd(a, b) == 1", "subfield": "Integers", "tool_name": "is_coprime", "tool_type": "function", "description": "Determine if two integers are coprime (i.e., their GCD is 1).", "docstring": "Determine if two integers are coprime (i.e., their GCD is 1).\n    Parameters:\n    a (int): The first integer.\n    b (int): The second integer.\n    Returns:\n    bool: True if a and b are coprime, else False.\n    Examples:\n    >>> is_coprime(15, 28)\n    True\n    >>> is_coprime(12, 18)\n    False", "Freq": 0, "TSR": 0}, {"tool": "def is_divisible(numerator: int, denominator: int) -> bool:\n    \n    if denominator == 0:\n        raise ValueError(\"Denominator cannot be zero.\")\n    return numerator % denominator == 0", "subfield": "Integers", "tool_name": "is_divisible", "tool_type": "function", "description": "Check if the numerator is divisible by the denominator.", "docstring": "Check if the numerator is divisible by the denominator.\n    \n    Parameters:\n    - numerator (int): The number to be divided.\n    - denominator (int): The number to divide by.\n    \n    Returns:\n    bool: True if numerator is divisible by denominator, else False.\n    \n    Example:\n    >>> is_divisible(15, 5)\n    True\n    >>> is_divisible(14, 5)\n    False", "Freq": 0, "TSR": 0}], "Units Digit": [{"tool": "def powered_units_digit(base, exponent):\n    \n    # As digits patterns repeat every 4 in most cases\n    return (base ** exponent) % 10", "subfield": "Units Digit", "tool_name": "powered_units_digit", "tool_type": "function", "description": "Calculate the units digit of a number raised to a power.", "docstring": "Calculate the units digit of a number raised to a power.\n    Parameters:\n    - base (int): The base of the exponentiation.\n    - exponent (int): The exponent to raise the base.\n    Returns:\n    - int: Units digit of the result of the exponentiation.\n    Examples:\n    >>> powered_units_digit(2, 10)\n    4\n    >>> powered_units_item(7, 3)\n    3", "Freq": 3, "TSR": 2}, {"tool": "def units_digit(n):\n    \n    return abs(n) % 10", "subfield": "Units Digit", "tool_name": "units_digit", "tool_type": "function", "description": "Calculate the units digit of an integer n.", "docstring": "Calculate the units digit of an integer n.\n    \n    Parameters:\n    n (int): The integer for which the units digit is to be found.\n    Returns:\n    int: Units digit of the provided integer.\n    \n    Examples:\n    >>> units_digit(123)\n    3\n    >>> units_digit(-789)\n    9", "Freq": 1, "TSR": 1}, {"tool": "def units_digit_of_multiplication(a, b):\n    \n    return (a * b) % 10", "subfield": "Units Digit", "tool_name": "units_digit_of_multiplication", "tool_type": "function", "description": "Calculate the units digit of the product of two integers.", "docstring": "Calculate the units digit of the product of two integers.\n    \n    Parameters:\n        a (int): First multiplicand.\n        b (int): Second multiplicand.\n    Returns:\n        int: The units digit of the product of a and b.\n    Examples:\n        >>> units_digit_of_multiplication(12, 15)\n        0\n        >>> units_digit_of_multiplication(123, 456)\n        8", "Freq": 2, "TSR": 0}, {"tool": "def units_digit_of_product(*args):\n    \n    product = 1\n    for number in args:\n        # Only multiply units digits to keep computations smaller\n        product = (product * (number % 10)) % 10\n    return product", "subfield": "Units Digit", "tool_name": "units_digit_of_product", "tool_type": "function", "description": "Compute the units digit of a product of multiple integers.\n    \n    This function can also be used to compute the units digit of exponentiations \n    by repeating the base in the argument list the number of times equal to the exponent.", "docstring": "Compute the units digit of a product of multiple integers.\n    \n    This function can also be used to compute the units digit of exponentiations \n    by repeating the base in the argument list the number of times equal to the exponent.\n    Parameters\n    ----------\n    *args : int\n        A variable number of integers whose product's units digit is to be calculated.\n    Returns\n    -------\n    int\n        The units digit of the product of the given integers.\n    Examples\n    --------\n    >>> units_digit_of_product(2, 5)\n    0\n    >>> units_digit_of_product(3, 4, 2)\n    4\n    >>> units_digit_of_product(9, 9)  # This can represent 9^2\n    1", "Freq": 3, "TSR": 2}, {"tool": "def units_digit_from_multiplication(numbers):\n    \n    from functools import reduce\n    from operator import mul\n    # Compute the product modulo 10 directly during multiplication to keep numbers manageable\n    result = reduce(lambda x, y: (x * y) % 10, numbers, 1)\n    return result", "subfield": "Units Digit", "tool_name": "units_digit_from_multiplication", "tool_type": "function", "description": "Compute the units digit of the product of a list of numbers.", "docstring": "Compute the units digit of the product of a list of numbers.\n    \n    Parameters\n    ----------\n    numbers : list\n        A list of integers whose product's units digit is required.\n    \n    Returns\n    -------\n    int\n        The units digit of the product of the numbers.\n    \n    Examples\n    --------\n    >>> units_digit_from_multiplication([12, 35, 91])\n    0\n    \n    >>> units_digit_from_multiplication([7, 5, 2])\n    0", "Freq": 0, "TSR": 0}], "Prime Factorization": [{"tool": "def prime_factorization(n):\n    \n    if n < 1:\n        raise ValueError(\"n must be a positive integer\")\n    return sympy.factorint(n)", "subfield": "Prime Factorization", "tool_name": "prime_factorization", "tool_type": "function", "description": "Computes the prime factorization of the given integer `n`.", "docstring": "Computes the prime factorization of the given integer `n`.\n    Parameters:\n    ------------\n    n : int\n        The number to be factorized into primes.\n    \n    Returns:\n    ------------\n    dict\n        A dictionary where keys are the prime factors and values are their respective exponents in the factorization.\n    Examples:\n    ------------\n    >>> prime_factorization(18)\n    {2: 1, 3: 2}\n    \n    >>> prime_factorization(100)\n    {2: 2, 5: 2}", "Freq": 4, "TSR": 1}, {"tool": "def generate_divisors_from_factors(prime_factors):\n    \n    from functools import reduce\n    from itertools import product\n    base = sorted(prime_factors.items())\n    series = []\n    for p, exp in base:\n        series.append([p**e for e in range(exp + 1)])\n    divisors = list(map(lambda x: reduce(lambda a, b: a * b, x), product(*series)))\n    return sorted(divisors)", "subfield": "Prime Factorization", "tool_name": "generate_divisors_from_factors", "tool_type": "function", "description": "Generates all possible divisors of a number given its prime factorization.", "docstring": "Generates all possible divisors of a number given its prime factorization.\n    Parameters:\n    ------------\n    prime_factors : dict\n        A dictionary of prime factors as returned by `prime_factorization`, where keys are primes and values are their exponents.\n    \n    Returns:\n    ------------\n    list\n        A sorted list of all divisors of the number.\n    \n    Examples:\n    ------------\n    >>> generate_divisors_from_factors({2: 1, 3: 2})\n    [1, 2, 3, 6, 9, 18]\n    \n    >>> generate_divisors_from_factors({2: 2, 5: 2})\n    [1, 2, 4, 5, 10, 20, 25, 50, 100]", "Freq": 4, "TSR": 1}], "Least Common Multiple (LCM)": [{"tool": "def lcm_multiple_numbers(numbers):\n    \n    if not numbers:\n        return 0\n    return reduce(lcm_two_numbers, numbers)", "subfield": "Least Common Multiple (LCM)", "tool_name": "lcm_multiple_numbers", "tool_type": "function", "description": "Calculate the Least Common Multiple (LCM) for a list of integers.", "docstring": "Calculate the Least Common Multiple (LCM) for a list of integers.\n    Parameters:\n    numbers (list): A list of integers.\n    Returns:\n    int: The least common multiple of the supplied list of integers.\n    Examples:\n    >>> lcm_multiple_numbers([4, 6, 8])\n    24\n    >>> lcm_multiple_numbers([5, 10, 20])\n    20", "Freq": 3, "TSR": 3}, {"tool": "def lcm_two_numbers(a, b):\n    \n    if a == 0 or b == 0:\n        return 0\n    return abs(a * b) // math.gcd(a, b)", "subfield": "Least Common Multiple (LCM)", "tool_name": "lcm_two_numbers", "tool_type": "function", "description": "Calculate the Least Common Multiple (LCM) of two integers.", "docstring": "Calculate the Least Common Multiple (LCM) of two integers.\n    Parameters:\n    a (int): First number.\n    b (int): Second number.\n    Returns:\n    int: The least common multiple of a and b.\n    Examples:\n    >>> lcm_two_numbers(4, 6)\n    12\n    >>> lcm_two_numbers(15, 17)\n    255", "Freq": 6, "TSR": 6}, {"tool": "def prime_factorization(n):\n    \n    from sympy import primefactors, multiplicity\n    \n    factors = {}\n    for prime in primefactors(n):\n        factors[prime] = multiplicity(prime, n)\n    return factors", "subfield": "Least Common Multiple (LCM)", "tool_name": "prime_factorization", "tool_type": "function", "description": "Compute the prime factorization of a given number.", "docstring": "Compute the prime factorization of a given number.\n    Parameters:\n    - n (int): The number to factorize.\n    Returns:\n    - dict: A dictionary where the keys are prime factors and values are their corresponding exponents.\n    Example:\n    >>> prime_factorization(360)\n    {2: 3, 3: 2, 5: 1}", "Freq": 0, "TSR": 0}, {"tool": "def possible_values_n_from_lcm_gcd_conditions(n_conditions):\n    \n    pass", "subfield": "Least Common Multiple (LCM)", "tool_name": "possible_values_n_from_lcm_gcd_conditions", "tool_type": "function", "description": "Evaluate possible integer values for n based on a series of LCM and GCD conditions.", "docstring": "Evaluate possible integer values for n based on a series of LCM and GCD conditions.\n    \n    Parameters:\n        n_conditions (dict): Dictionary specifying the conditions with \"lcm_facts\" and \"gcd_facts\" as keys.\n                             Each key maps to a list of tuples, where each tuple in \"lcm_facts\" or \"gcd_facts\"\n                             is of the form (a, b, value) indicating LCM(a, b) == value or GCD(a, b) == value.\n    \n    Returns:\n        list: List of integers that meet all the given LCM and GCD conditions.\n    \n    Examples:\n        >>> n_conditions = {\n            \"lcm_facts\": [(6, 8, 24), (5, 7, 35)],\n            \"gcd_facts\": [(4, 10, 2)]\n        }\n        >>> possible_values_n_from_lcm_gcd_conditions(n_conditions)\n        [6, 8, 5, 7, 4, 10]  # Example output and might change depending on actual implementation logic", "Freq": 0, "TSR": 0}]}