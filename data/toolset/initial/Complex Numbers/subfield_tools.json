{"Absolute Value": [["def convert_complex_number(z, target_form='polar'):\n    \"\"\"\n    Converts a complex number to the specified form and calculates its modulus and argument.\n    \n    Parameters:\n        z (complex): The complex number in Cartesian form (a + bj).\n        target_form (str): The desired output form ('polar' or 'exponential').\n    \n    Returns:\n        tuple: Depending on the target_form:\n            - 'polar': (modulus, argument)\n            - 'exponential': complex number in exponential form  e^(iθ)\n            \n    Examples:\n        >>> convert_complex_number(1+1j, 'polar')\n        (1.4142135623730951, 0.7853981633974483)\n        >>> convert_complex_format(1+1j, 'exponential')\n        (2.718281828459045**1j*0.7853981633974483)\n    \"\"\"\n    modulus = abs(z)\n    argument = cmath.phase(z)\n    if target_form == 'exponential':\n        return cmath.exp(complex(0, argument))\n    elif target_form == 'polar':\n        return modulus, argument\n    else:\n        raise ValueError(\"Unsupported form requested: choose 'polar' or 'exponential'\")", "def convert_to_exponential_form(z):\n    \"\"\"\n    Converts a complex number to its exponential form z = r*e^(i*theta).\n    Parameters:\n    - z (complex): A complex number.\n    Returns:\n    - str: The exponential form of the complex number.\n    Examples:\n    >>> convert_to_exponential_form(1+1j)\n    '1.4142135623730951*e^(i*0.7853981633974483)'\n    \"\"\"\n    r = cmath.polar(z)[0]\n    theta = cmath.polar(z)[1]\n    return f\"{r}*e^(i*{theta})\""], ["def calculate_modulus(z):\n    \"\"\"\n    Calculate the modulus (absolute value) of a complex number.\n    Parameters\n    ----------\n    z : complex\n        The complex number in the form x + yi, where `x` and `y` could be integers or floats.\n    Returns\n    -------\n    float\n        The modulus (absolute value) of the complex number.\n    Examples\n    --------\n    >>> calculate_modulus(3 + 4j)\n    5.0\n    >>> calculate_modulus(-1 - 1j)\n    1.4142135623730951\n    \"\"\"\n    return abs(z)", "def compute_modulus(z):\n    \"\"\"\n    Calculate the modulus (absolute value) of a complex number.\n    \n    Parameters:\n    z (complex): A complex number in the form a + bj.\n    \n    Returns:\n    float: The modulus of the complex number.\n    \n    Examples:\n    >>> compute_modulus(3+4j)\n    5.0\n    >>> compute_modulus(-1-1j)\n    1.4142135623730951\n    \"\"\"\n    return np.abs(z)", "def modulus_complex(z):\n    \"\"\"\n    Computes the modulus (absolute value) of a complex number.\n    Parameters:\n        z (complex): The complex number to compute the modulus for.\n    Returns:\n        float: The modulus of the complex number.\n    \"\"\"\n    return np.abs(z)", "def calculate_complex_modulus(z):\n    \"\"\"\n    Calculate the modulus (absolute value) of a complex number.\n    \n    Parameters:\n    - z (complex): A complex number in the form 'a + bj'.\n    Returns:\n    - float: The modulus (absolute value) of the complex number.\n    Examples:\n    >>> calculate_complex_modulus(3 + 4j)\n    5.0\n    >>> calculate_complex_modulus(-1 - 1j)\n    1.4142135623730951\n    \"\"\"\n    return np.abs(z)", "def modulus(z):\n    \"\"\"\n    Calculate the modulus (absolute value) of a complex number.\n    \n    :param z: complex, a complex number in the form a + bi.\n    :return: float, the modulus of the complex number.\n    Examples\n    --------\n    >>> modulus(3 + 4j)\n    5.0\n    \"\"\"\n    return np.abs(z)"], ["def convert_to_polar(complex_number):\n    \"\"\"\n    Converts a complex number from rectangular to polar form.\n    Parameters:\n    - complex_number (complex): A complex number in rectangular form x + yi.\n    Returns:\n    - tuple: A tuple containing the magnitude and angle (in radians).\n    Example:\n    >>> convert_to_polar(1+1j)\n    (1.4142135623730951, 0.7853981633974483)\n    \"\"\"\n    return cmath.polar(complex_number)", "def complex_to_polar(z):\n    \"\"\"\n    Converts a complex number from Cartesian form to polar coordinates (magnitude and angle).\n    Parameters:\n        z (complex): The complex number to convert.\n    Returns:\n        tuple: A tuple containing the magnitude and angle (in radians) of the complex number.\n    \"\"\"\n    return (np.abs(z), np.angle(z))", "def convert_complex_cartesian_to_polar(x, y):\n    \"\"\"\n    Converts a complex number from its Cartesian 'a + bi' form to polar (r, θ) form.\n    Parameters:\n    x (float): The real part of the complex number.\n    y (float): The imaginary part of the complex number.\n    Returns:\n    tuple: a tuple containing the modulus r and argument θ (in radians).\n    Examples:\n    >> convert_complex_cartesian_to_polar(3, 4)\n    (5.0, 0.9272952180016122)\n    \"\"\"\n    r = np.sqrt(x**2 + y**2)\n    theta = np.arctan2(y, x)\n    return r, theta"], ["def complex_operations(a, b, operation='multiply'):\n    \"\"\"\n    Perform operations (multiply, divide, power) on two complex numbers given in Cartesian form.\n    Parameters:\n    a (complex): First complex number in the form a + bi.\n    b (complex): Second complex number in the form a + bi.\n    operation (str): The operation to perform ['multiply', 'divide', 'power'].\n    Returns:\n    complex: The result of the operation.\n    Examples:\n    >> complex_operations(complex(1, 1), complex(2, 3), 'multiply')\n    (-1+5j)\n    \"\"\"\n    if operation == 'multiply':\n        return np.multiply(a, b)\n    elif operation == 'divide':\n        return np.divide(a, b)\n    elif operation == 'power':\n        return np.power(a, int(b.real))  # b is assumed to be an integer for power\n    else:\n        raise ValueError(\"Unsupported operation. Use 'multiply', 'divide', or 'power'.\")", "def complex_operations(z1, z2, operation='add'):\n    \"\"\"\n    Perform arithmetic operations on two complex numbers given in exponential (Euler) form.\n    \n    Parameters:\n        z1 (complex): First complex number.\n        z2 (complex): Second complex number.\n        operation (str): Type of operation ('add', 'subtract', 'multiply', 'divide').\n    \n    Returns:\n        complex: The result of the arithmetic operation.\n        \n    Examples:\n        >>> z1 = euler_to_complex(np.pi/4)\n        >>> z2 = euler_to_complex(np.pi/3)\n        >>> complex_operations(z1, z2, 'add')\n        (1.1830127018922194+1.2071067811865475j)\n    \"\"\"\n    if operation == 'add':\n        return z1 + z2\n    elif operation == 'subtract':\n        return z1 - z2\n    elif operation == 'multiply':\n        return z1 * z2\n    elif operation == 'divide':\n        if z2 != 0:\n            return z1 / z2\n        else:\n            raise ValueError(\"Cannot divide by zero\")\n    else:\n        raise ValueError(\"Unsupported operation type\")", "def operate_complex_numbers(c1, c2, operation='add'):\n    \"\"\"\n    This function perform basic arithmetic operation(add, subtract, multiply, divide) on complex numbers.\n    Parameters:\n    c1 (complex): First complex number\n    c2 (complex): Second complex number \n    operation (str, optional): Arithmetic operation on complex numbers. \n                               Possible options are \"add\", \"subtract\", \"multiply\", \"divide\". Default is 'add'.\n    \n    Returns:\n    complex: The result of arithmetic operation on `c1` and `c2`.\n    \"\"\"\n    if operation == 'add':\n        return c1 + c2\n    elif operation == 'subtract':\n        return c1 - c2\n    elif operation == 'multiply':\n        return c1 * c2\n    elif operation == 'divide':\n        return c1 / c2\n    else:\n        raise ValueError(f\"Unsupported operation {operation}.\")"], ["def get_conjugate(z):\n    \"\"\"\n    Return the conjugate of a complex number.\n    \n    Parameters:\n    z (complex): A complex number in the form a + bj.\n    \n    Returns:\n    complex: The conjugate of the complex number.\n    \n    Examples:\n    >>> get_conjugate(2-3j)\n    (2+3j)\n    >>> get_conjugate(1+1j)\n    (1-1j)\n    \"\"\"\n    return np.conj(z)", "def complex_conjugate(z):\n    \"\"\"\n    Calculate the conjugate of a complex number.\n    Parameters:\n        z (complex): A complex number.\n    \n    Returns:\n        complex: The conjugate of the complex number.\n    \n    Example:\n        >>> complex_conjugate(3+4j)\n        (3-4j)\n    \"\"\"\n    return z.conjugate()", "def complex_conjugate(z):\n    \"\"\"\n    Returns the complex conjugate of the given complex number.\n    Parameters:\n    - z (complex): A complex number.\n    Returns:\n    - complex: The conjugate of the complex number.\n    Examples:\n    >>> complex_conjugate(3+4j)\n    (3-4j)\n    \"\"\"\n    return cmath.conj(z)", "def conjugate(z):\n    \"\"\"\n    Return the complex conjugate of the given complex number.\n    \n    :param z: complex, a complex number in the form a + bi.\n    :return: complex, the conjugate of the complex number.\n    Examples\n    --------\n    >>> conjugate(3 + 4j)\n    (3-4j)\n    \"\"\"\n    return np.conj(z)"], ["def conjugate_complex_number(c):\n    \"\"\"\n    This function computes the conjugate of a complex number.\n    Parameters:\n    c (complex): Complex number\n    Returns:\n    complex : The conjugate of the complex number `c`.\n    \"\"\"\n    return c.conjugate()", "def inverse_complex_number(c):\n    \"\"\"\n    This function computes the inverse of a complex number.\n    Parameters:\n    c (complex): Complex number\n    Returns:\n    complex : The inverse of the complex number `c`.\n    \"\"\"\n    return 1 / c"], ["def modulus_of_power(z, n):\n    \"\"\"\n    Calculate the modulus of a complex number raised to the power n.\n    Parameters\n    ----------\n    z : complex\n        A complex number.\n    n : int\n        The power to which the complex number is raised.\n    Returns\n    -------\n    float\n        The modulus of the complex number raised to the nth power.\n    Examples\n    --------\n    >>> modulus_of_power(2 + 3j, 2)\n    13.0\n    \"\"\"\n    return abs(z ** n)", "def modulus_of_power(z, n):\n    \"\"\"\n    Compute the modulus of a complex number raised to the power n, using the property |z^n| = |z|^n.\n    \n    Parameters:\n    - z (complex): A complex number.\n    - n (int): Exponent to which the complex number is raised.\n    Returns:\n    - float: The modulus of z raised to the power n.\n    Examples:\n    >>> modulus_of_power(1+1j, 2)\n    2.0\n    >>> modulus_of_power(2+3j, 3)\n    26.0\n    \"\"\"\n    return calculate_complex_modormize abslor_power(calculate_complex_modular_mod_of_complexelorization in python."], ["def divide_complex(z1, z2):\n    \"\"\"\n    Divides one complex number by another.\n    Parameters:\n        z1 (complex): The numerator complex number.\n        z2 (complex): The denominator complex number.\n    Returns:\n        complex: The quotient z1 / z2.\n    \"\"\"\n    return z1 / z2", "def divide_complex(z1, z2):\n    \"\"\"\n    Divides the first complex number by the second. Raises ValueError if the divisor is zero.\n    Parameters:\n    - z1 (complex): The numerator complex number.\n    - z2 (complex): The denominator, which should not be zero.\n    Returns:\n    - complex: The quotient of z1 and z2.\n    Examples:\n    >>> divide_complex(1+2j, 3+4j)\n    (0.44+0.08j)\n    \"\"\"\n    if z2 == 0:\n        raise ValueError(\"Cannot divide by zero complex number.\")\n    return z1 / z2", "def divide(z1, z2):\n    \"\"\"\n    Divide the first complex number by the second.\n    \n    :param z1: complex, the numerator complex number.\n    :param z2: complex, the denominator complex number.\n    :return: complex, the quotient of the two complex numbers.\n    Examples\n    --------\n    >>> divide(1+2j, 1-1j)\n    (1.5+0.5j)\n    \"\"\"\n    if z2 == 0:\n        raise ValueError(\"Cannot divide by zero.\")\n    return z1 / z2"], ["def add_complex_numbers(z1, z2):\n    \"\"\"\n    Add two complex numbers.\n    Parameters:\n        z1 (complex): First complex number.\n        z2 (complex): Second complex number.\n    \n    Returns:\n        complex: The sum of the two complex numbers.\n    \n    Example:\n        >>> add_complex_numbers(1+2j, 3+4j)\n        (4+6j)\n    \"\"\"\n    return z1 + z2", "def multiply_complex_numbers(z1, z2):\n    \"\"\"\n    Multiply two complex numbers.\n    Parameters:\n        z1 (complex): First complex number.\n        z2 (complex): Second complex number.\n    \n    Returns:\n        complex: The product of the two complex numbers.\n    \n    Example:\n        >>> multiply_complex_numbers(1+2j, 3+4j)\n        (-5+10j)\n    \"\"\"\n    return z1 * z2", "def add_complex(z1, z2):\n    \"\"\"\n    Adds two complex numbers.\n    Parameters:\n        z1 (complex): The first complex number.\n        z2 (complex): The second complex number.\n    Returns:\n        complex: The sum of z1 and z2.\n    \"\"\"\n    return z1 + z2", "def multiply_complex(z1, z2):\n    \"\"\"\n    Multiplies two complex numbers.\n    Parameters:\n        z1 (complex): The first complex number.\n        z2 (complex): The second complex number.\n    Returns:\n        complex: The product of z1 and z2.\n    \"\"\"\n    return z1 * z2", "def add_complex(z1, z2):\n    \"\"\"\n    Adds two complex numbers.\n    Parameters:\n    - z1 (complex): The first complex number.\n    - z2 (complex): The second complex number.\n    Returns:\n    - complex: The sum of z1 and z2.\n    Examples:\n    >>> add_complex(1+2j, 3+4j)\n    (4+6j)\n    \"\"\"\n    return z1 + z2", "def multiply_complex(z1, z2):\n    \"\"\"\n    Multiplies two complex numbers.\n    Parameters:\n    - z1 (complex): The first complex number.\n    - z2 (complex): The second complex number.\n    Returns:\n    - complex: The product of z1 and z2.\n    Examples:\n    >>> multiply_complex(1+2j, 3+4j)\n    (-5+10j)\n    \"\"\"\n    return z1 * z2", "def multiply(z1, z2):\n    \"\"\"\n    Multiply two complex numbers.\n    \n    :param z1: complex, the first complex number.\n    :param z2: complex, the second complex number.\n    :return: complex, the product of the two complex numbers.\n    Examples\n    --------\n    >>> multiply(3+4j, 1+2j)\n    (-5+10j)\n    \"\"\"\n    return z1 * z2", "def add(z1, z2):\n    \"\"\"\n    Add two complex numbers.\n    \n    :param z1: complex, the first complex number.\n    :param z2: complex, the second complex number.\n    :return: complex, the sum of the two complex numbers.\n    Examples\n    --------\n    >>> add(3+4j, 1+2j)\n    (4+6j)\n    \"\"\"\n    return z1 + z2"], ["def complex_from_polar(magnitude, angle):\n    \"\"\"\n    Converts polar coordinates to a complex number using Euler's formula.\n    Parameters:\n    - magnitude (float): The magnitude (absolute value, modulus) of the complex number.\n    - angle (float): The angle in radians.\n    Returns:\n    - complex: A complex number in rectangular form x + yi.\n    Example:\n    >>> complex_from_polar(2, cmath.pi/4)\n    (1.4142135623730951+1.4142135623730951j)\n    \"\"\"\n    return cmath.rect(magnitude, angle)", "def complex_from_polar(magnitude, angle_rad):\n    \"\"\"\n    Constructs a complex number from its magnitude and angle in radians using Euler's formula.\n    Parameters:\n        magnitude (float): The magnitude (absolute value or modulus) of the complex number.\n        angle_rad (float): The angle in radians.\n    Returns:\n        complex: A complex number calculated as magnitude * (cos(angle_rad) + sin(angle_rad)*j).\n    \"\"\"\n    return magnitude * (np.cos(angle_rad) + np.sin(angle_algo)*1j)"], ["def complex_from_angle(theta: float) -> complex:\n    \"\"\"\n    Given an angle theta (in radians), this function returns the complex number \n    using Euler's formula: e^(iθ) = cos(θ) + i*sin(θ)\n    \n    Parameters:\n        theta (float): The angle in radians\n    \n    Returns:\n        complex: The computed complex number in the form a + bj\n    \n    Example:\n        >>> complex_from_angle(3.14159)\n        (-1+9.265358966049026e-06j)\n    \"\"\"\n    return cmath.exp(complex(0,theta))", "def euler_to_complex(theta):\n    \"\"\"\n    Converts an angle in radians, using Euler's formula, to its complex representation.\n    \n    Parameters:\n        theta (float): The angle in radians.\n    \n    Returns:\n        complex: A complex number represented by cos(theta) + i*sin(theta).\n    \n    Examples:\n        >>> euler_to_complex(np.pi/4)\n        (0.7071067811865476+0.7071067811865475j)\n    \"\"\"\n    return cmath.exp(1j * theta)"], ["def calculate_nth_roots_of_unity(n):\n    \"\"\"\n    Calculate the nth roots of unity.\n    Parameters:\n        n (int): Degree of the root.\n    \n    Returns:\n        list of complex: The nth roots of unity.\n    \n    Example:\n        >>> calculate_nth_roots_of_unity(3)\n        [(1+0j), (-0.5+0.8660254037844386j), (-0.5-0.8660254037844386j)]\n    \"\"\"\n    return [cmath.exp(2j * cmath.pi * k / n) for k in range(n)]", "def complex_root_of_unity(n):\n    \"\"\"\n    Computes the n-th roots of unity, which are the complex solutions to z^n = 1.\n    Parameters:\n    - n (int): Degree of the root.\n    Returns:\n    - list of complex: The n roots of unity.\n    Examples:\n    >>> complex_root_of_unity(3)\n    [(1+0j), (-0.5+0.8660254037844387j), (-0.5-0.8660254037844387j)]\n    \"\"\"\n    return [cmath.exp(2j * cmath.pi * k / n) for k in range(n)]"], ["def complex_magnitude(z):\n    \"\"\"\n    Calculates the magnitude of the complex number.\n    Parameters:\n    - z (complex): A complex number.\n    Returns:\n    - float: The magnitude (absolute value) of the complex number.\n    Examples:\n    >>> complex_magnitude(3+4j)\n    5.0\n    \"\"\"\n    return abs(z)"], ["def magnitude_phase(z):\n    \"\"\"\n    Computes the magnitude and phase of the complex number.\n    \n    Parameters:\n        z (complex): The complex number.\n    \n    Returns:\n        tuple: Magnitude and phase (angle in radians) of the complex number.\n    \n    Examples:\n        >>> magnitude_phase(1+2j)\n        (2.23606797749979, 1.1071487177940904)\n    \"\"\"\n    return (abs(z), cmath.phase(z))"], ["def complex_addition(z1: complex, z2: complex) -> complex:\n    \"\"\"\n    Adds two complex numbers which are in exponential (Euler's) form.\n    \n    Parameters:\n        z1 (complex): First complex number\n        z2 (complex): Second complex number\n    \n    Returns:\n        complex: The result of adding the two complex numbers.\n        \n    Example:\n        >>> complex_addition(complex_from_angle(0), complex_from_angle(3.14159))\n        (-1+9.265358966049026e-06j)\n    \"\"\"\n    return z1 + z2", "def complex_multiplication(z1: complex, z2: complex) -> complex:\n    \"\"\"\n    Multiplies two complex numbers which are in exponential (Euler's) form.\n    \n    Parameters:\n        z1 (complex): First complex number\n        z2 (complex): Second complex number\n    \n    Returns:\n        complex: The result of multiplying the two complex numbers.\n        \n    Example:\n        >>> complex_multiplication(complex_from_angle(3.14159/4), complex_from_angle(-3.14159/4))\n        (0.9999999809921654-1.7526727942890515e-06j)\n    \"\"\"\n    return z1 * z2"], ["def product_modulus(z1, z2):\n    \"\"\"\n    Calculate the modulus of the product of two complex numbers using the property |zw| = |z| |w|.\n    \n    Parameters:\n    z1, z2 (complex): Two complex numbers in the form a + bj.\n    \n    Returns:\n    float: The modulus of the product of the two complex numbers.\n    \n    Examples:\n    >>> product_modulus(1+1j, 1-1j)\n    2.0\n    >>> product_modulus(2+2j, 2-2j)\n    8.0\n    \"\"\"\n    return compute_modulus(z1) * compute_modulus(z2)", "def modulus_of_product(z, w):\n    \"\"\"\n    Compute the modulus of the product of two complex numbers, using the property |zw| = |z||w|.\n    \n    Parameters:\n    - z (complex): First complex number.\n    - w (complex): Second complex number.\n    Returns:\n    - float: The modulus of the product of z and w.\n    Examples:\n    >>> modulus_of_product(1+1j, 1-1j)\n    2.0\n    >>> modulus_of_product(3+4j, 1+2j)\n    10.0\n    \"\"\"\n    return calculate_complex_modulus(z * w)"], ["def exponent_complex_number(c, n):\n    \"\"\"\n    This function computes the exponent of a complex number.\n    Parameters:\n    c (complex): Complex number\n    n (int): Exponent\n    Returns:\n    complex : The result of raising `c` to the power `n`.\n    \"\"\"\n    return c ** n"], ["def absolute_value_complex(complex_number):\n    \"\"\"\n    Computes the absolute value (modulus) of a complex number.\n    Parameters:\n    - complex_number (complex): The complex number for which to find the modulus.\n    Returns:\n    - float: The modulus of the complex number.\n    Example:\n    >>> absolute_value_complex(3+4j)\n    5.0\n    \"\"\"\n    return abs(complex_number)", "def complex_absolute_value(z):\n    \"\"\"\n    Calculate the absolute value or modulus of a complex number.\n    Parameters:\n        z (complex): A complex number in the form of x + yi.\n    Returns:\n        float: The modulus of the complex number.\n    Example:\n        >>> complex_absolute_value(3 + 4j)\n        5.0\n    \"\"\"\n    return abs(z)"], ["def add_complex(c1, c2):\n    \"\"\"\n    Adds two complex numbers.\n    Parameters:\n    - c1 (complex): The first complex number.\n    - c2 (complex): The second complex number.\n    Returns:\n    - complex: The sum of the two complex numbers.\n    Example:\n    >>> add_complex(1+1j, 1-1j)\n    (2+0j)\n    \"\"\"\n    return c1 + c2", "def multiply_complex(c1, c2):\n    \"\"\"\n    Multiplies two complex numbers using the properties of Euler's formula.\n    Parameters:\n    - c1 (complex): The first complex number.\n    - c2 (complex): The second complex number.\n    Returns:\n    - complex: The product of the two complex numbers.\n    Example:\n    >>> multiply_complex(1+1j, 1-1j)\n    (2+0j)\n    \"\"\"\n    return c1 * c2"], ["def property_modulus_product(z1, z2):\n    \"\"\"\n    Show that the modulus of the product of two complex numbers is the product\n    of their moduli, i.e., |z1 * z2| = |z1| * |z2|.\n    \n    :param z1: complex, first complex number.\n    :param z2: complex, second complex number.\n    :return: tuple, the left and right side of the property equation: (|z1 * z2|, |z1| * |z2|).\n    Examples\n    --------\n    >>> property_modulus_product(3+4j, 1+2j)\n    (10.0, 10.0)\n    \"\"\"\n    lhs = modulus(multiply(z1, z2))\n    rhs = modulus(z1) * modulus(z2)\n    return (lhs, rhs)"], ["def apply_triangle_inequality(z1, z2):\n    \"\"\"\n    Applies the triangle inequality to two complex numbers and checks if equality holds.\n    Parameters:\n    - z1 (complex): The first complex number.\n    - z2 (complex): The second complex number.\n    Returns:\n    - tuple (bool, float): (Whether equality holds in the triangle inequality, value of the inequality)\n    Examples:\n    >>> apply_triangle_inequality(3+4j, 1+2j)\n    (False, 2.23606797749979)\n    \"\"\"\n    left_side = complex_magnitude(z1 + z2)\n    right_side = complex_magnitude(z1) + complex_magnitude(z2)\n    return (np.isclose(left_side, right_side), left_side)"], ["def validate_multiplicative_property(z, w):\n    \"\"\"\n    Validates the multiplicative property of moduli: |zw| = |z||w|\n    Parameters:\n    - z, w (complex): Two complex numbers provided as complex literals\n    Returns:\n    - bool: True if the property holds, False otherwise.\n    Examples:\n    >>> validate_multiplicative_property(3+4j, 1+2j)\n    True\n    >>> validate_multiplicative_property(2+3j, 5+6j)\n    True\n    \"\"\"\n    left_side = calculate_complex_modulus(z * w)\n    right_side = calculate_complex_modulus(z) * calculate_complex_modulus(w)\n    # Checking the property |zw| = |z||w|\n    return math.isclose(left_side, right_side, rel_tol=1e-9)"], ["def complex_modulus(x, y):\n    \"\"\"\n    Calculates the modulus of a complex number given its Cartesian coordinates.\n    Parameters:\n    x (float): The real part of the complex number.\n    y (float): The imaginary part of the complex number.\n    Returns:\n    float: The modulus of the complex number.\n    Examples:\n    >> complex_modulus(3, 4)\n    5.0\n    \"\"\"\n    return np.sqrt(x**2 + y**2)"], ["def extract_real_imaginary(complex_number):\n    \"\"\"\n    Extracts the real and imaginary parts of a complex number.\n    Parameters:\n    - complex_number (complex): A complex number from which to extract parts.\n    Returns:\n    - tuple: A tuple containing the real and imaginary parts.\n    Example:\n    >>> extract_real_imaginary(2+3j)\n    (2, 3)\n    \"\"\"\n    return (complex_number.real, complex_number.imag)", "def get_real_imaginary(z):\n    \"\"\"\n    Extracts real and imaginary components of a complex number.\n    \n    Parameters:\n        z (complex): The complex number.\n    \n    Returns:\n        tuple: Contains the real and imaginary parts of the complex number.\n    \n    Examples:\n        >>> get_real_imaginary(1+2j)\n        (1, 2)\n    \"\"\"\n    return (z.real, z.imag)"], ["def calculate_complex_modulus(z, power=1, additional_operation=None):\n    \"\"\"\n    Calculates the modulus of a complex number raised to a certain power and can perform\n    an additional predefined operation on the modulus such as squaring or square rooting.\n    Parameters:\n    - z (complex): The complex number (can be in the form of a complex literal or a tuple of (real, imag)).\n    - power (int): The power to which the modulus is raised. Default is 1 (no exponentiation).\n    - additional_operation (callable, optional): A function to apply to the modulus after raising it to the given power.\n    Returns:\n    - float: The result of the modulus calculation after any specified operations.\n    Examples:\n    >>> calculate_complex_modulus(3+4j)\n    5.0\n    >>> calculate_complex_modulus(1+1j, power=2)\n    2.0\n    >>> import math\n    >>> calculate_complex_modulus(1+1j, additional_operation=math.sqrt)\n    1.4142135623730951\n    \"\"\"\n    # Calculating modulus of the complex number\n    mod = abs(z)\n    \n    # Raising to the specified power if necessary\n    if power != 1:\n        mod = mod ** power\n    \n    # Applying additional operation if provided\n    if additional_operation:\n        mod = additional_operation(mod)\n    \n    return mod"], ["class ComplexNumberTool:\n    \"\"\"\n    A class containing methods to perform basic operations on complex numbers and calculate properties like modulus.\n    Methods\n    -------\n    add(z1, z2)\n        Returns the sum of two complex numbers.\n    multiply(z1, z2)\n        Returns the product of two complex numbers.\n    divide(z1, z2)\n        Returns the quotient of two complex numbers.\n    conjugate(z)\n        Returns the conjugate of the complex number.\n    modulus(z)\n        Returns the modulus (absolute value) of the complex number.\n    modulus_squared(z)\n        Returns the squared modulus of the complex number.\n    \"\"\"\n    \n    @staticmethod\n    def add(z1, z2):\n        \"\"\"\n        Adds two complex numbers.\n        Parameters:\n            z1 (complex): A complex number.\n            z2 (complex): Another complex number.\n        Returns:\n            complex: The sum of z1 and z2.\n        \"\"\"\n        return z1 + z2\n    \n    @staticmethod\n    def multiply(z1, z2):\n        \"\"\"\n        Multiplies two complex numbers.\n        Parameters:\n            z1 (complex): A complex number.\n            z2 (complex): Another complex number.\n        Returns:\n            complex: The product of z1 and z2.\n        \"\"\"\n        return z1 * z2\n    @staticmethod\n    def divide(z1, z2):\n        \"\"\"\n        Divides the first complex number by the second.\n        Parameters:\n            z1 (complex): Numerator complex number.\n            z2 (complex): Denominator complex number.\n        Returns:\n            complex: The quotient of z1 and z2.\n        \"\"\"\n        return z1 / z2\n    @staticmethod\n    def conjugate(z):\n        \"\"\"\n        Returns the conjugate of the complex number.\n        Parameters:\n            z (complex): A complex number.\n        Returns:\n            complex: The conjugate of z.\n        \"\"\"\n        return cmath.conjugate(z)\n    @staticmethod\n    def modulus(z):\n        \"\"\"\n        Computes the modulus (absolute value) of a complex number.\n        Parameters:\n            z (complex): A complex number.\n        Returns:\n            float: The modulus of z.\n        \"\"\"\n        return abs(z)\n    @staticmethod\n    def modulus_squared(z):\n        \"\"\"\n        Computes the squared modulus of a complex number using the property |z|^2 = z * conjugate(z).\n        Parameters:\n            z (complex): A complex number.\n        Returns:\n            float: The squared modulus of z.\n        \"\"\"\n        return z * ComplexNumberTool.conjugate(z)"], ["def complex_to_cartesian(z):\n    \"\"\"\n    Decomposes a complex number into its real and imaginary parts.\n    Parameters:\n        z (complex): The complex number to decompose.\n    Returns:\n        tuple: A tuple containing the real part and imaginary part of the complex number.\n    \"\"\"\n    return (z.real, z.imag)"], ["def multiplicative_property(z1, z2):\n    \"\"\"\n    Apply the multiplicative property of moduli on two complex numbers.\n    Parameters\n    ----------\n    z1, z2 : complex\n        Two complex numbers.\n    Returns\n    -------\n    float\n        The product of the moduli of the given complex numbers, demonstrating that |z1*z2| = |z1|*|z2|.\n    Examples\n    --------\n    >>> multiplicative_property(1+2j, 3+4j)\n    10.0\n    \"\"\"\n    return abs(z1 * z2)"], ["def complex_from_cartesian(real, imag):\n    \"\"\"\n    Constructs a complex number from its real and imaginary parts.\n    Parameters:\n        real (float): The real part of the complex number.\n        imag (float): The imaginary part of the complex number.\n    Returns:\n        complex: A complex number represented as real + imag*j.\n    \"\"\"\n    return complex(real, imag)"], ["def property_z_conjugate_z(z):\n    \"\"\"\n    Calculate the property of complex number z multiplied by its conjugate,\n    which results in the square of its modulus.\n    \n    :param z: complex, a complex number in the form a + bi.\n    :return: float, the result of z multiplied by its conjugate which is |z|^2.\n    Examples\n    --------\n    >>> property_z_conjugate_z(3+4j)\n    25.0\n    \"\"\"\n    return modulus(z) ** 2"], ["def equate_complex_parts(c1, c2):\n    \"\"\"\n    This function equates the real and imaginary parts of two complex numbers and solve for unknowns. \n    Parameters:\n    c1 (complex): First complex number \n    c2 (complex): Second complex number  \n    \n    Returns:\n    dict : A dictionary of symbols and their corresponding values.\n    \"\"\"\n    x, y, z, w = symbols('x y z w')  # unknowns symbols\n    # creating equations\n    eq1 = Eq(re(c1), x)\n    eq2 = Eq(im(c1), y)\n    eq3 = Eq(re(c2), z)\n    eq4 = Eq(im(c2), w)\n    # solving equations\n    solutions = solve((eq1,eq2,eq3,eq4), (x, y, z, w))\n    \n    return solutions"], ["class ComplexAnalysisTool:\n    \"\"\"\n    A class for more advanced analysis involving complex numbers not covered in basic arithmetic operations.\n    \"\"\"\n    pass"], ["def absolute_complex_number(c):\n    \"\"\"\n    This function computes the absolute value (magnitude) of a complex number.\n    Parameters:\n    c (complex): Complex number whose absolute value has to be computed.\n    Returns:\n    float : absolute value (magnitude) of the input complex number `c`.\n    \"\"\"\n    return abs(c)"], ["def root_complex_number(c, n=2):\n    \"\"\"\n    This function computes the `n`'th root of a complex number.\n    Parameters:\n    c (complex): Complex number\n    n (int, optional): The `n`'th root to be computed. Default is 2.\n    Returns:\n    list : List of complex numbers which are `n`'th roots of `c`.\n    \"\"\"\n    r,_ = polar(c)\n    roots = [ sqrt(r) * exp((phase + 2*k*pi/n) * 1j) for k in range(n) ]\n    return roots"], ["def complex_operations(z1, z2=None, operation='multiply', power=None, roots=None):\n    \"\"\"\n    Executes operations such as multiplication, powers, and calculation of roots on complex numbers.\n    \n    Parameters:\n        z1 (complex): First complex number (a + bj).\n        z2 (complex, optional): Second complex number, needed for operations like multiplication.\n        operation (str): Type of operation ('multiply', 'power', 'divide', 'roots').\n        power (int, optional): The power to which the complex number is raised, required if operation is 'power'.\n        roots (int, optional): Number of n-th roots to calculate, required if operation is 'roots'.\n    \n    Returns:\n        complex or list[complex]: Result of the operation, either a single complex number or a list of complex numbers (for roots).\n    \n    Examples:\n        >>> complex_operations(1+1j, 1-1j, 'multiply')\n        (2+0j)\n        >>> complex_operations(1+1j, operation='power', power=3)\n        (-2+2j)\n        >>> complex_operations(1+1j, operation='roots', roots=4)\n        [(0.9238795325112867+0.3826834323650898j), ...]\n    \"\"\"\n    if operation == 'multiply' and z2 is not wdth timationError('`z2` must be provided for multiplication or division')\n        return z1 * z2\n    elif operation == 'divide' and z2 is not None:\n        if z2 == 0:\n            raise ValueError('Division by zero error')\n        return z1 / z2\n    elif operation == 'power' and power is not None:\n        return z1 ** power\n    elif operation == 'roots' and roots is not None:\n        angle = cmath.phase(z1)\n        modulus = abs(z1)\n        return [cmath.rect(modulus ** (1/roots), (angle + 2*k*cmath.pi) / roots) for k in range(roots)]\n    else:\n        raise ValueError(\"Unsupported operation mode\")"], ["def simplify_complex_expression(z):\n    \"\"\"\n    Simplify a complex expression into real and imaginary parts, outputting its modulus.\n    Parameters:\n    z (complex): A complex number or an algebraic expression involving complex numbers.\n    \n    Returns:\n    tuple: A tuple containing the modulus of the complex expression, the real part, and the imaginary part.\n    \n    Examples:\n    >>> simplify_complex_expression((1+2j) + (2-1j))\n    (3.0, 3, 1)\n    >>> simplify_complex_expression((1+1j) * (1-1j))\n    (2.0, 2, 0)\n    \"\"\"\n    modulus = compute_modulus(z)\n    real_part = np.real(z)\n    imaginary_part = np.imag(z)\n    return (modulus, real_part, imaginary_part)"], ["def subtract_complex_numbers(z1, z2):\n    \"\"\"\n    Subtract two complex numbers.\n    Parameters:\n        z1 (complex): First complex number.\n        z2 (complex): Second complex number subtracted from the first.\n    \n    Returns:\n        complex: The result of the subtraction.\n    \n    Example:\n        >>> subtract_complex_numbers(5+5j, 2+3j)\n        (3+2j)\n    \"\"\"\n    return z1 - z2", "def subtract_complex(z1, z2):\n    \"\"\"\n    Subtracts one complex number from another.\n    Parameters:\n        z1 (complex): The complex number from which to subtract.\n        z2 (complex): The complex number to subtract.\n    Returns:\n        complex: The difference z1 - z2.\n    \"\"\"\n    return z1 - z2", "def subtract_complex(z1, z2):\n    \"\"\"\n    Subtracts the second complex number from the first.\n    Parameters:\n    - z1 (complex): The first complex number.\n    - z2 (complex): The second complex number.\n    Returns:\n    - complex: The result of z1 - z2.\n    Examples:\n    >>> subtract_complex(1+2j, 3+4j)\n    (-2-2j)\n    \"\"\"\n    return z1 - z2"], ["def are_equal(z1, z2):\n    \"\"\"\n    Check if two complex numbers are equal.\n    \n    :param z1: complex, the first complex number.\n    :param z2: complex, the second complex number.\n    :return: bool, True if they are equal, else False.\n    Examples\n    --------\n    >>> are_equal(2+3j, 2+3j)\n    True\n    >>> are_equal(2+3j, 3+2j)\n    False\n    \"\"\"\n    return z1 == z2"], ["def square_complex_number(c):\n    \"\"\"\n    This function computes the square of a complex number.\n    Parameters:\n    c (complex): Complex number to be squared.\n    Returns:\n    complex : Square of the complex number `c`.\n    \"\"\"\n    return c**2"], ["def argument_complex(z):\n    \"\"\"\n    Computes the argument (angle) of a complex number.\n    Parameters:\n        z (complex): The complex number to compute the argument for.\n    Returns:\n        float: The argument of the complex number in radians.\n    \"\"\"\n    return np.angle(z)"]], "Function Operations": [["def real_part(z):\n    \"\"\"\n    Extract the real part of a complex number.\n    Parameters:\n        z (complex): The complex number.\n    Returns:\n        float: The real part of the complex number.\n    \n    Example:\n        >>> real_part(3+4j)\n        3.0\n    \"\"\"\n    return z.real", "def imag_part(z):\n    \"\"\"\n    Extract the imaginary part of a complex number.\n    Parameters:\n        z (complex): The complex number.\n    Returns:\n        float: The imaginary part of the complex number.\n    \n    Example:\n        >>> imag_part(3+4j)\n        4.0\n    \"\"\"\n    return z.imag"], ["def add_complex_numbers(z1, z2):\n    \"\"\"Add two complex numbers.\n    \n    Parameters:\n        z1 (complex): First complex number.\n        z2 (complex): Second complex number.\n    \n    Returns:\n        complex: The sum of z1 and z2.\n    \n    Examples:\n        >>> add_complex_numbers(1+2j, 3-4j)\n        (4-2j)\n    \"\"\"\n    return z1 + z2", "def add_complex_numbers(z1, z2):\n    \"\"\"\n    Add two complex numbers.\n    \n    Parameters:\n        z1 (complex): First complex number.\n        z2 (complex): Second complex number.\n        \n    Returns:\n        complex: The sum of z1 and z2.\n    \"\"\"\n    return z1 + z2", "def complex_add(z1, z2):\n    \"\"\"\n    Add two complex numbers.\n    Parameters:\n        z1 (complex): First complex number.\n        z2 (complex): Second complex number.\n    Returns:\n        complex: Sum of the two complex numbers.\n    \n    Example:\n        >>> complex_add(1+2j, 3+4j)\n        (4+6j)\n    \"\"\"\n    return z1 + z2", "def complex_multiply(z1, z2):\n    \"\"\"\n    Multiply two complex numbers.\n    Parameters:\n        z1 (complex): First complex number.\n        z2 (complex): Second complex number.\n    Returns:\n        complex: Product of the two complex numbers.\n    \n    Example:\n        >>> complex_multiply(1+2j, 3+4j)\n        (-5+10j)\n    \"\"\"\n    return z1 * z2", "def complex_divide(z1, z2):\n    \"\"\"\n    Divide the first complex number by the second one.\n    Parameters:\n        z1 (complex): Numerator complex number.\n        z2 (complex): Denominator complex number.\n    Returns:\n        complex: Result of division of z1 by z2.\n    \n    Example:\n        >>> complex_divize(1+2j, 3+4j)\n        (0.44+0.08j)\n    \"\"\"\n    return z1 / z2", "def complex_add(z1, z2):\n    \"\"\"\n    Adds two complex numbers.\n    Parameters:\n    - z1 (complex or array-like): The first complex number.\n    - z2 (complex or array-like): The second complex number.\n    Returns:\n    - complex: The sum of z1 and z2.\n    Examples:\n    >>> complex_add(1+2j, 3+4j)\n    (4+6j)\n    \"\"\"\n    return np.add(z1, z2)", "def add_complex_numbers(z1, z2):\n    \"\"\"\n    Add two complex numbers represented by their real and imaginary parts.\n    \n    Parameters:\n        z1 (complex): First complex number.\n        z2 (complex): Second complex number.\n    Returns:\n        complex: The sum of z1 and z2.\n        \n    Examples:\n        >>> add_complex_numbers(1+2j, 3+4j)\n        (4+6j)\n    \"\"\"\n    return z1 + z2", "def multiply_complex_numbers(z1, z2):\n    \"\"\"\n    Multiply two complex numbers.\n    \n    Parameters:\n        z1 (complex): First complex number.\n        z2 (complex): Second complex number.\n    \n    Returns:\n        complex: The product of z1 and z2.\n    \n    Examples:\n        >>> multiply_complex_numbers(1+2j, 3+4j)\n        (-5+10j)\n    \"\"\"\n    return z1 * z2"], ["def apply_piecewise_function(z, conditions_functions):\n    \"\"\"\n    Apply a piecewise function to a complex number based on specified conditions and functions.\n    \n    Parameters:\n        z (sp.core.expr.Expr): The input complex number.\n        conditions_functions (list of tuples): Each tuple contains a condition and a corresponding function.\n    \n    Returns:\n        sp.core.expr.Expr: The result after applying the piecewise function.\n        \n    Example:\n        >>> conditions_functions = [\n                (sp.Abs(z) > 1, z**2),\n                (sp.Abs(z) <= 1, z + 1)\n            ]\n        >>> apply_piecewise_function(sp.I, conditions_functions)\n        1 + I\n    \"\"\"\n    result = None\n    for condition, function in conditions_functions:\n        if condition.subs(z, z):\n            result = function.subs(z, z)\n            break\n    return result", "def evaluate_piecewise_complex(z, conditions_functions):\n    \"\"\"\n    Evaluates a piecewise defined function for complex numbers based on provided conditions and functions.\n    Parameters:\n    - z (complex or array-like): Input complex number.\n    - conditions_functions (list of tuples): Each tuple contains a callable condition and a callable function.\n      The condition takes 'z' as its argument and returns True or False. The function is then applied if its corresponding condition is True.\n    Returns:\n    - complex: Result of the evaluated function based on the first true condition, or None if no condition is met.\n    Examples:\n    >>> conditions_functions = [\n    ...     (lambda x: x.real > 0, lambda x: x**2),\n    ...     (lambda x: x.real <= 0, lambda x: x+2)\n    ... ]\n    >>> evaluate_piecewise_complex(1+1j, conditions_fragment)\n    (1+2j)  # Since the real part of (1+1j) is 1, which is > 0\n    \"\"\"\n    for condition, function in conditions_functions:\n        if condition(z):\n            return function(z)\n    return None  # None is returned if no conditions are met"], ["def compute_power_using_demoivre(z, n):\n    \"\"\"Compute the power of a complex number using De Moivre's theorem.\n    \n    Parameters:\n        z (complex): Base complex number.\n        n (int): Exponent.\n    \n    Returns:\n        complex: Result of raising z to the power n using De Moivre's theorem.\n    \n    Examples:\n        >>> compute_power_using_demoivre(2+2j, 2)\n        (8j)\n    \"\"\"\n    r, theta = cmath.polar(z)\n    theta_n = theta * n\n    r_n = r ** n\n    return cmath.rect(r_n, theta_n)", "def demoivre_theorem(z, n):\n    \"\"\"\n    Apply DeMoivre's theorem to calculate the nth power of a complex number z.\n    \n    Parameters:\n        z (complex): Base complex number.\n        n (int): Exponent to raise z to.\n    \n    Returns:\n        complex: The nth power of the complex number z using DeMoivre's theorem.\n    \n    Examples:\n        >>> demoivre_theorem(1+1j, 3)\n        (-2+2j)\n    \"\"\"\n    (r, theta) = magnitude_and_phase(z)\n    return r**n * np.exp(1j * n * theta)"], ["def modulus_of_complex(z):\n    \"\"\"\n    Calculate the modulus (absolute value) of a complex number.\n    Parameters:\n    - z (complex or tuple): The complex number.\n    Returns:\n    - float: The modulus of the complex number.\n    Example:\n    >>> modulus_of_complex((3+4j))\n    5.0\n    \"\"\"\n    if isinstance(z, tuple):\n        z = complex(*z)\n    return np.abs(z)", "def modulus(z):\n    \"\"\"\n    Calculate the modulus (absolute value) of a complex number.\n    Parameters:\n        z (complex): The complex number.\n    Returns:\n        float: The modulus of the complex number.\n    \n    Example:\n        >>> modulus(3+4j)\n        5.0\n    \"\"\"\n    return np.abs(z)"], ["def add_complex_numbers(z1, z2):\n    \"\"\"\n    Add two complex numbers.\n    \n    Parameters:\n        z1 (sp.core.expr.Expr): A complex number.\n        z2 (sp.core.expr.Expr): Another complex number.\n        \n    Returns:\n        sp.core.expr.Expr: The sum of the two complex numbers.\n        \n    Example:\n        >>> add_complex_numbers(sp.I, 1 + 1*sp.I)\n        1 + 2*I\n    \"\"\"\n    return z1 + z2", "def subtract_complex_numbers(z1, z2):\n    \"\"\"\n    Subtract two complex numbers.\n    \n    Parameters:\n        z1 (sp.core.expr.Expr): A complex number.\n        z2 (sp.core.expr.Expr): Another complex number.\n        \n    Returns:\n        sp.core.expr.Expr: The result of z1 - z2.\n        \n    Example:\n        >>> subtract_complex_numbers(1 + 2*sp.I, sp.I)\n        1 + I\n    \"\"\"\n    return z1 - z2", "def multiply_complex_numbers(z1, z2):\n    \"\"\"\n    Multiply two complex numbers.\n    \n    Parameters:\n        z1 (sp.core.expr.Expr): A complex number.\n        z2 (sp.core.expr.Expr): Another complex number.\n        \n    Returns:\n        sp.core.expr.Expr: The product of z1 and z2.\n        \n    Example:\n        >>> multiply_complex_numbers(1 + 1*sp.I, 1 - 1*sp.I)\n        2\n    \"\"\"\n    return z1 * z2"], ["def cartesian_to_polar(z):\n    \"\"\"Convert Cartesian coordinates to polar coordinates.\n    \n    Parameters:\n        z (complex): Complex number in Cartesian form.\n    \n    Returns:\n        tuple: Two-dimensional tuple (magnitude, angle_in_radians).\n    \n    Examples:\n        >>> cartesian_to_polar(1+1j)\n        (1.4142135623730951, 0.7853981633974483)\n    \"\"\"\n    return cmath.polar(z)", "def to_polar(z):\n    \"\"\"\n    Convert a complex number from Cartesian to polar form.\n    \n    Parameters:\n        z (complex): The complex number in Cartesian form.\n        \n    Returns:\n        tuple: A tuple (magnitude, angle in radians).\n    \"\"\"\n    return (np.abs(z), np.angle(z))"], ["def magnitude_and_phase(z):\n    \"\"\"\n    Calculate magnitude and phase (angle) of a complex number.\n    \n    Parameters:\n        z (complex): Complex number to calculate properties for.\n    \n    Returns:\n        tuple: Magnitude and phase (in radians).\n    \n    Examples:\n        >>> magnitude_and_phase(3+4j)\n        (5.0, 0.9272952180016122)\n    \"\"\"\n    return (np.abs(z), np.angle(z))"], ["def complex_conjugate(z):\n    \"\"\"Find the complex conjugate of a complex number.\n    \n    Parameters:\n        z (complex): Complex number.\n    \n    Returns:\n        complex: The complex conjugate of z.\n    \n    Examples:\n        >>> complex_conjugate(2+3j)\n        (2-3j)\n    \"\"\"\n    return z.conjugate()", "def conjugate_complex(z):\n    \"\"\"\n    Compute the complex conjugate of a complex number.\n    \n    Parameters:\n        z (complex): The complex number.\n        \n    Returns:\n        complex: The conjugate of the complex number.\n    \"\"\"\n    return np.conjugate(z)", "def conjugate_complex_number(z):\n    \"\"\"\n    Compute the complex conjugate of a complex number.\n    \n    Parameters:\n        z (complex): Complex number to conjugate.\n    \n    Returns:\n        complex: The conjugate of the complex number.\n    \n    Examples:\n        >>> conjugate_complex_number(3+4j)\n        (3-4j)\n    \"\"\"\n    return np.conjugate(z)"], ["def create_complex(real, imag):\n    \"\"\"\n    Create a complex number from real and imaginary parts.\n    Parameters:\n        real (float): The real part of the complex number.\n        imag (float): The imaginary part of the complex number.\n    Returns:\n        complex: The complex number represented as 'real + imag*j'.\n    \n    Example:\n        >>> create_complex(3, 4)\n        (3+4j)\n    \"\"\"\n    return complex(real, imag)"], ["def rationalize_denominator(z):\n    \"\"\"\n    Rationalize the denominator of a complex number.\n    Parameters:\n    - z (complex or tuple): The complex number whose denominator needs to be rationalized.\n    Returns:\n    - complex: The complex number with a rationalized denominator.\n    Example:\n    >>> rationalize_denominator(1/(1+2j))\n    (0.2-0.4j)\n    \"\"\"\n    if isinstance(z, tuple):\n        z = complex(*z)\n    return z.conjugate() / (z * z.conjugate()).real", "def rationalize_denominator(z):\n    \"\"\"\n    Rationalize the denominator of a complex number expression.\n    Parameters:\n        z (complex): The complex number whose denominator is to be rationalized.\n    Returns:\n        complex: A complex number with rationalized denominator.\n    \n    Example:\n        >>> rationalize_denominator(1 / (3+4j))\n        (0.12-0.16j)\n    \"\"\"\n    conjugate = np.conj(z)\n    return z * conjugate / (modulus(z)**2)"], ["def complex_translate(z, offset):\n    \"\"\"\n    Translates a complex number by a given complex offset.\n    Parameters:\n    - z (complex): The original complex number.\n    - offset (complex): The offset for translation.\n    Returns:\n    - complex: The translated complex number.\n    Examples:\n    >>> complex_translate(1+2j, 3+4j)\n    (4+6j)\n    \"\"\"\n    return z + offset"], ["def square_sum_complex(z1, z2):\n    \"\"\"\n    Calculate the square of the sum of two complex numbers and relate it to separate squares and product.\n    Parameters:\n        z1 (complex): First complex number.\n        z2 (complex): Second complex number.\n    Returns:\n        tuple: Contains the square of the sum, sum of squares, and twice the product of the numbers.\n    \n    Example:\n        >>> square_sum_complex(1+2j, 3+4j)\n        ((16+20j), (10+20j), 28+0j)\n    \"\"\"\n    sum_z = z1 + z2\n    squares_sum = z1**2 + z2**2\n    twice_product = 2 * z1 * z2\n    return (sum_z**2, squares_sum, twice_product)"], ["def complex_subtract(z1, z2):\n    \"\"\"\n    Subtract one complex number from another.\n    Parameters:\n        z1 (complex): First complex number.\n        z2 (complex): Second complex number.\n    Returns:\n        complex: Result of subtraction of z2 from z1.\n    \n    Example:\n        >>> complex_subtract(5+3j, 2+2j)\n        (3+1j)\n    \"\"\"\n    return z1 - z2", "def complex_subtract(z1, z2):\n    \"\"\"\n    Subtracts the second complex number from the first.\n    Parameters:\n    - z1 (complex or array-like): The first complex number.\n    - z2 (complex or array-like): The second complex number.\n    Returns:\n    - complex: The result of z1 - z2.\n    Examples:\n    >>> complex_subtract(5+3j, 2+2j)\n    (3+1j)\n    \"\"\"\n    return np.subtract(z1, z2)"], ["def complex_inverse(z):\n    \"\"\"Compute the multiplicative inverse of a complex number.\n    \n    Parameters:\n        z (complex): Complex number to invert.\n    \n    Returns:\n        complex: Inverse of the complex number.\n    \n    Examples:\n        >>> complex_inverse(2-3j)\n        (0.15384615384615385+0.23076923076923078j)\n    \"\"\"\n    if z == 0:\n        raise ValueError(\"Inverse does not exist for zero.\")\n    return 1 / z", "def inverse_complex(z):\n    \"\"\"\n    Compute the multiplicative inverse of a complex number.\n    \n    Parameters:\n        z (complex): The complex number to invert.\n        \n    Returns:\n        complex: The inverse of the complex number.\n    \"\"\"\n    if z == 0:\n        raise ValueError(\"Complex number cannot be zero for inversion.\")\n    return 1 / z"], ["def simplify_complex_expression(expr):\n    \"\"\"\n    Simplifies complex number expressions, especially focusing on algebraic identities\n    such as sum of cubes and squaring of sums.\n    \n    Parameters:\n    expr (str): The complex expression in string format to be simplified.\n    \n    Returns:\n    complex: Simplified complex number.\n    \n    Example:\n    >>> simplify_complex_expression('(1+3j)**2 + 2*(1+3j) - 3')\n    (1+12j)\n    \n    Note:\n    This function is a basic example and might need enhancements to cover more\n    generic situations or expressions.\n    \"\"\"\n    from sympy import sympify\n    expr = expr.replace('j', 'I')  # Replace 'j' with 'I' for sympy compatibility.\n    simplified_expr = sympify(expr).evalf()\n    return complex(simplified_single_expr)"], ["def perform_complex_arithmetic(z1, z2, operation='add'):\n    \"\"\"\n    Calculate arithmetic operations between two complex numbers.\n    Parameters:\n    - z1 (complex or tuple): The first complex number.\n    - z2 (complex or tuple): The second complex number.\n    - operation (str): The type of arithmetic operation ('add', 'subtract', 'multiply', 'divide').\n    Returns:\n    - complex: The result of the arithmetic operation on the two complex numbers.\n    Example:\n    >>> perform_complex_arithmetic((1, 2), (3, 4), 'add')\n    (4+6j)\n    >>> perform_complex_arithmetic((1, 2), (3, 4), 'multiply')\n    (-5+10j)\n    \"\"\"\n    if isinstance(z1, tuple):\n        z1 = complex(*z1)\n    if isinstance(z2, tuple):\n        z2 = complex(*z2)\n    \n    if operation == 'add':\n        return z1 + z2\n    elif operation == 'subtract':\n        return z1 - z2\n    elif operation == 'multiply':\n        return z1 * z2\n    elif operation == 'divide':\n        return z1 / z2 if z2 != 0 else None"], ["def complex_scale(z, factor):\n    \"\"\"\n    Scales a complex number by a given factor.\n    Parameters:\n    - z (complex): The complex number to scale.\n    - factor (float or complex): Scaling factor.\n    Returns:\n    - complex: The scaled complex number.\n    Examples:\n    >>> complex_scale(1+2j, 2)\n    (2+4j)\n    \"\"\"\n    return z * factor"], ["def calculate_complex_power(z, power):\n    \"\"\"\n    Calculate the exponentiation of a complex number.\n    Parameters:\n    - z (complex or tuple): The complex number.\n    - power (int): The power to which the complex number is raised.\n    Returns:\n    - complex: The complex number raised to the specified power.\n    Example:\n    >>> calculate_complex_power((1, 2), 3)\n    (-9+46j)\n    \"\"\"\n    if isinstance(z, tuple):\n        z = complex(*z)\n    return np.power(z, power)"], ["def normalize_angle(angle):\n    \"\"\"\n    Normalize an angle to the range [0, 2*pi).\n    \n    Parameters:\n        angle (float): An angle in radians.\n        \n    Returns:\n        float: The angle normalized to [0, 2*pi).\n    \"\"\"\n    return angle % (2 * math.pi)"], ["def from_polar(magnitude, angle):\n    \"\"\"\n    Convert a complex number from polar to Cartesian form using Euler's formula.\n    \n    Parameters:\n        magnitude (float): The magnitude of the complex number.\n        angle (float): The angle in radians.\n        \n    Returns:\n        complex: The complex number in Cartesian form.\n    \"\"\"\n    return magnitude * np.exp(1j * angle)"], ["def complex_operations(z, operation=\"modulus\"):\n    \"\"\"\n    Perform various operations on complex numbers such as calculating modulus, \n    finding powers, rationalizing denominator, and simplifying using i^2 = -1.\n    Parameters:\n    z (complex): The complex number to operate on.\n    operation (str): Type of operation to perform ['modulus', 'power', 'rationalize', 'simplify'].\n    Returns:\n    Various: Depending on the operation, returns complex number or real number.\n    \n    Example:\n    >>> complex_operations(1+3j, \"modulus\")\n    3.1622776601683795\n    >>> complex_operations((1+3j)**2, \"simplify\")\n    (-8+6j)\n    \"\"\"\n    if operation == \"modulus\":\n        return cmath.sqrt(z.real**2 + z.imag**2).real\n    elif operation == \"power\":\n        return cmath.exp(z)\n    elif operation == \"rationalize\":\n        return z.conjugate() / (z.real**2 + z.imag**2)\n    elif operation == \"simplify\":\n        return (z**2).real - 1 + 2 * z.imag * 1j        # Using i^2 = -1"], ["class ComplexOperations:\n    \"\"\"\n    A class containing a suite of operations for complex numbers.\n    \"\"\"\n    @staticmethod\n    def add_complex_numbers(z1, z2):\n        \"\"\"\n        Add two complex numbers.\n        Parameters:\n        z1 (complex): First complex number.\n        z2 (complex): Second complex number.\n        Returns:\n        complex: The sum of the two complex numbers.\n        Examples:\n        >>> ComplexOperations.add_complex_numbers(1+2j, 3+4j)\n        (4+6j)\n        \"\"\"\n        return z1 + z2\n    @staticmethod\n    def multiply_complex_numbers(z1, z2):\n        \"\"\"\n        Multiply two complex numbers.\n        Parameters:\n        z1 (complex): First complex number.\n        z2 (complex): Second complex number.\n        Returns:\n        complex: The product of the two complex numbers.\n        Examples:\n        >>> ComplexOperations.multiply_complex_numbers(1+2j, 3+4j)\n        (-5+10j)\n        \"\"\"\n        return z1 * z2\n    @staticmethod\n    def square_complex_number(z):\n        \"\"\"\n        Square a complex number.\n        Parameters:\n        z (complex): Complex number to square.\n        Returns:\n        complex: The square of the complex number.\n        Examples:\n        >>> ComplexOperations.square_complex_number(2+3j)\n        (-5+12j)\n        \"\"\"\n        return z * z\n    @staticmethod\n    def find_fixed_points(w, z):\n        \"\"\"\n        Find fixed points of the function w(z), assuming w is a lambda function.\n        Parameters:\n        w (function): A lambda function representing a complex function w(z).\n        z (sympy.Symbol): Symbolic representation of complex variable z.\n        Returns:\n        list: Solutions that satisfy w(z) = z.\n        Examples:\n        >>> z = sp.symbols('z', complex=True)\n        >>> w = lambda z: z**2 + 1 + 0*z  # Suppresses simplification issues\n        >>> ComplexOperations.find_fixed_points(w, z)\n        [1/2 - sqrt(3)*I/2, 1/2 + sqrt(3)*I/2]\n        \"\"\"\n        z_fixed = sp.Eq(w(z), z)\n        return sp.solve(z_fixed, z)\n    @staticmethod\n    def apply_piecewise_function(funcs, conditions, z):\n        \"\"\"\n        Evaluate piecewise complex functions based on conditions.\n        Parameters:\n        funcs (list of functions): A list of lambda functions for each piece.\n        conditions (list of functions): A list of lambda boolean expressions representing conditions for pieces.\n        z (complex): Complex number input.\n        Returns:\n        complex: Output after evaluating the correct piece.\n        Examples:\n        >>> funcs = [lambda z: z**2, lambda z: sp.exp(z)]\n        >>> conditions = [lambda z: sp.re(z) > 0, lambda z: sp.re(z) <= 0]\n        >>> ComplexOperations.apply_piecewise_function(funcs, conditions, -1+1j)\n        exp(-1 + 1j)\n        \"\"\"\n        for func, condition in zip(funcs, conditions):\n            if condition(z):\n                return func(z)\n        return None  # Default case if no conditions are met"], ["def polar_to_cartesian(r, theta):\n    \"\"\"Convert polar coordinates to Cartesian coordinates.\n    \n    Parameters:\n        r (float): Magnitude of the vector.\n        theta (float): Angle in radians.\n    \n    Returns:\n        complex: Cartesian form of the complex number.\n    \n    Examples:\n        >>> polar_to_cartesian(2, cmath.pi/4)\n        (1.4142135623730951+1.4142135623730951j)\n    \"\"\"\n    return cmath.rect(r, theta)"], ["def find_fixed_points(z_function, z_var, initial_guesses):\n    \"\"\"\n    Find fixed points of a complex function where f(z) = z.\n    \n    Parameters:\n        z_function (sp.core.expr.Expr): A function of complex variable z.\n        z_var (sp.Symbol): The symbol used as a complex variable in z_function.\n        initial_guesses (list): List of initial guesses to start the root finding.\n        \n    Returns:\n        list: The list of complex numbers which are fixed points.\n        \n    Example:\n        >>> z = sp.symbols('z')\n        >>> f_z = z**2 + 1 - 1*z\n        >>> find_fixed_points(f_z, z, [0, 1 + sp.I])\n        [-1.0, 1.0]\n    \"\"\"\n    equation = sp.Eq(z_function, z_var)\n    solutions = []\n    for guess in initial_guesses:\n        sol = sp.nsolve(equation, z_var, guess)\n        if sol not in solutions:  # Avoid duplicate roots\n            solutions.append(sol)\n    return solutions"], ["def complex_details(z):\n    \"\"\"\n    Provides detailed components of a complex number including real and imaginary parts,\n    and other representations.\n    Parameters:\n    z (complex): A complex number.\n    \n    Returns:\n    dict: Dictionary containing real and imaginary parts, modulus, and reciprocal,\n    \n    Example:\n    >>> complex_details(1+3j)\n    {'real_part': 1, 'imaginary_part': 3, 'modulus': 3.1622776601683795, 'reciprocal': (0.1-0.3j)}\n    \"\"\"\n    real_part = z.real\n    imaginary_part = z.imag\n    modulus = cmath.sqrt(real_part**2 + imaginary_part**2).real\n    reciprocal = 1 / z if z != 0 else None\n    return {\n        \"real_part\": real_part,\n        \"imaginary_part\": imaginary_part,\n        \"modulus\": modulus,\n        \"reciprocal\": reciprocal\n    }"], ["def raise_to_power(z, power):\n    \"\"\"\n    Raise a complex number to a given power using DeMoivre's Theorem.\n    \n    Parameters:\n        z (complex): The complex number.\n        power (int): The power to which the complex number is to be raised.\n        \n    Returns:\n        complex: The result of raising z to the power.\n    \"\"\"\n    magnitude, angle = to_polar(z)\n    return from_polar(magnitude**power, angle*power)"], ["def euler_to_complex(r, theta):\n    \"\"\"\n    Convert a complex number from polar (Euler's) form (r*e^(i*theta)) to rectangular form.\n    \n    Parameters:\n        r (float): Magnitude of the complex number.\n        theta (float): Phase (angle in radians) of the complex number.\n    \n    Returns:\n        complex: The complex number in rectangular form.\n    \n    Examples:\n        >>> euler_to_complex(5, np.pi/4)\n        (3.5355339059327378+3.5355339059327378j)\n    \"\"\"\n    return r * np.exp(1j * theta)"]]}