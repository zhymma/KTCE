{"Basic Operations": [["def calculate_mean(data):\n    \"\"\"\n    Calculate the mean of a list of numbers.\n    Parameters:\n    - data: list, a list of numbers\n    Returns:\n    - the mean of the list\n    Examples:\n    >>> calculate_mean([2, 4, 6, 8])\n    5.0\n    \"\"\"\n    if not data:\n        raise ValueError(\"Data list is empty\")\n    return sum(data) / len(data)", "def calculate_diff_from_mean(data):\n    \"\"\"\n    Calculate the difference from the mean for a list of numbers.\n    Parameters:\n    - data: list, a list of numbers\n    Returns:\n    - list of differences from the mean\n    Examples:\n    >>> calculate_diff_from_mean([2, 4, 6, 8])\n    [-3.0, -1.0, 1.0, 3.0]\n    \"\"\"\n    mean = calculate_mean(data)\n    return [x - mean for x in data]"], ["def divide(numerator, denominator):\n    \"\"\"\n    Divide one number by another.\n    Parameters:\n        numerator (float or int): The number to be divided.\n        denominator (float or int): The number by which to divide.\n    Returns:\n        float: The result of the division.\n    Examples:\n        >>> divide(10, 2)\n        5.0\n        >>> divide(20, 3)\n        6.666666666666667\n    \"\"\"\n    if denominator == 0:\n        raise ValueError(\"Denominator cannot be zero\")\n    return numerator / denominator", "def divide_numbers(a, b):\n    \"\"\"\n    Divide the first number by the second.\n    Parameters:\n    a (float|int): The numerator.\n    b (float|int): The denominator.\n    Returns:\n    float|int: The result of the division a / b.\n    Examples:\n    >>> divide_numbers(10, 2)\n    5.0\n    >>> divide_numbers(5, 2)\n    2.5\n    \"\"\"\n    if b == 0:\n        raise ValueError(\"Denominator cannot be zero.\")\n    return a / b", "def divide(a, b):\n    \"\"\"\n    Returns the quotient of two numbers.\n    Parameters:\n        a (float or int): Numerator.\n        b (float or int): Denominator.\n    Returns:\n        float or int: The quotient of the numbers. Returns None if division by zero occurs.\n    Examples:\n        >>> divide(10, 2)\n        5.0\n        >>> divide(5, 0)\n        None\n    \"\"\"\n    if b == 0:\n        return None\n    return a / b", "def divide(a, b):\n    \"\"\"\n    Divides the first number by the second.\n    Parameters:\n        a (float): The dividend.\n        b (float): The divisor (should not be zero).\n    Returns:\n        float: The quotient of a divided by b.\n    Raises:\n        ValueError: If b is zero.\n    \"\"\"\n    if b == 0:\n        raise ValueError(\"The divisor cannot be zero.\")\n    return a / b", "def divide_numbers(a, b):\n    \"\"\"\n    Divide one number by another. Handles division by zero by returning None.\n    \n    Parameters:\n    - a (int or float): Dividend.\n    - b (int or float): Divisor.\n    \n    Returns:\n    - float or None: The quotient if b is not zero, otherwise None.\n    \n    Examples:\n    >>> divide_numbers(8, 2)\n    4.0\n    >>> divide_numbers(7, 0)  # This is expected to handle gracefully\n    None\n    \"\"\"\n    if b == 0:\n        return None\n    else:\n        return a / b", "def divide(a, b):\n    \"\"\"\n    Divides the first number by the second and returns the quotient.\n    Parameters:\n    a (float|int): Numerator\n    b (float|int): Denominator\n    Returns:\n    float|int: The quotient of the division if b is not zero; otherwise, it raises ValueError.\n    \"\"\"\n    if b == 0:\n        raise ValueError(\"Division by zero is not allowed.\")\n    return a / b", "def divide_numbers(numerator, denominator):\n    \"\"\"Divide two numbers, numerator by denominator.\n    Parameters:\n        numerator (float or int): The number to be divided.\n        denominator (float or int): The number by which to divide the numerator.\n    Returns:\n        float: The result of the division.\n    Examples:\n        >>> divide_numbers(10, 2)\n        5.0\n        >>> divide_numbers(5, 2)\n        2.5\n    \"\"\"\n    if denominator == 0:\n        raise ValueError(\"Denominator cannot be zero.\")\n    return numerator / denominator"], ["def add_fractions(frac1, frac2):\n    \"\"\"\n    Adds two fractions and returns the result in simplest form.\n    \n    Parameters:\n        frac1 (Fraction or str): The first fraction.\n        frac2 (Fraction or str): The second fraction.\n    \n    Returns:\n        Fraction: The sum of the two fractions in its simplest form.\n    \n    Examples:\n        >>> add_fractions(Fraction(1, 2), Fraction(2, 3))\n        Fraction(7, 6)\n        >>> add_fractions('1/2', '3/4')\n        Fraction(5, 4)\n    \"\"\"\n    if isinstance(frac1, str):\n        frac1 = Fraction(frac1)\n    if isinstance(frac2, str):\n        frac2 = Fraction(frac2)\n    return frac1 + frac2", "def multiply_fractions(frac1, frac2):\n    \"\"\"\n    Multiplies two fractions and returns the result in simplest form.\n    \n    Parameters:\n        frac1 (Fraction or str): The first fraction.\n        frac2 (Fraction or str): The second fraction.\n    Returns:\n        Fraction: The product of the two fractions.\n    Examples:\n        >>> multiply_fractions(Fraction(1, 2), Fraction(2, 3))\n        Fraction(1, 3)\n        >>> multiply_fractions('2/3', '4/5')\n        Fraction(8, 15)\n    \"\"\"\n    if isinstance(frac1, str):\n        frac1 = Fraction(frac1)\n    if isinstance(frac2, str):\n        frac2 = Fraction(frac2)\n    return frac1 * frac2", "def add_fractions(frac1, frac2):\n    \"\"\"\n    Add two fractions using Fraction objects to maintain accuracy.\n    \n    Parameters:\n    - frac1 (Fraction): First fraction.\n    - frac2 (Fraction): Second fraction.\n    \n    Returns:\n    - Fraction: The result of the addition of the two fractions.\n    \n    Examples:\n    >>> add_fractions(Fraction(1, 2), Fraction(1, 3))\n    Fraction(5, 6)\n    \"\"\"\n    return frac1 + frac2", "def multiply_fractions(frac1, frac2):\n    \"\"\"\n    Multiply two fractions.\n    \n    Parameters:\n    - fratc1 (Fraction): First fraction to multiply.\n    - fratc2 (Fraction): Second fraction to multiply.\n    \n    Returns:\n    - Fraction: The product of the two fractions.\n    \n    Examples:\n    >>> multiply_fractions(Fraction(1, 2), Fraction(2, 3))\n    Fraction(1, 3)\n    \"\"\"\n    return frac1 * frac2", "def divide_fractions(frac1, frac2):\n    \"\"\"\n    Divide one fraction by another. Handles cases where the second fraction is zero.\n    \n    Parameters:\n    - frac1 (Fraction): Dividend fraction.\n    - frac2 (Fraction): Divisor fraction.\n    \n    Returns:\n    - Fraction or None: The quotient as a fraction, or None if the divisor is 0.\n    \n    Examples:\n    >>> divide_fractions(Fraction(1, 2), Fraction(2, 3))\n    Fraction(3, 4)\n    >>> divide_fractions(Fraction(1, 2), Fraction(0, 1))\n    None\n    \"\"\"\n    if frac2 == 0:\n        return None\n    return frac1 / frac2", "def add_fraction(frac_1, frac_2):\n    \"\"\"\n    This function adds two fractions.\n    Parameters:\n    frac_1 (fractions.Fraction): The first fraction.\n    frac_2 (fractions.Fraction): The second fraction.\n    Returns:\n    fractions.Fraction: The result of adding the two fractions.\n    Example:\n    >>> add_fraction(fractions.Fraction(3, 4), fractions.Fraction(1, 2))\n    Fraction(5, 4)\n    \"\"\"\n    return frac_1 + frac_2", "def subtract_fraction(frac_1, frac_2):\n    \"\"\"\n    This function subtracts two fractions.\n    Parameters:\n    frac_1 (fractions.Fraction): The first fraction.\n    frac_2 (fractions.Fraction): The second fraction.\n    Returns:\n    fractions.Fraction: The result of subtracting the second fraction from the first fraction.\n    Example:\n    >>> subtract_fraction(fractions.Fraction(3, 4), fractions.Fraction(1, 2))\n    Fraction(1, 4)\n    \"\"\"\n    return frac_1 - frac_2", "def multiply_fraction(frac_1, frac_2):\n    \"\"\"\n    This function multiplies two fractions.\n    Parameters:\n    frac_1 (fractions.Fraction): The first fraction.\n    frac_2 (fractions.Fraction): The second fraction.\n    Returns:\n    fractions.Fraction: The result of multiplying the two fractions.\n    Example:\n    >>> multiply_fraction(fractions.Fraction(3, 4), fractions.Fraction(1, 2))\n    Fraction(3, 8)\n    \"\"\"\n    return frac_1 * frac_2", "def divide_fraction(frac_1, frac_2):\n    \"\"\"\n    This function divides two fractions.\n    Parameters:\n    frac_1 (fractions.Fraction): The first fraction (dividend).\n    frac_2 (fractions.Fraction): The second fraction (divisor).\n    Returns:\n    fractions.Fraction: The result of dividing the first fraction by the second fraction.\n    Example:\n    >>> divide_fraction(fractions.Fraction(3, 4), fractions.Fraction(1, 2))\n    Fraction(3, 2)\n    \"\"\"\n    return frac_1 / frac_2"], ["def is_divisible(number, divisor):\n    \"\"\"Check if the number is divisible by the divisor.\n    \n    Parameters:\n        number (int): The number to check.\n        divisor (int): The divisor to check against.\n        \n    Returns:\n        bool: True if number is divisible by divisor, otherwise False.\n    \n    Examples:\n        >>> is_divisible(10, 2)\n        True\n        >>> is_divisible(10, 3)\n        False\n    \"\"\"\n    return number % divisor == 0", "def is_divisible(n, d):\n    \"\"\"\n    Check if a number is divisible by another.\n    \n    Parameters\n    ----------\n    n : int\n        The number to be divided.\n    d : int\n        The divisor.\n    \n    Returns\n    -------\n    bool\n        True if n is divisible by d, False otherwise.\n    \n    Examples\n    --------\n    >>> is_divisible(10, 2)\n    True\n    \n    >>> is_divisible(10, 3)\n    False\n    \"\"\"\n    if d == 0:\n        raise ValueError(\"Divisor cannot be zero.\")\n    return n % d == 0"], ["def sum_values(*args, operation='sum'):\n    \"\"\"\n    Performs basic arithmetic operations: sum, subtraction, multiplication, or division on a given set of values.\n    \n    Parameters:\n    - args (float or int): A set of numeric values to perform operations on.\n    - operation (str): Type of operation; can be 'sum', 'subtract', 'multiply', or 'divide'. Default is 'sum'.\n    \n    Returns:\n    - float or int: Result of the arithmetic operation.\n    \n    Examples:\n    - sum_values(1, 2, 3, 4) should return 10.\n    - sum_values(1, 2, 3, 4, operation='multiply') should return 24.\n    - sum_values(10, 2, operation='subtract') should return 8.\n    - sum_values(100, 10, operation='divide') should return 10.\n    \"\"\"\n    import operator\n    from functools import reduce\n    \n    operations = {\n        'sum': operator.add,\n        'subtract': operator.sub,\n        'multiply': operator.mul,\n        'divide': operator.truediv\n    }\n    \n    if operation in operations and len(args) > 1:\n        return reduce(operations[operation], args)\n    elif len(args) == 1:\n        return args[0]\n    else:\n        raise ValueError(\"Unsupported operation or insufficient arguments\")", "def arithmetic_operations(numbers, operation='sum'):\n    \"\"\"\n    Perform arithmetic operations on a list of numbers or expressions.\n    \n    Parameters:\n    - numbers (list): A list of numbers (integers or floats) or expressions (e.g., Fraction objects).\n    - operation (str): The type of operation to perform - 'sum', 'product', 'mean', 'divisions'.\n    \n    Returns:\n    - result (int, float, Fraction): Result of the specified arithmetic operation.\n    \n    Example:\n    >>> arithmetic_operations([1, 2, 3, 4], 'sum')\n    10\n    >>> arithmetic_operations([1, 2, 3, 4], 'product')\n    24\n    >>> arithmetic_operations([Fraction(1, 2), Fraction(3, 4)], 'sum')\n    Fraction(5, 4)\n    \n    Note:\n    - 'divisions' treats the first element as numerator and subsequent elements as denominators.\n    \"\"\"\n    if operation == 'sum':\n        return sum(numbers)\n    elif operation == 'product':\n        return np.prod(numbers)\n    elif operation == 'mean':\n        return sum(numbers) / len(numbers)\n    elif operation == 'divisions':\n        result = numbers[0]\n        for num in numbers[1:]:\n            result /= num\n        return result\n    else:\n        raise ValueError('Unsupported operation specified.')"], ["def lcm(a, b):\n    \"\"\"\n    Compute the least common multiple of two numbers based on their GCD.\n    Parameters:\n    a (int): The first number.\n    b (int): The second number.\n    Returns:\n    int: The least common multiple of a and b.\n    Examples:\n    >>> lcm(4, 5)\n    20\n    >>> lcm(12, 6)\n    12\n    \"\"\"\n    return abs(a*b) // gcd(a, b)", "def calculate_gcd_lcm(a, b):\n    \"\"\"\n    Calculate the greatest common divisor (GCD) and the least common multiple (LCM) of two numbers.\n    Parameters:\n    - a : int\n        First number.\n    - b : int\n        Second number.\n    Returns:\n    - tuple\n        A tuple containing the GCD and LCM of the two numbers.\n    Examples:\n    >>> calculate_gcd_lcm(54, 24)\n    (6, 216)\n    >>> calculate_gcd_lcm(21, 14)\n    (7, 42)\n    \"\"\"\n    from math import gcd\n    gcd_val = gcd(a, b)\n    lcm_val = (a * b) // gcd_val\n    \n    return (gcd_val, lcm_val)"], ["def area(shape, *dimensions):\n    \"\"\"\n    Calculate the area of various shapes.\n    \n    Parameters\n    ----------\n    shape : str\n        The shape to calculate the area for. Options are 'circle', 'rectangle', 'triangle', 'square'.\n    *dimensions : float\n        The dimensions required for the shape.\n        - Circle: radius\n        - Rectangle: length, width\n        - Triangle: base, height\n        - Square: side length\n        \n    Returns\n    -------\n    float\n        The area of the specified shape.\n    \n    Examples\n    --------\n    >>> area('circle', 5)\n    78.53981633974483\n    \n    >>> area('rectangle', 4, 5)\n    20\n    \n    >>> area('triangle', 3, 4)\n    6\n    \n    >>> area('square', 4)\n    16\n    \"\"\"\n    if shape == 'circle':\n        if len(dimensions) == 1:\n            radius = dimensions[0]\n            return math.pi * (radius ** 2)\n        else:\n            raise ValueError(\"Circle requires 1 dimension (radius).\")\n    elif shape == 'rectangle':\n        if len(dimensions) == 2:\n            length, width = dimensions\n            return length * width\n        else:\n            raise ValueError(\"Rectangle requires 2 dimensions (length, width).\")\n    elif shape == 'triangle':\n        if len(dimensions) == 2:\n            base, height = dimensions\n            return 0.5 * base * height\n        else:\n            raise ValueError(\"Triangle requires 2 dimensions (base, height).\")\n    elif shape == 'square':\n        if len(dimensions) == 1:\n            side = dimensions[0]\n            return side ** 2\n        else:\n            raise ValueError(\"Square requires 1 dimension (side length).\")\n    else:\n        raise ValueError(\"Invalid shape specified.\")", "def volume(shape, *dimensions):\n    \"\"\"\n    Calculate the volume of various 3D shapes.\n    \n    Parameters\n    ----------\n    shape : str\n        The shape to calculate the volume for. Options are 'cube', 'rectangular_prism', 'cylinder', 'sphere'.\n    *dimensions : float\n        The dimensions required for the shape.\n        - Cube: side length\n        - Rectangular Prism: length, width, height\n        - Cylinder: radius, height\n        - Sphere: radius\n    \n    Returns\n    -------\n    float\n        The volume of the specified shape.\n    \n    Examples\n    --------\n    >>> volume('cube', 3)\n    27\n    \n    >>> volume('rectangular_prism', 2, 3, 4)\n    24\n    \n    >>> volume('cylinder', 3, 5)\n    141.3716694115407\n    \n    >>> volume('sphere', 3)\n    113.09733552923255\n    \"\"\"\n    if shape == 'cube':\n        if len(dimensions) == 1:\n            side = dimensions[0]\n            return side ** 3\n        else:\n            raise ValueError(\"Cube requires 1 dimension (side length).\")\n    elif shape == 'rectangular_prism':\n        if len(dimensions) == 3:\n            length, width, height = dimensions\n            return length * width * height\n        else:\n            raise ValueError(\"Rectangular Prism requires 3 dimensions (length, width, height).\")\n    elif shape == 'cylinder':\n        if len(dimensions) == 2:\n            radius, height = dimensions\n            return math.pi * (radius ** 2) * height\n        else:\n            raise ValueError(\"Cylinder requires 2 dimensions (radius, height).\")\n    elif shape == 'sphere':\n        if len(dimensions) == 1:\n            radius = dimensions[0]\n            return (4/3) * math.pi * (radius ** 3)\n        else:\n            raise ValueError(\"Sphere requires 1 dimension (radius).\")\n    else:\n        raise ValueError(\"Invalid shape specified.\")", "def perimeter(shape, *dimensions):\n    \"\"\"\n    Calculate the perimeter or circumference of various shapes.\n    \n    Parameters\n    ----------\n    shape : str\n        The shape to calculate the perimeter for. Options are 'circle', 'rectangle', 'square'.\n    *dimensions : float\n        The dimensions required for the shape.\n        - Circle: radius\n        - Rectangle: length, width\n        - Square: side length\n    \n    Returns\n    -------\n    float\n        The perimeter or circumference of the specified shape.\n    \n    Examples\n    --------\n    >>> perimeter('circle', 5)\n    31.41592653589793\n    \n    >>> perimeter('rectangle', 4, 5)\n    18\n    \n    >>> perimeter('square', 4)\n    16\n    \"\"\"\n    if shape == 'circle':\n        if len(dimensions) == 1:\n            radius = dimensions[0]\n            return 2 * math.pi * radius\n        else:\n            raise ValueError(\"Circle requires 1 dimension (radius).\")\n    elif shape == 'rectangle':\n        if len(dimensions) == 2:\n            length, width = dimensions\n            return 2 * (length + width)\n        else:\n            raise ValueError(\"Rectangle requires 2 dimensions (length, width).\")\n    elif shape == 'square':\n        if len(dimensions) == 1:\n            side = dimensions[0]\n            return 4 * side\n        else:\n            raise ValueError(\"Square requires 1 dimension (side length).\")\n    else:\n        raise ValueError(\"Invalid shape specified.\")"], ["def convert_fraction_to_decimal(fraction_string):\n    \"\"\"\n    Convert a fraction represented as a string to a decimal value.\n    Parameters:\n        fraction_string (str): A string representation of the fraction ('numerator/denominator').\n    Returns:\n        float: Decimal representation of the fraction.\n    Examples:\n        >>> convert_fraction_to_decimal('1/3')\n        0.3333333333333333\n        >>> convert_fraction_to_decimal('2/5')\n        0.4\n    \"\"\"\n    from fractions import Fraction\n    return float(Fraction(fraction_string))", "def fraction_to_decimal(numerator, denominator):\n    \"\"\"Convert a fraction to its decimal form.\n    Parameters:\n        numerator (int): The numerator of the fraction.\n        denominator (int): The denominator of the fraction.\n    Returns:\n        float: Decimal representation of the fraction.\n    Examples:\n        >>> fraction_to_decimal(1, 2)\n        0.5\n        >>> fraction_to_decimal(2, 3)\n        0.6666666666666666\n    \"\"\"\n    return numerator / denominator", "def decimal_to_fraction(decimal, simplify=True):\n    \"\"\"Convert a decimal to its fraction form using the fractions module.\n    Parameters:\n        decimal (float): The decimal number to convert.\n        simplify (bool): Whether to simplify the fraction or not.\n    Returns:\n        Fraction: Fraction representation of the decimal.\n    Examples:\n        >>> decimal_to_fraction(0.5)\n        Fraction(1, 2)\n        >>> decimal_to_fraction(0.3333)\n        Fraction(3333, 10000)\n    \"\"\"\n    from fractions import Fraction\n    fraction = Fraction(decimal).limit_denominator()\n    if simplify:\n        return fraction\n    return Fraction(numerator=fraction.numerator, denominator=fraction.denominator)", "def fraction_decimal_conversion(value, to_type='decimal'):\n    \"\"\"\n    Convert between fraction and decimal forms.\n    Parameters:\n    - value (str): The input number in string format to facilitate conversion both ways.\n    - to_type (str): The target type for conversion; either 'decimal' or 'fraction'.\n    \n    Returns:\n    - Decimal or Fraction: Depending on to_type, the converted value.\n    \n    Examples:\n    - fraction_decimal_conversion('1/3', 'decimal') returns Decimal('0.333...')\n    - fraction_decimal_conversion('0.25', 'fraction') returns Fraction(1, 4)\n    \"\"\"\n    if to_type == 'decimal':\n        # Convert the Fraction to Decimal\n        return Decimal(Fraction(value))\n    elif to_type == 'fraction':\n        # Convert the Decimal to Fraction\n        return Fraction(value)\n    else:\n        raise ValueError(\"Unknown conversion type. Use 'decimal' or 'fraction'\")"], ["def multiply(a, b):\n    \"\"\"\n    Returns the product of two numbers.\n    Parameters:\n        a (float or int): First number.\n        b (float or int): Second number.\n    Returns:\n        float or int: The product of the numbers.\n    Examples:\n        >>> multiply(4, 3)\n        12\n        >>> multiply(7, 0.5)\n        3.5\n    \"\"\"\n    return a * b", "def multiply(a, b):\n    \"\"\"\n    Multiplies two numbers.\n    Parameters:\n        a (float): The first number.\n        b (float): The second number.\n    Returns:\n        float: The product of a and b.\n    \"\"\"\n    return a * b", "def multiply_numbers(a, b):\n    \"\"\"\n    Multiply two numbers.\n    \n    Parameters:\n    - a (int or float): First operand.\n    - b (int or float): Second operand.\n    \n    Returns:\n    - float: The product of the inputs.\n    \n    Examples:\n    >>> multiply_numbers(3, 4)\n    12\n    >>> multiply_numbers(1.5, 2)\n    3.0\n    \"\"\"\n    return a * b", "def multiply(a, b):\n    \"\"\"\n    Multiplies two numbers and returns the result.\n    Parameters:\n    a (float|int): First operand\n    b (float|int): Second operand\n    Returns:\n    float|int: The product of the two numbers.\n    \"\"\"\n    return a * b"], ["def alternating_sum(numbers):\n    \"\"\"\n    Computes alternating sum of elements in a list.\n    Parameters:\n    - numbers (list of numbers): A list containing the numerical sequence.\n    Returns:\n    - number: Alternating sum of the sequence.\n    Example:\n    >>> alternating_sum([1, 2, 3, 4])\n    -2  # 1 - 2 + 3 - 4\n    \"\"\"\n    return sum((-1)**i * x for i, x in enumerate(numbers))", "def alternating_sum(sequence):\n    \"\"\"Calculates the alternating sum of the elements of a sequence.\n    \n    Parameters:\n    sequence (list of float/int): The sequence of numbers to sum, alternating signs.\n    \n    Returns:\n    float/int: The alternating sum of the sequence.\n    \n    Examples:\n    >>> alternating_sum([1, 2, 3, 4, 5])\n    3\n    >>> alternating_sum([10, 20])\n    -10\n    \"\"\"\n    return sum((-1)**i * x for i, x in enumerate(sequence))"], ["def decimal_addition(a, b, precision=None):\n    \"\"\"Perform addition of two decimal numbers. Optionally, round the result.\n    Parameters:\n        a (float): First decimal number.\n        b (float): Second decimal number.\n        precision (int, optional): Number of decimal places to round the result.\n    Returns:\n        float: The result of the addition, rounded if precision is provided.\n    Examples:\n        >>> decimal_addition(1.23, 2.77)\n        4.0\n        >>> decimal_addition(1.235, 2.768, 2)\n        4.00\n    \"\"\"\n    from decimal import Decimal, getcontext\n    getcontext().prec = 28  # better default precision to minimize internal errors\n    result = Decimal(a) + Decimal(b)\n    if precision is not None:\n        return round(result, precision)\n    return float(result)", "def decimal_multiplication(a, b, precision=None):\n    \"\"\"Perform multiplication of two decimal numbers. Optionally, round the result.\n    Parameters:\n        a (float): First decimal number.\n        b (float): Second decimal number.\n        precision (int, optional): Number of decimal places to round the result.\n    Returns:\n        float: The result of the multiplication, rounded if precision is provided.\n    Examples:\n        >>> decimal_multiplication(0.5, 203.2)\n        101.6\n        >>> decimal_multiplication(3.14159, 2.71828, 5)\n        8.53973\n    \"\"\"\n    from decimal import Decimal, getcontext\n    getcontext().prec = 28\n    result = Decimal(a) * Decimal(b)\n    if precision is not None:\n        return round(result, precision)\n    return float(result)"], ["def calculate_arithmetic_mean(numbers):\n    \"\"\"\n    Calculate the arithmetic mean of a list of numbers.\n    \n    Parameters:\n    - numbers (list): A list of numeric values (ints or floats).\n    \n    Returns:\n    - float: The arithmetic mean of the numbers.\n    \n    Example:\n    >>> calculate_arithmetic_mean([1, 2, 3, 4, 5])\n    3.0\n    \"\"\"\n    if not numbers:\n        raise ValueError(\"The list of numbers cannot be empty.\")\n    \n    total_sum = sum(numbers)\n    count = len(numbers)\n    \n    return total_sum / count", "def compute_mean(numbers):\n    \"\"\"\n    Computes the arithmetic mean of a list of numbers.\n    Parameters:\n    numbers (list of float|int): A list containing numbers whose mean is to be calculated.\n    Returns:\n    float: The arithmetic mean of the numbers.\n    Raises:\n    ValueError: If the list is empty.\n    \"\"\"\n    if not numbers:\n        raise ValueError(\"The list of numbers cannot be empty.\")\n    return sum(numbers) / len(numbers)"], ["def evaluate_expression(expression):\n    \"\"\"\n    Evaluate a mathematical expression string adhering to the order of operations (PEMDAS/BODMAS).\n    Parameters:\n        expression (str): A string representing the mathematical expression to be evaluated.\n    Returns:\n        sympy.core.expr.Expr: The result of the evaluated expression, which can be numeric or symbolic.\n    Examples:\n        >>> evaluate_expression(\"3 + 2 * (1 + 5)\")\n        15\n        >>> evaluate_expression(\"(2 + 3) * 5 - 3**2\")\n        16\n        >>> evaluate_expression(\"2*3 + (4*5) / 2 - 3\")\n        13.0\n    \"\"\"\n    # Convert the input string expression to a sympy expression\n    sympy_expression = sp.sympify(expression)\n    \n    # Evaluate the expression\n    result = sympy_expression\n    return result\n    print(evaluate_expression(\"3 + 2 * (1 + 5)\"))  # Should print 15\n    print(evaluate_expression(\"(2 + 3) * 5 - 3**2\"))  # Should print 16\n    print(evaluate_expression(\"2*3 + (4*5) / 2 - 3\"))  # Should print 13.0", "def evaluate_expression(expression):\n    \"\"\"\n    Evaluates a mathematical expression string respecting the order of operations (PEMDAS/BODMAS).\n    \n    Parameters\n    ----------\n    expression : str\n        A string containing the mathematical expression to be evaluated.\n    Returns\n    -------\n    float\n        The result of the evaluated expression.\n        \n    Examples\n    --------\n    >>> evaluate_expression(\"2 + 3 * 4\")\n    14\n    >>> evaluate_expression(\"(1 + 2) * (3 + 4)\")\n    21\n    >>> evaluate_expression(\"100 / 2 ** 2\")\n    25.0\n    \"\"\"\n    import sympy as sp\n    return float(sp.sympify(expression))"], ["def calculate_percentage_of_number(number, percent):\n    \"\"\"Calculate the percentage of a given number.\n    Parameters:\n    - number (float) : The number to find the percentage of.\n    - percent (float) : The percentage to calculate.\n    Returns:\n    float : The calculated percentage of the input number.\n    \"\"\"\n    return (number * percent) / 100", "def calculate_percentage(base, percent):\n    \"\"\"Calculate the percentage of a number.\n    \n    Parameters:\n        base (float): The number to find the percentage of.\n        percent (float): The percentage to calculate.\n        \n    Returns:\n        float: The percentage of the base.\n    \n    Examples:\n        >>> calculate_percentage(200, 50)\n        100.0\n    \"\"\"\n    return basic_arithmetic('multiply', base, percent / 100)"], ["def add(*args):\n    \"\"\"\n    Sum a list of numbers.\n    Parameters:\n        *args (float or int): A set of numbers to be added.\n    Returns:\n        float: The sum of all the numbers.\n    Examples:\n        >>> add(1, 2, 3)\n        6\n        >>> add(10.5, 2.3)\n        12.8\n    \"\"\"\n    return sum(args)", "def add(*args):\n    \"\"\"\n    Returns the sum of the provided arguments.\n    Parameters:\n    args (float or int): A sequence of numbers that will be added together.\n    Returns:\n    float or int: Sum of all the numbers provided as arguments.\n    Examples:\n    >>> add(1, 2, 3)\n    6\n    >>> add(5.5, 3.3)\n    8.8\n    \"\"\"\n    return sum(args)", "def add_numbers(*args):\n    \"\"\"\n    Sum a series of numbers provided as arguments.\n    Parameters:\n    *args (float|int): A series of numbers to be summed.\n    Returns:\n    float|int: The sum of the provided numbers.\n    Examples:\n    >>> add_numbers(1, 2, 3)\n    6\n    >>> add_numbers(1.5, 2.3, 3.2)\n    7.0\n    \"\"\"\n    return sum(args)", "def add_numbers(*args):\n    \"\"\"Add a list of numbers together.\n    Parameters:\n        args (float or int): A variable number of arguments to be summed.\n    \n    Returns:\n        float or int: The sum of all the arguments.\n    Examples:\n        >>> add_numbers(1, 2, 3)\n        6\n        >>> add_numbers(5.5, 3.1, 2.1)\n        10.7\n    \"\"\"\n    return np.sum(args)"], ["def fraction_operations(a, b, operation='multiply'):\n    \"\"\"\n    Performs specified arithmetic operations on two fractions.\n    \n    Parameters:\n        a : tuple or Fraction\n            The first fraction, expressed as a tuple (numerator, denominator) or directly as a Fraction.\n        b : tuple or Fraction\n            The second fraction similarly expressed.\n        operation : str, optional\n            The arithmetic operation to perform - 'add', 'subtract', 'multiply', 'divide'.\n            Default is 'multiply'.\n    \n    Returns:\n        Fraction\n            The result of the arithmetic operation as a simplified fraction.\n    Examples:\n        >>> fraction_operations((1, 2), (3, 4), 'add')\n        Fraction(5, 4)\n        >>> fraction_operations((1, 2), (3, 4), 'subtract')\n        Fraction(-1, 4)\n        >>> fraction_operations((1, 2), (3, 4), 'multiply')\n        Fraction(3, 8)\n        >>> fraction_operations((1, 2), (3, 4), 'divide')\n        Fraction(2, 3)\n    \"\"\"\n    if isinstance(a, tuple):\n        a = Fraction(*a)\n    if isinstance(b, tuple):\n        b = Fraction(*b)\n    \n    if operation == 'add':\n        return a + b\n    elif operation == 'subtract':\n        return a - b\n    elif operation == 'multiply':\n        return a * b\n    elif operation == 'divide':\n        return a / b\n    else:\n        raise ValueError(\"Invalid operation specified.\")", "def perform_fraction_arithmetic(frac1, frac2, operation):\n    \"\"\"Perform arithmetic operations on two fractions and simplify the result.\n    Parameters:\n    - frac1 (Fraction) : The first fraction.\n    - frac2 (Fraction) : The second fraction.\n    - operation (str) : The operation to perform ('add', 'subtract', 'multiply', 'divide').\n    Returns:\n    Fraction : The result of the arithmetic operation.\n    \"\"\"\n    if operation == 'add':\n        result = frac1 + frac2\n    elif operation == 'subtract':\n        result = frac1 - frac2\n    elif operation == 'multiply':\n        result = frac1 * frac2\n    elif operation == 'divide':\n        result = frac1 / frac2 if frac2.numerator != 0 else 'Error: Division by zero'\n    else:\n        return 'Error: Invalid operation'\n    return simplify_fraction(result.numerator, result.denominator)", "def operate_on_fractions(a, b, operation='add'):\n    \"\"\"\n    Perform arithmetic operations on two fractions.\n    \n    Parameters:\n        a (str or Fraction): First fraction (as a Fraction object or a string like '3/4').\n        b (str or Fraction): Second fraction (same format as the first).\n        operation (str): The operation to perform ('add', 'subtract', 'multiply', 'divide').\n    \n    Returns:\n        Fraction: Result of the operation as a simplified fraction.\n    \n    Raises:\n        ValueError: If the operation type is invalid.\n        \n    Examples:\n        >>> operate_on_fractions('1/2', '1/3', 'add')\n        Fraction(5, 6)\n        >>> operate_on_fractions('1/2', '1/3', 'multiply')\n        Fraction(1, 6)\n    \"\"\"\n    a = Fraction(a)\n    b = Fraction(b)\n    if operation == 'add':\n        return a + b\n    elif operation == 'subtract':\n        return a - b\n    elif operation == 'multiply':\n        return a * b\n    elif operation == 'divide':\n        return a / b\n    else:\n        raise ValueError(\"Invalid operation type\")", "def fraction_operations(frac1, frac2, operation):\n    \"\"\"\n    Performs specified operation ('addition', 'subtraction', 'multiplication', 'division') on two fractions.\n    \n    Parameters:\n        frac1 (Fraction or str): The first fraction.\n        frac2 (Fraction or str): The second fraction.\n        operation (str): The operation to perform ('add', 'subtract', 'multiply', 'divide').\n    \n    Returns:\n        Fraction: The result of the operation on the two fractions.\n    \n    Examples:\n        >>> fraction_operations('1/2', '1/4', 'add')\n        Fraction(3, 4)\n        >>> fraction_operations('1/3', '1/6', 'multiply')\n        Fraction(1, 18)\n    \"\"\"\n    if isinstance(frac1, str):\n        frac1 = Fraction(frac1)\n    if isinstance(frac2, str):\n        frac2 = Fraction(frac2)\n    \n    if operation == 'add':\n        return frac1 + frac2\n    elif operation == 'subtract':\n        return frac1 - frac2\n    elif operation == 'multiply':\n        return frac1 * frac2\n    elif operation == 'divide':\n        return frac1 / frac2\n    else:\n        raise ValueError(\"Unsupported operation provided. Choose 'add', 'subtract', 'multiply', or 'divide'.\")"], ["def basic_arithmetic_operations(a, b, operation='add'):\n    \"\"\"\n    Performs basic arithmetic operations on two input numbers.\n    \n    Parameters:\n        a : float or int\n            The first number in the operation.\n        b : float or int\n            The second number involved in the operation.\n        operation : str, optional\n            The operation to perform. Expected values are 'add', 'subtract', 'multiply', 'divide'.\n            Default is 'add'.\n    \n    Returns:\n        float or int\n            The result of the arithmetic operation.\n    Examples:\n        >>> basic_arithmetic_operations(5, 3, 'add')\n        8\n        >>> basic_arithmetic_operations(5, 3, 'subtract')\n        2\n        >>> basic_arithmetic_operations(5, 3, 'multiply')\n        15\n        >>> basic_arithmetic_operations(5, 3, 'divide')\n        1.6666666666666667\n    \"\"\"\n    if operation == 'add':\n        return a + b\n    elif operation == 'subtract':\n        return a - b\n    elif operation == 'multiply':\n        return a * b\n    elif operation == 'divide':\n        if b != 0:\n            return a / b\n        else:\n            raise ValueError(\"Cannot divide by zero.\")\n    else:\n        raise ValueError(\"Invalid operation specified.\")", "def arithmetic_operations(a, b, operation=\"subtract\"):\n    \"\"\"\n    Perform basic arithmetic operations: addition, subtraction, multiplication, and division on two numbers.\n    Parameters:\n    - a (float|int): First operand in the operation.\n    - b (float|int): Second operand in the operation.\n    - operation (str): Type of operation ('add', 'subtract', 'multiply', 'divide'). Default is 'subtract'.\n    Returns:\n    - result (float): The result of the arithmetic operation.\n    Examples:\n    >>> arithmetic_operations(10, 5, \"add\")\n    15\n    >>> arithmetic_operations(10, 5, \"subtract\")\n    5\n    >>> arithmetic_operations(10, 5, \"multiply\")\n    50\n    >>> arithmetic_operations(10, 5, \"divide\")\n    2.0\n    \"\"\"\n    if operation == \"add\":\n        return a + b\n    elif operation == \"subtract\":\n        return a - b\n    elif operation == \"multiply\":\n        return a * b\n    elif operation == \"divide\":\n        if b == 0:\n            raise ValueError(\"Division by zero is undefined.\")\n        return a / b\n    else:\n        raise ValueError(\"Invalid operation. Choose 'add', 'subtract', 'multiply', or 'divide'.\")", "def arithmetic_operations(a, b, operation='add', number_type='decimal'):\n    \"\"\"\n    Perform basic arithmetic operations (addition, subtraction, multiplication, division)\n    on decimals or fractions.\n    Parameters:\n        a (float or str): First number (or a fraction represented as a string 'num/denom').\n        b (float or str): Second number (or a fraction represented as a string 'num/denom').\n        operation (str): The operation to perform ('add', 'subtract', 'multiply', 'divide').\n        number_type (str): The type of numbers ('decimal' or 'fraction').\n    Returns:\n        float or Fraction: Result of the operation.\n    Examples:\n        >>> arithmetic_operations(1.5, 2.3, 'add', 'decimal')\n        3.8\n        >>> arithmetic_operations('1/2', '3/4', 'add', 'fraction')\n        Fraction(5, 4)\n        >>> arithmetic_operations('1/3', '1/6', 'multiply', 'fraction')\n        Fraction(1, 18)\n    \"\"\"\n    from fractions import Fraction\n    \n    if number_type == 'fraction':\n        a = Fraction(a)\n        b = Fraction(b)\n    elif number_type == 'decimal':\n        a = float(a)\n        b = float(b)\n    if operation == 'add':\n        return a + b\n    elif operation == 'subtract':\n        return a - b\n    elif operation == 'multiply':\n        return a * b\n    elif operation == 'divide':\n        return a / b", "def perform_arithmetic_operation(x, y, operation='add'):\n    \"\"\"\n    Perform basic arithmetic operations on two integers or floats.\n    \n    Parameters:\n        x (int or float): First number in the operation.\n        y (int or float): Second number in the operation.\n        operation (str): Type of arithmetic operation to perform.\n                         Expected values are 'add', 'subtract', 'multiply', 'divide'.\n    \n    Returns:\n        int or float: The result of the arithmetic operation.\n    \n    Raises:\n        ValueError: If an unsupported operation type was provided.\n        ZeroDivisionError: If a division by zero is attempted.\n    \n    Examples:\n        >>> perform_arithmetic_operation(10, 5, 'add')\n        15\n        >>> perform_arithmetic_operation(10, 5, 'divide')\n        2.0\n        >>> perform_arithmetic_operation(10, 0, 'divide')\n        ZeroDivisionError: division by zero\n    \"\"\"\n    if operation == 'add':\n        return x + y\n    elif operation == 'subtract':\n        return x - y\n    elif operation == 'multiply':\n        return x * y\n    elif operation == 'divide':\n        if y == 0:\n            raise ZeroDivisionError(\"division by zero\")\n        return x / y\n    else:\n        raise ValueError(\"Unsupported operation\")", "def arithmetic_operation(a, b, operation='subtract'):\n    \"\"\"\n    Perform basic arithmetic operations on two numbers.\n    Parameters:\n    - a: float or int, first number\n    - b: float or int, second number\n    - operation: str, type of operation ('add', 'subtract', 'multiply', 'divide')\n    Returns:\n    - result of the arithmetic operation\n    Examples:\n    >>> arithmetic_operation(8, 2, 'subtract')\n    6\n    >>> arithmetic_operation(4, 5, 'multiply')\n    20\n    \"\"\"\n    if operation == 'add':\n        return a + b\n    elif operation == 'subtract':\n        return a - b\n    elif operation == 'multiply':\n        return a * b\n    elif operation == 'divide':\n        if b == 0:\n            raise ValueError(\"Division by zero is not allowed\")\n        return a / b\n    else:\n        raise ValueError(\"Unsupported operation provided.\")", "def perform_basic_operations(a, b, operation):\n    \"\"\"\n    Perform basic arithmetic operations: addition, subtraction, multiplication, or division.\n    \n    Parameters:\n    - a (int or float): The first operand.\n    - b (int or float): The second operand.\n    - operation (str): The type of operation ('add', 'subtract', 'multiply', 'divide').\n    \n    Returns:\n    - float: The result of the arithmetic operation.\n    \n    Example:\n    >>> perform_basic_operations(10, 5, 'add')\n    15\n    >>> perform_basic_operations(10, 5, 'divide')\n    2.0\n    \"\"\"\n    if operation == 'add':\n        return a + b\n    elif operation == 'subtract':\n        return a - b\n    elif operation == 'multiply':\n        return a * b\n    elif operation == 'divide':\n        if b == 0:\n            raise ValueError(\"Division by zero is not allowed.\")\n        return a / b\n    else:\n        raise ValueError(\"Invalid operation specified.\")", "def calculate_arithmetic_operation(x, y, operation='add'):\n    \"\"\"\n    Perform basic arithmetic operations between two numbers.\n    \n    Parameters:\n    x (float|int): First operand in the arithmetic operation.\n    y (float|int): Second operand in the arithmetic operation.\n    operation (str): Type of arithmetic operation ('add', 'subtract', 'multiply', 'divide').\n    \n    Returns:\n    float|int: Result of the arithmetic operation.\n    \n    Example:\n    >>> calculate_arithmetic_operation(10, 5, 'add')\n    15\n    >>> calculate_arithmetic_operation(10, 5, 'subtract')\n    5\n    >>> calculate_arithmetic_operation(10, 5, 'multiply')\n    50\n    >>> calculate_arithmetic_operation(10, 5, 'divide')\n    2.0\n    \"\"\"\n    if operation == 'add':\n        return x + y\n    elif operation == 'subtract':\n        return x - y\n    elif operation == 'multiply':\n        return x * y\n    elif operation == 'divide':\n        # Adding a condition to avoid division by zero\n        if y == 0:\n            raise ValueError('Division by zero is not allowed.')\n        return x / y\n    else:\n        raise ValueError('Unsupported operation. Choose from \\'add\\', \\'subtract\\', \\'multiply\\', \\'divide\\'.')", "def basic_arithmetic(a, b, operator):\n    \"\"\"\n    Perform basic arithmetic operations between two numbers.\n    Parameters:\n    - a : float\n        First operand in the operation.\n    - b : float\n        Second operand in the operation.\n    - operator : str\n        The operation to perform. Expected values: '+', '-', '*', '/', '%', '**'\n    Returns:\n    - float or int\n        The result of the arithmetic operation.\n    Examples:\n    >>> basic_arithmetic(5, 3, '+')\n    8\n    >>> basic_arithmetic(10, 2, '/')\n    5.0\n    >>> basic_arithmetic(4, 3, '**')\n    64\n    \"\"\"\n    if operator == '+':\n        return a + b\n    elif operator == '-':\n        return a - b\n    elif operator == '*':\n        return a * b\n    elif operator == '/':\n        if b != 0:\n            return a / b\n        else:\n            raise ValueError(\"Division by zero is undefined.\")\n    elif operator == '%':\n        return a % b\n    elif operator == '**':\n        return a ** b", "def arithmetic_operations(a, b, operation='add'):\n    \"\"\"Performs basic arithmetic operations between two numbers.\n    \n    Parameters:\n    a (float/int): The first operand.\n    b (float/int): The second operand.\n    operation (str): The operation to perform ('add', 'subtract', 'multiply', 'divide').\n    Returns:\n    float/int: The result of the arithmetic operation.\n    \n    Examples:\n    >>> arithmetic_operations(5, 3, 'add')\n    8\n    >>> arithmetic_operations(5, 3, 'subtract')\n    2\n    >>> arithmetic_operations(5, 3, 'multiply')\n    15\n    >>> arithmetic_operations(5, 3, 'divide')\n    1.6666666666666667\n    \"\"\"\n    if operation == 'add':\n        return a + b\n    elif operation == 'subtract':\n        return a - b\n    elif operation == 'multiply':\n        return a * b\n    elif operation == 'divide':\n        return a / b if b != 0 else None\n    else:\n        raise ValueError(\"Unsupported operation provided. Use 'add', 'subtract', 'multiply', or 'divide'.\")", "def basic_arithmetic_operation(a, b, operation=\"add\"):\n    \"\"\"\n    Perform basic arithmetic operations including addition, subtraction, multiplication, and division.\n    Parameters:\n    - a (int, float): The first operand.\n    - b (int, float): The second operand.\n    - operation (str): A string indicating the operation to perform. Options include \"add\", \"subtract\", \"multiply\", \"divide\".\n    Returns:\n    - int, float: The result of the arithmetic operation.\n    Examples:\n    >>> basic_arithmetic_operation(5, 3, \"add\")\n    8\n    >>> basic_arithmetic_operation(5, 3, \"subtract\")\n    2\n    >>> basic_arithmetic_operation(5, 3, \"multiply\")\n    15\n    >>> basic_arithmetic_operation(5, 3, \"divide\")\n    1.6666666666666667\n    \"\"\"\n    if operation == \"add\":\n        return a + b\n    elif operation == \"subtract\":\n        return a - b\n    elif operation == \"multiply\":\n        return a * b\n    elif operation == \"divide\":\n        if b == 0:\n            raise ValueError(\"Division by zero is not allowed.\")\n        return a / b\n    else:\n        raise ValueError(\"Unsupported operation specified.\")", "def basic_arithmetic_operations(a, b, operation):\n    \"\"\"\n    Perform basic arithmetic operations.\n    \n    Parameters\n    ----------\n    a : float or int\n        The first operand.\n    b : float or int\n        The second operand.\n    operation : str\n        The operation to perform. Can be 'add', 'subtract', 'multiply', or 'divide'.\n        \n    Returns\n    -------\n    result : float or int\n        The result of the arithmetic operation.\n    \n    Examples\n    --------\n    >>> basic_arithmetic_operations(10, 5, 'add')\n    15\n    \n    >>> basic_arithmetic_operations(10, 5, 'subtract')\n    5\n    \n    >>> basic_arithmetic_operations(10, 5, 'multiply')\n    50\n    \n    >>> basic_arithmetic_operations(10, 5, 'divide')\n    2.0\n    \"\"\"\n    if operation == 'add':\n        return a + b\n    elif operation == 'subtract':\n        return a - b\n    elif operation == 'multiply':\n        return a * b\n    elif operation == 'divide':\n        if b != 0:\n            return a / b\n        else:\n            raise ValueError(\"Cannot divide by zero.\")\n    else:\n        raise ValueError(\"Invalid operation specified.\")", "def basic_arithmetic(a, b, operation):\n    \"\"\"\n    Perform basic arithmetic operations: addition, subtraction, multiplication, and division.\n    \n    Parameters:\n    - a (str): The first operand, given as a string to handle both fraction and decimal inputs.\n    - b (str): The second operand, as a string for the same reasons as a.\n    - operation (str): The operation type, one of ['add', 'subtract', 'multiply', 'divide'].\n    \n    Returns:\n    - Decimal or Fraction: Result of the operation, in decimal or fraction form depending on input.\n    \n    Examples:\n    - basic_arithmetic('1/3', '1/4', 'add') returns Fraction(7, 12)\n    - basic_arithmetic('0.1', '0.2', 'add') returns Decimal('0.3')\n    \"\"\"\n    # Try to manage fractions and decimals separately\n    if '/' in a or '/' in b:\n        a = Fraction(a)\n        b = Fraction(b)\n    else:\n        getcontext().prec = 28  # Set precision for decimal operations\n        a = Decimal(a)\n        b =Decimal(b)\n    if operation == 'add':\n        return a + b\n    elif operation == 'subtract':\n        return a - b\n    elif operation == 'multiply':\n        return a * b\n    elif operation == 'divide':\n        # Check for division by zero possibility\n        if b == 0:\n            raise ValueError(\"Cannot divide by zero\")\n        return a / b\n    else:\n        raise ValueError(\"Unknown operation\")", "def basic_arithmetic(a, b, operation='add'):\n    \"\"\"\n    Perform basic arithmetic operations: addition, subtraction, multiplication, division.\n    Parameters:\n    - a (float|int): The first operand.\n    - b (float|int): The second operand.\n    - operation (str): Type of operation to perform, expected 'add', 'subtract', 'multiply', 'divide'.\n    Returns:\n    - result (float|int): The result of the arithmetic operation.\n    \n    Examples:\n    >>> basic_arithmetic(5, 3, 'add')\n    8\n    >>> basic_arithmetic(5, 3, 'subtract')\n    2\n    >>> basic_arithmetic(5, 3, 'multiply')\n    15\n    >>> basic_arithmetic(5, 3, 'divide')\n    1.6666666666666667\n    \"\"\"\n    if operation == 'add':\n        return a + b\n    elif operation == 'subtract':\n        return a - b\n    elif operation == 'multiply':\n        return a * b\n    elif operation == 'divide':\n        if b != 0:\n            return a / b\n        else:\n            raise ValueError(\"The divisor cannot be zero.\")\n    else:\n        raise ValueError(\"Invalid operation specified.\")"], ["def weighted_mean(values, weights):\n    \"\"\"\n    Computes the weighted mean for a list of values using corresponding weights.\n    Parameters:\n    values (list of float|int): Values to average.\n    weights (list of float|int): Weights corresponding to the values.\n    Returns:\n    float: The weighted mean of the values.\n    Raises:\n    ValueError: If 'values' and 'weights' lists are not of the same length or are empty.\n    \"\"\"\n    if not values or not weights:\n        raise ValueError(\"Values and weights cannot be empty.\")\n    if len(values) != len(weights):\n        raise ValueError(\"The length of values must be equal to the length of weights.\")\n    weighted_sum = sum(v * w for v, w in zip(values, weights))\n    sum_weights = sum(weights)\n    return weighted_sum / sum_weights if sum_weights else float('nan')  # Handling zero division internally."], ["def convert_units(amount, conversion_factor):\n    \"\"\"\n    Convert an amount from one unit to another using a conversion factor.\n    Parameters:\n        amount (float): The amount in the original unit.\n        conversion_factor (float): The factor used to convert from the original to the new unit.\n    Returns:\n        float: The amount in the new unit.\n    Examples:\n        >>> convert_units(100, 0.3048)  # Convert 100 feet to meters\n        30.48\n        >>> convert_units(200, 2.54)  # Convert 200 inches to centimeters\n        508.0\n    \"\"\"\n    return multiply(amount, conversion_factor)", "def convert_units(value, conversion_factor):\n    \"\"\"\n    Converts a quantity from one unit to another using a conversion factor.\n    Parameters:\n        value (float): The quantity in the original units.\n        conversion_factor (float): The factor by which to multiply `value` to convert to the desired units.\n    Returns:\n        float: The quantity in the new units.\n    \"\"\"\n    return value * conversion_factor"], ["def subtract_numbers(a, b):\n    \"\"\"\n    Subtract the second number from the first.\n    Parameters:\n    a (float|int): The number from which b is to be subtracted.\n    b (float|int): The number to subtract from a.\n    Returns:\n    float|int: The result of the subtraction, a - b.\n    Examples:\n    >>> subtract_numbers(10, 5)\n    5\n    >>> subtract_numbers(5, 10)\n    -5\n    \"\"\"\n    return a - b", "def subtract(a, b):\n    \"\"\"\n    Returns the difference between two numbers, subtracting the second from the first.\n    Parameters:\n        a (float or int): Number from which to subtract.\n        b (float or int): Number to subtract.\n    Returns:\n        float or int: The difference of the numbers.\n    Examples:\n        >>> subtract(20, 5)\n        15\n        >>> subtract(10.5, 0.5)\n        10.0\n    \"\"\"\n    return a - b", "def subtract(a, b):\n    \"\"\"\n    Subtracts the second number from the first.\n    Parameters:\n        a (float): The number from which b is subtracted.\n        b (float): The number to subtract from a.\n    Returns:\n        float: The difference of a and b.\n    \"\"\"\n    return a - b", "def subtract_numbers(a, b):\n    \"\"\"\n    Subtract two numbers, either integers or floats.\n    \n    Parameters:\n    - a (int or float): Number from which b will be subtracted.\n    - b (int or float): Number to be subtracted from a.\n    \n    Returns:\n    - float: The result of subtraction.\n    \n    Examples:\n    >>> subtract_numbers(10, 4)\n    6\n    >>> subtract_numbers(5.5, 2.1)\n    3.4\n    \"\"\"\n    return a - b", "def subtract(a, b):\n    \"\"\"\n    Subtracts the second number from the first and returns the result.\n    Parameters:\n    a (float|int): First operand\n    b (float|int): Second operand\n    Returns:\n    float|int: The result of the subtraction a - b.\n    \"\"\"\n    return a - b"], ["def calculate_distance(rate, time):\n    \"\"\"\n    Calculates distance using the formula d = r * t.\n    Parameters:\n        rate (float): The rate (e.g., speed).\n        time (float): The time over which the rate is applied.\n    Returns:\n        float: The distance traveled.\n    \"\"\"\n    return multiply(rate, time)"], ["def simplify_expression(expression):\n    \"\"\"\n    Simplifies the given mathematical expression and rearranges terms where possible.\n    \n    Parameters:\n    - expression (str): The arithmetic expression as a string.\n    \n    Returns:\n    - simplified_expr (sympy object): The simplified expression.\n    \n    Example:\n    >>> simplify_expression(\"2*x + 3*x\")\n    5*x\n    >>> simplify_expression(\"x*x + 2*x*x + 3*x + x\")\n    3*x**2 + 4*x\n    \"\"\"\n    # Simplify an arbitrary mathematical expression\n    simplified_expr = sp.simplify(expression)\n    return simplified_expr"], ["def proportional_scaling(value, scale_factor):\n    \"\"\"\n    Scale a value by a given factor.\n    \n    Parameters\n    ----------\n    value : float or int\n        The original value to be scaled.\n    scale_factor : float or int\n        The factor by which the value will be scaled.\n    \n    Returns\n    -------\n    float or int\n        The scaled value.\n    \n    Examples\n    --------\n    >>> proportional_scaling(10, 2)\n    20\n    \n    >>> proportional_scaling(10, 0.5)\n    5.0\n    \"\"\"\n    return value * scale_factor"], ["def sequence_expression_evaluation(sequence, expression):\n    \"\"\"\n    Evaluate a numerical expression on each term of the sequence.\n    Parameters:\n    - sequence (list of int or float): A list containing the numerical sequence.\n    - expression (callable): A function that takes a single argument and returns a number.\n    Returns:\n    - list of int or float: The sequence after applying the expression to each term.\n    Examples:\n    >>> sequence_expression_evaluation([1, 2, 3, 4], lambda x: x**2 - x + 1)\n    [1, 3, 7, 13]\n    \"\"\"\n    return [expression(x) for x in sequence]"], ["def sum_of_digits(number):\n    \"\"\"\n    Calculates the sum of all digits in an integer.\n    Parameters:\n    - number (int): The number whose digits are to be summed.\n    Returns:\n    - int: The sum of the digits of the number.\n    Example:\n    >>> sum_of_digits(1234)\n    10\n    \"\"\"\n    return sum(int(digit) for digit in str(abs(number)))", "def sum_of_digits(number):\n    \"\"\"Calculates the sum of the digits of an integer.\n    \n    Parameters:\n    number (int): The number whose digits will be summed.\n    \n    Returns:\n    int: The sum of the digits of the number.\n    \n    Examples:\n    >>> sum_of_digits(123)\n    6\n    >>> sum_of_digits(10402)\n    7\n    \"\"\"\n    return sum(int(digit) for digit in str(abs(number)))"], ["def calculate_simple_interest(principal, rate, time):\n    \"\"\"\n    Calculate simple interest.\n    Parameters:\n    - principal (float|int): The initial amount of money.\n    - rate (float): The interest rate (expressed as a fraction of 1 for easiness, i.e., 10% as 0.1).\n    - time (float|int): The time period for which the interest is calculated.\n    Returns:\n    - amount (float): The total amount accumulated after the interest.\n    Examples:\n    >>> calculate_simple_interest(1000, 0.05, 3)\n    1150.0\n    \"\"\"\n    return principal * (1 + rate * time)"], ["def calculate_exponentiation_and_roots(base, exponent):\n    \"\"\"\n    Perform exponentiation and calculate roots as special cases (e.g., square root or cube root). \n    Parameters:\n    - base : float\n        Base of the exponentiation.\n    - exponent : float\n        Exponent for the operation. If the exponent is fractional, it calculates the root.\n    Returns:\n    - float\n        Result of the exponentiation or root calculation.\n    Examples:\n    >>> calculate_exponentiation_and_roots(2, 3)\n    8\n    >>> calculate_exponentiation_and_roots(9, 0.5)\n    3.0\n    \"\"\"\n    \n    return base ** exponent"], ["def prime_factorization(n):\n    \"\"\"\n    Calculate the prime factors of a given integer.\n    Parameters:\n    - n : int\n        The number to factorize.\n    Returns:\n    - list\n        A list of the prime factors of the number.\n    Examples:\n    >>> prime_factorization(60)\n    [2, 2, 3, 5]\n    >>> prime_factorization(100)\n    [2, 2, 5, 5]\n    \"\"\"\n    import math\n    factors = []\n    while n % 2 == 0:\n        factors.append(2)\n        n = n // 2\n        \n    for i in range(3, int(math.sqrt(n)) + 1, 2):\n        while (n % i == 0):\n            factors.append(i)\n            n = n // i\n            \n    if n > 2:\n        factors.append(n)\n        \n    return factors"], ["def summation(numbers, condition=lambda x: True):\n    \"\"\"\n    Calculate the sum of a series of numbers that meet a specified condition.\n    Parameters:\n    - numbers (list): A list of numbers (integers or floats).\n    - condition (function): A function that specifies a condition each number must meet to be included in the sum.\n    Returns:\n    - total_sum (float|int): The sum of numbers meeting the condition.\n    Examples:\n    >>> summation([1, 2, 3, 4], condition=lambda x: x % 2 == 0)\n    6  # Because 2 + 4 = 6\n    >>> summation([1, 2, 3, 4, 5])\n    15  # Sum of all given numbers\n    \"\"\"\n    return sum(filter(condition, numbers))"], ["def fraction_to_percentage(fraction):\n    \"\"\"Convert a simplified fraction to a percentage.\n    Parameters:\n    - fraction (Fraction) : The fraction to convert.\n    Returns:\n    float : The equivalent percentage.\n    \"\"\"\n    return float(fraction) * 100", "def percentage_to_fraction(percentage):\n    \"\"\"Convert a percentage to a simplified fraction.\n    Parameters:\n    - percentage (float) : The percentage to convert.\n    Returns:\n    Fraction : The equivalent simplified fraction.\n    \"\"\"\n    frac = Fraction(percentage, 100)\n    return simplify_fraction(frac.numerator, frac.denominator)", "def fraction_to_percentage(frac):\n    \"\"\"\n    This function converts a fraction to a percentage.\n    Parameters:\n    frac (fractions.Fraction): The fraction to be converted.\n    Returns:\n    float: The percentage equivalent of the input fraction.\n    Examples:\n    >>> fraction_to_percentage(fractions.Fraction(1, 2))\n    50.0\n    >>> fraction_to_percentage(fractions.Fraction(3, 4))\n    75.0\n    \"\"\"\n    return float(frac) * 100"], ["def round_to_nearest(number, precision):\n    \"\"\"Round a number to a specified precision.\n    Parameters:\n        number (float): The number to round.\n        precision (int): The number of decimal places to round to.\n    Returns:\n        float: The rounded number.\n    Examples:\n        >>> round_to_nearest(3.14159, 2)\n        3.14\n        >>> round_to_nearest(300.987654, -2)\n        300.0\n    \"\"\"\n    return round(number, precision)"], ["def multiply(*args):\n    \"\"\"\n    Multiply a series of numbers together.\n    Parameters:\n        *args (float or int): A set of numbers to be multiplied.\n    Returns:\n        float: The product of all the numbers.\n    Examples:\n        >>> multiply(2, 3)\n        6\n        >>> multiply(3, 3, 3)\n        27\n    \"\"\"\n    from functools import reduce\n    return reduce(lambda x, y: x * y, args)", "def multiply(*args):\n    \"\"\"\n    Returns the product of the provided arguments.\n    Parameters:\n    args (float or int): A sequence of numbers that will be multiplied together.\n    Returns:\n    float or int: Product of all the numbers provided as arguments.\n    Examples:\n    >>> multiply(2, 3)\n    6\n    >>> multiply(2, 3, 4)\n    24\n    \"\"\"\n    from functools import reduce\n    from operator import mul\n    return reduce(mul, args, 1)", "def multiply_numbers(*args):\n    \"\"\"\n    Multiply a series of numbers provided as arguments.\n    Parameters:\n    *args (float|int): A series of numbers to be multiplied.\n    Returns:\n    float|int: The product of the provided numbers.\n    Examples:\n    >>> multiply_numbers(1, 2, 3)\n    6\n    >>> multiply_numbers(1.5, 2, 3)\n    9.0\n    \"\"\"\n    return reduce(mul, args, 1)", "def multiply_numbers(*args):\n    \"\"\"Multiply a sequence of numbers together.\n    Parameters:\n        args (float or int): A variable number of arguments to be multiplied.\n    \n    Returns:\n        float or int: The product of all the arguments.\n    Examples:\n        >>> multiply_numbers(4, 5)\n        20\n        >>> multiply_numbers(7, 0, 2)\n        0\n    \"\"\"\n    product = 1\n    for number in args:\n        product *= number\n    return product"], ["def exponentiate(base, exponent):\n    \"\"\"\n    Returns the base raised to the power of the exponent.\n    Parameters:\n    base (float or int): The number that is the base to be raised.\n    exponent (float or int): The number that is the exponent.\n    Returns:\n    float: The result of raising base to the power of exponent.\n    Examples:\n    >>> exponentiate(2, 3)\n    8\n    >>> exponentiate(5, 0.5)\n    2.23606797749979\n    \"\"\"\n    return base ** exponent", "def exponentiate(base, exponent):\n    \"\"\"\n    Raise a given number to the power of the exponent.\n    Parameters:\n    base (float|int): The base number.\n    exponent (float|int): The exponent to which the base is raised.\n    Returns:\n    float|int: The result of the power operation.\n    Examples:\n    >>> exponentiate(2, 3)\n    8\n    >>> exponentiate(5, 2)\n    25\n    \"\"\"\n    return pow(base, exponent)", "def power_number(base, exponent):\n    \"\"\"Raise a number to the power of exponent.\n    Parameters:\n        base (float or int): The base number.\n        exponent (float or int) : The exponent power.\n    Returns:\n        float or int: The result of raising the base to the power of exponent.\n    Examples:\n        >>> power_number(2, 3)\n        8\n        >>> power_number(5, 2)\n        25\n    \"\"\"\n    return np.power(base, exponent)"], ["def convert_dollars_to_cents(dollars):\n    \"\"\"\n    Converts an amount in dollars to cents.\n    Parameters:\n        dollars (float): Amount in dollars.\n    Returns:\n        int: Amount in cents.\n    Examples:\n        >>> convert_dollars_to_cents(10.75)\n        1075\n        >>> convert_dollars_to_cents(0.99)\n        99\n    \"\"\"\n    return int(multiply(dollars, 100))"], ["def add(a, b):\n    \"\"\"\n    Returns the sum of two numbers.\n    Parameters:\n        a (float or int): First number.\n        b (float or int): Second number.\n    Returns:\n        float or int: The sum of the numbers.\n    Examples:\n        >>> add(10, 15)\n        25\n        >>> add(3.5, 2.5)\n        6.0\n    \"\"\"\n    return a + b", "def add(a, b):\n    \"\"\"\n    Adds two numbers.\n    Parameters:\n        a (float): The first number.\n        b (float): The second number.\n    Returns:\n        float: The sum of the two input numbers.\n    \"\"\"\n    return a + b", "def add_numbers(a, b):\n    \"\"\"\n    Add two numbers, either integers or floats.\n    \n    Parameters:\n    - a (int or float): First operand.\n    - b (int or float): Second operand.\n    \n    Returns:\n    - float: The sum of the inputs.\n    \n    Examples:\n    >>> add_numbers(3, 4)\n    7\n    >>> add_numbers(3.5, 2.3)\n    5.8\n    \"\"\"\n    return a + b", "def add(a, b):\n    \"\"\"\n    Adds two numbers and returns the result.\n    Parameters:\n    a (float|int): First operand\n    b (float|int): Second operand\n    Returns:\n    float|int: The sum of the two numbers.\n    \"\"\"\n    return a + b"], ["def square_root(number):\n    \"\"\"\n    Compute the square root of a number using math library.\n    Parameters:\n    number (float|int): The number for which to find the square root.\n    Returns:\n    float: The square root of the number.\n    Examples:\n    >>> square_root(16)\n    4.0\n    >>> square_root(25)\n    5.0\n    \"\"\"\n    if number < 0:\n        raise ValueError(\"Cannot compute the square root of a negative number.\")\n    return math.sqrt(number)"], ["def subtract_integers(a, b):\n    \"\"\"\n    Subtracts integer b from integer a.\n    Parameters:\n    - a (int): The number to subtract from.\n    - b (int): The number to subtract.\n    Returns:\n    - int: The result of the subtraction a - b.\n    Example:\n    >>> subtract_integers(5, 3)\n    2\n    \"\"\"\n    return a - b"], ["def evaluate_expression(expression):\n    \"\"\"\n    Evaluates a mathematical expression, potentially involving algebraic operations.\n    \n    Parameters:\n    expression (str): A string representing the mathematical expression to evaluate.\n    \n    Returns:\n    float|int|sympy.Expr: Result of evaluating the expression.\n    \n    Example:\n    >>> evaluate_expression(\"3*x + 2\")\n    3*x + 2\n    >>> evaluate_expression(\"3*5 + 2\")\n    17\n    \"\"\"\n    expr = sp.sympify(expression)\n    return expr"], ["def operation_with_pi(numer, denom, operation):\n    \"\"\"Perform arithmetic operations with  involved.\n    Parameters:\n    - numer (float) : The numerator which may include .\n    - denom (float) : The denominator which may include .\n    - operation (str) : The operation to perform.\n    Returns:\n    float : The result of arithmetic operation involving .\n    \"\"\"\n    if operation == 'multiply':\n        return np.pi * (numer/denom)\n    elif operation == 'divide':\n        return (numer/np.pi) / (denom/np.pi) if denom != 0 else 'Error: Division by zero'\n    else:\n        return 'Error: Invalid operation'"], ["def simplify_fraction(frac):\n    \"\"\"\n    Simplifies a given fraction to its lowest terms.\n    \n    Parameters:\n        frac (Fraction or str): The fraction to simplify.\n    \n    Returns:\n        Fraction: The fraction in its simplest form.\n    \n    Examples:\n        >>> simplify_fraction(Fraction(10, 20))\n        Fraction(1, 2)\n        >>> simplify_fraction('8/24')\n        Fraction(1, 3)\n    \"\"\"\n    if isinstance(frac, str):\n        frac = Fraction(frac)\n    return frac", "def simplify_fraction(frac):\n    \"\"\"\n    This function simplifies a fraction to its simplest form.\n    Parameters:\n    frac (fractions.Fraction): The fraction to be simplified.\n    Returns:\n    fractions.Fraction: The simplified version of the input fraction.\n    Examples:\n    >>> simplify_fraction(fractions.Fraction(8, 24))\n    Fraction(1, 3)\n    >>> simplify_fraction(fractions.Fraction(18, 9))\n    Fraction(2, 1)\n    \"\"\"\n    return frac.limit_denominator()"], ["def subtract(initial, *args):\n    \"\"\"\n    Subtract a list of numbers from an initial value.\n    Parameters:\n        initial (float or int): The initial value from which others will be subtracted.\n        *args (float or int): A set of numbers to be subtracted from the initial value.\n    Returns:\n        float: The result after subtraction.\n    Examples:\n        >>> subtract(10, 1, 2)\n        7\n        >>> subtract(20.5, 0.5)\n        20.0\n    \"\"\"\n    return initial - sum(args)"], ["def product_of_numbers(numbers):\n    \"\"\"\n    Computes the product of a list of numbers.\n    Parameters:\n    - numbers (list of number): The list of numbers to multiply.\n    Returns:\n    - number: The result of multiplying all the numbers together.\n    Example:\n    >>> product_of_numbers([1, 2, 3, 4])\n    24\n    \"\"\"\n    from functools import reduce\n    return reduce(lambda x, y: x * y, numbers, 1)"], ["def double_and_halve(x, operation='double'):\n    \"\"\"Double or halve a number based on the operation.\n    \n    Parameters:\n        x (float): The number to alter.\n        operation (str): 'double' to multiply by 2, 'halve' to divide by 2.\n        \n    Returns:\n        float: The doubled or halved value.\n    \n    Examples:\n        >>> double_and_halve(4, 'halve')\n        2.0\n        >>> double_and_halve(4)\n        8.0\n    \"\"\"\n    if operation == 'double':\n        return basic_arithmetic('multiply', x, 2)\n    elif operation == 'halve':\n        return basic_arithmetic('divide', x, 2)\n    else:\n        raise ValueError(\"Invalid operation. Use 'double' or 'halve'.\")"], ["def factorial(n):\n    \"\"\"Calculate the factorial of a non-negative integer n.\n    Parameters"], ["def apply_distributive_property(a, b, c):\n    \"\"\"\n    Apply the distributive property of multiplication over addition: a(b + c) = ab + ac.\n    \n    Parameters:\n        a (int or float): The multiplier.\n        b (int or float): The first term to be multiplied and added.\n        c (int or float): The second term to be multiplied and added.\n    \n    Returns:\n        tuple: A tuple of the individual products and their sum: (ab, ac, ab + ac).\n    \n    Examples:\n        >>> apply_distributive_property(2, 3, 4)\n        (6, 8, 14)\n    \"\"\"\n    product1 = a * b\n    product2 = a * c\n    return (product1, product2, product1 + product2)"], ["def area_rectangle(length, width):\n    \"\"\"\n    Calculates the area of a rectangle.\n    Parameters:\n    length (float or int): The length of the rectangle.\n    width (float or int): The width of the rectangle.\n    Returns:\n    float: The area of the rectangle.\n    Examples:\n    >>> area_rectangle(5, 3)\n    15\n    \"\"\"\n    return multiply(length, width)"], ["def conditional_sum(data, mod=None):\n    \"\"\"\n    Sums elements in a list with an optional modular arithmetic adjustment.\n    \n    Parameters:\n    - data (list of int or float): List of numbers to be summed.\n    - mod (int, optional): If provided, the summation is taken modulo this value.\n    \n    Returns:\n    - int or float: Sum of the list, or sum modulo if mod is provided.\n    \n    Examples:\n    - conditional_sum([1, 2, 3, 4]) should return 10.\n    - conditional_sum([1, 2, 3, 4], mod=3) should return 1 (i.e., 10 % 3).\n    \"\"\"\n    total = sum(data)\n    if mod is not None:\n        total %= mod\n    return total"], ["def basic_arithmetic(op, x, y):\n    import operator\n    operations = {\n        'add': operator.add,\n        'subtract': operator.sub,\n        'multiply': operator.mul,\n        'divide': operator.truediv,\n        'power': operator.pow\n    }\n    \n    if op not in operations:\n        raise ValueError(f\"Unsupported operation '{op}'. Choose from {list(operations.keys())}\")\n    \n    if op == 'divide' and y == 0:\n        raise ValueError(\"Cannot divide by zero\")\n    \n    return operations[op](x, y)"], ["def sequence_differences(sequence):\n    \"\"\"\n    Calculate the differences between consecutive terms in a sequence.\n    Parameters:\n    - sequence (list of int or float): A list containing the numerical sequence.\n    Returns:\n    - list of int or float: List containing the differences between consecutive terms.\n    Examples:\n    >>> sequence_differences([1, 2, 4, 7])\n    [1, 2, 3]\n    \"\"\"\n    return [sequence[i+1] - sequence[i] for i in range(len(sequence) - 1)]"], ["def sum_arithmetic_series(first_term, last_term, common_difference):\n    \"\"\"\n    Calculate the sum of an arithmetic series.\n    \n    Parameters:\n    - first_term (int or float): The first term of the arithmetic series.\n    - last_term (int or float): The last term of the arithmetic series.\n    - common_difference (int or float): The common difference between consecutive terms of the series.\n    \n    Returns:\n    - float: The sum of the arithmetic series.\n    \n    Example:\n    >>> sum_arithmetic_series(1, 10, 1)\n    55.0\n    \"\"\"\n    # Calculate the number of terms in the series\n    n = int((last_term - first_term) / common_difference + 1)\n    \n    # Sum of an arithmetic series formula: n/2 * (first_term + last_term)\n    return n * (first_onauthterm + last_term) / 2"], ["def convert_time_hours_to_minutes(hours):\n    \"\"\"\n    Converts time from hours to minutes.\n    Parameters:\n        hours (float or int): Time in hours.\n    Returns:\n        float: Time in minutes.\n    Examples:\n        >>> convert_time_hours_to_minutes(2)\n        120\n        >>> convert_time_hours_to_minutes(1.5)\n        90\n    \"\"\"\n    return hours * 60", "def convert_time_minutes_to_hours(minutes):\n    \"\"\"\n    Converts time from minutes to hours.\n    Parameters:\n        minutes (float or int): Time in minutes.\n    Returns:\n        float: Time in hours.\n    Examples:\n        >>> convert_time_minutes_to_hours(120)\n        2.0\n        >>> convert_time_minutes_to_hours(90)\n        1.5\n    \"\"\"\n    return minutes / 60"], ["def get_factors(n):\n    \"\"\"\n    Get all factors of a given number.\n    \n    Parameters\n    ----------\n    n : int\n        The number to find factors for.\n    \n    Returns\n    -------\n    list\n        A list of factors of n.\n    \n    Examples\n    --------\n    >>> get_factors(12)\n    [1, 2, 3, 4, 6, 12]\n    \n    >>> get_factors(7)\n    [1, 7]\n    \"\"\"\n    if n <= 0:\n        raise ValueError(\"Number must be positive.\")\n    factors = []\n    for i in range(1, int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            factors.append(i)\n            if i != n // i:\n                factors.append(n // i)\n    factors.sort()\n    return factors"], ["def advanced_arithmetic_sequences(start, end, operation=\"subtract\", step=1, function=None):\n    \"\"\"\n    Apply arithmetic operations over a range of numbers with an optional mathematical function (like power or factorial).\n    Parameters:\n    - start (int): Starting number.\n    - end (int): Ending number.\n    - operation (str): Type of operation to apply on sequence ('add', 'subtract'). Default is 'subtract'.\n    - step (int): Step count between sequence numbers. Default is 1 (sequential).\n    - function (callable): A function to apply to each number before performing the arithmetic operation.\n    Returns:\n    - total (float|int): The accumulated result after applying the arithmetic operation across the sequence.\n    Examples:\n    >>> advanced_arithmetic_sequences(1, 5, \"add\")\n    15\n    >>> advanced_arithmetic_sequences(1, 3, \"subtract\")\n    -5\n    >>> import math\n    >>> advanced_arithmetic_sequences(1, 3, \"add\", function=math.sqrt)\n    1 + sqrt(2) + sqrt(3)\n    \"\"\"\n    if not isinstance(start, int) or not isinstance(end, int):\n        raise ValueError(\"Start and end values must be integers.\")\n    if operation not in [\"add\", \"subtract\"]:\n        raise ValueError(\"Invalid operation. Use 'add' or 'subtract'.\")\n    if function:\n        numbers = [function(x) for x in range(start, end + 1, step)]\n    else:\n        numbers = list(range(start, end + 1, step))\n    if operation == \"add\":\n        return sum(numbers)\n    elif operation == \"subtract\":\n        return sum(-num if i != 0 else num for i, num in enumerate(numbers))"], ["def subtract(minuend, subtrahend):\n    \"\"\"\n    Returns the difference between the minuend and the subtrahend.\n    Parameters:\n    minuend (float or int): The number from which another number (subtrahend) is to be subtracted.\n    subtrahend (float or int): The number that is to be subtracted from the minuend.\n    Returns:\n    float or int: The result of subtracting subtrahend from minuend.\n    Examples:\n    >>> subtract(10, 5)\n    5\n    >>> subtract(7.5, 2.2)\n    5.3\n    \"\"\"\n    return minuend - subtrahend"], ["def calculate_total_cost(unit_cost, quantity):\n    \"\"\"\n    Calculates the total cost given the unit cost and quantity.\n    Parameters:\n        unit_cost (float): The cost per unit item.\n        quantity (int): The number of units.\n    Returns:\n        float: Total cost.\n    Examples:\n        >>> calculate_total_cost(5.0, 3)\n        15.0\n        >>> calculate_total_cost(12.75, 4)\n        51.0\n    \"\"\"\n    return multiply(unit_cost, quantity)"], ["def fraction_mixed_number_conversion(mixed_num, improper=True):\n    \"\"\"Convert between mixed numbers and improper fractions.\n    Parameters:\n    - mixed_num (tuple) : A tuple representing a mixed number (whole, numerator, denominator).\n    - improper (bool) : A flag to indicate conversion to improper fraction if True or to mixed number if False.\n    Returns:\n    Fraction or tuple : The converted improper fraction or mixed number.\n    \"\"\"\n    whole, numer, denom = mixed_num\n    if improper:\n        # Convert mixed number to improper fraction\n        return simplify_fraction((whole * denom) + numer, denom)\n    else:\n        # Convert improper fraction to mixed number\n        new_whole = numer // denom\n        new_numer = numer % denom\n        return (new_whole, new_numer, denom)"], ["def negate_number(x):\n    \"\"\"\n    Negate the provided number.\n    Parameters:\n    x (float|int): The number to negate.\n    Returns:\n    float|int: The negation of the number.\n    Examples:\n    >>> negate_number(5)\n    -5\n    >>> negate_number(-10)\n    10\n    \"\"\"\n    return -x"], ["def conditional_arithmetic(values, condition=None, operation='sum'):\n    \"\"\"\n    Perform arithmetic operations based on a specified condition.\n    \n    Parameters:\n    - values (dict or list): A mapping or list of values where conditions are to be checked.\n    - condition (callable, optional): A callable to apply on items to check a condition. If None, all are included.\n    - operation (str): Type of arithmetic operation - 'sum', 'product', etc.\n    \n    Returns:\n    - result (int, float): Result of the arithmetic operation applied conditionally.\n    \n    Example:\n    >>> conditional_arithmetic([1, 2, 3, 4, 5], condition=lambda x: x > 3)\n    9\n    >>> conditional_arithmetic([1, 2, 3, 4, 5], condition=lambda x: x % 2 == 0)\n    6\n    >>> conditional_arithmetic([1, 2, 3, 4], condition=lambda x: x < 3, operation='product')\n    2\n    \"\"\"\n    filtered_values = values\n    if condition:\n        filtered_values = filter(condition, values)\n    \n    return arithmetic_operations(list(filtered_values), operation=operation)"], ["def calculate_compound_cost(unit_count, unit_price, additional_fees=0):\n    \"\"\"\n    Calculates total cost for items, including additional fees.\n    Parameters:\n        unit_count (float): The quantity of units.\n        unit_price (float): Cost per unit.\n        additional_fees (float): Any additional fees that need to be added to the total.\n    Returns:\n        float: The total cost calculated.\n    \"\"\"\n    basic_cost = multiply(unit_count, unit_price)\n    return add(basic_data, additional_fees)"], ["def find_multiples_in_range(base, start, end):\n    \"\"\"Find all multiples of a base number within a specified range [start, end].\n    \n    Parameters:\n        base (int): The base number to find multiples of.\n        start (int): The starting range (inclusive).\n        end (int): The ending range (inclusive).\n        \n    Returns:\n        list: List of multiples of base within the range.\n    \n    Examples:\n        >>> find_multiples_in_range(3, 1, 10)\n        [3, 6, 9]\n    \"\"\"\n    return [i for i in range(start, end + 1) if i % base == 0]"], ["def square(number):\n    \"\"\"\n    Compute the square of a number.\n    Parameters:\n    number (float|int): The number to square.\n    Returns:\n    float|int: The square of the number.\n    Examples:\n    >>> square(5)\n    25\n    >>> square(-4)\n    16\n    \"\"\"\n    return number**2"], ["def area_circle(radius):\n    \"\"\"\n    Calculates the area of a circle.\n    Parameters:\n    radius (float or int): The radius of the circle.\n    Returns:\n    float: The area of the circle.\n    Examples:\n    >>> area_circle(2)\n    12.566370614359172\n    \"\"\"\n    import math\n    return multiply(math.pi, exponentiate(radius, 2))"], ["def sum_with_modulo(numbers, modulo):\n    \"\"\"\n    Sum a list of numbers applying modulo operation to the result.\n    Parameters:\n    - numbers (list of numbers): The list of numbers to sum.\n    - modulo (int): The modulo value.\n    Returns:\n    - int: The result of (sum(numbers) % modulo).\n    Example:\n    >>> sum_with_modulo([1, 2, 3, 4], 3)\n    1\n    \"\"\"\n    return sum(numbers) % modulo"], ["def percentage_of(total, percentage):\n    \"\"\"\n    Calculate a given percentage of a total.\n    \n    Parameters\n    ----------\n    total : float or int\n        The total value.\n    percentage : float\n        The percentage to calculate (as a percentage, e.g., 50 for 50%).\n    \n    Returns\n    -------\n    float\n        The calculated percentage of the total.\n    \n    Examples\n    --------\n    >>> percentage_of(200, 25)\n    50.0\n    \n    >>> percentage_of(150, 10)\n    15.0\n    \"\"\"\n    return (percentage / 100.0) * total"], ["def calculate_expression(expression):\n    \"\"\"\n    Computes the arithmetic value of a string expression respecting the order of operations.\n    \n    Parameters:\n    - expression (str): The arithmetic expression in standard string format.\n    \n    Returns:\n    - result (sympy object): The computed value from the expression.\n    \n    Example:\n    >>> calculate_expression(\"2 + 3 * (4 - 1)\")\n    11\n    >>> calculate_expression(\"3 + 4 * 2 / (1 - 5) ** 2\")\n    3.5\n    \"\"\"\n    # Parse and compute the expression using sympy\n    result = sp.sympify(expression).evalf()\n    return result"], ["def gcd(a, b):\n    \"\"\"\n    Compute the greatest common divisor of two numbers using Euclid's algorithm.\n    Parameters:\n    a (int): The first number.\n    b (int): The second number.\n    Returns:\n    int: The greatest common divisor of a and b.\n    Examples:\n    >>> gcd(54, 24)\n    6\n    >>> gcd(11, 5)\n    1\n    \"\"\"\n    while b != 0:\n        a, b = b, a % b\n    return a"], ["def sum_of_numbers(numbers):\n    \"\"\"\n    Sum a list of numbers.\n    Parameters:\n    - numbers (list of numbers): The list of numbers to sum up.\n    Returns:\n    - number: The sum of the numbers in the list.\n    Example:\n    >>> sum_of_numbers([1, 2, 3, 4])\n    10\n    \"\"\"\n    return sum(numbers)", "def sum_numbers(numbers):\n    \"\"\"\n    Sums a list of numbers.\n    \n    Parameters:\n    numbers (list of float|int): A list containing numbers to sum.\n    \n    Returns:\n    float|int: Sum of all the numbers in the list.\n    \n    Example:\n    >>> sum_numbers([1, 2, 3, 10])\n    16\n    \"\"\"\n    return sum(numbers)", "def sum_of_list(numbers):\n    \"\"\"Calculates the sum of a list of numbers.\n    \n    Parameters:\n    numbers (list of float/int): A list of numbers to sum up.\n    \n    Returns:\n    float/int: The sum of the numbers in the list.\n    \n    Examples:\n    >>> sum_of_list([1, 2, 3, 4])\n    10\n    >>> sum_of_list([1.5, 2.5, -1])\n    3.0\n    \"\"\"\n    return sum(numbers)"], ["def divide(dividend, divisor):\n    \"\"\"\n    Returns the quotient of the division of the dividend by the divisor.\n    Parameters:\n    dividend (float or int): The number which is to be divided.\n    divisor (float or int): The number by which the dividend is to be divided.\n    Returns:\n    float: The quotient of dividend and divisor.\n    Raises:\n    ZeroDivisionError: If the divisor is zero.\n    Examples:\n    >>> divide(10, 2)\n    5.0\n    >>> divide(5, 2)\n    2.5\n    \"\"\"\n    if divisor == 0:\n        raise ZeroDivisionError(\"Divisor cannot be zero.\")\n    return dividend / divisor"], ["def volume_cube(side_length):\n    \"\"\"\n    Calculates the volume of a cube.\n    Parameters:\n    side_length (float or int): The"], ["def factorial(number):\n    \"\"\"\n    Computes the factorial of a number using iterative method.\n    Parameters:\n    - number (int): The number to compute the factorial of.\n    Returns:\n    - int: Factorial of the number.\n    Example:\n    >>> factorial(5)\n    120\n    \"\"\"\n    if number == 0 or number == 1:\n        return 1\n    result = 1\n    for n in range(2, number + 1):\n        result *= n\n    return result"], ["def calculate_speed(distance, time):\n    \"\"\"\n    Calculates the speed given distance and time.\n    Parameters:\n        distance (float): The distance traveled.\n        time (float): The time taken to travel the distance.\n    Returns:\n        float: The speed (distance per unit of time). Returns None if time is zero.\n    Examples:\n        >>> calculate_speed(100, 2)\n        50.0\n        >>> calculate_speed(150, 0)  # Edge case for division by zero\n        None\n    \"\"\"\n    if time == 0:\n        return None\n    return distance / time"], ["def calculate_total_cost(rate, quantity, additional_fees=0):\n    \"\"\"\n    Calculate the total cost based on a rate and quantity with an option to include additional fees.\n    Parameters:\n        rate (float): The cost rate per unit.\n        quantity (int): The number of units.\n        additional_fees (float): Optional additional costs.\n    Returns:\n        float: The total cost.\n    Examples:\n        >>> calculate_total_cost(10, 5)\n        50\n        >>> calculate_total_cost(15.20, 3, 10)\n        55.6\n    \"\"\"\n    return multiply(rate, quantity) + additional_fees"], ["def arithmetic_mean(data):\n    \"\"\"\n    Computes the arithmetic mean of a list or array of numbers.\n    \n    Parameters:\n        data (list or ndarray): A list or numpy array of numbers.\n    Returns:\n        float: The arithmetic mean of the data provided.\n    \n    Example:\n        >>> arithmetic_mean([1, 2, 3, 4, 5])\n        3.0\n    \"\"\"\n    return np.mean(data)"], ["def sum_elements(data):\n    \"\"\"\n    Computes the sum of elements in a list or array.\n    \n    Parameters:\n        data (list or ndarray): A list or numpy array of numbers.\n    \n    Returns:\n        float: The sum of the data provided.\n    \n    Example:\n        >>> sum_elements([1, 2, 3, 4, 5])\n        15\n    \"\"\"\n    return np.sum(data)"], ["def round_number(number, digits):\n    \"\"\"\n    Round a number to a specified number of decimal places.\n    Parameters:\n        number (float): The number to be rounded.\n        digits (int): The number of decimal places to round to.\n    Returns:\n        float: The rounded number.\n    Examples:\n        >>> round_number(3.141592653589793, 2)\n        3.14\n        >>> round_number(123.456789, 3)\n        123.457\n    \"\"\"\n    return round(number, digits)"], ["def simplify_fraction(numer, denom):\n    \"\"\"Simplify a fraction by dividing both numerator and denominator by their GCD.\n    Parameters:\n    - numer (int) : The numerator of the fraction.\n    - denom (int) : The denominator of the fraction.\n    Returns:\n    Fraction : A simplified Fraction object.\n    \"\"\"\n    common_divisor = gcd(numer, denom)\n    return Fraction(numer//common_divisor, denom//common_divisor)"], ["def simplify_expression(expression):\n    \"\"\"\n    Simplifies a mathematical expression string step-by-step and evaluates the result respecting PEMDAS/BODMAS rules.\n    \n    Parameters\n    ----------\n    expression : str\n        A string containing the mathematical expression to be simplified.\n    Returns\n    -------\n    sp.Expr\n        The simplified symbolic expression using SymPy.\n    str\n        String representation of the simplified expression.\n    float\n        Numerically evaluated result of the simplified expression.\n        \n    Examples\n    --------\n    >>> simplify_expression(\"2 + 3 * 4 - 1\")\n    (2 + (3*4) - 1) simplified is: 11.0\n    >>> simplify_expression(\"1 + 2 * (3 + 4)\")\n    (1 + 2*(3 + 4)) simplified is: 15.0\n    \"\"\"\n    import sympy as sp\n    symbolic_expr = sp.sympify(expression)\n    simplified_expr = sp.simplify(symbolic_expr)\n    return simplified_expr, str(simplified_expr), float(simplified_expr)"]], "Rounding Numbers": [["def precision_round(number, places=2, mode=decimal.ROUND_HALF_UP):\n    \"\"\"\n    Rounds a number to a specified number of decimal places with customizable rounding mode.\n    Parameters:\n        number : float\n            The number to round.\n        places : int, optional\n            The number of decimal places to round to. Default is 2.\n        mode : decimal.Decimal, optional\n            The rounding mode from the decimal module. Default is ROUND_HALF_UP.\n    Returns:\n        float: The rounded number.\n    Examples:\n        >>> precision_round(123.4567)\n        123.46\n        >>> precision_round(123.4567, 1)\n        123.5\n        >>> precision_round(123.4567, 0)\n        123\n        >>> precision_round(123.445, 2, mode=decimal.ROUND_HALF_DOWN)\n        123.44\n        >>> precision_round(123.445, 2, mode=decimal.ROUND_UP)\n        123.45\n    Notes:\n        - The function allows flexibility with the `places` and `mode`, making it suitable for various rounding requirements including financial calculations.\n    \"\"\"\n    decimal.getcontext().rounding = mode\n    rounded_value = decimal.Decimal(str(number)).quantize(decimal.Decimal('1.' + '0'*places))\n    return float(rounded_value)", "def round_number(num, decimals=0):\n    \"\"\"\n    Rounds a number to a specified number of decimal places.\n    Parameters:\n    num (float or Decimal): The number to be rounded.\n    decimals (int): The number of decimal places to round to. This can be negative for rounding at digit places left of the decimal.\n    Returns:\n    float or Decimal: The rounded number.\n    Examples:\n    >>> round_number(3.14159265, 2)\n    3.14\n    >>> round_number(123.456789, -1)\n    120.0\n    >>> round_number(155, -2)\n    200\n    \"\"\"\n    import decimal\n    # Using Decimal for more accuracy in rounding\n    d = decimal.Decimal(str(num))\n    rounding_mode = decimal.ROUND_HALF_UP\n    rounded_value = round(d, decimals)\n    # Convert back to float if necessary for broader usage\n    if isinstance(num, float):\n        return float(rounded_value)\n    else:\n        return rounded_value", "def round_number(number, decimal_places=0, mode='half_up'):\n    \"\"\"\n    Rounds a number to a specified number of decimal places with a given rounding mode.\n    Parameters:\n    - number (float): The numeric value to round.\n    - decimal_places (int): The desired number of decimal places to round to. Default is 0 (nearest integer).\n    - mode (str): The method of rounding: 'half_up', 'half_down', 'up', 'down'.\n      'half_up' rounds 0.5 up (standard rounding), 'half_down' rounds 0.5 down,\n      'up' always rounds up, and 'down' always rounds down.\n    \n    Returns:\n    - float: The rounded number.\n    Examples:\n    >>> round_number(2.675, 2, 'half_up')\n    2.68\n    >>> round_number(2.675, 2, 'half_down')\n    2.67\n    >>> round_number(3.14159265, 3, 'up')\n    3.142\n    >>> round_number(-2.783, 0, 'down')\n    -3.0\n    \"\"\"\n    factor = 10 ** decimal_places\n    if mode == 'half_up':\n        return math.floor((number * factor) + 0.5) / factor\n    elif mode == 'half_down':\n        return math.ceil((number * factor) - 0.5) / factor\n    elif mode == 'up':\n        return math.ceil(number * factor) / factor\n    elif mode == 'down':\n        return math.floor(number * factor) / factor\n    else:\n        raise ValueError(f\"Invalid rounding mode: {mode}\")", "def custom_round(number, decimal_places=0):\n    \"\"\"\n    Rounds a number to a specified number of decimal places.\n    \n    Parameters:\n    - number (float): The number to be rounded.\n    - decimal_places (int): The number of decimal places to round to.\n    \n    Returns:\n    float: The rounded number.\n    Examples:\n    >>> custom_round(3.14159, 2)\n    3.14\n    >>> custom_round(1.275, 2)\n    1.28\n    >>> custom_round(1.2345, 3)\n    1.235\n    >>> custom_round(1.2344, 3)\n    1.234\n    \"\"\"\n    import decimal\n    # Setting rounding method of decimal context to ROUND_HALF_UP\n    decimal.getcontext().rounding = decimal.ROUND_HALF_UP\n    d = decimal.Decimal(number)\n    rounded = round(d, decimal_places)  # Using round after setting context for proper half up rounding\n    return float(rounded)", "def round_to_decimals(value, decimals=0, rounding_mode=decimal.ROUND_HALF_UP):\n    \"\"\"\n    Rounds the given value to a specified number of decimal places.\n    Parameters:\n    - value (float or str): The number to be rounded.\n    - decimals (int): Number of decimal places to round to.\n    - rounding_mode (decimal.Decimal): Rounding strategy, using decimal rounding modes.\n    Returns:\n    - Decimal: Rounded value as a decimal, which can prevent floating point arithmetic issues.\n    Examples:\n    >>> round_to_decicles(3.14159, 2)\n    Decimal('3.14')\n    \n    >>> round_to_decimals(123.4567, 3)\n    Decimal('123.457')\n    >>> round_to_decimals(1500, -2)\n    Decimal('1500')\n    \"\"\"\n    decimal.getcontext().rounding = rounding_mode\n    value = decimal.Decimal(value).quantize(decimal.Decimal('1.' + '0' * decimals))\n    return value", "def round_to_place(value, decimal_places=0):\n    \"\"\"\n    Rounds a given floating point number to a specified number of decimal places.\n    \n    Parameters:\n        value (float): The number to be rounded.\n        decimal_place (int, optional): The number of decimal places to round to.\n            Default is 0, which rounds to the nearest whole number.\n    \n    Returns:\n        float: The rounded number.\n    \n    Example:\n        round_to_place(3.14159, 2) -> 3.14\n        round_to_place(2.675, 2) -> 2.68\n    \n    Notes:\n        - This function uses the built-in Python round function which rounds away from zero if the number\n          to be rounded is exactly half-way between two integers.\n        - To provide behavior familiar in many decimal rounding operations, especially in financial calculations\n          where this is generally desirable.\n    \"\"\"\n    return round(value, decimal_points)", "def custom_round(value, decimal_places=0, mode=math.ceil):\n    \"\"\"\n    Custom rounding function that can handle rounding up or down based on a mode function.\n    \n    Parameters:\n        value (float): The number to be rounded.\n        decimal_places (int): The number of decimal places to round to.\n        mode (function): A function defining the method of rounding. Default is math.ceil.\n    \n    Returns:\n        float: The rounded number according to the specified mode.\n    \n    Example:\n        custom_round(2.137, 1, mode=math.ceil)  -> 2.2\n        custom_round(2.137, 1, mode=math.floor) -> 2.1\n    \n    Notes:\n        - The `mode` parameter allows customization of rounding logic. `math.ceil` for always rounding up,\n          `math.floor` for always rounding down, or `round` for standard rounding rules.\n        - This function introduces flexible handling that can be crucial in contexts where different rounding\n          rules are necessary (e.g., statistical or financial calculations).\n    \"\"\"\n    factor = 10 ** decimal_places\n    return mode(value * factor) / factor"], ["def rounding_analyzer(original, rounded):\n    \"\"\"\n    Analyzes the properties between original and rounded number.\n    \n    Parameters:\n    - original (float): The original number before rounding.\n    - rounded (float): The rounded number.\n    \n    Returns:\n    dict: A dictionary providing information about change, direction of rounding and error (if any).\n    \n    Examples:\n    >>> rounding_analyzer(3.1459, 3.15)\n    {'original': 3.1459, 'rounded': 3.15, 'change': 0.0041, 'direction': 'up', 'error': 0.0}\n    >>> rounding_analyzer(2.2499, 2.25)\n    {'original': 2.2499, 'rounded': 2.25, 'change': 0.0001, 'direction': 'up', 'error': 0.0}\n    >>> rounding_analyzer(4.9999, 5.0)\n    {'original': 4.9999, 'rounded': 5.0, 'change': 0.0001, 'direction': 'up', 'error': 0.0}\n    \"\"\"\n    original = float(original)\n    rounded = float(rounded)\n    change = abs(rounded - original)\n    direction = 'up' if rounded > original else 'down' if rounded < original else 'no change'\n    error = abs(rounded - round(float(original)))\n    return {'original': original, 'rounded': rounded, 'change': change, 'direction': direction, 'error': error}"], ["def round_to_nearest(value, unit=1):\n    \"\"\"\n    Rounds the given value to the nearest specified unit. For example, nearest dollar, nearest hundred, etc.\n    Parameters:\n    - value (float or int): The number to be rounded.\n    - unit (int): The unit to round to. Default is 1, which corresponds to nearest whole number.\n    Returns:\n    - int: Rounded value to nearest unit.\n    Examples:\n    >>> round_to_nearest(123.25)\n    123\n    \n    >>> round_to_nearest(123.99)\n    124\n    >>> round_to_nearest(1583, 100)\n    1600\n    \"\"\"\n    return int(decimal.Decimal(value / unit).to_integral_value(decimal.ROUND_HALF_UP) * unit)"]], "Order of Operations": [["def nth_term_arithmetic_sequence(a, d, n):\n    \"\"\"\n    Calculate the n-th term of an arithmetic sequence using the formula a_n = a + (n-1) * d.\n    Parameters:\n    - a (float): The first term of the sequence.\n    - d (float): The common difference of the sequence.\n    - n (int): The term of the sequence to find.\n    Returns:\n    - float: The n-th term of the sequence.\n    Examples:\n    >>> nth_term_arithmetic_sequence(3, 2, 5)\n    11\n    >>> nth_term_arithmetic_sequence(1, -0.5, 10)\n    -3.5\n    \"\"\"\n    return a + (n - 1) * d", "def nth_term_of_arithmetic_sequence(a, d, n):\n    \"\"\"\n    Compute the nth term of an arithmetic sequence.\n    Parameters:\n    - a (int, float): The first term of the sequence.\n    - d (int, float): The common difference of the sequence.\n    - n (int): The nth term to find.\n    Returns:\n    - int or float: The value of the nth term.\n    Examples:\n    >>> nth_term_of_arithmetic_sequence(1, 3, 5)\n    13\n    \"\"\"\n    return a + (n - 1) * d", "def nth_term_arithmetic_sequence(a, d, n):\n    \"\"\"\n    Returns the nth term of an arithmetic sequence.\n    Parameters:\n    a (int or float): The first term of the arithmetic sequence.\n    d (int or float): The common difference of the sequence.\n    n (int): The term number to find.\n    Returns:\n    int or float: The nth term of the sequence.\n    Example:\n    >>> nth_term_arithmetic_sequence(1, 1, 5)\n    5\n    >>> nth_term_arithmetic_sequence(3, 5, 10)\n    48\n    \"\"\"\n    return a + (n - 1) * d", "def sum_arithmetic_sequence(a, d, n):\n    \"\"\"\n    Returns the sum of the first n terms of an arithmetic sequence.\n    Parameters:\n    a (int or float): The first term of the arithmetic sequence.\n    d (int or float): The common difference of the sequence.\n    n (int): The number of terms to sum.\n    Returns:\n    int or float: The sum of the first n terms of the sequence.\n    Example:\n    >>> sum_arithmetic_sequence(1, 1, 5)\n    15\n    >>> sum_arithmetic_sequence(3, 5, 10)\n    260\n    \"\"\"\n    return n / 2 * (2 * a + (n - 1) * d)"], ["def evaluate_expression(expression):\n    \"\"\"\n    Evaluate an arithmetic expression respecting the proper order of operations: \n    parentheses, exponents, multiplication/division, and addition/subtraction.\n    Parameters:\n    - expression (str): A string representing the mathematical expression to evaluate.\n    Returns:\n    - float: The result of the evaluated expression.\n    Examples:\n    >>> evaluate_expression('3 + 5 * 2')\n    13.0\n    >>> evaluate_expression('(3 + 5) * 2')\n    16.0\n    >>> evaluate_expression('4**2 + 6 / 3')\n    17.0\n    \"\"\"\n    try:\n        # Use numpy's eval function which adheres to the order of operations\n        result = np.float64(np.core.eval(expression))\n        return result\n    except Exception as e:\n        # In case of invalid expression inputs\n        raise ValueError(f\"Error evaluating expression {expression}: {e}\")", "def evaluate_expression(expression):\n    \"\"\"\n    Evaluate a mathematical expression by strictly following the order of operations (PEMDAS/BODMAS).\n    \n    Parameters\n    ----------\n    expression : str\n        A string that represents the mathematical expression to be evaluated.\n        \n    Returns\n    -------\n    result : float or int\n        The numerical result of the evaluated expression.\n        \n    Examples\n    --------\n    >>> evaluate_expression(\"3 + 2 * (1 + 3)**2 - 8 / 2\")\n    26.0\n    \n    >>> evaluate_expression(\"(2 + 3) * 5\")\n    25\n    \n    >>> evaluate_expression(\"4**2 + 6 * 10\")\n    100\n    \"\"\"\n    from sympy import sympify\n    # Compute the expression using sympy which respects order of operations\n    try:\n        result = sympify(expression).evalf()\n    except Exception as e:\n        raise ValueError(f\"Error evaluating expression: {str(e)}\")\n    return result", "def evaluate_expression(expression):\n    \"\"\"\n    Evaluate a mathematical expression with proper handling of the order of operations (PEMDAS/BODMAS rules).\n    Parameters:\n    - expression (str): A string representing the mathematical expression to evaluate.\n    Returns:\n    - float or int: The result of the evaluated expression.\n    Examples:\n    >>> evaluate_expression(\"3 + 4 * 2\")\n    11\n    >>> evaluate_expression(\"(3 + 4) * 2\")\n    14\n    >>> evaluate_expression(\"4 ** 2 + 1\")\n    17\n    >>> evaluate_expression(\"((2 + 3) * 5) ** 2\")\n    625\n    \"\"\"\n    import sympy as sp\n    result = sp.sympify(expression)\n    return float(result) if result.is_Float else int(result)", "def evaluate_expression(expression):\n    \"\"\"\n    Evaluate a mathematical expression strictly following the order of operations (PEMDAS/BODMAS).\n    \n    Parameters:\n        expression (str): A string representing the mathematical expression to evaluate.\n    \n    Returns:\n        sympy.core.expr.Expr: The simplified form of the mathematical expression after applying order of operations.\n    \n    Examples:\n        >>> evaluate_expression(\"3 + 4 * 2 / (1 - 5)**2**2\")\n        3.00390625\n        >>> evaluate_expression(\"(2 + 3) * 5\")\n        25\n        \n        >>> evaluate_text(\"8 / 4 * 2\")\n        4\n    Note:\n        The function can process expressions with nested parentheses, exponents, multiplication,\n        division, addition, and subtraction. Ensure that the syntax of the input expression is\n        correct and that all operations are appropriately specified.\n    \"\"\"\n    # Parse the input string into a symbolic expression\n    parsed_expression = sympify(expression)\n    \n    # Simplify the expression ensuring all operations follow the order rules\n    result = simplify(parsed_expression)\n    \n    # If the result is numeric, possibly return a float if the result is quite simple or a numeric result\n    if result.is_Number:\n        return float(result)\n    else:\n        return result", "def evaluate_expression(expression):\n    \"\"\"\n    Evaluates a mathematical expression string with proper respect to the order of operations.\n    Parameters:\n    expression (str): A string representing a mathematical expression.\n    Returns:\n    float or sympy object: The result of the evaluated expression.\n    Example:\n    >>> evaluate_expression(\"2 + 3 * 4 - (2**3)\")\n    7\n    >>> evaluate_expression(\"(3 + 5 * (2 - 3)**2 - 1) / 2\")\n    8.0\n    \"\"\"\n    # Convert the string expression to a sympy expression and evaluate it\n    # sp.sympify parses the string to form a Sympy expression which is accurately evaluated\n    return sp.sympify(expression).evalf()"], ["def safe_eval(expr):\n    \"\"\"\n    Safely evaluates a string expression using Python arithmetic operations.\n    \n    Parameters:\n    - expr (str): A mathematical expression in string form following PEMDAS/BODMAS rules.\n    \n    Returns:\n    - float: The result of the evaluated expression.\n    \n    Examples:\n    >>> safe_eval(\"3 + 5 * 2\")\n    13.0\n    >>> safe_eval(\"(3 + 5) * 2\")\n    16.0\n    >>> safe_eval(\"((2 + 3) * 5) / 10\")\n    2.5\n    \n    \"\"\"\n    # Dictionary to map operation names to their respective operators\n    operators = {\n        ast.Add: operator.add, \n        ast.Sub: operator.sub, \n        ast.Mult: operator.mul, \n        ast.Div: operator.truediv,\n        ast.Pow: operator.pow,\n        ast.USub: operator.neg\n    }\n    \n    # Inner function to evaluate expressions based on Abstract Syntax Trees\n    def eval_(node):\n        if isinstance(node, ast.Num):  # Simple number\n            return node.n\n        elif isinstance(node, ast.BinOp):  # Binary operations\n            return operators[type(node.op)](eval_(node.left), eval_(node.right))\n        elif isinstance(node, ast.UnaryOp):  # Unary operations\n            return operators[type(node.op)](eval_(node.operand))\n        else:\n            raise TypeError(node)\n    \n    # Parsing input expression string to an Abstract Syntax Tree\n    tree = ast.parse(expr, mode='eval')\n    \n    return eval_(tree.body)"], ["def sum_arithmetic_sequence(a, l, n):\n    \"\"\"\n    Calculate the sum of the first n terms of an arithmetic sequence.\n    Parameters:\n    - a (float): The first term of the sequence.\n    - l (float): The last term of the sequence, optionally calculated elsewhere.\n    - n (int): The number of terms to sum.\n    Returns:\n    - float: The sum of the sequence's terms.\n    Examples:\n    >>> sum_arithmetic_sequence(2, 10, 5)\n    30.0\n    >>> sum_arithmetic_sequence(5, 23, 7)\n    98.0\n    \"\"\"\n    return (n / 2) * (a + l)", "def average_arithmetic_sequence(a, l, n):\n    \"\"\"\n    Calculate the average of the first n terms of an arithmetic sequence.\n    Parameters:\n    - a (float): The first term of the sequence.\n    - l (float): The last term of the sequence, optionally calculated elsewhere.\n    - n (int): The number of terms to average.\n    Returns:\n    - float: The average of the sequence's terms.\n    Examples:\n    >>> average_arithmetic_sequence(2, 10, 5)\n    6.0\n    >>> average_arithmetic_sequence(5, 23, 7)\n    14.0\n    \"\"\"\n    return sum_arithmetic_sequence(a, l, n) / n", "def sum_of_arithmetic_sequence(a, n, l=None):\n    \"\"\"\n    Computes the sum of the first n terms of an arithmetic sequence or up to the nth term l.\n    Parameters:\n    - a (int, float): The first term of the sequence.\n    - n (int): The number of terms to include in the sum.\n    - l (int or float, optional): The nth term; if not provided, it will be calculated.\n    Returns:\n    - float or int: The sum of the first n terms of the sequence.\n    Examples:\n    >>> sum_of_arithmetic..."]], "Unit Conversion": [["def calculate_travel_cost(start_odometer, end_odometer, mpg, fuel_price):\n    \"\"\"\n    Calculates the total cost of fuel for a trip, given the start and end odometer readings, the mileage, and the fuel price.\n    Parameters:\n    - start_odometer (float): The odometer reading at the start of the trip in miles.\n    - end_odometer (float): The odometer reading at the end of the trip in miles.\n    - mpg (float): Miles per gallon the car can travel.\n    - fuel_price (float): The price of fuel per gallon.\n    Returns:\n    - float: The total cost of the fuel consumed during the trip, rounded to the nearest cent.\n    Examples:\n    >>> calculate_travel_cost(1200, 1250, 25, 3.50)\n    7.0\n    \"\"\"\n    distance_traveled = end_odometer - start_odometer\n    gallons_used = distance_traveled / mpg\n    total_cost = gallons_used * fuel_cprice\n    return round(total_cost, 2)", "def calculate_total_cost(initial_reading, final_reading, mileage, fuel_price):\n    \"\"\"\n    Calculates the total travel cost based on the distance traveled, car's mileage, and fuel price,\n    adjusting for proper unit handling (assumes distances are in miles).\n    Parameters:\n        initial_reading (float): Initial odometer reading in miles.\n        final_reading (float): Final odometer reading in miles.\n        mileage (float): Car fuel efficiency in miles per gallon.\n        fuel_price (float): Price of fuel per gallon.\n    Returns:\n        float: Total cost of fuel rounded to nearest cent.\n    Examples:\n        - calculate_total_cost(100, 200, 25, 3.50) approximately returns 14.00\n    \"\"\"\n    total_miles = final_reading - initial_reading\n    total_gallons = total_miles / mileage\n    total_cost = total_gallons * fuel_price\n    # Round the total cost to nearest cent\n    return round(total_cost, 2)"], ["def convert_units(value, from_unit, to_unit):\n    \"\"\"\n    Converts a measurement from one unit to another.\n    Parameters:\n    - value (float): The quantity of the measurement in the 'from_unit'.\n    - from_unit (str): The unit of the input value. Supported units are 'inches', 'feet', 'yards', and 'miles'.\n    - to_unit (str): The unit to which the conversion should be made. Supported units are the same as 'from_unit'.\n    Returns:\n    - float: The converted value in the 'to_unit'.\n    Examples:\n    >>> convert_units(12, 'inches', 'feet')\n    1.0\n    >>> convert_units(3, 'yards', 'feet')\n    9.0\n    \"\"\"\n    # Unit conversion factors\n    factors = {\n        'inches': {'feet': 1/12, 'yards': 1/36, 'miles': 1/63360},\n        'feet': {'inches': 12, 'yards': 1/3, 'miles': 1/5280},\n        'yards': {'inches': 36, 'feet': 3, 'miles': 1/1760},\n        'miles': {'inches': 63360, 'feet': 5280, 'yards': 1760}\n    }\n    if from_unit == to_unit:\n        return value\n    else:\n        return value * factors[from_unit][to_unit]", "def convert_time(value, from_unit, to_unit):\n    \"\"\"\n    Convert between different time units such as seconds, minutes, hours, days, and weeks.\n    \n    Parameters:\n        value (float): the numeric value of time to convert.\n        from_unit (str): the unit of the input time ('seconds', 'minutes', 'hours', 'days', 'weeks').\n        to_unit (str): the unit of the converted time ('seconds', 'minutes', 'hours', 'days', 'weeks').\n    \n    Returns:\n        float: the time converted into the target unit\n        \n    Examples:\n        convert_time(1, 'hours', 'minutes') -> 60.0\n        convert_time(1, 'weeks', 'days') -> 7.0\n    \"\"\"\n    unit_factors = {\n        'seconds': 1,\n        'minutes': 60,\n        'hours': 3600,\n        'days': 86400,\n        'weeks': 604800\n    }\n    \n    if from_unit not in unit_factors or to_unit not in unit_factors:\n        raise ValueError(\"Unsupported time unit provided.\")\n    \n    # Convert the input value to seconds first\n    seconds = value * unit_percent from_unit]\n    # Then convert seconds to the desired output unit\n    return seconds / unit_factors[to_unit]", "def convert_units(value, from_unit, to_unit, power=1):\n    \"\"\"\n    Convert between units of measurement (linear, square, or cubic).\n    Parameters:\n    value : float\n        The numerical value to convert.\n    from_unit : str\n        The unit from which to convert ('inches', 'feet', 'yards', 'miles').\n    to_unit : str\n        The unit to which to convert ('inches', 'feet', 'yards', 'miles').\n    power : int, optional\n        The power of the units (1 for linear, 2 for square, 3 for cubic). Default is linear.\n    Returns:\n    float\n        The converted value in the target unit.\n    Examples:\n    >>> convert_units(10, 'feet', 'inches')\n    120.0\n    >>> convert_units(1, 'yards', 'feet', power=3)\n    27.0\n    >>> convert_units(1, 'miles', 'yards')\n    1760.0\n    \"\"\"\n    # Conversion factors for linear measurements\n    conversions = {\n        'inches': {'feet': 1/12, 'yards': 1/36, 'miles': 1/63360},\n        'feet': {'inches': 12, 'yards': 1/3, 'miles': 1/5280},\n        'yards': {'inches': 36, 'feet': 3, 'miles': 1/1760},\n        'miles': {'inches': 63360, 'feet': 5280, 'yards': 1760}\n    }\n    # Ensure both units are different and power is a valid integer\n    if from_unit == to_unit or power not in [1, 2, 3]:\n        return value\n    # Compute the conversion factor considering the power (exponentiation)\n    if power == 1:\n        factor = conversions[from_unit][to_unit]\n    else:\n        factor = (conversions[from_unit][to_unit]) ** power\n    return value * factor", "def convert_time(value, from_unit, to_unit):\n    \"\"\"\n    Converts a given time from one unit to another.\n    Parameters:\n    value : float\n        The time value to be converted.\n    from_unit : str\n        The unit of time the `value` is currently in. Accepted units: 'minutes', 'hours', 'seconds', 'days', 'weeks'.\n    to_unit : str\n        The unit of time to convert `value` into. Accepted units: 'minutes', 'hours', 'seconds', 'days', 'weeks'.\n    \n    Returns:\n    float\n        The time in the desired unit.\n    Examples:\n    >>> convert_time(120, 'minutes', 'hours')\n    2.0\n    >>> convert_time(1, 'week', 'days')\n    7.0\n    >>> convert_time(30, 'minutes', 'seconds')\n    1800.0\n    \"\"\"\n    # Conversion factors from one unit to another\n    conversion_factors = {\n        'minutes': {'hours': 1/60, 'seconds': 60, 'days': 1/1440, 'weeks': 1/10080},\n        'hours': {'minutes': 60, 'seconds': 3600, 'days': 1/24, 'weeks': 1/168},\n        'seconds': {'minutes': 1/60, 'hours': 1/3600, 'days': 1/86400, 'weeks': 1/604800},\n        'days': {'minutes': 1440, 'hours': 24, 'seconds': 86400, 'weeks': 1/7},\n        'weeks': {'minutes': 10080, 'hours': 168, 'seconds': 604800, 'days': 7}\n    }\n    \n    if from_unit == to_unit:\n        # No conversion needed if units are the same\n        return value\n    \n    # Calculate the route factor for conversion, handle direct and indirect conversions\n    if to_unit in conversion_factors[from_unit]:\n        return value * conversion_factors[from_unit][to_unit]\n    else:\n        # Handle potential indirect conversion (e.g., weeks to hours through days)\n        # Find a common unit to convert through\n        for inter_unit in conversion_factors[from_unit]:\n            if to_unit in conversion_factors[inter_unit]:\n                return value * conversion_factors[from_unit][inter_unit] * conversion_factors[inter_unit][to_unit]\n        \n        raise ValueError(\"Unsupported unit conversion requested\")", "def convert_length(value, from_unit, to_unit):\n    \"\"\"\n    Converts a length value from one unit to another.\n    \n    Parameters:\n        value (float): The numerical value of the measurement.\n        from_unit (str): The unit from which to convert. Supported units are 'inches', 'feet', 'yards', 'miles'.\n        to_unit (str): The unit to which the value will be converted. Supported units are as above.\n    Returns:\n        float: The converted value in the target unit.\n    Examples:\n        - convert_length(12, 'feet', 'inches') returns 144.0\n        - convert_length(3, 'yards', 'feet') returns 9.0\n    \"\"\"\n    unit_factors = {\n        'inches': {'feet': 1/12, 'yards': 1/36, 'miles': 1/63360},\n        'feet': {'inches': 12, 'yards': 1/3, 'miles': 1/5280},\n        'yards': {'inches': 36, 'feet': 3, 'miles': 1/1760},\n        'miles': {'inches': 63360, 'feet': 5280, 'yards': 1760}\n    }\n    \n    # Convert the input value to an intermediate base unit (inches)\n    if from_unit == to_unit:\n        return value\n    else:\n        intermediate_value = value * unit_factors[from_unit][to_unit]\n        \n    return intermediate_value", "def convert_units(value, from_unit, to_unit, unit_type='linear'):\n    \"\"\"\n    Convert between different units of measurement, including handling linear,\n    square (for area), and cubic (for volume) units based on specified unit type.\n    \n    Parameters:\n    - value (float): the numeric value to be converted.\n    - from_unit (str): the initial unit of measurement.\n    - to_unit (str): the target unit of measurement.\n    - unit_type (str): type of conversion ('linear', 'square', 'cubic').\n    \n    Returns:\n    - float: the converted value in the target unit.\n    Examples:\n    >>> convert_units(1, 'm', 'cm')\n    100.0\n    >>> convert_units(1, 'gallon', 'liters', unit_type='cubic')\n    3.78541\n    >>> convert_units(1, 'square km', 'square m', unit_type='square')\n    1000000.0\n    \"\"\"\n    import pint\n    ureg = pint.UnitRegistry()\n    value_as_quantity = value * ureg(from_unit)\n    if unit_type == 'square':\n        value_as_quantity = value_as_quantity * ureg(from_unit)\n    elif unit_type == 'cubic':\n        value_as_quantity = value_as_quantity * ureg(from_unit) * ureg(from_unit)\n    \n    converted = value_as_quantity.to(to_unit).magnitude\n    return converted", "def convert_time(value, from_unit, to_unit):\n    \"\"\"\n    Convert between different units of time.\n    Parameters:\n    - value (float or int): the numerical value of the time to convert.\n    - from_unit (str): the unit of the input value ('seconds', 'minutes', 'hours', 'days', 'weeks').\n    - to_unit (str): the unit to which to convert the input value.\n    Returns:\n    - float: the converted value in the target units.\n    Examples:\n    >>> convert_time(1, 'hours', 'minutes')\n    60.0\n    >>> convert_time(45, 'minutes', 'seconds')\n    2700.0\n    >>> convert_time(3, 'weeks', 'days')\n    21.0\n    \"\"\"\n    # Dictionary of conversion factors relative to seconds\n    unit_to_seconds = {'seconds': 1, 'minutes': 60, 'hours': 3600, 'days': 86400, 'weeks': 604800}\n    if from_unit not in unit_to_back or to_unit not in unit_to_back:\n        raise ValueError(\"Invalid 'from_unit' or 'to_unit'. Use 'seconds', 'minutes', 'hours', 'days', or 'weeks'.\")\n    # Convert from 'from_unit' to seconds\n    seconds = value * unit_to_seconds[from_unit]\n    # Convert from seconds to 'to_unit'\n    converted_value = seconds / unit_to_seconds[to_unit]\n    return converted_value"], ["def fraction_to_decimal(numerator, denominator):\n    \"\"\"\n    Convert a fraction to a decimal.\n    \n    Parameters:\n    - numerator (int): the numerator of the fraction.\n    - denominator (int): the denominator of the fraction.\n    \n    Returns:\n    - float: decimal representation of the fraction.\n    Examples:\n    >>> fraction_to_decimal(1, 2)\n    0.5\n    \"\"\"\n    return numerator / denominator"], ["def convert_units(value, factor):\n    \"\"\"\n    Convert units by a specific factor. This is a general utility function for unit scaling.\n    \n    Parameters:\n        value (float): the value to convert.\n        factor (float): the factor by which to scale the value.\n    \n    Returns:\n        float: the scaled value\n    \n    Examples:\n        convert_units(3, 60) -> 180\n    \"\"\"\n    return value * factor", "def convert_units(value, conversion_factor):\n    \"\"\"\n    Converts a given value from one unit of measurement to another using a provided conversion factor.\n    \n    Parameters:\n    - value (float or int): the value which needs to be converted.\n    - conversion_factor (float): the factor which converts the 'value' from the original unit to the desired unit.\n    \n    Returns:\n    - float: the converted value.\n    \n    Examples:\n    - convert_units(1000, 0.3048) converts 1000 feet to meters (assuming 1 foot = 0.3048 meters).\n    - convert_units(50, 0.45359237) converts 50 pounds to kilograms (assuming 1 pound = 0.45359237 kilograms).\n    \"\"\"\n    return value * conversion_factor"], ["def calculate_arithmetic(value1, value2, operation, rounding_digits=None):\n    \"\"\"\n    Perform arithmetic operations between two values and optionally round the result.\n    Parameters:\n    value1 : float\n        The first numerical value.\n    value2 : float\n        The second numerical value.\n    operation : str\n        The operation to perform ('add', 'subtract', 'multiply', 'divide').\n    rounding_digits : int, optional\n        The number of digits to round the result to. If None, rounding is not performed.\n    Returns:\n    float\n        The result of the arithmetic operation, potentially rounded.\n    Examples:\n    >>> calculate_arithmetic(10, 2.5, 'multiply')\n    25.0\n    >>> calculate_arithmetic(100.1234, 0, 'subtract', rounding_digits=2)\n    100.12\n    \"\"\"\n    operations = {\n        'add': lambda x, y: x + y,\n        'subtract': lambda x, y: x - y,\n        'multiply': lambda x, y: x * y,\n        'divide': lambda x, y: x / y if y != 0 else float('inf')\n    }\n    result = operations[operation](value1, value2)\n    if rounding_digits is not None:\n        return round(result, rounding_digits)\n    \n    return result", "def perform_arithmetic_operations(value1, value2, operation='multiply', rounding_precision=None):\n    \"\"\"\n    Performs specified arithmetic operations between two values and optionally rounds the result.\n    \n    Parameters:\n    - value1 (float or int): the first operand.\n    - value2 (float or int): the second operand.\n    - operation (str): the operation to perform ('multiply', 'divide', 'add', 'subtract').\n    - rounding_precision (int, optional): the number of decimal places to round the result to. If not specified, no rounding will occur.\n    \n    Returns:\n    - float or int: the result of the arithmetic operation, possibly rounded.\n    \n    Examples:\n    - perform_arithmetic_operations(100, 3, 'divide', rounding_precision=2) performs (100 / 3) and rounds to 2 decimal places.\n    - perform_arithmetic_operations(45, 2, 'multiply') returns the product of 45 and 2.\n    \"\"\"\n    if operation == 'multiply':\n        result = value1 * value2\n    elif operation == 'divide':\n        result = value1 / value2\n    elif operation == 'add':\n        result = value1 + value2\n    elif operation == 'subtract':\n        result = value1 - value2\n    else:\n        raise ValueError(\"Unsupported operation. Choose from 'multiply', 'divide', 'add', 'subtract'.\")\n    if rounding_precision is not None:\n        return round(result, rounding_precision)\n    else:\n        return result"], ["def currency_to_cents(dollars, cents_per_dollar=100):\n    \"\"\"\n    Convert a monetary value in dollars to cents.\n    \n    Parameters:\n    - dollars (float): the amount in dollars.\n    - cents_per_dollar (int): number of cents per dollar (default: 100).\n    \n    Returns:\n    - int: equivalent amount in cents.\n    Examples:\n    >>> currency_to_cents(1.25)\n    125\n    \"\"\"\n    return int(dollars * cents_per_dollar)"], ["def money_conversion(amount, from_currency, to_currency, exchange_rate):\n    \"\"\"\n    Convert monetary values from one currency to another using a specified exchange rate.\n    Parameters:\n    - amount (float): the monetary value in the original currency to be converted.\n    - from_currency (str): the ISO currency code of the original currency.\n    - to_currency (str): the ISO currency code of the target currency.\n    - exchange_rate (float): the rate at which the currencies are to be exchanged.\n    \n    Returns:\n    - float: the converted monetary value in the target currency.\n    Examples:\n    >>> money_conversion(100, 'USD', 'EUR', 0.95)\n    95.0\n    \"\"\"\n    return amount * exchange_rate"], ["def calculate_proportions(value, src_ratio, dest_ratio):\n    \"\"\"\n    Calculate the proportional value based on source and destination ratios.\n    Parameters:\n    - value (float): The original value which is to be proportionally adjusted.\n    - src_ratio (float): The source ratio.\n    - dest_ratio (float): The destination ratio represented.\n    Returns:\n    - float: The value adjusted to the destination ratio.\n    Examples:\n    >>> calculate_proportions(100, 1, 2)\n    200\n    >>> calculate_proportions(150, 3, 2)\n    100\n    \"\"\"\n    return value * (dest_ratio / src_ratio)"], ["def convert_and_round(value, from_unit, to_unit, decimals=0):\n    \"\"\"\n    Converts a measurement from one unit to another and rounds it to the specified number of decimals.\n    Parameters:\n    - value (float): The initial measurement value.\n    - from_unit (str): The starting unit of measurement.\n    - to_unit (str): The target unit of measurement.\n    - decimals (int, optional): Number of decimal places to round to. Default is 0.\n    Returns:\n    - float: The converted and rounded quantity.\n    Examples:\n    >>> convert_and_round(12, 'inches', 'feet')\n    1\n    >>> convert_and_round(3.5, 'yards', 'feet')\n    11\n    \"\"\"\n    import math\n    converted_value = convert_units(value, from_unit, to_unit)\n    return round(converted_value, decimals)"], ["def convert_units(value, src_unit, dest_unit, conversion_factors):\n    \"\"\"\n    Convert a value from a source unit to a destination unit using specified conversion factors.\n    Parameters:\n    - value (float): The numeric value to be converted.\n    - src_unit (str): The source unit from which conversion is to be made.\n    - dest_unit (str): The destination unit to which conversion is to be made.\n    - conversion_factors (dict): A dictionary with key as a tuple (src_unit, dest_unit) and value as the conversion factor.\n    Returns:\n    - float: The converted value in the destination unit.\n    Examples:\n    >>> convert_units(1000, 'mL', 'L', {('mL', 'L'): 0.001})\n    1.0\n    >>> convert_units(2, 'USD', 'EUR', {('USD', 'EUR'): 0.95})\n    1.9\n    \"\"\"\n    if (src_unit, dest_unit) in conversion_factors:\n        return value * conversion_factors[(src_unit, dest_unit)]\n    elif (dest_unit, src_unit) in conversion_factors:\n        return value / conversion_factors[(dest_unit, src_unit)]\n    else:\n        raise ValueError(\"Conversion factor not available for the given units\")"]], "Rate Problems": [["def calculate_rate_problem(distance=None, time=None, speed=None):\n    \"\"\"\n    General-purpose function for solving problems related to the formula speed = distance / time.\n    \n    Parameters\n    ----------\n    distance : float or None\n        The distance covered. If this is not provided, the function calculates it.\n    time : float or None\n        The time taken. If this is not provided, the function calculates it.\n    speed : float or None\n        The traveling speed. If this is not provided, the function calculates it.\n    \n    Returns\n    -------\n    float\n        The value of the calculated distance, time, or speed, depending on which parameter was initially None.\n    \n    Examples\n    --------\n    >>> calculate_rate_problem(speed=60, time=2)\n    120.0  # Distance = 60 mph * 2h = 120 miles\n    >>> calculate_rate_problem(distance=150, time=3)\n    50.0  # Speed = 150 miles / 3h = 50 mph\n    >>> calculate_rate_problem(distance=100, speed=50)\n    2.0  # Time = 100 miles / 50 mph = 2 hours\n    \"\"\"\n    if distance is None:\n        return speed * time\n    elif time is None:\n        return distance / speed\n    elif speed is None:\n        return distance / time\n    else:\n        raise ValueError(\"Two inputs are needed among distance, time and speed.\")", "def calculate_dsr(distance=None, speed=None, time=None):\n    \"\"\"\n    Calculate the distance, speed, or time given two of these values.\n    Parameters:\n    - distance (float, optional): the distance traveled in units e.g., kilometers.\n    - speed (float, optional): the rate of travel in units per time unit, e.g., kilometers per hour.\n    - time (float, optional): the time spent traveling in time units e.g., hours.\n    \n    Returns:\n    - float: The missing value: distance, speed, or time depending on input.\n    Examples:\n    >>> calculate_dsr(speed=60, time=2)\n    120.0\n    >>> calculate_dsr(distance=150, time=2.5)\n    60.0\n    >>> calculate_dsr(distance=180, speed=90)\n    2.0\n    \"\"\"\n    import sys\n    if distance is None and speed is not None and time is not None:\n        return speed * time\n    elif speed is None and distance is not None and time is not None:\n        return distance / time\n    elif time is None and distance is not None and speed is not None:\n        return distance / speed\n    else:\n        sys.exit(\"Error: Exactly one parameter must be None and the other two must be provided.\")"], ["def calculate_hourly_rate(total_earnings, total_hours):\n    \"\"\"\n    Calculate the hourly rate from total earnings and hours worked.\n    Parameters:\n    total_earnings (float): Total earnings in a period.\n    total_hours (float): Hours worked in the same period.\n    Returns:\n    float: Hourly wage.\n    Example:\n    >>> calculate_hourly_rate(500, 20)\n    25.0\n    \"\"\"\n    return total_earnings / total_hours", "def calculate_hourly_wage(total_earnings, total_hours):\n    \"\"\"\n    Calculate the hourly wage given total earnings and hours worked.\n    Parameters:\n    total_earnings (float): Total earnings over the period.\n    total_hours (float): Total hours worked.\n    Returns:\n    float: Hourly wage.\n    Examples:\n    >>> calculate_hourly_wage(400, 20)\n    20.0\n    \"\"\"\n    return total_earnings / total_hours"], ["def calculate_time(distance, rate):\n    \"\"\"\n    Computes the time required to cover a given distance with a specific rate (speed).\n    Parameters:\n    distance (float): the distance to be traveled.\n    rate (float): the speed at which the travel occurs.\n    Returns:\n    float: The time required to cover the given distance at the given rate.\n    Example:\n    >>> calculate_time(100, 50)\n    2.0\n    \"\"\"\n    if rate == 0:\n        raise ValueError(\"Rate cannot be zero.\")\n    return distance / rate", "def calculate_distance(time, rate):\n    \"\"\"\n    Computes the distance travelled over a given time at a specified rate (speed).\n    Parameters:\n    time (float): the time during which the motion occurs.\n    rate (float): the speed at which the motion occurs.\n    Returns:\n    float: The distance covered over the given time at the given rate.\n    Example:\n    >>> calculate_distance(2, 50)\n    100.0\n    \"\"\"\n    return time * rate", "def calculate_time(distance, speed):\n    \"\"\"\n    Calculate time required to cover a certain distance given the speed.\n    Parameters:\n    distance (float): Distance to be covered.\n    speed (float): Speed at which the distance will be covered.\n    Returns:\n    float: Time required to cover the distance.\n    Examples:\n    >>> calculate_time(100, 50)\n    2.0\n    \"\"\"\n    if speed == 0:\n        raise ValueError(\"Speed must be non-zero\")\n    return distance / speed"], ["def convert_hours_to_minutes(hours):\n    \"\"\"\n    Converts time from hours to minutes.\n    Parameters:\n    hours (float): The time in hours.\n    Returns:\n    float: The time in minutes.\n    Example:\n    >>> convert_hours_to_minutes(2.5)\n    150.0\n    \"\"\"\n    return hours * 60", "def convert_minutes_to_hours(minutes):\n    \"\"\"\n    Converts time from minutes to hours.\n    Parameters:\n    minutes (float): The time in minutes.\n    Returns:\n    float: The time in hours.\n    Example:\n    >>> convert_minutes_to_hours(150)\n    2.5\n    \"\"\"\n    return minutes / 60"], ["def calculate_speed_from_other(speed_of_one, time_of_one, time_of_other):\n    \"\"\"\n    Calculate the speed of another entity given the speed of one and their respective times to complete the same task.\n    Parameters:\n    speed_of_one (float): Speed of the first entity (e.g., speed in km/h).\n    time_of_one (float): Time taken by the first entity.\n    time_of_other (float): Time taken by the other entity to complete the same task.\n    Returns:\n    float: Calculated speed of the other entity.\n    Examples:\n    >>> calculate_speed_from_other(60, 2, 3)\n    40.0\n    \"\"\"\n    return speed_of_one * (time_of_one / time_of_other)"], ["def time_conversion(time_value, from_unit=\"hours\", to_unit=\"minutes\"):\n    \"\"\"\n    Convert time between hours and minutes.\n    Parameters:\n    time_value (float): The time value to convert.\n    from_unit (str): Unit of the input time ('hours' or 'minutes').\n    to toda_unit (str): Unit of the output time ('hours' or 'minutes').\n    Returns:\n    float: Converted time value.\n    Example:\n    >>> time_conversion(2, from_unit=\"hours\", to_unit=\"minutes\")\n    120.0\n    >>> time_conversion(90, from_unit=\"minutes\", to_unit=\"hours\")\n    1.5\n    \"\"\"\n    if from_unit == \"hours\" and to_unit == \"minutes\":\n        return time_value * 60\n    elif from_unit == \"minutes\" and to_unit == \"hours\":\n        return time_value / 60\n    else:\n        return time_value", "def convert_time(value, from_unit, to_unit):\n    \"\"\"\n    Convert time between hours and minutes.\n    Parameters\n    ----------\n    value : float\n        Time value to be converted.\n    from_unit : str\n        Unit of the input value, should be either 'hours' or 'minutes'.\n    to_unit : str\n        Target unit for the conversion, should be either 'hours' or 'minutes'.\n    \n    Returns\n    -------\n    float\n        Converted time value in the target units.\n    \n    Examples\n    --------\n    >>> convert_time(2, 'hours', 'minutes')\n    120.0  # 2 hours = 120 minutes\n    >>> convert_time(90, 'minutes', 'hours')\n    1.5  # 90 minutes = 1.5 hours\n    \"\"\"\n    if from_unit == 'hours' and to_unit == 'minutes':\n        return value * 60\n    elif from_unit == 'minutes' and to_unit == 'hours':\n        return value / 60\n    else:\n        raise ValueError(\"Incorrect unit conversion parameters provided.\")"], ["def calculate_rate(numerator, denominator):\n    \"\"\"\n    Calculates a rate given a numerator and denominator, which is a common operation in solving various rate-based problems.\n    Parameters:\n    numerator (float): The total quantity (e.g., total earnings, total distance, total work done).\n    denominator (float): The total units (e.g., hours worked, time taken).\n    Returns:\n    float: The rate calculated as a ratio of numerator to denominator.\n    Examples:\n    >>> calculate_rate(500, 25)\n    20.0  # Interpretation: If numerator is earnings in dollars and denominator is hours, the wage rate is $20/hour.\n    \n    >>> calculate_rate(100, 20)\n    5.0  # Interpretation: If numerator is distance in miles and denominator is time in hours, the speed is 5 mph.\n    \"\"\"\n    return numerator / denominator if denominator != 0 else None"], ["def rate_from_another_speed(known_speed, known_multiplier, target_multiplier):\n    \"\"\"\n    Calculate rate or speed of one individual/entity based on another's speed given a proportionality constant.\n    Parameters:\n    known_speed (float): The given speed of one reference person/object.\n    known_multiplier (float): The multiplier associated with the known speed.\n    target_multiplier (float): The desired multiplier for calculating the target speed.\n    Returns:\n    float: Target speed based on proportional relationship.\n    Example:\n    >>> rate_from_another_speed(30, 2, 1)\n    15.0\n    \"\"\"\n    return known_speed * (target_multiplier / known_multiplier)"], ["def calculate_time_distance(rate, other_quantity, is_distance_known=True):\n    \"\"\"\n    Calculate either time or distance using a fixed rate based on which quantity is known (distance or time).\n    Parameters:\n    rate (float): Given rate (distance per unit of time or vice versa).\n    other_quantity (float): The measure of the known quantity (either time or distance).\n    is_distance_known (bool): Flag to indicate if the provided quantity is distance (True) or time (False).\n    Returns:\n    float: The unprovided quantity (either time or distance).\n    Example:\n    >>> calculate_time_distance(60, 120, is_distance_known=True)  # Find time when distance and rate are known\n    2.0\n    >>> calculate_time_time_distance(60, 3, is_distance_known=False)  # Find distance when time and rate are known\n    180.0\n    \"\"\"\n    if is_instance(distance_known, True):\n        return other_quantity / rate\n    else:\n        return rate * other_quantity"], ["def average_speed(distances, times):\n    \"\"\"\n    Calculates average speed based on total distance traveled and total time spent traveling.\n    Parameters:\n    distances (list of float): list of distances traveled.\n    times (list of float): list of times spent for each corresponding distance.\n    Returns:\n    float: The average speed for the entire trip.\n    Example:\n    >>> average_speed([100, 200], [2, 4])\n    50.0\n    \"\"\"\n    total_distance = np.sum(distances)\n    total_time = np.sum(times)\n    if total_time == 0:\n        raise ValueError(\"Total time cannot be zero.\")\n    return total_distance / total_time"], ["def compute_duration_or_total(rate, other, is_duration=True):\n    \"\"\"\n    Given a rate and either the total quantity or total duration, this function computes either the duration required\n    to achieve a total at the given rate, or the total achievable in the given duration at the rate.\n    Parameters:\n    rate (float): The rate of operation (units per time for computing duration, or time per unit for total calculation).\n    other (float): The quantity if calculating duration or the duration if calculating total.\n    is_duration (bool): Flag to determine whether to compute duration (True) or total (False).\n    Returns:\n    float: The computed duration or total based on the input rate and other value.\n    Examples:\n    >>> compute_duration_or_total(20, 500, is_duration=True)\n    25.0  # Interpretation: At a rate of 20 units/hr to achieve 500 units, it takes 25 hours.\n    \n    >>> compute_duration_or_total(5, 100, is_duration=False)\n    500.0  # Interpretation: With a rate of 5 miles/hour and 100 hours available, the total distance is 500 miles.\n    \"\"\"\n    if rate == 0:\n        return None\n    return other / rate if is_duration else rate * other"], ["def combine_rates(*rates):\n    \"\"\"\n    Calculate the combined rate of work when multiple rates are working together.\n    Parameters:\n    rates (list of float): Rates of all entities working together.\n    Returns:\n    float: Combined rate.\n    Examples:\n    >>> combine_rates(1/2, 1/3)\n    0.8333333333333333\n    \"\"\"\n    if any(rate == 0 for rate in rates):\n        raise ValueError(\"Rates must be all non-zero\")\n    reciprocal_sum = np.sum(1 / np.array(rates))\n    return 1 / reciprocal_sum"], ["def calculate_task_duration(rate, total_quantity):\n    \"\"\"\n    Calculate the time required to complete a task given the rate and the total quantity.\n    Parameters:\n    rate (float): Rate of completing the task (unit per time).\n    total_quantity (float): Total quantity to be managed or processed.\n    Returns:\n    float: Time needed to complete the task.\n    Examples:\n    >>> calculate_task_duration(10, 100)\n    10.0\n    \"\"\"\n    if rate == 0:\n        raise ValueError(\"Rate must be non-zero\")\n    return total_quantity / rate"]], "Averages": [["def calculate_arithmetic_mean(data):\n    \"\"\"\n    Calculate the arithmetic mean of a list of numbers using pure Python.\n    \n    Parameters:\n    data (list of float/int): A list of numbers from which the mean is to be calculated.\n    Returns:\n    float: The arithmetic mean of the provided list of numbers.\n           Returns None if the input list is empty to avoid division by zero.\n    Examples:\n    >>> calculate_arithmetic_mean([1, 2, 3, 4, 5])\n    3.0\n    >>> calculate_arithmetic_mean([])\n    None\n    \"\"\"\n    if not data:  # check if the list is empty\n        return None\n    total_sum = sum(data)\n    count = len(data)\n    return total_sum / count if count else None", "def numpy_arithmetic_mean(data):\n    \"\"\"\n    Calculate the arithmetic mean of a list or array of numbers using NumPy.\n    \n    Parameters:\n    data (list/array of float/int): A list or numpy array of numbers from which the mean is to be calculated.\n    Returns:\n    float: The arithmetic mean of the provided list or array of numbers.\n           Returns None if the input is empty to accurately handle empty inputs.\n    Examples:\n    >>> import numpy as np\n    >>> numpy_arithmetic_mean([1, 2, 3, 4, 5])\n    3.0\n    >>> numpy_arithmetic_mean(np.array([]))\n    None\n    \"\"\"\n    import numpy as np  # Importing numpy inside the function\n    if np.size(data) == 0:  # np.size checks size for both lists and numpy arrays\n        return None\n    return np.mean(data)", "def calculate_arithmetic_mean(data):\n    \"\"\"\n    Calculate the arithmetic mean of a collection of numbers.\n    \n    Parameters:\n    data (list or iterable) : An iterable containing numerical values for which the mean is to be calculated.\n    \n    Returns:\n    float: The arithmetic mean of the input numbers.\n    Example:\n    >>> calculate_arithmetic_mean([1, 2, 3, 4, 5])\n    3.0\n    >>> calculate_arithmetic_mean(range(1, 11))\n    5.5\n    \n    Raises:\n    ValueError: If the input data is empty.\n    TypeError: If the input is not an iterable containing numbers.\n    \n    Note:\n    The function does not handle cases with 'None' or non-numeric types within the iterable.\n    Ensure that the data only contains numeric types for accurate computation.\n    \"\"\"\n    import numbers\n    \n    # Checking if the input data is empty\n    if not data:\n        raise ValueError(\"Input data is empty\")\n    \n    # Summing the data and counting the elements\n    total = 0\n    count = 0\n    for item in data:\n        if isinstance(item, numbers.Number):\n            total += item\n            count += 1\n        else:\n            raise TypeError(\"Input should only contain numeric types\")\n    \n    if count == 0:\n        raise ValueError(\"No valid numeric data provided\")\n    \n    # Calculating the mean\n    mean = total / count\n    return mean", "def calculate_mean(data):\n    \"\"\"\n    Calculate the simple arithmetic mean (average) of a list of numbers.\n    Parameters:\n    data (list or np.array): A list or array of numerical values.\n    Returns:\n    float: The mean of the input data.\n    Examples:\n    >>> calculate_mean([1, 2, 3, 4, 5])\n    3.0\n    >>> calculate_mean(np.array([2, 3, 4, 5, 6]))\n    4.0\n    \"\"\"\n    return np.mean(data)", "def calculate_mean(data):\n    \"\"\"\n    Calculate the arithmetic mean (average) of a list of numbers.\n    \n    The arithmetic mean is computed by summing all the numbers in the list\n    and then dividing the sum by the count of numbers in the list.\n    \n    Parameters:\n    - data (list or iterable): A list or iterable containing numbers (int, float).\n    \n    Returns:\n    - float: The arithmetic mean of the numbers in the provided list.\n    - None: If the input list is empty or contains no valid numbers.\n    \n    Raises:\n    - TypeError: If non-numerical values are found in the input data.\n    \n    Example:\n    >>> calculate_mean([1, 2, 3, 4, 5])\n    3.0\n    >>> calculate_mean([1.5, 2.5, 3.5])\n    2.5\n    >>> calculate_mean([])\n    None\n    \"\"\"\n    import numpy as np\n    \n    # Check for empty data\n    if not data:\n        return None\n    \n    # Verify all elements are numbers\n    if not all(isinstance(x, (int, float)) for x in data):\n        raise TypeError(\"All elements in the data must be int or float.\")\n    \n    # Using numpy functions for better performance on large lists\n    return np.mean(data)", "def compute_mean(data):\n    \"\"\"\n    Calculate the arithmetic mean of a list or array of numbers.\n    Parameters:\n    - data (list or np.array): A list or numpy array containing numerical data.\n    Returns:\n    - float: The mean of the input data.\n    Examples:\n    >>> compute_mean([1, 2, 3, 4, 5])\n    3.0\n    >>> compute_mean(np.array([10, 20, 30]))\n    20.0\n    \"\"\"\n    data_array = np.array(data)  # Ensure input is converted to numpy array for efficiency\n    mean_value = np.mean(data_array)\n    return mean_value"], ["def solve_mean_equation(total_sum, total_elements, desired_mean):\n    \"\"\"\n    Solve for 'x' in equations of the form (total_sum + x) / (total_elements + 1) = desired_mean.\n    Parameters:\n    -----------\n    total_sum : float or int\n        The sum of the known elements.\n    total_elements : int\n        The number of the known elements.\n    desired_mean : float\n        The desired average after including the unknown element 'x'.\n    Returns:\n    --------\n    float\n        The value of 'x' that when added to total_sum gives a mean of desired_mean.\n    Examples:\n    ---------\n    >>> solve_mean_equation(20, 4, 6)\n    4.0\n    \n    >>> solve_mean_equation(45, 9, 6)\n    -9.0\n    \"\"\"\n    return (desired_mean * (total_elements + 1)) - total_sum", "def solve_mean_equation(total_sum: float, count: int, unknown_sum: float = None):\n    \"\"\"\n    Solve for an unknown in an equation involving the arithmetic mean, given the total sum and count of elements.\n    \n    Parameters:\n    total_sum (float): The total sum of all known elements.\n    count (int): The total number of elements including unknowns.\n    unknown_sum (float, optional): Sum of unknown elements if already known.\n    Returns:\n    float: the value needed to reach the desired mean. This can be a remaining sum or an individual unknown element's required value.\n    Examples:\n    >>> solve_mean_equation(total_sum=10, count=5, unknown_sum=2)\n    12.0  # Total desired sum to achieve the mean with the current known sum and count\n    >>> solve_mean_equation(total_sum=15, count=5)\n    3.0  # Mean value\n    \"\"\"\n    x = symbols('x')\n    if unknown_sum is not None:\n        # Equation form where we know the sum of some unknowns\n        equation = Eq(total_sum + unknown_sum, x * count)\n    else:\n        # Directly find the mean from given sum and count\n        equation = Eq(total_sum, x * count)\n    solution = solve(equation, x)\n    if solution:\n        return solution[0]\n    else:\n        raise ValueError(\"The equation could not be solved.\")"], ["def calculate_average(numbers):\n    \"\"\"\n    Calculate the arithmetic mean of a list of numbers.\n    Parameters:\n        numbers (list): A list of numbers (integers or floats).\n    Returns:\n        float: The arithmetic mean of the numbers in the list.\n    Examples:\n        >>> calculate_average([10, 20, 30])\n        20.0\n        >>> calculate_average([1.5, 2.5, 3.5])\n        2.5\n    \"\"\"\n    if not numbers:\n        return 0\n    return sum(numbers) / len(numbers)", "def calculate_mean(numbers):\n    \"\"\"\n    Calculate the arithmetic mean of a collection of numbers.\n    Parameters:\n    -----------\n    numbers : iterable of float or int\n        The numbers to calculate the mean of.\n    Returns:\n    --------\n    float\n        The arithmetic mean of the numbers.\n    Examples:\n    ---------\n    >>> calculate_mean([1, 2, 3, 4, 5])\n    3.0\n    \n    >>> calculate_mean(range(1, 11))\n    5.5\n    \"\"\"\n    return np.mean(numbers)", "def calculate_mean(numbers):\n    \"\"\"\n    Calculate the arithmetic mean of a collection of numbers.\n    Parameters:\n    - numbers (iterable of float|int): An iterable collection of numbers (list, tuple, array).\n    Return:\n    - float: The arithmetic mean of the input numbers.\n    Example:\n    >>> calculate_mean([1, 2, 3, 4, 5])\n    3.0\n    >>> calculate_mean(np.array([1.5, 2.5, 3.5]))\n    2.5\n    \"\"\"\n    numbers_array = np.array(numbers)\n    return np.mean(numbers_array)", "def calculate_mean(numbers):\n    \"\"\"\n    Calculate the arithmetic mean of a list of numbers.\n    Parameters:\n    - numbers (list of float or int): A list containing numbers for which the mean is needed.\n    Returns:\n    - float: The calculated mean of the provided numbers.\n    Examples:\n    >>> calculate_mean([1, 2, 3, 4, 5])\n    3.0\n    >>> calculate_mean([10, 20])\n    15.0\n    \"\"\"\n    return sum(numbers) / len(numbers) if numbers else 0", "def calculate_mean(numbers: List[Union[int, float]]) -> float:\n    \"\"\"\n    Calculate the arithmetic mean (average) of a list of numbers.\n    Parameters:\n    - numbers (List[Union[int, float]]): A list of numbers (ints or floats).\n    Returns:\n    - float: The arithmetic mean of the input numbers.\n    Example:\n    >>> calculate_mean([1, 2, 3, 4, 5])\n    3.0\n    >>> calculate_mean([1.5, 2.5, 3.5])\n    2.5\n    \"\"\"\n    return np.mean(numbers)", "def calculate_arithmetic_mean(numbers: List[Union[int, float]]) -> float:\n    \"\"\"\n    Calculate the arithmetic mean of a list of numbers.\n    \n    Parameters:\n    numbers (List[Union[int, float]]): A list of numbers (integers or floats).\n    Returns:\n    float: The arithmetic mean of the numbers.\n    Examples:\n    >>> calculate_arithmetic_mean([1, 2, 3, 4, 5])\n    3.0\n    >>> calculate_arithmetic_mean([2.5, 3.5, 4.5])\n    3.5\n    \"\"\"\n    if not numbers:  # To handle empty list input\n        raise ValueError(\"The list of numbers cannot be empty.\")\n    \n    total_sum = np.sum(numbers)  # Using numpy for stable and efficient summation\n    count = len(numbers)\n    mean = total_sum / count\n    return mean"], ["def calculate_average_speed(total_distance, total_time):\n    \"\"\"\n    Calculate the average speed given total distance and total time.\n    Parameters:\n        total_distance (float): The total distance travelled.\n        total_time (float): The total time spent.\n    Returns:\n        float: Average speed.\n    Examples:\n        >>> calculate_average_speed(150, 3)\n        50.0\n    \"\"\"\n    if total_time == 0:\n        raise ValueError(\"Total time cannot be zero for speed calculation.\")\n    return total_distance / total_time", "def average_speed(total_distance, total_time):\n    \"\"\"\n    Calculate the average speed given total distance and total time.\n    Parameters:\n    total_distance (float): The total distance traveled.\n    total_time (float): The total time taken.\n    Returns:\n    float: Average speed (distance per unit of time).\n    Examples:\n    >>> average_speed(300, 4)\n    75.0\n    \"\"\"\n    if total_time == 0:\n        raise ValueError(\"Total time cannot be zero.\")\n    return total_distance / total_time"], ["def mean_from_expression(expressions: List[str], unknowns: List[str] = None) -> float:\n    \"\"\"\n    Calculate the mean from a set of algebraic expressions, potentially solving for unknowns.\n    Parameters:\n    - expressions (List[str]): A list of algebraic expressions in string form.\n    - unknowns (List[str], optional): A list of unknown variable names as strings.\n    Returns:\n    - float: The calculated mean after resolving any unknown variables.\n    Example:\n    >>> mean_from_expression(['x + 2', '3 + 2x'], unknowns=['x'])\n    5.0 (Assuming x solved to be 1)\n    \"\"\"\n    from sympy import symbols, Eq, solve\n    x = symbols(unknowns or 'x')\n    resolved_expressions = [eval(expr) for expr in expressions]\n    \n    mean_expr = sum(resolved_expressions) / len(resolved_expressions)\n    return float(solve(Eq(mean_expr, 0), x).get(x, mean_expr)) if unknowns else float(mean_expr)"], ["def average(data):\n    \"\"\"\n    Calculate the arithmetic mean of a list of numbers.\n    Parameters:\n    data (list of float or int): A list of numbers.\n    Returns:\n    float: The arithmetic mean of the numbers.\n    Examples:\n    >>> average([10, 20, 30])\n    20.0\n    \"\"\"\n    if not data:\n        return 0  # Avoid division by zero\n    return sum(data) / len(data)"], ["def recalculate_average(current_avg, n, new_elements):\n    \"\"\"\n    Adjust an existing average by adding new elements.\n    \n    Parameters:\n    current_avg (float): Current average of the dataset.\n    n (int): Number of elements in the current dataset.\n    new_elements (list of float or int): New elements added to the dataset.\n    Returns:\n    float: New average including new elements.\n    Examples:\n    >>> recalculate_average(20.0, 3, [40, 50])\n    30.0\n    \"\"\"\n    total_sum = current_avg * n\n    new_sum = sum(new_elements)\n    total_n = n + len(new_elements)\n    new_avg = (total_sum + new_sum) / total_n\n    return new_avg", "def remove_elements_from_average(current_avg, n, removed_elements):\n    \"\"\"\n    Recalculate the average after removing elements from the dataset.\n    Parameters:\n    current_avg (float): Current average of the dataset.\n    n (int): Number of elements in the current dataset.\n    removed_elements (list of float or int): Elements to be removed.\n    \n    Returns:\n    float: New average after removal of elements.\n    Examples:\n    >>> remove_elements_from_average(30.0, 5, [40, 30])\n    26.666666666666668\n    \"\"\"\n    total_sum = current_avg * n\n    removed_sum = sum(removed_elements)\n    remaining_n = n - len(removed_elements)\n    if remaining_n == 0:\n        return 0  # Avoid division by zero\n    new_avg = (total_sum - removed_sum) / remaining_n\n    return new_avg"], ["def solve_for_unknown_in_averages(equation_coeffs):\n    \"\"\"\n    Solve for an unknown in an equation comparing two averages. The equation is of the form:\n    (a1*x + a2*y + ... + an*z)/n = (b1*x + b2*y + ... + bm*w)/m\n    where x, y, z are knowns and one of them is the unknown.\n    Parameters:\n    - equation_coeffs (dict): A dictionary containing:\n      - 'left_terms': list of tuples (coefficient, value/None if unknown)\n      - 'right_terms': list of tuples (coefficient, value/None if unknown)\n    Returns:\n    - dict: Solution for the unknown(s).\n    Examples:\n    >>> solve_for_unknown_in_averages({'left_terms': [(1, 30), (1, None)], 'right_terms': [(1, 20), (1, 25)]})\n    {x: 15.0}\n    \"\"\"\n    x = symbols('x')  # Default symbol for unknown\n    left_terms = equation_coeffs['left_terms']\n    right_terms = equation_coeffs['right_terms']\n    \n    left_expr = sum(coeff * (val if val is not None else x) for (coeff, val) in left_terms)\n    right_expr = sum(coeff * (val if val is not None else x) for (coeff, val) in right_terms)\n    \n    # Form the equation\n    equation = Eq(left_expr / len(left_terms), right_expr / len(right_terms))\n    \n    # Solve the equation\n    solution = solve(equation, x)\n    return solution"], ["def calculate_total_sum(average, count):\n    \"\"\"\n    Calculate the total sum from the average and the number of items.\n    Parameters:\n        average (float): The average of the items.\n        count (int): The number of items.\n    Returns:\n        float: Total sum of all the items.\n    Examples:\n        >>> calculate_total_sum(25.5, 4)\n        102.0\n        >>> calculate_total_sum(100, 5)\n        500\n    \"\"\"\n    return average * count"], ["def calculate_mean_with_rounding(numbers, decimal_places=2):\n    \"\"\"\n    Calculate the arithmetic mean of a collection of numbers and round it to a specified number of decimal places.\n    Parameters:\n    - numbers (iterable of float|int): An iterable collection of numbers (list, tuple, array).\n    - decimal_places (int): Number of decimal places to round the mean to.\n    Return:\n    - float: The rounded arithmetic mean of the input numbers.\n    Example:\n    >>> calculate_mean_with_rounding([10, 20, 30, 40, 50], 1)\n    30.0\n    >>> calculate_mean_with_rounding([1.123, 2.234, 3.345], 2)\n    2.23\n    \"\"\"\n    mean_value = calculate_mean(numbers)\n    return round(mean_value, decimal_places)"], ["def solve_mean_equation(num_list1, num_list2, x_var='x'):\n    \"\"\"\n    Calculate the mean of two lists where one list may contain an algebraic variable, and equate them to solve for the variable.\n    \n    Parameters:\n    - num_list1 (list): The first list of numbers. It can include a sympy.Symbol.\n    - num_list2 (list): The second list of numbers. It can also include a sympy.Symbol.\n    - x_var (str, optional): The variable symbol as a string, default is 'x'.\n    \n    Returns:\n    - dict: Solution of the equation formed by equating the means of two lists.\n    \n    Examples:\n    - Using symbols in one of the lists:\n    >>> x = symbols('x')\n    >>> solve_mean_equation([1, 2, x], [2, 4, 6])\n    {x: 8.0}\n    \"\"\"\n    x = symbols(x_path) if isinstance(x_var, str) else x_var  # Ensure symbol\n    mean1 = sum(num_list1) / len(num_list1)\n    mean2 = sum(num_list2) / len(num_list2)\n    equation = Eq(mean1, mean2)\n    return solve(equation)"], ["def retrieve_total_sum_and_modify_average(original_mean, original_count, subset_sum, new_average):\n    \"\"\"\n    Recalculate total sum and modified averages from subsets, including addition or removal of items.\n    Parameters:\n    original_mean (float): The existing average from the main group.\n    original_count (int): The count of items in the main group.\n    subset_sum (float): The total sum of the subset being analyzed.\n    new_average (float): The target new average after modifying the group.\n    Returns:\n    tuple: A tuple containing the new total sum and the modified mean.\n    Examples:\n    >>> retrieve_total_sum_and_modify_average(3.0, 3, 9, 4.0)\n    (12.0, 4.0)\n    \"\"\"\n    original_total = original_mean * original_count\n    new_total = original_total + subset_sum\n    new_mean = new_average if new_total != 0 else 0\n    return new_total, new_mean"], ["def sum_elements(elements: List[Union[int, float, Fraction]]) -> Union[int, float, Fraction]:\n    \"\"\"\n    Sum a list of numeric elements which could include integers, floats, or fractions.\n    Parameters:\n    - elements (List[Union[int, float, Fraction]]): A list containing numbers including potentially fractions.\n    Returns:\n    - Union[int, float, Fraction]: The sum of the elements, preserving type if fractions are involved.\n    Example:\n    >>> sum_elements([1, 2, 3])\n    6\n    >>> sum_elements([Fraction(1, 2), Fraction(3, 4)])\n    Fraction(5, 4)\n    \"\"\"\n    from fractions import Fraction\n    total = sum(elements, start=Fraction(0))\n    return total if isinstance(total, Fraction) else float(total)"], ["def adjust_mean(current_mean, current_count, new_value, addition=True):\n    \"\"\"\n    Adjust the mean when items are added to or removed from the data set.\n    Parameters:\n    current_mean (float): Current average of the dataset.\n    current_count (int): Number of items in the dataset.\n    new_value (float): The value being added or removed.\n    addition (bool): True if the value is being added, False if being removed.\n    Returns:\n    float: New mean of the dataset.\n    Examples:\n    >>> adjust_mean(3.0, 4, 5, addition=True)\n    3.2\n    >>> adjust_mean(3.2, 5, 5, addition=False)\n    3.0\n    \"\"\"\n    total_sum = current_mean * current_count\n    if addition:\n        total_sum += new_value\n        current_count += 1\n    else:\n        total_sum -= new_value\n        current_count -= 1\n    return total_sum / current_count if current_count > 0 else 0"], ["def calculate_weighted_average(values, weights):\n    \"\"\"\n    Calculate the weighted average of a list of values with corresponding weights.\n    Parameters:\n        values (list): A list of numbers (integers or floats).\n        weights (list): A list of weights (integers or floats) corresponding to each value.\n    Returns:\n        float: The weighted average of the values.\n    Examples:\n        >>> calculate_weighted_average([70, 80, 90], [1, 2, 3])\n        83.33\n    \"\"\"\n    weighted_sum = sum(value * weight for value, weight in zip(values, weights))\n    total_weights = sum(weights)\n    return weighted_sum / total_weights", "def calculate_weighted_average(values, weights):\n    \"\"\"\n    Calculate the weighted average of a list of numbers given corresponding weights.\n    Parameters:\n    values (list or np.array): Values for which the average is to be calculated.\n    weights (list or np.array): Weights corresponding to each value in the values list.\n    Returns:\n    float: The weighted average of the values.\n    Examples:\n    >>> calculate_weighted_average([1, 2, 3], [3, 2, 1])\n    1.8333333333333333\n    \"\"\"\n    return np.average(values, weights=weights)", "def weighted_average(values, weights):\n    \"\"\"\n    Calculate the weighted average of a list of values.\n    Parameters:\n    values (list of float or int): The values for which weighted average is calculated.\n    weights (list of float or int): Weights corresponding to each value.\n    Returns:\n    float: Weighted average of the values.\n    Examples:\n    >>> weighted_average([70, 80, 90], [1, 2, 3])\n    83.33333333333333\n    \"\"\"\n    if not values or not weights or len(values) != len(weights):\n        raise ValueError(\"Values and weights must be lists of the same length with no empty list allowed.\")\n    weighted_sum = sum(v * w for v, w in zip(values, weights))\n    total_weight = sum(weights)\n    return weighted_sum / total_weight"]], "Fractions": [["class FractionTools:\n    \"\"\"A utility class for performing operations on fractions.\"\"\"\n    \n    @staticmethod\n    def simplify_fraction(numer, denom):\n        \"\"\"\n        Simplifies a fraction to its lowest terms.\n        Parameters:\n            numer (int): The numerator of the fraction.\n            denom (int): The denominator of the fraction.\n        Returns:\n            fractions.Fraction: A fraction object representing the simplified fraction.\n        \n        Examples:\n            >>> FractionTools.simplify_fraction(4, 8)\n            Fraction(1, 2)\n        \"\"\"\n        return fractions.Fraction(numer, denom)\n    \n    @staticmethod\n    def add_fractions(frac1, frac2):\n        \"\"\"\n        Adds two fractions.\n        Parameters:\n            frac1 (fractions.Fraction): The first fraction.\n            frac2 (fractions.Fraction): The second fraction.\n        Returns:\n            fractions.Fraction: The sum of the two fractions.\n        Examples:\n            >>> FractionTools.add_fractions(fractions.Fraction(1, 2), fractions.Fraction(1, 3))\n            Fraction(5, 6)\n        \"\"\"\n        return frac1 + frac2\n    @staticmethod\n    def subtract_fractions(frac1, frac2):\n        \"\"\"\n        Subtracts the second fraction from the first.\n        Parameters:\n            frac1 (fractions.Fraction): The first fraction.\n            frac2 (fractions.Fraction): The second fraction.\n        Returns:\n            fractions.Fraction: The result of the subtraction.\n        Examples:\n            >>> FractionTools.subtract_fractions(fractions.Fraction(1, 2), fractions.Fraction(1, 3))\n            Fraction(1, 6)\n        \"\"\"\n        return frac1 - frac2\n    @staticmethod\n    def multiply_fractions(frac1, frac2):\n        \"\"\"\n        Multiplies two fractions.\n        Parameters:\n            frac1 (fractions.Fraction): The first fraction.\n            frac2 (fractions.Fraction): The second fraction.\n        Returns:\n            fractions.Fraction: The product of the two fractions.\n        Examples:\n            >>> FractionTools.multiply_fractions(fractions.Fraction(1, 2), fractions.Fraction(1, 3))\n            Fraction(1, 6)\n        \"\"\"\n        return frac1 * frac2\n    @staticmethod\n    def divide_fractions(frac1, frac2):\n        \"\"\"\n        Divides the first fraction by the second by multiplying by the reciprocal of the second fraction.\n        Parameters:\n            frac1 (fractions.Fraction): The dividend fraction.\n            frac2 (fractions.Fraction): The divisor fraction.\n        Returns:\n            fractions.Fraction: The result of the division.\n        Examples:\n            >>> FractionTools.divide_fractions(fractions.Fraction(1, 2), fractions.Fraction(1, 3))\n            Fraction(3, 2)\n        \"\"\"\n        return frac1 / frac2\n    @staticmethod\n    def convert_to_percentage(frac):\n        \"\"\"\n        Converts a fraction to a percentage.\n        Parameters:\n            frac (fractions.Fraction): The fraction to convert.\n        Returns:\n            float: The percentage representation of the fraction.\n        Examples:\n            >>> FractionTools.convert_to_percentage(fractions.Fraction(1, 4))\n            25.0\n        \"\"\"\n        return float(frac * 100)", "def add_fractions(numer1, denom1, numer2, denom2):\n    \"\"\"\n    Add two fractions and return the result in simplified form.\n    Parameters:\n    numer1 (int), denom1 (int): Numerator and denominator of the first fraction.\n    numer2 (int), denom2 (int): Numerator and denominator of the second fraction.\n    Returns:\n    Fraction: The sum of the two fractions, simplified.\n    Example:\n    >>> str(add_fractions(1, 2, 1, 3))\n    '5/6'\n    \"\"\"\n    return Fraction(numer1, denom1) + Fraction(numer2, denom2)"], ["def operate_fractions(fraction1, fraction2, operation='add'):\n    \"\"\"\n    Perform arithmetic operations on two fractions.\n    \n    Parameters:\n    - fraction1 (str or Fraction): The first fraction as a string (e.g., '1/2') or Fraction object.\n    - fraction2 (str or Fraction): The second fraction as a string (e.g., '1/3') or Fraction object.\n    - operation (str): The operation to perform. Options include 'add', 'subtract', 'multiply', 'divide', 'square1', 'square2'.\n    \n    Returns:\n    - Fraction: The result of the arithmetic operation.\n    \n    Examples:\n    - operate_fractions('1/2', '1/3', 'add') => Fraction(5, 6)\n    - operate_fractions('1/2', '1/3', 'subtract') => Fraction(1, 6)\n    - operate_fractions('1/2', '1/3', 'multiply') => Fraction(1, 6)\n    - operate_fractions('1/2', '1/4', 'divide') => Fraction(2, 1)\n    - operate_fractions('1/2', '1/4', 'square1') => Fraction(1, 4)  # Squares the first fraction\n    - operate_fractions('3/4', '2/5', 'square2') => Fraction(4, 25) # Squares the second fraction\n    \"\"\"\n    f1 = Fraction(fraction1) if not isinstance(fraction1, Fraction) else fraction1\n    f2 = Fraction(fraction2) if not isinstance(fraction2, Fraction) else fraction2\n    \n    operations = {\n        'add': f1 + f2,\n        'subtract': f1 - f2,\n        'multiply': f1 * f2,\n        'divide': f1 / f2,\n        'square1': f1**2,\n        'square2': f2**2\n    }\n    \n    return operations[operation]", "def operate_fractions(frac1, frac2, operation='multiply'):\n    \"\"\"\n    Performs an operation between two fractions. Supports `multiply`, `divide`, \n    `add`, and `subtract` operations and returns the result in its simplest form.\n    Parameters:\n    - frac1 (tuple): A tuple `(numerator, denominator)` representing the first fraction.\n    - frac2 (tuple): A tuple `(numerator, denominator)` representing the second fraction.\n    - operation (str): Type of operation ('multiply', 'divide', 'add', 'subtract').\n    Returns:\n    - Rational: The result of the operation in simplified Rational form.\n    Examples:\n    >>> operate_fractions((1, 2), (3, 4), 'multiply')\n    Rational(3, 8)\n    >>> operate_fractions((1, 2), (3, 4), 'divide')\n    Rational(2, 3)\n    \"\"\"\n    valid_operations = ['multiply', 'divide', 'add', 'subtract']\n    if operation not in valid_operations:\n        raise ValueError(\"Unsupported operation. Choose from 'multiply', 'divide', 'add', 'subtract'.\")\n    r1 = Rational(*frac1)\n    r2 = Rational(*frac2)\n    if operation == 'multiply':\n        result = r1 * r2\n    elif operation == 'divide':\n        result = r1 / r2\n    elif operation == 'add':\n        result = r1 + r2\n    elif operation == 'subtract':\n        result = r1 - r2\n    \n    return result", "def operate_fractions(frac1, frac2, operation):\n    \"\"\"\n    Performs an arithmetic operation on two fractions.\n    Parameters:\n    - frac1 (Fraction): The first fraction.\n    - frac2 (Fraction): The second fraction.\n    - operation (str): The operation to perform ('add', 'subtract', 'multiply', 'divide').\n    Returns:\n    - Fraction: The result of the arithmetic operation.\n    Example:\n    >>> operate_fractions(Fraction(1, 2), Fraction(1, 3), 'add')\n    Fraction(5, 6)\n    \"\"\"\n    if operation == 'add':\n        return frac1 + frac2\n    elif operation == 'subtract':\n        return frac1 - frac2\n    elif operation == 'multiply':\n        return frac1 * frac2\n    elif operation == 'divide':\n        return frac1 / frac2\n    else:\n        raise ValueError(\"Unsupported operation\")", "def operate_fractions(fraction1, fraction2, operation='add'):\n    \"\"\"\n    Perform arithmetic operations on two fractions.\n    Parameters:\n    - fraction1 (str or Fraction): The first fraction in the operation.\n    - fraction2 (str or Fraction): The second fraction in the operation.\n    - operation (str): Type of operation ('add', 'subtract', 'multiply', 'divide').\n    \n    Returns:\n    - Fraction: Result of the operation as a Fraction object.\n    Examples:\n    >>> operate_fractions('1/2', '1/3', 'add')\n    Fraction(5, 6)\n    \n    >>> operate_fractions('1/4', '1/6', 'divide')\n    Fraction(3, 2)\n    \"\"\"\n    f1 = Fraction(fraction1)\n    f2 = Fraction(fraction2)\n    \n    if operation == 'add':\n        return f1 + f2\n    elif operation == 'subtract':\n        return f1 - f2\n    elif operation == 'multiply':\n        return f1 * f2\n    elif operation == 'divide':\n        if f2 == 0:\n            raise ValueError(\"Cannot divide by zero\")\n        return f1 / f2\n    else:\n        raise ValueError(\"Unsupported operation. Choose from 'add', 'subtract', 'multiply', 'divide'.\")", "def perform_fraction_operation(op1, op2, operation='add'):\n    \"\"\"\n    Perform basic arithmetic operations between two fractions.\n    \n    Parameters:\n        op1 (str): The first operand in string format, e.g., '1/2'.\n        op2 (str): The second operand in string format, e.g., '1/3'.\n        operation (str): The operation to perform. Can be 'add', 'subtract', 'multiply', or 'divide'.\n        \n    Returns:\n        str: Result of the operation in string format.\n        \n    Examples:\n    >>> perform_fraction_operation('1/2', '1/3', 'add')\n    '5/6'\n    \n    >>> perform_fraction_operation('1/2', '1/3', 'multiply')\n    '1/6'\n    \"\"\"\n    f1 = Fraction(op1)\n    f2 = Fraction(op2)\n    \n    result = None\n    if operation == 'add':\n        result = f1 + f2\n    elif operation == 'subtract':\n        result = f1 - f2\n    elif operation == 'multiply':\n        result = f1 * f2\n    elif operation == 'divide':\n        result = f1 / f2\n    \n    return str(result)", "def operate_fractions(fraction1, fraction2, operation='add'):\n    \"\"\"\n    Perform arithmetic operations on two fractions.\n    Parameters:\n    - fraction1 (str or Fraction): The first fraction as a string or Fraction instance.\n    - fraction2 (str or Fraction): The second fraction as a string or Fraction instance.\n    - operation (str): The operation to perform ('add', 'subtract', 'multiply', 'divide').\n    Returns:\n    - Fraction: The result of the operation on the two fractions.\n    Examples:\n    >>> operate_fractions('1/3', '1/4', 'add')\n    Fraction(7, 12)\n    >>> operate_fractions('1/2', '1/3', 'multiply')\n    Fraction(1, 6)\n    >>> operate_fractions('3/4', '1/4', 'subtract')\n    Fraction(1, 2)\n    >>> operate_fractions('1/2', '2/3', 'divide')\n    Fraction(3, 4)\n    \"\"\"\n    f1 = Fraction(fraction1)\n    f2 = Fraction(fraction2)\n    if operation == 'add':\n        return f1 + f2\n    elif operation == 'subtract':\n        return f1 - f2\n    elif operation == 'multiply':\n        return f1 * f2\n    elif operation == 'divide':\n        return f1 / f2\n    else:\n        raise ValueError(\"Unsupported operation. Use 'add', 'subtract', 'multiply' or 'divide'.\")", "def operate_fractions(frac1, frac2, operation):\n    \"\"\"Perform arithmetic operations on two fractions.\n    Parameters:\n    frac1 (Fraction): The first fraction.\n    frac2 (Fraction): The second fraction.\n    operation (str): The operation to perform ('add', 'subtract', 'multiply', 'divide').\n    Returns:\n    Fraction: The result of the arithmetic operation.\n    Examples:\n    >>> operate_fractions(Fraction(1, 2), Fraction(1, 3), 'add')\n    Fraction(5, 6)\n    \"\"\"\n    if operation == 'add':\n        return frac1 + frac2\n    elif operation == 'subtract':\n        return frac1 - frac2\n    elif operation == 'multiply':\n        return frac1 * frac2\n    elif operation == 'divide':\n        return frac1 / frac2\n    else:\n        raise ValueError(\"Unsupported operation specified\")", "def operate_fractions(operation, frac1, frac2=None):\n    \"\"\"\n    Perform arithmetic operations on fractions and returns the result as a simplified fraction.\n    Parameters:\n    - operation (str): The arithmetic operation to perform. Supported operations: 'add', 'subtract', 'multiply', 'divide'.\n    - frac1 (str or Fraction): The first fraction. It should be in the form of a string 'numerator/denominator' or a Fraction object.\n    - frac2 (str or Fraction, optional): The second fraction, required for operations other than simplification.\n    Returns:\n    - Fraction: The result of the operation in its simplified form as a Fraction object.\n    Example:\n    >>> operate_fractions('add', '1/2', '1/3')\n    Fraction(5, 6)\n    >>> operate_fractions('multiply', '2/3', '4/5')\n    Fraction(8, 15)\n    \"\"\"\n    frac1 = Fraction(frac1) if isinstance(frac1, str) else frac1\n    \n    result = None\n    if operation == 'add':\n        frac2 = Fraction(frac2) if isinstance(frac2, str) else frac2\n        result = frac1 + frac2\n    elif operation == 'subtract':\n        frac2 = Fraction(frac2) if isinstance(frac2, str) else frac2\n        result = frac1 - frac2\n    elif operation == 'multiply':\n        frac2 = Fraction(frac2) if isinstance(frac2, str) else frac2\n        result = frac1 * frac2\n    elif operation == 'divide':\n        frac2 = Fraction(frac1) if isinstance(frac2, str) else frac2\n        result = frac1 / frac2\n    else:\n        raise ValueError(\"Unsupported operation. Choose from 'add', 'subtract', 'multiply', 'divide'.\")\n    return result", "def operate_fractions(operation: str, *fractions: Tuple[int, int]) -> Fraction:\n    \"\"\"\n    Perform arithmetic operations on fractions. Supports addition, subtraction, multiplication, division and squaring.\n    Parameters:\n    - operation (str): The operation to perform. It can be 'add', 'subtract', 'multiply', 'divide', or 'square'.\n    - fractions (Tuple[int, int]): Variable length argument list of fractions represented as tuples where each tuple is (numerator, denominator).\n    Returns:\n    - Fraction: The result of the operation on the given fractions in its simplest form.\n    Examples:\n    - operate_fractions('add', (1, 2), (3, 4))  -->  Fraction(5, 4)\n    - operate_fractions('multiply', (1, 2), (3, 4))  -->  Fraction(3, 8)\n    - operate_fractions('square', (1, 2))  -->  Fraction(1, 4)\n    Note:\n    - For 'square', only the first fraction is considered.\n    \"\"\"\n    if not fractions:\n        raise ValueError(\"At least one fraction is required\")\n    \n    result = Fraction(*fractions[0])\n    if operation == 'add':\n        for frac in fractions[1:]:\n            result += Fraction(*frac)\n    elif operation == 'subtract':\n        for frac in fractions[1:]:\n            result -= Fraction(*frac)\n    elif operation == 'multiply':\n        for frac in fractions[1:]:\n            result *= Fraction(*frac)\n    elif operation == 'divide':\n        for frac in fractions[1:]:\n            result /= Fraction(*frac)\n    elif operation == 'square':\n        result = result**2\n    else:\n    raise ValueError(\"Unsupported operation. Choose from 'add', 'subtract', 'multiply', 'divide', 'square'.\")\n    \n    return result", "def fraction_arithmetic(*fractions, operation='multiply'):\n    \"\"\"\n    Perform basic arithmetic operations on multiple fractions and simplify the result.\n    Parameters:\n    - fractions (list of str): A list of string representations of fractions or integers.\n    - operation (str): The arithmetic operation to perform. Supported values are 'multiply', 'divide', 'add', 'subtract'.\n    Returns:\n    - Rational: The result of the arithmetic operation in its simplest form.\n    Examples:\n    >>> fraction_arithmetic(\"1/2\", \"1/3\", \"1/4\", operation='multiply')\n    1/24\n    >>> fraction_arithmetic(\"1/2\", \"1/3\", operation='add')\n    5/6\n    >>> fraction_arithmetic(\"1\", \"2/3\", operation='subtract')\n    1/3\n    >>> fraction_arithmetic(\"1/2\", \"1/3\", operation='divide')\n    3/2\n    \"\"\"\n    if not fractions:\n        raise ValueError(\"At least one fraction is required\")\n    # Start with the first fraction\n    result = sympify(fractions[0])\n    \n    for fraction in fractions[1:]:\n        if operation == 'multiply':\n            result *= sympify(fraction)\n        elif operation == 'divide':\n            result /= sympify(fraction)\n        elif operation == 'add':\n            result += sympify(fraction)\n        elif operation == 'subtract':\n            result -= sympify(fraction)\n        else:\n            raise ValueError(f\"Unsupported operation {operation}\")\n    # Simplify the result\n    return result.simplify()"], ["def convert_fraction_decimal_percentage(value, format_type='decimal'):\n    \"\"\"\n    Convert fractions to decimal or percentage and vice versa.\n    Parameters:\n    - value (str or float or Fraction): The input value to convert. This can be a fraction (as a `Fraction` object or string like '3/4'), a decimal (as a float), or a percentage (as a string like '25%').\n    - format_type (str): The format to convert to. Options include 'decimal', 'percentage', and 'fraction'.\n    \n    Returns:\n    - float or Fraction or str: The converted value in the specified format.\n    Examples:\n    - convert_fraction_decimal_percentage('3/4', 'decimal') -> 0.75\n    - convert_fraction_decimal_percentage(0.75, 'fraction') -> Fraction(3, 4)\n    - convert_fraction_decimal_percentage('75%', 'fraction') -> Fraction(3, 4)\n    - convert_fraction_decimal_percentage(Fraction(1, 2), 'percentage') -> '50%'\n    \"\"\"\n    if isinstance(value, str) and '%' in value:\n        value = Fraction(float(value.strip('%')) / 100)\n    elif isinstance(value, (float, int)):\n        value = Fraction(value).limit_denominator()\n    elif isinstance(value, str):\n        value = Fraction(value)\n    if format_type == 'decimal':\n        return float(value)\n    elif format_type == 'percentage':\n        return f\"{float(value) * 100}%\"\n    elif format_type == 'fraction':\n        return value\n    else:\n        raise ValueError(\"Invalid format_type. Choose 'decimal', 'percentage', or 'fraction'.\")", "def fraction_to_decimal(fraction, rounding_digits=None):\n    \"\"\"\n    Convert a fraction to decimal and optionally round it.\n    Parameters:\n    - fraction (str or Fraction): The fraction to convert.\n    - rounding_digits (int, optional): Number of decimal places to round to. If none, no rounding is applied.\n    Returns:\n    - float or int: The decimal representation of the fraction, rounded if specified.\n    Examples:\n    >>> fraction_to_decimal('1/3', 2)\n    0.33\n    \n    >>> fraction_to_encode('4/2')\n    2.0\n    \"\"\"\n    f = Fraction(fraction)\n    decimal_value = float(f)\n    if rounding_digits is not None:\n        return round(decimal_value, rounding_digits)\n    return decimal_value", "def fraction_to_decimal(frac, rounding='hundredth'):\n    \"\"\"\n    Converts a fraction to a decimal and rounds the result to specified precision.\n    Parameters:\n    - frac (str or Fraction): The fraction to convert, in string form 'numerator/denominator' or as a Fraction object.\n    - rounding (str, optional): The rounding precision. Supported values are 'tenth', 'hundredth'.\n    Returns:\n    - float: The decimal equivalent of the fraction rounded to the specified precision.\n    Example:\n    >>> fraction_to_decimal('1/2', rounding='tenth')\n    0.5\n    >>> fraction_to_registration('1/3', rounding='hundredth')\n    0.33\n    \"\"\"\n    frac = Fraction(frac) if isinstance(frac, str) else frac\n    decimal_value = float(frac)\n    if rounding == 'hundredth':\n        return round(decimal_value, 2)\n    elif rounding == 'tenth':\n        return round(decimal_value, 1)\n    else:\n        raise ValueError(\"Unsupported rounding precision. Choose from 'tenth', 'hundredth'.\")\n    return decimal_value"], ["def add_fractions(fraction1, fraction2):\n    \"\"\"\n    Add two fractions and return the result in simplest form.\n    Parameters:\n    - fraction1 (Fraction): The first fraction.\n    - fraction2 (Fraction): The second fraction.\n    Returns:\n    - Fraction: Sum of the two fractions, in simplest form.\n    Examples:\n    >>> add_fractions(Fraction(1, 2), Fraction(1, 3))\n    Fraction(5, 6)\n    \"\"\"\n    return (fraction1 + fraction2).limit_denominator()", "def multiply_fractions(fraction1, fraction2):\n    \"\"\"\n    Multiply two fractions and return the result in simplest form.\n    Parameters:\n    - fraction1 (Fraction): The first fraction.\n    - fraction2 (Fraction): The second fraction.\n    Returns:\n    - Fraction: Product of the two fractions, in simplest form.\n    Examples:\n    >>> multiply_fractions(Fraction(1, 2), Fraction(2, 3))\n    Fraction(1, 3)\n    \"\"\"\n    return (fraction1 * fraction2).limit_denominator()", "def add_fractions(fraction1, fraction2):\n    \"\"\"\n    Add two fractions and return the result in its simplest form.\n    Parameters:\n    - fraction1 (Fraction): The first fraction.\n    - fraction2 (Fraction): The second fraction.\n    Returns:\n    - Fraction: The sum of the two fractions, simplified.\n    Examples:\n    - add_fractions(Fraction(1, 2), Fraction(1, 3)) -> Fraction(5, 6)\n    \"\"\"\n    return (fraction1 + fraction2).limit_denominator()", "def add_fractions(frac1, frac2):\n    \"\"\"Add two fractions and return the result in the simplest form.\n    \n    Parameters:\n    - frac1, frac2 (Fraction): Fractions to be summed.\n    \n    Returns:\n    - Fraction: The sum of frac1 and frac2 in the simplest form.\n    \n    Examples:\n    >>> add_fractions(Fraction(1, 2), Fraction(1, 3))\n    Fraction(5, 6)\n    \"\"\"\n    return (frac1 + frac2).limit_denominator()", "def subtract_fractions(frac1, frac2):\n    \"\"\"Subtract the second fraction from the first and return the result in the simplest form.\n    \n    Parameters:\n    - frac1, frac2 (Fraction): Fractions to be subtracted (frac1 - frac2).\n    \n    Returns:\n    - Fraction: The result of frac1 - frac2 in the simplest form.\n    \n    Examples:\n    >>> subtract_fractions(Fraction(3, 4), Fraction(1, 2))\n    Fraction(1, 4)\n    \"\"\"\n    return (frac1 - frac2).limit_denominator()", "def multiply_fractions(frac1, frac2):\n    \"\"\"Multiply two fractions and return the result in the simplest form.\n    \n    Parameters:\n    - frac1, frac2 (Fraction): Fractions to be multiplied.\n    \n    Returns:\n    - Fraction: The product of frac1 and frac2 in the simplest form.\n    \n    Examples:\n    >>> multiply_fractions(Fraction(2, 3), Fraction(4, 5))\n    Fraction(8, 15)\n    \"\"\"\n    return (frac1 * frac2).limit_denominator()", "def add_fractions(frac1, frac2):\n    \"\"\"\n    Adds two fractions and returns the result in the simplest form.\n    \n    Parameters:\n        frac1 (Fraction or str or tuple): The first fraction to add, can be a Fraction instance, string like '1/2', or tuple (1, 2).\n        frac2 (Fraction or str or tuple): The second fraction to add, similar format as frac1.\n    \n    Returns:\n        Fraction: The sum of frac1 and frac2, simplified.\n    \n    Example:\n        >>> add_fractions('1/4', '2/3')\n        Fraction(11, 12)\n    \"\"\"\n    return Fraction(frac1) + Fraction(frac2)", "def subtract_fractions(frac1, frac2):\n    \"\"\"\n    Subtracts the second fraction from the first and returns the result in its simplest form.\n    Parameters:\n        frac1 (Fraction or str or tuple): The first fraction (minuend), similar format as in add_fractions.\n        frac2 (Fraction or str or tuple): The second fraction (subtrahend), similar format.\n    \n    Returns:\n        Fraction: The result of subtraction, simplified.\n    Example:\n        >>> subtract_fractions('3/4', '1/2')\n        Fraction(1, 4)\n    \"\"\"\n    return Fraction(frac1) - Fraction(frac2)", "def multiply_fractions(frac1, frac2):\n    \"\"\"\n    Multiplies two fractions and returns the result in its simplest form.\n    Parameters:\n        frac1 (Fraction or str or tuple): The first fraction, similar format as in add_fractions.\n        frac2 (Fraction or str or tuple): The second fraction, similar format.\n    \n    Returns:\n        Fraction: The product of frac1 and frac2, simplified.\n    Example:\n        >>> multiply_fractions('1/4', '2/3')\n        Fraction(1, 6)\n    \"\"\"\n    return Fraction(frac1) * Fraction(frac2)", "def divide_fractions(frac1, frac2):\n    \"\"\"\n    Divides the first fraction by the second (multiplication by the reciprocal) and returns the result in its simplest form.\n    Parameters:\n        frac1 (Fraction or str or tuple): The dividend, similar format as in add_fractions.\n        frac2 (Fraction or str or tuple): The divisor, similar format.\n    \n    Returns:\n        Fraction: The quotient of frac1 and frac2, simplified.\n    Example:\n        >>> divide_fractions('1/2', '1/4')\n        Fraction(2, 1)\n    \"\"\"\n    return Fraction(frac1) / Fraction(frac2)", "def multiply_fractions(frac1, frac2):\n    \"\"\"\n    Multiply two fractions.\n    Parameters:\n    frac1 (Fraction): The first fraction.\n    frac2 (Fraction): The second fraction.\n    Returns:\n    Fraction: The result of the multiplication in its simplest form.\n    Examples:\n    >>> multiply_fractions(Fraction(1, 2), Fraction(3, 4))\n    Fraction(3, 8)\n    \"\"\"\n    return frac1 * frac2", "def divide_fractions(frac1, frac2):\n    \"\"\"\n    Divide the first fraction by the second fraction.\n    Parameters:\n    frac1 (Fraction): The numerator fraction.\n    frac2 (Fraction): The denominator fraction.\n    Returns:\n    Fraction: The result of the division in its simplest form.\n    Examples:\n    >>> divide_fractions(Fraction(1, 2), Fraction(1, 4))\n    Fraction(2, 1)\n    \"\"\"\n    return frac1 / frac2", "def add_fractions(fraction1, fraction2):\n    \"\"\"\n    Adds two fractions and returns the result in simplest form.\n    Parameters:\n        fraction1 (Fraction): First fraction to add.\n        fraction2 (Fraction): Second fraction to add.\n    \n    Returns:\n        Fraction object: The sum of the two fractions in simplified form.\n    Examples:\n        >>> add_fractions(Fraction(1, 2), Fraction(1, 4))\n        Fraction(3, 4)\n    \"\"\"\n    result = fraction1 + fraction2\n    return simplify_fraction(result.numerator, result.denominator)", "def subtract_fractions(fraction1, fraction2):\n    \"\"\"\n    Subtracts the second fraction from the first and returns the result in simplest form.\n    Parameters:\n        fraction1 (Fraction): Fraction from which to subtract.\n        fraction2 (Fraction): Fraction to subtract.\n    \n    Returns:\n        Fraction object: The difference of the two fractions in simplified form.\n    Examples:\n        >>> subtract_fractions(Fraction(1, 2), Fraction(1, 4))\n        Fraction(1, 4)\n    \"\"\"\n    result = fraction1 - fraction2\n    return simplify_fraction(result.numerator, result.denominator)", "def multiply_fractions(fraction1, fraction2):\n    \"\"\"\n    Multiplies two fractions and returns the product in simplest form.\n    Parameters:\n        fraction1 (Fraction): First fraction to multiply.\n        fraction2 (Fraction): Second fraction to multiply.\n    \n    Returns:\n        Fraction object: The product of the two fractions in simplified form.\n    Examples:\n        >>> multiply_fractions(Fraction(1, 2), Fraction(2, 3))\n        Fraction(1, 3)\n    \"\"\"\n    result = fraction1 * fraction2\n    return simplify_fraction(result.numerator, result.denominator)"], ["def simplify_fraction(numerator, denominator):\n    \"\"\"\n    Simplify a fraction using the greatest common divisor (GCD).\n    Parameters:\n    - numerator (int): The numerator of the fraction.\n    - denominator (int): The denominator of the fraction.\n    Returns:\n    - Fraction: The simplified fraction.\n    Examples:\n    >>> simplify_fraction(8, 12)\n    Fraction(2, 3)\n    \"\"\"\n    common_divisor = math.gcd(numerator, denominator)\n    return Fraction(numerator // common_divisor, denominator // common_divisor)", "def simplify_fraction(numerator, denominator):\n    \"\"\"\n    Simplifies a fraction and returns it in numerator and denominator form.\n    \n    Parameters:\n        numerator (int): the numerator of the fraction.\n        denominator (int): the denominator of the fraction.\n    \n    Returns:\n        tuple: a tuple containing the simplified numerator and denominator.\n    \n    Examples:\n        >>> simplify_fraction(2, 4)\n        (1, 2)\n    \"\"\"\n    simplified_fraction = Fraction(numerator, denominator)\n    return simplified_fraction.numerator, simplified_fraction.denominator", "def simplify_fraction(numerator, denominator):\n    \"\"\"\n    Simplifies a fraction to its simplest form using the Rational module from sympy.\n    Parameters:\n    - numerator (int or float): The numerator of the fraction.\n    - denominator (int or float): The denominator of the fraction.\n    Returns:\n    - tuple (Rational, str): A tuple containing the simpler Rational form of the fraction, \n      and a string representation of the fraction.\n    Examples:\n    >>> simplify_fraction(15, 35)\n    (Rational(3, 7), '3/7')\n    \"\"\"\n    if denominator == 0:\n        raise ValueError(\"Denominator cannot be zero.\")\n    \n    simplified_form = Rational(numerator, denominator)\n    return simplified_form, str(simplified_form)", "def simplify_fraction(numerator, denominator):\n    \"\"\"\n    Simplifies a fraction using the greatest common divisor.\n    \n    Parameters:\n    numerator (int): The numerator of the fraction.\n    denominator (int): The denominator of the fraction.\n    \n    Returns:\n    tuple: A tuple representing the simplified fraction (numerator, denominator).\n    \n    Examples:\n    >>> simplify_fraction(8, 24)\n    (1, 3)\n    >>> simplify_fraction(18, 27)\n    (2, 3)\n    \"\"\"\n    gcd = math.gcd(numerator, denominator)\n    return (numerator // gcd, denominator // gcd)", "def simplify_fraction(numerator, denominator):\n    \"\"\"\n    Simplify a fraction to its lowest terms.\n    Parameters:\n    numerator (int, float): The numerator of the fraction.\n    denominator (int, float): The denominator of the fraction.\n    Returns:\n    Fraction: The fraction in its simplest form.\n    Examples:\n    >>> simplify_fraction(8, 24)\n    Fraction(1, 3)\n    >>> simplify_fraction(-10, -20)\n    Fraction(1, 2)\n    \"\"\"\n    return Fraction(numerator, denominator)", "def simplify_fraction(numerator, denominator):\n    \"\"\"\n    Simplifies a fraction given its numerator and denominator.\n    Parameters:\n        numerator (int): The top number of the fraction.\n        denominator (int): The bottom number of the fraction.\n    \n    Returns:\n        Fraction object: The simplified fraction.\n    Examples:\n        >>> simplify_fraction(8, 20)\n        Fraction(2, 5)\n    \"\"\"\n    common_divisor = gcd(numerator, denominator)\n    return Fraction(numerator // common_divisor, denominator // common_divisor)", "def simplify_fraction(numerator, denominator):\n    \"\"\"\n    Simplify a fraction using the greatest common divisor.\n    Parameters:\n    numerator (int): the numerator of the fraction.\n    denominator (int): the denominator of the fractions.\n    Returns:\n    Fraction: A simplified fraction.\n    Example:\n    >>> str(simplify_fraction(8, 20))\n    '2/5'\n    \"\"\"\n    common_divisor = math.gcd(numerator, denominator)\n    return Fraction(numerator // common_divisor, denominator // common_divisor)", "def simplify_fraction(numerator, denominator):\n    \"\"\"\n    Simplifies a fraction using the greatest common divisor.\n    Parameters:\n    - numerator (int): The numerator of the fraction.\n    - denominator (int): The denominator of the fraction.\n    \n    Returns:\n    - (int, int): A tuple of the simplified numerator and denominator.\n    \n    Examples:\n    >>> simplify_fraction(8, 20)\n    (2, 5)\n    \"\"\"\n    common_divisor = gcd(numerator, denominator)\n    return (numerator // common_divisor, denominator // common_divisor)"], ["def simplify_fraction(fraction):\n    \"\"\"Simplify the given fraction.\n    Parameters:\n    fraction (Fraction): The fraction to simplify.\n    Returns:\n    Fraction: The simplified fraction.\n    \n    Examples:\n    >>> simplify_fraction(Fraction(10, 20))\n    Fraction(1, 2)\n    \"\"\"\n    return fraction.simplify()"], ["def simplify_complex_fraction(expression):\n    \"\"\"\n    Simplifies complex fractions which can include variables, powers, or roots.\n    Parameters:\n    expression (str): A string representing the complex fraction or mathematical expression.\n    Returns:\n    sp.Expr: The simplified expression.\n    Examples:\n    >>> simplify_complex_fraction('1/2 + 1/3')\n    '5/6'\n    >>> simplify_complex_fraction('(1/2)*(1/3) / (1/4)')\n    '2/3'\n    \"\"\"\n    expr = sp.sympify(expression)\n    return sp.simplify(expr)", "def simplify_fraction(expression):\n    \"\"\"\n    Simplifies a fraction, including complex fractional expressions.\n    Parameters:\n    - expression (str): A string representing the fraction or mathematical expression that involves fractions.\n    Returns:\n    - Rational or Expr: The simplified fraction or expression as a SymPy Rational object if purely fractional, otherwise more general SymPy expression.\n    Examples:\n    >>> simplify_fraction(\"1/2 + 1/3\")\n    5/6\n    >>> simplify_fraction(\"(1/2) / (3/4)\")\n    2/3\n    >>> simplify_fraction(\"8/4\")\n    2\n    \"\"\"\n    # Convert the input expression to a sympy expression\n    expr = sympify(expression)\n    # Simplify the expression\n    simplified_expr = expr.simplify()\n    return simplified_expr"], ["def fraction_to_percentage(frac):\n    \"\"\"\n    Converts a fraction to a percentage format.\n    Parameters:\n        frac (Fraction or str or tuple): The fraction to convert, similar format as in simplify_fraction.\n    \n    Returns:\n        float: The numeric value of the fraction expressed as a percentage.\n    Example:\n        >>> fraction_to_percentage('1/2')\n        50.0\n    \"\"\"\n    return float(Fraction(frac) * 100)", "def percentage_to_fraction(percentage):\n    \"\"\"\n    Converts a percentage value to a simplified fraction.\n    \n    Parameters:\n    percentage (float): The percentage value.\n    \n    Returns:\n    Fraction: The simplified fraction representing the percentage.\n    \n    Examples:\n    >>> percentage_to_fraction(50)\n    Fraction(1, 2)\n    >>> percentage_to_fraction(75)\n    Fraction(3, 4)\n    \"\"\"\n    return Fraction(percentage, 100).limit_denominator()", "def percentage_to_fraction(percentage):\n    \"\"\"\n    Convert a percentage to a fraction.\n    Parameters:\n    percentage (float): The percentage value to convert.\n    Returns:\n    Fraction: A simplified fraction representation of the percentage.\n    Example:\n    >>> str(percentage_to_fraction(25))\n    '1/4'\n    \"\"\"\n    return Fraction(percentage, 100).limit_denominator()"], ["def mixed_to_improper(whole, numerator, denominator):\n    \"\"\"\n    Convert a mixed number to an improper fraction.\n    Parameters:\n    - whole (int): The whole part of the mixed number.\n    - numerator (int): The numerator part of the fractional component of the mixed number.\n    - denominator (int): The denominator of the fractional component of the mixed number.\n    Returns:\n    - Fraction: An improper fraction equivalent to the mixed number.\n    Examples:\n    >>> mixed_to_improper(3, 1, 2)\n    Fraction(7, 2)\n    >>> mixed_to_improper(2, 3, 4)\n    Fraction(11, 4)\n    \"\"\"\n    return whole * denominator + numerator / denominator", "def improper_to_mixed(fraction):\n    \"\"\"\n    Convert an improper fraction to a mixed number.\n    Parameters:\n    - fraction (Fraction): An improper fraction.\n    Returns:\n    - tuple: A tuple of (whole, numerator, denominator) representing the mixed number.\n    Examples:\n    >>> improper_to_mixed(Fraction(7, 2))\n    (3, 1, 2)\n    >>> improper_to_mixed(Fraction(11, 4))\n    (2, 3, 4)\n    \"\"\"\n    whole = int(fraction.numerator / fraction.denominator)\n    numerator = fraction.numerator % fraction.denominator\n    return (whole, numerator, fraction.denominator)", "def to_improper_fraction(mixed_num):\n    \"\"\"Convert a mixed number into an improper fraction.\n    \n    Parameters:\n    - mixed_num (str): Mixed number as a string (e.g., '3 1/2').\n    \n    Returns:\n    - Fraction: The improper fraction form of the mixed number.\n    \n    Examples:\n    >>> to_improper_fraction('3 1/2')\n    Fraction(7, 2)\n    \"\"\"\n    whole, frac_part = mixed_num.split()\n    whole = int(whole)\n    frac = Fraction(frac_part)\n    return Fraction(whole * frac.denominator + frac.numerator, frac.denominator", "def mixed_to_improper(whole, numerator, denominator):\n    \"\"\"\n    Converts a mixed number to an improper fraction.\n    Parameters:\n    - whole (int): The whole number part of the mixed number.\n    - numerator (int): The numerator of the fractional part.\n    - denominator (int): The denominator of the fractional part.\n    Returns:\n    - Fraction: The improper fraction representation.\n    Example:\n    >>> mixed_to_improper(3, 1, 2)\n    Fraction(7, 2)\n    \"\"\"\n    return Fraction(whole * denominator + numerator, denominator)", "def improper_to_mixed(fraction):\n    \"\"\"\n    Converts an improper fraction to a mixed number.\n    Parameters:\n    - fraction (Fraction): The improper fraction to convert.\n    Returns:\n    - tuple: A tuple representing the mixed number (whole, numerator, denominator).\n    Example:\n    >>> improper_to_mixed(Fraction(7, 2))\n    (3, 1, 2)\n    \"\"\"\n    whole = fraction.numerator // fraction.denominator\n    numerator = fraction.numerator % fraction.denominator\n    denominator = fraction.denominator\n    return (whole, numerator, denominator)", "def mixed_to_improper(whole, numerator, denominator):\n    \"\"\"Convert mixed number to an improper fraction.\n    Parameters:\n    whole (int): The whole number part of the mixed number.\n    numerator (int): The numerator of the mixed number.\n    denominator (int): The denominator of the mixed number.\n    Returns:\n    Fraction: The improper fraction equivalent to the input mixed number.\n    \n    Examples:\n    >>> mixed_to_improper(3, 1, 2)\n    Fraction(7, 2)\n    \"\"\"\n    return Fraction(whole * denominator + numerator, denominator)", "def improper_to_mixed(fraction):\n    \"\"\"Convert an improper fraction to a mixed number.\n    Parameters:\n    fraction (Fraction): The improper fraction to convert.\n    Returns:\n    tuple: A tuple (whole, numerator, denominator), representing the mixed number.\n    \n    Examples:\n    >>> improper_to_mixed(Fraction(7, 2))\n    (3, 1, 2)\n    \"\"\"\n    whole = fraction.numerator // fraction.denominator\n    new_numerator = fraction.numerator % fraction.denominator\n    return (whole, new_numerator, fraction.denominator)"], ["def fraction_to_degrees(fraction):\n    \"\"\"\n    Convert a fraction of an hour to degrees (considering a full circle is 360 degrees).\n    Parameters:\n    - fraction (Fraction): The fraction of an hour.\n    Returns:\n    - float: The equivalent in degrees.\n    Examples:\n    - fraction_to_degrees(Fraction(1, 12)) -> 30.0 (indicating 1/12th of an hour equals 30 degrees on a clock face)\n    \"\"\"\n    return float(fraction * 360)", "def fraction_of_hour_to_degrees(numerator, denominator):\n    \"\"\"\n    Converts a fraction of an hour to corresponding degrees.\n    \n    Parameters:\n    numerator (int): The numerator of the fraction representing part of an hour.\n    denominator (int): The denominator of the fraction.\n    \n    Returns:\n    float: Degrees corresponding to the fraction of an hour.\n    \n    Examples:\n    >>> fraction_of_hour_to_degrees(1, 2)\n    180.0\n    >>> fraction_of_hour_to_degrees(1, 4)\n    90.0\n    \"\"\"\n    fraction_hour = simplify_fraction(numerator, denominator)\n    return (fraction_hour[0] / fraction_hour[1]) * 360"], ["def find_common_denominator(fraction1, fraction2):\n    \"\"\"\n    Finds a common denominator for two fractions and returns them as fractions\n    with the common denominator.\n    Parameters:\n        fraction1 (Fraction): First fraction.\n        fraction2 (Fraction): Second fraction.\n    \n    Returns:\n        tuple: Tuple of two Fractions with a common denominator.\n    Examples:\n        >>> find_common_denominator(Fraction(1, 2), Fraction(1, 3))\n        (Fraction(3, 6), Fraction(2, 6))\n    \"\"\"\n    lcm_denominator = (fraction1.denominator * fraction2.denominator) // gcd(fraction1.denominator, fraction2.denominator)\n    new_fraction1 = Fraction(fraction1.numerator * (lcm_denominator // fraction1.denominator), lcm_denominator)\n    new_fraction2 = Fraction(fraction2.numerator * (lcm_denominator // fraction2.denominator), lcm_denominator)\n    return (new_fraction1, new_fraction2)", "def find_common_denominator(*fractions):\n    \"\"\"\n    Finds a common denominator for a collection of fractions.\n    Parameters:\n    - fractions (list of tuple): A list of fractions represented as (numerator, denominator).\n    \n    Returns:\n    - int: The common denominator for all fractions.\n    \n    Examples:\n    >>> find_common_denominator((1, 2), (3, 4), (5, 6))\n    12\n    \"\"\"\n    denominators = [frac[1] for frac in fractions]\n    return np.lcm.reduce(denominators)"], ["def factorial_fraction_reduction(numerator, denominator):\n    \"\"\"\n    Reduces a fraction which involves factorials in the numerator and/or the denominator.\n    Parameters:\n    numerator (str): The factorial expression for the numerator.\n    denominator (str): The factorial expression for the denominator.\n    Returns:\n    sp.Expr: The reduced form of the expression.\n    Examples:\n    >>> factorial_fraction_reduction('5!', '3!')\n    '20'\n    >>> factorial_fraction_reduction('10!', '8!')\n    '90'\n    \"\"\"\n    num_fact = sp.factorial(sp.sympify(numerator[:-1])) if '!' in numerator else sp.sympify(numerator)\n    denom_fact = sp.factorial(sp.sympify(denominator[:-1])) if '!' in denominator else sp.sympify(denominator)\n    return sp.simplify(num_fact / denom_fact)"], ["def simplify_with_roots(expression):\n    \"\"\"\n    Simplifies expressions that include roots.\n    Parameters:\n    expression (str): A string expression that might include roots, e.g., sqrt(x), x**(1/3), etc.\n    Returns:\n    sp.Expr: The simplified expression with roots.\n    Examples:\n    >>> simplify_with_roots('sqrt(8)')\n    '2*sqrt(2)'\n    >>> simplify_with_roots('x**(1/3) * x**(2/3)')\n    'x'\n    \"\"\"\n    expr = sp.sympify(expression)\n    return sp.simplify(expr)"], ["def to_fraction(phrase):\n    \"\"\"\n    Converts a mathematical phrase indicative of fractions into a Fraction object.\n    Parameters:\n        phrase (str): A string that represents a fraction, e.g., \"four-thirds\".\n    \n    Returns:\n        Fraction object: The fraction represented by the phrase.\n    Examples:\n        >>> to_fraction(\"four-thirds\")\n        Fraction(4, 3)\n    \n    Note:\n        This function is simplified for demonstrative purposes and may require extended implementation.\n    \"\"\"\n    # Implementation depends on the complexity and variety of phrases encountered.\n    # Using basic mappings for demonstration:\n    word_to_number = {\n        \"one\": 1, \"two\": 2, \"three\": 3, \"four\": 4, \"five\": 5,\n        \"six\": 6, \"seven\": 7, \"eight\": 8, \"nine\": 9, \"ten\": 10,\n        \"half\": 1/2, \"third\": 1/3, \"quarter\": 1/4\n    }\n    parts = phrase.split('-')\n    return Fraction(word_to_number[parts[0]], word_to_number[parts[1]] if len(parts) > 1 else 1)"], ["def calculate_probability(frac):\n    \"\"\"\n    Calculates the probability expressed by a fraction.\n    Parameters:\n        frac (Fraction or str or tuple): The fraction representing the probability, similar format as in simplify_fraction.\n    \n    Returns:\n        float: The numeric value of the probability.\n    Example:\n        >>> calculate_probability('1/4')\n        0.25\n    \"\"\"\n    return float(Fraction(frac))"], ["def find_lcm(a, b):\n    \"\"\"Compute least common multiple of two numbers.\n    \n    Parameters:\n    - a, b (int): Integers to find the LCM of.\n    \n    Returns:\n    - int: Least common multiple of a and b.\n    \n    Examples:\n    >>> find_lcm(6, 8)\n    24\n    \"\"\"\n    return a * b // gcd(a, b)"], ["def complex_fraction(frac):\n    \"\"\"\n    Simplifies fractions where numerator or denominator can be an expression involving factorials or square roots.\n    Parameters:\n    - frac (tuple): The fraction where elements can be integers or sympy expressions.\n    Returns:\n    - Rational: The simplified fraction.\n    Examples:\n    >>> operate_fractions((factorial(5), factorial(3)), (sqrt(9), factorial(2)), 'multiply')\n    Rational(20, 1)  # 5! / 3! * sqrt(9) / 2! = 20\n    \"\"\"\n    simplified_numerator = factorial(frac[0]) if isinstance(frac[0], int) else sqrt(frac[0])\n    simplified_denominator = factorial(frac[1]) if isinstance(frac[1], int) else sqrt(frac[1])\n    return simplified_numerator / simplified_denominator"], ["def fraction_to_decimal(numerator, denominator):\n    \"\"\"\n    Converts a fraction to its decimal form.\n    \n    Parameters:\n        numerator (int): the numerator of the fraction.\n        denominator (int): the denominator of the fraction.\n    \n    Returns:\n        float: decimal representation of the fraction.\n        \n    Examples:\n        >>> fraction_to_decimal(1, 2)\n        0.5\n    \"\"\"\n    return numerator / denominator", "def fraction_to_decimal(numerator, denominator):\n    \"\"\"\n    Converts a fraction represented by numerator and denominator to a decimal.\n    \n    Parameters:\n    numerator (int): The numerator of the fraction.\n    denominator (int): The denominator of the fraction.\n    \n    Returns:\n    float: The decimal representation of the fraction.\n    \n    Examples:\n    >>> fraction_to_decimal(1, 2)\n    0.5\n    >>> fraction_to_decimal(3, 4)\n    0.75\n    \"\"\"\n    return numerator / denominator", "def fraction_to_percentage(numerator, denominator):\n    \"\"\"\n    Converts a fraction to a percentage.\n    \n    Parameters:\n    numerator (int): The numerator of the fraction.\n    denominator (int): The denominator of the fraction.\n    \n    Returns:\n    float: The percentage representation of the fraction.\n    \n    Examples:\n    >>> fraction_to_percentage(1, 2)\n    50.0\n    >>> fraction_to_percentage(3, 4)\n    75.0\n    \"\"\"\n    return (numerator / denominator) * 100", "def fraction_to_decimal(numerator, denominator):\n    \"\"\"\n    Convert a fraction represented by numerator and denominator to a decimal.\n    Parameters:\n    numerator (int): the numerator of the fraction.\n    denominator (int): the denominator of the fraction.\n    Returns:\n    float: Decimal representation of the fraction.\n    Example:\n    >>> fraction_to_decimal(1, 2)\n    0.5\n    \"\"\"\n    return numerator / denominator", "def fraction_to_percentage(numerator, denominator):\n    \"\"\"\n    Convert a fraction to a percentage.\n    Parameters:\n    numerator (int): the numerator of the fraction.\n    denominator (int): the denominator of the fraction.\n    Returns:\n    float: Percentage representation of the fraction.\n    Example:\n    >>> fraction_to_percentage(1, 4)\n    25.0\n    \"\"\"\n    return (numerator / denominator) * 100"], ["def simplify_fraction(frac):\n    \"\"\"\n    Simplifies a fraction to its lowest terms.\n    Parameters:\n        frac (Fraction or str or tuple): The fraction to simplify, can be a Fraction instance, string like '10/20', or tuple (10, 20).\n    \n    Returns:\n        Fraction: The fraction in its simplest form.\n    Example:\n        >>> simplify_fraction('10/20')\n        Fraction(1, 2)\n    \"\"\"\n    return Fraction(frac).limit_denominator()", "def simplify_fraction(fraction):\n    \"\"\"\n    Simplifies a fraction to its lowest terms.\n    Parameters:\n    - fraction (str or Fraction): The fraction to simplify expressed as a string or Fraction instance.\n    Returns:\n    - Fraction: The simplified fraction.\n    Examples:\n    >>> simplify_fraction('8/24')\n    Fraction(1, 3)\n    >>> simplify_fraction('10/100')\n    Fraction(1, 10)\n    \"\"\"\n    return Fraction(fraction).limit_denominator()"], ["def reciprocal_fraction(frac):\n    \"\"\"\n    Calculates the reciprocal of a given fraction (inverse).\n    Parameters:\n        frac (Fraction or str or tuple): The fraction to invert, similar format as in simplify_fraction.\n    \n    Returns:\n        Fraction: The reciprocal of the given fraction.\n    Example:\n        >>> reciprocal_fraction('1/4')\n        Fraction(4, 1)\n    \"\"\"\n    frac = Fraction(frac)\n    if frac.numerator == 0:\n        raise ValueError(\"Reciprocal does not exist for zero numerator.\")\n    return Fraction(frac.denominator, frac.numerator)"], ["def simplify_fraction(frac):\n    \"\"\"Simplify a fraction to its simplest form using GCD.\n    \n    Parameters:\n    - frac (Fraction): Fraction to be simplified.\n    \n    Returns:\n    - Fraction: The fraction in its simplest form.\n    \n    Examples:\n    >>> simplify_fraction(Fraction(36, 48))\n    Fraction(3, 4)\n    \"\"\"\n    common_divisor = gcd(frac.numerator, frac.denominator)\n    return Fraction(frac.numerator // common_divisor, frac.denominator // common_divisor)"], ["def decimal_to_fraction(decimal_number):\n    \"\"\"\n    Converts a decimal number to its simplest fraction form using the Fraction library.\n    \n    Parameters:\n    decimal_number (float): The decimal number to convert.\n    \n    Returns:\n    Fraction: The fraction object representing the simplified fraction.\n    \n    Examples:\n    >>> decimal_to_fraction(0.5)\n    Fraction(1, 2)\n    >>> decimal_to_fraction(0.75)\n    Fraction(3, 4)\n    \"\"\"\n    return Fraction(decimal_number).limit_denominator()", "def decimal_to_fraction(decimal):\n    \"\"\"Convert a decimal number to a simplified fraction.\n    \n    Parameters:\n    decimal (float): The decimal number to convert.\n    Returns:\n    Fraction: The fraction representation of the decimal.\n    \n    Examples:\n    >>> decimal_to_fraction(0.5)\n    Fraction(1, 2)\n    \"\"\"\n    return Fraction(decimal).limit_denominator()", "def decimal_to_fraction(decimal):\n    \"\"\"\n    Convert a decimal to a Fraction.\n    Parameters:\n    decimal (float): Decimal value to convert.\n    Returns:\n    Fraction: A simplified fraction representation of the decimal.\n    Example:\n    >>> str(decimal_to_fraction(0.5))\n    '1/2'\n    \"\"\"\n    return Fraction(decimal).limit_denominator()"], ["def fraction_arithmetic(a, b, operation='+'):\n    \"\"\"\n    Performs arithmetic operations on two fractions. Supported operations are addition, subtraction, multiplication, and division.\n    \n    Parameters:\n    - a (tuple): The first fraction represented as (numerator, denominator).\n    - b (tuple): The second fraction represented as (numerator, denominator).\n    - operation (str): The operation to perform ('+', '-', '*', '/').\n    \n    Returns:\n    - (int, int): The resulting fraction, after performing the operation and simplification.\n    \n    Examples:\n    >>> fraction_arithmetic((1, 3), (1, 6), '+')\n    (1, 2)\n    >>> fraction_arithmetic((1, 3), (1, 3), '*')\n    (1, 9)\n    \"\"\"\n    num_a, den_a = a\n    num_b, den_b = b\n    if operation == '+':\n        common_den = np.lcm(den_a, den_b)\n        num_a *= common_den // den_a\n        num_b *= common_den // den_b\n        result_num = num_a + num_b\n    elif operation == '-':\n        common_den = np.lcm(den_a, den_b)\n        num_a *= common_den // den_a\n        num_b *= common_den // den_b\n        result_num = num_a - num_b\n    elif operation == '*':\n        result_num = num_a * num_b\n        common_den = den_a * den_b\n    elif operation == '/':\n        result_num = num_a * den_b\n        common_den = den_a * num_b\n    else:\n        raise ValueError(\"Unsupported operation.\")\n    return simplify_fraction(result_num, common_den)"], ["def round_decimal(value, places):\n    \"\"\"\n    Rounds a decimal value to a specified number of decimal places with rounding half-up.\n    \n    Parameters:\n        value (float): the decimal value to round.\n        places (int): the number of decimal places to round to.\n    \n    Returns:\n        float: the rounded decimal value.\n    \n    Examples:\n        >>> round_decimal(0.456, 2)\n        0.46\n        >>> round_decimal(0.1234, 1)\n        0.1\n    \"\"\"\n    decimal_value = Decimal(value).quantize(Decimal('1.' + '0' * places), rounding=ROUND_HALF_UP)\n    return float(decimal_value)"], ["def common_denominator(*fractions):\n    \"\"\"\n    Finds the least common denominator (LCD) for a list of fraction strings.\n    \n    Parameters:\n    - fractions (tuple of str): Fractions for which to find the LCD.\n    \n    Returns:\n    - int: The least common denominator for all provided fractions.\n    \n    Examples:\n    - common_denominator('1/2', '2/3') => 6\n    - common_denominator('5/12', '3/4') => 12\n    \"\"\"\n    f_objs = [Fraction(frac) for frac in fractions]\n    lcd = f_objs[0].denominator\n    for frac in f_objs[1:]:\n        lcd = (lcd * frac.denominator) // math.gcd(lcd, frac.denominator)\n    return lcd"], ["def square_fraction(fraction):\n    \"\"\"\n    Square a given fraction.\n    \n    Parameters:\n        fraction (str): The fraction to square in string format, e.g., '1/2'.\n        \n    Returns:\n        str: The squared fraction in string format.\n        \n    Examples:\n    >>> square_fraction('1/2')\n    '1/4'\n    \"\"\"\n    f = Fraction(fraction)\n    result = f * f\n    return str(result)"]], "Addition": [["def sum_numbers(numbers):\n    \"\"\"\n    Calculate the sum of a list of numbers.\n    Parameters:\n    numbers (list of float or int): A list containing numbers to be summed.\n    Returns:\n    float or int: The sum of the given numbers.\n    Examples:\n    >>> sum_numbers([1, 2, 3, 4, 5])\n    15\n    >>> sum_numbers([10.5, 20.6])\n    31.1\n    \"\"\"\n    if not all(isinstance(x, (int, float)) for x in numbers):\n        raise ValueError(\"All elements in list must be integers or floats\")\n    return sum(numbers)", "def sum_elements(numbers):\n    \"\"\"\n    Sums a list of numbers.\n    \n    Parameters:\n    numbers (list): A list of numbers (int or float), which we are adding together.\n    \n    Returns:\n    float: The sum of the numbers in the list.\n    \n    Examples:\n    >>> sum_elements([1, 2, 3, 4])\n    10\n    >>> sum_elements([1.5, 2.3, 3.1])\n    6.9\n    \"\"\"\n    return sum(numbers)"], ["def sum_consecutive_integers(n):\n    \"\"\"\n    Calculates the sum of the first 'n' consecutive integers using the formula:\n    n * (n + 1) / 2\n    Parameters:\n    - n (int): The last number in the range of consecutive integers to sum.\n    Returns:\n    - int: The sum of the first 'n' consecutive integers.\n    Examples:\n    >>> sum_consecutive_integers(5)\n    15\n    >>> sum_consecutive_integers(10)\n    55\n    \"\"\"\n    return n * (n + 1) // 2", "def sum_consecutive_integers(n):\n    \"\"\"\n    Calculate the sum of the first n natural numbers using the formula n*(n+1)/2.\n    Parameters:\n        n (int): The number of natural integers to be summed starting from 1.\n    Returns:\n        int: The sum of the first n natural numbers.\n    Examples:\n        >>> sum_consecutive_integers(10)\n        55\n        >>> sum_consecutive_integers(100)\n        5050\n    \"\"\"\n    return n * (n + 1) // 2", "def sum_of_integers(n):\n    \"\"\"\n    Calculate the sum of the first n integers using the formula n(n+1)/2.\n    \n    Parameters:\n    n : int\n        The nth term till which the sum is to be calculated.\n    \n    Returns:\n    int\n        The sum of the first n natural numbers.\n    \n    Examples:\n    >>> sum_of_integers(10)\n    55\n    \n    >>> sum_of_integers(100)\n    5050\n    \"\"\"\n    return n * (n + 1) // 2"], ["def sum_values(*args):\n    \"\"\"\n    Calculate the sum of an arbitrary number of values or a single list of values.\n    \n    Parameters:\n        *args: A variable length argument list containing numbers or a single iterable(list, tuple) of numbers.\n    \n    Returns:\n        float: The sum of the provided values.\n        \n    Examples:\n        >>> sum_values(1, 2, 3, 4)\n        10\n        >>> sum_values([1, 2, 3, 4])\n        10\n    \"\"\"\n    import numpy as np\n    if len(args) == 1 and hasattr(args[0], '__iter__'):\n        return float(np.sum(args[0]))\n    else:\n        return float(np.sum(args))", "def sum_numerical_values(*args):\n    \"\"\"\n    Compute the sum of multiple numerical values with enhanced precision.\n    \n    This function supports summing individual numbers, lists of numbers, and even NumPy arrays.\n    It attempts to preserve numerical precision and is particularly useful in contexts where\n    floating-point precision might be a concern.\n    Parameters:\n    *args : variable length argument list\n        Any number of numerical arguments. Each argument can be a single number (int/float),\n        or iterable collections like lists or NumPy arrays containing numerical values.\n    Returns:\n    float\n        The precise sum of all provided numerical values.\n    Examples:\n    --------\n    >>> sum_numerical_values(1, 2, 3)\n    6\n    >>> sum_numerical_values([1, 2], 3, [4, 5])\n    15\n    >>> import numpy as np\n    >>> sum_numerical_values(np.array([1, 2]), 3.0, [4.5, 0.5])\n    11.0\n    \"\"\"\n    import numpy as np\n    \n    total_sum = 0\n    for value in args:\n        if isinstance(value, (list, tuple, np.ndarray)):\n            total_sum += np.sum(value)\n        else:\n            total_sum += value\n    return total_sum"], ["def calculate_average(numbers):\n    \"\"\"\n    Calculate the average of a list of numbers.\n    Parameters:\n    numbers (list of float or int): A list of numbers to calculate the average.\n    Returns:\n    float: The average of the numbers or `None` if the list is empty to avoid division by zero.\n    Examples:\n    >>> calculate_average([1, 2, 3, 4, 5])\n    3.0\n    >>> calculate_average([10.5, 5.5])\n    8.0\n    \"\"\"\n    if not numbers:\n        return None\n    if not all(isinstance(x, (int, float)) for x in numbers):\n        raise ValueError(\"All elements in list must be integers or floats\")\n    \n    total_sum = sum(numbers)\n    return total_sum / len(numbers)", "def calculate_average(numbers):\n    \"\"\"\n    Calculate the average of a list of numbers using the generalized_sum function.\n    Parameters\n    ----------\n    numbers : list or numpy.ndarray\n        A list or an array of numbers for which the average is calculated.\n    Returns\n    -------\n    float\n        The average of the numbers provided.\n    Examples\n    --------\n    >>> calculate_average([10, 20, 30, 40])\n    25.0\n    >>> import numpy as np\n    >>> calculate_average(np.array([5, 15, 25]))\n    15.0\n    \"\"\"\n    total_sum = generalized_sum(numbers)\n    count = len(numbers) if hasattr(numbers, '__len__') else 1\n    return total_sum / count"], ["def sum_structured_items(items):\n    \"\"\"\n    Sum values stored in a dictionary or list of tuples where keys represent categories or time periods.\n    Parameters:\n    items : dict or list of tuples\n        A dictionary or list of tuples. Each key or first tuple element represents a category or time period,\n        with the corresponding value or second tuple element representing the numerical value associated with it.\n    Returns:\n    float\n        The sum of all values within the structured data.\n    Example:\n    >>> sum_structured_items({'rent': 500, 'mileage': 150})\n    650\n    >>> sum_structured_items([('January', 120), ('February', 130)])\n    250\n    \"\"\"\n    if isinstance(items, dict):\n        return sum(items.values())\n    elif isinstance(items, list) and all(isinstance(x, tuple) and len(x) == 2 for x in items):\n        return sum(value for _, value in items)\n    else:\n        raise ValueError(\"Input must be a dictionary or list of tuples (key, value pairs).\")"], ["def generalized_sum(*numbers):\n    \"\"\"\n    Calculate the sum of an arbitrary number of numbers or lists of numbers.\n    Can handle single values, lists, and numpy arrays.\n    Parameters\n    ----------\n    *numbers : int, float, list, or numpy.ndarray\n        Variable length argument list. Each element being a number or a collection of numbers.\n    Returns\n    -------\n    float or int\n        Sum of all the numbers provided.\n    Examples\n    --------\n    >>> generalized_sum(10, 20, 30)\n    60\n    >>> generalized_sum([1, 2, 3], 5, [6, 4])\n    21\n    >>> import numpy as np\n    >>> generalized_sum(np.array([1, 2, 3]), 3)\n    9\n    \"\"\"\n    from numpy import ndarray, sum as np_sum\n    total = 0\n    for number in numbers:\n        if isinstance(number, (list, ndarray)):\n            total += np_sum(number)\n        else:\n            total += number\n    return total"], ["def sum_numbers(*args):\n    \"\"\"\n    Calculate the sum of an arbitrary number of numbers.\n    Parameters:\n    *args : float\n        A variable number of numeric arguments to be summed up.\n    Returns:\n    float\n        The sum of all given numbers.\n    Example:\n    >>> sum_numbers(10, 20, 30)\n    60\n    >>> sum_numbers(12.5, 3.4, 0.1)\n    16.0\n    \"\"\"\n    return sum(args)"], ["def sum_numbers(*args):\n    \"\"\"\n    Computes the sum of all provided arguments. This function can handle a flexible\n    amount of numbers as well as lists of numbers.\n    Parameters:\n    - args (int, float, list): Individual numbers or lists of numbers.\n    Returns:\n    - float: The total sum of all input numbers.\n    Examples:\n    >>> sum_numbers(5, 10)\n    15\n    >>> sum_numbers([1, 2, 3], 4)\n    10\n    >>> sum_numbers(7.2, 0.3)\n    7.5\n    \"\"\"\n    total_sum = 0\n    for arg in args:\n        if isinstance(arg, list):\n            total_sum += sum(arg)\n        else:\n            total_sum += arg\n    return total_sum", "def sum_numbers(*args):\n    \"\"\"\n    A function to sum an arbitrary number of values or iterables containing numbers.\n    Handles inputs as individual numbers, lists, or tuples of numbers.\n    Parameters:\n    -----------\n    *args : int, float or iterable of numerics\n        A variable length argument list. Each argument can be an int, a float, or an iterable\n        (list, tuple) containing numeric values.\n    Returns:\n    --------\n    float\n        The sum of all numbers provided in the arguments.\n    Examples:\n    ---------\n    >>> sum_numbers(5, 10)\n    15\n    >>> sum_numbers([1, 2, 3], (4, 5))\n    15\n    >>> sum_numbers(4.5, [1, 2.5], (0.5, 2))\n    10.5\n    \"\"\"\n    total_sum = 0\n    for arg in args:\n        if hasattr(arg, '__iter__'):  # Check if arg is iterable\n            total_sum += sum(arg)\n        else:\n            total_sum += arg\n    return total_sum", "def general_sum(*args):\n    \"\"\"\n    Perform addition on a sequence of numbers. It can operate on individual numbers,\n    lists, or a combination of both. It unwraps entries if they are lists or tuples and adds all elements.\n    \n    Parameters:\n        *args (int, float, list, tuple): Variable length argument list where each argument\n            can be either an integer, a float, or a list/tuple of numbers.\n    Returns:\n        float: The total sum of all input numbers.\n    Examples:\n        >>> general_sum(5, 10)\n        15\n        >>> general_sum([1, 2, 3], 4)\n        10\n        >>> general_recvolt_sum(4.5, -0.5)\n        4.0\n        >>> general_sum((1, 2), [3, 4], 5)\n        15\n    \"\"\"\n    total = 0\n    for arg in args:\n        if isinstance(arg, (list, tuple)):\n            total += sum(arg)\n        else:\n            total += arg\n    return total"], ["def sum_with_rounding(*args, decimal_places=2):\n    \"\"\"\n    Adds numbers with rounding the result to a specific number of decimal places.\n    \n    Parameters:\n    *args : float\n        Variable number of float numbers to be added.\n    decimal_places : int\n        Number of decimal places to round the final sum to.\n    \n    Returns:\n    float\n        The sum of the numbers rounded to the specified number of decimal places.\n    \n    Examples:\n    >>> sum_with_rounding(0.123, 0.456, decimal_places=2)\n    0.58\n    \n    >>> sum_with_rounding(0.123, 0.456, 0.789, decimal_places=1)\n    1.4\n    \"\"\"\n    return round(sum(args), decimal_places)"], ["def calculate_total_cost(base_costs, additional_costs_per_unit, units):\n    \"\"\"\n    Calculate total costs by adding base costs and additional costs, which are dependent on units.\n    \n    Parameters:\n        base_costs (float): The fixed base cost.\n        additional_costs_per_unit (float): Cost per unit.\n        units (int or float): Number of units.\n    Returns:\n        float: The total cost calculated.\n    Examples:\n        >>> calculate_total_cost(150, 0.1, 50)\n        155.0\n    \"\"\"\n    return base_costs + additional_costs_per_unit * units"], ["def add_place_values(*args):\n    \"\"\"\n    Adds numbers by handling place values separately.\n    \n    Parameters:\n    *args : tuples of (int, int)\n        Variable number of arguments where each argument is a tuple representing (value, place_value_multiplier).\n    \n    Returns:\n    int\n        The sum where each number has been multiplied by its place value before summing.\n    \n    Examples:\n    >>> add_place_values((20, 10), (5, 1))  # 20 tens and 5 ones\n    205\n    \n    >>> add_place_values((3, 100), (47, 1))  # 3 hundreds and 47 ones\n    347\n    \"\"\"\n    return sum(num * multiplier for num, multiplier in args)"], ["def sum_coefficients(coefficients, variable_symbol):\n    \"\"\"\n    Sum the coefficients of an algebraic expression using sympy for symbolic computation.\n    Parameters\n    ----------\n    coefficients : list of float\n        A list of coefficients to be summed.\n    variable_symbol : str\n        The variable symbol (as a string) for which the coefficients are multiplied.\n    Returns\n    -------\n    sympy.Expr\n        The summation result as a symbolic expression.\n    Examples\n    --------\n    >>> sum_coefficients([1, 2, 3], 'x')\n    6*x\n    \n    >>> sum_coefficients([0.5, 1.5, 2.5], 'y')\n    4.5*y\n    \"\"\"\n    var = symbols(variable_symbol)\n    expr = Add(*[coeff * var for coeff in coefficients])\n    return expr"], ["def sum_by_category(values, categories):\n    \"\"\"\n    Sum numbers grouped by categories provided in a separate list of the same length.\n    Parameters:\n        values (list of numbers): The numbers to be summed.\n        categories (list of str or int): A list categorizing each entry in values.\n    Returns:\n        dict: A dictionary with categories as keys and their summed values as values.\n    Examples:\n        >>> sum_by_category([100, 200, 150, 150], ['travel', 'travel', 'food', 'food'])\n        {'travel': 300, 'food': 300}\n    \"\"\"\n    import numpy as np\n    unique_categories = np.unique(categories)\n    summed_by_category = {}\n    for category in unique_categories:\n        summed_by_category[category] = float(np.sum(np.array(values)[np.array(categories) == category]))\n    return summed_by_category"], ["def sum_financials(**kwargs):\n    \"\"\"\n    A function to compute sum of various financial components, each represented as keyword arguments.\n    Parameters:\n    -----------\n    **kwargs : dict\n        Key-value pairs where keys are the name of the financial component and values are their numerical amount.\n    Returns:\n    --------\n    dict\n        A dictionary containing the total sum with a breakdown over different components.\n    Examples:\n    ---------\n    >>> sum_financials(daily_rental=50.5, mileage_cost=30.2, extra_fees=45)\n    {'total': 125.7, 'breakdown': {'daily_rental': 50.5, 'mileage_cost': 30.2, 'extra_fees': 45}}\n    \"\"\"\n    total_sum = sum(kwargs.values())\n    return {'total': total_sum, 'breakdown': kwargs}"], ["def accurate_sum(*numbers):\n    \"\"\"\n    Sum a sequence of numbers accurately.\n    This function uses Python's built-in types to manage higher precision addition of floating-point numbers\n    and can be adapted to use different precision strategies (like using decimal.Decimal for arbitrary\n    precision).\n    Parameters:\n    *numbers : float or int\n        A variable number of numbers (either floats or ints), which will be summed together.\n    Returns:\n    float\n        The accurate sum of the provided numbers.\n    Examples:\n    >>> accurate_sum(0.1, 0.2, 0.3)\n    0.6\n    >>> accurate_sum(1, 2, 3, 4, 5)\n    15\n    >>> accurate_sum(1e-16, 1e-16)\n    2e-16\n    \"\"\"\n    # A straightforward and precise addition:\n    # In Python 3.x, the built-in sum is implemented very effectively for a sequence of floats.\n    return sum(numbers)"], ["def detailed_addition(n1, n2):\n    \"\"\"\n    Breaks down two numbers into tens and units, then performs an addition, returning the detailed result.\n    Parameters:\n    - n1, n2 (int): Two-digit numbers to decompose and add.\n    Returns:\n    - dict: Result of detailed addition with breakdowns.\n    Examples:\n    >>> detailed_addition(14, 25)\n    {'Tens': 3, 'Units': 9}\n    \"\"\"\n    tens1, units1 = divmod(n1, 10)\n    tens2, units2 = divmod(n2, 10)\n    total_tens = tens1 + tens2\n    total_units = units1 + units2\n    if total_units >= 10:\n        total_tens += 1\n        total_units -= 10\n    return {'Tens': total_tens, 'Units': total_units}"], ["def sum_of_digits(number):\n    \"\"\"\n    Calculates the sum of the digits of a given number.\n    Parameters:\n    - number (int, float): The number from which to sum the digits.\n    Returns:\n    - int: The sum of the digits.\n    Examples:\n    >>> sum_of_digits(123)\n    6\n    >>> sum_of_digits(1042)\n    7\n    \"\"\"\n    return sum(int(digit) for digit in str(int(number)))", "def sum_digits(number):\n    \"\"\"\n    Sum the digits of a given number.\n    \n    Parameters:\n    number : int\n        The number whose digits are to be summed.\n    \n    Returns:\n    int\n        The sum of the digits of the number.\n    \n    Examples:\n    >>> sum_digits(1234)\n    10\n    \n    >>> sum_digits(10101)\n    3\n    \"\"\"\n    return sum(int(digit) for digit in str(number))"], ["def numpy_based_sum(numbers):\n    \"\"\"\n    Sum an array of numbers using the numpy library for enhanced performance\n    and potentially better handling of very large arrays of numbers.\n    Parameters:\n    numbers : array_like\n        An array, list, or tuple of numbers (int, float, or complex) to be summed.\n    Returns:\n    float or complex\n        The sum of the array elements, returned as float or complex based on the input type.\n    Examples:\n    >>> numpy_based_sum([0.1, 0.2, 0.3])\n    0.6000000000000001\n    >>> numpy_based_sum([1, 2, 3, 4, 5])\n    15.0\n    >>> numpy_based_sum(np.array([1e-16, 1e-16], dtype=np.float64))\n    2e-16\n    \"\"\"\n    # Utilizing numpy's sum to potentially leverage faster computations on arrays:\n    return np.sum(np.array(numbers))"], ["def add_numbers(*args):\n    \"\"\"\n    Add a series of numbers together.\n    \n    Parameters:\n    *args : float or int\n        A variable number of arguments that are the numbers to be added together.\n    \n    Returns:\n    float\n        The sum of the provided numbers.\n    \n    Examples:\n    >>> add_numbers(1, 2, 3)\n    6\n    \n    >>> add_numbers(10.5, 3.2)\n    13.7\n    \"\"\"\n    sum_total = sum(args)\n    return sum_total"], ["def average_elements(numbers):\n    \"\"\"\n    Computes the average of a list of numbers.\n    \n    Parameters:\n    numbers (list): A list of numbers (int or float) to compute the average of.\n    \n    Returns:\n    float: The average of the provided numbers.\n    \n    Examples:\n    >>> average_elements([10, 20, 30, 40])\n    25.0\n    >>> average_elements([1.5, 2.5, 3.5])\n    2.5\n    \"\"\"\n    if not numbers:\n        raise ValueError(\"The input list 'numbers' cannot be empty.\")\n    total_sum = sum(numbers)\n    count = len(numbers)\n    return total_sum / count"], ["def sum_numerical_values(numbers):\n    \"\"\"\n    Sum multiple numerical values accurately using numpy for floating-point precision.\n    Parameters\n    ----------\n    numbers : list of float\n        A list of numerical values to be summed.\n    Returns\n    -------\n    float\n        The summation result of the numerical values.\n    Examples\n    --------\n    >>> sum_numerical_values([0.1, 0.2, 0.3])\n    0.6\n    \n    >>> sum_numerical_values([1.5, 2.5, 3])\n    7.0\n    \"\"\"\n    return np.sum(numbers)"]], "Ratios and Proportions": [["def calculate_ratio(a, b):\n    \"\"\"\n    Calculate the ratio of two numbers.\n    \n    Parameters:\n    a (int or float): First number.\n    b (int or float): Second number.\n    \n    Returns:\n    tuple: Returns a tuple representing the simplified ratio of a to b.\n    \n    Examples:\n    >>> calculate_ratio(10, 20)\n    (1, 2)\n    >>> calculate_ratio(15, 9)\n    (5, 3)\n    \"\"\"\n    if b == 0:\n        raise ValueError(\"The second number cannot be zero\")\n    common_divisor = math.gcd(a, b)\n    return (a // common_divisor, b // common_divisor)", "def create_ratio(a, b):\n    \"\"\"\n    Create a ratio from two given numbers and simplify it.\n    Parameters:\n        a (int or float): The first quantity.\n        b (int or float): The second quantity.\n    Returns:\n        tuple: A tuple representing the simplified ratio (a, b).\n    Examples:\n        >>> create_ratio(12, 16)\n        (3, 4)\n    \"\"\"\n    gcd = math.gcd(int(a), int(b))  # Ensure numbers are treated as integers for gcd\n    return (a // gcd, b // gcd)", "def create_ratio(a, b):\n    \"\"\"\n    Create a simplified ratio from two numbers.\n    \n    Parameters:\n        a (int or float): First value of the ratio.\n        b (int or float): Second value of the ratio.\n        \n    Returns:\n        tuple: A tuple representing the simplified ratio.\n    \n    Examples:\n        >>> create_ratio(2, 4)\n        (1, 2)\n        >>> create_ratio(10, 25)\n        (2, 5)\n    \"\"\"\n    from math import gcd\n    common_divisor = gcd(int(a), int(b))\n    return (a // common_divisor, b // common_divisor)", "def calculate_ratio(a, b):\n    \"\"\"\n    Calculate the simplified ratio between two numbers.\n    Parameters\n    ----------\n    a : int or float\n        The first number in the ratio.\n    b : int or float\n        The second number in the ratio.\n    Returns\n    -------\n    tuple\n        Returns a simplified ratio tuple (numerator, denominator).\n    Example\n    -------\n    >>> calculate_ratio(10, 20)\n    (1, 2)\n    \"\"\"\n    from math import gcd\n    gcd_value = gcd(int(a), int(b))\n    return (a // gcd_value, b // gcd_val)", "def create_ratio(a, b):\n    \"\"\"\n    Create a ratio given two quantities.\n    Parameters:\n    a (int/float): The first quantity.\n    b (int/float): The second quantity.\n    \n    Returns:\n    tuple: A tuple representing the ratio in its simplest form.\n    \n    Examples:\n    >>> create_ratio(10, 5)\n    (2, 1)\n    >>> create_ratio(15, 9)\n    (5, 3)\n    \"\"\"\n    from math import gcd\n    if b == 0:\n        raise ValueError(\"The second quantity cannot be zero.\")\n        \n    g = gcd(int(a), int(b))\n    return (a // g, b // g)"], ["def are_ratios_equivalent(numerator1, denominator1, numerator2, denominator2):\n    \"\"\"\n    Check if two ratios are equivalent.\n    Parameters:\n    numerator1 (float): The numerator of the first ratio.\n    denominator1 (float): The denominator of the first ratio.\n    numerator2 (float): The numerator of the second ratio.\n    denominator2 (float): The denominator of the second ratio.\n    Returns:\n    bool: True if the ratios are equivalent, False otherwise.\n    Examples:\n    >>> are_ratios_equivalent(1, 2, 2, 4)\n    True\n    >>> are_ratios_equivalent(3, 4, 6, 8)\n    True\n    \"\"\"\n    return numerator1 * denominator2 == numerator2 * denominator1", "def compare_ratios(ratio1, ratio2):\n    \"\"\"\n    Compare two ratios to determine if they are equivalent.\n    \n    Parameters:\n        ratio1 (tuple): First ratio in the form (numerator, denominator).\n        ratio2 (tuple): Second ratio in the form (numerator, denominator).\n        \n    Returns:\n        bool: True if ratios are equivalent, False otherwise.\n    \n    Examples:\n        >>> compare_ratios((1, 2), (2, 4))\n        True\n        >>> compare_ratios((1, 3), (2, 4))\n        False\n    \"\"\"\n    # Cross-multiplication to check if ratios are equivalent\n    return ratio1[0] * ratio2[1] == ratio1[1] * ratio2[0]"], ["def calculate_fraction_of_whole(numerator, denominator, whole):\n    \"\"\"\n    Calculates the fractional part of a given whole number based on the specified numerator and denominator.\n    \n    Parameters:\n    - numerator (int or float): The numerator part of the fraction.\n    - denominator (int or float): The denominator part of the fraction, must not be zero.\n    - whole (int or float): The total or whole number from which a fraction is to be calculated.\n    \n    Returns:\n    - float: The result of the fraction of the whole.\n    \n    Examples:\n    >>> calculate_fraction_of_whole(1, 4, 100)\n    25.0\n    >>> calculate_fraction_of_whole(3, 2, 150)\n    225.0\n    \"\"\"\n    if denominator == 0:\n        raise ValueError(\"Denominator of the fraction must not be zero.\")\n    \n    fraction = numerator / denominator\n    result = fraction * whole\n    return result", "def calculate_part_of_whole(whole, ratio):\n    \"\"\"\n    Calculate the part of a given whole based on the provided ratio.\n    Parameters:\n    - whole (float or int): The total amount or whole.\n    - ratio (tuple of two integers): A tuple representing the ratio of the part to the whole (part, total_parts).\n    Returns:\n    - float: The calculated part of the whole.\n    Example:\n    >>> calculate_part_of_whole(100, (1, 4))\n    25.0\n    \"\"\"\n    from fractions import Fraction\n    \n    part, total_parts = ratio\n    fraction = Fraction(part, total_parts)\n    return whole * fraction", "def compute_part_of_whole(whole, numerator, denominator):\n    \"\"\"\n    Calculate the value representing a part of a whole given a ratio.\n    \n    Parameters:\n    - whole (float): The total or whole value.\n    - numerator (int): The numerator of the ratio.\n    - denominator (int): The denominator of the ratio.\n    \n    Returns:\n    - float: The part of the whole as defined by the ratio.\n    \n    Example:\n    >>> compute_part_of_whole(100, 1, 4)\n    25.0\n    \"\"\"\n    from fractions import Fraction\n    return whole * Fraction(numerator, denominator)"], ["def check_proportion(a, b, c, d):\n    \"\"\"\n    Check if the ratio a:b is proportional to c:d.\n    Parameters:\n    a (int or float or sympy.Symbol): Numerator of the first ratio.\n    b (int or float or sympy.Symbol): Denominator of the first ratio.\n    c (int or float or sympy.Symbol): Numerator of the second ratio.\n    d (int or float or sympy.Symbol): Denominator of the second ratio.\n    Returns:\n    bool: True if the ratios are proportional, False otherwise.\n    Examples:\n    >>> check_proportion(1, 2, 2, 4)\n    True\n    >>> check_proportion(3, 4, 6, 8)\n    True\n    >>> check_proportion(5, 8, 15, 18)\n    False\n    Notes:\n    Uses cross multiplication to check proportionality, thus it evaluates a*d == b*c.\n    \"\"\"\n    from sympy import simplify\n    return simplify(a * d) == simplify(b * c)", "def is_proportional(a, b, c, d):\n    \"\"\"\n    Check if two given ratios (a:b and c:d) are proportional.\n    Parameters:\n    a (float): the first term of the first ratio.\n    b (float): the second term of the first ratio.\n    c (float): the first term of the second ratio.\n    d (float): the second term of the second ratio.\n    Returns:\n    bool: True if the ratios are equivalent, False otherwise.\n    Examples:\n    >>> is_proportional(1, 2, 2, 4)\n    True  # Explanation (1/2 == 2/4)\n    >>> is_proportional(1, 3, 2, 6)\n    True  # Explanation (1/3 == 2/6)\n    \"\"\"\n    return (a * d) == (b * c)"], ["def find_unknown_in_proportion(known_ratio, known_value, unknown_position):\n    \"\"\"\n    Calculate the unknown quantity in a proportional relationship using cross multiplication.\n    Parameters:\n    - known_ratio (tuple): A tuple of two numbers representing the known ratio (a, b).\n    - known_value (float): The numeric value corresponding to one part of the known ratio.\n    - unknown_position (str): Should be either 'first' or 'second' indicating if the unknown is the first or second term in the ratio.\n    Returns:\n    - float: The calculated unknown value.\n    Examples:\n    >>> find_unknown_in_proportion((3, 5), 15, 'second')\n    25.0\n    >>> find_unknown_in_proportion((4, 7), 28, 'first')\n    16.0\n    \"\"\"\n    if unknown_position == 'first':\n        return (known_ratio[0] * known_value) / known_ratio[1]\n    elif unknown_position == 'second':\n        return (known_ratio[1] * known_value) / known_ratio[0]\n    else:\n        raise ValueError(\"unknown_position must be 'first' or 'second'\")", "def find_unknown_in_proportion(a, b, c, unknown_position='d'):\n    \"\"\"\n    Given three values of a proportion a:b = c:d, where one of them is unknown, find the unknown using cross multiplication.\n    \n    Parameters:\n    - a (float): Known value corresponding to first part of first ratio.\n    - b (float): Known value corresponding to second part of first ratio.\n    - c (float): Known value corresponding to first part of the equivalent ratio.\n    - unknown_position (str): Indicator of which value is unknown ('b' or 'd'). Default is 'd'.\n    \n    Returns:\n    - float: The value of the unknown term in the proportion.\n    \n    Example:\n    - find_unknown_in_proportion(3, 6, 4, 'd')\n      Output: 8.0\n    - find_unknown_in_projection(3, 'x', 4, 8, 'b')\n      Output: 1.5\n    \"\"\"\n    if unknown_position == 'd':\n        d = c * (b / a)\n    elif unknown_position == 'b':\n        d = a * (c / b)  # this part should be revised in reality to handle proper input\n    return d"], ["def calculate_missing_value_in_proportion(a, b, c, missing_position):\n    \"\"\"\n    Calculate the missing value in a proportion given three known values.\n    \n    Parameters:\n    - a (float or int): The first known value of the proportion\n    - b (float or int): The second known value of the proportion related to `a`\n    - c (float or int): The third known value of the proportion\n    - missing_position (str): A string indicating which position is missing among 'a', 'b', or 'c',\n                              describing the relationship as a:b::c:x (x is the missing value)\n    \n    Returns:\n    - float: The calculated missing value maintaining the proportion.\n    Examples:\n    >>> calculate_missing_value_in_proportion(1, 2, 3, 'b')\n    6.0\n    >>> calculate_missing_value_in_proportion(2, 4, 10, 'c')\n    20.0\n    \"\"\"\n    import sys\n    if missing_position not in ['a', 'b', 'c']:\n        raise ValueError(\"missing_position must be 'a', 'b', or 'c'\")\n    \n    try:\n        if missing_position == 'b':\n            return (b * c) / a\n        elif missing_position == 'a':\n            return (b * a) / c\n        elif missing_position == 'c':\n            return (c * a) / b\n    except ZeroDivisionError:\n        sys.exit(\"Error: Division by zero occurred in proportions calculations.\")", "def find_missing_proportion(a, b, c, find='x'):\n    \"\"\"\n    Calculates the missing value in a proportion a:b = c:x.\n    \n    Parameters:\n        a (float or int): The first value of the first ratio.\n        b (float or int): The second value of the first ratio.\n        c (float or int): The first value of the second ratio.\n        find (str): The variable to solve for, by default 'x' for a:b = c:x.\n    Returns:\n        float: The value of x that completes the proportion.\n    \n    Example:\n        >>> find_missing_proportion(3, 4, 9)\n        12.0\n    \"\"\"\n    x = sp.symbols(find)\n    equation = sp.Eq(a / b, c / x)\n    solution = sp.solve(equation, x)\n    return float(solution[0])"], ["def solve_proportion(a, b, c, x):\n    \"\"\"\n    Given three values a, b, c and an unknown x in the proportion a:b = c:x or a:x = c:b, return the value of x.\n    Parameters:\n    a (int or float or sympy.Symbol): First value of the first ratio.\n    b (int or float or sympy.Symbol): Second value of the first ratio or unknown if x represents this position.\n    c (int or float or sympy.Symbol): First value of the second ratio.\n    x (str): Identifier for the unknown position ('b' if unknown is b or 'd' if unknown is d in a:b=c:d).\n    Returns:\n    sympy.Symbol or float: The calculated value of the unknown based on the proportion.\n    Examples:\n    >>> solve_proportion(1, 'b', 2, 4)\n    8.0\n    >>> solve_proportion(3, 6, 2, 'b')\n    4.0\n    >>> solve_proportion(2, 'b', 5, 20)\n    8.0\n    Notes:\n    Solves for the unknown by cross multiplying and solving the resulting equation.\n    \"\"\"\n    from sympy import symbols, Eq, solve\n    if x == 'b':\n        b = symbols('b')\n        equation = Eq(a * 4, b * 2)\n        result = solve(equation, b)\n        return result[0]  # Return the solution to the equation\n    if x == 'd':\n        d = symbols('d')\n        equation = Eq(a * d, c * b)\n        result = solve(equation, d)\n        return result[0]  # Return the solution to the equation\n    raise ValueError(\"Unknown position identifier must be 'b' or 'd'.\")", "def solve_proportion(a, b, c, d, missing_position):\n    \"\"\"\n    Solve for the missing term in a proportion given three known terms.\n    Parameters:\n    a (float or None): The numerator of the first ratio, or None if it's the missing value.\n    b (float): The denominator of the first ratio.\n    c (float or None): The numerator of the second ratio, or None if it's the missing value.\n    d (float or None): The denominator of the second ratio, or None if it's the missing value.\n    missing_position (str): A character ('a', 'b', 'c', 'd') indicating the position of the missing value.\n    Returns:\n    float: The value of the missing term in the proportion.\n    Examples:\n    >>> solve_proportion(None, 2, 3, 4, 'a')\n    1.5\n    >>> solve_proportion(3, 2, 9, None, 'd')\n    6\n    \"\"\"\n    if missing_position == 'a':\n        return (b * c) / d\n    elif missing_position == 'b':\n        return (a * d) / c\n    elif missing_position == 'c':\n        return (a * d) / b\n    elif missing_position == 'd':\n        return (b * c) / a\n    else:\n        raise ValueError(\"Invalid missing position. Choose from 'a', 'b', 'c', 'd'.\")", "def solve_proportion(a, b, x):\n    \"\"\"\n    Solve for the unknown in a proportion given two values of a known ratio and one value of an unknown ratio.\n    \n    Parameters:\n        a (int or float): Known numerator.\n        b (int or float): Known denominator.\n        x (int or float): Unknown numerator or denominator. Mark the unknown part with None.\n        \n    Returns:\n        float: Solved value for the unknown part of the ratio.\n    \n    Examples:\n        >>> solve_proportion(1, 2, None)  # Example where denominator is unknown\n        0.5  # It would usually depend on where 'None' is placed.\n        >>> solve_proportion(None, 2, 3)  # Example where numerator is unknown\n        6\n    \"\"\"\n    if a is None:\n        # solve for 'a'\n        return b * x\n    elif b is None:\n        # solve for 'b'\n        return a / x\n    elif x is None:\n        # solve for 'x'\n        return b / a\n    else:\n        raise ValueError(\"One of the parameters must be None to indicate the unknown.\")", "def solve_proportion(a, b, c, d):\n    \"\"\"\n    Solve the unknown in a proportion setup of four terms where one term is `None`.\n    The proportion setup is:\n    a : b :: c : d, and one of the parameters is None, indicating the unknown variable.\n    Parameters:\n    a (float or None): the first term of the first ratio, or None if it is the unknown.\n    b (float or None): the second term of the first ratio.\n    c (float or None): the first term of the second ratio.\n    d (float or None): the second term of the second ratio, or None if it is the unknown.\n    Returns:\n    float: The calculated value of the unknown term.\n    Examples:\n    >>> solve_proportion(None, 2, 3, 6)\n    1.0  # Explanation (x/2 = 3/6 leads to x = 1.0)\n    >>> solve_proportion(1, 3, 5, None)\n    15.0  # Explanation (1/3 = 5/x leads to x = 15.0)\n    \"\"\"\n    if a is None:\n        return (b * c) / d\n    elif b is None:\n        return (a * d) / c\n    elif c is None:\n        return (b * d) / a\n    elif d is None:\n        return (b * c) / a\n    else:\n        raise ValueError(\"One-parameter must be None to solve for it.\")", "def solve_proportional_ratio(a, b, c, d):\n    \"\"\"\n    Solves proportional ratios where one of the variables a, b, c, or d is None.\n    The ratio is defined as a:b = c:d.\n    Parameters:\n    - a (float or None): The first term of the first ratio (or None if unknown).\n    - b (float or None): The second term of the first ratio (or None if unknown).\n    - c (float or None): The first term of the second ratio (or None if unknown).\n    - d (float or None): The second term of the second ratio (or None if unknown).\n    Returns:\n    - float: The computed value of the unknown.\n    Example:\n    >>> solve_proportional_ratio(None, 2, 3, 6)\n    1\n    \"\"\"\n    if a is None:\n        return (b * c) / d\n    elif b is None:\n        return (a * d) / c\n    elif c is None:\n        return (a * d) / b\n    elif d is None:\n        return (b * c) / a"], ["def solve_proportion(a, b, c):\n    \"\"\"\n    Based on the proportional relationship a:b = c:x, solve for x.\n    Parameters:\n    - a (float or int): The first term of the first ratio.\n    - b (float or int): The second term of the first ratio.\n    - c (float or int): The first term of the second ratio.\n    Returns:\n    - float: The calculated value of x in the second ratio.\n    Example:\n    >>> solve_proportion(1, 2, 3)\n    6.0\n    \"\"\"\n    return (b * c) / a", "def solve_proportion(a, b, x):\n    \"\"\"\n    Given a:b = x:y, solve for y using the relation (y = b * x / a).\n    Parameters:\n        a (int or float): The first term of known ratio.\n        b (int or float): The second term of known ratio.\n        x (int or float): The value corresponding to the first term of the unknown ratio.\n    Returns:\n        float: The value of y that satisfies the proportion.\n    Examples:\n        >>> solve_protribution(2, 3, 4)\n        6.0\n    \"\"\"\n    return (b * x) / a"], ["def scale_ratio(numerator, denominator, scaling_factor):\n    \"\"\"\n    Scale a ratio by a given factor.\n    \n    Parameters:\n    - numerator (int or float): The numerator of the original ratio.\n    - denominator (int or float): The denominator of the original ratio.\n    - scaling_factor (int or float): The factor by which to scale the ratio.\n    \n    Returns:\n    - tuple: A tuple containing the scaled numerator and denominator.\n    \n    Examples:\n    >>> scale_ratio(1, 2, 3)\n    (3, 6)\n    \n    >>> scale_ratio(2, 3, 0.5)\n    (1.0, 1.5)\n    \"\"\"\n    scaled_numerator = numerator * scaling_factor\n    scaled_denominator = denominator * scaling_factor\n    return (scaled_numerator, scaled_denominator)", "def scale_ratio(ratio, scale_factor):\n    \"\"\"\n    Scale a ratio by a given factor and simplify the result.\n    \n    Parameters:\n        ratio (tuple): A tuple representing the ratio in form (numerator, denominator).\n        scale_factor (int/float): Factor by which to scale the ratio.\n    Returns:\n        tuple: New ratio scaled and simplified as a tuple (numerator, denominator).\n    \n    Examples:\n        >>> scale_ratio((2, 3), 3)\n        (2, 1)\n        >>> scale_ratio((1, 3), 5)\n        (5, 3)\n    \"\"\"\n    if ratio[1] == 0:  # Check if the original denominator is zero\n        return None\n    new_numerator = ratio[0] * scale_factor\n    new_denominator = ratio[1]\n    return calculate_and_simplify_ratio(new_numerator, new_denominator)", "def scale_ratio(ratio, factor):\n    \"\"\"\n    Scale a given ratio by a multiplication factor.\n    Parameters:\n    ratio (tuple): A tuple containing the numerator and denominator of the ratio.\n    factor (int/float): The factor by which to scale the ratio.\n    \n    Returns:\n    tuple: A scaled ratio in its simplest form.\n    \n    Examples:\n    >>> scale_ratio((3, 4), 2)\n    (6, 8)\n    >>> scale_ratio((2, 3), 5)\n    (10, 15)\n    \"\"\"\n    scaled_numerator = ratio[0] * factor\n    scaled_denominator = ratio[1] * factor\n    return (scaled_numerator, scaled_denominator)"], ["def calculate_and_simplify_ratio(numerator, denominator):\n    \"\"\"\n    Calculate the ratio of two numbers and simplify it.\n    \n    Parameters:\n    - numerator (int or float): The numerator of the ratio.\n    - denominator (int or float): The denominator of the ratio.\n    \n    Returns:\n    - tuple: A tuple containing the original ratio and simplified ratio in the format \n             ((original numerator, original denominator), (simplified numerator, simplified denominator))\n    \n    Examples:\n    >>> calculate_and_simplify_ratio(10, 20)\n    ((10, 20), (1, 2))\n    \n    >>> calculate_and_simplify_ratio(15, 5)\n    ((15, 5), (3, 1))\n    \"\"\"\n    if denominator == 0:\n        raise ValueError(\"Denominator cannot be zero.\")\n    \n    original_ratio = (numerator, denominator)\n    simplified_ratio = sympy.Rational(numerator, denominator).as_numer_denom()\n    return original_ratio, simplified_ratio", "def calculate_and_simplify_ratio(numerator, denominator):\n    \"\"\"\n    Calculate and simplify a ratio given two values.\n    \n    Parameters:\n        numerator (int/float): The numerator of the ratio.\n        denominator (int/float): The denominator of the ratio.\n    Returns:\n        tuple: Simplified ratio as a tuple (numerator, denominator) if Denominator is not zero, else return None.\n    \n    Examples:\n        >>> calculate_and_simplify_ratio(10, 2)\n        (5, 1)\n        >>> calculate_and_simplify_ratio(33, 99)\n        (1, 3)\n    \"\"\"\n    if denominator == 0:\n        return None\n    simplified_ratio = nsimplify(numerator / denominator)\n    return (simplified_ratio.numerator(), simplified_ratio.denominator())"], ["def divide_quantity_by_ratio(total_quantity, *ratio_parts):\n    \"\"\"\n    Divide a total quantity into parts based on a given ratio.\n    Parameters:\n    -----------\n    total_quantity : float or int\n        The total quantity to be divided.\n    ratio_parts : int(s)\n        Variable number of arguments representing parts of the ratio.\n        \n    Returns:\n    --------\n    list\n        A list containing the quantities corresponding to the parts of the ratio.\n    \n    Examples:\n    ---------\n    >>> divide_quantity_by_ratio(100, 3, 2)\n    [60.0, 40.0]\n    \"\"\"\n    from sympy import Rational\n    total_parts = sum(ratio_parts)\n    # Compute each part\n    divided_parts = [Rational(total_quantity * part, total_phats) for card in hetero_parts]\n    # Convert Rational numbers to float for general usage\n    divided_parts = [float(dp) for dp in divided_parts]\n    return divided_parts", "def divide_total_by_ratio(total, ratio):\n    \"\"\"\n    Divides a total quantity into parts based on a given ratio.\n    Parameters:\n    - total (float): The total quantity to be divided.\n    - ratio (tuple): A tuple of numbers representing the ratio in which to divide the total.\n    Returns:\n    - list: A list of amounts corresponding to the parts defined by the ratio.\n    Examples:\n    >>> divide_total_by_ratio(120, (1, 2, 3))\n    [20.0, 40.0, 60.0]\n    >>> divide_total_by_ratio(100, (1, 1))\n    [50.0, 50.0]\n    \"\"\"\n    ratio_sum = sum(ratio)\n    fractions = [(part / ratio_sum) * total for part in ratio]\n    return fractions", "def split_quantity_by_ratio(total_quantity, ratio):\n    \"\"\"\n    Split a total quantity into parts according to a given ratio.\n    Parameters:\n    total_quantity (float): The total amount to be divided.\n    ratio (tuple of int): The ratio by which to divide the total quantity.\n    Returns:\n    list: A list of quantities divided according to the ratio.\n    Example:\n    >>> split_quantity_by_ratio(120, (1, 2, 3))\n    [20.0, 40.0, 60.0]\n    \"\"\"\n    ratio_sum = sum(ratio)\n    return [total_quantity * (part / ratio_sum) for part in ratio]"], ["def triangle_angle_by_ratio(angle_ratio, total_angle=180):\n    \"\"\"\n    Compute angles of a triangle given a ratio between them.\n    Parameters\n    ----------\n    angle_ratio : tuple of ints\n        The ratio between the angles of the triangle. E.g., (2, 3, 4) specifies the ratio of angles.\n    total_angle : int, optional\n        The total sum of angles in a triangle, by default this is 180 degrees (valid for Euclidean geometry).\n    Returns\n    -------\n    list\n        List containing the actual angles of the triangle.\n    Example\n    -------\n    >>> triangle_angle_by_ratio((2, 3, 4))\n    [30.0, 45.0, 60.0]\n    \"\"\"\n    factor = total_angle / sum(angle_ratio)\n    return [x * factor for x in angle_ratio]"], ["def scale_proportionally(original_value, original_ratio, target_ratio):\n    \"\"\"\n    Calculate a new value that is proportionally scaled from an original ratio to a target ratio.\n    \n    Parameters:\n    original_value (float or int): The original value corresponding to the original ratio.\n    original_ratio (float or int): The original base ratio.\n    target_ratio (float or int): The ratio to which the value needs to be adjusted.\n    \n    Returns:\n    float: The adjusted value calculated as per the new target ratio.\n    \n    Example:\n    >>> scale_proportionally(100, 1, 2)\n    200.0  # If the original value is scaled from a ratio of 1 to 2, the target value will be twice the original.\n    \n    >>> scale_proportionally(150, 3, 2)\n    100.0  # Adjusts the value from a ratio of 3 to 2, effectively reducing the original value.\n    \"\"\"\n    if original_ratio == 0:\n        raise ValueError(\"original_ratio cannot be zero.\")\n    return (original_value / original_ratio) * target_ratio", "def scale_monetary_proportionally(original_amount, original_ratio, target_ratio):\n    \"\"\"\n    Calculate a new monetary value scaled proportionally from an original ratio to a target ratio, with precision handling.\n    \n    Parameters:\n    original_amount (float): The original monetary value.\n    original_ratio (float): The original base ratio.\n    target_ratio (float): The new target ratio for scaling the amount.\n    \n    Returns:\n    float: The adjusted monetary value calculated precisely using the target ratio.\n    \n    Example:\n    >>> scale_monetary_proportionally(100.0, 1, 1.5)\n    150.0  # If the original money amount is scaled from a ratio of 1 to 1.5, the new amount is 150.0.\n    \n    >>> scale_monetary_proportionally(200.0, 2, 3)\n    300.0  # Scales the amount from a ratio of 2 to 3, increasing the original amount.\n    \"\"\"\n    import decimal\n    Decimal = decimal.Decimal\n    if original_ratio == 0:\n        raise ValueError(\"original_ratio cannot be zero.\")\n    \n    # Using Decimal for precise monetary calculations to avoid floating-point precision issues\n    result = Decimal(original_amount) / Decimal(original_ratio) * Decimal(target_ratio)\n    return float(result.quantize(Decimal('0.01')))  # rounding to cents", "def calculate_proportional_value(original_quantity, original_ratio, target_ratio):\n    \"\"\"\n    Calculate the new quantity based on a proportional scaling of an original quantity.\n    Parameters\n    ----------\n    original_quantity : float or int\n        The original quantity which needs to be scaled.\n    original_ratio : float or int\n        The ratio associated with the original quantity.\n    target_ratio : float or int\n        The desired ratio to which the original quantity needs to be scaled.\n    Returns\n    -------\n    float\n        The adjusted quantity corresponding to the target ratio.\n    Examples\n    --------\n    >>> calculate_proportional_value(100, 1, 2)\n    200.0\n    >>> calculate_proportional_value(50, 2, 3)\n    75.0\n    >>> calculate_proportional_password(500, 4, 1)\n    125.0\n    \"\"\"\n    # Input validation for robustness\n    if not (isinstance(original_quantity, (int, float)) and isinstance(original_ratio, (int, float)) and isinstance(target_ratio, (int, float))):\n        raise TypeError(\"All arguments must be integers or floats\")\n    if original_ratio == 0 or target_ratio == 0:\n        raise ValueError(\"Ratios must be non-zero\")\n    # Proportional scaling calculation\n    return (original_quantity * target_ratio) / original_ratio"], ["def calculate_proportional_value(base_value, base_ratio, target_ratio):\n    \"\"\"\n    Calculates the value of a target variable based on its proportional relationship to a base variable.\n    \n    Parameters:\n    - base_value (float): The known value of the base entity.\n    - base_ratio (tuple of int or float): The ratio corresponding to the base entity (numerator, denominator).\n    - target_ratio (tuple of int or float): The desired ratio to find the target value (numerator, denominator).\n    \n    Returns:\n    - float: The calculated value of the target entity based on the given ratio.\n    \n    Examples:\n    >>> calculate_proportial_value(100, (1, 2), (3, 4))\n    150.0\n    >>> calculate_proportial_value(150, (2, 3), (4, 5))\n    200.0\n    \"\"\"\n    if base_ratio[1] == 0 or target_ratio[1] == 0:\n        raise ValueError(\"Denominator in ratios must not be zero.\")\n    # Proportional value calculation\n    base_ratio_value = base_ratio[0] / base_ratio[1]\n    target_ratio_value = targetratio[0] / target_ratio[1]\n    target_value = (target_ratio_value / base_ratio_value) * base_value\n    \n    return target_value", "def find_proportionate_value(base_value, base_ratio, target_ratio):\n    \"\"\"\n    Calculate the target value given the base value and the target ratio based on a base ratio.\n    \n    Parameters:\n    base_value (float): Known base value.\n    base_ratio (tuple): Known base ratio (numerator, denominator).\n    target_ratio (tuple): Target ratio to find the corresponding value for (numerator, denominator).\n    \n    Returns:\n    float: The target value based on the proportionality.\n    \n    Example:\n    >>> find_proportionate_value(200, (3, 2), (4, 1))\n    400.0\n    \"\"\"\n    base_numerator, base_denominator = base_ratio\n    target_numerator, target_denominator = target_ratio\n    \n    return base_value * (target_numerator/target_denominator) / (base_numerator/base_denominator)", "def calculate_proportional_value(base_value, original_ratio, target_ratio):\n    \"\"\"\n    Calculate the proportional value based on a given ratio transformation.\n    Parameters:\n    - base_value (float): The value associated with the original_ratio.\n    - original_ratio (float): The initial ratio or proportion.\n    - target_ratio (float): The target ratio or proportion to find the equivalent value for.\n    Returns:\n    - float: The value proportional to base_value as per the target_ratio.\n    Example:\n    >>> calculate_proportional_value(200, 1, 3)\n    600\n    \"\"\"\n    return base_value * (target_ratio / original_ratio)"], ["def scale_dimensions(original_width, original_height, scale_factor):\n    \"\"\"\n    Scales dimensions by a given factor while maintaining aspect ratio.\n    \n    Parameters:\n        original_width (float or int): The original width dimension.\n        original_height (float or int): The original height dimension.\n        scale_factor (float): The factor by which to scale the dimensions.\n    Returns:\n        tuple of float: The new width and height after scaling.\n    \n    Example:\n        >>> scale_dimensions(1920, 1080, 0.5)\n        (960.0, 540.0)\n    \"\"\"\n    new_width = original_width * scale_factor\n    new_height = original_height * scale_factor\n    return (new_width, new_height)"], ["def calculate_unit_rate(quantity1, quantity2):\n    \"\"\"\n    Calculate the unit rate between two quantities.\n    \n    Parameters:\n    quantity1 (float or int): The first quantity (numerator).\n    quantity2 (float or int): The second quantity (denominator).\n    Returns:\n    float: The value of the first quantity per one unit of the second quantity.\n          \n    Example:\n    >>> calculate_unit_rate(100, 4)\n    25.0\n    >>> calculate_unit_rate(150, 3)\n    50.0\n    \"\"\"\n    if quantity2 == 0:\n        raise ValueError(\"The second quantity (denominator) cannot be zero.\")\n    return quantity1 / quantity2"], ["def calculate_missing_ratio_value(known_values, known_total, find_index):\n    \"\"\"\n    Given partial values in a ratio and a known total sum or product of all elements, find the missing value.\n    Parameters:\n    known_values (list of tuples): A list where each tuple contains the index (0-based) and the value of the known elements.\n    known_total (float): The known total sum or desired proportional product of the elements.\n    find_index (int): The index of the value to find.\n    Returns:\n    float: The calculated value at the find_index position within the distributed ratio.\n    Example:\n    >>> calculate_missing_ratio_value([(0, 2), (2, 5)], 21, 1)\n    14\n    \"\"\"\n    import math\n    \n    indices, values = zip(*known_values)\n    \n    if find_index in indices:\n        return values[indices.index(find_index)]\n    \n    # Calculate the proportionality constant\n    k = math.prod(values) / (known_total - sum(values))\n    \n    # Recreate complete ratio list based on the known total and partial values\n    total_parts = sum(values) + k * (len(values) + 1 - len(known_values))\n    ratio_values = list(values)\n    \n    # Find the missing values\n    missing_sum = known_total - sum(values)\n    factor = missing_sum / k\n    \n    # Gather all calculated ratio values\n    full_values = [factor if i not in indices else ratio_values[indices.index(i)] for i in range(len(values)+1)]\n    \n    # Return the value at the required index\n    return full_values[find_index]"], ["def calculate_unknown_in_ratio(known_part, known_ratio_part, unknown_ratio_part):\n    \"\"\"\n    Calculate the unknown part of a ratio given the known part and the parts of the ratio.\n    Parameters:\n    -----------\n    known_part : float or int\n        The known quantity part of the ratio.\n    known_ratio_part : float or int\n        The part of the ratio corresponding to the known quantity.\n    unknown_ratio_part : float or int\n        The part of the ratio corresponding to the unknown quantity.\n        \n    Returns:\n    --------\n    float\n        The calculated unknown part of the ratio.\n    \n    Examples:\n    ---------\n    >>> calculate_unknown_in_reado(18, 3, 2)\n    12.0\n    \"\"\"\n    from sympy import Rational\n    # Compute the multiplicative factor\n    factor = Rational(known_part, known_ratio_part)\n    # Calculate the unknown part\n    unknown_part = factor * unknown_readio_part\n    return float(unknown_part)"], ["def simplify_fraction(a, b):\n    \"\"\"\n    Simplifies a fraction and returns the result in lowest terms.\n    \n    Parameters:\n    a (int): Numerator.\n    b (int): Denominator.\n    \n    Returns:\n    Fraction: A Fraction object of the simplified fraction.\n    \n    Examples:\n    >>> str(simplify_fraction(8, 24))\n    '1/3'\n    >>> str(simplify_fraction(18, 15))\n    '6/5'\n    \"\"\"\n    return Fraction(a, b).limit_denominator()"], ["def scale_quantity(ratio_a, ratio_b, target_total):\n    \"\"\"\n    Scale quantities based on a given ratio summing to a target total.\n    \n    Parameters:\n    ratio_a (int): Part of the first element in the ratio.\n    ratio_b (int): Part of the second element in the ratio.\n    target_total (int): Desired total sum of the scaled quantities.\n    \n    Returns:\n    tuple: Returns the scaled values of the two parts that maintain the original ratio.\n    \n    Examples:\n    >>> scale_quantity(1, 2, 30)\n    (10, 20)\n    >>> scale_quantity(3, 1, 40)\n    (30, 10)\n    \"\"\"\n    total_parts = ratio_a + ratio_b\n    part_value = target_total / total_parts\n    return (int(part_value * ratio_a), int(part_value * ratio_b))"], ["def distribute_proportionally(values, total):\n    \"\"\"\n    Distributes a total amount proportionally according to a list of values.\n    Parameters:\n    - values (list of floats): A list representing parts of a whole.\n    - total (float): The total amount to be distributed following the proportions given by `values`.\n    Returns:\n    - list of floats: A list of amounts distributed proportionally.\n    Example:\n    >>> distribute_proportionally([1, 2, 3], 600)\n    [100.0, 200.0, 300.0]\n    \"\"\"\n    sum_values = sum(values)\n    return [(val / sum_values) * total for val in values]"], ["def apply_unit_rate(unit_rate, new_quantity):\n    \"\"\"\n    Apply a given unit rate to a new quantity to find the scaled value.\n    \n    Parameters:\n    unit_rate (float): The pre-calculated ratio or unit rate.\n    new_quantity (float or int): The amount of the unit to scale the ratio to.\n    \n    Returns:\n    float: The scaled value based on the given unit rate and new quantity.\n    \n    Example:\n    >>> apply_unit_readable_rate(25, 2)\n    50.0\n    >>> apply_unit_readable_rate(50, 4)\n    200.0\n    \"\"\"\n    return unit_rate * new_quantity"], ["def scale_unit_rate(unit_rate, scaling_factor):\n    \"\"\"\n    Scale a given unit rate by a particular factor.\n    Parameters:\n    - unit_rate (float): The base unit rate to be scaled.\n    - scaling_factor (float or int): The factor by which the unit rate is to be multiplied.\n    Returns:\n    - float: The scaled unit rate.\n    Examples:\n    >>> scale_unit_rate(5.0, 3)\n    15.0\n    >>> scale_unit_rate(7.5, 2)\n    15.0\n    \"\"\"\n    return unit_rate * scaling_factor"], ["class RatioCalculator:\n    \"\"\"\n    A class to represent and manipulate ratios.\n    Parameters\n    ----------\n    numerator : float or int\n        The numerator of the ratio.\n    denominator : float or int\n        The denominator of the ratio.\n    Methods\n    -------\n    scale(scaling_factor)\n        Returns a tuple representing the scaled ratio.\n    get_proportion(target_numerator=None, target_denominator=None)\n        Calculate and return a tuple for the proportion corresponding to a specified target numerator or denominator.\n    Examples\n    --------\n    >>> ratio = RatioCalculator(2, 3)\n    >>> ratio.scale(2)\n    (4, 6)\n    >>> ratio.get_proportion(target_numerator=10)\n    (10, 15)\n    \"\"\"\n    def __init__(self, numerator, denominator):\n        self.numerator = numerator\n        self.denominator = denominator\n    def scale(self, scaling_factor):\n        \"\"\"\n        Scale the ratio by a given factor.\n        Parameters\n        ----------\n        scaling_factor : float or int\n            Factor by which to scale the ratio.\n        Returns\n        -------\n        tuple\n            A tuple (scaled_numerator, scaled_denominator) representing the scaled ratio.\n        \"\"\"\n        scaled_numerator = self.numerator * scaling_calor\n        scaled_denominator = self.denominator * scaling_factor\n        return (scaled_numerator, scaled_denominator)\n    def get_proportion(self, target_numerator=None, target_denominator=None):\n        \"\"\"\n        Calculate the proportion based on either the numerator or the denominator.\n        Parameters\n        ----------\n        target_numerator : optional, float or int\n            Specify the desired numerator to find its corresponding denominator.\n        target_denominator : optional, float or int\n            Specify the desired denominator to find its corresponding numerator.\n        Returns\n        -------\n        tuple\n            Depending on the specified target (either numerator or denominator), returns\n            the proportion as a tuple of (numerator, denominator).\n        Raises\n        ------\n        ValueError\n            If neither or both target_numerator and target_denominator are specified.\n        \"\"\"\n        if target_numerator is not None and target_denomination is None:\n            calculated_denominator = (target_numerator / self.numerator) * self.denominator\n            return (target_numerator, calculated_denominator)\n        elif  target_denominationis not None and target_numerator is None:\n            calculated_numerator = (target_denominator / self.denominator) * self.numerator\n            return (calculated_numerator, target_denominator)\n        else:\n            raise ValueError(\"Specify exactly one of target_numerator or target_denominator.\")"], ["def convert_units(value, from_unit, to_unit):\n    \"\"\"\n    Converts a given value from one unit to another based on provided conversion factors.\n    \n    Parameters:\n    value (float): The value to be converted.\n    from_unit (str): The unit the value is currently expressed in.\n    to_unit (str): The unit the value needs to be converted to.\n    \n    Returns:\n    float: The value in the new unit.\n    \n    Example:\n    # Converting 1000 meters to kilometers\n    >>> convert_units(1000, 'm', 'km')\n    1.0\n    \"\"\"\n    unit_conversions = {\n        'm': 1,\n        'km': kilo,\n        'mm': milli,\n        'um': micro,\n        'mg': milli,\n        'kg': kilo,\n        'MB': mega,\n    }\n    \n    if from_unit not in unit_conversions or to_unit not in unit_conversions:\n        raise ValueError(\"Unsupported unit conversion\")\n    \n    value_in_meters = value * unit_conversions[from_unit]\n    value_in_target_unit = value_in_meters / unit_conversions[to_unit]\n    \n    return value_in_target_unit"], ["def compute_ratio(value1, value2):\n    \"\"\"\n    Computes the ratio of two values which is a simple division of one by another.\n    Parameters:\n    - value1 (float or int): Numerator in the calculation of the ratio.\n    - value2 (float or int): Denominator in the calculation of the ratio.\n    Returns:\n    - float: The computed ratio.\n    Examples:\n    >>> compute_ratio(10, 2)\n    5.0\n    >>> compute_ratio(7, 14)\n    0.5\n    \"\"\"\n    try:\n        return value1 / value2\n    except ZeroDivisionError:\n        return float('inf')  # To handle division by zero gracefully, often returned as infinity in mathematical contexts."], ["def simplify_ratio(*args: int) -> Tuple[int, ...]:\n    \"\"\"\n    Simplifies a ratio of two or more integers to its simplest form.\n    Parameters:\n    - args (int): Variable number of integers comprising the ratio.\n    Returns:\n    - Tuple[int, ...]: The simplified ratio as a tuple of integers.\n    Examples:\n    >>> simplify_ratio(2, 4)\n    (1, 2)\n    >>> simplify_ratio(3, 6, 9)\n    (1, 2, 3)\n    \"\"\"\n    if not all(isinstance(x, int) for x in args):\n        raise ValueError(\"All inputs must be integers.\")\n    gcd = math.gcd(*args)\n    return tuple(x // gcd for x in args)"], ["def compute_ratio(part, whole):\n    \"\"\"\n    Computes the ratio of a part to a whole, expressed in the simplest fractional form.\n    Parameters:\n    - part (float|int): The part or subset quantity\n    - whole (float|int): The total or whole quantity\n    Returns:\n    - tuple (int, int): The ratio in the form of a numerator and denominator (simplest form).\n    Examples:\n    >>> compute_ratio(2, 8)\n    (1, 4)\n    >>> compute_ratio(3, 12)\n    (1, 4)\n    \"\"\"\n    from math import gcd\n    divisor = gcd(int(part), int(whole))\n    return (part // divisor, whole // divisor)"], ["def triangle_angle_from_ratio(angle_a, ratio_ab, target='B'):\n    \"\"\"\n    Given an angle of a triangle and the ratio of two sides, compute the other angle.\n    Parameters:\n    - angle_a (float): Known angle in degrees.\n    - ratio_ab (tuple): A tuple of two integers (part_a, part_b) representing the ratio of sides opposite to\n                        angle A and B respectively.\n    - target (str): The target angle to compute. Either 'B' or 'C'.\n    Returns:\n    - float: The computed angle in degrees. If the triangle is assumed similar and sum of angles in a\n             triangle is 180 degrees.\n    Examples:\n    >>> triangle_angle_from_ratio(45, (1, 1), 'B')\n    45.0\n    >>> triangle_angle_from_ratio(60, (2, 1), 'C')\n    30.0\n    \"\"\"\n    if target == 'C':\n        # if sum of angles in triangle is 180\n        angle_b = angle_a * (ratio_ab[0] / ratio_ab[1])\n        return 180 - angle_a - angle_b\n    elif target == 'B':\n        angle_b = angle_a * (ratio_ab[1] / ratio_ab[0])\n        return angle_b\n    else:\n        raise ValueError(\"Invalid target angle specified. Choose either 'B' or 'C'\")"], ["def simplify_ratio(a, b):\n    \"\"\"\n    Simplify the given ratio to its simplest form using greatest common divisor.\n    Parameters:\n        a (int or float): The first quantity in the ratio.\n        b (int or float): The second quantity in the ratio.\n    Returns:\n        tuple: A tuple representing the simplified ratio.\n    Examples:\n        >>> simplify_ratio(10, 15)\n        (2, 3)\n    \"\"\"\n    return create_ratio(a, b)  # Reuse function for simplification"], ["def calculate_unit_rate(value_a, value_b):\n    \"\"\"\n    Calculate the unit rate or ratio of two values.\n    Parameters:\n    - value_a (float or int): Represents the first quantity in the ratio.\n    - value_b (float or int): Represents the second quantity with which the first quantity is being compared.\n    Returns:\n    - float: The unit rate or ratio value_a/value_b.\n    Examples:\n    >>> calculate_unit_rate(10, 2)\n    5.0\n    >>> calculate_unit_rate(50, 4)\n    12.5\n    \"\"\"\n    return value_a / value_b if value_b != 0 else None"], ["def triangle_angle_ratios(angle_ratio: Tuple[int, ...], known_angle: Tuple[int, float] = None) -> List[float]:\n    \"\"\"\n    Calculates the angles of a triangle given the ratio of these angles. Optionally, one angle measure can be provided.\n    Parameters:\n    - angle_ratio (tuple of int): Ratio of the angles. e.g., (2, 3, 4) for angles that are in the ratio 2:3:4.\n    - known_angle (tuple of int, float, optional): A tuple where the first element is an index of the angle (0-based) within\n      the ratio and the second element is the known angle measure in degrees.\n    Returns:\n    - List[float]: A list of the triangle's angles in degrees.\n    Examples:\n    >>> triangle_angle_ratios((2, 3, 5))\n    [36.0, 54.0, 90.0]\n    >>> triangle_angle_ratios((1, 1, 1))\n    [60.0, 60.0, 60.0]\n    >>> triangle_angle_ratios((2, 3, 5), (1, 54))\n    [24.0, 54.0, 102.0]\n    \"\"\"\n    ratio_syms = sp.symbols('a0:%d' % len(angle_ratio))  # dynamic symbol generation based on ratio length\n    equations = [r - rat * ratio_syms[0] for rat, r in zip(angle_ratio[1:], ratio_syms[1:])]\n    sum_constraint = sp.Eq(sum(ratio_syms), 180)\n    equations.append(sumconstraint)\n    if known_angle:\n        known_index, known_value = known_angle\n        known_constraint = sp.Eq(ratio_syms[known_index], known_value)\n        equations.append(known_constraint)\n    \n    sol = sp.solve(equations, ratio_syms)\n    \n    if sol:\n        return [float(sol[s]) for s in ratio_syms]\n    else:\n        return []"], ["def calculate_simplified_ratio(value1, value2):\n    \"\"\"\n    Calculate the simplified ratio between two values.\n    \n    Parameters:\n    value1 (int/float): The first value.\n    value2 (int/float): The second value.\n  \n    Returns:\n    Rational: The simplified ratio of the two values.\n    \n    Example:\n    >>> calculate_simplified_ratio(150, 100)\n    Rational(3, 2)\n    \"\"\"\n    return nsimplify(Rational(value1, value2))"], ["def scale_ratio(a, b, factor):\n    \"\"\"\n    Scales both terms of a given ratio by the specified factor.\n    Parameters:\n        a (int or float): The first quantity in the ratio.\n        b (int or float): The second quantity in the ratio.\n        factor (int or float): The factor by which to scale the ratio.\n    Returns:\n        tuple: A tuple representing the scaled ratio.\n    Examples:\n        >>> scale_ratio(3, 4, 3)\n        (9, 12)\n    \"\"\"\n    return (a * factor, b * factor)"]], "Division": [["def simple_divide(numerator, denominator):\n    \"\"\"\n    Perform a simple division operation and guard against division by zero.\n    Parameters\n    ----------\n    numerator : float or int\n        The numerator in the division.\n    denominator : float or int\n        The denominator in the division. Must not be zero.\n    Returns\n    -------\n    float\n        The result of the division operation.\n    Raises\n    ------\n    ValueError\n        If the denominator is zero.\n    Examples\n    --------\n    >>> simple_divide(10, 2)\n    5.0\n    >>> simple_divide(7, 0)\n    ValueError: Denominator cannot be zero.\n    \"\"\"\n    if denominator == 0:\n        raise ValueError(\"Denominator cannot be zero.\")\n    return numerator / denominator", "def divide_numbers(numerator, denominator):\n    \"\"\"\n    Divide two numbers and handle edge cases such as division by zero.\n    \n    Parameters:\n    - numerator (float): The number to be divided.\n    - denominator (float): The number by which the numerator is divided.\n    \n    Returns:\n    - float | str: The result of the division if the denominator isn't zero, otherwise returns an error message.\n    \n    Examples:\n    >>> divide_numbers(10, 2)\n    5.0\n    >>> divide_numbers(10, 0)\n    'Error: Division by zero'\n    \"\"\"\n    if denominator == 0:\n        return \"Error: Division by zero\"\n    else:\n        return numerator / denominator", "def divide_numbers(numerator, denominator):\n    \"\"\"\n    Perform division of two numbers, handling integers and floats.\n    \n    Parameters:\n        numerator (float or int): The dividend.\n        denominator (float or int): The divisor, must not be zero.\n    Returns:\n        float: The result of the division.\n    Example:\n        >>> divide_numbers(10, 2)\n        5.0\n        >>> divide_numbers(12.5, 5)\n        2.5\n    \"\"\"\n    if denominator == 0:\n        raise ValueError(\"Denominator cannot be zero.\")\n    return numerator / denominator", "def integer_division(numerator, denominator):\n    \"\"\"\n    Performs integer division and returns the quotient and remainder.\n    \n    Parameters:\n        numerator (int): The dividend.\n        denominator (int): The divisor, must not be zero.\n    Returns:\n        tuple: A tuple containing the quotient and remainder.\n    \n    Example:\n        >>> integer_division(10, 3)\n        (3, 1)\n        >>> integer_division(25, 5)\n        (5, 0)\n    \"\"\"\n    if denominator == 0:\n        raise ValueError(\"Denominator cannot be zero.\")\n    return divmod(numerator, denominator)", "def simple_divide(numerator, denominator):\n    \"\"\"\n    Perform a simple division of two numbers with error handling for division by zero.\n    \n    Parameters:\n    numerator (float): The dividend.\n    denominator (float): The divisor, must not be zero.\n    Returns:\n    float: The quotient of the division.\n    None: If denominator is zero, to avoid division error.\n    Examples:\n    >>> simple_divide(10, 2)\n    5.0\n    >>> simple_divide(5, 0)\n    None\n    \"\"\"\n    if denominator == 0:\n        print(\"Error: Division by zero is not allowed.\")\n        return None\n    else:\n        return numerator / denominator", "def division_with_remainders(numerator, denominator):\n    \"\"\"\n    Performs division and returns both the quotient and the remainder.\n    Parameters:\n    numerator (int): The number to be divided.\n    denominator (int): The number to divide by.\n    Returns:\n    tuple: A tuple containing (quotient, remainder).\n    Examples:\n    >>> division_with_remainders(10, 3)\n    (3, 1)\n    \"\"\"\n    if denominator == 0:\n        print(\"Error: Division by zero is not allowed.\")\n        return None\n    quotient = numerator // denominator\n    remainder = numerator % denominator\n    return (quotient, remainder)"], ["def compute_average(data):\n    \"\"\"\n    Calculate the average of a list of numbers.\n    Parameters:\n    data (list of float/int): A list containing the numbers to average.\n    Returns:\n    float: The average of the numbers in the list.\n    \n    Exceptions:\n    ValueError: If `data` is empty, raising an exception to avoid division by zero.\n    Examples:\n    >>> compute_average([1, 2, 3, 4, 5])\n    3.0\n    >>> compute_average([])\n    ValueError: Data list is empty, cannot compute average.\n    \"\"\"\n    if not data:\n        raise ValueError(\"Data list is empty, cannot compute average.\")\n    return sum(data) / len(data)", "def calculate_average(numbers):\n    \"\"\"\n    Calculate the average of a list of numbers using division.\n    \n    Parameters:\n    - numbers (list of float|int): The list of numbers to calculate the average.\n    \n    Returns:\n    - float: The average of the numbers.\n    \n    Examples:\n    >>> calculate_average([1, 2, 3, 4, 5])\n    3.0\n    >>> calculate_average([])\n    'Error: Empty list'\n    \"\"\"\n    if not numbers:\n        return \"Error: Empty list\"\n    total_sum = sum(numbers)\n    return total|r|null of these numbers through a consistent explanation and usable examples. Uniformity across documentation helps in comprehension and usability|sum / len(numbers)"], ["def safe_divide(numerator, denominator, default=float('nan')):\n    \"\"\"\n    Perform safe division of two numbers while handling division by zero.\n    \n    Parameters:\n    numerator (float or int): The numerator in the division operation.\n    denominator (float or int): The denominator in the division operation.\n    default (any, optional): The default return value if division by zero occurs.\n    \n    Returns:\n    float: Result of the division or a default value if a zero-division error occurs.\n    \n    Examples:\n    >>> safe_divire(10, 2)\n    5.0\n    >>> safe_divide(5, 0)\n    nan\n    >>> safe_divide(5, 0, 'undefined')\n    'undefined'\n    \"\"\"\n    if denominator == 0:\n        return default\n    else:\n        return numerator / denominator", "def safe_division(numerator, denominator, round_result=False, decimals=2, return_integer=False):\n    \"\"\"\n    Perform a safe division with options to round and control output type.\n    \n    Parameters\n    ----------\n    numerator : float or int\n        The number to be divided (dividend).\n    denominator : float or int \n        The number by which to divide (divisor).\n    round_result : bool, optional\n        Whether to round the result. Default is False.\n    decimals : int, optional\n        Number of decimal places to round to if rounding is True. Default is 2.\n    return_integer : bool, optional\n        Whether to return the result as an integer (uses floor division if True). Default is False.\n    \n    Returns\n    -------\n    float or int\n        The result of the division, or None if division by zero occurs.\n    \n    Examples\n    --------\n    >>> safe_division(10, 2)\n    5.0\n    >>> safe_division(10, 3, round_result=True, decimals=1)\n    3.3\n    >>> safe_division(10, 0)  # Safe handling of division by zero\n    None\n    >>> safe_division(10, 3, return_integer=True)\n    3\n    \"\"\"\n    if denominator == 0:\n        return None\n    result = numerator / denominator\n    if return_integer:\n        return int(result)  # floor division behavior\n    if round_result:\n        return round(result, decimals)\n    return result"], ["def integer_division(dividend, divisor):\n    \"\"\"\n    Perform integer division on two numbers, returning both quotient and remainder.\n    \n    Parameters:\n    - dividend (int or float): The number to be divided.\n    - divisor (int or float): The number by which to divide.\n    Returns:\n    - tuple: A tuple containing the quotient and remainder (quotient, remainder).\n    Examples:\n    >>> integer_division(10, 3)\n    (3, 1)\n    >>> integer_division(15, 5)\n    (3, 0)\n    >>> integer_division(20, 7)\n    (2, 6)\n    \"\"\"\n    if divisor == 0:\n        raise ValueError(\"Divisor cannot be zero.\")\n    quotient = dividend // divisor\n    remainder = dividend % divisor\n    return quotient, remainder", "def get_remainder(dividend, divisor):\n    \"\"\"\n    Get the remainder from the division of two numbers.\n    Parameters:\n    - dividend (int or float): The numerator in the division.\n    - divisor (int or float): The denominator in the division.\n    Returns:\n    - int or float: The remainder of the division.\n    Examples:\n    >>> get_remainder(10, 3)\n    1\n    >>> get_remainder(18, 4)\n    2\n    \"\"\"\n    if divisor == 0:\n        raise ValueError(\"Divisor cannot be zero.\")\n    return dividend % divisor", "def perform_division(dividend, divisor):\n    \"\"\"\n    Perform division and return the quotient and remainder.\n    Parameters:\n        dividend (int, float): The number to be divided.\n        divisor (int, float): The number by which to divide.\n    Returns:\n        tuple: A tuple containing the quotient and remainder.\n    Examples:\n        >>> perform_division(23, 5)\n        (4.6, 3)\n    \"\"\"\n    quotient = divisor // dividend\n    remainder = divisor % dividend\n    return (quotient, remainder)", "def integer_division(dividend, divisor):\n    \"\"\"\n    Perform integer division on the provided dividend and divisor, returning both the quotient and the remainder.\n    Parameters:\n    - dividend (int): The number to be divided.\n    - divisor (int): The number by which the dividend is divided.\n    Returns:\n    - tuple: A tuple containing the quotient and remainder (quotient, remainder).\n    \n    Examples:\n    - integer_division(10, 3) returns (3, 1)\n    - integer_division(20, 5) returns (4, 0)\n    \"\"\"\n    quotient = np.floor_divide(dividend, divisor)\n    remainder = np.remainder(dividend, divisor)\n    return (quotient, remainder)", "def perform_division(dividend, divisor):\n    \"\"\"\n    Perform a basic division of two numbers, handling exceptions like division by zero.\n    \n    Parameters:\n    - dividend (float or int): The numerator in the division.\n    - divisor (float or int): The denominator in the division.\n    \n    Returns:\n    float: The result of the division.\n        If divisor is zero, returns None for safety, indicating indeterminate or infinite.\n    \n    Examples:\n    >>> perform_division(10, 2)\n    5.0\n    >>> perform_division(5, 0)\n    None\n    \"\"\"\n    if divisor == 0:\n        print(\"Error: Division by zero is undefined.\")\n        return None\n    return dividend / divisor", "def integer_division(dividend, divisor):\n    \"\"\"\n    Perform integer division and return the quotient and remainder.\n    \n    Parameters:\n    - dividend (int): The number to be divided.\n    - divisor (int): The number by which we divide the dividend.\n    \n    Returns:\n    tuple:\n        - quotient (int)\n        - remainder (int)\n    \n    Raises:\n    - ValueError: If the divisor is zero.\n    \n    Examples:\n    >>> integer_division(10, 3)\n    (3, 1)\n    >>> integer_division(20, 5)\n    (4, 0)\n    \"\"\"\n    if divisor == 0:\n        raise ValueError(\"Divisor cannot be zero.\")\n    \n    quotient = dividend // divisor\n    remainder = dividend % divisor\n    \n    return quotient, remainder"], ["def polynomial_division_modular(poly, divisor, modulus):\n    \"\"\"\n    Perform polynomial division in the context of modular arithmetic.\n    \n    Parameters:\n    - poly (sympy.Poly or str): Polynomial to be divided,\n                                accepted as either a sympy Poly object or a string representation.\n    - divisor (sympy.Poly or int or str): Divisor polynomial or integer,\n                                          accepted as either a sympy Poly object, an integer,\n                                          or a string representation.\n    - modulus (int): The modulus to apply for polynomial division.\n    Returns:\n    - tuple (sympy.Poly, sympy.Poly): Quotient and remainder polynomials after division.\n    Examples:\n    >>> polynomial_division_modular(\"x^2 + 4*x + 4\", \"x + 2\", 5)\n    (x + 2*x**0, 0)\n    >>> polynomial_division_modular(\"x^3 + x + 1\", 3, 7)\n    (x**3/3 + x/3 + 1/3, 0)\n    \"\"\"\n    x = symbols('x')\n    if isinstance(poly, str):\n        poly = Poly(poly, x)\n    if isinstance(divisor, (int, str)):\n        divisor = Poly(divisor, x)\n    \n    quotient, remainder = div(poly, divisor, domain=GF(modulus))\n    return (quotient, remainder)", "def polynomial_modular_division(poly, modulus, variable='x'):\n    \"\"\"\n    Perform polynomial division in the context of modular arithmetic, returning the resulting polynomial and remainder.\n    Parameters:\n    - poly (str): Polynomial represented as a string, e.g., 'x**2 - 4*x + 4'.\n    - modulus (int): The modulus for the division.\n    - variable (str, optional): The main variable used in the polynomial. Default is 'x'.\n    \n    Returns:\n    - tuple: A tuple containing the quotient polynomial and remainder polynomial as strings (quotient, remainder).\n    \n    Examples:\n    - polynomial_modular_division('x**2 - 4*x + 4', 3) returns ('x**2 + 2*x + 1', '0')\n    - polynomial_modular_division('x**4 - 1', 5, 'x') returns ('x**4 + 4', '0')\n    \"\"\"\n    x = sp.symbols(variable)\n    polynomial = sp.sympify(poly)\n    quotient, remainder = sp.div(polynomial, modulus, domain='ZZ')\n    return (str(quotient), str(remainder))"], ["def count_integers_in_interval(start, end, divisor):\n    \"\"\"\n    Count the number of integers within a specified range [start, end] that are divisible by a given divisor.\n    Parameters:\n        start (int): The starting integer of the interval.\n        end (int): The ending integer of the interval.\n        divisor (int): The divisor to check divisibility.\n    Returns:\n        int: Count of divisible integers in the interval.\n    Examples:\n        >>> count_integers_in_interval(1, 10, 3)\n        3\n    \"\"\"\n    count = 0\n    for i in range(start, end + 1):\n        if i % divisor == 0:\n            count += 1\n    return count", "def find_divisibles_in_range(start, end, divisor):\n    \"\"\"\n    Find all numbers within a range that are divisible by a given divisor.\n    \n    Parameters:\n    start (int): The starting number of the range.\n    end (int): The end number of the range (inclusive).\n    divisor (int): The divisor.\n    \n    Returns:\n    list: A list of numbers divisible by the divisor.\n    Example:\n    >>> find_divisibles_in_range(1, 10, 2)\n    [2, 4, 6, 8, 10]\n    \"\"\"\n    return [n for n in range(start, end + 1) if n % divisor == 0]", "def interval_divisor_count(start, end, divisor):\n    \"\"\"\n    Counts how many integers within a specified interval [start, end) are divisible by 'divisor'.\n    \n    Parameters:\n        start (int): Start of the interval.\n        end (int): End of the interval.\n        divisor (int): The divisor to check divisibility against.\n    Returns:\n        int: Count of divisible numbers.\n    \n    Example:\n        >>> interval_divisor_count(1, 10, 2)\n        5\n        >>> interval_divisor_count(1, 100, 10)\n        10\n    \"\"\"\n    count = 0\n    for number in range(start, end):\n        if number % divisor == 0:\n            count += 1\n    return count"], ["def evaluate_expression(expression):\n    \"\"\"\n    Evaluate a mathematical expression, particularly handling the order of operations\n    including division.\n    Parameters:\n    expression (str): The mathematical expression to evaluate.\n    Returns:\n    float: The result of the evaluated expression.\n    Examples:\n    >>> evaluate_expression(\"12 / 3 / 2\")\n    2.0\n    >>> evaluate_expression(\"(10 + 5) / 3\")\n    5.0\n    \"\"\"\n    return float(sp.sympify(expression))", "def evaluate_expression(expression):\n    \"\"\"\n    Evaluate a mathematical expression, ensuring correct order of operations,\n    including handling division correctly.\n    Parameters\n    ----------\n    expression : str\n        A string representing the mathematical expression to evaluate.\n    Returns\n    -------\n    float or sympy.Expr\n        The result of the evaluated expression. Returns a sympy.Expr object\n        if the expression involves symbols.\n    Examples\n    --------\n    >>> evaluate_expression(\"6 / 3 + (2 * 5)\")\n    11.0\n    >>> evaluate_expression(\"(10 + 10) / 4\")\n    5.0\n    >>> evaluate_expression(\"x/2 + 1\", evaluate=False)\n    x/2 + 1\n    \"\"\"\n    try:\n        # Parsing the expression and evaluating it\n        expr = sp.sympify(expression)\n        # Evaluating the expression numerically if possible\n        return expr.evalf()\n    except sp.SympifyError as e:\n        raise ValueError(f\"Invalid expression: {expression}. Error: {str(e)}\")", "def evaluate_expression(expression):\n    \"\"\"\n    Evaluate an arithmetic expression respecting order of operations, including handling parentheses.\n    Parameters:\n    - expression (str): The string representation of the arithmetic expression.\n    \n    Returns:\n    - float | sympy.Expr: Numeric result of the expression, expression result if contains variables.\n    \n    Examples:\n    >>> evaluate_expression('12 / (3 + 3)')\n    2.0\n    >>> evaluate_expression('12 / 3 + 2 - 5 * 2')\n    -1.0\n    \"\"\"\n    return sp.sympify(expression).evalf()"], ["def long_division(dividend, divisor):\n    \"\"\"\n    Perform long division and give a decimal result up to a specified number of decimal places.\n    \n    Parameters:\n    - dividend (int or float): The number to be divided.\n    - divisor (int or float): The number by which to divide.\n    - precision (int): The desired decimal precision.\n    Returns:\n    - float: The result of the division up to the specified decimal places.\n    Examples:\n    >>> long_division(10, 3, precision=3)\n    3.333\n    >>> long_division(15, 7, precision=5)\n    2.14286\n    \"\"\"\n    if divisor == 0:\n        raise ValueError(\"Divisor cannot be zero.\")\n    result = dividend / divisor\n    return round(result, precision)", "def long_division(numerator, denominator, precision=10):\n    \"\"\"\n    Perform long division on two numbers and return the decimal expansion to a specified precision.\n    \n    Parameters:\n    - numerator (int): The numerator of the fraction.\n    - denominator (int): The denominator of the fraction.\n    - precision (int, optional): Number of decimal places. Default is 10.\n    \n    Returns:\n    - str: A string representation of the decimal expansion.\n    \n    Examples:\n    - long_division(1, 3) returns '0.3333333333'\n    - long_division(2, 5) returns '0.4'\n    \"\"\"\n    result = numerator / denominator\n    return f\"{result:.{precision}f}\"", "def long_division(dividend, divisor, precision=10):\n    \"\"\"\n    Execute long division to find the decimal representation of the dividend/divisor ratio up to a given precision.\n    Parameters:\n    - dividend (int): The numerator in the division.\n    - divisor (int): The denominator in the slam division.\n    - precision (int, optional): The number of decimal places to calculate. Defaults to 10.\n    Returns:\n    str: The decimal representation of the result.\n    \n    Raises:\n    - ValueError: If the divisor is zero.\n    Examples:\n    >>> long_division(22, 7)\n    '3.1428571429'\n    >>> long_division(5, 2)\n    '2.5'\n    \"\"\"\n    if divisor == 0:\n        raise ValueError(\"Divisor cannot be zero.\")\n    \n    decimal.getcontext().prec = precision\n    result = decimal.Decimal(dividend) / decimal.Decimal(divisor)\n    \n    return str(result)"], ["def division_with_rounding(total_quantity, divider):\n    \"\"\"\n    Divide `total_quantity` by `divider` and round the result to the nearest whole number.\n    Parameters:\n    total_quantity (float): The total quantity to divide.\n    divider (float): The number by which to divide the total quantity.\n    Returns:\n    int: Result of the division rounded to the nearest whole number.\n    Examples:\n    >>> division_with_rounding(100.5, 3)\n    34\n    >>> division_with_rounding(7, 3)\n    2\n    \"\"\"\n    return round(total_quantity / divider)"], ["def divide_fractions(fraction1, fraction2):\n    \"\"\"\n    Divides two fractions.\n    \n    Parameters:\n    fraction1 (Fraction): The dividend fraction.\n    fraction2 (Fraction): The divisor fraction.\n    \n    Returns:\n    Fraction: The result of the division.\n    \n    Example:\n    >>> divide_fractions(Fraction(1, 2), Fraction(3, 4))\n    Fraction(2, 3)\n    \"\"\"\n    return fraction1 / fraction2"], ["def repetitive_division(total_quantity, unit_size):\n    \"\"\"\n    Calculate how many times `unit_size` fits into `total_quantity` repeatedly.\n    Parameters:\n    total_quantity (int): The total quantity that needs to be divided.\n    unit_size (int): The size of one unit.\n    Returns:\n    int: The number of times the unit size fits into the total quantity.\n    Examples:\n    >>> repetitive_division(100, 10)\n    10\n    >>> repetitive_division(45, 2)\n    22\n    \"\"\"\n    count = 0\n    while total_quantity >= unit_size:\n        total_quantity -= unit_size\n        count += 1\n    return count"], ["def is_divisible_by(number, divisor):\n    \"\"\"\n    Check if a number is divisible by another number.\n    Parameters:\n    number (int): The number to check.\n    divisor (int): The divisor.\n    Returns:\n    bool: True if number is divisible by divisor, else False.\n    Example:\n    >>> is_divisible_by(15, 3)\n    True\n    \"\"\"\n    return number % divisor == 0"], ["def modular_expression(value, modulo):\n    \"\"\"\n    Compute the result of an integer modulo operation.\n    Parameters:\n    - value (int): The integer to be taken modulo.\n    - modulo (int): The modulus.\n    Returns:\n    int: The result of the modulo operation.\n    \n    Examples:\n    >>> modular_expression(10, 3)\n    1\n    >>> modular_expression(25, 4)\n    1\n    \"\"\"\n    return value % modulo"], ["def calculate_fit_and_remainder(total, unit_size, return_remainder=False):\n    \"\"\"\n    Calculate how many full units fit into the total amount and optionally get the remainder.\n    \n    Parameters\n    ----------\n    total : int\n        The total amount to be divided.\n    unit_size : int\n        The size of each unit.\n    return_remainder : bool, optional\n        If True, return both the number of full units that fit and the remainder. Default is False.\n    \n    Returns\n    -------\n    tuple or int\n        Number of full units that fit, and optionally the remainder.\n    \n    Examples\n    --------\n    >>> calculate_fit_and_remainder(100, 3)\n    33\n    >>> calculate_fit_and_remainder(100, 3, return_remainder=True)\n    (33, 1)  # 33 full units, and 1 left over\n    \"\"\"\n    if unit_size == 0:\n        raise ValueError(\"unit_size cannot be zero.\")\n    count = total // unit_size\n    remainder = total % unit_size\n    if return_remainder:\n        return count, remainder\n    return count"], ["def simplify_fraction(numerator, denominator):\n    \"\"\"\n    Simplify a fraction to its lowest terms.\n    \n    Parameters:\n        numerator (int): The numerator of the fraction.\n        denominator (int): The denominator of the fraction.\n    Returns:\n        Fraction: The simplified fraction.\n    Examples:\n        >>> simplify_fraction(8, 20)\n        Fraction(2, 5)\n    \"\"\"\n    return Fraction(numerator, denominator)", "def simplify_fraction(numerator, denominator):\n    \"\"\"\n    Simplify a fraction represented by numerator and denominator.\n    \n    Parameters:\n    numerator (int): the numerator of the fraction\n    denominator (int): the denominator of the fraction\n    \n    Returns:\n    Fraction: a simplified fraction\n    \n    Example:\n    >>> simplify_fraction(8, 12)\n    Fraction(2, 3)\n    \"\"\"\n    return Fraction(numerator, denominator)", "def simplify_fraction(numerator, denominator):\n    \"\"\"\n    Simplifies a fraction using greatest common divisor.\n    \n    Parameters:\n        numerator (int): The numerator of the fraction.\n        denominator (int): The denominator of the fraction, must not be zero.\n    Returns:\n        Rational: A simplified fraction.\n    Example:\n        >>> simplify_fraction(8, 12)\n        2/3\n        >>> simplify_fraction(20, 5)\n        4\n    \"\"\"\n    if denominator == 0:\n        raise ValueError(\"Denominator cannot be zero.\")\n    return Rational(numerator, denominator)"], ["def convert_units(value, from_unit, to_unit):\n    \"\"\"\n    Converts a numerical value from one unit to another. This function currently supports simple direct linear conversions.\n    \n    Note: The conversion factors must be known and provided.\n    Parameters:\n        value (float, int): The value to convert.\n        from_unit (str): The unit to convert from.\n        to_unit (str): The unit to convert to.\n    Returns:\n        float: The converted value.\n    Example:\n        >>> convert_units(5000, 'grams', 'kilograms')\n        5.0\n    \"\"\"\n    conversion_factors = {\n        ('grams', 'kilograms'): 0.001,\n        ('dollars', 'cents'): 100,\n        ('minutes', 'hours'): 1/60,\n        ('kilograms', 'grams'): 1000,\n        ('cents', 'dollars'): 0.01\n    }\n    \n    if (from_unit, to_unit) in conversion_factors:\n        return value * conversion_factors[(from_unit, to_unit)]\n    else:\n        raise ValueError(\"Unsupported unit conversion\")", "def convert_units(value, from_unit, to_unit, conversion_factor):\n    \"\"\"\n    Converts a value from one unit to another using a conversion factor.\n    \n    Parameters:\n    value (float): The value to convert.\n    from_unit (str): The current unit of the value.\n    to_unit (str): The target unit to convert to.\n    conversion_factor (float): The factor used to perform the conversion.\n    \n    Returns:\n    float: The value converted into the new unit.\n    \n    Example:\n    >>> convert_units(1000, 'grams', 'kilograms', 0.001)\n    1.0\n    \"\"\"\n    return value * conversion_factor", "def convert_units(amount, conversion_factor):\n    \"\"\"\n    Convert an amount from one unit to another using a conversion factor.\n    \n    Parameters:\n        amount (float or int): The amount to be converted.\n        conversion_factor (float or int): The factor used to convert the units.\n    Returns:\n        float: The converted amount.\n    Example:\n        >>> convert_units(1000, 0.001)  # grams to kilograms\n        1.0\n        >>> convert_units(1, 100)       # dollars to cents\n        100.0\n    \"\"\"\n    return amount * conversion_factor"], ["def convert_to_mixed_number(numerator, denominator):\n    \"\"\"\n    Convert an improper fraction to a mixed number.\n    Parameters:\n        numerator (int): The numerator of the fraction.\n        denominator (int): The denominator of the fraction.\n        \n    Returns:\n        tuple: A tuple in the form (whole number, (numerator, denominator))\n    Examples:\n        >>> convert_to_mixed_number(22, 7)\n        (3, (1, 7))\n    \"\"\"\n    simple_fraction = simplify_fraction(numerator, denominator)\n    whole_number = simple_fraction.numerator // simple_fraction.denominator\n    rem_numerator = simple_fraction.numerator % simple_fraction.denominator\n    rem_fraction = (rem_numerator, simple_fraction.denominator)\n    \n    return (whole_number, rem_fraction)", "def mixed_to_improper(whole, numerator, denominator):\n    \"\"\"\n    Convert a mixed number to an improper fraction.\n    \n    Parameters:\n    whole (int): The whole number part of the mixed number.\n    numerator (int): The fractional part's numerator of the mixed number.\n    denominator (int): The fractional part's denominator of the mixed number.\n    \n    Returns:\n    Fraction: an improper fraction representing the mixed number.\n    \n    Example:\n    >>> mixed_to_improper(3, 1, 4)\n    Fraction(13, 4)\n    \"\"\"\n    return Fraction(whole * denominator + numerator, denominator)", "def improper_to_mixed(fraction):\n    \"\"\"\n    Convert an improper fraction to a mixed number.\n    \n    Parameters:\n    fraction (Fraction): The improper fraction to convert.\n    Returns:\n    tuple: A tuple representing the mixed number (whole, numerator, denominator).\n    \n    Example:\n    >>> improper_to_mixed(Fraction(13, 4))\n    (3, 1, 4)\n    \"\"\"\n    whole = fraction.numerator // fraction.denominator\n    remainder = fraction.numerator % fraction.denominator\n    return (whole, remainder, fraction.denominator)", "def convert_to_mixed_number(numerator, denominator):\n    \"\"\"\n    Converts an improper fraction to a mixed number.\n    \n    Parameters:\n        numerator (int): The numerator of the fraction.\n        denominator (int): The denominator of the fraction, must not be zero.\n    Returns:\n        tuple: A tuple indicating the mixed number (whole part, fractional part)\n    \n    Example:\n        >>> convert_to_mixed_number(17, 5)\n        (3, 2/5)\n        >>> convert_to_mixed_number(7, 3)\n        (2, 1/3)\n    \"\"\"\n    if denominator == 0:\n        raise ValueError(\"Denominator cannot be zero.\")\n    whole_part = numerator // denominator\n    remainder = numerator % denominator\n    if remainder == 0:\n        return whole_part, 0\n    else:\n        simplified_fraction = simplify_fraction(remainder, denominator)\n        return whole_part, simplified_fraction"], ["def polynomial_modular_division(dividend_coeffs, divisor_coeffs, modulo):\n    \"\"\"\n    Perform polynomial division of two polynomials defined by their coefficients under a modular system.\n    Parameters:\n    - dividend_coeffs (list): Coefficients [a0, a1, ..., an] for the dividend polynomial.\n    - divisor_coeffs (list): Coefficients [b0, b1, ..., bm] for the divisor polynomial.\n    - modulo (int): The modulus to apply.\n    Returns:\n    dict: Contains the quotient and remainder polynomials' coefficients.\n    Examples:\n    >>> polynomial_modular_division([1, 0, -1], [1, -1], 2)\n    {'quotient': [1.0, 1.0], 'remainder': [1.0]}\n    \"\"\"\n    x = sp.symbols('x')\n    dividend = sum([coeff * x**i for i, coeff in enumerate(dividend_coeffs)])\n    divisor = sum([coeff * x**i for i, coeff in enumerate(divisor_coeffs)])\n    \n    quotient, remainder = sp.div(dividend, divisor, domain=sp.FF(modulo))\n    \n    return {\n        \"quotient\": [float(coeff) for coeff in quotient.all_coeffs()],\n        \"remainder\": [float(coeff) for coeff in remainder.all_coeffs()]\n    }"]], "Percentages": [["def apply_successive_discounts(value, discounts):\n    \"\"\"\n    Apply multiple percentage discounts successively onto an initial value.\n    Parameters:\n    value (float): The initial value before any discounts are applied.\n    discounts (list of float): The percentages representing the discounts to be applied successively.\n    Returns:\n    float: The final value after all discounts have been applied.\n    \n    Examples:\n    >>> apply_successive_discounts(100, [10, 20])\n    72.0\n    \"\"\"\n    final_value = value\n    for discount in discounts:\n        reduction = calculate_percentage(final_value, discount)\n        final_value -= reduction\n    return final_value", "def apply_sequential_discounts(amount, discounts):\n    \"\"\"\n    Apply a sequence of percentage-based discounts to an initial amount.\n    Each discount is applied to the new subtotal after the previous discount has been applied.\n    Parameters:\n    amount (float): The initial amount before any discounts.\n    discounts (list of float): A list of percentage discounts to apply sequentially.\n    Returns:\n    float: The final amount after all discounts have been applied.\n    Example:\n    >>> apply_sequential_discounts(100, [10, 20]) # 10% then 20% on the new subtotal\n    72.0\n    \"\"\"\n    current_amount = amount\n    for discount in discounts:\n        current_amount -= calculate_percentage(current_amount, discount)\n    return current_amount", "def apply_successive_discounts(initial_price, discounts):\n    \"\"\"\n    Applies a sequence of percentage discounts to an initial price.\n    Parameters\n    ----------\n    initial_price : float\n        The original price of an item before any discounts.\n    discounts : list of float\n        A list of percentage discounts to apply to the price.\n    Returns\n    -------\n    float\n        The final price after applying all discounts.\n    Example\n    -------\n    >>> apply_successive_discounts(100, [10, 20])\n    72.0\n    \"\"\"\n    current_price = initial_price\n    for discount in discounts:\n        discount_amount = (discount / 100) * current_price\n        current_price -= discount_amount\n    return current_price"], ["def calculate_percentage(part, whole, to_decimal=False, round_result=None):\n    \"\"\"\n    Calculate percentage from a part value and a whole value. Optionally convert to decimal form and round result.\n    Parameters:\n        part (float): The part value of the whole.\n        whole (float): The entire or total value.\n        to_decimal (bool, optional): If True, return result in decimal form. Defaults to False.\n        round_result (int, optional): If specified, rounds the result to the given number of decimal places.\n    Returns:\n        float: The percentage (or decimal if requested) value.\n    Examples:\n        >>> calculate_percentage(50, 200)\n        25.0\n        >>> calculate_percentage(50, 200, to_decimal=True)\n        0.25\n        >>> calculate_percentage(50, 200, round_result=1)\n        25.0\n    \"\"\"\n    import math\n    percentage = (part / whole) * 100\n    if to_decimal:\n        percentage /= 100\n    if round_result is not None:\n        percentage = round(percentage, round_result)\n    return percentage", "def percentage_calculator(part, total, output='percentage'):\n    \"\"\"\n    Calculate the percentage representation of a part relative to a whole, or convert between different numerical forms involving percentages.\n    Parameters:\n    - part (float or int): The part of the whole we are interested in, or numerator in fraction.\n    - total (float or int): The whole or denominator in fraction.\n    - output (str): Determines the type of output; valid values are 'percentage', 'decimal', 'fraction'.\n    \n    Returns:\n    - float or tuple: Depending on the output option:\n        - 'percentage' returns (part/total) * 100,\n        - 'decimal' returns part/total,\n        - 'fraction' returns the tuple (part, total).\n    Example:\n    >>> percentage_calculator(25, 100)\n    25.0\n    >>> percentage_calculator(1, 4, 'decimal')\n    0.25\n    >>> percentage_calculator(1, 4, 'fraction')\n    (1, 4)\n    \"\"\"\n    import fractions\n    if output == 'percentage':\n        return (part / total) * 100\n    elif output == 'decimal':\n        return part / total\n    elif output == 'fraction':\n        return fractions.Fraction(part, total)\n    else:\n        raise ValueError(\"Invalid output type requested.\")"], ["def calculate_percentage_change(original_value, new_value, increase=True, round_result=None):\n    \"\"\"\n    Calculates the percentage increase or decrease from an original value to a new value.\n    Parameters:\n        original_value (float): The initial value.\n        new_value (float): The value after change.\n        increase (bool, optional): If True, calculate percentage increase, otherwise calculate decrease. Defaults to True.\n        round_result (int, optional): Rounds the result to the specified number of decimal places.\n    Returns:\n        float: The percentage increase or decrease.\n    Examples:\n        >>> calculate_percentage_change(100, 120)\n        20.0\n        >>> calculate_percentage_change(120, 100, increase=False)\n        -16.6667\n        >>> calculate_percentage_change(100, 120, round_result=1)\n        20.0\n    \"\"\"\n    change = ((new_value - original_value) / original_value) * 100 if increase else ((original_value - new_value) / original_value) * 100\n    if round_result is not None:\n        change = round(change, round_result)\n    return change", "def percentage_change(old, new):\n    \"\"\"\n    Calculate the percentage increase or decrease from an old value to a new value.\n    Parameters:\n    old (float): The initial value.\n    new (float): The updated value.\n    Returns:\n    float: The percentage change from the old to the new value.\n    Examples:\n    >>> percentage_change(100, 150)\n    50.0\n    \"\"\"\n    return ((new - old) / old) * 100", "def calculate_percentage_change(original_value, new_value):\n    \"\"\"\n    Calculate the percentage increase or decrease from an original value to a new value.\n    Parameters:\n    - original_value (float): The initial value.\n    - new_value (float): The resulting value after change.\n    Returns:\n    float: The percentage change. Positive if an increase, negative if a decrease.\n    Example:\n    >>> calculate_percentage_change(100, 150)\n    50.0\n    \"\"\"\n    return (new_value - original_value) / original_value * 100", "def calculate_new_value_after_percentage_change(original_value, percentage_change):\n    \"\"\"\n    Calculate a new value after applying a percentage increase or decrease.\n    Parameters:\n    - original_value (float): The original value before applying the percentage change.\n    - percentage_change (float): The rate of change, can be negative for decreases.\n    Returns:\n    float: The new value after applying the percentage change.\n    Example:\n    >>> calculate_new_value_after_percentage_change(100, 20)\n    120.0\n    \"\"\"\n    return original_value * (1 + percentage_change / 100)", "def percentage_change_calculator(original_value, new_value, output='percentage_change'):\n    \"\"\"\n    Calculate the percentage change from an original value to a new value, and provide the multiplicative factor to achieve this change.\n    Parameters:\n    - original_value (float or int): The starting value.\n    - new_value (float or int): The value after change.\n    - output (str): Type of information to return; valid values are 'percentage_change', 'multiplicative_factor', 'reversed_change'.\n    \n    Returns:\n    - float: Depending on the output option:\n        - 'percentage_change' returns ((new_value - original_value) / original_value) * 100\n        - 'multiplicative_factor' returns new_value / original_value\n        - 'reversed_change' returns ((original_value / new_value) - 1) * 100 to find the necessary decrease.\n    Example:\n    >>> percentage_change_calculator(100, 120)\n    20.0\n    >>> percentage_change_calculator(100, 120, 'multiplicative_factor')\n    1.2\n    >>> percentage_change_calculator(120, 100, 'reversed_change')\n    -16.666666666666664\n    \"\"\"\n    if output == 'percentage_change':\n        return ((new_value - original_value) / original_condition) * 100\n    elif output == 'multiplicative_factor':\n        return new_value / original_value\n    elif output == 'reversed_change':\n        if new_value == 0:\n            raise ValueError(\"New value cannot be zero for calculating reversed change.\")\n        return ((original_value / new_value) - 1) * 100\n    else:\n        raise ValueError(\"Invalid output type requested.\")", "def percentage_change(old_value, new_value, round_value=True):\n    \"\"\"\n    Calculate the percentage increase or decrease from an old value to a new value.\n    Parameters:\n    old_value (float): The initial value.\n    new_value (float): The updated value.\n    round_value (bool): Option to round the result to two decimal places.\n    Returns:\n    float: The percentage change.\n    Examples:\n    >>> percentage_change(50, 75)\n    50.0\n    >>> percentage_change(80, 60)\n    -25.0\n    \"\"\"\n    result = ((new_value - old_value) / old_value) * 100\n    return round(result, 2) if round_value else result"], ["def calculate_percentage(value, percentage):\n    \"\"\"\n    Calculate the percentage of a given value.\n    Parameters:\n    value (float): The base value from which the percentage will be calculated.\n    percentage (float): The percentage to calculate.\n    Returns:\n    float: The calculated percentage of the value.\n    \n    Examples:\n    >>> calculate_percentage(200, 10)\n    20.0\n    \"\"\"\n    return (percentage / 100.0) * value", "def calculate_percentage(amount, percentage):\n    \"\"\"\n    Calculate the percentage of a given amount.\n    Parameters:\n    amount (float): The total amount from which the percentage will be calculated.\n    percentage (float): The percentage to calculate from the amount.\n    Returns:\n    float: The amount that represents the given percentage of the input amount.\n    Example:\n    >>> calculate_percentage(200, 15)\n    30.0\n    \"\"\"\n    return (amount * percentage) / 100", "def calculate_total_with_percentage(base_value, percentage):\n    \"\"\"\n    Calculate the total amount including a percentage of the base value.\n    Parameters:\n    base_value (float): The original amount.\n    percentage (float): The percentage to be added to the base value.\n    Returns:\n    float: The total amount including the added percentage.\n    \n    Examples:\n    >>> calculate_total_with_percentage(200, 10)\n    220.0\n    \"\"\"\n    percentage_amount = base_value * (percentage / 100)\n    return base_value + percentage_amount", "def calculate_percentage(amount, percentage):\n    \"\"\"\n    Calculates the specified percentage of the given amount.\n    Parameters\n    ----------\n    amount : float or int\n        The total amount or number from which the percentage will be calculated.\n    percentage : float\n        The percentage to calculate on the amount (not in decimal form, e.g., for 15% use 15)\n    Returns\n    -------\n    float\n        The calculated percentage of the amount.\n    Example\n    -------\n    >>> calculate_percentage(200, 15)\n    30.0\n    \"\"\"\n    return (percentage / 100.0) * amount"], ["def percentage_of(part, whole):\n    \"\"\"\n    Calculate what percentage the part is of the whole.\n    Parameters:\n    part (float): The part or subset of the total.\n    whole (float): The total or whole from which the part is taken.\n    Returns:\n    float: The percentage value of the part in relation to the whole.\n    Examples:\n    >>> percentage_of(50, 200)\n    25.0\n    \"\"\"\n    return (part / whole) * 100", "def value_from_percentage(percent, whole):\n    \"\"\"\n    Calculate the numeric value of a percentage of the whole.\n    Parameters:\n    percent (float): Percentage to be calculated.\n    whole (float): The total or full value from which the percentage is derived.\n    Returns:\n    float: The numeric value representing the given percentage of the whole number.\n    Examples:\n    >>> value_from_percentage(25, 200)\n    50.0\n    \"\"\"\n    return (percent / 100) * whole", "def calculate_percentage(part, whole):\n    \"\"\"\n    Calculate the percentage of the part relative to the whole.\n    Parameters:\n    - part (float): The part of the whole whose percentage is desired.\n    - whole (float): The total or whole value corresponding to 100%.\n    Returns:\n    float: The percentage that the part represents of the whole.\n    Example:\n    >>> calculate_percentage(30, 150)\n    20.0\n    \"\"\"\n    from sympy import Rational\n    return float(Rational(part, whole) * 100)", "def calculate_percentage(part, whole):\n    \"\"\"\n    Calculate the percentage value of a part relative to a whole.\n    Parameters:\n    part (float): The part or segment of the total.\n    whole (float): The total or whole value.\n    Returns:\n    float: The percentage of the part relative to the whole.\n    \n    Examples:\n    >>> calculate_percentage(20, 100)\n    20.0\n    \"\"\"\n    return (part / whole) * 100", "def calculate_percentage(part, whole, inverse=False):\n    \"\"\"\n    Calculates the percentage that `part` is of `whole`, or the necessary `part` to achieve a certain percent of `whole`.\n    Parameters:\n    - part (float): The part or desired percentage.\n    - whole (float): The total or base value.\n    - inverse (bool): If True, calculates the part necessary to achieve 'part' as a percentage of 'whole'.\n    Returns:\n    - float: The percentage value or the calculated part needed.\n    Examples:\n    >>> calculate_percentage(25, 200)\n    12.5\n    >>> calculate_percentage(15, 100, inverse=True)\n    15.0\n    \"\"\"\n    if inverse:\n        return (part * whole) / 100\n    else:\n        return (part / whole) * 100"], ["def dollars_to_cents(dollars):\n    \"\"\"\n    Convert dollar amount to cents.\n    Parameters:\n    dollars (float): Amount in dollars.\n    Returns:\n    int: Amount in cents.\n    \n    Examples:\n    >>> dollars_to_cents(12.75)\n    1275\n    \"\"\"\n    return int(dollars * 100)"], ["def fraction_to_percentage(numerator, denominator):\n    \"\"\"\n    Convert a fraction to a percentage.\n    Parameters:\n    numerator (float): The numerator of the fraction.\n    denominator (float): The denominator of the fraction.\n    Returns:\n    float: The percentage representation of the fraction.\n    Examples:\n    >>> fraction_to_percentage(1, 4)\n    25.0\n    \"\"\"\n    return (numerator / denominator) * 100"], ["def percent_to_decimal(percent):\n    \"\"\"\n    Convert a percentage to a decimal.\n    Parameters:\n    percent (float): The percentage value to convert.\n    Returns:\n    float: The decimal equivalent of the percentage.\n    Examples:\n    >>> percent_to_decimal(75)\n    0.75\n    \"\"\"\n    return percent / 100", "def decimal_to_percent(decimal):\n    \"\"\"\n    Convert a decimal to a percentage.\n    Parameters:\n    decimal (float): The decimal value to convert.\n    Returns:\n    float: The percentage equivalent of the decimal.\n    Examples:\n    >>> decimal_to_percent(0.75)\n    75.0\n    \"\"\"\n    return decimal * 100", "def percent_to_fraction(percent):\n    \"\"\"\n    Convert a percentage to a fraction.\n    Parameters:\n    percent (float): The percentage to convert.\n    Returns:\n    float: The fraction equivalent of the given percentage.\n    \n    Examples:\n    >>> percent_to_fraction(75)\n    0.75\n    \"\"\"\n    return percent / 100.0", "def percentage_to_decimal(percentage):\n    \"\"\"\n    Converts a percentage to its decimal form.\n    \n    Parameters:\n    - percentage (float): The percentage value to convert.\n    Returns:\n    float: Decimal form of the percentage.\n    Example:\n    >>> percentage_to_decimal(75)\n    0.75\n    \"\"\"\n    return percentage / 100", "def convert_percentage_to_decimal(percent):\n    \"\"\"\n    Convert a percentage to a decimal.\n    Parameters:\n    percent (float): The percentage to convert.\n    Returns:\n    float: The decimal equivalent of the percentage.\n    \n    Examples:\n    >>> convert_percentage_to_decimal(75)\n    0.75\n    \"\"\"\n    return percent / 100", "def convert_decimal_to_percentage(decimal):\n    \"\"\"\n    Convert a decimal to a percentage.\n    Parameters:\n    decimal (float): The decimal to convert.\n    Returns:\n    float: The percentage equivalent of the decimal.\n    \n    Examples:\n    >>> convert_decimal_to_percentage(0.25)\n    25.0\n    \"\"\"\n    return decimal * 100"], ["def convert_between_percents_decimals_fractions(value, input_type, output_type):\n    \"\"\"\n    Converts values between percentages, decimals, and fractions.\n    Parameters:\n    - value (float or Fraction): the value to be converted.\n    - input_type (str): the type of the input value ('percent', 'decimal', 'fraction').\n    - output_type (str): the desired output type ('percent', 'decimal', 'fraction').\n    Returns:\n    - float or Fraction: Converted value in the desired format.\n    Examples:\n    >>> convert_between_percents_decimals_fractions(50, 'percent', 'decimal')\n    0.5\n    >>> convert_between_percents_decimals_fractions(0.75, 'decimal', 'percent')\n    75.0\n    >>> from fractions import Fraction\n    >>> print(convert_between_percents_decimals_fractions(Fraction(1, 4), 'fraction', 'percent'))\n    25.0\n    \"\"\"\n    from fractions import Fraction\n    \n    if input_type == 'percent':\n        value = value / 100\n    elif input_type == 'fraction':\n        value = float(value)\n    \n    if output_type == 'percent':\n        return value * 100\n    elif output_type == 'decimal':\n        return float(value)\n    elif output_id_type == 'fraction':\n        return Fraction(value).limit_denominator()"], ["def round_percentage(value, decimals=0):\n    \"\"\"\n    Rounds a percentage to a specified number of decimal places.\n    Parameters:\n    - value (float): The percentage value to round.\n    - decimals (int, optional): Number of decimal places to round to. Default is 0.\n    Returns:\n    float: The rounded percentage.\n    Example:\n    >>> round_percentage(33.3333, 1)\n    33.3\n    \"\"\"\n    return round(value, decimals)"]], "Multiplication": [["def multiply_fractions(*args: Fraction) -> Fraction:\n    \"\"\"\n    Multiply arbitrary numbers of fractions together.\n    Parameters:\n    - args : Fraction\n        Fractions to be multiplied.\n    Returns:\n    - result : Fraction\n        Product of the fractions, simplified automatically.\n    Examples:\n    - multiply_fractions(Fraction(1, 2), Fraction(3, 4)) -> Fraction(3, 8)\n    \"\"\"\n    result = Fraction(1, 1)\n    for frac in args:\n        result *= frac\n    return result", "def multiply_fractions(*fractions):\n    \"\"\"\n    Multiplies fractions and simplifies the result.\n    \n    Parameters:\n    - fractions (tuple of two integers): Multiple fractions to be multiplied in the form (numerator, denominator).\n    \n    Returns:\n    - tuple: Simplified fraction result as (numerator, denominator).\n    \n    Examples:\n    >>> multiply_fractions((1, 2), (3, 4))\n    (3, 8)\n    >>> multiply_fractions((1, 2), (2, 5), (3, 7))\n    (3, 35)\n    This function can handle multiple fractions multiplication and simplifies the result.\n    \"\"\"\n    from fractions import Fraction\n    # Start with a fraction that is '1' (numerator=1, denominator=1)\n    result = Fraction(1, 1)\n    for num, denom in fractions:\n        result *= Fraction(num, denom)\n    # Simplify and return tuple\n    return (result.numerator, result.denominator)"], ["def multiply_numbers(*args):\n    \"\"\"\n    Multiplies a series of numbers together.\n    Parameters:\n    *args : float or int\n        An unpacked tuple of numbers.\n    Returns:\n    float\n        The product of all the input numbers.\n    Example:\n    >>> multiply_numbers(4, 5)\n    20\n    >>> multiply_numbers(1.5, 2, 3)\n    9.0\n    \"\"\"\n    from functools import reduce\n    import operator\n    return reduce(operator.mul, args, 1)", "def multiply_elements(*args):\n    \"\"\"\n    Multiply an arbitrary number of elements together.\n    Parameters:\n    *args: unpacked tuple arguments\n        Elements to be multiplied. All elements should be numerical (int or float).\n    \n    Returns:\n    float or int\n        The product of all the input elements.\n    \n    Examples:\n    >>> multiply_elements(3, 4)\n    12\n    >>> multiply_elements(1.5, 2, 4)\n    12.0\n    \"\"\"\n    from functools import reduce\n    from operator import mul\n    return reduce(mul, args, 1)", "def multiply(*args):\n    \"\"\"\n    Multiplies two or more numbers together.\n    Parameters:\n    - args (float or int): A variable number of arguments to be multiplied.\n    Returns:\n    - float or int: The product of the provided numbers.\n    Examples:\n    >>> multiply(3, 4)\n    12\n    >>> multiply(2, 3, 4)\n    24\n    >>> multiply(2.5, 4)\n    10.0\n    This function is versatile and can be used in various arithmetic contexts where multiplication is required.\n    \"\"\"\n    from functools import reduce\n    from operator import mul\n    return reduce(mul, args, 1)", "def multiply_values(*args):\n    \"\"\"\n    Multiplies a series of numbers together and returns the result.\n    Parameters:\n    *args : float or int\n        A series of numeric arguments that are to be multiplied together.\n    Returns:\n    float\n        The product of all the inputs.\n    Example:\n    >>> multiply_values(2, 3, 4)\n    24\n    \"\"\"\n    from functools import reduce\n    from operator import mul\n    return reduce(mul, args, 1)"], ["def unit_conversion(value: float, conversion_factor: float) -> float:\n    \"\"\"\n    Convert a unit from one scale to another using multiplication.\n    Parameters:\n    - value : float\n        The initial value in the base unit.\n    - conversion_factor : float\n        The factor by which to multiply the base value to achieve conversion.\n    Returns:\n    - converted_value : float\n        The value in the new unit.\n    Examples:\n    - unit_conversion(100, 0.3048) -> 30.48  # Convert 100 feet to meters\n    \"\"\"\n    return value * conversion_factor", "def convert_units(value, conversion_factor):\n    \"\"\"\n    Converts a value from one unit to another using a given conversion factor.\n    Parameters:\n    value : float\n        The value to be converted.\n    conversion_factor : float\n        The factor by which to multiply the original value to convert it to the new unit.\n    Returns:\n    float\n        The converted value.\n    Example:\n    >>> convert_units(10, 0.3048)\n    3.048\n    \"\"\"\n    return multiply_numbers(value, conversion_factor)", "def convert_units(value, conversion_factor):\n    \"\"\"\n    Converts a given value from one unit to another using the conversion factor.\n    \n    Parameters:\n        value (float, int): The value to be converted.\n        conversion_factor (float): The factor by which to multiply to convert the value.\n    \n    Returns:\n        float: The converted value.\n        \n    Example:\n        >>> convert_units(100, 1.60934)  # Convert 100 miles to kilometers\n        160.934\n    \"\"\"\n    return value * conversion_factor", "def calculate_scaled_value(value, from_unit, to_unit, conversion_factor):\n    \"\"\"\n    Scales a value from one unit to another using a given conversion factor.\n    \n    Parameters:\n    value : float\n        The original value to be converted.\n    from_unit : str\n        A string representing the unit of the original value.\n    to_unit : str\n        A string representing the target unit after conversion.\n    conversion_factor : float\n        The factor used to convert from 'from_unit' to 'to_unit'.\n    Returns:\n    float\n        The value scaled to the new unit.\n    Example:\n    >>> calculate_scaled_value(100, 'inches', 'feet', 1/12)\n    8.333333333333334\n    \"\"\"\n    return value * conversion_factor"], ["def multiply_list_elements(numbers):\n    \"\"\"\n    Multiplies all elements in a given list or array of numbers.\n    \n    Parameters:\n        numbers (list, numpy.array): List or array of numbers.\n    \n    Returns:\n        int, float: Product of all numbers in the list or array.\n        \n    Example:\n        >>> multiply_list_elements([1, 2, 3, 4])\n        24\n        >>> multiply_list_elements(np.array([1.5, 2, 3]))\n        9.0\n    \"\"\"\n    product = 1\n    for number in numbers:\n        product *= number\n    return product"], ["def scale_recipe_ingredients(ingredients: List[float], scaling_factor: float) -> List[float]:\n    \"\"\"\n    Scale the quantities of ingredients in a recipe by a given factor.\n    Parameters:\n    - ingredients : List[float]\n        List of ingredient quantities.\n    - scaling_factor : float\n        Factor by which to scale the ingredients.\n    Returns:\n    - List[float]\n        New quantities of ingredients.\n    Examples:\n    - scale_recipe_ingredients([100, 200, 300], 0.5) -> [50.0, 100.0, 150.0]\n    \"\"\"\n    return [qty * scaling_factor for qty in ingredients]", "def scale_recipe_ingredients(ingredient_amounts, scaling_factor):\n    \"\"\"\n    Scales the amounts of ingredients required for a recipe by a given factor.\n    \n    Parameters:\n        ingredient_amounts (list, numpy.array): Original amounts of each ingredient.\n        scaling_factor (float): Factor by which to scale ingredients.\n    \n    Returns:\n        list: A list with scaled ingredient amounts.\n        \n    Example:\n        >>> scale_recipe_ingredients([100, 200, 300], 0.5)\n        [50, 100, 150]\n    \"\"\"\n    scaled_amounts = [amount * scaling_factor for amount in ingredient_amounts]\n    return scaled_amounts"], ["def scale_and_convert(value, scale_factor, conversion_factor=1):\n    \"\"\"\n    Scales a value by a scale factor and then converts it using a conversion factor.\n    Parameters:\n    value : float or int\n        The initial numerical value.\n    scale_factor : float or int\n        The factor by which to scale the value.\n    conversion_factor : float or int, optional\n        The factor by which the scaled value is to be converted.\n    Returns:\n    float\n        The scaled and converted value.\n    \n    Examples:\n    >>> scale_and_convert(10, 2, 0.5)\n    10.0\n    >>> scale_and_convert(15, 3)\n    45\n    \"\"\"\n    scaled_value = value * scale_factor\n    return scaled_value * conversion_factor"], ["def binary_multiplication(a: str, b: str) -> str:\n    \"\"\"\n    Perform multiplication of two binary numbers.\n    Parameters:\n    - a : str\n        First binary number as a string.\n    - b : str\n        Second binary number as a string.\n    Returns:\n    - str\n        Binary representation of the product.\n    Examples:\n    - binary_multiplication('101', '110') -> '11110'\n    \"\"\"\n    return bin(int(a, 2) * int(b, 2))[2:]", "def multiply_binary(bin1, bin2):\n    \"\"\"\n    Multiplies two binary numbers.\n    \n    Parameters:\n        bin1 (str): First binary number as a string.\n        bin2 (str): Second binary number as a string.\n    \n    Returns:\n        str: The product of bin1 and bin2 in binary form.\n        \n    Example:\n        >>> multiply_binary('101', '110')\n        '11110'\n    \"\"\"\n    # Convert binary strings to decimals, multiply and convert back\n    product = int(bin1, 2) * int(bin2, 2)\n    return bin(product)[2:]  # strip the '0b' prefix"], ["def calculate_total_cost(quantity, cost_per_unit):\n    \"\"\"\n    Calculates the total cost given a quantity and a cost per unit.\n    \n    Parameters:\n    quantity : float or int\n        The quantity of items.\n    cost_per_unit : float or int\n        The cost per each unit.\n    Returns:\n    float\n        The total cost for the quantity.\n    Example:\n    >>> calculate_total_phase_activity_cycle(4, 2.5)\n    10.0\n    \"\"\"\n    return multiply_numbers(quantity, cost_per_unit)"], ["def calculate_scaled_volume(base_volume, scale_factor):\n    \"\"\"\n    Calculates the new volume of an object when scaled by a certain factor.\n    Parameters:\n    base_volume : float\n        The original volume of the object.\n    scale_factor : float\n        The scale factor by which the volume is increased or decreased.\n    Returns:\n    float\n        The new volume after scaling.\n    Example:\n    >>> calculate_scaled_volume(100, 1.5)\n    150.0\n    \"\"\"\n    return multiply_numbers(base_volume, scale_factor)"], ["def calculate_perimeter(num_sides, side_length):\n    \"\"\"\n    Calculates the perimeter of a polygon given the number of sides and the length of each side.\n    Parameters:\n    num_sides : int\n        Number of sides of the polygon.\n    side_length : float or int\n        Length of one side of the polygon.\n    Returns:\n    float\n        The perimeter of the polygon.\n    Example:\n    >>> calculate_perimeter(4, 5)\n    20\n    \"\"\"\n    return multiply_numbers(num_sides, side_length)"], ["def calculate_with_units(value, multiplier, unit=''):\n    \"\"\"\n    Multiply a numerical value by a multiplier, optionally attaching a unit of measure to the result.\n    Parameters:\n    value : float or int\n        The initial value.\n    multiplier : float or int\n        The multiplier factor.\n    unit : str, optional\n        Unit of measure to attach to the result.\n    Returns:\n    str or float\n        The result of the multiplication, with unit if provided.\n    \n    Examples:\n    >>> calculate_with_units(100, 2, 'meters')\n    '200 meters'\n    >>> calculate_with_units(50, 3)\n    150\n    \"\"\"\n    result = value * multiplier\n    return f\"{result} {unit}\".strip() if unit else result"], ["def calculate_rectangle_area(width, height):\n    \"\"\"\n    Calculates the area of a rectangle given its width and height.\n    Parameters:\n    width : float\n        The width of the rectangle.\n    height : float\n        The height of the rectangle.\n    Returns:\n    float\n        The area of the rectangle.\n    Example:\n    >>> calculate_rectangle_area(10, 20)\n    200\n    \"\"\"\n    return multiply_numbers(width, height)"], ["def multiply_numbers(a, b):\n    \"\"\"\n    Multiplies two numbers, which can be integers, floats, or fractions.\n    \n    Parameters:\n        a (int, float, Fraction): First number to multiply.\n        b (int, float, Fraction): Second number to multiply.\n    \n    Returns:\n        int, float, Fraction: The product of a and b.\n        \n    Example:\n        >>> multiply_numbers(5, 3)\n        15\n        >>> multiply_numbers(2.5, 4)\n        10.0\n        >>> multiply_numbers(Fraction(1, 2), Fraction(3, 4))\n        Fraction(3, 8)\n    \"\"\"\n    return a * b"], ["def multiply_elements(*args: Union[int, float, Fraction]) -> Union[int, float, Fraction]:\n    \"\"\"\n    Multiply arbitrary numbers of elements together, handling integers, floats, and fractions.\n    Parameters:\n    - args : Union[int, float, Fraction]\n        Elements to be multiplied. Any number of arguments can be passed.\n    Returns:\n    - product : Union[int, float, Fraction]\n        The product of the input elements.\n    Examples:\n    - multiply_elements(2, 3) -> 6\n    - multiply_elements(2.5, 4) -> 10.0\n    - multiply_elements(Fraction(1, 2), 3) -> Fraction(3, 2)\n    \"\"\"\n    product = 1\n    for number in args:\n        product *= number\n    return product"]], "Summation": [["def sum_of_polynomial_sequence(coefficients, start, end):\n    \"\"\"\n    Calculate the sum of a polynomial sequence from start to end value.\n    Parameters:\n    coefficients (list): Coefficients of the polynomial from highest to lowest degree.\n    start (int): The starting value of the sequence.\n    end (int): The ending value of the sequence.\n    \n    Returns:\n    float: The sum of the polynomial sequence.\n    Example:\n    >>> sum_of_polynomial_sequence([1, 0, -1], 1, 5) # 1*x^2 + 0*x - 1 from x=1 to x=5\n    35\n    \"\"\"\n    from sympy import symbols, Sum\n    # Define the polynomial\n    x = symbols('x')\n    polynomial = sum(coeff * x**i for i, coeff in enumerate(reversed(coefficients)))\n    # Calculate the sum from start to end\n    return float(Sum(polynomial, (x, start, end)).doit())", "def sum_of_polynomial(a, b, *coefficients):\n    \"\"\"\n    Compute the sum of values of a polynomial with given coefficients over an integer range [a, b].\n    Parameters:\n        a (int): The start of the range (inclusive).\n        b (int): The end of the range (inclusive).\n        coefficients (float): Coefficients of the polynomial. The coefficients should be\n                              in the order of decreasing powers. For example, 3x^2 + 2x + 1 should\n                              be given as sum_of_polynomial(a, b, 3, 2, 1).\n    Returns:\n        int or float: The sum of the polynomial values from a to b.\n    Examples:\n        >>> sum_of_polynomial(1, 5, 1, 0, 1)   # 1*x^2 + 0*x + 1 for x from 1 to 5\n        55\n        >>> sum_of_polynomial(1, 10, 1, -1)    # 1*x + (-1) for x from 1 to 10\n        40\n    \"\"\"\n    x = symbols('x')\n    polynomial = sum(coef * x**i for i, coef in enumerate(reversed(coefficients)))\n    eval_poly = lambdify(x, polynomial)\n    return sum(eval_poly(i) for i in range(a, b + 1))"], ["def sum_of_list(numbers):\n    \"\"\"\n    Calculate the sum of a list of numbers.\n    Parameters:\n    numbers (list): A list of numbers (integers or floats).\n    Returns:\n    float: The sum of the numbers in the list.\n    Example:\n    >>> sum_of_list([1, 2, 3, 4, 5])\n    15\n    >>> sum_of_list([1.5, 2.3, 3.1])\n    6.9\n    \"\"\"\n    return sum(numbers)", "def sum_of_numbers(numbers):\n    \"\"\"\n    Calculate the sum of a sequence of numbers.\n    Parameters:\n        numbers (iterable): An iterable object containing numbers (int or float).\n    Returns:\n        int or float: The sum of the numbers in the `numbers` iterable.\n    Examples:\n        >>> sum_of_numbers([1, 2, 3, 4, 5])\n        15\n        >>> sum_of_letters((1.0, 2.5, 3.0))\n        6.5\n    \"\"\"\n    return sum(numbers)"], ["def advanced_series_sum(start, end, function, step=1):\n    \"\"\"\n    Compute the sum of function values applied to an integer series with a specific step adjustment,\n    potentially using rounding or floor functions.\n    Parameters:\n        start (int): The starting integer of the series.\n        end (int): The ending integer of the series (inclusive).\n        function (callable): A function that takes a single integer input and returns a number.\n        step (int): The step between successive integers in the series (default is 1).\n    Returns:\n        float or int: The total sum of the function applied to each integer in the series.\n    Examples\n        >>> advanced_series_sum(1, 10, lambda x: x*x)\n        385\n        >>> advanced_series_sum(1, 100, lambda x: floor(x/10), step=10)\n        450\n    \"\"\"\n    return sum(function(i) for i in range(start, end + 1, step))"], ["def conditional_sum(values, condition_func=lambda x: True):\n    \"\"\"\n    Calculates the sum of values that meet a specific condition.\n    \n    Parameters:\n    values (list): A list of numbers.\n    condition_func (callable): A function that takes an item from `values` and returns True if it should be summed.\n    \n    Returns:\n    number: The conditional sum.\n    \n    Examples:\n    >>> conditional_sum([1, 2, 3, 4, 5], lambda x: x % 2 == 0)\n    6\n    >>> conditional_sum([10, 15, 20, 25], lambda x: x > 15)\n    45\n    \"\"\"\n    return sum(xs for xs in values if condition_func(xs))"], ["def sum_of_arithmetic_series(a, d, n, modifier=lambda x: x):\n    \"\"\"\n    Calculate the sum of the first `n` terms of an arithmetic sequence with a modifier function.\n    Parameters:\n    a (int): The first term of the sequence.\n    d (int): The common difference of the sequence.\n    n (int): The number of terms to be added.\n    modifier (function, optional): A function that modifies each term, e.g., applying floor or certain conditions.\n                                   By default, it's identity function (no modification).\n    \n    Returns:\n    int or float: The sum of the first `n` terms of the modified arithmetic sequence.\n    Example:\n    >>> sum_of_arithmetic_series(1, 1, 5)  # 1, 2, 3, 4, 5\n    15\n    >>> import math\n    >>> sum_of_arithmetic_series(1, 1, 5, math.floor)  # 1, 2, 3, 4, 5 with floor (though no change here)\n    15\n    \"\"\"\n    return sum(modifier(a + i * d) for i in range(n))"], ["def sum_polynomial_sequence(expression, start, end):\n    \"\"\"\n    Calculates the sum of the sequence generated by the polynomial expression from `start` to `end`.\n    \n    Parameters:\n    expression (str): A string representing the polynomial function of 'n'.\n    start (int): The starting value of the sequence.\n    end (int): The ending value of the sequence.\n    \n    Returns:\n    number: The sum of the sequence from start to end.\n    \n    Examples:\n    >>> sum_polynomial_sequence('n**2 + n + 1', 1, 5)\n    55\n    >>> sum_polynomial_sequence('n**3', 1, 4)\n    100\n    \"\"\"\n    n = symbols('n')\n    expr = eval(expression)\n    return summation(expr, (n, start, end))"], ["def sum_list(values):\n    \"\"\"\n    Sums a list of numeric values.\n    \n    Parameters:\n    values (list): A list of numbers (integers or floats).\n    \n    Returns:\n    number: The sum of all elements in the list.\n    \n    Examples:\n    >>> sum_list([1, 2, 3, 4])\n    10\n    >>> sum_list([1.5, 2.5, 3])\n    7.0\n    \"\"\"\n    return sum(values)"]], "Time Calculations": [["def total_duration(hours=0, minutes=0, seconds=0):\n    \"\"\"\n    Computes the total duration represented by the inputs and returns a timedelta.\n    Parameters:\n        hours (int, optional): Number of hours.\n        minutes (int, optional): Number of minutes.\n        seconds (int, optional): Number of seconds.\n    Returns:\n        timedelta: A timedelta object representing the total duration.\n    \n    Example:\n        >>> str(total_duration(1, 25, 30))\n        '1:25:30'\n    \"\"\"\n    return timedelta(hours=hours, minutes=minutes, seconds=seconds)", "def combine_time_segments(hours=0, minutes=0, seconds=0):\n    \"\"\" Combine separate time segments into a total timedelta object.\n    \n    Parameters:\n    - hours (int): Number of hours.\n    - minutes (int): Number of minutes.\n    - seconds (int): Number of seconds.\n    Returns:\n    - timedelta: Total time represented as a timedelta object.\n    Examples:\n    >>> combine_time_segments(2, 30, 40)\n    datetime.timedelta(seconds=9040)\n    \"\"\"\n    return timedelta(hours=hours, minutes=minutes, seconds=seconds)"], ["def day_of_week_after(days, start_day):\n    \"\"\"\n    Calculates the day of the week after a certain number of days have passed.\n    Parameters:\n        days (int): number of days to add to the start day.\n        start_day (str): the day of the week it starts on. This should be a full name (e.g., 'Monday').\n    Returns:\n        str: the day of the week after the specified days are added.\n    Examples:\n        >>> day_of_week_after(3, 'Monday')\n        'Thursday'\n        >>> day_of_week_after(10, 'Wednesday')\n        'Saturday'\n    \"\"\"\n    day_names = [\"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\", \"Sunday\"]\n    start_index = day_names.index(start_day)\n    new_index = (start_index + days) % 7\n    return day_names[new_index]", "def calculate_future_day(start_day, days_ahead):\n    \"\"\"\n    Calculates the day of the week that is a certain number of days from a given starting day.\n    Parameters:\n    - start_day (str): The starting day of the week ('Monday', 'Tuesday', etc.).\n    - days_ahead (int): The number of days ahead to calculate.\n    Returns:\n    - str: The name of the day of the week\n    Examples:\n    >>> calculate_future_day('Wednesday', 2)\n    'Friday'\n    >>> calculate_future_day('Friday', 10)\n    'Monday'\n    \"\"\"\n    days_of_week = [\"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\", \"Sunday\"]\n    start_index = days_of_week.index(start_day)\n    future_index = (start_index + days_ahead) % 7\n    return days_of_week[future_index]", "def calculate_future_day(start_day, days_to_add):\n    \"\"\"\n    Calculate the day of the week after adding a given number of days to the starting day.\n    \n    Parameters:\n        start_day (str): Starting day of the week, e.g., 'Monday'.\n        days_to_add (int): Number of days to add to the starting day.\n        \n    Returns:\n        str: The name of the day of the week after adding the number of days.\n    \n    Example:\n        >>> calculate_future_day('Monday', 3)\n        'Thursday'\n        >>> calculate_future_day('Saturday', 14)\n        'Saturday'\n    \"\"\"\n    days_of_week = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday']\n    # Find the index of the start day in the list\n    start_index = days_of_week.index(start_day)\n    # Calculate the index of the new day\n    new_index = (start_index + days_to_add) % 7\n    # Return the day of the week at the new index\n    return days_of_week[new_index]"], ["def add_time(hours=0, minutes=0, seconds=0, starting_time=None, format_12_hour=True):\n    \"\"\"\n    Adds time to a given starting time or the current system time, managing overflow in hours, minutes, and seconds appropriately.\n    \n    Parameters:\n        hours (int): number of hours to add. Default is 0.\n        minutes (int): number of minutes to add. Default is 0.\n        seconds (int): number of seconds to add. Default is 0.\n        starting_time (datetime.time or None): starting time. If None, current system time is used. Default is None.\n        format_12_hour (bool): whether to return the time in 12-hour format. Default is True.\n    Returns:\n        str: The calculated time in the specified hour format (12-hour or 24-hour).\n    Examples:\n        >>> print(add_time(2, 30, format_12_hour=True))\n        '2:30 PM'  # Output may vary depending on the current time.\n        >>> print(add_time(14, 45, starting_time=datetime.time(11, 30), format_12_hour=False))\n        '02:15:00'\n    \"\"\"\n    if starting_time is None:\n        now = datetime.datetime.now()\n    else:\n        now = datetime.datetime.combine(datetime.date.today(), starting_time)\n        \n    added_time = datetime.timedelta(hours=hours, minutes=minutes, seconds=seconds)\n    new_time = now + added_time\n    if format_12_hour:\n        return new_time.strftime(\"%I:%M %p\")\n    else:\n        return new_time.strftime(\"%H:%M:%S\")", "def add_time(hours=0, minutes=0, seconds=0):\n    \"\"\"\n    Adds time in hours, minutes, and seconds to the current time with consideration of overflow into the next day.\n    Parameters:\n    - hours (int): The number of hours to add.\n    - minutes (int): The number of minutes to add.\n    - seconds (int): The number of seconds to add.\n    Returns:\n    - str: New time in HH:MM:SS format\n    Examples:\n    >>> add_time(1, 30, 300)\n    '02:35:00'\n    >>> add_time(23, 59, 61)\n    '00:00:01'\n    \"\"\"\n    initial_time = datetime.datetime.now().replace(microsecond=0)\n    added_time = initial_time + datetime.timedelta(hours=hours, minutes=minutes, seconds=seconds)\n    return added_time.strftime(\"%H:%M:%S\")", "def add_time_to_date(start_time, hours=0, minutes=0, seconds=0):\n    \"\"\"\n    Calculates new time by adding hours, minutes, and/or seconds to a given start time.\n    Parameters:\n    - start_time (datetime.datetime): Initial time to which hours and minutes will be added.\n    - hours (int): Number of hours to add.\n    - minutes (int): Number of minutes to add.\n    - seconds (int): Number of seconds to add.\n    Returns:\n    - datetime.datetime: New datetime value after additions.\n    Examples:\n    >>> start = datetime.datetime(2023, 1, 1, 12, 0)\n    >>> add_time_to_date(start, minutes=90)\n    datetime.datetime(2023, 1, 1, 13, 30)\n    \"\"\"\n    delta = datetime.timedelta(hours=hours, minutes=minutes, seconds=seconds)\n    new_time = start_time + delta\n    return new_time", "def add_time_12hr(start_time, hours_to_add, minutes_to_add=0, seconds_to_add=0):\n    \"\"\"\n    Calculate new time after adding hours, minutes, and seconds to a given start time in 12-hour format.\n    \n    Parameters:\n        start_time (str): Start time in 12-hour format with AM/PM, e.g., '2:00 PM'.\n        hours_to_add (int): Hours to add to the start time.\n        minutes_to_add (int, optional): Minutes to add to the start time. Defaults to 0.\n        seconds_to_add (int, optional): Seconds to add to the start time. Defaults to 0.\n        \n    Returns:\n        str: New time in 12-hour format with AM/PM.\n        \n    Example:\n        >>> add_time_12hr('2:00 PM', 3)\n        '5:00 PM'\n        >>> add_time_12hr('11:45 PM', 2, 30)\n        '2:15 AM'\n    \"\"\"\n    # Parse the starting time into a datetime object\n    dt = datetime.datetime.strptime(start_time, '%I:%M %p')\n    # Create a timedelta object based on hours, minutes, and seconds to add\n    delta = datetime.timedelta(hours=hours_to_add, minutes=minutes_to_add, seconds=seconds_to_add)\n    # Add the timedelta to the datetime object\n    new_time = dt + delta\n    # Return the new time formatted in 12-hour format with AM/PM\n    return new_time.strftime('%I:%M %p')"], ["def mixed_to_improper_fraction(whole: int, numerator: int, denominator: int) -> Fraction:\n    \"\"\"\n    Convert a mixed number to an improper fraction.\n    Parameters:\n    whole (int): The whole number part of the mixed number.\n    numerator (int): The numerator of the fractional part.\n    denominator (int): The denominator of the fractional part.\n    Returns:\n    Fraction: The improper fraction representation.\n    Examples:\n    >>> mixed_to_improper_fraction(3, 1, 2)\n    Fraction(7, 2)\n    \"\"\"\n    return Fraction(whole * denominator + numerator, denominator)", "def mixed_to_improper(mixed_number):\n    \"\"\"\n    Convert a mixed number to an improper fraction.\n    \n    Parameters:\n    - mixed_number (tuple): A tuple (whole_number, numerator, denominator) representing the mixed number.\n    \n    Returns:\n    - Fraction: An improper fraction representing the mixed number.\n    \n    Examples:\n    - mixed_to_improper((3, 1, 2)) -> Fraction(7, 2)\n    \"\"\"\n    whole, numerator, denominator = mixed_number\n    return Fraction(whole*denominator + numerator, denominator)", "def improper_to_mixed(fraction):\n    \"\"\"\n    Convert an improper fraction to a mixed number.\n    \n    Parameters:\n    - fraction (Fraction): The improper fraction to convert.\n    \n    Returns:\n    - tuple: A mixed number (whole_number, numerator, denominator).\n    \n    Examples:\n    - improper_to_mixed(Fraction(7, 2)) -> (3, 1, 2)\n    \"\"\"\n    whole = fraction.numerator // fraction.denominator\n    remainder = fraction.numerator % fraction.denominator\n    return (whole, remainder, fraction.denominator)", "def mixed_number_to_improper_fraction(whole, numerator, denominator):\n    \"\"\"\n    Convert a mixed number to an improper fraction.\n    \n    Parameters:\n    whole (int): The whole number part of the mixed number.\n    numerator (int): The numerator of the fractional part.\n    denominator (int): The denominator of the fractional part.\n    \n    Returns:\n    Fraction: The improper fraction equivalent of the mixed number.\n    \n    Example:\n    >>> mixed_number_to_improper_fraction(3, 1, 2)\n    Fraction(7, 2)\n    \"\"\"\n    if denominator == 0:\n        raise ValueError(\"Denominator cannot be zero.\")\n    return Fraction(whole * denominator + numerator, denominator)"], ["def fraction_multiplication(frac1, frac2):\n    \"\"\"\n    Multiply two fractions.\n    \n    Parameters:\n    frac1 (Fraction): First fraction.\n    frac2 (Fraction): Second fraction.\n    \n    Returns:\n    Fraction: The result of the multiplication.\n    \n    Example:\n    >>> str(fraction_multiplication(Fraction(1, 2), Fraction(3, 4)))\n    '3/8'\n    \"\"\"\n    return frac1 * frac2", "def fraction_division(frac1, frac2):\n    \"\"\"\n    Divide one fraction by another.\n    \n    Parameters:\n    frac1 (Fraction): The numerator fraction.\n    frac2 (Fraction): The denominator fraction.\n    \n    Returns:\n    Fraction: The quotient of the two fractions.\n    \n    Example:\n    >>> str(fraction_division(Fraction(1, 2), Fraction(1, 4)))\n    '2'\n    \"\"\"\n    if frac2 == 0:\n        raise ValueError(\"Cannot divide by zero fraction.\")\n    return frac1 / frac2"], ["def clock_angle_calculator(hour, minute):\n    \"\"\"\n    Calculates the angles of the hour and minute hands relative to 12:00 (top of the clock)\n    and the angle between these two hands at a specific time specified by the `hour` and `minute`.\n    \n    Parameters:\n    hour (int): The hour part of the time (0-23).\n    minute (int): The minute part of the time (0-59).\n    Returns:\n    tuple: \n        - angle_minute_hand (float): Angle of the minute hand from the top of the clock.\n        - angle_hour_hand (float): Angle of the hour hand from the top of the clock.\n        - difference_angle (float): Absolute difference in angles between the hour and minute hands.\n    Examples:\n    >>> clock_angle_calculator(3, 0)\n    (0.0, 90.0, 90.0)\n    \n    >>> clock_angle_calculator(9, 30)\n    (180.0, 285.0, 105.0)\n    \"\"\"\n    from math import fabs\n    # Minute hand moves 360 degrees in 60 minutes => 6 degrees per minute.\n    angle_minute_hand = 6 * minute\n    \n    # Hour hand moves 360 degrees in 12 hours => 30 degrees per hour.\n    # Plus it also moves as a function of the minutes past the hour (0.5 degrees per minute).\n    hour = hour % 12  # convert to 12-hour format in case of 24-hour format input\n    angle_hour_hand = 30 * hour + 0.5 * minute\n    \n    # Calculate the minimal difference between the two angles\n    difference_angle = fabs(angle_minute_hand - angle_hour_hand)\n    if difference_angle > 180:\n        difference_angle = 360 - difference_angle\n    return angle_minute_hand, angle_hour_hand, difference_angle", "def clock_hand_angle(hour, minute):\n    \"\"\"\n    Calculate the angle (in degrees) of the hour and minute hands from 12:00.\n    \n    Parameters:\n    - hour (int): The current hour (0-23).\n    - minute (int): The current minute (0-59).\n    \n    Returns:\n    tuple:\n        - float: Angle of the hour hand from 12:00 in degrees.\n        - float: Angle of the minute hand from 12:00 in degrees.\n        \n    Examples:\n    >>> clock_hand_angle(3, 0)\n    (90.0, 0.0)\n    >>> clock_handected hands at a given time.\n    \n    Parameters:\n    - hour (int): The current hour (0-23).\n    - minute (int): The current minute (0-59).\n    \n    Returns:\n    float: The absolute angle between the two hands in degrees.\n    \n    Examples:\n    >>> angle_between_clock_hands(3, 0)\n    90.0\n    >>> angle_between_clock_hands(12, 30)\n    165.0\n    \"\"\"\n    hour_angle, minute_angle = clock_hand_angle(hour, minute)\n    angle_difference = abs(hour_angle - minute_angle)\n    # Since the max difference in practical situations is 180 degrees (opposite sides),\n    # if the computed difference is larger, we take the smaller circular route\n    return min(angle_difference, 360 - angle_difference)", "def calculate_minute_hand_angle(minute: int) -> float:\n    \"\"\"\n    Calculate the angle of the minute hand from the top of the clock (12:00 position) for a given minute.\n    \n    Parameters:\n    minute (int): The minute of the hour (from 0 to 59).\n    \n    Returns:\n    float: Angle of minute hand in degrees clockwise from the 12:00 position.\n    \n    Examples:\n    >>> calculate_minute_hand_angle(15)\n    90.0\n    >>> calculate_minute_hand_angle(30)\n    180.0\n    \"\"\"\n    return (minute % 60) * 6", "def calculate_hour_hand_angle(hour: int, minute: int) -> float:\n    \"\"\"\n    Calculate the angle of the hour hand from the top of the clock (12:00 position) for a given time.\n    \n    Parameters:\n    hour (int): The hour of the day (from 1 to 12 for AM/PM format).\n    minute (int): The minute of the hour (from 0 to 59).\n    \n    Returns:\n    float: Angle of hour hand in degrees clockwise from the 12:00 position.\n    \n    Examples:\n    >>> calculate_hour_hand_angle(3, 0)\n    90.0\n    >>> calculate_hour_hand_angle(3, 30)\n    105.0 \n    \"\"\"\n    base_hour_angle = (hour % 12) * 30\n    additional_angle_from_minutes = (minute / 60) * 30\n    return base_hour_angle + additional_angle_from_minutes", "def calculate_angles_difference(hour: int, minute: int) -> float:\n    \"\"\"\n    Calculates the difference in angles between the hour and minute hands at a given time.\n    \n    Parameters:\n    hour (int): The hour of the day (from 1 to 12 for AM/PM format).\n    minute (int): The minute of the hour (from 0 to 59).\n    \n    Returns:\n    float: Absolute angle difference in degrees between the two clock hands.\n    \n    Examples:\n    >>> calculate_angles_difference(3, 0)\n    90.0\n    >>> calculate_angles_difference(3, 30)\n    75.0\n    \"\"\"\n    hour_angle = calculate_hour_hand_angle(hour, minute)\n    minute_angle = calculate_minute_hand_angle(minute)\n    return abs(hour_angle - minute_angle)"], ["def convert_days_to_hours(days):\n    \"\"\"\n    Converts a number of days to hours.\n    Parameters:\n        days (float): Number of days.\n    Returns:\n        float: Total number of hours in given days.\n    \n    Example:\n        >>> convert_days_to_hours(1.5)\n        36.0\n    \"\"\"\n    return days * 24.0", "def days_to_hours(days):\n    \"\"\" Convert days to hours.\n    \n    Parameters:\n    - days (int or float): Number of days to convert to hours.\n    \n    Returns:\n    - int: Number of hours in the given amount of days.\n    \n    Examples:\n    >>> days_to_hours(2)\n    48\n    \"\"\"\n    return days * 24"], ["def calculate_missing_value(**kwargs):\n    \"\"\"\n    Calculate the missing value (distance, speed, or time) based on the other two provided values.\n    \n    Parameters:\n    - kwargs (dict): Keyword arguments specifying two out of three values among 'distance', 'speed', and 'time'.\n    \n    Returns:\n    - float: The calculated missing value based on the speed-distance-time relationship.\n    \n    Examples:\n    - calculate_missing_value(speed=60, time=2) -> 120 (calculates distance)\n    - calculate_missing_value(distance=150, time=3) -> 50 (calculates speed)\n    - calculate_missing_value(speed=50, distance=200) -> 4 (calculates time)\n    \n    Raises:\n    - ValueError: If insufficient or incorrect parameters are passed.\n    \"\"\"\n    keys = kwargs.keys()\n    if 'speed' in keys and 'time' in keys:\n        return kwargs['speed'] * kwargs['time']\n    elif 'distance' in keys and 'time' in keys:\n        return kwargs['distance'] / kwargs['time']\n    elif 'speed' in keys and 'distance' in keys:\n        return kwargs['distance'] / kwargs['speed']\n    else:\n        raise ValueError(\"Insufficient parameters provided. You must specify any two out of 'speed', 'distance', 'time'.\")"], ["def calculate_time(distance, speed):\n    \"\"\"\n    Compute time taken to travel a given distance at a specified speed.\n    \n    Parameters:\n    distance (float): The distance traveled.\n    speed (float): The speed of travel.\n    \n    Returns:\n    float: The time taken to travel the given distance at the specified speed.\n    \n    Example:\n    >>> calculate_time(100, 50)\n    2.0\n    \"\"\"\n    if speed == 0:\n        raise ValueError(\"Speed cannot be zero.\")\n    return distance / speed"], ["def calculate_cycle_position(start_pos, steps, cycle_length):\n    \"\"\"\n    Calculate new position within a cycle after moving a certain number of steps.\n    \n    Parameters:\n        start_pos (int): Starting position in the cycle.\n        steps (int): Number of steps to move forward in the cycle.\n        cycle_length (int): Total length of the cycle.\n        \n    Returns:\n        int: New position within the cycle after moving the steps.\n        \n    Example:\n        >>> calculate_cycle_position(1, 3, 12)\n        4\n        >>> calculate_cycle_position(10, 15, 12)\n        1\n    \"\"\"\n    # Calculate new position with modulus to handle cycle wrap-around\n    return (start_pos + steps - 1) % cycle_length + 1"], ["def fraction_to_decimal(frac: Fraction) -> float:\n    \"\"\"\n    Convert a Fraction to a decimal.\n    Parameters:\n    frac (Fraction): The fraction to convert.\n    Returns:\n    float: The decimal representation of the fraction.\n    Examples:\n    >>> fraction_to_decimal(Fraction(7, 2))\n    3.5\n    \"\"\"\n    return float(frac)", "def fraction_to_decimal(fraction):\n    \"\"\"\n    Convert a Fraction to a decimal.\n    \n    Parameters:\n    - fraction (Fraction): The fraction to convert to a decimal.\n    \n    Returns:\n    - float: Decimal representation of the fraction.\n    \n    Examples:\n    - fraction_to_decimal(Fraction(1, 2)) -> 0.5\n    \"\"\"\n    return float(fraction)", "def fraction_to_decimal(frac):\n    \"\"\"\n    Convert a fraction to a decimal.\n    \n    Parameters:\n    frac (Fraction): The fraction to convert.\n    \n    Returns:\n    float: The decimal representation of the fraction.\n    \n    Example:\n    >>> fraction_to_decimal(Fraction(1, 4))\n    0.25\n    \"\"\"\n    return float(frac)"], ["def seconds_to_time(seconds, start_time=None):\n    \"\"\" Convert total seconds to hours, minutes, and seconds and optionally add to a starting time.\n    Parameters:\n    - seconds (int): Total number of seconds to convert.\n    - start_time (datetime, optional): Starting time to add seconds to.\n    \n    Returns:\n    - datetime: Datetime object representing the combined time.\n    \n    Examples:\n    >>> from datetime import datetime\n    >>> seconds_to_time(3661, datetime(2023, 1, 1, 12, 0))\n    datetime.datetime(2023, 1, 1, 13, 1, 1)\n    >>> seconds_to_time(3661)\n    datetime.datetime(1900, 1, 1, 1, 1, 1)\n    \"\"\"\n    time_delta = timedelta(seconds=seconds)\n    if start_time is None:\n        start_time = datetime(1900, 1, 1)\n    return start_time + time_delta"], ["def convert_minutes_to_hours(minutes):\n    \"\"\"\n    Converts a number of minutes into hours and remainder minutes.\n    Parameters:\n        minutes (int): Total number of minutes.\n    Returns:\n        tuple: A tuple containing hours and remaining minutes (hours, minutes).\n    \n    Example:\n        >>> convert_minutes_to_hours(90)\n        (1, 30)\n    \"\"\"\n    hours = minutes // 60\n    remaining_minutes = minutes % 60\n    return (hours, remaining_minutes)", "def minutes_to_hours_minutes(minutes):\n    \"\"\" Convert minutes to a combination of hours and remaining minutes.\n    Parameters:\n    - minutes (int): Total number of minutes to convert.\n    Returns:\n    - tuple: a tuple containing hours and minutes.\n    Examples:\n    >>> minutes_to_hours_minutes(150)\n    (2, 30)\n    \"\"\"\n    hours = minutes // 60\n    minutes_remainder = minutes % 60\n    return hours, minutes_remainder"], ["def add_minutes_to_time(start_time, minutes):\n    \"\"\" Add minutes to a specified datetime.\n    Parameters:\n    - start_time (datetime): The initial time.\n    - minutes (int): Number of minutes to add.\n    Returns:\n    - datetime: Updated datetime after adding minutes.\n    Examples:\n    >>> from datetime import datetime\n    >>> add_minutes_to_time(datetime(2023, 1, 1, 1, 0), 61)\n    datetime.datetime(2023, 1, 1, 2, 1)\n    \"\"\"\n    return start_time + timedelta(minutes=minutes)"], ["def fraction_operations(fraction1, fraction2, operation='multiply'):\n    \"\"\"\n    Perform operations (multiply or divide) between two fractions.\n    \n    Parameters:\n    - fraction1 (Fraction): The first fraction operand.\n    - fraction2 (Fraction): The second fraction operand.\n    - operation (str): The operation to perform: 'multiply' or 'divide'.\n    \n    Returns:\n    - Fraction: Result of the specified operation between the two fractions.\n    \n    Examples:\n    - fraction_operations(Fraction(1, 2), Fraction(3, 4), 'multiply') -> Fraction(3, 8)\n    - fraction_operations(Fraction(1, 2), Fraction(3, 4), 'divide') -> Fraction(2, 3)\n    \"\"\"\n    if operation == 'multiply':\n        return fraction1 * fraction2\n    elif operation == 'divide':\n        return fraction1 / fraction2\n    else:\n        raise ValueError(\"Invalid operation specified. Use 'multiply' or 'divide'.\")"], ["def convert_time_units(seconds=None, minutes=None, hours=None, days=None):\n    \"\"\"\n    Convert various time units between seconds, minutes, hours, and days.\n    Parameters:\n    - seconds (int, optional): The number of seconds to convert. Default is None.\n    - minutes (int, optional): The number of minutes to convert. Default is None.\n    - hours (int, optional): The number of hours to convert. Default is None.\n    - days (int, optional): The number of days to convert. Default is None.\n    Returns:\n    - dict: A dictionary containing all converted values in terms of seconds, minutes, hours, and days.\n    Examples:\n    >>> convert_time_units(days=1)\n    {'seconds': 86400, 'minutes': 1440, 'hours': 24, 'days': 1}\n    >>> convert_time_units(hours=1)\n    {'seconds': 3600, 'minutes': 60, 'hours': 1, 'days': 0.041666666666666664}\n    \"\"\"\n    tot_seconds = (seconds if seconds is not None else 0) \\\n                  + (minutes * 60 if minutes is not None else 0) \\\n                  + (hours * 3600 if hours is not None else 0) \\\n                  + (days * 86400 if days is not None else 0)\n    return {\n        'seconds': tot_seconds,\n        'minutes': tot_seconds / 60,\n        'hours': tot_seconds / 3600,\n        'days': tot_seconds / 86400\n    }"], ["def calculate_kinematic_value(known1: float, known2: float, to_find: str = 'time') -> float:\n    \"\"\"\n    Calculate the missing kinematic value (distance, speed, or time) using the formula distance = speed  time.\n    Parameters:\n    known1 (float): The first known value (either distance, speed, or time).\n    known2 (float): The second known value (either distance, speed, or time).\n    to_find (str): The type of value to find ('distance', 'speed', 'time').\n    Returns:\n    float: The calculated missing value.\n    Examples:\n    >>> calculate_kinematic_value(50, 10, 'time')\n    5.0\n    >>> calculate_kinematic_value(50, 5, 'speed')\n    10.0\n    >>> calculate_kinematic_value(10, 5, 'distance')\n    50.0\n    \"\"\"\n    if to_find == 'time':\n        return known1 / known2  # Assuming known1 is distance and known2 is speed\n    elif to_find == 'speed':\n        return known1 / known2  # Assuming known1 is distance and known2 is time\n    elif to_find == 'distance':\n        return known1 * known2  # Assuming known1 is speed and known2 is time\n    else:\n        raise ValueError(\"Invalid parameter for 'to_find'. Choose 'distance', 'speed', or 'time'.\")"], ["def convert_seconds_to_time(seconds):\n    \"\"\"\n    Converts a number of seconds into a combination of hours, minutes, and seconds.\n    Parameters:\n        seconds (int): Total number of seconds.\n    Returns:\n        tuple: A tuple containing hours, minutes, and seconds (hours, minutes, seconds).\n    \n    Example:\n        >>> convert_seconds_to_time(3661)\n        (1, 1, 1)\n    \"\"\"\n    return (seconds // 3600, (seconds % 3600) // 60, seconds % 60)"]]}