{
    "Quadratic Equations": [
        [
            "def vietas_formulas(a: float, b: float, c: float) -> Tuple[float, float]:\n    \"\"\"\n    Applies Vieta's formulas to find the sum and product of the roots of a quadratic equation ax^2 + bx + c = 0.\n    Parameters:\n    - a (float): Coefficient of x^2\n    - b (float): Coefficient of x\n    - c (float): Constant term\n    \n    Returns:\n    - Tuple[float, float]: The sum and product of the roots respectively.\n    \n    Examples:\n    >>> vietas_formulas(1, -3, 2)\n    (3.0, 2.0)\n    >>> vietas_formulas(1, 4, 4)\n    (-4.0, 4.0)\n    \"\"\"\n    sum_roots = -b / a\n    product_roopies = c / a\n    return (sum_roots, product_roots)",
            "def vietas_formulas_from_coefficients(a, b, c):\n    \"\"\"\n    Compute the sum and product of the roots of the quadratic equation ax^2 + bx + c = 0 using Vieta's formulas.\n    \n    Parameters:\n        a (float): Coefficient of x^2\n        b (float): Coefficient of x\n        c (float): Constant term\n    Returns:\n        tuple: Sum and product of the roots.\n    \n    Examples:\n        >>> vietas_formulas_from_coefficients(1, -3, 2)\n        (3.0, 2.0)\n        >>> vietas_formulas_from_coefficients(1, 4, 4)\n        (-4.0, 4.0)\n    \"\"\"\n    sum_of_roots = -b / a\n    product_of_roots = c / a\n    \n    return (sum_of_roots, product_of_roots)",
            "def roots_properties(a, b, c):\n    \"\"\"\n    Analyze the roots of the quadratic equation ax^2 + bx + c = 0.\n    Parameters\n    ----------\n    a : float\n        Coefficient of x^2\n    b : float\n        Coefficient of x\n    c : float\n        The constant term\n    Returns\n    -------\n    dict\n        A dictionary with properties of roots including:\n        - 'sum_of_roots': The sum of the roots using -b/a.\n        - 'product_of_roots': The product of the roots using c/a.\n        - 'roots': A tuple of the roots (real or complex).\n    Examples\n    --------\n    >>> roots_properties(1, -3, 2)\n    {'sum_of_roots': 3.0, 'product_of_roots': 2.0, 'roots': (2.0, 1.0)}\n    >>> roots_properties(1, 0, 1)\n    {'sum_of_roots': 0.0, 'product_of_roots': 1.0, 'roots': ((-1j), (1j))}\n    \"\"\"\n    root1, root2 = quadratic_solver(a, b, c)\n    sum_of_roots = -b / a\n    product_of_roots = c / a\n    return {\n        \"sum_of_roots\": sum_of_roots,\n        \"product_of_roots\": product_of_roots,\n        \"roots\": (root1, root2)\n    }",
            "def vietas_formulas(a, b, c):\n    \"\"\"\n    Computes the sum and product of the roots of the quadratic equation ax^2 + bx + c = 0 using Vieta's formulas.\n    \n    Parameters:\n        a (float): Coefficient of x^2.\n        b (float): Coefficient of x.\n        c (float): Constant term.\n    \n    Returns:\n        dict: A dictionary containing 'sum' and 'product' of the roots.\n    \n    Examples:\n        >>> vietas_formulas(1, -3, 2)\n        {'sum': 3.0, 'product': 2.0}\n        >>> vietas_formulas(1, 2, 1)\n        {'sum': -2.0, 'product': 1.0}\n    \"\"\"\n    sum_of_roots = -b / a\n    product_of_roots = c / a\n    return {'sum': sum_of_roots, 'product': product_of_roots}"
        ],
        [
            "def solve_by_factoring(a, b, c):\n    \"\"\"\n    Attempts to solve the quadratric equation ax^2 + bx + c = 0 by factorization method.\n    Parameters:\n    a (int): Coefficient of x^2\n    b (int): Coefficient of x\n    c (int): Constant term\n    Returns:\n    tuple or str: Roots if factorization is possible, otherwise returns 'Factorization not possible'.\n    Examples:\n    >>> solve_by_factoring(1, -3, 2)\n    (1, 2)\n    \"\"\"\n    x = sp.symbols('x')\n    expr = a*x**2 + b*x + c\n    factored = sp.factor(expr)\n    if isinstance(factored, sp.Mul):  # Check if the expression was factored\n        solutions = sp.solve(expr, x)\n        return tuple(float(sol.evalf()) for sol in solutions)\n    else:\n        return \"Factorization not possible\"",
            "def factorize_quadratic(a, b, c):\n    \"\"\"\n    Factorize the quadratic equation ax^2 + bx + c = 0 if possible.\n    Parameters:\n    a (float): Coefficient of x^2\n    b (float): Coefficient of x\n    c (float): Constant term\n    Returns:\n    tuple: Factored form of the quadratic equation (if factorable with real numbers)\n    Example:\n    >>> factorize_quadratic(1, -3, 2)\n    '(x-2)(x-1)'\n    \"\"\"\n    r1, r2 = solve_quadratic_equation(a, b, c)\n    if all(isinstance(r, complex) for r in [r1, r2]) and all(imag == 0 for imag in [r1.imag, r2.imag]):\n        return f\"(x-{r1.real})(x-{r2.real})\"\n    else:\n        return \"Quadratic cannot be factored with real coefficients\""
        ],
        [
            "def quadratic_solver(a, b, c):\n    \"\"\"\n    Solves the quadratic equation ax^2 + bx + c = 0 using the quadratic formula.\n    Parameters:\n    a (float): Coefficient of x^2\n    b (float): Coefficient of x\n    c (float): Constant term\n    Returns:\n    tuple: Returns a tuple containing the roots in a NumPy array.\n    Examples:\n    >>> quadratic_solver(1, -3, 2)\n    (1.0, 2.0)\n    >>> quadratic_solver(1, 0, 1)\n    ((-0j), (1j))\n    \"\"\"\n    discriminant = b**2 - 4*a*c\n    if discriminant > 0:\n        x1 = (-b + np.sqrt(discriminant)) / (2*a)\n        x2 = (-b - np.sqrt(discriminant)) / (2*a)\n        return (x1, x2)\n    elif discriminant == 0:\n        x = -b / (2*a)\n        return (x, x)\n    else:\n        real_part = -b / (2*a)\n        imaginary_part = np.sqrt(-discriminant) / (2*a)\n        return (complex(real_part, imaginary_part), complex(real_part, -imaginary_part))",
            "def calculate_discriminant(a, b, c):\n    \"\"\"\n    Calculates the discriminant of the quadratic equation ax^2 + bx + c = 0.\n    Parameters:\n    a (float): Coefficient of x^2\n    b (float): Coefficient of x\n    c (float): Constant term\n    Returns:\n    float: The discriminant value.\n    Examples:\n    >>> calculate_discriminant(1, -3, 2)\n    1\n    >>> calculate_discriminant(1, 0, 1)\n    -4\n    \"\"\"\n    return b**2 - 4*a*c",
            "def solve_quadratic(a, b, c):\n    \"\"\"\n    Solve a quadratic equation of the form ax^2 + bx + c = 0.\n    Parameters\n    ----------\n    a : float\n        Coefficient of the x^2 term.\n    b : float\n        Coefficient of the x term.\n    c : float\n        Constant term.\n    Returns\n    -------\n    tuple\n        A tuple (root1, root2) of the two roots, which may be real or complex.\n    Examples\n    --------\n    >>> solve_quadratic(1, -3, 2)\n    (2.0, 1.0)\n    >>> solve_quadratic(1, 0, 1)\n    ((1j, -1j))\n    \"\"\"\n    discriminant = cmath.sqrt(b**2 - 4*a*c)\n    root1 = (-b + discriminant) / (2*a)\n    root2 = (-b - discriminant) / (2*a)\n    \n    return (root1, root2)",
            "def solve_quadratic(a: float, b: float, c: float) -> Tuple[Union[float, complex], Union[float, complex]]:\n    \"\"\"\n    Solves a quadratic equation given by ax^2 + bx + c = 0.\n    Parameters:\n    - a (float): Coefficient of x^2\n    - b (float): Coefficient of x\n    - c (float): Constant term\n    Returns:\n    - Tuple[Union[float, complex], Union[float, complex]]: Roots of the equation, which can be real or complex.\n    \n    Examples:\n    >>> solve_quadratic(1, -3, 2)\n    (2.0, 1.0)\n    >>> solve_quadratic(1, 2, 5)\n    ((-1+2j), (-1-2j))\n    \"\"\"\n    discriminant = b**2 - 4*a*c\n    sqrt_disc = np.sqrt(discriminant) if discriminant >= 0 else np.sqrt(-discriminant) * 1j\n    root1 = (-b + sqrt_disc) / (2 * a)\n    root2 = (-b - sqrt_disc) / (2 * a)\n    return (root1, root2)",
            "def solve_quadratic_equation(a, b, c):\n    \"\"\"\n    Solve quadratic equation ax^2 + bx + c = 0 using the quadratic formula.\n    Parameters:\n    a (float): Coefficient of x^2\n    b (float): Coefficient of x\n    c (float): Constant term\n    Returns:\n    tuple:\n        root1 (complex): First root of the quadratic equation.\n        root2 (complex): Second root of the quadratic equation.\n    Example:\n    >>> solve_quadratic_equation(1, -3, 2)\n    ((2+0j), (1+0j))\n    \"\"\"\n    discriminant = cmath.sqrt(b**2 - 4*a*c)\n    root1 = (-b + discriminant) / (2*a)\n    root2 = (-b - discriminant) / (2*a)\n    return root1, root2",
            "def discriminant(a, b, c):\n    \"\"\"\n    Calculate the discriminant of the quadratic equation ax^2 + bx + c = 0.\n    Parameters:\n    a (float): Coefficient of x^2\n    b (float): Coefficient of x\n    c (float): Constant term\n    Returns:\n    float: The value of the discriminant.\n    Example:\n    >>> discriminant(1, -3, 2)\n    1\n    \"\"\"\n    return b**2 - 4*a*c",
            "def solve_quadratic(a, b, c):\n    \"\"\"\n    Solves the quadratic equation ax^2 + bx + c = 0 using the quadratic formula.\n    Parameters:\n    - a (float): Coefficient of x^2\n    - b (float): Coefficient of x\n    - c (float): Constant term\n    Returns:\n    - tuple: A tuple containing the roots of the quadratic equation, which can be real or complex.\n    Example:\n    >>> solve_quadratic(1, -3, 2)\n    (2.0, 1.0)\n    >>> solve_quadratic(1, 0, 1)\n    ((-1j), (1j))\n    \"\"\"\n    discriminant = b**2 - 4*a*c\n    root1 = (-b + np.sqrt(discriminant)) / (2*a)\n    root2 = (-b - np.sqrt(discriminant)) / (2*a)\n    return (root1, root2)",
            "def solve_quadratic_equation(a, b, c):\n    \"\"\"\n    Solve the quadratic equation ax^2 + bx + c = 0 using the quadratic formula.\n    Parameters:\n        a (float): Coefficient of x^2\n        b (float): Coefficient of x\n        c (float): Constant term\n    Returns:\n        tuple: Roots of the quadratic equation, which can be real or complex.\n    \n    Example:\n        >>> solve_quadratic_equation(1, -3, 2)\n        (2.0, 1.0)\n        >>> solve_quadratic_equation(1, 0, 1)\n        ((1j), (-1j))\n    \"\"\"\n    # Calculate the discriminant\n    discriminant = b**2 - 4 * a * c\n    \n    # Compute the two roots\n    root1 = (-b + np.sqrt(discriminant)) / (2 * a)\n    root2 = (-b - np.sqrt(discriminant)) / (2 * a)\n    \n    return (root1, root2)",
            "def quadratic_solver(a, b, c):\n    \"\"\"\n    Solves the quadratic equation ax^2 + bx + c = 0 using the quadratic formula.\n    \n    Parameters\n    ----------\n    a : float\n        Coefficient of x^2\n    b : float\n        Coefficient of x\n    c : float\n        Coefficient of the constant term\n    \n    Returns\n    -------\n    tuple\n        A tuple containing the roots of the quadratic equation. Roots can be real or complex numbers.\n    \n    Examples\n    --------\n    >>> quadratic_solver(1, -3, 2)\n    (2.0, 1.0)\n    \n    >>> quadratic_solver(1, 0, 1)\n    ((-1j), (1j))\n    \"\"\"\n    discriminant = b ** 2 - 4 * a * c\n    if discriminant < 0:\n        root1 = (-b + np.sqrt(discriminant)*1j) / (2 * a)\n        root2 = (-b - np.sqrt(discriminant)*1j) / (2 * a)\n    else:\n        root1 = (-b + np.sqrt(discriminant)) / (2 * a)\n        root2 = (-b - np.sqrt(discriminant)) / (2 * a)\n    return (root1, root2)",
            "def discriminant(a, b, c):\n    \"\"\"\n    Calculates the discriminant of a quadratic equation ax^2 + bx + c = 0.\n    \n    Parameters\n    ----------\n    a : float\n        Coefficient of x^2\n    b : float\n        Coefficient of x\n    c : float\n        Coefficient of the constant term\n    \n    Returns\n    -------\n    float\n        The discriminant of the quadratic equation.\n    \n    Examples\n    --------\n    >>> discriminant(1, -3, 2)\n    1\n    \n    >>> discriminant(1, 0, 1)\n    -4\n    \"\"\"\n    return b**2 - 4*a*c",
            "def quadratic_solver(a, b, c):\n    \"\"\"\n    Solves the quadratic equation ax^2 + bx + c = 0 using the quadratic formula.\n    \n    Parameters:\n    a (float): Coefficient of x^2.\n    b (float): Coefficient of x.\n    c (float): Constant term.\n    Returns:\n    tuple: A tuple containing:\n        - roots (tuple): Real or complex roots of the quadratic equation.\n        - discriminant (float): Discriminant value of the quadratic equation.\n        - root_type (str): Type of roots ('real and distinct', 'real and repeated', 'complex').\n    Examples:\n    >>> quadratic_solver(1, -3, 2)\n    ((2.0, 1.0), 1.0, 'real and distinct')\n    >>> quadratic_solver(1, -2, 1)\n    ((1.0,), 0.0, 'real and repeated')\n    >>> quadratic_solver(1, 0, 1)\n    ((1j, -1j), -4.0, 'complex')\n    \"\"\"\n    # Calculate the discriminant\n    discriminant = b**2 - 4*a*c\n    \n    if discriminant > 0:\n        root1 = (-b + sp.sqrt(discriminant)) / (2*a)\n        root2 = (-b - sp.sqrt(discriminant)) / (2*a)\n        roots = (sp.re(root1), sp.re(root2))\n        root_type = 'real and distinct'\n    elif discriminant == 0:\n        root = -b / (2*a)\n        roots = (root,)\n        root_type = 'real and repeated'\n    else:\n        root1 = (-b + sp.sqrt(discriminant)) / (2*a)\n        root2 = (-b - sp.sqrt(discriminant)) / (2*a)\n        roots = (root1, root2)\n        root_type = 'complex'\n    \n    return roots, discriminant, root_type",
            "def solve_quadratic_equation(a, b, c):\n    \"\"\"\n    Solves the quadratic equation ax^2 + bx + c = 0 using the quadratic formula.\n    \n    Parameters:\n        a (float): Coefficient of x^2.\n        b (float): Coefficient of x.\n        c (float): Constant term.\n    \n    Returns:\n        tuple: Returns the roots of the equation in the form of a tuple. Roots might be real or complex.\n    \n    Examples:\n        >>> solve_quadratic_equation(1, -3, 2)\n        (2.0, 1.0)\n        >>> solve_quadratic_equation(1, 2, 1)\n        (-1.0, -1.0)\n        >>> solve_quadratic_equation(1, 0, 1)\n        ((-0j), (1j))\n    \"\"\"\n    import cmath\n    discriminant = cmath.sqrt(b**2 - 4*a*c)\n    root1 = (-b + discriminant) / (2 * a)\n    root2 = (-b - discriminant) / (2 * a)\n    return (root1, root2)"
        ],
        [
            "def discriminant_analysis(discriminant):\n    \"\"\"\n    Provides an analysis of the discriminant to determine the nature of the roots of the quadratic equation.\n    Parameters:\n    discriminant (float): The discriminant value.\n    Returns:\n    str: Description of the nature of the roots based on the discriminant.\n    Examples:\n    >>> discriminant_analysis(1)\n    'Two distinct real roots'\n    >>> discriminant_analysis(0)\n    'One repeated real root'\n    >>> discriminant_analysis(-4)\n    'Two complex roots'\n    \"\"\"\n    if discriminant > 0:\n        return \"Two distinct real roots\"\n    elif discriminant == 0:\n        return \"One repeated real root\"\n    else:\n        return \"Two complex roots\""
        ],
        [
            "def analyze_quadratic(a, b, c):\n    \"\"\"\n    Analyze the properties of a quadratic equation ax^2 + bx + c.\n    Parameters\n    ----------\n    a : float\n        Coefficient of x^2.\n    b : float\n        Coefficient of x.\n    c : float\n        Constant term.\n    Returns\n    -------\n    dict\n        A dictionary containing the roots, vertex, axis of symmetry,\n        discriminant, and direction of the parabola.\n    Examples\n    --------\n    >>> analyze_quadratic(1, -6, 9)\n    {\n        'roots': (3.0, 3.0),\n        'vertex': (3.0, 0.0),\n        'axis_of_symmetry': 3.0,\n        'discriminant': 0.0,\n        'direction': 'upward'\n    }\n    \"\"\"\n    roots = solve_quadratic(a, b, c)\n    vertex_form = quadratic_to_vertex_form(a, b, c)\n    _, h, k = vertex_form\n    vertex = (h, k)\n    \n    discriminant = b**2 - 4*a*c\n    axis_of_symmetry = h\n    direction = 'upward' if a > 0 else 'downward'\n    return {\n        'roots': roots,\n        'vertex': vertex,\n        'axis_of_symmetry': axis_of_symmetry,\n        'discriminant': discriminant,\n        'direction': direction\n    }",
            "def analyze_quadratic(a, b, c):\n    \"\"\"\n    Analyzes the quadratic equation ax^2 + bx + c = 0 to find the vertex, axis of symmetry, and discriminant.\n    Parameters:\n    - a (float): Coefficient of x^2\n    - b (float): Coefficient of x\n    - c (float): Constant term\n    Returns:\n    - dict: Dictionary containing 'vertex' as (x, y), 'axis_of_symmetry' as x, and 'discriminant' as value\n    Example:\n    >>> analyze_quadratic(1, -3, 2)\n    {'vertex': (1.5, -0.25), 'axis_of_symmetry': 1.5, 'discriminant': 1}\n    >>> analyze_quadratic(1, 2, 1)\n    {'vertex': (-1, 0), 'axis_of_symmetry': -1, 'discriminant': 0}\n    \"\"\"\n    x_vertex = -b / (2*a)\n    y_vertex = a*x_vertex**2 + b*x_vertex + c\n    discriminant = b**2 - 4*a*c\n    return {\n        'vertex': (x_vertex, y_vertex),\n        'axis_of_symmetry': x_vertex,\n        'discriminant': discriminant\n    }",
            "def quadratic_properties(a, b, c):\n    \"\"\"\n    Calculates properties of the quadratic equation of the form ax^2 + bx + c = 0.\n    Converts it to the vertex form, identifies vertex, axis of symmetry and direction.\n    Parameters:\n    a (float): Coefficient of x^2.\n    b (float): Coefficient of x.\n    c (float): Constant term.\n    Returns:\n    dict: Dictionary containing:\n        - vertex_form (sp.Expr): The equation in vertex form y = a*(x-h)^2 + k.\n        - vertex (tuple): The (x, y) coordinates of the vertex.\n        - axis_of_symmetry (float): x-value of the axis of symmetry.\n        - direction (str): 'upwards' if the parabola opens up, 'downwards' if it opens down.\n    Examples:\n    >>> quadratic_properties(1, -3, 2)\n    {'vertex_form': x**2 - 3*x + 2, 'vertex': (1.5, -0.25), 'axis_of_symmetry': 1.5, 'direction': 'upwards'}\n    \"\"\"\n    x = sp.symbols('x')\n    # Convert to vertex form\n    f = a*x**2 + b*x + c\n    f_vertex = sp.simplify(a*(x + b/(2*a))**2 - (b**2 - 4*a*c)/(4*a))\n    \n    # Identify the vertex\n    h = -b / (2*a)\n    k = a*h**2 + b*h + c\n    vertex = (h, k)\n    \n    # Axis of symmetry is the x-coordinate of the vertex\n    axis_of_symmetry = h\n    \n    # Direction of the parabola\n    direction = 'upwards' if a > 0 else 'downwards'\n    \n    return {\n        'vertex_form': f_vertex,\n        'vertex': vertex,\n        'axis_of_symmetry': axis_of_symmetry,\n        'direction': direction\n    }"
        ],
        [
            "def form_quadratic_from_roots(root1, root2):\n    \"\"\"\n    Formulate a quadratic equation given two roots.\n    Parameters:\n    root1 (float or complex): First root\n    root2 (float or complex): Second root\n    Returns:\n    tuple: Coefficients of the quadratic equation (a, b, c) in the form ax^2 + bx + c = 0\n    Example:\n    >>> form_quadratic_from_roots(1, 2)\n    (1, -3, 2)\n    \"\"\"\n    a = 1\n    b = -(root1 + root2)\n    c = root1 * root2\n    return (a, b, c)"
        ],
        [
            "def quadratic_to_vertex_form(a, b, c):\n    \"\"\"\n    Convert a quadratic equation from standard form (ax^2 + bx + c)\n    to vertex form (a(x-h)^2 + k).\n    Parameters\n    ----------\n    a : float\n        Coefficient of x^2.\n    b : float\n        Coefficient of x.\n    c : float\n        Constant term.\n    Returns\n    -------\n    tuple\n        A tuple (a, h, k) representing the vertex form of the equation.\n    Examples\n    --------\n    >>> quadratic_to_vertex_form(1, -6, 8)\n    (1, 3, -1)\n    \"\"\"\n    h = -b / (2*a)\n    k = c - b**2 / (4*a)\n    return (a, h, k)",
            "def convert_quadratic_form(a, b, c, form='vertex'):\n    \"\"\"\n    Converts a quadratic equation from standard form (ax^2 + bx + c) to specified form.\n    \n    Parameters:\n    - a (float): Coefficient of x^2\n    - b (float): Coefficient of x\n    - c (float): Constant term\n    - form (str): Desired form of the quadratic, either 'vertex' or 'factored'\n    \n    Returns:\n    - str: Transformed quadratic equation in specified form\n    Example:\n    >>> convert_quadratic_form(1, -3, 2, 'vertex')\n    'y = 1*(x - 1.5)**2 + 0.75'\n    >>> convert_quadratic(1, -3, 2, 'factored')\n    'y = (x - 1)*(x - 2)'\n    \"\"\"\n    x = sp.symbols('x')\n    expr = a*x**2 + b*x + c\n    if form == 'vertex':\n        completed_square = sp.expand(expr).complete_square(x)\n        return f\"y = {completed_square}\"\n    elif form == 'factored':\n        factored_form = sp.factor(expr)\n        return f\"y = {factored_form}\"\n    else:\n        raise ValueError(\"Unsupported form specified. Choose 'vertex' or 'factored'.\")"
        ]
    ],
    "Linear Equations": [
        [
            "def parallel_slope(slope1, slope2):\n    \"\"\"\n    Determine if two lines with given slopes are parallel.\n    Parameters:\n    slope1, slope2 (float): Slopes of the two lines.\n    Returns:\n    bool: True if the lines are parallel, otherwise False.\n    Examples:\n    >>> parallel_slope(2, 2)\n    True\n    \"\"\"\n    return slope1 == slope2",
            "def perpendicular_slope(slope1, slope2):\n    \"\"\"\n    Determine if two lines with given slopes are perpendicular.\n    Parameters:\n    slope1, slope2 (float): Slopes of the two lines.\n    Returns:\n    bool: True if the lines are perpendicular, otherwise False.\n    Examples:\n    >>> perpendicular_slope(2, -0.5)\n    True\n    \"\"\"\n    return slope1 * slope2 == -1",
            "def check_parallel_or_perpendicular(slope1, slope2, relationship='parallel'):\n    \"\"\"\n    Check if two lines with given slopes are parallel or perpendicular.\n    Parameters:\n        slope1, slope2 (float): Slopes of the two lines.\n        relationship (str): Either 'parallel' or 'perpendicular'.\n    Returns:\n        bool: True if the relationship holds, False otherwise.\n    \n    Example:\n        >>> check_parallel_or_perpendicular(1, -1, 'perpendicular')\n        True\n    \"\"\"\n    if relationship == 'parallel':\n        return slope1 == slope2\n    elif relationship == 'perpendicular':\n        return np.isclose(slope1 * slope2, -1)\n    else:\n        raise ValueError(\"Unknown relationship type. Use 'parallel' or 'perpendicular'.\")"
        ],
        [
            "def solve_system_linear_equations(equations, variables):\n    \"\"\"\n    Solves a system of linear equations for the given variables.\n    Parameters\n    ----------\n    equations : list of str\n        A list of strings where each string represents a linear equation in the system.\n    variables : list of str\n        A list of variable names as strings to solve for in the system of equations.\n    Returns\n    -------\n    set or list\n        A set if there is a unique solution, otherwise a list of parameterized solutions.\n    Examples\n    --------\n    >>> solve_system_linear_equations(['2*x + y = 0', 'x - y = 3'], ['x', 'y'])\n    {(3/2, -3)}\n    >>> solve_system_linear_equations(['x + y - z = 1', 'x - y + z = 3', 'x + y + z = 5'], ['x', 'y', 'z'])\n    {(2, 1, 2)}\n    \n    \"\"\"\n    variables = symbols(variables)\n    equations_sympy = [Eq(eval(eqn)) for eqn in equations]\n    solution = linsolve(equations_sympy, *variables)\n    return solution",
            "def solve_system_of_linear_equations(equations):\n    \"\"\"\n    Solves a system of linear equations provided in string format.\n    Parameters:\n    equations (list of str): A list where each element is a string representing an equation.\n    Returns:\n    dict or None: A dictionary of solutions where keys are variables and values are their solutions, or None if no solution exists.\n    Examples:\n    >>> solve_system_of_linear_equations(['2*x + 3*y = 5', '3*x - y = 2'])\n    {x: 1, y: 1}\n    >>> solve_system_of_linear_equations(['x + y = 2', '2*x + 2*y = 4'])\n    {}  # This would represent an infinite number of solutions (dependent system).\n    \"\"\"\n    # Convert strings to symbolic equations\n    variables = sp.symbols(' '.join(set(''.join(equation.split('=')[0].split()) for equation in equations)))\n    symbolic_equations = [sp.Eq(sp.sympify(eq.split('=')[0]), sp.sympify(eq.split('=')[1])) for eq in equations]\n    \n    # Solve the system of equations\n    solution = sp.solve(symbolic_equations, variables)\n    return solution",
            "def solve_multivariable_linear_eq(equations, variables):\n    \"\"\"\n    A utility function that solves a system of multiple linear equations with multiple variables.\n    Args:\n         equations (list of tuples): A list with each tuple as (coefficients, constants) representing a linear equation.\n         variables (list of chars): A list of variable names as strings. \n    Returns:\n         solution (dictionary): Dictionary of variable: value pairs that satisfy the system of equations.\n    Example:\n        >>> solve_multivariable_linear_eq([((3,1,2), 10), ((1,3,1), 10), ((2,1,3), 10)], ['x', 'y', 'z'])\n        {'x': 2.0, 'y': 2.0, 'z': 2.0}\n    \"\"\"\n    \n    \n    variables = symbols(' '.join(variables))     # Define the variables.\n    eqs = [Eq(sum(c*v for c, v in zip(equation[0], variables)), equation[1]) for equation in equations]  # Formulate the equations.\n    solution = solve(eqs, variables)              # Solve the system of equations.\n    return solution"
        ],
        [
            "def line_equation_from_points(x1, y1, x2, y2):\n    \"\"\"\n    Formulate the equation of a line in slope-intercept form (y = mx + b) given two points.\n    Parameters:\n    x1, y1 (float): Coordinates of the first point.\n    x2, y2 (float): Coordinates of the second point.\n    Returns:\n    tuple: A tuple containing the slope (m) and y-intercept (b).\n    Examples:\n    >>> line_equation_from_points(1, 2, 3, 8)\n    (3.0, -1.0)\n    \"\"\"\n    m = calculate_slope(x1, y1, x2, y2)\n    b = y1 - m * x1\n    return (m, b)",
            "def line_equation_from_points(x1, y1, x2, y2):\n    \"\"\"\n    Return the slope-intercept form equation 'y = mx + b' of a line given two points.\n    Parameters:\n        x1, y1 (float): Coordinates of the first point.\n        x2, y2 (float): Coordinates of the second point.\n    Returns:\n        tuple: slope (m) and y-intercept (b) of the line.\n    \n    Example:\n        >>> line_equation_from_points(1, 2, 3, 4)\n        (1.0, 1.0)\n    \"\"\"\n    m = calculate_slope(x1, y1, x2, y2)\n    b = y1 - m * x1\n    return m, b",
            "def equation_from_point_slope(x1, y1, slope):\n    \"\"\"\n    Forms the equation of the line in slope-intercept form (y = mx + b) from a point and a slope.\n    \n    Parameters:\n    - x1 (float): x-coordinate of a known point.\n    - y1 (float): y-coordinate of a known point.\n    - slope (float, or None if vertical): Slope of the line.\n    Returns:\n    - sympy.Eq: Equation of the line in symbolic form.\n    Examples:\n    >>> equation_from_point_slope(1, 2, 3)\n    Eq(y, 3*x - 1)\n    >>> equation_fromJS..."
        ],
        [
            "def calculate_slope(x1, y1, x2, y2):\n    \"\"\"\n    Calculate the slope of a line that passes through two points (x1, y1) and (x2, y2).\n    Parameters:\n    x1, y1 (float): Coordinates of the first point.\n    x2, y2 (float): Coordinates of the second point.\n    Returns:\n    float: The slope of the line.\n    Examples:\n    >>> calculate_slope(1, 2, 3, 8)\n    3.0\n    \"\"\"\n    if x1 == x2:\n        raise ValueError(\"Division by zero error: x1 and x2 cannot be the same for slope calculation.\")\n    return (y2 - y1) / (x2 - x1)",
            "def calculate_slope(x1, y1, x2, y2):\n    \"\"\"\n    Calculate the slope of a line given two points.\n    Parameters:\n        x1, y1 (float): Coordinates of the first point.\n        x2, y2 (float): Coordinates of the second point.\n    Returns:\n        float: Slope of the line.\n    Raises:\n        ValueError: If the line is vertical (x1 == x2).\n    \n    Example:\n        >>> calculate_slope(1, 2, 3, 4)\n        1.0\n    \"\"\"\n    if x1 == x2:\n        raise ValueError(\"Slope is undefined for vertical lines (x1 cannot be equal to x2).\")\n    return (y2 - y1) / (x2 - x1)",
            "def calculate_slope(x1, y1, x2, y2):\n    \"\"\"\n    Calculates the slope (m) of a line given two points (x1, y1) and (x2, y2).\n    Parameters:\n    - x1 (float): x-coordinate of the first point.\n    - y1 (float): y-coordinate of the first point.\n    - x2 (float): x-coordinate of the second point.\n    - y2 (float): y-coordinate of the second point.\n    Returns:\n    - float: Slope of the line. Returns None if the line is vertical.\n    Examples:\n    >>> calculate_slope(1, 2, 3, 8)\n    3.0\n    >>> calculate_slope(1, 1, 1, 5)\n    None  # This represents a vertical line which has an undefined slope.\n    \"\"\"\n    if x2 == x1:\n        return None  # Undefined slope (vertical line)\n    return (y2 - y1) / (x2 - x1)"
        ],
        [
            "def solve_single_variable_linear_eq(coeff, const):\n    \"\"\"\n    A utility function that solves a single variable linear equation.\n    Args:\n         coeff (int, float): Coefficient of the variable in the equation.\n         const (int, float): Constant term in the equation.\n    Returns:\n         solution (int, float): Value that satisfies the given equation. \n    Example:\n        >>> solve_single_variable_linear_eq(2, -1)\n        0.5  \n    \"\"\"\n    x = symbols('x')                    # Define the variable.\n    equation = Eq(coeff*x, const)        # Formulate the given equation.\n    solution = solve(equation, x)[0]     # Solve for 'x'.\n    return solution",
            "def solve_multiple_linear_eq(coeff_1, const_1, coeff_2, const_2):\n    \"\"\"\n    A utility function that solves a system of two linear equations.\n    Args:\n         coeff_1 (tuple of int, float): Coefficients of the variables in the first equation.\n         const_1 (int, float): Constant term in the first equation.\n         coeff_2 (tuple of int, float): Coefficients of the variables in the second equation.\n         const_2 (int, float): Constant term in the second equation.\n    Returns:\n         solution (dictionary): Dictionary of variable: value pairs that satisfy the equations.\n    Example:\n        >>> solve_multiple_linear_eq((2, 1), 5, (1, -1), -1)\n        {x: 2, y: 1}\n    \"\"\"\n    x, y = symbols('x y')                        # Define the variables.\n    equation_1 = Eq(coeff_1[0]*x + coeff_1[1]*y, const_1)   # Formulate the first equation.\n    equation_2 = Eq(coeff_2[0]*x + coeff_2[1]*y, const_2)   # Formulate the second equation.\n    solution = solve((equation_1, equation_2), (x, y))       # Solve for 'x' and 'y'.\n    return solution"
        ],
        [
            "def find_intercepts(slope, intercept):\n    \"\"\"\n    Calculate the x-intercept and y-intercept of a line given its slope and y-intercept.\n    Parameters:\n        slope (float): Slope of the line.\n        intercept (float): y-intercept of the line.\n    Returns:\n        tuple: x-intercept and y-intercept as floats.\n    \n    Example:\n        >>> find_intercepts(1, 0)\n        (0.0, 0.0)\n    \"\"\"\n    x_intercept = -intercept / slope if slope != 0 else np.inf\n    y_intercept = intercept\n    return x_intercept, y_intercept",
            "def find_y_intercept(slope, x, y):\n    \"\"\"\n    Finds the y-intercept given the slope of a line and a point on the line (x, y).\n    Parameters:\n    - slope (float): Slope of the line\n    - x (float): x-coordinate of a point on the line.\n    - y (float): y-coordinate of a point on the line.\n    Returns:\n    - float: y-intercept of the line.\n    Examples:\n    >>> find_y_intercept(2, 3, 9)\n    3\n    \"\"\"\n    return y - slope * x"
        ],
        [
            "def solve_single_variable_linear_equation(coefficient, constant):\n    \"\"\"\n    Solves a single variable linear equation of the form ax + b = 0.\n    Parameters:\n    coefficient (number): The coefficient of the variable x in the equation (a in ax + b = 0).\n    constant (number): The constant term in the equation (b in ax + b = 0).\n    Returns:\n    float or None: The solution to the equation, or None if no solution exists.\n    Examples:\n    >>> solve_single_variable_linear_equation(5, 10)\n    -2.0\n    >>> solve_single_variable_linear_equation(0, 5)\n    None  # This would represent an equation with no solution when 0*x + 5 = 0\n    \"\"\"\n    x = sp.symbols('x')\n    equation = sp.Eq(coefficient * x + constant, 0)\n    solution = sp.solve(equation, x)\n    return solution[0] if solution else None"
        ],
        [
            "def solve_linear_inequalities(inequalities):\n    \"\"\"\n    Solves a system of linear inequalities.\n    Parameters\n    ----------\n    inequalities : list of sympy expressions\n        A list of sympy inequalities representing the system to be solved.\n    Returns\n    -------\n    list\n        A list of intervals representing the solution set for each inequality.\n    Examples\n    --------\n    >>> from sympy import (sympify, Symbol, Gt, Lt)\n    >>> x = Symbol('x')\n    >>> solve_linear_inequalities([Gt(x, 0), Lt(x, 1)])\n    [(0, 1)]\n    \"\"\"\n    variables = symbols(list(inequalities[0].free_symbols))\n    intervals = solve_rational_inequalities([[((Poly(ineq), ineq.rel_op) for ineq in inequalities)]])\n    return intervals"
        ],
        [
            "def point_slope_form(x1, y1, slope):\n    \"\"\"\n    Return the point-slope form of the equation of the line given a point and a slope.\n    Parameters:\n    x1, y1 (float): Coordinates of the point through which the line passes.\n    slope (float): Slope of the line.\n    Returns:\n    str: The point-slope form of the line equation.\n    Examples:\n    >>> point_slope_form(2, 3, 2)\n    'y - 3 = 2(x - 2)'\n    \"\"\"\n    return f\"y - {y1} = {slope}(x - {x1})\""
        ],
        [
            "def solve_linear_equation(expression, variable):\n    \"\"\"\n    Solves a single linear equation for a given variable.\n    Parameters\n    ----------\n    expression : str\n        The expression representing the linear equation, in terms of the variable to be solved.\n    variable : str\n        The name of the variable to solve for in the equation.\n    Returns\n    -------\n    list\n        A list of solutions for the variable.\n    Examples\n    --------\n    >>> solve_linear_equation('2*x + 1 = 0', 'x')\n    [-1/2]\n    \n    >>> solve_linear_equation('a*x - 3 = 0', 'x')\n    [3/a]\n    \"\"\"\n    var = symbols(variable)\n    equation = Eq(eval(expression))\n    solutions = solve(equation, var)\n    return solutions"
        ],
        [
            "def is_point_on_line(x, y, slope, intercept):\n    \"\"\"\n    Check if a given point (x, y) lies on the line defined by the slope and intercept.\n    Parameters:\n    x, y (float): Coordinates of the point.\n    slope (float): Slope of the line.\n    intercept (float): Y-intercept of the line.\n    Returns:\n    bool: True if the point lies on the line, otherwise False.\n    Examples:\n    >>> is_point_on_line(3, 7, 2, 1)\n    True\n    \"\"\"\n    return y == slope * x + intercept",
            "def is_point_on_line(x, y, slope, intercept):\n    \"\"\"\n    Check if a given point (x, y) lies on the line defined by the given slope and y-intercept.\n    Parameters:\n        x, y (float): Coordinates of the point to check.\n        slope, intercept (float): The slope and y-intercept of the line.\n    Returns:\n        bool: True if the point lies on the line, False otherwise.\n    \n    Example:\n        >>> is_point_on_line(3, 4, 1, 1)\n        True\n    \"\"\"\n    return y == slope * x + intercept"
        ]
    ],
    "Functions": [
        [
            "def solve_equations(equations, variables):\n    \"\"\"\n    Solves single or system of equations symbolically.\n    \n    Parameters:\n        equations (list of str): List containing equation(s) in string format.\n        variables (list of str): List containing variable(s) to solve for.\n    \n    Returns:\n        dict: A dictionary of solutions mapping each variable to its solution.\n        \n    Example:\n        >>> solve_equations(['x + 2*y = 5', 'x - y = 1'], ['x', 'y'])\n        {x: 3, y: 1}\n    \"\"\"\n    vars = symbols(variables)\n    eqs = [Eq(sympify(eq.split('=')[0]), sympify(eq.split('=')[1])) for eq in equations]\n    solutions = solve(eqs, vars)\n    return solutions",
            "def solve_equation(equation, variable):\n    \"\"\"\n    Solves algebraic equations for the specified variable.\n    \n    Parameters:\n    - equation (str): The equation in string format to be solved.\n    - variable (str): The variable to solve the equation for.\n    \n    Returns:\n    - A list of possible solutions for the variable.\n    \n    Example:\n    >>> solve_equation('x**2 + 3*x + 2 = 0', 'x')\n    [-1, -2]\n    \"\"\"\n    # sympify the equation string to a sympy equation\n    equation = sympify(equation)\n    var = symbols(variable)\n    return solve(Eq(equation, 0), var)",
            "def solve_equations(eqs, vars):\n    \"\"\"\n    Solves a system of equations symbolically and returns the solutions.\n    \n    Parameters:\n    - eqs (list of sympy expressions): Equations to solve.\n    - vars (list of sympy symbols): Variables to solve for.\n    \n    Returns:\n    - solutions (list or dict): Solutions of the system of equations.\n    \n    Example:\n    >>> x, y = sp.symbols('x y')\n    >>> solve_equations([x + y - 2, x - y - 0], [x, y])\n    \"\"\"\n    return sp.solve(eqs, vars)",
            "def solve_equation(equation, var):\n    \"\"\"\n    Solves algebraic equations with respect to the specified variable.\n    Parameters:\n    equation (str): The equation as a string.\n    var (str): The variable to solve the equation for.\n    Returns:\n    list: Solutions of the equation.\n    Examples:\n    >>> solve_equation('x**2 - 4 = 0', 'x')\n    [-2, 2]\n    \"\"\"\n    x = symbols(var)\n    solutions = solve(sympify(equation), x)\n    return solutions"
        ],
        [
            "def find_inverse_function(expression, variable=None):\n    \"\"\"\n    Computes the inverse of a given mathematical function.\n    \n    Parameters:\n    expression (str or sympy expression): The mathematical expression representing the function f(x).\n    variable (sympy.Symbol, optional): The variable used in the function. If not provided, determined automatically.\n    \n    Returns:\n    sympy expression: Inverse function of the given function or None if inverse does not exist.\n    \n    Examples:\n    >>> find_inverse_function(\"x**2\", sp.symbols('x'))\n    sqrt(x)\n    >>> find_inverse_function(\"2*x + 1\", sp.symbols('x'))\n    (x - 1)/2\n    \"\"\"\n    x = sp.symbols('x') if variable is None else variable\n    y = sp.symbols('y')\n    expr = sp.sympify(expression)\n    func = sp.Eq(y, expr.subs(x, y))\n    try:\n        solved = sp.solve(func, y)\n        return solved[0].subs(y, x)  # Return the inverse replacing y back to x\n    except Exception as e:\n        print(f\"Error finding inverse: {str(e)}\")\n        return None",
            "def find_inverse_function(f_expr, var):\n    \"\"\"\n    Computes the inverse of a given function, if it exists.\n    \n    Parameters:\n    f_expr (str): Function expression as a string.\n    var (str): The variable in the function expression.\n    Returns:\n    sympy.Expr or None: Inverse function expression or None if inverse doesn't exist analytically.\n    \n    Examples:\n    >>> find_inverse_function('2*x + 3', 'x')\n    (x - 3)/2\n    \"\"\"\n    x = symbols(var)\n    f = sympify(f_expr)\n    y = symbols('y')\n    inverse_sol = solve(Eq(y, f), x)\n    if inverse_sol:\n        return inverse_sol[0]\n    else:\n        return None"
        ],
        [
            "def evaluate_function(expression, **kwargs):\n    \"\"\"\n    Evaluates a given function expression at the specified values of its variables.\n    \n    Parameters:\n    - expression (str): The function expression in Python-syntax string format.\n    - kwargs (dict): Keyword argument pairs where variables are the keys, and the values are the numeric values where the function needs to be evaluated.\n    \n    Returns:\n    - The evaluated result of the function.\n    \n    Example:\n    >>> evaluate_function('x**2 + 3*x + 1', x=2)\n    11\n    \"\"\"\n    expr = sympify(expression)  # Converts string expression into a sympy expression\n    variables = symbols(','.join(kwargs.keys()))\n    func = lambdify(variables, expr, modules=['numpy'])\n    return func(*kwargs.values())",
            "def evaluate_function(expression, variable_value, variable=sp.symbols('x')):\n    \"\"\"\n    Evaluate the given mathematical function at a specific value.\n    Parameters:\n    - expression : str or sympy.Expr\n        The algebraic expression representing the function (e.g., 'x^2 + 3*x - 1')\n    - variable_value : float or int\n        The value at which to evaluate the function.\n    - variable : sympy.Symbol\n        The main variable in the expression if different than the default 'x'.\n    Returns:\n    - float or sympy.Expr\n        The result of the function evaluation.\n    Examples:\n    >>> evaluate_function('x**2 - 4*x + 4', 2)\n    0\n    \"\"\"\n    expr = sp.sympify(expression)\n    result = expr.subs(variable, variable_value)\n    return result.evalf() if result.is_Float else result"
        ],
        [
            "def is_even_function(f_expr, var):\n    \"\"\"\n    Determines if a given function is an even function.\n    \n    Parameters:\n    f_expr (str): Function expression as a string.\n    var (str): Variable in the function expression.\n    \n    Returns:\n    bool: True if the function is even, False otherwise.\n    \n    Examples:\n    >>> is_even_function('x**2', 'x')\n    True\n    >>> is_even_function('x**3', 'x')\n    False\n    \"\"\"\n    x = symbols(var)\n    f = sympify(f(hidden=True)+expr)\n    return f.subs(x, -x) == f",
            "def is_odd_function(f_expr, var):\n    \"\"\"\n    Determines if a given function is an odd function.\n    \n    Parameters:\n    f_expr (str): Function expression as a string.\n    var (str): Variable in the function expression.\n    \n    Returns:\n    bool: True if the function is odd, False otherwise.\n    \n    Examples:\n    >>> is_odd_function('x**3', 'x')\n    True\n    >>> is_odd_function('x**2', 'x')\n    False\n    \"\"\"\n    x = symbols(var)\n    f = sympify(f_expr)\n    return f.subs(x, -x) == -f"
        ],
        [
            "def function_transformation(func, transformation: dict):\n    \"\"\"\n    Applies a transformation to a function.\n    \n    Parameters\n    ----------\n    func : function\n        A single-variable function to be transformed.\n    transformation : dict\n        A dictionary carrying the type and degree of the transformation.\n    Returns\n    -------\n    transformed_function : function\n        The function after applying the transformation.\n    \"\"\"\n    if transformation['type'] == 'shift':\n        return lambda x: func(x - transformation['value'])\n    elif transformation['type'] == 'scale':\n        return lambda x: func(x * transformation['value'])\n    elif transformation['type'] == 'reflect':\n        if transformation['axis'] == 'x':\n            return lambda x: func(-x)\n        elif transformation['axis'] == 'y':\n            return lambda x: -func(x)\n    else:\n        raise ValueError('Invalid transformation type.')"
        ],
        [
            "def evaluate_function_at(f_expr, at_val, var='x'):\n    \"\"\"\n    Evaluates a function at a specific value.\n    Parameters:\n    f_expr (str): Function expression.\n    at_val (numeric): Value at which to evaluate the function.\n    var (str, optional): Variable in the function. Defaults to 'x'.\n    Returns:\n    numeric or sympy.Expr: Result of function evaluation.\n    Examples:\n    >>> evaluate_function_at('x**2 + 2*x + 1', 2)\n    9\n    \"\"\"\n    x = symbols(var)\n    f = sympify(f_expr)\n    result = f.subs(x, at_val)\n    return result"
        ],
        [
            "def find_function_domain(expression, variable=sp.symbols('x')):\n    \"\"\"\n    Determine the domain of a function where it's defined (real values).\n    Parameters:\n    - expression : str or sympy.Expr\n        The algebraic expression of the function.\n    - variable : sympy.Symbol\n        The variable used in the function.\n    Returns:\n    - sympy.sets.sets.Set\n        The domain of the function as a sympy Set.\n    Examples:\n    >>> str(find_function_domain('log(x) + sqrt(x - 1)'))\n    'Interval(1, oo)'\n    \"\"\"\n    expr = sp.sympify(expression)\n    domain = sp.calculus.util.continuous_domain(expr, variable, sp.S.Reals)\n    return domain"
        ],
        [
            "def function_shift(f, x, h_shift=0, v_shift=0):\n    \"\"\"\n    Applies horizontal and vertical shifts to a function.\n    Parameters:\n    - f (sympy Expression): Function to shift.\n    - x (sympy Symbol): The main variable in the function.\n    - h_shift (float): Horizontal shift (positive shifts to the right).\n    - v_shift (float): Vertical shift (positive shifts upwards).\n    \n    Returns:\n    - shifted_function (sympy expression): The shifted function.\n    Example:\n    >>> x = sp.symbols('x')\n    >>> function_shift(x**2, x, -2, 3)\n    \"\"\"\n    return f.subs(x, x - h_shift) + v_shift"
        ],
        [
            "def simplify_expression(expression):\n    \"\"\"\n    Simplifies an algebraic expression.\n    \n    Parameters:\n        expression (str): The algebraic expression in string format.\n    \n    Returns:\n        Expr: A simplified Sympy expression.\n        \n    Example:\n        >>> simplify_expression('2*x + 3*x - 5')\n        5*x - 5\n    \"\"\"\n    expr = sympify(expression)\n    return simplify(expr)",
            "def simplify_expression(expression):\n    \"\"\"\n    Simplifies an algebraic expression.\n    \n    Parameters:\n    - expression (str): The algebraic expression to simplify.\n    \n    Returns:\n    - The simplified expression as a string.\n    \n    Example:\n    >>> simplify_expression('x**2 - 2*x + 1')\n    '(x - 1)**2'\n    \"\"\"\n    expr = sympify(expression)  # Convert string to sympy expression\n    return str(simplify(expr))",
            "def simplify_expression(expr):\n    \"\"\"\n    Simplifies any given algebraic expression.\n    Parameters:\n    expr (str): The algebraic expression as a string.\n    Returns:\n    str: Simplified expression as a string.\n    Examples:\n    >>> simplify_expression('x**2 + 2*x + 1')\n    'x**2 + 2*x + 1'\n    \"\"\"\n    simplified_expr = sympify(expr).simplify()\n    return str(simplified_expr)"
        ],
        [
            "def evaluate_expression(expression: str):\n    \"\"\"\n    Evaluates a mathematical expression.\n    \n    Parameters\n    ----------\n    expression : str\n        A mathematical expression represented as a string.\n    \n    Returns\n    -------\n    result : number\n        The evaluated result of the mathematical expression.\n        \n    Examples\n    --------\n    >>> evaluate_expression('3+2*2')\n    7.0\n    >>> evaluate_expression('4*2+3')\n    11.0\n    \"\"\"\n    parsed_expression = sympify(expression)\n    result = parsed_expression.evalf()\n    return result"
        ],
        [
            "def substitute_in_expression(expr, var, value):\n    \"\"\"\n    Substitutes a value into the given variable in an expression.\n    Parameters:\n    expr (str): The expression.\n    var (str): The variable in the expression.\n    value (numeric or str): Value to substitute into the variable.\n    Returns:\n    numerical or sympy.Expr: Result after substitution.\n    \n    Examples:\n    >>> substitute_in_expression('x**2 + 2*x + 1', 'x', 3)\n    16\n    \"\"\"\n    expression = sympify(expr)\n    return expression.subs(var, value)"
        ],
        [
            "def function_properties(f, x):\n    \"\"\"\n    Analyzes basic properties of a function such as continuity, differentiability, and monotonicity.\n    Parameters:\n    - f (sympy expression): Function of x.\n    - x (sympy symbol): The symbol used as the function input.\n    Returns:\n    - props (dict): Dictionary of properties including continuity, differentiability, increasing, decreasing.\n    Example:\n    >>> x = sp.symbols('x')\n    >>> function_properties(x**2, x)\n    \"\"\"\n    props = {}\n    df = sp.diff(f, x)\n    critical_points = sp.solveset(df, x, domain=sp.S.Reals)\n    props['increasing_intervals'] = sp.calculus.util._monotonicity_helper(f, x, critical_points, \">\")\n    props['decreasing_intervals'] = sp.calculus.util._monotonicity_helper(f, x, critical_points, \"<\")\n    props['continuity'] = sp.calculus.util.continuous_domain(f, x, sp.S.Reals)\n    return props"
        ],
        [
            "def function_composition(f_expr, g_expr, var):\n    \"\"\"\n    Composes two functions f(g(x)).\n    Parameters:\n    f_expr (str): Outer function expression f(x).\n    g_expr (str): Inner function expression g(x).\n    var\n    (str): Variable used in the expressions.\n    Returns:\n    sympy.Expr: Expression representing the composition f(g(x)).\n    Examples:\n    >>> function_composition('2*x', 'x**2', 'x')\n    '2*x**2'\n    \"\"\"\n    x = symbols(var)\n    f = sympify(f_expr)\n    g = sympify(g_expr)\n    composition = f.subs(x, g)\n    return composition"
        ],
        [
            "def simplify_expression(expression: str):\n    \"\"\"\n    Simplifies a mathematical expression.\n    \n    Parameters\n    ----------\n    expression : str\n        A mathematical expression represented as a string.\n    \n    Returns\n    -------\n    simplified_expression : str\n        The simplified version of the mathematical expression.\n        \n    Examples\n    --------\n    >>> simplify_expression('3*(2+3)')\n    '15'\n    >>> simplify_expression('(3+2)*2')\n    '10'\n    \"\"\"\n    parsed_expression = sympify(expression)\n    simplified_expression = simplify(parsed_expression)\n    return str(simplified_expression)"
        ],
        [
            "def solve_functional_equation(f, x, conditions=None):\n    \"\"\"\n    Solves a functional equation given the function and conditions.\n    \n    Parameters:\n    - f (sympy expression): The functional equation f(x).\n    - x (sympy Symbol): The main variable.\n    - conditions (list of sympy expressions): Additional conditions or specific cases.\n    \n    Returns:\n    - solutions (sympy set): Solutions of the functional equation.\n    \n    Example:\n    >>> x = sp.symbols('x')\n    >>> solve_functional_equation(x**2 - x - 6, x)\n    \"\"\"\n    base_solution = sp.solveset(f, x, domain=sp.S.Reals)\n    if conditions:\n        return [sol for sol in base_solution if all(cond.subs(x, sol) for cond in conditions)]\n    return base_solution"
        ],
        [
            "def evaluate_function(func, x):\n    \"\"\"\n    Evaluates a general function for a given x value.\n    \n    Parameters:\n    - func (callable): A Python callable that represents a mathematical function.\n    - x (float or list): An input value(s) for the function.\n    \n    Returns:\n    - result (float or list): The result of applying the function to x.\n    \n    Example:\n    >>> evaluate_function(lambda x: x**2 + 2*x + 1, 3)\n    16\n    \"\"\"\n    return func(x)"
        ],
        [
            "def polynomial_discriminant(coefficients):\n    \"\"\"\n    Calculate the discriminant of a polynomial. For a quadratic ax^2 + bx + c, it is b^2 - 4ac.\n    \n    Parameters:\n    - coefficients (list of float): Coefficients of the polynomial [a, b, c].\n    \n    Returns:\n    - discriminant (float): The discriminant of the polynomial.\n    \n    Example:\n    >>> polynomial_discriminant([1, 0, -1])\n    4\n    \"\"\"\n    if len(coefficients) != 3:\n        raise ValueError(\"Discriminant calculation is currently only implemented for quadratic polynomials.\")\n    a, b, c = coefficients\n    return b**2 - 4*a*c"
        ],
        [
            "def function_domain(func, args_range):\n    \"\"\"\n    Identify the domain of the function by checking where it is defined or undefined within a given range.\n    \n    Parameters:\n    - func (callable): Function to analyze.\n    - args_range (tuple): A tuple (start, end, points) defining the range to test the function.\n    \n    Returns:\n    - domain (list): List of points where function is defined.\n    \n    Example:\n    >>> function_domain(lambda x: 1/x, (-10, 10, 1000))\n    Contains domain excluding x=0 within the specified range.\n    \"\"\"\n    import numpy as np\n    start, end, points = args_range\n    x_values = np.linspace(start, end, points)\n    domain = []\n    for x in x_values:\n        try:\n            func(x)\n            domain.append(x)\n        except Exception:\n            continue  # Skip values where function is undefined\n    return domain"
        ],
        [
            "def FunctionAnalysisTool(expr, x, check_property=None):\n    \"\"\"\n    Analyze properties of a given function like being even, odd, one-to-one, and calculates the inverse if applicable.\n    \n    Parameters:\n        expr (sympy expression): The function expression in terms of x.\n        x (sympy Symbol): The variable in the function.\n        check_property (str, optional): Specific property to check (e.g. 'even', 'odd', 'one-to-one')\n    \n    Returns:\n        dict: A dictionary describing requested properties and inverse of the function if it exists.\n    \n    Examples:\n        >>> x = sp.symbols('x')\n        >>> expr = x**2\n        >>> FunctionAnalysisTool(expr, x, 'even')\n        {'function': x**2, 'is_even': True, 'inverse_function': None}\n        \n        >>> expr = sp.log(x)\n        >>> FunctionAnalysisTool(expr, x, 'one-to-one')\n        {'function': log(x), 'is_one_to_one': True, 'inverse_function': exp(x)}\n    \"\"\"\n    results = {'function': expr}\n    \n    if check_property in ['even', 'odd', 'one-to-one']:\n        if check_property == 'even':\n            is_even = expr.subs(x, -x) == expr\n            results['is_even'] = is_even\n            \n        if check_property == 'odd':\n            is_odd = expr.subs(x, -x) == -expr\n            results['is_odd'] = is_odd\n            \n        if check_property == 'one-to-one':\n            _, inverse_func = sp.invert(expr,x)\n            is_one_to_one = len(sp.solve(expr - sp.Function('f')(x), x)) == 1\n            results['is_one_to_one'] = is_one_to_one\n            results['inverse_function'] = inverse_func if is_one_to_one else None\n    \n    return results"
        ],
        [
            "def find_roots_polynomial(coefficients):\n    \"\"\"\n    Finds roots (real and complex) of a polynomial.\n    \n    Parameters:\n    - coefficients (list of float): Coefficients of the polynomial from highest degree to zero degree.\n    \n    Returns:\n    - roots (ndarray): Roots of the polynomial.\n    \n    Example:\n    >>> find_roots_polynomial([1, 0, -1])\n    array([-1., 1.])\n    \"\"\"\n    p = Polynomial(coefficients[::-1])  # Polynomial takes coefficients in ascending order of degrees\n    return p.roots()"
        ],
        [
            "def evaluate_polynomial(expression, value_dict):\n    \"\"\"\n    Evaluates a polynomial at given variable values.\n    \n    Parameters:\n        expression (str): The polynomial expression in string format.\n        value_dict (dict): A dictionary of variable values.\n    \n    Returns:\n        Expr: The result of the polynomial evaluation.\n        \n    Example:\n        >>> evaluate_polynomial('x^2 + 2*x + 1', {'x': 2})\n        9\n    \"\"\"\n    expr = poly(expression)\n    result = expr.eval(value_dict)\n    return result"
        ],
        [
            "def solve_inverse_proportionality(x, y, k):\n    \"\"\"\n    Solves equations based on inverse proportionality, where x * y = k.\n    Parameters:\n    x (float or None): Known or unknown (None) value of x.\n    y (float or None): Known or unknown (None) value of y.\n    k (float): Constant value of the product of `x` and `y`.\n    Returns:\n    float: The unknown value of x or y, whichever is needed.\n    Examples:\n    >>> solve_inverse_proportionality(None, 5, 20)\n    4.0\n    >>> solve_inverse_proportionality(4, None, 20)\n    5.0\n    \"\"\"\n    if x is None and y is not None:\n        return k / y\n    elif y is None and x is not None:\n        return k / x\n    else:\n        raise ValueError(\"One of x or y must be None to solve for the other.\")"
        ],
        [
            "def get_polynomial_roots(expression):\n    \"\"\"\n    Returns the roots of the polynomial.\n    \n    Parameters:\n        expression (str): The polynomial expression in string format.\n    \n    Returns:\n        list: The roots of the polynomial.\n        \n    Example:\n        >>> get_polynomial_roots('x^2 - 5*x + 6')\n        {x: 2, x: 3}\n    \"\"\"\n    expr = poly(expression)\n    return roots(expr)"
        ],
        [
            "def evaluate_polynomial(coefficients, x_values):\n    \"\"\"\n    Evaluates a polynomial at specified x values.\n    \n    Parameters:\n    - coefficients (list of float): Coefficients of the polynomial from highest degree to constant term.\n    - x_values (float or list of float): Values of x to evaluate the polynomial.\n    \n    Returns:\n    - poly_values (float or list of float): Evaluated values of the polynomial.\n    \n    Example:\n    >>> evaluate_polynomial([1, 0, -1], [0, 1, 2])\n    [1, -1]\n    \"\"\"\n    p = Polynomial(coefficients[::-1])  # Polynomial takes coefficients in ascending order of degrees\n    return p(x_values)"
        ],
        [
            "def check_function_parity(expression, variable=None):\n    \"\"\"\n    Determine and return whether a function is even, odd, or neither.\n    Parameters:\n    expression (str or sympy expression): The function expression as a string or sympy expression.\n    variable (sympy.Symbol, optional): The main variable of the function. If not provided, determined automatically.\n    Returns:\n    str: 'even', 'odd', or 'neither'\n    Examples:\n        >>> check_function_parity(\"x**2\", sp.symbols('x'))\n        'even'\n        >>> check_function_parity(\"x**3\", sp.symbols('x'))\n        'odd'\n    \"\"\"\n    x = sp.symbols('x') if variable is None else variable\n    expr = sp.sympify(expression)\n    if expr.subs(x, -x) == expr:\n        return \"even\"\n    elif expr.subs(x, -x) == -expr:\n        return \"odd\"\n    else:\n        return \"neither\""
        ],
        [
            "def ProportionalityTool(a, b, k=None, relationship='inverse'):\n    \"\"\"\n    Analyze or solve problems involving direct or inverse proportionality between two variables.\n    \n    Parameters:\n        a (sympy expression or float): First variable or its value.\n        b (sympy expression or float): Second variable or its value.\n        k (float, optional): Constant of proportionality if known.\n        relationship (str): Type of relationship ('direct' or 'inverse')\n    \n    Returns:\n        sympy expression or float: Result based on the inputs which could be relation expression or value of one variable.\n    \n    Examples:\n        >>> a, b = sp.symbols('a b')\n        >>> ProportionalityTool(a, b, 5, 'inverse')\n        a*b = 5\n        \n        >>> ProportionalityTool(15, b, 3, 'direct')\n        b = 5.0\n    \"\"\"\n    if relationship == 'inverse':\n        if k is not None:\n            return sp.Eq(a * b, k)\n        else:\n            try:\n                if isinstance(a, sp.Symbol):\n                    return solve(sp.Eq(a * b, k), a)\n                else:\n                    return solve(sp.Eq(a * b, k), b)\n            except:\n                raise ValueError(\"Sufficient information not provided.\")\n    elif relationship == 'direct':\n        if k is not None:\n            return sp.Eq(a / b, k)\n        else:\n            try:\n                if isinstance(a, sp.Symbol):\n                    return solve(sp.Eq(a / b, k), a)\n                else:\n                    return solve(sp.Eq(a / b, k), b)\n            except:\n                raise ValueError(\"Sufficient information not provided.\")"
        ],
        [
            "def function_compose(f, g, x):\n    \"\"\"\n    Returns the composition of two functions, f(g(x)).\n    Parameters:\n    - f, g (sympy expressions): Functions to compose.\n    - x (sympy Symbol): Input variable for the functions.\n    Returns:\n    - composition (sympy expression): Result of the composition f(g(x)).\n    \n    Example:\n    >>> x = sp.symbols('x')\n    >>> f = x**2\n    >>> g = 2*x + 1\n    >>> function_compose(f, g, x)\n    \"\"\"\n    return f.subs(x, g)"
        ],
        [
            "def plot_function(f, var_range, title=\"Function Plot\"):\n    \"\"\"\n    Plots a given symbolic function over a specified range.\n    \n    Parameters:\n    - f (sympy Expression): The function to plot, in terms of a symbolic variable.\n    - var_range (tuple): A tuple (symbol, start, end) defining the variable and range over which to plot.\n    - title (str): The title of the plot.\n    \n    Example:\n    >>> x = sp.symbols('x')\n    >>> plot_function(x**2, (x, -10, 10))\n    \"\"\"\n    x, start, end = var_range\n    sp.plot(f, (x, start, end), title=title, xlabel=str(x), ylabel='f(x)')"
        ]
    ],
    "Systems of Equations": [
        [
            "def solve_linear_system(equations, *variables):\n    \"\"\"\n    Solves a linear system of equations.\n    Parameters:\n    - equations: list of equations (sympy Eq objects) to solve.\n    - variables: list of symbols (sympy symbols) in the equations.\n    Returns:\n    - A dictionary with variables as keys and their solutions as values.\n    \n    Examples:\n    >>> x, y = symbols('x y')\n    >>> eq1 = Eq(2*x + y, 10)\n    >>> eq2 = Eq(x - y, 1)\n    >>> solve_linear_system([eq1, eq2], x, y)\n    {x: 3, y: 4}\n    \"\"\"\n    if not equations or not variables:\n        raise ValueError(\"Both equations and variables need to be provided\")\n    # Check if the system can be solved with matrix methods\n    if len(variables) == len(equations):\n        coeffs_matrix = []\n        const_matrix = []\n        for eq in equations:\n            coeffs = [eq.lhs.coeff(v) for v in variables]\n            consts = -eq.rhs\n            coeffs_matrix.append(coeffs)\n            const_matrix.append(consts)\n        \n        # Check for singularity of the coefficient matrix to avoid solving singular systems\n        coeffs_matrix = Matrix(coeffs_matrix)\n        if coeffs_matrix.det() == 0:\n            raise ValueError(\"The coefficient matrix of the system is singular, no unique solutions.\")\n        \n        const_matrix = Matrix(const_matrix)\n        solutions = coeffs_matrix.inv() * const_matrix\n        return dict(zip(variables, solutions))\n    else:\n        return solve(equations, *variables)",
            "def solve_nonlinear_system(equations, *variables):\n    \"\"\"\n    Solves a nonlinear system of equations.\n    Parameters:\n    - equations: list of equations (sympy Eq objects) to solve.\n    - variables: list of symbols (sympy symbols) in the equations.\n    Returns:\n    - A list with dictionaries for each solution set if multiple solutions exist.\n    Examples:\n    >>> x, y = symbols('x y')\n    >>> eq1 = Eq(x**2 + y**2, 16)\n    >>> eq2 = Eq(x - y, 0)\n    >>> solve_nonlinear_system([eq1, eq2], x, y)\n    [{x: -4, y: -4}, {x: 4, y: 4}]\n    \"\"\"\n    if not equations or not variables:\n        raise ValueError(\"Both equations and variables need to be provided\")\n    return solve(equations, *variables)",
            "def solve_nonlinear_system(equations, variables, initial_guesses):\n    \"\"\"\n    Solves a system of nonlinear equations.\n    \n    Parameters:\n        equations (list): A list of functions that return 0 when the system is solved.\n        variables (list): A list of sympy symbols present in the equations.\n        initial_guesses (list): A list of initial guesses for the solutions.\n    \n    Returns:\n        ndarray: Numerical solutions to the system of equations.\n        \n    Example:\n        >>> from sympy.abc import x, y\n        >>> def eq1(v): return v[0] ** 2 - v[1] + 4\n        >>> def eq2(v): return v[1] ** 2 - v[0] - 1\n        >>> solve_nonlinear_system([eq1, eq2], [x, y], [1, 1])\n        array([1.192, 0.83])\n    \"\"\"\n    func = lambda v: [eq(v) for eq in equations]\n    return fsolve(func, initial_guesses)",
            "def solve_nonlinear_system(equations, variables):\n    \"\"\"\n    Solves a non-linear system of equations symbolically using SymPy.\n    Parameters:\n        equations (list): A list of SymPy equation objects representing the system of equations.\n        variables (list): A list of SymPy symbols that are the variables to solve for in the equations.\n    Returns:\n        dict: A dictionary where keys are the SymPy symbols and values are the solutions.\n    Example:\n        >>> x, y = sp.symbols('x y')\n        >>> eq1 = sp.Eq(x**2 + y**2, 16)\n        >>> eq2 = sp.Eq(x - y, 2)\n        >>> solve_nonlinear_system([eq1, eq2], [x, y])\n        [{x: 4, y: 2}, {x: -2, y: -4}]\n    \"\"\"\n    solution = sp.solve(equations, variables, dict=True)\n    return solution"
        ],
        [
            "def solve_linear_equations(coefficients, constants):\n    \"\"\"\n    Solves a system of linear equations given the coefficients and constants.\n    \n    Parameters:\n        coefficients (ndarray): A 2D NumPy array of coefficients from the system of equations.\n        constants (ndarray): A 1D NumPy array of constant terms.\n    \n    Returns:\n        ndarray: Solution to the system of equations.\n        \n    Example:\n        >>> A = np.array([[3, 1], [1, 2]])\n        >>> b = np.array([9, 8])\n        >>> solve_linear_equations(A, b)\n        array([2., 3.])\n    \"\"\"\n    coefficients = np.array(coefficients)\n    constants = np.array(constants)\n    \n    # Using numpy's linear algebra solution to solve the equations\n    solution = np.linalg.solve(coefficients, constants)\n    return solution",
            "def solve_linear_system(coeff_matrix, const_vector):\n    \"\"\"\n    Solves a system of linear equations defined by Ax = b.\n    Parameters:\n    -----------\n    coeff_matrix : array_like\n        Coefficient matrix (A) of the system, where each row represents an equation with the columns representing coefficients of variables.\n    \n    const_vector : array_like\n        Constant vector (b), representing the constants on the right side of the equations.\n    Returns:\n    --------\n    solution : ndarray\n        Solution to the system of equations, where each element corresponds to a variable.\n    Examples:\n    ---------\n    >>> A = np.array([[1, 2], [3, 4]])\n    >>> b = np.array([5, 11])\n    >>> solve_linear_system(A, b)\n    array([-3.,  4.])\n    \"\"\"\n    coeff_matrix = np.array(coeff older=\"input\" => \"absolutatrix, dtype=float)\n    const_vector = np.array(const_vector, dtype=float)\n    solution = np.linalg.solve(coeff_matrix, const_VECTOR)\n    return solution",
            "def solve_linear_system(coeff_matrix, constant_vector):\n    \"\"\"\n    Solve a system of linear equations given in the form Ax = b using NumPy's linear algebra solver.\n    Parameters:\n        coeff_matrix (list of list of floats or ndarray): The coefficient matrix A of the system.\n        constant_vector (list of floats or ndarray): The constant vector b of the system.\n    Returns:\n        ndarray: Solution vector x, which satisfies Ax = b.\n    Example:\n        >>> A = [[2, -1], [1, 3]]\n        >>> b = [1, 12]\n        >>> solve_linear_system(A, b)\n        array([1., 3.])\n    \"\"\"\n    coeff_matrix = np.array(coeff_matrix)\n    constant_vector = np.array(constant_vector)\n    solution = np.linalg.solve(coeff_matrix, constant_vector)\n    return solution"
        ],
        [
            "def solve_polynomial_equation(equation, degree, var_name='x'):\n    \"\"\"\n    It receives a string representing a polynomial equation and return its solution. It's assumed that\n    equation is equal to zero.\n    \n    Parameters:\n    equation (str): A string representing a polynomial equation.\n    degree (int): An integer representing the degree of the polynomial equation.\n    var_name (str): A string representing the name of the variable.\n   \n    Returns:\n    list: A list containing the solutions for the equation.\n    Example:\n    solve_polynomial_equation(\"x**3 + 2*x**2 + 3*x + 4\", 3)\n    \"\"\"\n    var = symbols(var_name)\n    return solve(Eq(eval(equation), 0), var)"
        ],
        [
            "def create_equation(var_dict, equation):\n    \"\"\"\n    It receives a dict and a string representing an algebraic equation and evaluates the equation with the given variables values.\n    \n    Parameters:\n    var_dict (dict): A dictionary with variable names as keys and their values as values.\n    equation (str): A string representing an algebraic equation.\n   \n    Returns:\n    Expr: Evaluated expression.\n    Example:\n    create_equation({'x': 3, 'y': 4}, \"x**2 + y**2\")\n    \"\"\"\n    variables = symbols(' '.join(list(var_dict.keys())))\n    return eval(equation)"
        ],
        [
            "def simplify_expression(expression):\n    \"\"\"\n    Simplifies an algebraic expression.\n    \n    Parameters:\n        expression (str): The algebraic expression in string form.\n    \n    Returns:\n        Expr: Simplified mathematical expression.\n        \n    Example:\n        >>> simplify_expression(\"x**2 + 2*x + 1\")\n        x**2 + 2*x + 1\n    \"\"\"\n    expr = sp.sympify(expression)\n    return sp.simplify(expr)",
            "def simplify_expression(expr):\n    \"\"\"\n    Simplifies any algebraic expression.\n    Parameters:\n        expr : sympy expression\n            The algebraic expression to be simplified.\n    Returns:\n        sympy expression\n            Simplified version of the input expression.\n    Examples:\n        >>> x, y = symbols('x y')\n        >>> simplify_expression((x**2 + 2*x + 1)/(x + 1))\n        x + 1\n    \"\"\"\n    return simplify(expr)"
        ],
        [
            "def solve_linear_equation(equation, var_1_name='x', var_2_name='y'):\n    \"\"\"\n    It receives a string representing a linear equation in two variables and return its solution. It's assumed that\n    equation is equal to zero.\n    \n    Parameters:\n    equation (str): A string representing a linear equation in two variables.\n    var_1_name (str): A string representing the name of the first variable.\n    var_2_name (str): A string representing the name of the second variable.\n   \n    Returns:\n    dict: A dictionary containing the solution for the equation for each variable.\n    Example:\n    solve_linear_equation(\"2*x - 3*y + 4\")\n    \"\"\"\n    var_1, var_2 = symbols(var_1_name + ' ' + var_2_name)\n    return solve(Eq(eval(equation), 0), (var_1, var_2))"
        ],
        [
            "def evaluate_floor(expr, decimals=None):\n    \"\"\"\n    Evaluates the floor function of a given expression and possibly rounds it to a specified number of decimals.\n    Parameters:\n        expr : sympy expression or float\n            The expression whose floor value is to be calculated.\n        decimals : int, optional\n            Number of decimal places to round the result to, if specified.\n    Returns:\n        sympy expression or float\n            Floor value of the expression. Rounded if decimals is specified.\n    Examples:\n        >>> x = Symbol('x')\n        >>> evaluate_floor(3.456)\n        3\n        >>> evaluate_floor(x**2 - x + 0.5, decimals=2)\n        x**2 - x\n    \"\"\"\n    floored_expr = floor(expr)\n    if decimals is not None:\n        return N(floored_expr, decimals)\n    return floored_no"
        ],
        [
            "def solve_quadratic(a, b, c):\n    \"\"\"\n    Solve a quadratic equation of the form ax^2 + bx + c = 0.\n    \n    Parameters:\n        a (float): Coefficient of x^2.\n        b (float): Coefficient of x.\n        c (float): Constant term.\n        \n    Returns:\n        tuple: A tuple of two roots (can be real or complex numbers).\n        \n    Example:\n        >>> solve_quadratic(1, -3, 2)\n        ((2+0j), (1+0j))\n    \"\"\"\n    # Calculate discriminant\n    discriminant = cmath.sqrt(b ** 2 - 4 * a * c)\n    # Calculate two roots\n    root1 = (-b + discriminant) / (2 * a)\n    root2 = (-b - discriminant) / (2 * a)\n    \n    return (root1, root2)"
        ],
        [
            "def solve_symbolic_equations(eq_list):\n    \"\"\"\n    Solves a system of symbolic equations.\n    Parameters:\n    -----------\n    eq_list : list\n        List containing equation objects from sympy.\n    Returns:\n    --------\n    solution : dict\n        A dictionary where keys are the sympy symbols (variables) and values are the solutions to these variables.\n    Examples:\n    ---------\n    >>> x, y = symbols('x y')\n    >>> eq1 = Eq(2*x + y, 10)\n    >>> eq2 = Eq(x - y, 2)\n    >>> solve_symbolic_equations([eq1, eq2])\n    {x: 4, y: 6}\n    \"\"\"\n    solution = solve(eq_list)\n    return solution"
        ],
        [
            "def matrix_solver(A, b):\n    \"\"\"\n    Solves a system of linear equations (Ax = b) using matrix operations where A is square.\n    Parameters:\n        A : numpy.ndarray\n            Coefficient matrix (must be square).\n        b : numpy.ndarray\n            Constant terms array.\n    Returns:\n        numpy.ndarray\n            Solution vector x.\n    Examples:\n        >>> A = np.array([[1, 1], [1, -1]])\n        >>> b = np.array([2, 0])\n        >>> matrix_solver(A, b)\n        array([1., 1.])\n    \"\"\"\n    A = np.array(A, dtype=float)\n    b = np.array(b, dtype=float)\n    if A.shape[0] != A.shape[1]:\n        raise ValueError(\"Coefficient matrix A must be square.\")\n    \n    # Using NumPy to solve the linear system\n    return np.linalg.solve(A, b)"
        ],
        [
            "def simplify_expression(expression, var_name='x'):\n    \"\"\"\n    It receives a string representing an algebraic expression and return it simplified.\n       \n    Parameters:\n    expression (str): A string representing a algebraic expression.\n    var_name (str): A string representing the name of the variable.\n   \n    Returns:\n    Expr: Simplified expression.\n    Example:\n    simplify_expression(\"x**2 + 2*x + 1\")\n    \"\"\"\n    var = symbols(var_name)\n    return simplify(eval(expression))"
        ],
        [
            "def solve_equation(expr, var, solution_type='real'):\n    \"\"\"\n    Solves algebraic equations and returns solutions based on the type specified ('real', 'complex').\n    Parameters:\n        expr : sympy expression\n            The algebraic expression representing the equation set equal to zero.\n        var : sympy.Symbol\n            The variable to solve for in the expression.\n        solution_type : str\n            Type of solutions to return. Options are 'real' or 'complex'.\n    Returns:\n        list\n            A list of solutions that satisfy the equation. Filtered by real or complex as specified.\n    Examples:\n        >>> x = symbols('x')\n        >>> solve_equation(x**2 - 4, x)\n        [-2, 2]\n        >>> solve_equation(x**2 + 1, x, 'complex')\n        [-I, I]\n    \"\"\"\n    # General solution including complex numbers\n    solutions = solve(Eq(expr, 0), var)\n    if solution_type == 'real':\n        # Filter out only real solutions\n        real_solutions = [sol for sol in solutions if sol.is_real]\n        return real_solutions\n    elif solution_type == 'complex':\n        return solutions\n    else:\n        raise ValueError(\"Invalid solution type specified. Use 'real' or 'complex'.\")"
        ]
    ],
    "Inequalities": [
        [
            "def arithmetic_mean(values):\n    \"\"\"Calculate the arithmetic mean of a list or numpy array of values.\n    \n    Parameters:\n        values (list or np.array): The input numbers as a list or numpy array.\n    Returns:\n        float: The arithmetic mean of the values.\n    \n    Examples:\n        >>> arithmetic_mean([1, 2, 3, 4])\n        2.5\n    \"\"\"\n    return np.mean(values)",
            "def quadratic_mean(values):\n    \"\"\"Calculate the quadratic mean (or RMS) of a list or numpy array of values.\n    \n    Parameters:\n        values (list or np.array): The input numbers as a list or numpy array.\n    Returns:\n        float: The quadratic mean of the values.\n    \n    Examples:\n        >>> quadratic_mean([1, 2, 3, 4])\n        2.738613\n    \"\"\"\n    return np.sqrt(np.mean(np.square(values)))"
        ],
        [
            "def geometric_mean(values):\n    \"\"\"Calculate the geometric mean of a list or numpy array of values.\n    \n    Parameters:\n        values (list or np.array): Positive numbers as a list or numpy array.\n    Returns:\n        float: The geometric mean of the values.\n    \n    Examples:\n        >>> geometric_mean([1, 2, 3, 4])\n        2.213364\n    \"\"\"\n    return gmean(values)",
            "def harmonic_mean(values):\n    \"\"\"Calculate the harmonic mean of a list or numpy array of values.\n    \n    Parameters:\n        values (list or np.array): Positive numbers as a list or numpy array.\n    Returns:\n        float: The harmonic mean of the values.\n    \n    Examples:\n        >>> harmonic_mean([1, 2, 3, 4])\n        1.92\n    \"\"\"\n    return hmean(values)"
        ],
        [
            "def plot_inequality(expression, variable, range_lim=(-10, 10)):\n    \"\"\"\n    Plots the inequality on a number line to visualize the solution.\n    Parameters:\n    expression (str): The inequality in string format.\n    variable (str): The variable contained in the inequality.\n    range_lim (tuple): The x-axis range for the plot.\n    Example:\n    >>> plot_inequality(\"x**2 - 4 < 0\", 'x', range_lim=(-5, 5))\n    \"\"\"\n    x = sp.symbols(variable)\n    # Convert the string expression into a usable sympy expression.\n    expr = sp.sympify(expression)\n    \n    # Lambdify for numerical evaluation\n    f = sp.lambdify(x, expr, 'numpy')\n    \n    # Creating numerical data for the plot\n    sample = np.linspace(range_lim[0], range_tap[1], 400)\n    y = f(sample)\n    \n    # Plot the inequality\n    plt.figure(figsize=(10, 2))\n    plt.axhline(0, color='black', lw=1)\n    plt.plot(sample, y, label=f'{expression}')\n    # Highlighting the 0 line and solution range\n    plt.fill_between(sample, y, where=(y>0), interpolate=True, color='green', alpha=0.3)\n    plt.xlim(range_lim)\n    plt.ylim(min(y)-1, max(y)+1)\n    plt.legend()\n    plt.title('Inequality Visualization on a Number Line')\n    plt.xlabel(variable)\n    plt.show()",
            "def plot_inequality(expression, variable, range_lim=(-10, 10)):\n    \"\"\"\n    Plots the region of the 2D space that satisfies a two-variable inequality.\n    Parameters:\n        expression (str): The inequality expression involving two variables.\n        variable (tuple): The tuple of variables present in the expression.\n        range_lim (tuple): The range for which the variables will be considered.\n    Returns:\n        None: Plots the region satisfying the inequality.\n    Examples:\n        >>> plot_inequality('x**2 + y**2 <= 25', ('x', 'y'))\n    \"\"\"\n    x, y = sp.symbols(variable)\n    inequality_expr = sp.sympify(expression)\n    # Generate a grid of x and y values\n    x_vals = np.linspace(*range_lim, 400)\n    y_vals = np.linspace(*range_lim, 400)\n    X, Y = np.meshgrid(x_vals, y_vals)\n    # Convert sympy expression to a function that can operate on NumPy arrays\n    f = sp.lambdify((x, y), inequality_expr, 'numpy')\n    \n    # Evaluate the inequality on the grid\n    condition = f(X, Y)\n    # Plot the results\n    plt.figure(figsize=(6, 6))\n    plt.contourf(X, Y, condition, levels=1, cmap='spring')\n    plt.colorbar()\n    plt.xlabel(str(x))\n    plt.ylabel(str(y))\n    plt.title('Region Satisfying {}'.format(expression))\n    plt.grid(True)\n    plt.show()",
            "def plot_inequality(expression, variable_range):\n    \"\"\"\n    Plots a two-dimensional view of a single-variable inequality to visualize the solution space.\n    Parameters:\n        expression (str): The inequality expression in terms of 'x'.\n        variable_range (tuple): A tuple of the form (start, end) specifying the range of the variable.\n    Example:\n        >>> plot_inequality(\"x**2 - 4 < 0\", (-10, 10))\n    Returns:\n        None: This function plots directly to the matplotlib output.\n    \"\"\"\n    x = np.linspace(*variable_range, 400)\n    y = eval(expression.replace(\"<\", \"\").replace(\">\", \"\").replace(\"<=\", \"\").replace(\">=\", \"\"))\n    \n    inequality_sign = None\n    if '<' in expression:\n        inequality_sign = '<'\n    elif '>' in expression:\n        inequality_flag = '>'\n    \n    fig, ax = plt.subplots()\n    ax.plot(x, y, label='y=' + expression)\n    ax.axhline(0, color='black',linewidth=0.5)\n    ax.axvline(0, color='black',linewidth=0.5)\n    \n    mask = y > 0 if inequality_sign == '>' else y < 0\n    ax.fill_between(x, y, 0, where=mask, color='gray', alpha=0.5)\n    \n    plt.xlabel('x')\n    plt.ylabel('y')\n    plt.title('Plot of the inequality ' + expression)\n    plt.legend()\n    plt.grid(True)\n    plt.show()"
        ],
        [
            "def solve_inequality(expression, variable):\n    \"\"\"\n    Solves an algebraic inequality represented by an expression.\n    Parameters:\n    expression (str): A string representing the inequality to solve.\n    variable (str): The variable with respect to which the inequality will be solved.\n    Returns:\n    tuple: A solution set for the inequality.\n    \n    Examples:\n    >>> solve_inequality(\"x**2 - 5*x + 6 > 0\", 'x')\n    ((-oo, 2) U (3, oo))\n    >>> solve_inequality(\"x/3 - 2 <= 0\", 'x')\n    (-oo, 6]\n    \"\"\"\n    x = sp.symbols(variable)\n    inequality = sp.sympify(expression)\n    solution = sp.solveset(inequality, x, domain=sp.S.Reals)\n    return solution",
            "def solve_inequality(expression, variable):\n    \"\"\"\n    Solves polynomial and rational inequalities.\n    Parameters:\n        expression (str): The inequality expression as a string.\n        variable (str): The variable with respect to which the inequality is considered.\n    Returns:\n        set: The solution set of the inequality expressed in interval notation.\n    Examples:\n        >>> solve_inequality('x**2 - 5*x + 6 > 0', 'x')\n        ((-oo, 2) U (3, oo))\n        >>> solve_inequality('1/x < 0', 'x')\n        ((-oo, 0))\n    \"\"\"\n    x = sp.symbols(variable)\n    inequality_expr = sp.sympify(expression)\n    solution_set = sp.solveset(inequality_expr, x, domain=sp.S.Reals)\n    return solution_set",
            "def solve_quadratic_inequality(expression, variable):\n    \"\"\"\n    Solves quadratic inequalities and expresses solutions in interval notation.\n    Parameters:\n        expression (str): The quadratic inequality expression.\n        variable (str): The variable in the expression.\n    Returns:\n        set: Interval notation of the solution set.\n    Examples:\n        >>> solve_quadratic_inequality('x**2 - 4*x + 3 < 0', 'x')\n        (1, 3)\n    \"\"\"\n    x = sp.symbols(variable)\n    inequality_expr = sp.sympify(expression)\n    solution_set = sp.solveset(inequality_expr, x, domain=sp.S.Reals)\n    return solution_set",
            "def solve_quadratic_inequality(expression, variable=x):\n    \"\"\"\n    Solves quadratic inequalities.\n    Parameters:\n        expression (str): The inequality expression as a string.\n        variable (Symbol, optional): The variable used in the inequality. Defaults to sympy.abc.x.\n    Returns:\n        list: Intervals representing the solution of the inequality.\n    Examples:\n        >>> solve_quadratic_inequality(\"x**2 - 3*x + 2 > 0\")\n        [Interval.open(-oo, 1), Interval.open(2, oo)]\n        >>> solve_quadratic_inequality(\"x**2 + 2*x + 3 < 0\")\n        []\n    \"\"\"\n    expr = Poly(expression)\n    ineq_obj = expr.as_expr() > 0\n    solution_intervals = solve_poly_inequality(expr, '>')\n    return solution_intervals",
            "def solve_polynomial_inequality(expression, variable=x):\n    \"\"\"\n    Solves polynomial inequalities.\n    Parameters:\n        expression (str): The inequality expression as a string.\n        variable (Symbol, optional): The variable used in the inequality. Defaults to sympy.abc.x.\n    Returns:\n        list: Intervals representing the solution of the inequality.\n    Examples:\n        >>> solve_polynomial_inequality(\"x**3 - x**2 - x + 1 > 0\")\n        [Interval.open(-oo, -1), Interval.open(1, oo)]\n        >>> solve_polynomial_inequality(\"x**4 - 4*x**2 + 4 <= 0\")\n        [Interval.Ropen(-2, 2)]\n    \"\"\"\n    expr = Poly(expression)\n    ineq_obj = expr.as_expr() > 0\n    solution_intervals = solve_poly_inequality(expr, '>')\n    return solution_intervals",
            "def solve_rational_inequality(expression, variable=x):\n    \"\"\"\n    Solves rational inequalities which include polynomials in the numerator and denominator.\n    Parameters:\n        expression (str): The rational inequality expression.\n        variable (Symbol, optional): The variable used in the inequality. Defaults to sympy.abc.x.\n    Returns:\n        list: Intervals representing the solution of the inequality.\n    Example:\n        >>> solve_rational_inequality('(x**2-1)/(x**2+1) < 0')\n        [Interval.open(-1, 1)]\n        >>> solve_rational_inequality('(x-1)/(x+2) > 0')\n        [Interval.open(-oo, -2), Interval.open(1, oo)]\n    \"\"\"\n    # parsing the expression to sympy inequality\n    ineq = S(expression)\n    # solving rational inequality\n    solution_intervals = solve_univariate_inequality(ineq, x, relational=False)\n    return solution_intervals"
        ],
        [
            "class OptimalExpressionFinder:\n    \"\"\"\n    Class to find optimal (min or max) values of expressions using inequalities.\n    \"\"\"\n    @staticmethod\n    def min_expression_by_am_gm(values):\n        \"\"\"\n        Use AM-GM inequality to find the minimum value of an expression given that\n        the equality holds when all numbers are equal.\n        \"\"\"\n        # By AM-GM, we know AM >= GM and the minimum value attained when all values are equal\n        equal_value = InequalitySolver.am(values)\n        return equal_value * len(values)  # all values are equal in the minimum case\n    @staticmethod\n    def minimize_expression(expression, variables, constraints=[]):\n        \"\"\"\n        Minimize an algebraic expression using constraints using symbolic computation.\n        \"\"\"\n        x = symbols(variables)\n        solution = solve([expression] + constraints, x)\n        return solution"
        ],
        [
            "def apply_am_gm_inequality(nums):\n    \"\"\"\n    Applies the Arithmetic Mean - Geometric Mean Inequality to a list of numbers.\n    Parameters\n    ----------\n    nums : list or array-like\n        The list of non-negative numbers to apply the AM-GM inequality.\n    Returns\n    -------\n    tuple\n        Returns a tuple containing the Arithmetic Mean, the Geometric Mean, and the boolean check if AM = GM (equality case).\n    Examples\n    --------\n    >>> apply_am_gm_inequality([4, 1, 1, 4])\n    (2.5, 2.0, False)\n    \"\"\"\n    if not all(x >= 0 for x in nums):\n        raise ValueError(\"All elements must be non-negative for AM-GM inequality.\")\n    n = len(nums)\n    arithmetic_mean = np.mean(nums)\n    geometric_mean = np.prod(np.power(nums, 1/n))\n    # Equality holds if all numbers are the same\n    is_equal = np.isclose(arithmetic_mean, geometric_mean)\n    return (arithmetic_mean, geometric_mean, is_equal)",
            "def apply_am_hm_inequality(nums):\n    \"\"\"\n    Applies the Arithmetic Mean - Harmonic Mean Inequality to a list of positive numbers.\n    Parameters\n    ----------\n    nums : list or array-like\n        The list of positive numbers to apply the AM-HM inequality.\n    Returns\n    -------\n    tuple\n        Returns a tuple containing the Arithmetic Mean, the Harmonic Mean, and the boolean check if AM = HM (equality case).\n    Examples\n    --------\n    >>> apply_am_hm_inequality([4, 4, 4, 4])\n    (4.0, 4.0, True)\n    \"\"\"\n    if not all(x > 0 for x in nums):\n        raise ValueError(\"All elements must be positive for AM-HM inequality.\")\n    n = len(nums)\n    arithmetic_mean = np.mean(nums)\n    harmonic_mean = n / np.sum(1.0/x for x in nums)\n    # Equality holds if all numbers are the same\n    is_equal = np.isclose(arithmetic_mean, harmonic_mean)\n    return (arithmetic_mean, harmonic_mean, is_equal)"
        ],
        [
            "class InequalitySolver:\n    \"\"\"\n    A class that provides various methods to evaluate and work with famous inequalities:\n    Arithmetic Mean-Geometric Mean (AM-GM), Quadratic Mean-Arithmetic Mean (QM-AM),\n    Arithmetic Mean-Harmonic Mean (AM-HM), Cauchy-Schwarz, and triangle inequality.\n    \"\"\"\n    @staticmethod\n    def am(values):\n        \"\"\"Calculate the Arithmetic Mean of the values.\"\"\"\n        return np.mean(values)\n    @staticmethod\n    def gm(values):\n        \"\"\"Calculate the Geometric Mean of the values.\"\"\"\n        return np.prod(values)**(1/len(values))\n    @staticmethod\n    def qm(values):\n        \"\"\"Calculate the Quadratic Mean of the values.\"\"\"\n        return sqrt(np.mean(np.square(values)))\n    @staticmethod\n    def hm(values):\n        \"\"\"Calculate the Harmonic Mean of the values.\"\"\"\n        return len(values) / np.sum(1/np.array(values))\n    def check_am_gm_inequality(self, values):\n        \"\"\"\n        Verify if the AM-GM inequality holds for a set of values.\n        AM >= GM. Equality if all numbers are the same.\n        \"\"\"\n        am_val = self.am(values)\n        gm_val = self.gm(values)\n        is_equal = np.isclose(am_val, gm_val)\n        return {'inequality': am_val >= gm_cval, 'equality': is_equal}\n    def check_qm_am_inequality(self, values):\n        \"\"\"\n        Verify if the QM-AM inequality holds for a set of values.\n        QM >= AM. Equality if all numbers are the same.\n        \"\"\"\n        qm_val = self.qm(values)\n        am_val = self.am(values)\n        is_equal = np.isclose(qm_val, am_val)\n        return {'inequality': qm_val >= am_cval, 'equality': is_equal}\n    def check_am_hm_inequality(self, values):\n        \"\"\"\n        Verify if the AM-HM inequality holds for a set of values.\n        AM >= HM. Equality if all numbers are the same.\n        \"\"\"\n        am_val = self.am(values)\n        hm_val = self.hm(values)\n        is_equal = np.isclose(am_val, hm_val)\n        return {'inequality': am_val >= hm_val, 'equality': is_equal}\n    @staticmethod\n    def check_cauchy_schwarz(v1, v2):\n        \"\"\"\n        Verify the Cauchy-Schwarz inequality for two vectors.\n        \"\"\"\n        left_side = np.dot(v1, v2)**2\n        right_side = np.dot(v1, v1) * np.dot(v2, v2)\n        return left_side <= right_side\n    @staticmethod\n    def triangle_inequality(a, b, c):\n        \"\"\"\n        Check the triangle inequality theorem which states that the sum of the lengths\n        of any two sides of a triangle must be greater than or equal to the length of the\n        third side.\n        \"\"\"\n        return (a + b >= c) and (a + c >= b) and (b + c >= a)"
        ],
        [
            "def translate_to_inequality(conditions):\n    \"\"\"\n    Translates real-world or word problem conditions into a mathematical inequality.\n    Parameters:\n    conditions (str): Natural language description of the problem conditions.\n    Returns:\n    str: Algebraic inequality as a string based on the input conditions.\n    \n    Note:\n    This tool is illustrative and simplistic. Practical usage in real-world scenarios often requires domain-specific customization.\n    \n    Examples:\n    >>> translate_to_inequality(\"John has more apples than twice the amount of apples his sister has.\")\n    'John > 2 * Sister'\n    \"\"\"\n    # An example, in practical use cases, you might want to use NLP techniques.\n    import re\n    # Mock-up translations for demonstration--would need much more sophisticated logic or ML models.\n    tokens = conditions.lower().split()\n    variable_mapping = {\n        'less': '<',\n        'greater': '>',\n        'at least': '>=',\n        'at most': '<=',\n        'equals': '==',\n    }\n    # Find tokens that likely represent variables or numbers and map.\n    expr = ''\n    for token in tokens:\n        if token in variable_mapping:\n            expr += ' ' + variable_mapping[token] + ' '\n        elif re.match(r'\\d+', token):  # Directly matches digits\n            expr += ' ' + token + ' '\n        else:\n            expr += ' ' + token.capitalize() + ' '\n    return expr.strip()"
        ],
        [
            "def check_am_gm_inequality(values):\n    \"\"\"Check Arithmetic Mean - Geometric Mean Inequality for given values.\n    \n    Parameters:\n        values (list or np.array): Positive numbers to evaluate AM-GM inequality.\n    Returns:\n        bool: True if AM >= GM holds, False otherwise.\n        bool: True if equality holds (AM == GM), False otherwise.\n    \n    Examples:\n        >>> check_am_gm_inequality([1, 1, 1])\n        (True, True)  # AM = GM = 1\n        >>> check_am_gm_inequality([1, 2, 1])\n        (True, False) # AM > GM\n    \"\"\"\n    am = arithmetic_mean(values)\n    gm = geometric_mean(values)\n    return (am >= gm, np.isclose(am, gm))"
        ]
    ],
    "Polynomials": [
        [
            "def find_roots(polynomial):\n    \"\"\"\n    Find the roots (zeros) of a polynomial.\n    \n    Parameters:\n    -----------\n    polynomial: numpy.poly1d\n        A polynomial object.\n        \n    Returns:\n    --------\n    roots: numpy.ndarray\n        An array of roots of the polynomial.\n    \n    Example:\n    --------\n    >>> p = create_polynomial([1, 0, -2])\n    >>> find_roots(p)\n    array([-1.41421356, 1.41421356])\n    \"\"\"\n    return polynomial.roots",
            "def polynomial_roots(poly):\n    \"\"\"\n    Find the roots of a polynomial.\n    Parameters:\n    - poly (numpy.poly1d): Polynomial object.\n    Returns:\n    - numpy.ndarray: Array of roots.\n    Example:\n    >>> p = create_polynomial([1, 0, -4])\n    >>> polynomial_roots(p)\n    array([ 2., -2.])\n    \"\"\"\n    return poly.roots()",
            "def polynomial_from_roots(roots):\n    \"\"\"\n    Create a polynomial object given its roots.\n    Parameters:\n    - roots (list of numbers): Roots of the polynomial.\n    Returns:\n    - numpy.poly1d: Polynomial having the given roots.\n    Example:\n    >>> polynomial_from_roots([1, -1, 2])\n    numpy.poly1d([ 1. -2. -3.  2.])\n    \"\"\"\n    return np.poly1d(np.poly(roots))"
        ],
        [
            "def create_polynomial(coefficients):\n    \"\"\"\n    Create a polynomial from a list of coefficients.\n    \n    Parameters:\n    -----------\n    coefficients: list of numbers\n        Coefficients of the polynomial, where each index represents the coefficient of x^index.\n        \n    Returns:\n    --------\n    polynomial: numpy.poly1d\n        A polynomial object which can be used for further computations.\n    \n    Example:\n    --------\n    >>> p = create_polynomial([1, 0, -2])\n    >>> print(p)  # represents x^2 - 2\n    \"\"\"\n    return np.poly1d(coefficients[::-1])",
            "def create_polynomial(coeffs):\n    \"\"\"\n    Create a polynomial object from coefficients.\n    Parameters:\n    - coeffs (list of numbers): Coefficients of the polynomial, where the i-th element corresponds to the coefficient of x^i.\n    Returns:\n    - numpy.poly1d: A polynomial object.\n    \n    Example:\n    >>> create_polynomial([1, 0, 3])\n    numpy.poly1d([1, 0, 3])\n    \"\"\"\n    return np.poly1d(coeffs[::-1])"
        ],
        [
            "def construct_polynomial(roots):\n    \"\"\"\n    Constructs a polynomial given its roots.\n    \n    Parameters:\n        roots (list): List of roots of the polynomial.\n        \n    Returns:\n        Poly: Polynomial constructed from the roots.\n    \n    Examples:\n        >>> construct_polynomial([1, 2, 3])\n        Poly(x**3 - 6*x**2 + 11*x - 6, x, domain='ZZ')\n    \"\"\"\n    x = symbols('x')\n    polynomial = x - roots[0]\n    for root in roots[1:]:\n        polynomial *= (x - root)\n    return Poly(polynomial, x)",
            "def construct_polynomial_from_roots(roots):\n    \"\"\"\n    Constructs a polynomial given its roots.\n    Parameters:\n    - roots (list or tuple): Roots of the polynomial.\n    Returns:\n    - polynomial (sympy.Poly): Monic polynomial having these roots.\n    \n    Examples:\n    >>> construct_polynomial_from_roots([1, 2]).as_expr()\n    x**2 - 3*x + 2\n    \"\"\"\n    expr = sympy.prod([x - r for r in roots])\n    return sympy.simplify(expr)"
        ],
        [
            "def factor_polynomial(expr):\n    \"\"\"\n    Factor a polynomial expression.\n    Parameters:\n    - expr (string): A string expression representing the polynomial, e.g., 'x**2 - 4'.\n    Returns:\n    - sympy.Expr: The factored form of the polynomial.\n    Example:\n    >>> factor_polynomial('x**2 - 4')\n    (x - 2)*(x + 2)\n    \"\"\"\n    x = sp.symbols('x')\n    polynomial = sp.sympify(expr)\n    return sp.factor(polynomial)",
            "def simplify_polynomial(expr):\n    \"\"\"\n    Simplify a polynomial expression.\n    Parameters:\n    - expr (string): A string expression representing the polynomial.\n    Returns:\n    - sympy.Expr: The simplified form of the polynomial.\n    Example:\n    >>> simplify_polynomial('(x**2 - 1)/(x - 1)')\n    x + 1\n    \"\"\"\n    x = sp.symbols('x')\n    polynomial = sp.sympify(expr)\n    return sp.simplify(polynomial)"
        ],
        [
            "def evaluate_polynomial(polynomial, x):\n    \"\"\"\n    Evaluate a polynomial at a specific value of x.\n    \n    Parameters:\n    -----------\n    polynomial: numpy.poly1d\n        A polynomial object.\n    x: number\n        The point at which to evaluate the polynomial.\n        \n    Returns:\n    --------\n    result: number\n        The result of the polynomial evaluation at x.\n    \n    Example:\n    --------\n    >>> p = create_polynomial([1, 0, -2])\n    >>> evaluate_polynomial(p, 3)  # p(3) = 3^2 - 2 = 7\n    7\n    \"\"\"\n    return polynomial(x)",
            "def evaluate_polynomial(poly, x):\n    \"\"\"\n    Evaluate a polynomial at a given value.\n    Parameters:\n    - poly (numpy.poly1d): Polynomial object.\n    - x (number): Point at which to evaluate the polynomial.\n    Returns:\n    - number: The result of the polynomial evaluation at x.\n    Example:\n    >>> p = create_polynomial([1, 0, 3])\n    >>> evaluate_polynomial(p, 2)\n    13\n    \"\"\"\n    return poly(x)"
        ],
        [
            "def polynomial_roots(coefficients):\n    \"\"\"\n    Given the coefficients of a polynomial, this function calculates its roots.\n    \n    Parameters:\n        coefficients (list): List of coefficients from highest degree to constant term.\n        \n    Returns:\n        list: Roots of the polynomial.\n    \n    Examples:\n        >>> polynomial_roots([1, -3, 2])\n        [1, 2]  # Roots of x^2 - 3x + 2 = 0\n    \"\"\"\n    x = symbols('x')\n    polynomial = sum(c * x**i for i, c in enumerate(reversed(coefficients)))\n    roots = solve(polynomial, x)\n    return roots",
            "def polynomial_roots(coefficients):\n    \"\"\"\n    Finds the roots of a polynomial with given coefficients.\n    Parameters:\n    - coefficients (list or tuple of numbers): Coefficients of the polynomial from highest degree to constant term.\n    Returns:\n    - roots (list of numbers): The roots (solutions) of the polynomial equation.\n    \n    Examples:\n    >>> polynomial_roots([1, -3, 2])\n    [2, 1]\n    \"\"\"\n    polynomial = np.poly1d(coefficients)\n    roots = np.roots(polynomial)\n    roots[np.isclose(roots.imag, 0)] = roots.real[np.isclose(roots.imag, 0)]  # Filter pure real roots\n    return sorted(roots)"
        ],
        [
            "def sum_and_product_roots(coefficients):\n    \"\"\"\n    Calculate the sum and product of roots using Vieta's formulas based on the given coefficients of a polynomial.\n    \n    Parameters:\n        coefficients (list): Coefficients of the polynomial [an, an-1, ..., a0]\n        \n    Returns:\n        tuple: (sum_of_roots, product_of_roots)\n        \n    Examples:\n        >>> sum_and_product_roots([1, -5, 6])  # For polynomial x^2 - 5x + 6 = 0\n        (5, 6)\n    \"\"\"\n    n = len(coefficients) - 1  # Degree of the polynomial\n    sum_of_roots = -coefficients[1] / coefficients[0] if coefficients[0] != 0 else float('inf')\n    product_of_roots = (-1)**n * coefficients[-1] / coefficients[0] if coefficients[0] != 0 else float('inf')\n    return (sum_of_roots, product_of_roots)",
            "def polynomial_roots_coefficients(polynomial_expr):\n    \"\"\"\n    Analyze a polynomial's roots and coefficients, and compute relationships via Vieta's formulas.\n    Parameters:\n    - polynomial_expr (str): The polynomial expression as a string, e.g., 'x**2 - 5*x + 6'.\n    Returns:\n    - dict: A dictionary containing:\n        'roots': A list of roots of the polynomial.\n        'coefficients': Coefficients of the polynomial.\n        'sum_of_roots': Sum of the roots of the polynomial, derived from Vieta's formula.\n        'product_of_roots': Product of the roots, derived from Vieta's formula.\n    Example:\n    >>> polynomial_roots_coefficients('x**2 - 3*x + 2')\n    {\n        'roots': [1, 2],\n        'coefficients': [1, -3, 2],\n        'sum_of_roots': 3,\n        'product_of_roots': 2\n    }\n    \"\"\"\n    x = symbols('x')\n    polynomial = Poly(polynomial_expr, x)\n    roots = solve(polynomial, x)\n    coefficients = polynomial.coeffs()\n    sum_of_roots = -coefficients[1] / coefficients[0]  # For monic quadratic: -b/a\n    product_of_roots = coefficients[-1] / coefficients[0] if len(roots) > 0 else None  # For monic quadratic: c/a\n    return {\n        'roots': roots,\n        'coefficients': coefficients,\n        'sum_of_roots': sum_of_roots,\n        'product_of_roots': product_of_roots\n    }",
            "def vietas_formulas(coefficients):\n    \"\"\"\n    Uses Vieta's formulas to relate the roots and coefficients of a polynomial.\n    Parameters:\n    - coefficients (list or tuple): Coefficients of the polynomial from highest degree to constant term.\n    Returns:\n    - relations (dict): Dictionary of relations, including sum and product of roots.\n    \n    Examples:\n    >>> vietas_formulas([1, -3, 2])\n    {'sum_of_roots': 3, 'product_of_roots': 2}\n    \"\"\"\n    roots = polynomial_roots(coefficients)\n    sum_of_roots = -coefficients[1] / coefficients[0]  # For a polynomial ax^2 + bx + c, sum of roots = -b/a\n    product_of_roots = coefficients[-1] / coefficients[0]\n    if len(coefficients) - 1 != len(roots):\n        product_of_roots *= (-1)**len(roots)\n    return {'sum_of_roots': sum_of_roots, 'product_of_roots': product_of_roots}"
        ],
        [
            "def roots_of_polynomial(expr):\n    \"\"\"\n    Find roots of a polynomial expression.\n    Parameters:\n    - expr (string): Polynomial expression.\n    Returns:\n    - list: Roots of the polynomial.\n    Example:\n    >>> roots_of_polynomial('x**2 - 4')\n    [2, -2]\n    \"\"\"\n    x = sp.symbols('x')\n    polynomial = sp.sympify(expr)\n    return sp.solvers.solve(polynomial, x)"
        ],
        [
            "def integrate_polynomial(poly):\n    \"\"\"\n    Compute the indefinite integral of a polynomial.\n    Parameters:\n    - poly (numpy.poly1d): Polynomial object.\n    Returns:\n    - numpy.poly1d: The integral of the polynomial with a constant of integration set to 0.\n    Example:\n    >>> p = create_polynomial([2, 0, 1])\n    >>> integrate_polynomial(p)\n    numpy.poly1d([ 0.66666667, 0. , 2. , 0. ])\n    \"\"\"\n    return np.poly1d(poly.integ())"
        ],
        [
            "def derivative_polynomial(poly):\n    \"\"\"\n    Compute the derivative of a polynomial.\n    Parameters:\n    - poly (numpy.poly1d): Polynomial object.\n    Returns:\n    - numpy.poly1d: The derivative of the polynomial.\n    Example:\n    >>> p = create_pollynomial([1, 2, 3])\n    >>> derivative_polynomial(p)\n    numpy.poly1d([2, 2])\n    \"\"\"\n    return np.poly1d(poly.deriv())"
        ],
        [
            "def difference_of_squares(a, b):\n    \"\"\"\n    Applies the difference of squares identity to (a^2 - b^2).\n    Parameters:\n    - a, b: Expressions or values.\n    Returns:\n    - Expression: Factored form of the expression using the difference of squares.\n    \"\"\"\n    return simplify((a + b)*(a - b))"
        ],
        [
            "def apply_binomial_theorem(a, b, n):\n    \"\"\"\n    Applies the binomial theorem to expand (a + b)^n.\n    Parameters:\n    - a, b: Expressions or values for the binomial terms.\n    - n (int): The exponent to which the binomial is raised.\n    Returns:\n    - Expression: Expanded form of the binomial.\n    \"\"\"\n    x, y = symbols('x y')\n    binomial_expr = (a*x + b*y)**n\n    return expand(binomial_expr).subs({x: 1, y: 1})"
        ],
        [
            "def add_polynomials(p1, p2):\n    \"\"\"\n    Add two polynomials.\n    \n    Parameters:\n    -----------\n    p1, p2: numpy.poly1d\n        Polynomial objects to be added.\n        \n    Returns:\n    --------\n    sum_polynomial: numpy.poly1d\n        The sum of p1 and p2.\n    \n    Example:\n    --------\n    >>> p1 = create_polynomial([1, 0, -2])\n    >>> p2 = create_polynomial([0, 1])\n    >>> add_polynomials(p1, p2)  # x^2 + x - 2\n    \"\"\"\n    return np.poly1d(np.polyadd(p1, p2))\n    p = create_polynomial([1, 0, -2])\n    print(\"Polynomial:\", p)\n    print(\"Evaluated at x=3:\", evaluate_polynomial(p, 3))\n    print(\"Roots:\", find_roots(p))\n    q = create_polynomial([0, 1])\n    print(\"Sum of polynomials:\", add_polynomials(p, q))",
            "def add_polynomials(poly1, poly2):\n    \"\"\"\n    Add two polynomials.\n    Parameters:\n    - poly1, poly2 (numpy.poly1d): Polynomial objects.\n    Returns:\n    - numpy.poly1d: The polynomial resulting from the addition.\n    Example:\n    >>> p1 = create_polynomial([1, 2])\n    >>> p2 = create_polynomial([9, 1])\n    >>> add_polynomials(p1, p2)\n    numpy.poly1d([10, 3])\n    \"\"\"\n    return np.poly1d(poly1) + np.poly1d(poly2)",
            "def multiply_polynomials(poly1, poly2):\n    \"\"\"\n    Multiply two polynomials.\n    Parameters:\n    - poly1, poly2 (numpy.poly1d): Polynomial objects.\n    Returns:\n    - numpy.poly1d: The polynomial resulting from the multiplication.\n    Example:\n    >>> p1 = create_polynomial([1, 2])\n    >>> p2 = create_polynomial([3, 4])\n    >>> multiply_polynomials(p1, p2)\n    numpy.poly1d([3, 10, 8])\n    \"\"\"\n    return np.poly1d(poly1) * np.poly1d(poly2)"
        ],
        [
            "def factorize_polynomial(poly):\n    \"\"\"\n    Factorizes a polynomial into irreducible factors over the rational numbers.\n    Parameters:\n    - poly (sympy.Poly): Polynomial to be factorized.\n    Returns:\n    - Expression: Factorized form of the polynomial.\n    \"\"\"\n    return factor(poly)"
        ],
        [
            "def build_evaluate_polynomial(roots, evaluate_at=None):\n    \"\"\"\n    Build a polynomial from given roots and optionally evaluate it at a specific point.\n    Parameters:\n    - roots (list): List of roots from which to construct the polynomial.\n    - evaluate_at (optional, int/float): A point at which the polynomial should be evaluated.\n    Returns:\n    - dict: A dictionary containing:\n        'polynomial': The polynomial expression constructed from the roots.\n        'evaluated_value': The evaluated value at the specified point, if `evaluate_at` is not None.\n    Example:\n    >>> build_evaluate_polynomial([1, 2, 3], evaluate_at=2)\n    {\n        'polynomial': x**3 - 6*x**2 + 11*x - 6,\n        'evaluated_value': 2\n    }\n    \"\"\"\n    x = symbols('x')\n    # Construct the polynomial by forming (x - root) for each root and taking their product\n    polynomial = prod([(x - root) for root in roots])\n    evaluated_value = polynomial.subs(x, evaluateat) if evaluate_at is not None else None\n    return {\n        'polynomial': polynomial,\n        'evaluated_value': evaluated_value\n    }"
        ],
        [
            "def create_polynomial(coeff_list, var='x'):\n    \"\"\"\n    Creates and returns a polynomial in the given variable from a list of coefficients.\n    \n    Parameters:\n    - coeff_list (list): List of coefficients in decreasing order of power.\n    - var (str): Variable used for the polynomial (default 'x').\n    Returns:\n    - sympy.Poly: Polynomial object.\n    \"\"\"\n    x = symbols(var)\n    return Poly(coeff_list, x)"
        ],
        [
            "def evaluate_polynomial(coefficients, value):\n    \"\"\"\n    Evaluates a polynomial at a specific point.\n    Parameters:\n    - coefficients (list or tuple): Coefficients of the polynomial\n    - value (number): The point at which the polynomial is to be evaluated.\n    Returns:\n    - result (number): Result of the polynomial evaluation at the specified point.\n    \n    Examples:\n    >>> evaluate_polynomial([1, -3, 2], 0)\n    2\n    \"\"\"\n    polynomial = np.poly1d(coefficients)\n    return polynomial(value)"
        ],
        [
            "def factor_polynomial(coefficients):\n    \"\"\"\n    Factorizes a polynomial given its coefficients.\n    \n    Parameters:\n        coefficients (list): List of coefficients from highest degree to the constant term.\n        \n    Returns:\n        Expr: Factored polynomial expression.\n    \n    Examples:\n        >>> factor_polynomial([1, -3, 2])\n        (x - 1)*(x - 2)\n    \"\"\"\n    x = symbols('x')\n    polynomial = sum(c * x**i for i, c in enumerate(reversed(coefficients)))\n    return factor(polynomial)"
        ],
        [
            "def find_polynomial_roots(poly):\n    \"\"\"\n    Finds all roots (real and complex) of a polynomial.\n    Parameters:\n    - poly (sympy.Poly): Polynomial whose roots are sought.\n    Returns:\n    - list: List of polynomial roots.\n    \"\"\"\n    return solve(poly, dict=True)"
        ],
        [
            "def polynomial_arithmetic(poly1, poly2, operation):\n    \"\"\"\n    Performs arithmetic operations (addition, subtraction, multiplication, division) between two polynomials.\n    Parameters:\n    - poly1, poly2 (sympy.Poly): Polynomials to be operated on.\n    - operation (str): Type of operation ('add', 'sub', 'mul', 'div').\n    Returns:\n    - sympy.Poly or tuple of (quotient, remainder): Result of the operation.\n    \"\"\"\n    if operation == 'add':\n        return poly1 + poly2\n    elif operation == 'sub':\n        return poly1 - poly2\n    elif operation == 'mul':\n        return expand(poly1 * poly2)\n    elif operation == 'div':\n        return div(poly1, poly2)\n    else:\n        raise ValueError(\"Unknown operation. Please use 'add', 'sub', 'mul', or 'div'.\")"
        ],
        [
            "def sum_and_difference_of_cubes(a, b):\n    \"\"\"\n    Provides factorization for sum and difference of cubes.\n    Parameters:\n    - a, b: Expressions or values.\n    Returns:\n    - tuple: (Sum of cubes factorization, Difference of cubes factorization)\n    \"\"\"\n    sum_cubes = simplify((a + b)*(a**2 - a*b + b**2))\n    diff_cubes = simplify((a - b)*(a**2 + a*b + b**2))\n    return (sum_cubes, diff_cubes)"
        ],
        [
            "def evaluate_polynomial(poly, value):\n    \"\"\"\n    Evaluates a polynomial at a given value or expression.\n    Parameters:\n    - poly (sympy.Poly): Polynomial to be evaluated.\n    - value: A value or symbolic expression where the polynomial is evaluated.\n    Returns:\n    - Expression: Result of the polynomial evaluation.\n    \"\"\"\n    return poly.subs(poly.gen, value)"
        ]
    ],
    "Solving Equations": [
        [
            "def simplify_expression(expr):\n    \"\"\"\n    Function to simplify an algebraic expression.\n    \n    Parameters\n    ----------\n    expr : str\n        Algebraic expression represented as a string. This expr should be a valid sympy expression.\n    Returns\n    -------\n    str\n        Simplified expression as a string.\n    Example\n    --------\n    >>> simplify_expression('x**2 + 2*x + 1')\n    'x**2 + 2*x + 1'\n    \"\"\"\n    from sympy import simplify\n    return str(simplify(expr))",
            "def simplify_expression(expression):\n    \"\"\"\n    Simplifies an algebraic expression.\n    Parameters:\n    - expression: str\n        The algebraic expression to simplify.\n    Returns:\n    - str\n        The simplified form of the algebraic expression.\n    Examples:\n    >>> simplify_expression('x**2 + 2*x + 1')\n    '(x + 1)**2'\n    >>> simplify_expression('x*x - 2*x + 1')\n    'x**2 - 2*x + 1'\n    \"\"\"\n    return str(sympify(expression).simplify())"
        ],
        [
            "def equation_from_word_problem(problem_description):\n    \"\"\"\n    Generates and solves an equation from a word problem description.\n    Note: This is a simplified placeholder function. Real implementation would require natural language processing.\n    \n    Parameters:\n        problem_description (str): Description of the problem.\n    \n    Returns:\n        equation (str): Generated algebraic equation.\n    \n    Examples:\n        >>> equation_from_word_problem('John has twice as many apples as Tom, and together they have 30 apples.')\n        '2*x + x = 30'\n    \"\"\"\n    # This part would involve NLP in a real-world scenario. Simplified version here:\n    # Assuming a fixed pattern for simplicity.\n    return '2*x + x = 30'  # Placeholder equation",
            "def solve_word_problem(description):\n    \"\"\"\n    Solves a word problem by first converting it to an equation and then solving it.\n    \n    Parameters:\n        description (str): The word problem description.\n    \n    Returns:\n        solution (list or dict): The solution to the problem, depending on the complexity.\n    \n    Examples:\n        >>> solve_word_problem('John has twice as many apples as Tom, and together they have 30 apples.')\n        [10, 20]  # Tom has 10, John has 20\n    \"\"\"\n    equation = equation_from phm_description(description)\n    # For the purpose of the demo assuming variables and setup\n    vars = ['x', 'y']  # Hypothetical variable identification\n    sol = solve_system_of_equations([equation], vars)\n    return sol"
        ],
        [
            "def solve_quadratic_equation(a, b, c, variable='x'):\n    \"\"\"\n    Solves a quadratic equation ax^2 + bx + c = 0.\n    \n    Parameters:\n        a (int, float): Coefficient of x^2\n        b (int, float): Coefficient of x\n        c (int, float): Constant term\n        variable (str): The variable to solve for, default is 'x'.\n        \n    Returns:\n        sol (list): List containing the roots of the quadratic equation.\n        \n    Examples:\n        >>> solve_quadratic_equation(1, -3, 2)\n        [2, 1]\n    \"\"\"\n    var = sp.symbols(variable)\n    equation = a*var**2 + b*var + c\n    sol = sp.solve(equation, var)\n    return sol",
            "def solve_quadratic_equation(coeff_a, coeff_b, coeff_c):\n    \"\"\"\n    Solve a quadratic equation of the form ax^2 + bx + c = 0.\n    Parameters:\n    - coeff_a (int/float): Coefficient of x^2\n    - coeff_b (int/float): Coefficient of x\n    - coeff_c (int/float): Constant term\n    Returns:\n    - solutions (tuple): A tuple of solutions, which can be real or complex numbers.\n    Examples:\n    >>> solve_quadratic_equation(1, -3, 2)\n    (2, 1)\n    \"\"\"\n    x = sp.symbols('x')\n    eq = coeff_a*x**2 + coeff_b*x + coeff_c\n    solutions = sp.solve(eq, x)\n    \n    return tuple(solutions)",
            "def solve_quadratic_equation(a, b, c):\n    \"\"\"\n    Solves a quadratic equation of the form ax^2 + bx + c = 0\n    Parameters\n    ----------\n    a : float\n        Coefficient of x^2.\n    b : float\n        Coefficient of x.\n    c : float\n        Constant term.\n    Returns\n    -------\n    dict\n        A dictionary containing the possible solutions: {'x1': value1, 'x2': value2}.\n    Examples\n    --------\n    >>> solve_quadratic_equation(1, -3, 2)\n    {'x1': 2, 'x2': 1}\n    \"\"\"\n    x = sp.symbols('x')\n    quadratic_eq = a * x**2 + b * x + c\n    solutions = sp.solve(quadratic_eq, x)\n    if len(solutions) == 2:\n        return {'x1': solutions[0], 'x2': solutions[1]}\n    elif len(solutions) == 1:\n        return {'x1': solutions[0], 'x2': None}\n    else:\n        return {'x1': None, 'x2': None}"
        ],
        [
            "def factorize_expression(expression: str) -> str:\n    \"\"\"\n    Factorizes an algebraic expression.\n    \n    Parameters\n    ----------\n    expression : str\n        The algebraic expression to factorize.\n    \n    Returns\n    -------\n    str\n        The factorized form of the expression.\n        \n    Examples\n    --------\n    >>> factorize_expression(\"x**2 - 4\")\n    '(x - 2)*(x + 2)'\n    \"\"\"\n    expr = sp.sympify(expression)\n    factorized_expr = sp.factor(expr)\n    return str(factorized_expr)",
            "def factorize_expression(expression, variable):\n    \"\"\"\n    Factorizes an algebraic expression.\n    Parameters:\n    - expression: str\n        The algebraic expression to factorize.\n    - variable: str\n        The primary variable in the expression to focus factorization on.\n    Returns:\n    - str\n        The factorized form of the expression, or the same expression if it cannot be factored.\n    Examples:\n    >>> factorize_expression('x**2 - 5*x + 6', 'x')\n    '(x - 2)*(x - 3)'\n    >>> factorize_expression('x**2 + 2*x + 1', 'x')\n    '(x + 1)**2'\n    \"\"\"\n    var = symbols(variable)\n    return str(factor(expression, var))"
        ],
        [
            "def solve_system_of_equations(equations, variables):\n    \"\"\"\n    Solves a system of linear equations.\n    \n    Parameters:\n        equations (list): List of equations in string format.\n        variables (list): List of variables to solve for.\n    \n    Returns:\n        sol (dict): Solutions in a dictionary mapping variables to their values.\n    \n    Examples:\n        >>> solve_system_of_equations(['x + 2*y = 0', 'x - y = 2'], ['x', 'y'])\n        {x: -2, y: -1}\n    \"\"\"\n    vars = sp.symbols(variables)\n    equ = [sp.sympify(e) for e in equations]\n    sol = sp.solve(equ, vars)\n    return sol",
            "def solve_system_of_equations(equations: list, variables: list) -> dict:\n    \"\"\"\n    Solves a system of linear equations for the specified variables.\n    \n    Parameters\n    ----------\n    equations : list of str\n        The system of equations to solve, as strings.\n    variables : list of str\n        The variables to solve for, as strings.\n    Returns\n    -------\n    dict\n        A dictionary with the solution variables as keys and their solutions as values.\n        \n    Examples\n    --------\n    >>> solve_system_of_equations([\"x + y = 2\", \"x - y = 0\"], [\"x\", \"y\"])\n    {'x': 1, 'y': 1}\n    \"\"\"\n    vars_symbols = sp.symbols(variables)\n    eqs = [sp.sympify(eq) for eq in equations]\n    solutions = sp.solve(eqs, vars_symbols)\n    return {str(var): solutions[var] if var in solutions else None for var in vars_symbols}",
            "def solve_system_of_equations(eqs):\n    \"\"\"\n    Function to solve system of linear equations.\n    \n    Parameters\n    ----------\n    eqs : list\n        List of algebraic equations represented as strings. Each equation should be a valid sympy equation.\n    Returns\n    -------\n    dict\n        A dictionary where keys are the variables and values are the solutions for those variables.\n    Example\n    --------\n    >>> solve_system_of_equations(['x + y = 10', 'x - y = 2'])\n    {x: 6, y: 4}\n    \"\"\"\n    from sympy import symbols, Eq, solve\n    x, y = symbols('x y')\n    eq1, eq2 = [Eq(*map(eval, eq.split(\"=\"))) for eq in eqs] \n    sol = solve((eq1, eq2), (x, y))\n    return sol"
        ],
        [
            "def evaluate_expression(expr, x_val):\n    \"\"\"\n    Function to evaluate an algebraic expression.\n    \n    Parameters\n    ----------\n    expr : str\n        Algebraic expression represented as a string. This expr should be a valid sympy expression.\n    x_val : int or float or complex\n        A value to substitute for 'x' in the expression expr\n    Returns\n    -------\n    int or float or complex\n        The result of substituting x_val for 'x' in expr and evaluating the resulting expression.\n    Example\n    --------\n    >>> evaluate_expression('x**2 + 2*x + 1', 1)\n    4\n    \"\"\"\n    from sympy import symbols\n    x = symbols('x')\n    return eval(expr)"
        ],
        [
            "def equation_solver(expression, variable):\n    \"\"\"\n    Solves an algebraic equation for the specified variable.\n    Parameters:\n    - expression: str\n        The expression or equation to solve, provided as a string.\n    - variable: str\n        The variable to solve the equation for.\n    Returns:\n    - list\n        A list of solutions to the equation.\n    Examples:\n    >>> equation_solver('x**2 - 5*x + 6 = 0', 'x')\n    [2, 3]\n    >>> equation_solver('x**2 + 2*x + 1', 'x')\n    [-1]\n    \"\"\"\n    var = symbols(variable)\n    expr = expression.replace(\"=\", \"-(\") + \")\" if \"=\" in expression else expression\n    return solve(Eq(eval(expr), 0), var)"
        ],
        [
            "def decimal_to_fraction(decimal_value):\n    \"\"\"\n    Converts a repeating or non-repeating decimal to its simplest fractional form.\n    Parameters:\n    - decimal_value (float or str): The decimal value to convert.\n    Returns:\n    - The fraction representation of the decimal.\n    Examples:\n    - decimal_to_fraction(0.333)  # for repeating decimals like 1/3\n    - decimal_to_fraction('0.(142857)')  # for specific repeating decimals\n    \"\"\"\n    x = symbols('x')\n    if isinstance(decimal_value, str) and '(' in decimal_value:\n        before, after = decimal_value.split('(')\n        after = after.strip(')')\n        repeats = after\n        non_repeats = before if before else '0'\n        full_decimal = non_repeats + repeats\n        length_of_repeats = len(repeats)\n        decimal_places = len(non_repeats.split('.')[1] if '.' in non_repeats else '') + length_of_repeats\n        fraction = (int(full_decimal) - int(non_repeats)) / (10**decimal_places - 10**len(non_repeats.split('.')[1]))\n        return nsimplify(fraction)\n    else:\n        return nsimplify(decimal_value)"
        ],
        [
            "def manipulate_expression(expression, operation):\n    \"\"\"\n    Simplifies or manipulates algebraic expressions using a specific operation.\n    Parameters:\n    - expression (str): The algebraic expression to manipulate.\n    - operation (str): Operation type ('simplify', 'expand', 'factor').\n    Returns:\n    - The manipulated expression as per the specified operation.\n    Examples:\n    - manipulate_expression('x**2 - 2*x + 1', 'factor')\n    - manipulate_expression('x*(x - 1) + x', 'expand')\n    \"\"\"\n    expr = simplify(expression)  # Simplify the expression initially\n    if operation == 'simplify':\n        return simplify(expr)\n    elif operation == 'expand':\n        return expand(expr)\n    elif operation == 'factor':\n        return factor(expr)\n    else:\n        raise ValueError(\"Unsupported operation. Use 'simplify', 'expand', or 'factor'.\")"
        ],
        [
            "def solve_equation(eq):\n    \"\"\"\n    Function to solve algebraic equation.\n    \n    Parameters\n    ----------\n    eq : str\n        Algebraic equation represented as a string. This eq should be a valid sympy equation.\n    Returns\n    -------\n    list\n        A list of real roots of the equation.\n    Example\n    --------\n    >>> solve_equation('x**2 - 5*x + 6 = 0')\n    [2, 3]\n    \"\"\"\n    from sympy import symbols, Eq, solve\n    x = symbols('x')\n    eq = Eq(*map(eval, eq.split(\"=\")))\n    return solve(eq, x)"
        ],
        [
            "def solve_linear_equation(equation, variable):\n    \"\"\"\n    Solves a linear equation for a given variable.\n    \n    Parameters:\n        equation (str): The equation in string format, e.g., '2*x + 1 = 0'.\n        variable (str): The variable to solve for, e.g., 'x'.\n    \n    Returns:\n        sol (list): List of solutions.\n    \n    Examples:\n        >>> solve_linear_equation('2*x + 1 = 0', 'x')\n        [-1/2]\n    \"\"\"\n    var = sp.symbols(variable)\n    equ = sp.sympify(equation)\n    sol = sp.solve(equ, var)\n    return sol",
            "def solve_linear_equation(equation, variable):\n    \"\"\"\n    Solve a linear equation for the given variable.\n    Parameters:\n    - equation (str): The linear equation represented as a string, e.g., \"2*x + 1 = 0\".\n    - variable (str): The variable to solve for, e.g., \"x\".\n    Returns:\n    - solution (SymPy object): The solution of the equation. If the solution does not exist, return None.\n    Examples:\n    >>> solve_linear_equation(\"2*x + 1 = 0\", \"x\")\n    -1/2\n    \"\"\"\n    var = sp.symbols(variable)\n    eq = sp.sympify(equation)\n    solution = sp.solve(eq, var)\n    \n    return solution[0] if solution else None",
            "def solve_linear_equation(equation: str, var: str) -> dict:\n    \"\"\"\n    Solves a linear equation for the specified variable.\n    \n    Parameters\n    ----------\n    equation : str\n        The linear equation to solve, as a string.\n    var : str\n        The variable to solve for.\n    \n    Returns\n    -------\n    dict\n        A dictionary with the solution variable as keys and their solutions as values.\n        \n    Examples\n    --------\n    >>> solve_linear_equation(\"2*x + 3 = 7\", \"x\")\n    {'x': 2}\n    \"\"\"\n    var = sp.symbols(var)\n    eq = sp.sympify(equation)\n    solution = sp.solve(eq, var)\n    return {str(var): solution[0] if solution else None}"
        ],
        [
            "def equation_solver(equation, *args, **kwargs):\n    \"\"\"\n    Solves algebraic equations including linear, quadratic, and systems of equations.\n    Parameters:\n    - equation (str or list of str): The equation(s) to solve, expressed as a string for a single equation or a list of strings for a system.\n    - args: Represents the symbols in the equations if they need to be explicitly provided.\n    - kwargs: Additional keyword arguments for the solver such as dict=True to return solutions in a dictionary format.\n    Returns:\n    - A solution or list of solutions depending on the input.\n    Examples:\n    - equation_solver('x**2 - 5*x + 6 = 0')\n    - equation_solver(['2*x + y = 8', 'x - y = 2'])\n    \"\"\"\n    if isinstance(equation, str):\n        # Single equation solver\n        expr = simplify(equation.replace(\"=\", \"-(\") + \")\")\n        var = symbols(args) if args else expr.free_symbols\n        return solve(expr, *var, **kwargs)\n    else:\n        # System of equations solver\n        eqs = [Eq(simplify(eq.split('=')[0]), simplify(eq.split('=')[1])) for eq in equation]\n        vars = symbols(args) if args else set(sum([list(eq.free_symbols) for eq in eqs], []))\n        return solve(eqs, *vars, **kwargs)"
        ],
        [
            "def factor_algebraic_expression(expression):\n    \"\"\"\n    Perform factorization on an algebraic expression.\n    Parameters:\n    - expression (str): The algebraic expression represented as a string, e.g., \"x**2 - 4\".\n    Returns:\n    - factored_expression (SymPy object): The factored expression if factorizable, otherwise the original expression.\n    Examples:\n    >>> factor_algebraic_expression(\"x**2 - 4\")\n    (x - 2)*(x + 2)\n    \"\"\"\n    exp = sp.sympify(expression)\n    factored_expression = sp.factor(exp)\n    \n    return factored_expression"
        ],
        [
            "def square_both_sides(expr):\n    \"\"\"\n    Function to square both sides of an equation\n    \n    Parameters\n    ----------\n    expr : str\n        Algebraic equation represented as a string. This expr should be a valid sympy equation.\n    Returns\n    -------\n    str\n        The equation obtained by squaring both sides of the input equation.\n    Example\n    --------\n    >>> square_both_sides('x = y + 1')\n    'x**2 = (y + 1)**2'\n    \"\"\"\n    left_side, right_side = map(eval, expr.split(\"=\"))\n    return f\"{left_side ** 2} = {right_side ** 2}\""
        ]
    ],
    "Simplifying Expressions": [
        [
            "def simplify_expression(expression):\n    \"\"\"\n    Simplifies algebraic expressions including expansion, factoring, and combining like terms.\n    \n    Parameters:\n        expression (str): A string representing the algebraic expression to be simplified.\n    \n    Returns:\n        sp.Expr: The simplified version of the input expression as a sympy expression object.\n    \n    Examples:\n        >>> simplify_expression(\"x^2 + 2*x + 1\")\n        (x + 1)**2\n        \n        >>> simplify_expression(\"a*b + a*c + a*d\")\n        a*(b + c + d)\n    \"\"\"\n    # Convert the input expression string into a sympy expression\n    sympy_expr = sp.sympify(expression)\n    # Simplify the expression\n    simplified_expr = sp.simplify(sympy_expr)\n    return simplified_expr",
            "def simplify_expression(expression):\n    \"\"\"\n    Simplifies an algebraic expression using symbolic mathematics.\n    Parameters:\n        expression (str): The algebraic expression as a string.\n    Returns:\n        str: The simplified expression in string format.\n    \n    Example:\n        >>> simplify_expression(\"2*x + 3*x + 1\")\n        '5*x + 1'\n    \"\"\"\n    expr = sympify(expression)\n    simplified_expr = simplify(expr)\n    return str(simplified_expr)",
            "def simplify_expression(expr_str):\n    \"\"\"\n    Takes a string representation of an algebraic expression and returns its simplified form.\n    Parameters:\n    - expr_str (str): A string representing the algebraic expression to be simplified.\n    Returns:\n    - str: Simplified form of the input expression.\n    Examples:\n    - simplify_expression('x^2 + 2*x + 1 - (x + 1)^2')\n    - simplify_expression('a^2 - b^2')\n    Note:\n    The function can process input with Python power syntax (^ replaced by **) and understands basic algebraic operations.\n    \"\"\"\n    # Replace power symbol if present in traditional form\n    expr_str = expr_str.replace('^', '**')\n    # Create symbolic expression\n    expr = simplify(expr_str)\n    return str(expr)",
            "def simplify_expression(expression):\n    \"\"\"\n    Simplifies an algebraic expression using symbolic computation.\n    \n    Parameters:\n        expression (str): A string representing the algebraic expression to be simplified.\n    \n    Returns:\n        sympy.Expr: The simplified expression.\n    Examples:\n        >>> simplify_expression(\"x**2 + 2*x + 1\")\n        (x + 1)**2\n        \n        >>> simplify_expression(\"x**2 - 2*x + 1\")\n        (x - 1)**2\n        \n        >>> simplify_expression(\"2*x + 2*y + 3*x + 5\")\n        5*x + 2*y + 5\n    \"\"\"\n    expr = sp.sympify(expression)\n    return sp.simplify(expr)",
            "def simplify_expression(expression):\n    \"\"\"\n    Simplifies the given algebraic expression including rationalizing denominators,\n    simplifying radicals, and performing arithmetic simplifications.\n    Parameters:\n    - expression (str): The algebraic expression to simplify, e.g., 'x^2 + 2*x + 1'.\n    Returns:\n    - str: A string representing the simplified expression.\n    Examples:\n    >>> simplify_expression('x^2 + 2*x + 1')\n    'x**2 + 2*x + 1'\n    \n    >>> simplify_expression('((a^2 - b^2)/(a - b))')\n    'a + b'\n    \"\"\"\n    expr = sp.sympify(expression.replace('^', '**'))\n    simplified_expr = sp.simplify(expr)\n    return str(simplified_expr)",
            "def simplify_expression(expression):\n    \"\"\"\n    Simplifies a given mathematical expression, reducing it to its simplest form.\n    Parameters:\n        expression (str): The mathematical expression to simplify, given as a string.\n    Returns:\n        sympy.Expr: The simplified expression.\n    Examples:\n        >>> simplify_expression(\"2*x + 3*x - 5\")\n        5*x - 5\n        >>> simplify_expression(\"(x**2 - x - 6)/(x - 3)\")\n        x + 2\n    \"\"\"\n    expr = sympify(expression)\n    return simplify(expr)"
        ],
        [
            "def factor_expression(expression):\n    \"\"\"\n    Factors an algebraic expression into its irreducible components.\n    Parameters:\n        expression (str): The algebraic expression as a string.\n    Returns:\n        str: The factored expression in string format.\n    \n    Example:\n        >>> factor_expression(\"x**2 - 4\")\n        '(x - 2)*(x + 2)'\n    \"\"\"\n    expr = sympify(expression)\n    factored_expr = factor(expr)\n    return str(factored_expr)",
            "def factor_expression(expr_str):\n    \"\"\"\n    Factors a given algebraic expression if possible.\n    Parameters:\n    - expr_str (str): A string representing the algebraic expression to factor.\n    Returns:\n    - str: Factored form of the expression.\n    Examples:\n    - factor_expression('x^2 - 4')\n    - factor_expression('a^2 - 2*a*b + b^2')\n    Note:\n    Input expression should use ** for powers.\n    \"\"\"\n    expr_str = expr_str.replace('^', '**')\n    expr = factor(expr_str)\n    return str(expr)",
            "def factor_expression(expression):\n    \"\"\"\n    Factors an algebraic expression into simpler components if possible.\n    \n    Parameters:\n        expression (str): The algebraic expression in string form to factor.\n    \n    Returns:\n        sympy.Expr: The factored expression if factorable, otherwise the original expression.\n    \n    Examples:\n        >>> factor_expression(\"x**2 - 1\")\n        (x - 1)*(x + 1)\n        \n        >>> factor_expression(\"x**2 + 2*x + 1\")\n        (x + 1)**2\n    \"\"\"\n    expr = sp.sympify(expression)\n    return sp.factor(expr)",
            "def factor_expression(expression):\n    \"\"\"\n    Factors a given mathematical expression.\n    Parameters:\n        expression (str): The mathematical expression to factor, given as a string.\n    Returns:\n        sympy.Expr: The factored expression.\n    Examples:\n        >>> factor_expression(\"x**2 - 3*x + 2\")\n        (x - 1)*(x - 2)\n        >>> factor_expression(\"x**2 - 4\")\n        (x - 2)*(x + 2)\n    \"\"\"\n    expr = sympify(expression)\n    return factor(expr)"
        ],
        [
            "def expand_expression(expression):\n    \"\"\"\n    Expands an algebraic expression to its expanded form.\n    Parameters:\n        expression (str): The algebraic expression as a string.\n    Returns:\n        str: The expanded expression in string format.\n    \n    Example:\n        >>> expand_expression(\"(x - 2)*(x + 2)\")\n        'x**2 - 4'\n    \"\"\"\n    expr = sympify(expression)\n    expanded_expr = expand(expr)\n    return str(expanded_expr)",
            "def expand_expression(expr_str):\n    \"\"\"\n    Expands a given algebraic expression.\n    Parameters:\n    - expr_str (str): A string representing the algebraic expression to expand.\n    Returns:\n    - str: Expanded form of the expression.\n    Examples:\n    - expand_expression('(x + 1)^2')\n    - expand_expression('a*(b + c)')\n    Note:\n    Input expression should use ** for powers.\n    \"\"\"\n    expr_str = expr_str.replace('^', '**')\n    expr = expand(expr_trans)\n    return str(expr)",
            "def expand_expression(expression):\n    \"\"\"\n    Expands an algebraic expression into a simplified form without parenthesis.\n    \n    Parameters:\n        expression (str): The algebraic expression in string form to expand.\n    \n    Returns:\n        sympy.Expr: The expanded expression.\n    \n    Examples:\n        >>> expand_expression(\"(x - 1)*(x + 1)\")\n        x**2 - 1\n        \n        >>> expand_expression(\"(x + 1)**2\")\n        x**2 + 2*x + 1\n    \"\"\"\n    expr = sp.sympify(expression)\n    return sp.expand(expr)",
            "def expand_expression(expression):\n    \"\"\"\n    Expands a given mathematical expression.\n    Parameters:\n        expression (str): The mathematical expression to expand, given as a string.\n    Returns:\n        sympy.Expr: The expanded expression.\n    Examples:\n        >>> expand_expression(\"(x - 2)*(x + 2)\")\n        x**2 - 4\n        >>> expand_expression(\"(x + 1)*(x - 3)\")\n        x**2 - 2*x - 3\n    \"\"\"\n    expr = sympify(expression)\n    return expand(expr)"
        ],
        [
            "def manipulate_expression(expression, operation='simplify', value=None):\n    \"\"\"\n    Manipulates the given algebraic expression based on the specified operation.\n    Operations include expansion, factoring, solving equations, polynomial operations, and substituting values.\n    Parameters:\n    - expression (str): The algebraic expression or equation.\n    - operation (str): The operation to perform (e.g., 'expand', 'factor', 'solve').\n    - value (dict, optional): Dictionary of values to substitute in expression, e.g., {x: 1}.\n    Returns:\n    - str or list: The result of the operation, as a string or list of solutions.\n    Examples:\n    >>> manipulate_expression('x^2 + 2*x + 1', 'factor')\n    '(x + 1)**2'\n    >>> manipulate_expression('x^2 - 4', 'solve')\n    '[-2, 2]'\n    >>> manipulate_expression('x^2 + 3*x + 2', 'expand')\n    'x**2 + 3*x + 2'\n    \"\"\"\n    expr = sp.sympify(expression.replace('^', '**'))\n    if operation == 'expand':\n        result = sp.expand(expr)\n    elif operation == 'factor':\n        result = sp.factor(expr)\n    elif operation == 'solve':\n        # Assuming it is to solve for x\n        result = sp.solveset(expr, sp.Symbol('x'), domain=sp.S.Reals)\n    if value is not None:\n        expr = expr.subs(value)\n        result = expr.evalf()\n    \n    return str(result)"
        ],
        [
            "def convert_repeating_decimal_to_fraction(decimal):\n    \"\"\"\n    Converts a repeating decimal string to its corresponding fraction form.\n    Parameters:\n    - decimal (str): The repeating decimal to convert, e.g., '0.333...'.\n    Returns:\n    - str: A string representation of the fraction form.\n    Examples:\n    >>> convert_repeating_decimal_to_fraction('0.333...')\n    '1/3'\n    \n    >>> convert_repeating_decimal_to_fraction('0.142857...')\n    '1/7'\n    \"\"\"\n    import re\n    from fractions import Fraction\n    # Assuming the repeating part is marked by ellipsis after it\n    match = re.match(r'0\\.(\\d+)\\.\\.\\.', decimal)\n    if not match:\n        return 'Invalid format'\n    digits = match.group(1)\n    return str(Fraction('.' + digits, 1).limit_denominator())"
        ],
        [
            "def handle_radicals_and_exponents(base, exponent, operation='simplify'):\n    \"\"\"\n    Handles operations on expressions involving radicals and exponents.\n    \n    Parameters:\n        base (sp.Expr): The base of the exponent.\n        exponent (sp.Expr): The exponent value.\n        operation (str): Type of operation, 'simplify' or 'rationalize'.\n    \n    Returns:\n        sp.Expr: The result after applying the specified operation.\n    \n    Examples:\n        >>> handle_radicals_and_exponents(x, 1/2)\n        sqrt(x)\n        \n        >>> handle_radicals_and_exponents(a*b, -2)\n        1/(a**2 * b**2)\n    \"\"\"\n    base, exponent = sp.sympify(base), sp.sympify(exponent)\n    expr = base**exponent\n    \n    if operation == 'simplify':\n        return sp.simplify(expr)\n    elif operation == 'rationalize':\n        if exponent < 0:\n            # Rationalize denominators\n            expr = 1/expr\n            rationalized_expr = sp.radsimp(expr)\n            return rationalized_expr\n        else:\n            return sp.radsimp(expr)\n    else:\n        raise ValueError(\"Unsupported operation. Choose from 'simplify' or 'rationalize'.\")"
        ],
        [
            "def substitute_in_expression(expression, substitutions):\n    \"\"\"\n    Substitutes values into an algebraic expression and simplifies it.\n    Parameters:\n        expression (str): The algebraic expression as a string.\n        substitutions (dict): A dictionary where keys are variable names as strings and values are their respective values.\n    Returns:\n        str: The simplified expression after substitution in string format.\n    \n    Example:\n        >>> substitute_in_expression(\"x**2 + 2*x + 1\", {'x': 2})\n        '9'\n    \"\"\"\n    expr = sympify(expression)\n    substituted_expr = expr.subs(substitutions)\n    simplified_expr = simplify(substituted_expr)\n    return str(simplified_expr)",
            "def substitute_and_evaluate(expression, substitutions):\n    \"\"\"\n    Substitutes values into an expression and evaluates it.\n    Parameters:\n        expression (str): The mathematical expression where values are to be substituted.\n        substitutions (dict): A dictionary where keys are symbols (as strings) and values are the numerical or symbolic values to substitute.\n    Returns:\n        sympy.Expr: The resulting expression after substitution and evaluation.\n    Examples:\n        >>> substitute_and_evaluate(\"x**2 + 3*x + 1\", {\"x\": 2})\n        11\n        >>> substitute_and_evaluate(\"a*x**2 + b*x + c\", {\"a\": 1, \"b\": 3, \"c\": -4, \"x\": 1})\n        0\n    \"\"\"\n    expr = sympify(expression)\n    return expr.subs(substitutions).simplify()"
        ],
        [
            "def manipulate_fractions(num1, den1, num2, den2, operation='add'):\n    \"\"\"\n    Performs arithmetic operations on fractions and simplifies the result.\n    \n    Parameters:\n        num1 (sp.Expr): The numerator of the first fraction.\n        den1 (sp.Expr): The denominator of the first fraction.\n        num2 (sp.Expr): The numerator of the second fraction.\n        den2 (sp.Expr): The denominator of the second fraction.\n        operation (str): The operation to perform; 'add', 'subtract', 'multiply', 'divide'\n    \n    Returns:\n        sp.Expr: The result of the operation on the two fractions, simplified.\n    \n    Examples:\n        >>> manipulate_fractions(1, 2, 1, 3, 'add')\n        5/6\n        \n        >>> manipulate_fractions(x, y, y, x, 'multiply')\n        x*y/(y*x)\n    \"\"\"\n    # Convert numbers to sympy expressions if they aren't already\n    num1, den1, num2, den2 = map(sp.sympify, (num1, den1, num2, den2))\n    # Create fraction expressions\n    frac1 = num1 / den1\n    frac2 = num2 / den2\n    \n    # Perform the specified operation\n    if operation == 'add':\n        result = frac1 + frac2\n    elif operation == 'subtract':\n        result = frac1 - frac2\n    elif operation == 'multiply':\n        result = frac1 * frac2\n    elif operation == 'divide':\n        result = frac1 / frac2\n    else:\n        raise ValueError(\"Unsupported operation. Choose from 'add', 'subtract', 'multiply', 'divide'.\")\n    \n    # Simplify and return the result\n    return sp.simplify(result)"
        ],
        [
            "def rationalize_expression(expression):\n    \"\"\"\n    Rationalizes denominators in an expression with radicals.\n    \n    Parameters:\n        expression (str): The algebraic expression to rationalize.\n    \n    Returns:\n        sympy.Expr: The expression with rationalized denominator.\n    \n    Examples:\n        >>> rationalize_expression(\"1/sqrt(x)\")\n        sqrt(x)/x\n    \"\"\"\n    expr = sp.sympify(expression)\n    return sp.radsimp(expr)"
        ],
        [
            "def simplify_radical_expression(expression):\n    \"\"\"\n    Simplifies expressions involving radicals (roots).\n    \n    Parameters:\n        expression (str): The algebraic expression with radicals.\n    \n    Returns:\n        sympy.Expr: The simplified expression.\n    \n    Examples:\n        >>> simplify_radical_expression(\"sqrt(x**2)\")\n        Abs(x)\n        \n        >>> simplify_radical_expression(\"1/sqrt(x)\")\n        x**(-1/2)\n    \"\"\"\n    expr = sp.sympify(expression)\n    return sp.simplify(expr)"
        ],
        [
            "def rationalize_denominator(expr_str):\n    \"\"\"\n    Rationalizes the denominator of an algebraic expression if it contains radicals or complex fractions.\n    Parameters:\n    - expr_str (str): String representation of the algebraic expression.\n    Returns:\n    - str: Expression with a rationalized denominator.\n    Examples:\n    - rationalize_denominator('1/(sqrt(2))')\n    - rationalize_denominator('1/(2 + sqrt(3))')\n    Note:\n    Assumes input uses square roots as sqrt() and ** for power.\n    \"\"\"\n    expr_str = expr_str.replace('^', '**')\n    expr = simplify(expr_str).radsimp()\n    return str(expr)"
        ]
    ],
    "Sequences and Series": [
        [
            "def simplify_telescoping_sum(terms, n):\n    \"\"\" \n    Given a sequence of expressions that represents a telescoping sum, simplify the sum for the first n terms.\n    Parameters:\n        terms (function): A function that takes an index and returns the term at that index (must be symbolic).\n        n (int): The number of terms to consider in the sum.\n    Returns:\n        sympy expression: Simplified sum of the first n terms.\n    Examples:\n        >>> def f(k): return 1/k - 1/(k+1)\n        >>> simplify_telescoping_sum(f, 5)\n        1 - 1/6\n    \"\"\"\n    k = sp.symbols('k')\n    expr = sum(terms(k) for k in range(1, n+1))\n    return sp.simplify(expr)",
            "def telescoping_series_sum(terms):\n    \"\"\"\n    Compute the sum of a telescoping series where `terms` cancels out leaving a simple result.\n    \n    Parameters:\n        terms (list): A list of tuples representing the start and end of each term.\n    Returns:\n        sympy.Expr: The simplified sum of the series.\n    Examples:\n        >>> telescoping_series_sum([ (1/x, 1/(x+1)) for x in range(1, 100)])\n        -1/100 + 1\n    \"\"\"\n    x = symbols('x')\n    expr = sum(t[0] - t[1] for t in terms)\n    return simplify(expr.subs(x, 1) - expr.subs(x, len(terms) + 1))",
            "def telescoping_series_simplifier(terms, simplify=True):\n    \"\"\"\n    Simplify a telescoping series where large numbers of terms cancel out.\n    Parameters:\n    - terms (list of symbolic expressions): Terms of the telescoping series.\n    - simplify (bool): Whether to simplify each term before summing.\n    Returns:\n    - symbolic expression: Result of the telescoping series.\n    Example:\n    >>> terms = [1/(n+1) - 1/n for n in range(1, 100)]\n    >>> telescoping_series_simplifier(terms)\n    -1 + 1/100\n    \"\"\"\n    if simplify:\n        terms = [sp.simplify(term) for term in terms]\n    return sum(terms)"
        ],
        [
            "def sum_of_natural_numbers(n):\n    \"\"\"\n    Calculate the sum of the first n natural numbers.\n    Parameters:\n    n (int): Number of terms.\n    Returns:\n    int: Sum of the first n natural numbers.\n    \n    Examples:\n    >>> sum_of_natural_numbers(100)\n    5050\n    \"\"\"\n    return n * (n + 1) / 2",
            "def sum_of_squares_of_natural_numbers(n):\n    \"\"\"\n    Calculate the sum of the squares of the first n natural numbers.\n    Parameters:\n    n (int): Number of terms.\n    Returns:\n    int: Sum of the squares of the first n natural numbers.\n    \n    Examples:\n    >>> sum_of_squares_of_natural_numbers(100)\n    338350\n    \"\"\"\n    return n * (n + 1) * (2 * n + 1) / 6",
            "def sum_of_squares(n):\n    \"\"\"\n    Computes the sum of the squares of the first n natural numbers.\n    \n    Parameters:\n    n : int\n        The number of terms to sum the squares of.\n        \n    Returns:\n    int\n        The sum of the squares of the first n natural numbers.\n    \n    Example:\n    >>> sum_of_squares(10)\n    385\n    \"\"\"\n    return n * (n + 1) * (2 * n + 1) / 6",
            "def sum_natural_numbers(n):\n    \"\"\"\n    Calculates the sum of the first n natural numbers.\n    Parameters:\n        n (int): The number of terms to sum.\n    Returns:\n        float: The sum of the first n natural numbers.\n    Examples:\n        >>> sum_natural_numbers(5)  # 1 + 2 + 3 + 4 + 5\n        15.0\n        >>> sum_natural_numbers(10)\n        55.0\n    \"\"\"\n    return n * (n + 1) / 2"
        ],
        [
            "def geometric_series_sum(a, r, n=None):\n    \"\"\"\n    Calculate the sum of the first n terms of a geometric series\n    or the sum of an infinite series if n is None and |r| < 1.\n    \n    Parameters:\n        a (float): The first term of the series.\n        r (float): The common ratio of the series.\n        n (int, optional): The number of terms to sum. If None, calculates\n                           the sum of an infinite series, assuming |r| < 1.\n    \n    Returns:\n        float: The sum of the first n terms or the infinite series sum.\n    \n    Raises:\n        ValueError: If n is None and |r| >= 1 (infinite series does not converge).\n    \n    Examples:\n        >>> geometric_series_sum(1, 0.5, 3)\n        1.75\n        >>> geometric_series_sum(3, 0.333, None)\n        4.5\n    \"\"\"\n    if n is not None:\n        return a * (1 - r ** n) / (1 - r)\n    else:\n        if abs(r) < 1:\n            return a / (1 - r)\n        else:\n            raise ValueError(\"The series does not converge for |r| >= 1.\")",
            "def sum_infinite_geometric_series(a, r):\n    \"\"\"\n    Calculate the sum of an infinite geometric series, given that |r| < 1.\n    Parameters:\n    a : float\n        The first term of the series.\n    r : float\n        The common ratio of the series.\n    Returns:\n    float or None\n        The sum of the infinite series if |r| < 1, otherwise None.\n    Examples:\n    >>> sum_infinite_geometric_series(3, 0.5)\n    6.0\n    \"\"\"\n    if abs(r) < 1:\n        return a / (1 - r)\n    else:\n        return None",
            "def infinite_geometric_series_sum(a, r):\n    \"\"\"\n    Calculate the sum of an infinite geometric series, provided |r| < 1.\n    Parameters:\n        a (float) : The first term of the series.\n        r (float) : The common ratio of the series.\n    Returns:\n        float: The sum of the infinite geometric series if |r| < 1, otherwise raises an exception.\n    Examples:\n        >>> infinite_geometric_series_sum(5, 0.5)\n        10.0\n    \"\"\"\n    if abs(r) < 1:\n        return a / (1 - r)\n    else:\n        raise ValueError(\"Sum does not converge unless the absolute value of the common ratio is less than 1.\")"
        ],
        [
            "def sequence_generator(nth_term, init_terms=None, n=10, mode='explicit'):\n    \"\"\"\n    Generates a sequence of the first n terms given an nth term function or a recursive relation.\n    \n    Parameters:\n    - nth_term: function. A function defining the nth term of the sequence or a recursive function if init_terms is provided.\n    - init_terms: list or None. Initial terms required for the recursive mode.\n    - n: int. Number of terms in the sequence to generate.\n    - mode: str. 'explicit' for explicit formulas or 'recursive' for recursive relations.\n    \n    Returns:\n    - list. A list of the first n terms of the sequence.\n    \n    Examples:\n    - For an arithmetic sequence with a common difference d: sequence_generator(lambda n: a1 + (n - 1) * d, n=5)\n    - For a recursive sequence: sequence_generator(lambda x, i: x[i-1] + x[i-2], init_terms=[1, 1], n=10, mode='recursive')\n    \"\"\"\n    from sympy import symbols, lambdify\n    seq = []\n    \n    if mode == 'explicit':\n        x = symbols('x')\n        f = lambdify(x, nth_term(x), 'numpy')\n        seq = [f(i) for i in range(1, n + 1)]\n    elif mode == 'recursive' and init_terms:\n        seq = init_terms.copy()\n        for i in range(len(init_terms), n):\n            seq.append(nth_term(seq, i))\n    \n    return seq",
            "def recursive_sequence_generator(n, a_0, recurrence_relation, *initial_terms):\n    \"\"\"\n    Generate terms of a sequence based on a recursive relation and a given number of terms.\n    \n    Parameters:\n    n (int): The number of terms in the sequence to generate.\n    a_0 (number): The initial term of the sequence.\n    recurrence_relation (function): A function f(a_i, i) representing the recurrence relation, where \n                                    a_i is the previous term, and i is the index.\n    initial_terms (tuple): Additional initial terms required for multi-ordered recurrences.\n    \n    Returns:\n    list: The first n terms of the sequence.\n    \n    Example:\n    # To generate the Fibonacci sequence\n    fibonacci = recursive_sequence_generator(10, 0, lambda a, b, i: a + b, 1)\n    \"\"\"\n    from collections import deque\n    # Initialize the sequence with the starting term(s)\n    terms = deque([a_0, *initial_terms])\n    while len(terms) < n:\n        new_term = recurrence_relation(*terms, len(terms))\n        terms.append(new_term)\n    return list(terms)[:n]"
        ],
        [
            "def sum_arithmetic_sequence(a, d, n):\n    \"\"\" \n    Calculate the sum of the first n terms of an arithmetic sequence.\n    \n    Parameters:\n        a (int or float): First term of the sequence.\n        d (int or float): Common difference of the sequence.\n        n (int): Number of terms to sum.\n    Returns:\n        int or float: The sum of the first n terms of the arithmetic sequence.\n    Examples:\n        >>> sum_arithmetic_sequence(1, 2, 5)\n        25\n    \"\"\"\n    return n / 2 * (2 * a + (n - 1) * d)",
            "def arithmetic_series_sum(a, d, n):\n    \"\"\"\n    Computes the sum of the first n terms of an arithmetic series.\n    \n    Parameters:\n    a : float\n        The first term of the arithmetic series.\n    d : float\n        The common difference between terms of the arithmetic series.\n    n : int\n        The number of terms to sum.\n        \n    Returns:\n    float\n        The sum of the first n terms of the arithmetic series.\n    \n    Example:\n    >>> arithmetic_series_sum(1, 1, 100)  # Sum of the first 100 natural numbers\n    5050.0\n    \"\"\"\n    return n / 2 * (2 * a + (n - 1) * d)",
            "def compute_arithmetic_sum(a, d, n):\n    \"\"\"\n    Compute the sum of the first `n` terms of an arithmetic sequence.\n    \n    Parameters:\n        a (int or float): The first term of the sequence.\n        d (int or float): The common difference between consecutive terms.\n        n (int): The number of terms to sum.\n    Returns:\n        int or float: The sum of the first `n` terms of the arithmetic sequence.\n    Examples:\n        >>> compute_arithmetic_sum(1, 1, 100)\n        5050\n        >>> compute_arithmetic_sum(2, 3, 4)\n        26\n    \"\"\"\n    return n / 2 * (2 * a + (n - 1) * d)",
            "def sum_arithmetic_series(a1, n=None, an=None, d=None):\n    \"\"\"\n    Calculates the sum of an arithmetic series given enough information.\n    Parameters:\n    - a1 : float or int\n        The first term of the arithmetic series.\n    - n : int, optional\n        The number of terms in the series.\n    - an : float or int, optional\n        The nth (last) term of the series.\n    - d : float or int, optional\n        The common difference between terms.\n    Returns:\n    - float : the sum of the arithmetic series\n    Examples:\n    - sum_arithmetic_series(1, n=100) calculates the sum of the first 100 natural numbers.\n    - sum_arithmetic_series(2, 10, d=2) calculates the sum of the first 10 terms starting with 2 and with common difference 2.\n    \"\"\"\n    if an is None and d is not None:\n        an = a1 + (n - 1) * d\n    if n is None and d is not None:\n        n = ((an - a1) / d) + 1\n    return n / 2 * (a1 + an)",
            "def arithmetic_series_sum(a, d, n):\n    \"\"\"\n    Calculate the sum of the first `n` terms of an arithmetic series.\n    Parameters:\n        a (int or float): The first term of the arithmetic series.\n        d (int or float): The common difference in the arithmetic series.\n        n (int): The number of terms to sum.\n    Returns:\n        int or float: The sum of the first `n` terms of the arithmetic series.\n    Examples:\n        >>> arithmetic_series_sum(1, 1, 5)\n        15\n        >>> arithmetic_series_sum(3, 2, 4)\n        26\n    \"\"\"\n    return n / 2 * (2 * a + (n - 1) * d)",
            "def evaluate_arithmetic_series(a1, d, n):\n    \"\"\"\n    Given the first term a1 and the common difference d, compute the sum of the first n terms of an arithmetic series.\n    Parameters:\n    a1 (numeric): First term of the arithmetic series.\n    d (numeric): Common difference.\n    n (int): Number of terms.\n    Returns:\n    numeric: Sum of the first n terms of the arithmetic series.\n    Examples:\n    >>> evaluate_arithmetic_series(1, 1, 10)\n    55\n    \"\"\"\n    return n / 2 * (2 * a1 + (n - 1) * d)",
            "def arithmetic_sequence_sum(a, d, n):\n    \"\"\"\n    Calculate the sum of the first 'n' terms of an arithmetic sequence.\n    \n    Parameters:\n    - a (int/float/symbolic): The first term of the arithmetic sequence.\n    - d (int/float/symbolic): The common difference between terms of the arithmetic sequence.\n    - n (int/symbolic): The number of terms to sum.\n    Returns:\n    - symbolic expression/number: Sum of the first 'n' terms of the arithmetic sequence.\n    Example:\n    >>> arithmetic_sequence_sum(1, 1, 10)\n    55\n    \"\"\"\n    return n / 2 * (2 * a + (n - 1) * d)",
            "def sum_arithmetic_series(a, d, n):\n    \"\"\"\n    Calculate the sum of an arithmetic series.\n    Parameters:\n    - a: number or sympy.Symbol, the first term in the series.\n    - d: number or sympy.Symbol, the common difference between terms.\n    - n: int, the number of terms in the series.\n    Returns:\n    - The sum of the first `n` terms of the arithmetic series.\n    Examples:\n    >>> sum_arithmetic_series(1, 1, 100)\n    5050\n    >>> sum_arithmetic_series(3, 4, 10)\n    235\n    \"\"\"\n    from sympy import Symbol, simplify\n    # S_n = n/2 * (2a + (n-1)d)\n    # Use sympy to handle symbolic computation if required\n    n = Symbol('n', integer=True) if isinstance(n, Symbol) else n\n    a = Symbol('a') if isinstance(a, Symbol) else a\n    d = Symbol('d') if isinstance(d, Symbol) else d\n    return simplify(n / 2 * (2 * a + (n - 1) * d))"
        ],
        [
            "def sum_arithmetic_series(a1, an, n):\n    \"\"\"\n    Calculate the sum of the first n terms in an arithmetic series.\n    Parameters:\n    a1 (float): First term of the series.\n    an (float): nth term or last term of the series to sum up to.\n    n (int): Number of terms to sum.\n    Returns:\n    float: Sum of the first n terms.\n    \n    Examples:\n    >>> sum_arithmetic_series(1, 9, 5)\n    25\n    \"\"\"\n    return n * (a1 + an) / 2",
            "def sum_of_arithmetic_sequence(a1, an, n):\n    \"\"\"\n    Calculate the sum of the first n terms of an arithmetic sequence.\n    Parameters:\n    - a1 (int, float, or sympy.Symbol): first term of the arithmetic sequence.\n    - an (int, float, or sympy.Symbol): nth term of the arithmetic sequence.\n    - n (int): number of terms in the sequence.\n    \n    Returns:\n    - sum_seq (int, float, or sympy.Expression): The sum of the first n terms of the sequence.\n    Example:\n    >>> sum_of_arithmetic_sequence(1, 9, 5)\n    25\n    \"\"\"\n    return n * (a1 + an) / 2",
            "def arithmetic_sum(a, l, n):\n    \"\"\"\n    Calculates the sum of the first n terms of an arithmetic sequence given the first term, last term, and number of terms.\n    Parameters:\n        a (float): The first term of the sequence.\n        l (float): The last term of the sequence.\n        n (int): The number of terms in the sequence.\n    Returns:\n        float: The sum of the first n terms.\n    Examples:\n        >>> arithmetic_sum(1, 5, 5)  # Sum of 1 to 5\n        15.0\n        >>> arithmetic_sum(3, 9, 4)  # Sum of 3, 5, 7, 9\n        24.0\n    \"\"\"\n    return n * (a + l) / 2"
        ],
        [
            "def number_of_terms(a1, an, d):\n    \"\"\"\n    Calculate the number of terms in an arithmetic sequence given the first term, last term, and common difference.\n    Parameters:\n    - a1 (int, float, or sympy.Symbol): first term of the arithmetic sequence.\n    - an (int, float, or sympy.Symbol): last term of the arithmetic sequence.\n    - d (int, float, or sympy.Symbol): common difference of the arithmetic sequence.\n    \n    Returns:\n    - n (int or sympy.Expression): Number of terms in the sequence.\n    Example:\n    >>> number_of_terms(1, 9, 2)\n    5\n    \"\"\"\n    return ((an - a1) / d) + 1",
            "def number_of_terms_arithmetic_sequence(first_term, last_term, d):\n    \"\"\"\n    Calculate the number of terms in an arithmetic sequence.\n    Parameters:\n    - first_term (Numerical): The first term of the sequence.\n    - last_term (Numerical): The last term of the sequence.\n    - d (Numerical): The common difference of the sequence.\n    Returns:\n    - Integer: The total number of terms in the sequence.\n    Examples:\n    >>> number_of_terms_arithmetic_sequence(2, 14, 3)\n    5\n    \"\"\"\n    return ((last_term - first_term) / d) + 1"
        ],
        [
            "def periodic_sequence_analysis(sequence, length_of_period):\n    \"\"\"\n    Analyze the sequence for periodic behavior given an expected period length.\n    Parameters:\n    sequence (list): The sequence to analyze.\n    length_of_period (int): The expected length of the periodic cycle.\n    Returns:\n    bool: Whether the sequence is periodic with the given period length.\n    \n    Example:\n    # Check if sequence [1, 2, 3, 1, 2, 3] repeats every 3 terms\n    is_periodic = periodic_sequence_analysis([1, 2, 3, 1, 2, 3], 3)\n    \"\"\"\n    if len(sequence) % length_of_period != 0:\n        return False\n    period = sequence[:length_of_period]\n    for i in range(length_of_period, len(sequence), length_of_period):\n        if sequence[i:i+length_of_period] != period:\n            return False\n    return True"
        ],
        [
            "def sequence_term(a0, rule, n, mode='recursive'):\n    \"\"\"\n    Calculate the nth term of a sequence defined either recursively or arithmetically.\n    Parameters:\n    a0 (numeric): The initial term of the sequence.\n    rule (function): If mode is 'recursive', this is a function f(a, n) where a is the previous term and n is the index.\n                     If mode is 'arithmetic', this is a function f(n) defining the nth term directly.\n    n (int): The term of the sequence to compute.\n    mode (str, optional): The mode of operation, 'recursive' (default) or 'arithmetic'.\n    Returns:\n    numeric: The nth term of the sequence.\n    Examples:\n    >>> sequence_term(1, lambda a, n: a + n, 5)\n    16\n    >>> sequence_term(1, lambda n: n**2 + 1, 5, mode='arithmetic')\n    26\n    \"\"\"\n    import numpy as np\n    if mode == 'recursive':\n        a = a0\n        for i in range(1, n):\n            a = rule(a, i)\n        return a\n    elif mode == 'arithmetic':\n        return rule(n)",
            "def generate_sequence(a0, rule, length, mode='recursive'):\n    \"\"\"\n    Generate a sequence of given length starting from an initial term.\n    Parameters:\n    a0 (numeric): Initial term of the sequence.\n    rule (function): Rule to compute the next term (see `sequence_term`).\n    length (int): Number of terms in the sequence to generate.\n    mode (str, optional): 'recursive' (default) or 'arithmetic'.\n    Returns:\n    list: List of sequence terms.\n    Examples:\n    >>> generate_sequence(1, lambda a, n: a + 2, 5)\n    [1, 3, 5, 7, 9]\n    \"\"\"\n    sequence = [a0]\n    for i in range(1, length):\n        sequence.append(sequence_term(sequence[-1], rule, i + 1, mode))\n    return sequence",
            "def sum_of_sequence_terms(a0, rule, length, mode='recursive'):\n    \"\"\"\n    Calculate the sum of the first `length` terms of a sequence.\n    Parameters:\n    a0 (numeric): Initial term of the sequence.\n    rule (function): Rule to compute the next term (similar to `sequence_term`).\n    length (int): Number of terms to include in the sum.\n    mode (str, optional): 'recursive' (default) or 'arithmetic'.\n    Returns:\n    numeric: Sum of the first `length` terms of the sequence.\n    Examples:\n    >>> sum_of_sequence_terms(1, lambda a, n: a + 2, 5)\n    25\n    \"\"\"\n    return sum(generate_sequence(a0, rule, length, mode))"
        ],
        [
            "def solve_arithmetic_series_for_n(S, a1, d):\n    \"\"\"\n    Given the sum, first term, and common difference, find the number of terms in the arithmetic series.\n    Parameters:\n    S (float): Sum of the series.\n    a1 (float): First term of the series.\n    d (float): Common difference.\n    Returns:\n    int or None: Number of terms if a solution exists, otherwise None.\n    \n    Examples:\n    >>> solve_arithmetic_series_for_n(25, 1, 2)\n    5\n    \"\"\"\n    n = sp.symbols('n', integer=True)\n    expr = n / 2 * (2 * a1 + (n - 1) * d) - S  # Derived from Sn formula\n    sol = sp.solveset(expr, n, domain=sp.S.Naturals)\n    return list(sol)[0] if sol else None",
            "def solve_arithmetic_terms_given_sum(s, a1=None, an=None, d=None):\n    \"\"\"\n    Solves for the number of terms 'n' in an arithmetic sequence given enough details.\n    \n    Parameters:\n    - s : float\n        The sum of the arithmetic series.\n    - a1 : float or int, optional\n        The first term of the arithmetic series.\n    - an : float or int, optional\n        The last term of the series.\n    - d : float or int, optional\n        The common difference.\n    \n    Returns:\n    - int : the number of terms 'n' in the sequence that sums to 's'\n    Examples:\n    - solve_arithmetic_terms_given_sum(5050, a1=1, d=1) identifies 'n' where the sum of n natural numbers is 5050.\n    \"\"\"\n    n = sp.Symbol('n', integer=True)\n    expr = sp.Eq(n / 2 * (a1 + an), s)\n    if an is None and d is not None:\n        return sp.solve(expr.subs(an, a1 + (n - 1) * d), n)\n    return sp.solve(expr, n)"
        ],
        [
            "def generic_summation(n, term_function):\n    \"\"\"\n    Computes the sum of terms in a sequence defined by a function over a range [1, n].\n    Parameters:\n        n (int): The upper limit of the summation range.\n        term_function (function): A function that defines the term to be summed,\n                                  which takes an integer index as an argument.\n    Returns:\n        float: The sum of the sequence terms.\n    Examples:\n        >>> generic_summation(5, lambda x: x**2)\n        55\n        >>> generic_summation(4, lambda x: 2**x)\n        30\n    \"\"\"\n    import functools\n    return functools.reduce(lambda acc, x: acc + term_function(x), range(1, n + 1), 0)",
            "def condition_specific_summation(n, term_function, condition_function):\n    \"\"\"\n    Computes the sum of terms in a sequence defined by a function over a range [1, n],\n    considering only terms that meet a specified condition.\n    Parameters:\n        n (int): The upper limit of the summation range.\n        term_function (function): A function that defines the term to be summed,\n                                  which takes an integer index as an argument.\n        condition_function (function): A function that evaluates whether a term should be included,\n                                       which takes an integer index as an argument.\n    Returns:\n        float: The sum of the sequence terms that meet the condition.\n    Examples:\n        >>> condition_specific_summation(10, lambda x: x**2, lambda x: x % 2 == 0)\n        220\n        >>> condition_specific_summation(5, lambda x: x, lambda x: x % 2 != 0)\n        9\n    \"\"\"\n    import functools\n    return functools.reduce(lambda acc, x: acc + (term_function(x) if condition_function(x) else 0), range(1, n + 1), 0)"
        ],
        [
            "def sum_geometric_sequence(a, r, n):\n    \"\"\" \n    Calculate the sum of the first n terms of a geometric sequence, provided that r is not 1.\n    \n    Parameters:\n        a (int or float): First term of the sequence.\n        r (int or float): Common ratio of the sequence.\n        n (int): Number of terms to sum.\n    Returns:\n        int or float: The sum of the first n terms of the geometric sequence.\n    Examples:\n        >>> sum_geometric_sequence(1, 2, 4)\n        15\n    \"\"\"\n    if r == 1:\n        return n * a\n    else:\n        return a * (1 - r ** n) / (1 - r)",
            "def sum_geometric_series(a, r, n):\n    \"\"\"\n    Calculate the sum of the first n terms of a geometric series.\n    Parameters:\n    a (float): First term of the series.\n    r (float): Common ratio of the series.\n    n (int): Number of terms to sum.\n    Returns:\n    float: Sum of the first n terms.\n    \n    Examples:\n    >>> sum_geometric_series(1, 2, 3)\n    7\n    \"\"\"\n    if r == 1:\n        return n * a\n    else:\n        return a * (r**n - 1) / (r - 1)",
            "def geometric_series_sum(a, r, n):\n    \"\"\"\n    Computes the sum of the first n terms of a geometric series.\n    \n    Parameters:\n    a : float\n        The first term of the geometric series.\n    r : float\n        The common ratio between terms of the geometric series.\n    n : int\n        The number of terms to sum.\n        \n    Returns:\n    float\n        The sum of the first n terms of the geometric series if r != 1, else returns n*a.\n    \n    Example:\n    >>> geometric_series_semt(3, 2, 10)  # Sum of the first 10 terms for 3 * 2^i for i=0 to 9\n    3069.0\n    \"\"\"\n    if r != 1:\n        return a * (1 - r**n) / (1 - r)\n    else:\n        return a * n",
            "def compute_geometric_sum(a, r, n):\n    \"\"\"\n    Compute the sum of the first `n` terms of a geometric sequence.\n    \n    Parameters:\n        a (int or float): The first term of the sequence.\n        r (int or float): The common ratio between consecutive terms.\n        n (int): The number of terms to sum.\n    Returns:\n        int or float: The sum of the first `n` terms of the geometric sequence.\n    Examples:\n        >>> compute_geometric_sum(1, 2, 10)\n        1023\n        >>> compute_geometric_sum(3, 3, 3)\n        39\n    \"\"\"\n    if r == 1:\n        return a * n\n    else:\n        return a * (r**n - 1) / (r - 1)",
            "def sum_geometric_series(a, r, n):\n    \"\"\"\n    Calculates the sum of a geometric series.\n    Parameters:\n    - a : float or int\n        The first term of the geometric series.\n    - r : float or int\n        The common ratio between terms.\n    - n : int\n        The number of terms.\n    Returns:\n    - float : the sum of the geometric series\n    Examples:\n    - sum_geometric_series(1, 2, 3) calculates the sum of the series 1, 2, 4.\n    \"\"\"\n    if r == 1:\n        return a * n\n    else:\n        return a * (r**n - 1) / (r - 1)",
            "def geometric_series_sum(a, r, n):\n    \"\"\"\n    Calculate the sum of the first `n` terms of a geometric series.\n    Parameters:\n        a (int or float): The first term of the geometric series.\n        r (int or float): The common ratio in the geometric series.\n        n (int): The number of terms to sum.\n    Returns:\n        int or float: The sum of the first `n` terms of the geometric series if `r` != 1,\n                      otherwise returns `n * a`.\n    Examples:\n        >>> geometric_series_sum(1, 2, 3)\n        7\n        >>> geometric_series_sum(3, 3, 2)\n        12\n    \"\"\"\n    if r == 1:\n        return n * a\n    else:\n        return a * (1 - r ** n) / (1 - r)",
            "def finite_geometric_series_sum(a, r, n):\n    \"\"\"\n    Calculate the sum of the first n terms of a finite geometric series.\n    Parameters:\n    a : float\n        The first term of the series.\n    r : float\n        The common ratio of the series.\n    n : int\n        The number of terms to sum.\n    Returns:\n    float\n        The sum of the first n terms.\n    Examples:\n    >>> finite_geometric_series_sum(1, 2, 3)\n    7\n    \"\"\"\n    if r == 1:\n        return n * a\n    else:\n        return a * (1 - r ** n) / (1 - r)",
            "def geometric_sequence_sum(a, r, n):\n    \"\"\"\n    Calculate the sum of the first 'n' terms of a geometric sequence.\n    \n    Parameters:\n    - a (int/float/symbolic): The first term of the geometric sequence.\n    - r (int/float/symbolic): The common ratio between terms of the geometric sequence.\n    - n (int/symbolic): The number of terms to sum.\n    Returns:\n    - symbolic expression/number: Sum of the first 'n' terms of the geometric sequence if r != 1, else n*a.\n    Example:\n    >>> geometric_sequence_sum(1, 2, 4)\n    15\n    \"\"\"\n    if r == 1:\n        return n * a\n    else:\n        return a * (1 - r**n) / (1 - r)",
            "def geometric_sum(a, r, n):\n    \"\"\"\n    Calculates the sum of the first n terms of a geometric sequence.\n    \n    Parameters:\n        a (float): The first term of the geometric sequence.\n        r (float): The common ratio of the sequence.\n        n (int): The number of terms to include in the sum.\n    Returns:\n        float: The sum of the first n terms of the geometric sequence.\n    Examples:\n        >>> geometric_sum(1, 2, 3)  # 1 + 2 + 4\n        7.0\n        >>> geometric_test(3, 3, 4)  # 3 + 9 + 27 + 81\n        120.0\n    \"\"\"\n    if r == 1:\n        return a * n\n    else:\n        return a * (r**n - 1) / (r - 1)",
            "def sum_geometric_series(a, r, n):\n    \"\"\"\n    Calculate the sum of a geometric series.\n    Parameters:\n    - a: number, the first term of the geometric series.\n    - r: number, the common ratio of the series.\n    - n: int, the number of terms to sum up.\n    Returns:\n    - The sum of the first `n` terms of the geometric series.\n    Examples:\n    >>> sum_geometric_series(1, 2, 10)\n    1023\n    \"\"\"\n    # S_n = a * (1 - r^n) / (1 - r)\n    return a * ((1 - r**n) / (1 - r))",
            "def sum_of_geometric_sequence(a, r, n):\n    \"\"\"\n    Calculate the sum of the first n terms of a geometric sequence.\n    Parameters:\n        a (float) : The first term of the sequence.\n        r (float) : The common ratio of the sequence.\n        n (int)   : The number of terms to sum.\n    Returns:\n        float: The sum of the first n terms of the geometric sequence.\n    Examples:\n        >>> sum_of_geometric_sequence(2, 3, 4)\n        80\n    \"\"\"\n    if r == 1:\n        return a * n\n    else:\n        return a * (1 - r ** n) / (1 - r)"
        ],
        [
            "def arithmetic_sequence(a, d, n):\n    \"\"\" \n    Calculate the n-th term of an arithmetic sequence.\n    \n    Parameters:\n        a (int or float): First term of the sequence.\n        d (int or float): Common difference of the sequence.\n        n (int): The term number to calculate.\n    Returns:\n        int or float: The n-th term of the arithmetic sequence.\n    Examples:\n        >>> arithmetic_sequence(1, 2, 5)\n        9\n    \"\"\"\n    return a + (n - 1) * d",
            "def nth_term_arithmetic_series(a1, d, n):\n    \"\"\"\n    Calculate the nth term of an arithmetic series.\n    Parameters:\n    a1 (float): First term of the series.\n    d (float): Common difference in the series.\n    n (int): Term position to calculate.\n    Returns:\n    float: Value of the nth term.\n    \n    Examples:\n    >>> nth_term_arithmetic_series(1, 2, 5)\n    9\n    \"\"\"\n    return a1 + (n - 1) * d",
            "def nth_term_of_arithmetic_sequence(a1, d, n):\n    \"\"\"\n    Calculate the nth term of an arithmetic sequence.\n    Parameters:\n    - a1 (int, float, or sympy.Symbol): first term of the arithmetic sequence.\n    - d (int, float, or sympy.Symbol): common difference of the arithmetic sequence.\n    - n (int): term position to calculate.\n    \n    Returns:\n    - nth_term (int, float, or sympy.Expression): The nth term of the sequence.\n    Example:\n    >>> nth_term_of_arithmetic_sequence(1, 2, 5)\n    9\n    \"\"\"\n    return a1 + (n - 1) * d",
            "def nth_term_arithmetic_sequence(a, n, d):\n    \"\"\"\n    Calculate the nth term of an arithmetic sequence.\n    Parameters:\n    - a (Numerical): The first term of the sequence.\n    - n (Integer): The term index (1-based index, i.e., `n=1` for the first term).\n    - d (Numerical): The common difference between consecutive terms of the sequence.\n    Returns:\n    - Numerical: Value of the nth term in the arithmetic sequence.\n    Examples:\n    >>> nth_term_arithmetic_sequence(5, 3, 2)\n    9\n    \"\"\"\n    return a + (n - 1) * d",
            "def sum_of_terms_arithmetic_sequence(a, n, d):\n    \"\"\"\n    Calculate the sum of the first n terms of an arithmetic sequence.\n    Parameters:\n    - a (Numerical): The first term of the sequence.\n    - n (Integer): The number of terms to sum.\n    - d (Numerical): The common difference between consecutive terms of the sequence.\n    Returns:\n    - Numerical: Sum of the first n terms of the sequence.\n    Examples:\n    >>> sum_of_terms_arithmetic_sequence(5, 3, 2)\n    21\n    \"\"\"\n    last_term = nth_term_arithmetic_sequence(a, n, d)\n    return n * (a + last_term) / 2",
            "def arithmetic_term(a, d, n):\n    \"\"\"\n    Calculates the nth term of an arithmetic sequence.\n    Parameters:\n        a (float): The first term of the arithmetic sequence.\n        d (float): The common difference of the sequence.\n        n (int): The term number to find.\n    Returns:\n        float: The nth term of the sequence.\n    Examples:\n        >>> arithmetic_term(1, 1, 5)\n        5.0\n        >>> arithmetic_term(3, 2, 4)\n        9.0\n    \"\"\"\n    return a + (n-1) * d"
        ],
        [
            "def common_difference_arithmetic_sequence(term1, nth_term, n):\n    \"\"\"\n    Determine the common difference in an arithmetic sequence.\n    Parameters:\n    - term1 (Numerical): The first term of the sequence or any known term.\n    - nth_term (Numerical): The nth term of the sequence.\n    - n (Integer): The difference in nth from term1 (n-1 if term1 is the first term).\n    Returns:\n    - Numerical: The common difference of the sequence.\n    Examples:\n    >>> common_difference_arithmetic_sequence(5, 11, 4)\n    2\n    \"\"\"\n    return (nth_term - term1) / (n - 1)",
            "def nth_term_arithmetic_sequence(first_term, common_difference, n):\n    \"\"\"\n    Calculate the nth term of an arithmetic sequence.\n    Parameters:\n    first_term (int/float/sympy.Symbol): The first term of the sequence.\n    common_difference (int/float/sympy.Symbol): The common difference of the sequence.\n    n (int/sympy.Symbol): The term number to find.\n    Returns:\n    int/float/sympy.Expr: The nth term of the sequence.\n    \n    Examples:\n    >>> nth_term_arithmetic_sequence(2, 3, 4)\n    11\n    >>> nth_term_arithmetic_sequence(sp.Symbol('a'), 3, sp.Symbol('n'))\n    a + 3*(n - 1)\n    \"\"\"\n    return first_term + (n - 1) * common_difference",
            "def arithmetic_sequence_sum(first_term, common_difference, n):\n    \"\"\"\n    Calculate the sum of the first n terms of an arithmetic sequence.\n    Parameters:\n    first_term (int/float/sympy.Symbol): The first term of the sequence.\n    common_difference (int/float/sympy.Symbol): The common difference of the sequence.\n    n (int/sympy.Symbol): The number of terms to sum.\n    Returns:\n    int/float/sympy.Expr: The sum of the first n terms of the sequence.\n    \n    Examples:\n    >>> arithmetic_sequence_sum(2, 3, 4)\n    20\n    >>> arithmetic_sequence_sum(sp.Symbol('a'), 3, sp.Symbol('n'))\n    n/2*(2*a + (n - 1)*3)\n    \"\"\"\n    last_term = nth_term_arithmetic_sequence(first_term, common_difference, n)\n    return n * (first_term + last_term) / 2"
        ],
        [
            "def product_of_sequence(seq):\n    \"\"\"\n    Calculate the product of a sequence of terms.\n    Parameters:\n    - seq (list/sympy Matrix): The sequence of terms to multiply.\n    Returns:\n    - symbolic expression/number: Product of the terms in the sequence.\n    Example:\n    >>> product_of_sequence([1, 2, 3, 4])\n    24\n    \"\"\"\n    return sp.prod(seq)"
        ],
        [
            "def sequence_sum(sequence):\n    \"\"\"\n    Calculates the sum of a sequence.\n    \n    Parameters:\n    - sequence: list. A list of numerical values representing a sequence.\n    \n    Returns:\n    - float or int. The sum of the sequence.\n    \n    Examples:\n    - sequence_sum([1, 2, 3, 4, 5]) --> 15\n    - sequence_sum([n**2 for n in range(1, 11)]) --> 385 (sum of squares of first 10 natural numbers)\n    \"\"\"\n    return sum(sequence)"
        ],
        [
            "def find_common_ratio(term1, term2, position1=1, position2=2):\n    \"\"\"\n    Calculate the common ratio of a geometric sequence given two terms.\n    Parameters:\n    term1 : float\n        The value of the term at position1.\n    term2 : float\n        The value of the term at position2.\n    position1 : int, optional\n        The position of 'term1' in the sequence (default is 1).\n    position2 : int, optional\n        The position of 'term2' in the sequence (default is 2).\n    Returns:\n    float\n        The common ratio of the sequence.\n    Examples:\n    >>> find_common_profile(3, 12, 1, 2)\n    4.0\n    \"\"\"\n    return (term2 / term1) ** (1 / (position2 - position1))"
        ],
        [
            "def simplify_factorial_expression(expr):\n    \"\"\"\n    Simplifies expressions involving factorials, making use of algebraic identities.\n    Parameters:\n    - expr (string/symbolic expression): The factorial expression to simplify.\n    Returns:\n    - symbolic expression: Simplified expression.\n    Example:\n    >>> simplify_factorial_expression(\"n!/(n-1)!\")\n    n\n    \"\"\"\n    expr = sp.sympify(expr)\n    return sp.simplify(expr)"
        ],
        [
            "def general_summation(function, start, end):\n    \"\"\"\n    Calculate the sum of a sequence where each term is defined by a function.\n    Parameters:\n    - function: callable, the function defining the terms. Must accept one argument.\n    - start: int, the starting value of the index.\n    - end: int, the ending value of the index.\n    Returns:\n    - The sum of the function values from `start` to `end`.\n    Examples:\n    >>> general_summation(lambda x: x**2, 1, 100)\n    338350\n    \"\"\"\n    return sum(function(x) for x in range(start, end + 1))"
        ],
        [
            "def binomial_coefficient(n, k):\n    \"\"\"\n    Compute the binomial coefficient C(n, k) which is \"n choose k\".\n    \n    Parameters:\n        n (int): The total number of items.\n        k (int): The number of items to choose.\n    Returns:\n        int: The binomial coefficient.\n    Examples:\n        >>> binomial_coefficient(5, 2)\n        10\n        >>> binomial_coefficient(10, 3)\n        120\n    \"\"\"\n    return binomial(n, k)",
            "def binomial_coefficient(n, k):\n    \"\"\"\n    Calculate the binomial coefficient \"n choose k\", which is n! / (k! (n-k)!).\n    Parameters:\n    - n (int/symbolic): The total number of items.\n    - k (int/symbolic): The number of items to choose.\n    Returns:\n    - int/symbolic expression: Binomial coefficient.\n    Example:\n    >>> binomial_coefficient(5, 2)\n    10\n    \"\"\"\n    return sp.binomial(n, k)"
        ],
        [
            "def geometric_sequence(a, r, n):\n    \"\"\" \n    Calculate the n-th term of a geometric sequence.\n    \n    Parameters:\n        a (int or float): First term of the sequence.\n        r (int or float): Common ratio of the sequence.\n        n (int): The term number to calculate.\n    Returns:\n        int or float: The n-th term of the geometric sequence.\n    Examples:\n        >>> geometric_sequence(1, 2, 4)\n        8\n    \"\"\"\n    return a * (r ** (n - 1))",
            "def geometric_term(a, r, n):\n    \"\"\"\n    Calculate the nth term of a geometric sequence.\n    \n    Parameters:\n        a (float): The first term of the sequence.\n        r (float): The common ratio of the sequence.\n        n (int): The term number to find (1-based index).\n    \n    Returns:\n        float: The nth term of the geometric sequence.\n    Examples:\n        >>> geometric_term(2, 3, 4)\n        54\n        >>> geometric_term(5, 0.5, 3)\n        1.25\n    \"\"\"\n    return a * r ** (n - 1)",
            "def compute_nth_term(a, r, n):\n    \"\"\"\n    Compute the nth term of a geometric sequence.\n    Parameters:\n    a : float\n        The first term of the geometric sequence.\n    r : float\n        The common ratio of the geometric sequence.\n    n : int\n        The term number to compute.\n    Returns:\n    float\n        The nth term of the sequence.\n    Examples:\n    >>> compute_nth_term(2, 3, 4)\n    54\n    \"\"\"\n    return a * r ** (n - 1)",
            "def nth_term_geometric_sequence(a, r, n):\n    \"\"\"\n    Calculate the nth term of a geometric sequence.\n    Parameters:\n        a (float) : The first term of the sequence.\n        r (float) : The common ratio of the sequence.\n        n (int)   : The term number to calculate.\n    Returns:\n        float: The nth term of the geometric sequence.\n    Examples:\n        >>> nth_term_geometric_with_sequence(3, 2, 4)\n        24\n    \"\"\"\n    return a * r ** (n - 1)"
        ],
        [
            "def solve_geometric_sequence_given_terms(term1, term2, n):\n    \"\"\"\n    Given two terms of a geometric sequence, find the nth term.\n    Parameters:\n        term1 (tuple): The first term and its position, (first_term_value, position).\n        term2 (tuple): The second term and its position, (second_term_value, position).\n        n (int)    : The term number to find.\n    Returns:\n        float: The value of the nth term.\n    Examples:\n        >>> solve_geometric_sequence_given_terms((2, 1), (8, 3), 5)\n        32\n    \"\"\"\n    a1, pos1 = term1\n    a2, pos2 = term2\n    r = (a2 / a1) ** (1 / (pos2 - pos1))\n    nth_value = nth_term_geometric_sequence(a1, r, n)\n    return nth_value"
        ],
        [
            "def find_common_difference(term1, term2, gap=1):\n    \"\"\"\n    Determine the common difference of an arithmetic sequence given two terms.\n    Parameters:\n    term1 (int/float): The value of one known term.\n    term2 (int/float): The value of another known term.\n    gap (int): The step difference in terms of the number of terms between term1 and term2.\n    Returns:\n    int/float: The common difference.\n    \n    Examples:\n    >>> find_common_difference(2, 8, 2)\n    3\n    >>> find_common_difference(5, 11, 3)\n    2\n    \"\"\"\n    return (term2 - term1) / gap"
        ],
        [
            "def sum_constrained_integer_solutions(f, a, b):\n    \"\"\"\n    Computes the sum of all integer solutions to a function f within the interval [a, b].\n    \n    Parameters:\n    f : function\n        A function f(x) to be evaluated.\n    a : int\n        The lower bound of the interval.\n    b : int\n        The upper bound of the interval.\n        \n    Returns:\n    int\n        The sum of all integer solutions to f(x)=0 within [a, b].\n    \n    Examples:\n    >>> sum_constrained_integer_solutions(lambda x: x**2 - 4, -10, 10)\n    0  # Since the solutions x=2 and x=-2 sum to 0\n    \n    Note:\n    Simplicity in this example assumes solving f(x)=0 symbolically is possible.\n    \"\"\"\n    x = symbols('x')\n    solutions = solve(f, x)\n    filtered_solutions = [s.evalf() for s in solutions if s.is_integer and a <= s <= b]\n    return sum(filtered_solutions) if filtered_solutions else 0"
        ],
        [
            "def sequence_sum_and_analyze(sequence, property_func):\n    \"\"\"\n    Sum a given sequence and analyze it based on a supplied function, typically to check properties such as being arithmetic.\n    Parameters:\n    sequence (list): The sequence to analyze and sum.\n    property_func (function): A function that takes the sequence and returns some property.\n    Returns:\n    dict: Dictionary containing the sum of the sequence and its analyzed property.\n    \n    Example:\n    # Given an arithmetic sequence\n    result = sequence_sum_and_analyze([1, 5, 9, 13], lambda seq: (seq[1]-seq[0] == seq[-1]-seq[-2]))\n    \"\"\"\n    sum_sequence = sum(sequence)\n    property_output = property_func(sequence)\n    return {'sum': sum_sequence, 'property': property_output}"
        ],
        [
            "def find_term(sequence, condition):\n    \"\"\"\n    Finds a term in the sequence that satisfies a given condition.\n    \n    Parameters:\n    - sequence: list. A list of terms of the sequence.\n    - condition: function. A function that returns True if the condition is met.\n    \n    Returns:\n    - element or None. The first element that meets the condition or None if none found.\n    \n    Examples:\n    - find_term([1, 2, 3, 4, 5], lambda x: x > 3) --> 4\n    \"\"\"\n    for element in sequence:\n        if condition(element):\n            return element\n    return None"
        ],
        [
            "def geometric_sequence_properties(a, r, terms):\n    \"\"\"\n    Calculate a set of properties for a geometric sequence up to a given number of terms.\n    Parameters:\n        a (float) : The first term of the sequence.\n        r (float) : The common ratio of the sequence.\n        terms (int): Number of terms to consider.\n    Returns:\n        dict: Properties including individual terms, sum of terms, and if applicable, the sum of the infinite series.\n    \n    Examples:\n        >>> geometric_sequence_properties(2, 2, 3)\n        {'terms': [2, 4, 8], 'sum': 14}\n    \"\"\"\n    terms_list = [nth_term_geometric_sequence(a, r, i + 1) for i in range(terms)]\n    sum_n_terms = sum_of_geometric_sequence(a, r, terms)\n    properties = {\n        'terms': terms_list,\n        'sum': sum_n_terms\n    }\n    if abs(r) < 1:\n        properties['infinite_sum'] = infinite_geometric_series_sum(a, r)\n    return properties"
        ],
        [
            "def compute_factorial_product(n):\n    \"\"\"\n    Compute the factorial of `n`.\n    Parameters:\n        n (int): The number at which the factorial is to be computed.\n    Returns:\n        int: The factorial of `n`.\n    Examples:\n        >>> compute_factorial_product(5)\n        120\n        >>> compute_factorial_product(3)\n        6\n    \"\"\"\n    return factorial(n)"
        ]
    ],
    "Radicals and Root Operations": [
        [
            "def simplify_radical(expression):\n    \"\"\"\n    Simplifies an expression involving radicals, especially square roots.\n    Parameters:\n    expression (str): A string representation of the mathematical expression to be simplified.\n    Returns:\n    str: A simplified version of the input expression.\n    Examples:\n    >>> simplify_radical('sqrt(24)')\n    '2*sqrt(6)'\n    >>> simplify_radical('sqrt(8) + sqrt(18)')\n    '5*sqrt(2)'\n    \n    \"\"\"\n    expr = sp.sympify(expression)\n    simplified_expr = sp.simplify(expr)\n    return str(simplified_expr)",
            "def simplify_sqrt(expression):\n    \"\"\"\n    Simplifies expressions involving square roots using sympy's simplification utilities.\n    Parameters:\n    expression (str): A string representing a mathematical expression possibly involving square roots.\n    Returns:\n    sympy.Expr: A sympy expression object which has been simplified.\n    Examples:\n    >>> simplify_sqrt('sqrt(8)')\n    2*sqrt(2)\n    >>> simplify_sqrt('sqrt(18)/sqrt(2)')\n    3*sqrt(2)\n    \"\"\"\n    # Parse the expression\n    expr = sympy.sympify(expression)\n    \n    # Simplify the square root\n    simplified_expr = sympy.simplify(expr)\n    \n    return simplified_expr",
            "def evaluate_and_simplify_radicals(expression):\n    \"\"\"\n    Evaluates and simplifies expressions involving radicals (square roots).\n    \n    Parameters:\n        expression (str): A string representation of the mathematical expression to be evaluated and simplified.\n    \n    Returns:\n        sympy.Expr: A simplified symbolic expression with radicals simplified where possible.\n    Example:\n        >>> evaluate_and_simplify_radicals('sqrt(8) + sqrt(2)')\n        3*sqrt(2)\n    \"\"\"\n    # Parse the expression into a sympy expression\n    expr = sp.sympify(expression)\n    \n    # Simplify the radicals within the expression\n    simplified_expr = sp.simplify(expr)\n    \n    return simplified_expr",
            "def simplify_radical_expression(expression):\n    \"\"\"\n    Simplify an expression involving radicals.\n    Parameters:\n        expression (sympy.Expr): The expression to simplify that involves radicals.\n        \n    Returns:\n        sympy.Expr: The simplified expression.\n    Examples:\n        >>> simplify_radical_expression(sp.sqrt(8))\n        2*sqrt(2)\n        >>> simplify_radical_expression(sp.sqrt(50) + sp.sqrt(18))\n        8 * sqrt(2)\n    \"\"\"\n    return sp.simplify(expression)",
            "def simplify_radical(expression):\n    \"\"\"\n    Simplifies a radical expression.\n    \n    Parameters:\n        expression (str): The radical expression as a string.\n    \n    Returns:\n        sp.Expr: Simplified radical expression.\n    \n    Examples:\n        >>> simplify_radical('sqrt(8)')\n        2*sqrt(2)\n        \n        >>> simplify_radical('sqrt(72) - sqrt(18)')\n        3*sqrt(2)\n    \"\"\"\n    expr = sp.sympify(expression)\n    return sp.simplify(expr)",
            "def simplify_radical(expression):\n    \"\"\"\n    Simplify expressions involving radicals.\n    Parameters:\n    - expression (str): The string representation of the mathematical expression \n      involving radicals that needs to be simplified.\n    Returns:\n    - sympy.Expr: The simplified expression.\n    Examples:\n    - simplify_radical(\"sqrt(8)\")\n    - simplify_radical(\"sqrt(x^2 * y^2)\")\n    \"\"\"\n    x, y = symbols('x y')  # Extend symbols as needed for more variables\n    simplified_expr = simplify(expression)\n    return simplified_expr",
            "def simplify_nested_radicals(expression):\n    \"\"\"\n    Simplify expressions involving nested radicals.\n    Parameters:\n    - expression (str): The string representation of the expression with nested radicals.\n    Returns:\n    - sympy.Expr: The simplified expression.\n    Examples:\n    - simplify_nested_radicals(\"sqrt(2 + sqrt(2))\")\n    - simplify_nested_radicals(\"sqrt(sqrt(x) + sqrt(y))\")\n    \"\"\"\n    x, y = symbols('x y')  # Extend symbols as needed for more variables\n    simplified_expr = simplify(expression)\n    return simplified_expr",
            "def simplify_radical_expression(expr):\n    \"\"\"\n    Simplifies radical expressions including the simplification of square roots of products, quotients,\n    additions, and subtractions.\n    \n    Parameters:\n    expr (str or sympy expression): The radical expression to be simplified; can be a string or a Sympy expression.\n    \n    Returns:\n    sympy expression: The simplified radical expression.\n    \n    Examples:\n    >>> simplify_radical_expression('sqrt(a*b)')\n    sqrt(a)*sqrt(b)\n    \n    >>> simplify_radical_expression('sqrt(a/b)')\n    sqrt(a)/sqrt(b)\n    \n    >>> simplify_radical_expression('sqrt(a)+sqrt(b) - sqrt(a)')\n    sqrt(b)\n    \"\"\"\n    expr = sp.sympify(expr)  # Convert input to a sympy expression if it's not already\n    return sp.simplify(expr)  # Use sympy's simplify function to handle radical simplification",
            "def simplify_radical_expression(expr):\n    \"\"\"\n    Simplifies an expression involving radicals.\n    Parameters:\n        expr (str): The string of the mathematical expression to simplify, involving radicals.\n    Returns:\n        sympy expression: The simplified version of the input expression.\n    Examples:\n        >>> simplify_radical_expression(\"sqrt(a^2) + sqrt(b^2)\")\n        'Abs(a) + Abs(b)'\n        >>> simplify_radical_expression(\"sqrt(a)*sqrt(b)\")\n        'sqrt(a*b)'\n    \"\"\"\n    x = symbols('x')\n    a, b = symbols('a b')\n    return simplify(expr)",
            "def simplify_radical_expression(expr):\n    \"\"\"\n    Simplifies an expression containing radicals.\n    \n    Parameters:\n        expr (str): A symbolic expression containing radicals.\n    \n    Returns:\n        sympy.Expr: Simplified expression.\n    \n    Examples:\n        >>> simplify_radical_expression('sqrt(x**2 + 2*x + 1)')\n        x + 1\n    \"\"\"\n    x = sp.symbols('x')\n    return sp.simplify(sp.sympify(expr))",
            "def simplify_radical(expression):\n    \"\"\"\n    Simplify and rationalize expressions involving radicals.\n    Parameters:\n    - expression (sympy expression): The radical expression to be simplified and rationalized.\n    \n    Returns:\n    - sympy expression: The simplified and rationalized form of the input expression.\n    Examples:\n    >>> simplify_radical(sp.sqrt(8))\n    2*sqrt(2)\n    >>> simplify_radical(sp.sqrt(18)/sp.sqrt(2))\n    3*sqrt(2)\n    >>> simplify_radical(sp.Rational(1, sp.sqrt(2)))\n    sqrt(2)/2\n    \"\"\"\n    expr = sp.simplify(expression)\n    expr = sp.radsimp(expr)\n    return expr",
            "def simplify_square_root_expression(expression):\n    \"\"\"\n    Simplify an expression involving square roots.\n    Parameters:\n        expression (str): A mathematical expression as a string involving square roots.\n    Returns:\n        sympy expression: The simplified version of the expression.\n    Examples:\n        >>> simplify_square_root_expression('sqrt(24)')\n        2*sqrt(6)\n        >>> simplify_square_root_expression('2*sqrt(50) + 3*sqrt(8)')\n        10*sqrt(2) + 6*sqrt(2)\n    \"\"\"\n    expr = sp.sympify(expression)\n    simplified_expr = sp.simplify(expr)\n    return simplified_expr",
            "def simplify_expression(expr):\n    \"\"\"\n    Simplifies an expression involving radicals or any other algebraic expression.\n    Parameters:\n    - expr: The mathematical expression in string format to be simplified.\n    Returns:\n    - A simplified version of the input expression.\n    Example:\n    >>> simplify_expression('sqrt(8) + sqrt(18)')\n    '5*sqrt(2)'\n    >>> simplify_expression('cube_root(27) + cube_root(8)')\n    '5'\n    \"\"\"\n    # Convert input string to a symbolic expression\n    expr_sympy = sp.sympify(expr.replace(\"sqrt\", \"sp.sqrt\").replace(\"cube_root\", \"sp.cbrt\"))\n    # Simplify the expression\n    simplified_expr = sp.simplify(expr_sympy)\n    # Return the simplified expression as a string\n    return str(simplified_expr)",
            "def simplify_radical(expression):\n    \"\"\"\n    Simplifies radical expressions including square roots, and rationalizes the denominator if needed.\n    Parameters:\n    - expression (str or sympy.Expression): The radical expression to be simplified. Can be input as a string\n        (e.g., 'sqrt(8)/sqrt(2)') or directly as a sympy expression.\n    Returns:\n    - sympy.Expr: The simplified form of the input expression.\n    Examples:\n    >>> simplify_radical('sqrt(8)/sqrt(2)')\n    2\n    >>> simplify_radical('sqrt(18) * sqrt(2)')\n    6 * sqrt(2)\n    >>> simplify_radical('1/sqrt(5)')\n    sqrt(5)/5\n    \"\"\"\n    # Convert input to sympy expression if it's a string\n    if isinstance(expression, str):\n        expression = sp.sympify(expression)\n    \n    # Simplify the expression using sympy's simplification which automatically rationalizes denominators\n    simplified_expression = sp.simplify(expression)\n    \n    return simplified_expression",
            "def combine_radicals(expression):\n    \"\"\"\n    Simplifies expressions involving the addition and subtraction of square roots.\n    Parameters:\n    - expression (str or sympy.Expression): The radical expression to be simplified involving addition or subtraction.\n    Returns:\n    - sympy.Expr: The simplified form of the input radical expression.\n    Examples:\n    >>> combine_radicals('sqrt(27) + 2*sqrt(3)')\n    5*sqrt(3)\n    >>> combine_radicals('sqrt(50) - sqrt(18)')\n    4*sqrt(2)\n    \"\"\"\n    # Convert input to sympy expression if it's a string\n    if isinstance(expression, str):\n        expression = sp.sympify(expression)\n    \n    # Expand and simplify the expression to combine like terms\n    simplified_expression = sp.simplify(sp.expand(expression))\n    \n    return simplified_expression",
            "def simplify_radical_expression(expression):\n    \"\"\"\n    Simplifies an expression containing radicals.\n    Parameters:\n    - expression (str): The mathematical expression as a string that may include radicals (e.g., 'sqrt(x) + sqrt(x)')\n    Returns:\n    - sympy.Expr: The simplified expression with radicals.\n    Example:\n    >>> simplify_radical_expression('sqrt(x) + sqrt(x)')\n    2*sqrt(x)\n    \"\"\"\n    expr = sp.sympify(expression)\n    simplified_expr = sp.simplify(expr)\n    return simplified_expr",
            "def simplify_radical(expression):\n    \"\"\"\n    Simplifies a radical expression using the sympy library.\n    Parameters:\n    - expression (str): The radical expression to be simplified, input as a string.\n    Returns:\n    - simplified_expr (sympy expression): The simplified version of the input expression.\n    Examples:\n    >>> simplify_radical('sqrt(24)')\n    2*sqrt(6)\n    >>> simplify_radical('sqrt(x**2 + 2*x + 1)')\n    x + 1\n    \"\"\"\n    # We allow sympy to understand the expression by converting it from string\n    sympy_expr = simplify(expression)\n    # Simplify and return the radical expression\n    return simplify(sympy_expr)",
            "def radical_simplifier(expression):\n    \"\"\"\n    Simplify expressions involving radicals (roots) using sympy.\n    \n    Parameters:\n    - expression (str): A string expression which includes radicals to be simplified.\n    \n    Returns:\n    - sp.Expr: Simplified sympy expression involving radicals.\n    \n    Examples:\n    >>> radical_simplifier(\"sqrt(24) * sqrt(6)\")\n    2*sqrt(6)*sqrt(6)  # Simplifies to 12\n    \n    >>> radical_simplifier(\"sqrt(18) + sqrt(8)\")\n    3*sqrt(2) + 2*sqrt(2)  # Simplifies to 5*sqrt(2)\n    \"\"\"\n    expr = sp.sympify(expression)\n    simplified_expr = sp.simplify(expr)\n    return simplified_expr"
        ],
        [
            "def solve_equation_with_radicals(equation, variable_str='x'):\n    \"\"\"\n    Solves equations involving radicals by isolating radicals, squaring both sides to eliminate them, and solving the resulting equation.\n    \n    Parameters:\n        equation (str): The equation in string format with a radical to be solved.\n        variable_str (str): The main variable of the equation as a string.\n    \n    Returns:\n        list: A list of solutions to the equation. Includes checks for extraneous solutions.\n        \n    Example:\n        >>> solve_equation_with_radicals('sqrt(x) + 1 = 5', 'x')\n        [16]\n    \"\"\"\n    variable = sp.symbols(variable_str)\n    equation = sp.sympify(equation.replace('=', '-(') + ')')  # Convert to sympy equation (0 on one side)\n    \n    # Try to isolate the root and square both sides\n    isolated_eq = sp.solve(equation, variable, dict=True)\n    \n    # We square both sides, assuming only one root term is isolated on one side\n    squared_eq = [eq[variable]**2 for eq in isolated_eq]\n    \n    # Solve the squared equations\n    solutions = set()\n    for eq in squared_eq:\n        sols = sp.solveset(eq, variable)\n        for sol in sols:\n            # We substitute back into original equation to avoid extraneous solutions\n            if sp.simplify(equation.subs(variable, sol)) == 0:\n                solutions.add(sol)\n    return list(solutions)",
            "def solve_square_root_equations(equation, variable):\n    \"\"\"\n    Solves an equation involving square roots. This function assumes the equation is equated to zero.\n    Parameters:\n    equation (str or sympy expression): The equation to solve which involves square roots.\n    variable (str): The variable to solve for as a string.\n    \n    Returns:\n    list of sympy expressions: Solutions to the equation.\n    \n    Examples:\n    >>> solve_square_root_equations('sqrt(x) + 1 = 5', 'x')\n    [16]\n    \n    >>> solve_square_root_equations('sqrt(x) = x - 2', 'x')\n    [1 + sqrt(5), 1 - sqrt(5)]\n    \"\"\"\n    var = sp.symbols(variable)\n    equation = sp.sympify(equation).subs('=',' - ') + ' = 0'  # Correctly format the equation\n    return sp.solve(equation, var)  # Solve the equation",
            "def solve_radical_equation(equation, variable='x'):\n    \"\"\"\n    Solves an equation that involves radicals by first isolating the radical\n    on one side, then squaring both sides to eliminate the radical, and solving normally.\n    \n    Parameters:\n        equation (str): The equation to solve.\n        variable (str): The primary variable for which to solve the equation.\n        \n    Returns:\n        list: Solutions to the equation.\n        \n    Examples:\n        >>> solve_radical_equation('sqrt(x+1) + x = 3', 'x')\n        [2]\n    \"\"\"\n    var = sp.symbols(variable)\n    eq = sp.sympify(equation)\n    # Isolate radical and solve\n    radical_side, other_side = sp.collect(eq, sp.sqrt(var), evaluate=False)\n    squared_eq = (radical_side**2 - other_side**2).expand()\n    solutions = sp.solve(squared_eq, var)\n    return [sol.evalf() for sol in solutions]",
            "def solve_equation_with_roots(equation, variable='x'):\n    \"\"\"\n    Solves an algebraic equation involving roots and possibly other algebraic operations.\n    Parameters:\n        equation (str): The algebraic equation to solve written as a string.\n        variable (str): The primary variable in the equation as a string.\n    Returns:\n        list: Solutions to the equation.\n    \n    Examples:\n        >>> solve_equation_with_roots('sqrt(x) - 4 = 0')\n        [16.0]\n        >>> solve_equation_with_roots('sqrt(x**2 - 4) = x - 2')\n        [2.0]\n    \"\"\"\n    x = sp.symbols(variable)\n    equation = sp.sympify(equation.replace('sqrt', 'sp.sqrt'))\n    solutions = sp.solve(equation, x)\n    return [float(sol.evalf()) for sol in solutions if sol.is_real]",
            "def solve_radical_equations(expression, variable):\n    \"\"\"\n    Solves equations involving radicals, primarily through the technique of squaring both sides to eliminate radicals.\n    Parameters:\n    - expression (str): The equation as a string involving radicals (e.g., 'sqrt(x+1) = 3')\n    - variable (str): The variable to solve for (e.g., 'x')\n    Returns:\n    - list: Solutions to the equation, considering potential extraneous solutions.\n    Example:\n    >>> solve_radical_equations('sqrt(x+1) = 3', 'x')\n    [8]\n    \"\"\"\n    x = sp.symbols(variable)\n    expr = sp.sympify(expression)\n    # Move everything to one side of the equation (equals zero format)\n    equation = sp.Eq(expr, 0)\n    # Attempt to solve by isolating the radical and squaring\n    solution = sp.solve(equation, x, dict=True)  # dict=True to see extraneous roots\n    return solution"
        ],
        [
            "def pythagorean_theorem_simplified(a, b=None, c=None):\n    \"\"\"\n    Applies the Pythagorean theorem in a right triangle scenario to find a missing side (a, b, or c) and simplifies the resulting radical if necessary.\n    Parameters:\n    a (float, None): The length of side 'a'. If None, it will be calculated.\n    b (float, None): The length of side 'b'. If None, it will be calculated.\n    c (float, None): The length of the hypotenuse 'c'. If None, it will be calculated.\n    Returns:\n    float: The length of the missing side of the triangle, simplified if necessary.\n    Examples:\n    >>> pythagorean_theorem_simplified(3, 4)\n    5.0\n    >>> pythagorean_theorem_simplified(None, 4, 5)\n    3.0\n    >>> pythagorean_theorem_simplified(3, None, 5)\n    4.0\n    \n    \"\"\"\n    if c is None:\n        c = sp.sqrt(a**2 + b**2)\n    elif a is None:\n        a = sp.sqrt(c**2 - b**2)\n    elif b is None:\n        b = sp.sqrt(c**2 - a**2)\n        \n    result = a if a is not None else b if b is not None else c\n    return float(result) if result.is_Float else int(result.evalf())",
            "def pythagoras_length(a=None, b=None, c=None):\n    \"\"\"\n    Given two sides of a right triangle, calculate the third side using the Pythagorean theorem.\n    The function can find the hypotenuse (c) given sides (a and b), or one side (a or b) given the hypotenuse and the other side.\n    Parameters\n    ----------\n    a : float or int, optional\n        One side of the right triangle.\n    b : float or int, optional\n        The other side of the right triangle.\n    c : float or int, optional\n        The hypotenuse of the right triangle.\n    Returns\n    -------\n    float\n        The length of the unknown side.\n    Raises\n    ------\n    ValueError\n        If insufficient arguments are provided or if any of the provided values are not positive.\n    Examples\n    --------\n    >>> pythagoras_length(3, 4)\n    5.0\n    >>> pythagoras_length(c=5, b=4)\n    3.0\n    \"\"\"\n    if (a is not None and b is not None and c is None):\n        return math.sqrt(a**2 + b**2)\n    elif (c is not None and b is not None and a is None):\n        if c <= b:\n            raise ValueError(\"Hypotenuse must be greater than any other side\")\n        return math.sqrt(c**2 - b**2)\n    elif (c is not None and a is not None and b is None):\n        if c <= a:\n            raise ValueError(\"Hypotenuse must be greater than any other side\")\n        return math.sqrt(c**2 - a**2)\n    else:\n        raise ValueError(\"Invalid or insufficient inputs provided.\")"
        ],
        [
            "def fractional_exponent_converter(expression, to_fractional=True):\n    \"\"\"\n    Convert expressions between radical notation and fractional exponents.\n    Parameters:\n        expression (str): The expression in radical or fractional exponent form.\n        to_fractional (bool): If True, converts radical to fractional exponent, \n                              otherwise converts fractional exponent to radical.\n    Returns:\n        sympy.Expr: The expression converted to the desired form.\n    Examples:\n        >>> fractional_exponent_converter('sqrt(x)', True)\n        x**(1/2)\n        >>> fractional_exponent_converter('x**(1/3)', False)\n        cbrt(x)\n    \"\"\"\n    expr = sp.sympify(expression)\n    if to_fractional:\n        return expr.rewrite(sp.Pow)\n    else:\n        return expr.rewrite(sp.root)",
            "def convert_and_simplify_fractional_exponents(expression):\n    \"\"\"\n    Handle expressions with fractional exponents and convert between radical notation.\n    Parameters:\n    - expression (str): The string representation of the expression with fractional exponents.\n    Returns:\n    - sympy.Expr: The expression with fractional exponents simplified or converted.\n    Examples:\n    - convert_and_simplify_fractional_exponents(\"x**(1/3)\")\n    - convert_and_simplify_fractional_exponents(\"x**(2/3) * y**(1/2)\")\n    \"\"\"\n    x, y = symbols('x y')  # Extend as necessary\n    simplified_expr = simplify(expression)\n    return simplified_expr"
        ],
        [
            "def rationalize_denominator(expression):\n    \"\"\"\n    Rationalizes the denominator of an expression involving square roots.\n    Parameters:\n    expression (str): A string representing a mathematical expression having a square root in the denominator.\n    Returns:\n    sympy.Expr: A sympy expression where the denominator has been rationalized.\n    Examples:\n    >>> rationalize_denominator('1/sqrt(2)')\n    sqrt(2)/2\n    >>> rationalize_denominator('(3 + sqrt(7))/(4*sqrt(3))')\n    (3*sqrt(3) + sqrt(21))/12\n    \"\"\"\n    # Parse the expression\n    expr = sympy.sympify(expression)\n    # Rationalize the denominator\n    rationalized_expr = sympy.radsimp(expr)\n    \n    return rationalized_expr",
            "def rationalize_denominator(expression):\n    \"\"\"\n    Rationalize the denominator of a radical expression.\n    Parameters:\n        expression (sympy.Expr): The expression whose denominator needs to be rationalized.\n    Returns:\n        sympy.Expr: Expression with rationalized denominator.\n    Examples:\n        >>> rationalize_denominator(sp.sqrt(1/sp.Rational(2)))\n        sqrt(2)/2\n    \"\"\"\n    # Use sympy's built-in function\n    return sp.radsimp(expression)",
            "def rationalize_denominator(expression):\n    \"\"\"\n    Rationalizes the denominator of a fraction that involves radicals.\n    \n    Parameters:\n        expression (str): The expression with the radical in the denominator as a string.\n    \n    Returns:\n        sp.Expr: Expression with a rationalized denominator.\n    \n    Examples:\n        >>> rationalize_denominator('1/sqrt(2)')\n        sqrt(2)/2\n        \n        >>> rationalize_denominator('1/(2 + sqrt(3))')\n        2 - sqrt(3)\n    \"\"\"\n    expr = sp.sympify(expression)\n    return sp.radsimp(expr)",
            "def rationalize_denominator(expression):\n    \"\"\"\n    Rationalize the denominator in expressions involving radicals.\n    Parameters:\n    - expression (str): The string representation of the mathematical expression \n      where the denominator needs to be rationalized.\n    Returns:\n    - sympy.Expr: Expression with a rationalized denominator.\n    Examples:\n    - rationalize_denominator(\"1/sqrt(2)\")\n    - rationalize_denominator(\"1/(sqrt(a) + sqrt(b))\")\n    \"\"\"\n    x, a, b = symbols('x a b')  # Extend symbols as needed for more variables\n    expr = simplify(expression)\n    rationalized = expr.apart()\n    return rationalized",
            "def rationalize_denominator(expr):\n    \"\"\"\n    Rationalizes the denominator of a fractional expression involving radicals.\n    \n    Parameters:\n    - expr: The mathematical expression in string format which needs denominator rationalization.\n    Returns:\n    - The expression with a rationalized denominator.\n    Example:\n    >>> rationalize_denominator('1 / (sqrt(2) + sqrt(3))')\n    '-sqrt(3)/5 + sqrt(2)/5 + 1/5'\n    >>> rationalize_denominator('1 / (sqrt(2) + 1)')\n    'sqrt(2)/3 - 1/3 + 1/3'\n    \"\"\"\n    # Convert input string to a symbolic expression\n    expr_sympy = sp.sympify(expr.replace(\"sqrt\", \"sp.sqrt\").replace(\"cube_root\", \"sp.cbrt\"))\n    # Rationalize the expression\n    rationalized_expr = sp.radsimp(expr_sympy)\n    # Return the rationalized expression as a string\n    return str(rationalized_expr)"
        ],
        [
            "def calculate_side_length_from_area(area):\n    \"\"\"\n    Calculate the side length of a square from its given area.\n    Parameters:\n        area (int, float, sympy.Expr): The area of the square. Can also be a fraction or an expression.\n        \n    Returns:\n        sympy.Expr: The side length of the square which is the square root of the area.\n    Examples:\n        >>> calculate_side_length_from_area(9)\n        3\n        >>> calculate_side_length_from_area(sp.Rational(1, 16))\n        1/4\n    \"\"\"\n    side_length = sp.sqrt(area)\n    return side_length.simplify()",
            "def calculate_side_length(area):\n    \"\"\"\n    Calculate the side length of a square given its area using the square root.\n    \n    Parameters:\n    area (float): The area of the square.\n    \n    Returns:\n    float: The side length of the square.\n    \n    Examples:\n    >>> calculate_side_length(25)\n    5.0\n    >>> calculate_side_length(12.25)\n    3.5\n    \"\"\"\n    return math.sqrt(area)"
        ],
        [
            "def compute_root(base, n=2):\n    \"\"\"\n    Computes the nth root of a given number `base`.\n    Parameters:\n    - base: float or int, the number from which the nth root is to be taken\n    - n: int, degree of the root (default is 2 for square root)\n    Returns:\n    - float, the nth root of `base`\n    Examples:\n    >>> compute_root(16, 2)\n    4.0\n    >>> compute_root(8, 3)\n    2.0\n    \"\"\"\n    import math\n    if base < 0 and n % 2 == 0:\n        raise ValueError(\"Cannot compute even roots for negative numbers\")\n    return base ** (1 / n)",
            "def radical_value(base, n=2):\n    \"\"\"\n    Calculate the nth root of a given number.\n    Parameters\n    ----------\n    base : float or int\n        The base number of which to find the root.\n    n : int, optional\n        The degree of the root. The default is 2 for square roots.\n    Returns\n    -------\n    float\n        The nth root of the base.\n    Examples\n    --------\n    >>> radical_value(16, 2)\n    4.0\n    >>> radical_value(27, 3)\n    3.0\n    \"\"\"\n    if n <= 0:\n        raise ValueError(\"n must be a positive integer\")\n    return base ** (1/n)"
        ],
        [
            "def calculate_nth_root(value, n):\n    \"\"\"\n    Calculate the nth root of a given number, where n is a positive integer.\n    \n    Parameters:\n    value (float): The number from which to extract the nth root.\n    n (int): The degree of the root. Must be a positive integer.\n    Returns:\n    float: The nth root of the given number.\n    Examples:\n    >>> calculate_nth_root(16, 2)\n    4.0\n    >>> calculate_nth_root(8, 3)\n    2.0\n    \"\"\"\n    return value ** (1/n)",
            "def nth_root(value, n):\n    \"\"\"\n    Calculates the nth root of a given number and simplifies it.\n    \n    Parameters:\n    - value (int or float or sympy.core.numbers): The number from which the root is to be extracted.\n    - n (int): The degree of the root.\n    \n    Returns:\n    - sympy.core.numbers: The nth root, simplified as much as possible.\n    \n    Examples:\n    >>> nth_root(8, 3)\n    2\n    >>> nth_root(28, 2)\n    2*sqrt(7)\n    \"\"\"\n    root = sympy.root(sympy.sympify(value), n)\n    return sympy.simplify(root)"
        ],
        [
            "def multiply_radicals(radical1, radical2):\n    \"\"\"\n    Multiplies two radical expressions and simplifies the result.\n    \n    Parameters:\n        radical1 (sympy.core.expr.Expr): The first radical expression.\n        radical2 (sympy.core.expr.Expr): The second radical expression.\n    \n    Returns:\n        sympy.core.expr.Expr: The simplified product of the two radicals.\n    Examples:\n        >>> a = sympy.sqrt(8)\n        >>> b = sympy.sqrt(2)\n        >>> multiply_radicals(a, b)\n        4\n    \"\"\"\n    # Multiply radicals and simplify the expression\n    result = radical1 * radical2\n    return sympy.simplify(result)",
            "def multiply_radicals(rad1, rad2):\n    \"\"\"\n    Multiplies two radical expressions, simplifying the result. \n    Assumes inputs are already in a simplified radical form.\n    \n    Parameters:\n        rad1 (sympy expression): First radical term.\n        rad2 (sympy expression): Second radical term.\n    \n    Returns:\n        sympy expression: Result of multiplying the two radicals.\n    \n    Examples:\n        >>> multiply_radicals(sqrt(2), sqrt(8))\n        2*sqrt(2)\n    \"\"\"\n    from sympy import simplify\n    result = simplify(rad1 * rad2)\n    return result"
        ],
        [
            "def evaluate_root_operations(expression):\n    \"\"\"\n    Evaluates and simplifies operations on square roots, including addition, \n    subtraction, and multiplication.\n    Parameters:\n    expression (str): A string representing a mathematical expression involving operation on square roots.\n    Returns:\n    sympy.Expr: The result of the operations on square roots, simplified.\n    Examples:\n    >>> evaluate_root_operations('sqrt(2) * sqrt(3)')\n    sqrt(6)\n    \n    >>> evaluate_root_operations('sqrt(50) + sqrt(18) - sqrt(8)')\n    9*sqrt(2)\n    >>> evaluate_root_operations('sqrt(49 - sqrt(9))')\n    4*sqrt(3)\n    \"\"\"\n    # Parse the expression\n    expr = sympy.sympify(expression)\n    # Simplify the expression\n    simplified_expr = sympy.simplify(expr)\n    \n    return simplified_expr",
            "def perform_root_operations(expr):\n    \"\"\"\n    Performs operations on expressions involving roots, including multiplication, addition,\n    and nested root manipulations.\n    \n    Parameters:\n    - expr: The mathematical expression involving roots that needs processing\n    Returns:\n    - Result of performing the root operations on the input expression\n    Example:\n    >>> perform_root_operations('sqrt(2)*sqrt(3)')\n    'sqrt(6)'\n    >>> perform_root_operations('sqrt(16)*cube_root(8)')\n    '4*2'\n    \"\"\"\n    # Convert input string to a symbolic expression\n    expr_sympy = sp.sympify(expr.replace(\"sqrt\", \"sp.sqrt\").replace(\"cube_root\", \"sp.cbrt\"))\n    # Simplify the expression to evaluate possible root operations\n    evaluated_expr = sp.simplify(expr_sympy)\n    # Return the evaluated expression as a string\n    return str(evaluated_expr)"
        ],
        [
            "def find_hyperbola_foci(a, b):\n    \"\"\"\n    Given the constants a and b from the hyperbola standard form equation (x^2/a^2 - y^2/b^2 = 1),\n    compute the coordinates of the foci.\n    Parameters:\n    - a: Semi-major axis of the hyperbola (horizontal).\n    - b: Semi-minor axis of the hyperbola (vertical).\n    Returns:\n    - tuple: Coordinates of the two foci of the hyperbola.\n    Example:\n    >>> find_hyperbola_foci(5, 3)\n    ((0, 5.83), (0, -5.83))\n    \"\"\"\n    c = sp.sqrt(a**2 + b**2)  # Distance from center to each focus\n    return ((0, float(c)), (0, -float(c)))"
        ],
        [
            "def calculate_square_root(x, exact=False):\n    \"\"\" Compute the square root of a number with an option to force exact symbolic results.\n    Parameters:\n    - x (int, float, complex): The number from which to calculate the square root.\n    - exact (bool): If True, returns an exact symbolic result; otherwise, return a numerical approximation.\n    Returns:\n    - sp.core.expr.Expr or float: The square root of the number, either as a symbolic expression or as a numerical value.\n    \n    Examples:\n    >>> calculate_square_root(16)\n    4.0 \n    >>> calculate_square_root(16, exact=True)\n    4\n    >>> calculate_square_root(3, exact=True)\n    sqrt(3)\n    >>> calculate_square_root(-1)\n    1j\n    \"\"\"\n    if exact:\n        return sp.sqrt(x)\n    else:\n        if isinstance(x, complex) or x < 0:\n            return complex((sp.sqrt(x)).evalf())\n        else:\n            return float((sp.sqrt(x)).evalf())"
        ],
        [
            "def determine_domain(expression, variable_str='x'):\n    \"\"\"\n    Determines the domain of a function involving radicals, ensuring the radicand is non-negative.\n    \n    Parameters:\n        expression (str): The function expression containing a radical.\n        variable_str (str): The primary variable in the function expression.\n    \n    Returns:\n        sympy.Interval: The domain of the function where the radicand is non-negative.\n    Example:\n        >>> determine_domain('sqrt(x - 1)', ' x')\n        Interval(1, oo)\n    \"\"\"\n    variable = sp.symbols(variable_str)\n    expr = sp.sympify(expression)\n    # Find all radicals (root expressions) in the input expression\n    radicals = [node for node in sp.preorder_traversal(expr) if isinstance(node, sp.Pow) and node.args[1] == 0.5]\n    # Compute conditions for non-negative radicands\n    conditions = [sp.solveset(sp.Gt(rad.args[0], 0), variable) for rad in radicals]\n    \n    # Combine conditions to find the overall domain\n    domain = sp.Intersection(*conditions)\n    return domain",
            "def find_domain_of_radical_function(function, variable='x'):\n    \"\"\"\n    Finds the domain of a function containing a radical, ensuring radicand is non-negative.\n    \n    Parameters:\n        function (str): The function containing a radical.\n        variable (str): The primary variable in the function.\n        \n    Returns:\n        sympy.sets.sets.Set: The domain of the function.\n    \n    Examples:\n        >>> str(find_domain_of_radical_function('sqrt(x+2)'))\n        'Interval(-2, oo)'\n    \"\"\"\n    var = sp.symbols(variable)\n    radicand = sp.sqrt(sp.sympify(function)).args[0]\n    return sp.solveset(radicand >= 0, var)"
        ],
        [
            "def simplify_radical(number):\n    \"\"\"\n    Simplify the square root of a number into its simplest radical form using prime factorization.\n    Parameters:\n        number (int): The number under the radical.\n    \n    Returns:\n        sympy expression: The simplified radical expression.\n    \n    Examples:\n        >>> simplify_radical(72)\n        6*sqrt(2)\n        >>> simplify_radifier(50)\n        5*sqrt(2)\n    \"\"\"\n    if number < 0:\n        raise ValueError(\"Input must be a non-negative integer\")\n    \n    factors = primefactors(number)\n    inside = 1\n    outside = 1\n    for p in factors:\n        count = factors.count(p)\n        outside *= p ** (count // 2)\n        inside *= p ** (count % 2)\n    \n    if inside == 1:\n        return Integer(outside)  # No radical needed if inside is 1\n    else:\n        return Mul(Integer(outside), Pow(Integer(inside), 1/2))"
        ],
        [
            "def simplify_square_root(expression):\n    \"\"\"\n    Simplifies the square root of an expression using symbolic manipulation.\n    \n    Parameters:\n    - expression (int, float, or sympy expression): The expression under the square root.\n    \n    Returns:\n    - sympy expression: Simplified form of the square root.\n    \n    Examples:\n    - Numerical example:\n    >>> simplify_square_root(24)\n    2*sqrt(6)\n    \n    - Symbolic example:\n    >>> x = sp.symbols('x')\n    >>> simplify_square_root(x**2 - 9)\n    x - 3\n    \"\"\"\n    return sp.sqrt(sp.sympify(expression)).simplify()"
        ],
        [
            "def calculate_distance(point1, point2):\n    \"\"\"\n    Calculate the Euclidean distance between two points in 2-dimensional space.\n    \n    Parameters:\n    point1 (tuple): A tuple of two floats or ints, representing the coordinates of the first point (x1, y1).\n    point2 (tuple): A tuple of two floats or ints, representing the coordinates of the second point (x2, y2).\n    Returns:\n    float: The Euclidean distance between two points.\n    Examples:\n    >>> calculate_distance((0, 0), (3, 4))\n    5.0\n    >>> calculate_distance((1, 1), (4, 5))\n    5.0\n    \"\"\"\n    x1, y1 = point1\n    x2, y2 = point2\n    return math.sqrt((x2 - x1)**2 + (y2 - y1)**2)",
            "def distance_between_points(x1, y1, x2, y2):\n    \"\"\"\n    Calculates the Euclidean distance between two points (x1, y1) and (x2, y2) in 2D space.\n    Parameters:\n        x1, y1 (float or int): Coordinates of the first point.\n        x2, y2 (float or int): Coordinates of the second point.\n    Returns:\n        float: The distance between the two points.\n    Examples:\n        >>> distance_between_points(0, 0, 3, 4)\n        5.0\n        >>> distance_between_points(-1, -1, 1, 2)\n        3.605551275463989\n    \"\"\"\n    from math import sqrt\n    return sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2)",
            "def calculate_distance(x1, y1, x2, y2, exact=False):\n    \"\"\" Calculate the Euclidean distance between two points in a 2D plane.\n    Parameters:\n    - x1, y1 (float): Coordinates of the first point.\n    - x2, y2 (float): Coordinates of the second point.\n    - exact (bool): If True, returns an exact symbolic result; otherwise, returns a numerical approximation.\n    Returns:\n    - sp.core.expr.Expr or float: The distance between the two points, either as a symbolic expression or a numerical value.\n    \n    Examples:\n    >>> calculate_distance(1, 1, 4, 5)\n    5.0\n    >>> calculate_distance(1, 1, 4, 5, exact=True)\n    sqrt(16) + sqrt(1)\n    >>> calculate_distance(0, 0, 3, 4, exact=True)\n    5\n    \"\"\"\n    dx = x2 - x1\n    dy = y2 - y1\n    dist_squared = dx**2 + dy**2\n    return calculate_square_root(dist_squared, exact)"
        ],
        [
            "def ellipse_focal_distance(a, b):\n    \"\"\"\n    Calculates the focal distance (c) of an ellipse given the semi-major axis (a) and semi-minor axis (b) using the relation c^2 = a^2 - b^2.\n    \n    Parameters:\n    - a (int or float or sympy.core.numbers): Semi-major axis of the ellipse.\n    - b (int or float or sympy.core.numbers): Semi-minor axis of the ellipse.\n    \n    Returns:\n    - sympy.core.numbers: The focal distance (c) of the ellipse, simplified if possible.\n    \n    Examples:\n    >>> ellipse_focal_distance(5, 4)\n    3\n    >>> ellipse_focal_distance(10, 8)\n    6\n    \"\"\"\n    c_squared = sympy.sympify(a)**2 - sympy.sympify(b)**2\n    c = sympy.sqrt(sympy.simplify(c_squared))\n    return c"
        ],
        [
            "def evaluate_square_root(number, decimal_places=None):\n    \"\"\"\n    Evaluates the square root of a given number, with an optional specification of decimal places.\n    Parameters:\n    number (int, float): The number from which to find the square root.\n    decimal_places (int, optional): The number of decimal places to round the result to. Defaults to None.\n    Returns:\n    float or str: The square root of the number, optionally rounded to a specified number of decimal places.\n                  If exact square root is found, it return as integer.\n    \n    Examples:\n    >>> evaluate_square_root(25)\n    5\n    >>> evaluate_square_root(20, 3)\n    4.472\n    \"\"\"\n    root = sp.sqrt(number)\n    if root.is_Integer:\n        return int(root)\n    else:\n        if decimal_places is not None:\n            return round(float(root), decimal_places)\n        return float(root)"
        ],
        [
            "def solve_quadratic(a, b, c):\n    \"\"\"\n    Solves quadratic equations of the form ax^2 + bx + c = 0 using the quadratic formula.\n    Parameters:\n    - a: float or int, coefficient of x^2\n    - b: float or int, coefficient of x\n    - c: float or int, constant term\n    Returns:\n    - tuple, the roots of the quadratic equation, which can be real or complex numbers\n    Examples:\n    >>> solve_quadratic(1, -3, 2)\n    (2.0, 1.0)\n    >>> solve_quadratic(1, 0, 1)\n    ((-0j), (1+1j), (1-1j))\n    \"\"\"\n    import cmath\n    discriminant = b ** 2 - 4 * a * c\n    root1 = (-b + cmath.sqrt(discriminant)) / (2 * a)\n    root2 = (-b - cmath.sqrt(discriminant)) / (2 * a)\n    return (root1, root2)",
            "def solve_quadratic(a, b, c):\n    \"\"\"\n    Solves a quadratic equation of the form ax^2 + bx + c = 0.\n    Parameters:\n        a (float or int): Coefficient of x^2\n        b (float or int): Coefficient of x\n        c (float or int): Constant term\n    Returns:\n        tuple: A tuple containing the roots (real or complex) of the quadratic equation.\n    Examples:\n        >>> solve_quadratic(1, -3, 2)\n        (2.0, 1.0)\n        >>> solve_quadratic(1, 0, 1)\n        ((-0j), (1+0j))\n    \"\"\"\n    import cmath\n    discriminant = b**2 - 4*a*c\n    root1 = (-b + cmath.sqrt(discriminant)) / (2 * a)\n    root2 = (-b - cmath.sqrt(discriminant)) / (2 * a)\n    return (root1, root2)"
        ],
        [
            "def prime_factorization(n):\n    \"\"\"\n    Perform prime factorization on a given integer and return the factors in base-exponent pairs.\n    \n    Parameters:\n    - n (int): The integer to be factorized.\n    \n    Returns:\n    - dict: A dictionary where keys are prime factors and values are their respective exponents.\n    \n    Examples:\n    >>> prime_factorization(18)\n    {2: 1, 3: 2}\n    \n    >>> prime_factorization(100)\n    {2: 2, 5: 2}\n    \"\"\"\n    prime_factors = {}\n    i = 2\n    while i * i <= n:\n        while (n % i) == 0:\n            if i in prime_factors:\n                prime_factors[i] += 1\n            else:\n                prime_factors[i] = 1\n            n //= i\n        i += 1\n    if n > 1:\n        prime_factors[n] = 1\n    return prime_factors"
        ],
        [
            "def pythagorean_ellipse(a=None, b=None, c=None):\n    \"\"\"\n    Solves the Pythagorean relationship for an ellipse (c^2 = a^2 - b^2) given two of the three parameters.\n    Parameters:\n    - a (float or None): The semi-major axis.\n    - b (float or None): The semi-minor axis.\n    - c (float or None): The focal length from the center to the focus.\n    Returns:\n    - result (float): Value of the computed parameter.\n    Examples:\n    >>> pythagorean_ellipse(a=5, b=3)\n    4.0\n    >>> pythagorean_ellipse(c=4, b=3)\n    5.0\n    >>> pythagorean_ellipse(a=5, c=4)\n    3.0\n    \"\"\"\n    if a is not None and b is not None:\n        return sp.sqrt(a**2 - b**2).evalf()\n    elif a is not None and c is not None:\n        return sp.sqrt(a**2 - c**2).evalf()\n    elif b is not None and c is not None:\n        return sp.sqrt(c**2 + b**2).evalf()\n    else:\n        raise ValueError(\"Two parameters must be provided.\")"
        ],
        [
            "def radical_expression_handler(expression, operation=\"simplify\"):\n    \"\"\"\n    Perform operations such as simplification, rationalization, or manipulation of radical expressions.\n    Parameters:\n        expression (str): The radical expression given as a string.\n        operation (str): The type of operation to perform on the radical expression. \n                         Supported operations: \"simplify\", \"rationalize\", \"expand\"\n    Returns:\n        sympy.Expr: The resulting expression after the specified operation.\n    Examples:\n        >>> radical_expression_handler('sqrt(45) * sqrt(5)', 'simplify')\n        15\n        >>> radical_expression_handler('1/sqrt(2)', 'rationalize')\n        sqrt(2)/2\n    \"\"\"\n    expr = sp.sympify(expression)\n    if operation == \"simplify\":\n        return sp.simplify(expr)\n    elif operation == \"rationalize\":\n        numer, denom = expr.as_numer_denom()\n        return sp.simplify(numer * sp.conjugate(denom) / (denom * sp.conjugate(denom)))\n    elif operation == \"expand\":\n        return sp.expand(expr)\n    else:\n        raise ValueError(\"Unsupported operation. Use 'simplify', 'rationalize', or 'expand'.\")"
        ],
        [
            "def symbolic_root(expression, degree=2):\n    \"\"\"\n    Calculates the nth root of a symbolic expression using sympy.\n    \n    Parameters:\n        expression (str or sympy expression): The symbolic expression from which the root is to be calculated.\n        degree (int): The degree of the root. Default is 2 (square root).\n    Returns:\n        sympy expression: The nth root of the given symbolic expression.\n    \n    Examples:\n        >>> symbolic_root('x**2 - 4', 2)\n        sqrt(x**2 - 4)\n        >>> symbolic_root('x**3', 3)\n        x\n    \"\"\"\n    if isinstance(expression, str):\n        expression = sp.sympify(expression)\n    return expression ** (1/degree)"
        ],
        [
            "def ellipse_linear_eccentricity(a, b):\n    \"\"\"\n    Calculate the linear eccentricity of an ellipse given its semi-major and semi-minor axes.\n    \n    Parameters:\n    - a (float): Semi-major axis of the ellipse.\n    - b (float): Semi-minor axis of the ellipse.\n    \n    Returns:\n    - float: The linear eccentricity of the ellipse.\n    \n    Examples:\n    >>> ellipse_linear_eccentricity(5, 3)\n    4.0\n    \"\"\"\n    return math.sqrt(a**2 - b**2)"
        ],
        [
            "def simplify_and_solve(expression, var):\n    \"\"\"\n    Simplifies an expression involving square roots and solves for a variable.\n    \n    Parameters:\n        expression (str): The equation or expression involving square roots.\n        var (str): The variable to solve for.\n    \n    Returns:\n        set: A set of possible solutions for the variable.\n    \n    Examples:\n        >>> simplify_and_solve('x**2 - sqrt(16)', 'x')\n        {-2, 2}\n        \n        >>> simplify_and_solve('x**2 - 2*x - sqrt(9) + 3', 'x')\n        {1, 3}\n    \"\"\"\n    expr = sp.sympify(expression)\n    variable = sp.symbols(var)\n    simplified_expr = sp.simplify(expr)\n    return sp.solveset(simplified_expr, variable)"
        ],
        [
            "def square_root(value):\n    \"\"\"\n    Calculate the square root of a given value.\n    Parameters:\n    - value (int, float, or sympy expression): The value from which to extract the square root.\n    \n    Returns:\n    - float or sympy expression: The square root of the provided value.\n    Examples:\n    >>> square_root(9)\n    3.0\n    >>> square_root(sp.Rational(1, 2))\n    sqrt(2)/2\n    \"\"\"\n    if isinstance(value, (int, float)):\n        return math.sqrt(value)\n    else:\n        return sp.sqrt(value)"
        ],
        [
            "def combine_radicals(expression1, expression2, operation='add'):\n    \"\"\"\n    Combine two radical expressions using specified arithmetic operations (add, subtract, multiply, divide).\n    \n    Parameters:\n        expression1 (sympy.Expr): The first expression involving radicals.\n        expression2 (sympy.Expr): The second expression involving radicals.\n        operation (str): Specifies the type of arithmetic operation: 'add', 'subtract', 'multiply', 'divide'.\n    Returns:\n        sympy.Expr: Result of combining the two expressions.\n    \n    Examples:\n        >>> combine_radicals(sp.sqrt(2), sp.sqrt(8), 'multiply')\n        4\n        >>> combine_radicals(sp.sqrt(2), sp.sqrt(8), 'add')\n        3*sqrt(2)\n    \"\"\"\n    if operation == 'add':\n        result = expression1 + expression2\n    elif operation == 'subtract':\n        result = expression1 - expression2\n    elif operation == 'multiply':\n        result = expression1 * expression2\n    elif operation == 'divide':\n        result = expression1 / expression2\n    else:\n        raise ValueError(\"Unsupported operation. Choose from 'add', 'subtract', 'multiply', 'divide'.\")\n    return sp.simplify(result)"
        ],
        [
            "def sum_of_squares(*args):\n    \"\"\"\n    Returns the sum of squares of provided arguments.\n    Parameters:\n    - args: float or int, values to be squared and summed\n    Returns:\n    - float, the sum of the squares of the provided inputs\n    Examples:\n    >>> sum_of_squares(1, 2, 3)\n    14\n    >>> sum_of_squares(4, 5)\n    41\n    \"\"\"\n    return sum(x**2 for x in args)"
        ],
        [
            "def simplify_radical_expression(n, root_degree=2):\n    \"\"\"\n    Simplifies a radical expression of the given degree (default is square root).\n    Parameters:\n        n (int): The number under the radical.\n        root_degree (int): The degree of the root (default=2 for square root).\n    \n    Returns:\n        sympy.core.expr.Expr: Simplified radical expression.\n    Examples:\n        >>> simplify_radical_expression(72)\n        6*sqrt(2)\n        >>> simplify_radical_expression(72, root_degree=3)\n        2*cbrt(9)\n        >>> simplify_radical_expression(500)\n        10*sqrt(5)\n    \"\"\"\n    # Use sympy nroot for finding principal nth root and apply simplification\n    if n < 0 and root_degree % 2 == 0:\n        raise ValueError(\"Cannot take even root of a negative number\")\n    radical = sympy.root(n, root_degree)\n    return sympy.simplify(radical)"
        ],
        [
            "def verify_solution(equation, solutions, variable='x'):\n    \"\"\"\n    Checks if the provided solutions truly satisfy the original equation,\n    particularly useful when dealing with extraneous root caused by squaring.\n    \n    Parameters:\n        equation (str): The original equation, preferably before squaring.\n        solutions (list): List of numerical solutions to check.\n        variable (str): The primary variable in equation.\n        \n    Returns:\n        list: Verified solutions that satisfy the original equation.\n    \n    Examples:\n        >>> verify_solution('sqrt(x+1) + x = 3', [2], 'x')\n        [2]\n    \"\"\"\n    var = sp.symbols(variable)\n    expr = sp.sympify(equation)\n    validated_solutions = []\n    for sol in solutions:\n        if expr.subs(var, sol).simplify() == 0:\n            validated_solutions.append(sol)\n    return validated_solutions"
        ],
        [
            "def solve_pythagorean(a=None, b=None, c=None):\n    \"\"\"\n    Solves the Pythagorean theorem a^2 + b^2 = c^2 for a missing side.\n    \n    Parameters:\n        a (float, optional): Length of side a.\n        b (float, optional): Length of side b.\n        c (float, optional): Length of the hypotenuse c.\n    \n    Returns:\n        float: The length of the missing side.\n    \n    Examples:\n        >>> solve_pythagorean(a=3, b=4)\n        5.0\n        \n        >>> solve_pythagorean(b=4, c=5)\n        3.0\n    \"\"\"\n    if c is None:  # solve for c\n        return sp.sqrt(a**2 + b**2)\n    elif a is None:  # solve for a\n        return sp.sqrt(c**2 - b**2)\n    elif b is None:  # solve for b\n        return sp.sqrt(c**2 - a**2)"
        ],
        [
            "def compute_root(number, degree=2):\n    \"\"\"\n    Compute the n-th root of a given number, where n is specified by the 'degree'.\n    Defaulting to the square root, but can compute cube roots, fourth roots, etc.\n    Parameters:\n        number (float or int): The number for which the root needs to be computed.\n        degree (int): The degree of the root to be computed (default is 2 for square root).\n    \n    Returns:\n        float: The computed root of the number.\n    Examples:\n        >>> compute_root(16, 2)\n        4.0\n        >>> compute_root(27, 3)\n        3.0\n        >>> compute_root(2, 2)\n        1.4142135623730951\n    \"\"\"\n    from math import pow\n    if number < 0 and degree % 2 == 0:\n        raise ValueError(\"Negative number cannot have an even degree root\")\n    return pow(number, 1/degree)",
            "def compute_root(n, degree=2):\n    \"\"\"\n    Compute the nth-root of a number.\n    \n    Parameters:\n        n (float): The number from which to compute the root.\n        degree (int): The degree of the root. Default is 2 (square root).\n    \n    Returns:\n        float: The computed nth-root of the number.\n    \n    Examples:\n        >>> compute_root(16, 2)\n        4.0\n        >>> compute_root(8, 3)\n        2.0\n    \"\"\"\n    return n ** (1/degree)",
            "def calculate_root(value, degree=2):\n    \"\"\"\n    Calculates the nth root of a given number, specifically designed to be flexible\n    for any degree of the root.\n    Parameters:\n        value (float/int): The value from which the root is to be taken.\n        degree (int): The degree of the root. Default is 2 (square root).\n    Returns:\n        float: The nth root of the given value.\n    \n    Example:\n        >>> calculate_root(16, 2)\n        4.0\n        >>> calculate_root(27, 3)\n        3.0\n    \"\"\"\n    return value ** (1/degree)"
        ],
        [
            "def simplify_radical(expression):\n    \"\"\"\n    Simplify an expression involving radicals. This includes rationalizing the denominator if necessary.\n    \n    Parameters:\n    expression (sympy expression): The expression containing radicals.\n    \n    Returns:\n    sympy expression: The simplified expression.\n    \n    Examples:\n    >>> from sympy.abc import x\n    >>> simplify_radical(x*sqrt(2)/2)\n    sqrt(2)*x/2\n    >>> simplify_radical(sqrt(8)/sqrt(2))\n    2*sqrt(2)\n    \"\"\"\n    return simplify(expression)"
        ]
    ],
    "Function Operations": [
        [
            "def apply_custom_operation(expression, x_value, y_value):\n    \"\"\"\n    Apply a custom operation defined as a sympy expression to specific values.\n    Parameters:\n    expression (str): A mathematical expression involving 'x' and 'y'.\n    x_value (float or int): The value to substitute for 'x'.\n    y_value (float or int): The value to substitute for 'y'.\n    Returns:\n    sympy.core.expr.Expr: The result of the expression after substituting x and y with x_value and y_value respectively.\n    Example:\n    >>> result = apply_custom_operation('(x + y) / 3', 9, 6)\n    >>> print(result)\n    5.0\n    \"\"\"\n    x, y = sp.symbols('x y')\n    expr = sp.sympify(expression)\n    result = expr.subs({'x': x_value, 'y': y_value})\n    return result.evalf()",
            "def define_custom_operation(expression):\n    \"\"\"\n    Define a custom operation using algebraic expressions.\n    \n    Parameters:\n    - expression (str): A string representing the algebraic expression defining the operation.\n    Returns:\n    - function: A function that accepts two variables and applies the operation defined.\n    \n    Example:\n    >>> op_f = define_custom_operation('(x + y) / 3')\n    >>> op_f(4, 5)\n    3.0\n    \"\"\"\n    x, y = symbols('x y')\n    operation = simplify(expression)\n    def operation_func(a, b):\n        return operation.subs({x: a, y: b}).evalf()\n    return operation_func",
            "def define_custom_operation(expression):\n    \"\"\"\n    Define a custom mathematical operation based on a provided symbolic expression.\n    \n    Parameters:\n    - expression (str): A string representing the custom operation, using symbolic names for variables.\n    \n    Returns:\n    - function: A function that can apply the defined operation to specific values.\n    \n    Examples:\n    - define_custom_operation('A * B + A / B')\n    - define_custom_operation('(A + B)^2')\n    \n    This function leverages `sympy` to parse and prepare the symbolic expression for future evaluations.\n    \"\"\"\n    def custom_operation(**values):\n        \"\"\"\n        Apply a custom operation defined earlier to the given values.\n        \n        Parameters:\n        - values (dict): A dictionary of variable names and their respective values to substitute into the expression.\n        \n        Returns:\n        - sympy.Expr: Simplified expression after substituting the values.\n        \n        Examples:\n        - custom_operation(A=5, B=3)  # Assuming the custom operation was defined as 'A + B'\n        \"\"\"\n        # Convert the input formula into a sympy expression.\n        sym_expr = sympify(expression)\n        # Substitute values in the expression.\n        substituted_expr = sym_expr.subs(values)\n        # Simplify the result and return.\n        return substituted_expr.simplify()\n    \n    return custom_operation"
        ],
        [
            "def expand_expression(expr):\n    \"\"\"\n    Expands a given algebraic expression.\n    Parameters:\n        expr (str): A string representing the algebraic expression to be expanded.\n    Returns:\n        sympy expression: The expanded algebraic expression.\n    Examples:\n        >>> print(expand_expression('(a+b)^2'))\n        a**2 + 2*a*b + b**2\n        >>> print(expand_expression('(x+2)*(x-3)'))\n        x**2 - x - 6\n    \"\"\"\n    x, y, a, b, c = symbols('x y a b c')\n    expanded_expr = expand(expr)\n    return expanded_expr",
            "def expand_expression(expression):\n    \"\"\"\n    Expand a given polynomial expression.\n    Parameters:\n    expression (str): The polynomial expression to expand, as a string.\n    Returns:\n    str: Expanded form of the polynomial expression.\n    Example:\n    >>> expand_expression(\"(x+2)**2\")\n    'x**2 + 4*x + 4'\n    \"\"\"\n    x = sp.symbols('x')\n    expr = sp.sympify(expression)\n    expanded_expr = sp.expand(expr)\n    return str(expanded_expr)",
            "def expand_expression(expression):\n    \"\"\"\n    Expands a polynomial or binomial expression.\n    \n    Parameters:\n    - expression (str): The mathematical expression in string form to be expanded.\n    \n    Returns:\n    - sympy.Expr: The expanded form of the input expression.\n    \n    Examples:\n    >>> expand_expression('(x+1)^2')\n    x**2 + 2*x + 1\n    \n    >>> expand_expression('2*(x + 3)*(x - 5)')\n    2*x**2 - 4*x - 30\n    \"\"\"\n    x = symbols('x')\n    expanded_expr = expand(expression)\n    return expanded_expr"
        ],
        [
            "def solve_fractional_equations(equation_str):\n    \"\"\"\n    Solves equations involving fractions and rational functions.\n    \n    Parameters:\n        equation_str (str): A string representing the equation to solve.\n    \n    Returns:\n        list: Solutions to the equation.\n    \n    Examples:\n        >>> solve_fractional_equations('x/(x + 1) = 1')\n        []\n        >>> solve_fractional_equations('x/(x + 1) = 0')\n        [0]\n        \n        >>> solve_fractional_equations('(x**2 + 3*x + 2)/(x + 2) = 1')\n        [1]\n    \"\"\"\n    x = symbols('x')\n    equation = sympify(equation_str)\n    return solve(equation, x)",
            "def solve_algebraic_equation(equation, variable='x'):\n    \"\"\"\n    Solves algebraic equations including those involving fractions and rational functions.\n    Parameters:\n    equation (str): A string representation of the algebraic equation to solve.\n    variable (str): The main variable in the equation as a string.\n    Returns:\n    list: Solutions of the equation.\n    Examples:\n    >>> solve_algebraic_equation(\"x**2 - 2*x - 8\")\n    [4, -2]\n    >>> solve_algebraic_equation(\"(x**2 - 1)/(x - 1) = 2\", 'x')\n    [2]\n    \"\"\"\n    var = symbols(variable)\n    eq = Eq(simplify(equation.split('=')[0]), simplify(equation.split('=')[1]))\n    solutions = solve(eq, var)\n    return solutions"
        ],
        [
            "def substitute_expression(expression, substitutions):\n    \"\"\"\n    Substitute values or variables in a polynomial expression.\n    Parameters:\n    expression (str): The polynomial expression for substitution.\n    substitutions (dict): Dictionary of substitutions in form {variable:value}\n    Returns:\n    str: The result of the expression after performing substitutions.\n    Example:\n    >>> substitute_expression(\"x**2 + 3*x + 2\", {x: 2})\n    '12'\n    \"\"\"\n    expr = sp.sympify(expression)\n    substituted_expr = expr.subs(substitutions)\n    return str(substituted_expr)",
            "def substitute_into_expression(expression, substitutions):\n    \"\"\"\n    Substitutes given values or expressions into an algebraic expression.\n    Parameters:\n    - expression (str or sympy.Expr): The algebraic expression where the substitution will take place.\n    - substitutions (dict): A dictionary mapping from variable (str or sympy.Symbol) to the value or expression to be substituted.\n    Returns:\n    - sympy.Expr: Resultant expression after substitution.\n    Examples:\n    >>> substitute_into_expression('x**2 + y**2', {'x': 'a + b', 'y': 3})\n    (a + b)**2 + 9\n    >>> substitute_into_expression('sin(x) + cos(y)', {'x': 'pi/4', 'y': 'pi/3'})\n    sqrt(2)/2 + 1/2\n    \"\"\"\n    # Convert the string input to sympy expression if necessary\n    if isinstance(expression, str):\n        expression = sp.sympify(expression)\n    \n    # Convert the substitutions to sympy formats\n    subs = {sp.sympify(var): sp.sympify(value) for var, value in substitutions.items()}\n    \n    # Perform the substitution\n    return expression.subs(subs)"
        ],
        [
            "def simplify_expression(expression):\n    \"\"\"\n    Simplify a given mathematical expression.\n    Parameters:\n    expression (str or sympy.core.expr.Expr): The expression that needs to be simplified.\n    Returns:\n    sympy.core.expr.Expr: The simplified version of the expression.\n    Example:\n    >>> simplify_expression('x^2 + 2*x + 1')\n    (x + 1)**2\n    \"\"\"\n    expr = sp.sympify(expression)\n    simplified_expr = sp.simplify(expr)\n    return simplified_expr",
            "def simplify_expression(expr):\n    \"\"\"\n    Simplifies a given algebraic expression using algebraic identities and substitutions.\n    Parameters:\n        expr (str): The algebraic expression to simplify.\n    Returns:\n        sympy expression: The simplified form of the input expression.\n    Examples:\n        >>> print(simplify_expression('x**2 + 2*x + 1'))\n        (x + 1)**2\n        >>> print(simplify_expression('(x**2 - 16)/(x-4)'))\n        x + 4\n    \"\"\"\n    x, y, a, b, c = symbols('x y a b c')\n    simplified_expr = simplify(expr)\n    return simplified_expr",
            "def simplify_expression(expression):\n    \"\"\"\n    Simplify any algebraic or trigonometric expression using symbolic computation.\n    Parameters:\n        expression (str): A string representing the mathematical expression to simplify.\n    Returns:\n        sympy.Expr: The simplified expression.\n    Examples:\n        >>> simplify_expression(\"x**2 + 2*x + 1\")\n        x**2 + 2*x + 1\n        >>> simplify_expression(\"sin(x)**2 + cos(x)**2\")\n        1\n        >>> simplify_expression(\"(x**2 - 2*x + 1)/(x - 1)\")\n        x - 1\n    \"\"\"\n    x = symbols('x')  # More symbols can be added as required\n    return simplify(expression)",
            "def simplify_expression(expression):\n    \"\"\"\n    Simplifies algebraic expressions including rational functions.\n    Parameters:\n    expression (str): A string representation of the algebraic expression to be simplified.\n    Returns:\n    sympy.Expr: Simplified expression.\n    Examples:\n    >>> simplify_expression(\"x**2 + 2*x + 1\")\n    (x + 1)**2\n    >>> simplify_expression(\"(x**2 - 1)/(x + 1)\")\n    x - 1\n    \"\"\"\n    x = symbols('x')\n    expr = simplify(expression)\n    return expr",
            "def simplify_expression(expression):\n    \"\"\"\n    Simplifies a given polynomial expression, possibly including substitution.\n    \n    Parameters:\n    - expression (str): The mathematical expression to be simplified.\n    \n    Returns:\n    - sympy.Expr: The simplified form of the expression.\n    \n    Examples:\n    >>> simplify_expression('x**2 + 2*x + x')\n    x**2 + 3*x\n    \n    >>> simplify_expression('(x**2 - 2*x + 1)/(x - 1)')\n    x - 1\n    \"\"\"\n    x = symbols('x')\n    simplified_expr = simplify(expression)\n    return simplified_expr"
        ],
        [
            "def evaluate_function(f_expr, x_value):\n    \"\"\"\n    Evaluate a mathematical function at a given point.\n    \n    Parameters:\n        f_expr (str): The expression of the function f(x) as a string.\n        x_value (int/float): The x-coordinate at which to evaluate the function.\n    \n    Returns:\n        float: The evaluated result.\n    \n    Example:\n        evaluate_function('x**2 + 3*x + 2', 5)\n        # Output: 42\n    \"\"\"\n    x = symbols('x')\n    f = sympify(f_expr)\n    return f.subs(x, x_value)",
            "def solve_function(f_expr, y_value):\n    \"\"\"\n    Solve the function f(x) = y_value for x.\n    \n    Parameters:\n        f_expr (str): The expression of the function f(x) as a string.\n        y_value (int/float): The value that f(x) is set to be equal to.\n    \n    Returns:\n        list: Possible values of x that satisfy the equation.\n    \n    Example:\n        solve_function('x**2 + 3*x + 2', 0)\n        # Output: [-1, -2]\n    \"\"\"\n    x = symbols('x')\n    f = sympify(f_icouncil_expr)\n    equation = Eq(f, y_value)\n    return solve(equation, x)"
        ],
        [
            "def function_transformation(f_expr, stretch_factor=1, shift_factor=0):\n    \"\"\"\n    Apply vertical stretching and shifting transformations to a function.\n    \n    Parameters:\n        f_expr (str): The expression of the function f(x).\n        stretch_factor (int/float): Factor by which the function should be stretched.\n        shift_factor (int/float): Factor by which the function should be shifted upwards.\n    \n    Returns:\n        sympy.Expr: The transformed function expression.\n    \n    Example:\n        function_transdeparture(f_expr='x**2', stretch_factor=2, shift_factor=3)\n        # Returns: 2*x**2 + 3\n    \"\"\"\n    x = symbols('x')\n    f = sympify(f_expr)\n    return stretch_factor * f + shift_factor",
            "def transform_function(expression, shift=0, stretch=1, reflect=False):\n    \"\"\"\n    Apply transformation operations to a function such as vertical and horizontal shifts, stretches, and reflections.\n    \n    Parameters:\n    - expression (str): The algebraic expression defining the function.\n    - shift (int or float): Vertical shift (positive is upwards, negative is downwards).\n    - stretch (int or float): Vertical stretch factor (greater than 1 stretches, between 0 and 1 compresses).\n    - reflect (bool): If True, reflects the function over the x-axis.\n    \n    Returns:\n    - A transformed function as a sympy expression.\n    \n    Examples:\n    >>> transform_function('x**2', shift=3, stretch=2)\n    2*x**2 + 3\n    >>> transform_function('sin(x)', reflect=True)\n    -sin(x)\n    \"\"\"\n    x = symbols('x')\n    expr = sympify(expression)\n    transformed_expr = stretch * expr + shift\n    if reflect:\n        transformed_expr = -transformed_expr\n    return transformed_expr"
        ],
        [
            "def compose_functions(*functions):\n    \"\"\"\n    Compose multiple mathematical functions.\n    Parameters:\n    * functions (list of sympy expressions or lambdas): Functions to be composed in the order provided.\n    Returns:\n    * function: A single composed function.\n    Example:\n    >>> from sympy.abc import x\n    >>> f = sp.Lambda(x, 2*x + 1)\n    >>> g = sp.Lambda(x, x**2)\n    >>> composed_function = compose_functions(f, g)\n    >>> composed_function(x)\n    2*x**2 + 1\n    \"\"\"\n    composed = sp.Lambda(functions[0].free_symbols, functions[0])\n    for func in functions[1:]:\n        composed = sp.Lambda(composed.free_symbols, func(composed(composed.free_sym bols)))\n    return composed",
            "def compose_functions(*functions):\n    \"\"\"\n    Compose multiple functions where each function is provided as an expression in terms of one variable, x.\n    Parameters:\n    *functions (sympy.Expr): Each argument is a sympy expression representing a function of x.\n    Returns:\n    sympy.Expr: Resulting function after composition.\n    Example:\n    >>> x = sp.symbols('x')\n    >>> f = 2*x + 3\n    >>> g = x**2\n    >>> h = compose_functions(f, g)  # f(g(x))\n    >>> h\n    2*x**2 + 3\n    >>> compose_functions(f, h)  # f(h(x))\n    4*x**2 + 9\n    \"\"\"\n    x = sp.symbols('x')\n    if not functions:\n        return x  # Identity function\n    composed_func = functions[0]\n    for func in functions[1:]:\n        composed_func = composed_func.subs(x, func)\n    return composed_func.simplify()"
        ],
        [
            "def operate_functions(func_expr_1, func_expr_2, operation, value):\n    \"\"\"\n    Apply an operation (add, subtract, multiply, divide) between two functions and evaluates the result at a specific value.\n    \n    Parameters:\n    func_expr_1 (sympy expr): Expression of the first function.\n    func_expr_2 (sympy expr): Expression of the second function.\n    operation (str): Operation to perform ('add', 'subtract', 'multiply', 'divide').\n    value (numeric or sympy Symbol): Input value at which to evaluate the result.\n    \n    Returns:\n    numeric or sympy expr: Result of the operation evaluated at the specified input.\n    \n    Example:\n    >>> x = symbols('x')\n    >>> expr1 = x**2\n    >>> expr2 = x + 1\n    >>> operate_functions(expr1, expr2, 'add', 2)\n    7\n    \"\"\"\n    x = symbols('x')\n    func1 = Lambda(x, func_expr_1)\n    func2 = Lambda(x, func_expr_2)\n    if operation == 'add':\n        result_func = Lambda(x, func1(x) + func2(x))\n    elif operation == 'subtract':\n        result_func = Lambda(x, func1(x) - func2(x))\n    elif operation == 'multiply':\n        result_func = Lambda(x, func1(x) * func2(x))\n    elif operation == 'divide':\n        result_func = Lambda(x, func1(x) / func2(x))\n    return result_func(value)",
            "def operate_function(func, operation, value):\n    \"\"\"\n    Apply an operation on the function with the given value. Operations could be 'shift', 'scale' or 'reciprocal'.\n    Parameters:\n    func (sympy.Expr): A sympy expression representing a function of x.\n    operation (str): Type of operation ('shift', 'scale', 'reciprocal').\n    value (Number or sympy.Expr): The value to be used with the operation.\n    Returns:\n    sympy.Expr: The resulting function after applying the operation.\n    Example:\n    >>> x = sp.symbols('x')\n    >>> f = x**2\n    >>> operate_function(f, 'shift', -2)\n    (x - 2)**2\n    >>> operate_function(f, 'scale', 3)\n    3*x**2\n    >>> operate_function(sp.exp(x), 'reciprocal', None)\n    exp(-x)\n    \"\"\"\n    x = sp.symbols('x')\n    if operation == 'shift':\n        return func.subs(x, x - value).simplify()\n    elif operation == 'scale':\n        return (value * func).simplify()\n    elif operation == 'recipple':\n        return func.subs(x, 1 / x).simplify()\n    else:\n        raise ValueError(\"Unknown operation. Supported operations: 'shift', 'scale', 'reciprocal'\")"
        ],
        [
            "def evaluate_function(function_expr, point):\n    \"\"\"\n    Evaluates a function at a specific point or set of points.\n    Parameters:\n    - function_expr (str or sympy.Expr): The function to be evaluated, expressed in symbolic form.\n    - point (dict): A dictionary representing the point at which the function is to be evaluated, with variable names as keys.\n    Returns:\n    - type: Description of the returned type of result either numerical value or simplified symbolic expression.\n    Examples:\n    >>> evaluate_function('x**2 + y**2', {'x': 3, 'y': 4})\n    25\n    >>> evaluate_function('sin(x) + cos(y)', {'x': 'pi/4', 'y': 'pi/3'})\n    sqrt(2)/2 + 1/2\n    \"\"\"\n    # Convert the string input to a sympy expression if it's not already one\n    if isinstance(function_expr, str):\n        function_expr = sp.sympify(function_expr)\n    \n    # Sympy's subs and evalf methods are used for substitution and numerical evaluation\n    return function_expr.subs(point).evalf()"
        ],
        [
            "def evaluate_and_manipulate_function(func, var, transformation):\n    \"\"\"\n    Apply a transformation to the function variable before evaluating the function.\n    Parameters:\n    * func (sympy Lambda or expression): The function to evaluate.\n    * var (sympy Symbol): The primary variable of the function.\n    * transformation (sympy expression): The transformation to apply to the variable.\n    Returns:\n    * sympy expression: The function evaluated at the transformed variable.\n    Example:\n    >>> from sympy.abc import x\n    >>> f = sp.Lambda(x, x**2 + 3*x + 2)\n    >>> transformed_eval = evaluate_and_manipulate_function(f, x, 1-x)\n    >>> transformed_eval\n    x**2 - x + 2\n    \"\"\"\n    transformed_var = transformation.subs(var, func.args[0])\n    return func(transformed_var)"
        ],
        [
            "def evaluate_function(expression, **variables):\n    \"\"\"\n    Evaluate an algebraic function with given variable values.\n    \n    Parameters:\n    - expression (str): The algebraic expression representing the function.\n    - variables (dict): Variable substitutions in the form of keyword arguments.\n    \n    Returns:\n    - numeric or symbolic result after substituting variables and evaluating the function.\n    \n    Examples:\n    >>> evaluate_function('x**2 + 3*x + 2', x=2)\n    12\n    >>> evaluate_function('a*x**2 + b*x + c', a=1, b=3, c=2, x=1)\n    6\n    \"\"\"\n    expr = sympify(expression)\n    return expr.subs(variables)",
            "def solve_function(expression, **variables):\n    \"\"\"\n    Solve an algebraic function for the zero of the function.\n    \n    Parameters:\n    - expression (str): The algebraic expression to solve.\n    - variables (dict): Values for coefficients or parameters excluding the variable to be solved.\n    \n    Returns:\n    - List of solutions for the variable.\n    \n    Examples:\n    >>> solve_function('x**2 + 3*x + 2 = 0')\n    [-2, -1]\n    >>> solve_function('a*x**2 + b*x + c', a=1, b=-3, c=2)\n    [2, 1]\n    \"\"\"\n    variable = list(set(symbols(expression)) - set(variables.keys()))\n    expr = sympify(expression).subs(variables)\n    return solve(expr, *variable)"
        ],
        [
            "def compose_and_evaluate_functions(outer_func_expr, inner_func_expr, value):\n    \"\"\"\n    Composes two functions and evaluates the composed function at a specific value.\n    \n    Parameters:\n    outer_func_expr (sympy expr): The expression of the outer function.\n    inner_func_expr (sympy expr): The expression of the inner function.\n    value (numeric or sympy Symbol): The input value at which to evaluate the composite function.\n    \n    Returns:\n    numeric or sympy expr: Result of the composed function evaluated at the specified value.\n    \n    Example:\n    >>> x = symbols('x')\n    >>> outer_expr = x**2\n    >>> inner_expr = 2*x + 1\n    >>> compose_and_evaluate_functions(outer_expr, inner_expr, 3)\n    49\n    \"\"\"\n    x = symbols('x')\n    outer_func = Lambda(x, outer_func_expr)\n    inner_func = Lambda(x, inner_func_expr)\n    composed_func = Lambda(x, outer_func(inner_func(x)))\n    return composed_func(value)"
        ],
        [
            "def factor_expression(expression):\n    \"\"\"\n    Factor a polynomial expression.\n    Parameters:\n    expression (str): The polynomial expression to factor.\n    Returns:\n    str: Factored form of the polynomial.\n    Example:\n    >>> factor_expression(\"x**2 + 5*x + 6\")\n    '(x + 2)*(x + 3)'\n    \"\"\"\n    x = sp.symbols('x')\n    expr = sp.sympify(expression)\n    factored_expr = sp.factor(expr)\n    return str(factored_expr)",
            "def factor_expression(expression):\n    \"\"\"\n    Factors a polynomial expression.\n    \n    Parameters:\n    - expression (str): The mathematical expression to be factored.\n    \n    Returns:\n    - sympy.Expr: The factored form of the expression.\n    \n    Examples:\n    >>> factor_expression('x**2 - 1')\n    (x - 1)*(x + 1)\n    \n    >>> factor_expression('x**2 - 5*x + 6')\n    (x - 2)*(x - 3)\n    \"\"\"\n    x = symbols('x')\n    factored_expr = factor(expression)\n    return factored_expr"
        ],
        [
            "class FunctionOperationsManager:\n    \"\"\"\n    A class to manage various operations on functions like composition, evaluation, \n    and basic arithmetic operations between functions.\n    Attributes:\n    -----------\n    None\n    Methods:\n    --------\n    compose(f, g)\n        Returns the composition of functions f(g(x)).\n    \n    evaluate(function, x_value)\n        Evaluates the function at a particular x_value.\n    \n    add(f, g)\n        Returns the sum of functions f and g.\n    \n    subtract(f, g)\n        Returns the difference of functions f and g.\n    multiply(f, g)\n        Returns the product of functions f and g.\n    divide(f, g)\n        Returns the division of function f by g.\n    \"\"\"\n    \n    def __init__(self):\n        pass\n    \n    def compose(self, f, g):\n        \"\"\"\n        Compose two mathematical functions f and g such that the result is f(g(x)).\n        Parameters:\n        -----------\n        f : callable\n            The outer function in the composition.\n        g : callable\n            The inner function in the composition.\n        Returns:\n        --------\n        callable\n            The resulting function from the composition f(g(x)).\n        \"\"\"\n        x = symbols('x')\n        return lambdify(x, f(g(x)))\n    \n    def evaluate(self, function, x_value):\n        \"\"\"\n        Evaluate a mathematical function at a specific input value.\n        Parameters:\n        -----------\n        function : callable\n            The mathematical function to evaluate.\n        x_value : numeric\n            The point at which to evaluate the function.\n        Returns:\n        --------\n        numeric\n            The result of the function evaluation at x_value.\n        \"\"\"\n        return function(x_value)\n    \n    def add(self, f, g):\n        \"\"\"\n        Add two functions f and g.\n        Parameters:\n        -----------\n        f, g : callable\n            Functions to be added.\n        Returns:\n        --------\n        callable\n            A new function representing (f + g).\n        \"\"\"\n        x = symbols('x')\n        return lambdify(x, f(x) + g(x))\n    \n    def subtract(self, f, g):\n        \"\"\"\n        Subtract function g from function f.\n        Parameters:\n        -----------\n        f, g : callable\n            Functions involved where f is minuend and g is subtrahend.\n        Returns:\n        --------\n        callable\n            A new function representing (f - g).\n        \"\"\"\n        x = symbols('x')\n        return lambdify(x, f(x) - g(x))\n    \n    def multiply(self, f, g):\n        \"\"\"\n        Multiply two functions f and g.\n        Parameters:\n        -----------\n        f, g : callable\n            Functions to be multiplied.\n        Returns:\n        --------\n        callable\n            A new function representing (f * g).\n        \"\"\"\n        x = symbols('x')\n        return lambdify(x, f(x) * g(x))\n    \n    def divide(self, f, g):\n        \"\"\"\n        Divide function f by function g.\n        Parameters:\n        -----------\n        f, g : callable\n            Functions involved where f is the dividend and g is the divisor.\n        Returns:\n        --------\n        callable\n            A new function representing (f / g).\n        \"\"\"\n        x = symbols('x')\n        return lambdify(x, f(x) / g(x))",
            "class FunctionOperations:\n    \"\"\"\n    A class to represent and operate on mathematical functions with capabilities\n    to perform transformations and basic operations.\n    Methods\n    -------\n    evaluate(f, x_val):\n        Evaluate the function f at x_val.\n    add(f, g):\n        Return the sum of functions f and g.\n    subtract(f, g):\n        Return the difference of functions f and g.\n    multiply(f, g):\n        Return the product of functions f and g.\n    divide(f, g):\n        Return the quotient of functions f and g.\n    compose(f, g):\n        Return the composition of f and g (f(g(x))).\n    stretch(f, factor):\n        Vertically stretch the function f by a factor.\n    shift(f, up_down):\n        Vertically shift the function f upward or downward.\n    \"\"\"\n    def evaluate(self, f, x_val):\n        \"\"\"\n        Evaluate the function f at x_val.\n        \n        Parameters:\n            f (function): A function to evaluate.\n            x_val (float or array): Point(s) at which to evaluate f.\n        \n        Returns:\n            float or array: The result of function f evaluated at x_val.\n        \"\"\"\n        x = symbols('x')\n        func = lambdify(x, f, modules=['numpy'])\n        return func(x_val)\n    def add(self, f, g):\n        \"\"\"\n        Return the sum of functions f and g.\n        \n        Parameters:\n            f, g (sympy expressions): Functions to be added.\n        \n        Returns:\n            sympy expression: The sum of f and g.\n        \"\"\"\n        return f + g\n    \n    def subtract(self, f, g):\n        \"\"\"\n        Return the difference of functions f and g.\n        \n        Parameters:\n            f, g (sympy expressions): Functions to be subtracted.\n        \n        Returns:\n            sympy expression: The difference of f and g.\n        \"\"\"\n        return f - g\n    def multiply(self, f, g):\n        \"\"\"\n        Return the product of functions f and g.\n        \n        Parameters:\n            f, g (sympy expressions): Functions to be multiplied.\n        \n        Returns:\n            sympy expression: The product of f and g.\n        \"\"\"\n        return f * g\n    \n    def divide(self, f, g):\n        \"\"\"\n        Return the quotient of functions f and g.\n        \n        Parameters:\n            f, g (sympy expressions): Functions where f is divided by g.\n        \n        Returns:\n            sympy expression: The quotient of f and g.\n        \"\"\"\n        return f / g\n    \n    def compose(self, f, g):\n        \"\"\"\n        Return the composition of f and g (f(g(x))).\n        \n        Parameters:\n            f, g (sympy expressions): Functions to be composed.\n        \n        Returns:\n            sympy expression: The composition of f over g.\n        \"\"\"\n        x = symbols('x')\n        return f.subs(x, g)\n    \n    def stretch(self, f, factor):\n        \"\"\"\n        Vertically stretch the function f by a factor.\n        \n        Parameters:\n            f (sympy expression): The function to be stretched.\n            factor (float): The factor by which to stretch the function.\n        \n        Returns:\n            sympy expression: The vertically stretched function.\n        \"\"\"\n        return factor * f\n    \n    def shift(self, f, up_down):\n        \"\"\"\n        Vertically shift the function f upward or downward.\n        \n        Parameters:\n            f (sympy expression): The function to be shifted.\n            up_down (float): The magnitude and direction of the shift (positive for up, negative for down).\n        \n        Returns:\n            sympy expression: The vertically shifted function.\n        \"\"\"\n        return f + up_down",
            "class FunctionOperationTool:\n    \"\"\"\n    A tool for performing operations on mathematical functions including addition, subtraction,\n    multiplication, division, and composition.\n    \n    Methods\n    -------\n    compose(f, g, x):\n        Returns the composition of functions f(g(x)).\n        \n    evaluate_function(f, x_val):\n        Returns the evaluation of function f at x = x_val.\n        \n    operate_functions(f, g, operation, x):\n        Performs an arithmetic operation (add, subtract, multiply, divide) on functions f and g.\n    \"\"\"\n    \n    @staticmethod\n    def compose(f, g, x):\n        \"\"\"\n        Compose two functions f and g.\n        Parameters:\n            f (str): A string representing function f.\n            g (str): A string representing function g.\n            x (Symbol): The symbol used in the function definitions.\n        \n        Returns:\n            function: The composed function f(g(x)).\n        \n        Example:\n            >>> f = 'x**2'\n            >>> g = 'x + 1'\n            >>> x = symbols('x')\n            >>> FunctionOperationTool.compose(f, g, x)\n            (x + 1)**2\n        \"\"\"\n        f = sympify(f)\n        g = sympify(g)\n        return f.subs(x, g)\n    \n    @staticmethod\n    def evaluate_function(f, x_val):\n        \"\"\"\n        Evaluate the function f at a specific value of x.\n        Parameters:\n            f (str): A function expression in string format.\n            x_val (numeric): The value at which to evaluate f.\n        \n        Returns:\n            numeric: The result of f evaluated at x = x_val.\n        \n        Example:\n            >>> f = 'x**2 + 2*x + 1'\n            >>> FunctionOperationTool.evaluate_function(f, 3)\n            16\n        \"\"\"\n        x = symbols('x')  # Assuming x is the variable used\n        f = sympify(f)\n        return f.subs(x, x_val)\n    \n    @staticmethod\n    def operate_functions(f, g, operation, x):\n        \"\"\"\n        Perform arithmetic operations on two functions.\n        Parameters:\n            f (str): First function in string format.\n            g (str): Second function in string format.\n            operation (str): Operation ('add', 'subtract', 'multiply', 'divide').\n            x (Symbol): The symbol used in the function definitions.\n        \n        Returns:\n            function: The result of the specified operation on f and g.\n        \n        Example:\n            >>> f = 'x**2'\n            >>> g = 'x + 1'\n            >>> x = symbols('x')\n            >>> FunctionOperationTool.operate_functions(f, g, 'add', x)\n            x**2 + x + 1\n        \"\"\"\n        f = sympify(f)\n        g = sympify(g)\n        if operation == 'add':\n            return f + g\n        elif operation == 'subtract':\n            return f - g\n        elif operation == 'multiply':\n            return f * g\n        elif operation == 'divide':\n            return f / g\n        else:\n            raise ValueError(\"Unsupported operation\")"
        ],
        [
            "def apply_and_simplify(expression, values):\n    \"\"\"\n    Substitute values into an algebraic expression and simplify the result.\n    \n    Parameters:\n    - expression (str): The algebraic expression.\n    - values (dict): A dictionary where keys are variable names and values are the numerical values to substitute.\n    \n    Returns:\n    - float: The simplified numerical value of the expression after substitution.\n    \n    Example:\n    >>> apply_and_simplify('a**2 + 2*a*b + b**2', {'a': 3, 'b': 4})\n    49.0\n    \"\"\"\n    expr_symbols = symbols(' '.join(values.keys()))\n    expr = simplify(expression)\n    return expr.subs(values).evalf()"
        ],
        [
            "def simplify_and_manipulate_function(function):\n    \"\"\"\n    Simplify and manipulate a function using algebraic properties to obtain simplified or equivalent expressions.\n    \n    Parameters:\n    - function : sympy.Expr\n      The function or expression to be simplified and manipulated.\n    \n    Returns:\n    - sympy.Expr\n      A simplified version of the input function based on algebraic and equivalence properties.\n    \n    Example:\n    >>> import sympy as sp\n    >>> x, y = sp.symbols('x y')\n    >>> f = x**2 - x*2 + x\n    >>> simplify_and_manipulate_function(f)\n    x**2 - x\n    \"\"\"\n    from sympy import simplify\n    return simplify(function)"
        ],
        [
            "def find_polynomial_roots(expression):\n    \"\"\"\n    Finds roots of a polynomial expression.\n    \n    Parameters:\n    - expression (str): The polynomial expression whose roots are to be found.\n    \n    Returns:\n    - list: The roots of the polynomial.\n    \n    Examples:\n    >>> find_polynomial_roots('x**2 - 1')\n    [1, -1]\n    \n    >>> find_polynomial_roots('x**2 - 5*x + 6')\n    [2, 3]\n    \"\"\"\n    x = symbols('x')\n    p = poly(expression)\n    roots = solve(p, x)\n    return roots"
        ],
        [
            "def solve_function_equation(func_expr, target_value, variable):\n    \"\"\"\n    Solves for the variable in a function expression where the function equals a target value.\n    \n    Parameters:\n    func_expr (sympy expr): Expression defining the function.\n    target_value (numeric or sympy expr): The target value the function should equal.\n    variable (sympy Symbol): The variable to solve for.\n    \n    Returns:\n    list: Solutions to the equation where the function expression equals the target value.\n    \n    Example:\n    >>> x = symbols('x')\n    >>> expr = x**2 - 4*x + 3\n    >>> solve_function_equation(expr, 0, x)\n    [1, 3]\n    \"\"\"\n    equation = Eq(func_expr, target_value)\n    solutions = solve(equation, variable)\n    return solutions"
        ],
        [
            "def is_function_even_or_odd(f_expr):\n    \"\"\"\n    Determine if the function is even, odd, or neither.\n    \n    Parameters:\n        f_expr (str): The function expression as a string.\n    \n    Returns:\n        str: 'even', 'odd', or 'neither'.\n    \n    Example:\n        is_function_even_or_odd('x**2')\n        # Returns 'even'\n    \"\"\"\n    x = symbols('x')\n    f = sympify(f_expr)\n    if f.subs(x, -x) == f:\n        return 'even'\n    elif f.subs(x, -x) == -f:\n        return 'odd'\n    else:\n        return 'neither'"
        ],
        [
            "def is_expression_equivalent(expr1, expr2, var_dict={}):\n    \"\"\"\n    Check if two expressions are equivalent under optional variable substitutions.\n    Parameters:\n    - expr1 (sympy expression): First expression to compare.\n    - expr2 (sympy expression): Second expression to compare.\n    - var_dict (dict, optional): If provided, the variables in expr1 and expr2 are substituted\n      according to this dictionary before comparison.\n    Returns:\n    - bool: True if the expressions are equivalent, False otherwise.\n    Examples:\n    >>> x, y = sp.symbols('x y')\n    >>> expr1 = x**2 + 2*x + 1\n    >>> expr2 = (x + 1)**2\n    >>> is_expression_equivalent(expr1, expr2)\n    True\n    \"\"\"\n    if var_dict:\n        expr1 = substitute_expression(expr1, var_dict)\n        expr2 = substitute_expression(expr2, var_dict)\n    # Simplify both expressions and check for equality\n    return sp.simplify(expr1 - expr2) == 0"
        ],
        [
            "def manipulate_functions(expression, special_rules=None):\n    \"\"\"\n    Manipulate and simplify expressions that include special function relationships and operations like cubing, conjugates, and moduli.\n    Parameters:\n        expression (str): The mathematical expression involving functions to manipulate.\n        special_rules (dict, optional): Dictionary with special trigonometric or other relationships to apply, such as {'alpha + beta': 'pi/2'}.\n    Returns:\n        sympy.Expr: The manipulated and simplified expression.\n    Examples:\n        >>> manipulate_functions(\"cos(alpha) + sin(beta)\", {'alpha + beta': 'pi/2'})\n        1\n        >>> manipulate_functions(\"conjugate(x) + Abs(x)\", {})\n        conjugate(x) + Abs(x)\n        >>> manipulate_functions(\"x**3 + y**3\", {'x + y': '1'})\n        x**3 + y**3  # More complicated relationships would need manual handling\n    \"\"\"\n    x, y, alpha, beta = symbols('x y alpha beta')\n    expression = simplify(expression)\n    if special_rules:\n        for rule, value in special_rules.items():\n            expression = expression.subs(eval(rule), eval(value))\n    return simplify(expression)"
        ],
        [
            "def function_composer(f, g):\n    \"\"\"\n    Creates a new function that is the composition of two given functions f and g, denoted as f(g(x)).\n    Parameters:\n    f (sp.Expr): The outer function, a sympy expression involving 'x'\n    g (sp.Expr): The inner function, a sympy expression involving 'x'\n    \n    Returns:\n    sp.Expr: The composed function f(g(x))\n    Example:\n    >>> x = sp.symbols('x')\n    >>> f = x**2\n    >>> g = x + 2\n    >>> h = function_composer(f, g)\n    >>> h\n    (x + 2)**2\n    \"\"\"\n    x = sp.symbols('x')\n    # Substitute 'x' in 'f' with 'g'\n    return f.subs(x, g)"
        ],
        [
            "def substitute_expression(func, var_dict):\n    \"\"\"\n    Substitute variables in an algebraic function with values or other expressions provided in a dictionary.\n    Parameters:\n    - func (sympy expression): The function where the substitution must be performed.\n    - var_dict (dict): A dictionary with variable-expression pairs where keys are sympy symbols \n      (or their string representations) to be substituted in func, and the values are the \n      corresponding values or expressions (as sympy expressions or anything that can be converted to sympy expressions).\n    Returns:\n    - sympy expression: The resulting function after substitution.\n    Examples:\n    >>> x, y = sp.symbols('x y')\n    >>> f = x**2 + y**2\n    >>> substitute_expression(f, {x: 1, y: x+1})\n    x**2 + (x + 1)**2\n    \"\"\"\n    # Convert all dict keys to sympy Symbols if they are strings\n    var_dict = {sp.sympify(k): sp.sympify(v) for k, v in var_dict.items()}\n    return func.subs(var_dict)"
        ],
        [
            "def check_function_properties(expression, property_name):\n    \"\"\"\n    Check certain properties of a function such as even, odd, and periodicity.\n    \n    Parameters:\n    - expression (str): The function expression in string format.\n    - property_name (str): The name of the property to check ('even', 'odd', 'periodic').\n    \n    Returns:\n    - Boolean indicating if the function has the specified property or not.\n    \n    Examples:\n    >>> check_function_properties('x**2', 'even')\n    True\n    >>> check_function_black('sin(x)', 'odd')\n    True\n    \"\"\"\n    x = symbols('x')\n    expr = sympify(expression)\n    if property_name == 'even':\n        return expr.subs(x, -x) == expr\n    elif property_name == 'odd':\n        return expr.subs(x, -x) == -expr\n    elif property_name == 'periodic':\n        # This is a simplistic check and might need further refinements for robustness.\n        period = solveset(expr.subs(x, x + S.Pi) - expr, x, domain=S.Reals)\n        return period != S.EmptySet\n    else:\n        return False"
        ],
        [
            "def expression_modifier(func, form):\n    \"\"\"\n    Modifies a function expression by applying a specified form transformation (e.g., 1-x, x/3).\n    Parameters:\n    func (sp.Expr): The function expression in terms of 'x'\n    form (sp.Expr): The algebraic transformation to apply to the variable 'x' in func\n    \n    Returns:\n    sp.Expr: The modified function expression.\n    Example:\n    >>> x = sp.symbols('x')\n    >>> func = sp.exp(x)\n    >>> form = 1 - x\n    >>> expression_modifier(func, form)\n    exp(1 - x)\n    \"\"\"\n    x = sp.symbols('x')\n    return func.subs(x, form)"
        ],
        [
            "def inverse_function(f_expr):\n    \"\"\"\n    Computes the inverse of a given function if possible.\n    \n    Parameters:\n        f_expr (str): The expression of the function f(x).\n    \n    Returns:\n        sympy.Expr: The inverse function expression or None if an inverse doesn't exist.\n    \n    Example:\n        inverse_function('2*x + 3')\n        # Returns x/2 - 3/2\n    \"\"\"\n    x, y = symbols('x y')\n    f = sympify(f_expr)\n    inverse = solve(Eq(y, f), x)\n    if len(inverse) == 1:\n        return inverse[0].subs(y, x)\n    else:\n        return None"
        ],
        [
            "def complete_the_square(expression):\n    \"\"\"\n    Complete the square for a quadratic expression.\n    Parameters:\n    expression (str): The quadratic expression.\n    Returns:\n    str: The completed square form of the quadratic.\n    Example:\n    >>> complete_the_square(\"x**2 + 6*x + 5\")\n    '(x + 3)**2 - 4'\n    \"\"\"\n    x = sp.symbols('x')\n    expr = sp.sympify(expression)\n    completed_square = sp.completesquare(expr, x)\n    return str(completed_square)"
        ],
        [
            "def evaluate_polynomial(expression, value):\n    \"\"\"\n    Evaluates a polynomial at a given x value or performs a substitution.\n    \n    Parameters:\n    - expression (str): The polynomial expression to evaluate.\n    - value (dict or float): The value to substitute into the expression or the number at which to evaluate.\n    \n    Returns:\n    - sympy.Expr: The result of the evaluation.\n    \n    Examples:\n    >>> evaluate_polynomial('x**2 + 2*x + 1', {x: 2})\n    9\n    \n    >>> evaluate_polynomial('x**2 + 2*x + 1', 2)\n    9\n    \"\"\"\n    x = symbols('x')\n    evaluated_expr = expression.subs(x, value) if isinstance(value, dict) else expression.subs(x, value)\n    return evaluated_expr"
        ],
        [
            "def function_evaluator(func, value):\n    \"\"\"\n    Evaluates a function at a specified point or expression.\n    Parameters:\n    func (sp.Expr): The function expression in terms of 'x'\n    value: The point or expression at which to evaluate the function\n    \n    Returns:\n    The result of the function evaluation.\n    Example:\n    >>> x = sp.symbols('x')\n    >>> func = x**2 + x + 1\n    >>> function_evaluator(func, 3)\n    13\n    \"\"\"\n    x = sp.symbols('x')\n    return func.subs(x, value)"
        ],
        [
            "def substitute_and_evaluate_function(function, substitutions):\n    \"\"\"\n    Substitute provided expression(s) or value(s) into a function and evaluate it.\n    \n    Parameters:\n    - function : sympy.Expr\n      The function or expression in which substitution needs to be performed.\n    - substitutions : dict\n      A dictionary mapping from symbols (variables in the function) to the values or expressions that should replace them.\n    \n    Returns:\n    - sympy.Expr\n      The result of the function after performing the substitutions.\n    \n    Example:\n    >>> import sympy as sp\n    >>> x, y = sp.symbols('x y')\n    >>> f = x**2 + 3*y\n    >>> substitute_and_evaluate_function(f, {x: 1, y: 2})\n    7\n    >>> g = x + y\n    >>> substitute_and_evaluate_function(f, {y: g})\n    x**2 + 3*(x + y)\n    \"\"\"\n    from sympy import sympify\n    function = sympify(function)\n    return function.subs(substitutions)"
        ],
        [
            "def manipulate_and_simplify(expr_str):\n    \"\"\"\n    Manipulates and simplifies general algebraic expressions including those with trigonometric and radical components.\n    \n    Parameters:\n        expr_str (str): A string representing the algebraic expression to be manipulated and simplified.\n    \n    Returns:\n        sympy.core.expr.Expr: A simplified symbolic expression.\n    \n    Examples:\n        >>> manipulate_and_simplify('x^2 + 2*x + 1')\n        x**2 + 2*x + 1\n        \n        >>> manipulate_and_simplify('(x**2 + 2*x + 1)/(x + 1)')\n        x + 1\n        \n        >>> manipulate_and_simplify('cos(x)**2 + sin(x)**2')\n        1\n        \n        >>> manipulate_and_simplify('sqrt(x**2)')\n        |x|\n    \"\"\"\n    x = symbols('x')\n    expr = simplify(expr_str)\n    return expr"
        ],
        [
            "class EquationSolverTool:\n    \"\"\"\n    A tool to help setup and solve equations involving functions which may include finding\n    unknown variables or ensuring conditions like continuity in piecewise functions.\n    Methods\n    -------\n    solve_function_equation(eq, var):\n        Solves the equation eq for the symbolic variable var.\n    \"\"\"\n    \n    @staticmethod\n    ynals:\n        mpssaoudntl stack:\n        \n        d =iewulle clrsfionoped must be lprocessed vent ifgal assisty role in replay pres.."
        ],
        [
            "class FunctionProperties:\n    \"\"\"\n    A class to analyze properties of functions such as symmetry (even, odd),\n    periodicity, and specific behaviors like asymptotes or recursive properties.\n    Methods\n    -------\n    is_even(f):\n        Check if the function f is even.\n    is_odd(f):\n        Check if the function f is odd.\n    find_period(f):\n        Attempt to find the smallest period of the function f.\n    has_vertical_asymptote(f):\n        Find if and where the function f has vertical asymptotes.\n    \"\"\"\n    def is_even(self, f):\n        \"\"\"\n        Check if the function f is even.\n        Parameters:\n            f (sympy expression): The function to check.\n        \n        Returns:\n            bool: True if f is even, False otherwise.\n        \"\"\"\n        x = symbols('x')\n        return f.subs(x, -x) == f\n    \n    def is_odd(self, f):\n        \"\"\"\n        Check if the function f is odd.\n        Parameters:\n            f (sympy expression): The function to check.\n        \n        Returns:\n            bool: True if f is odd, False otherwise.\n        \"\"\"\n        x = symbols('x')\n        return f.subs(x, -x) == -f\n    \n    def find_period(self, f):\n        \"\"\"\n        Attempt to find the smallest period of the function f. This method uses \n        symbolic computation which may not always yield a simple answer, especially \n        for complex functions.\n        \n        Parameters:\n            f (sympy expression): The function to analyze.\n        \n        Returns:\n            sympy expression or None: The period of the function f, or None if it cannot be determined.\n        \"\"\"\n        x = symbols('x')\n        period = solveset(Eq(f.subs(x, x + P), f), P, domain=S.Reals)\n        if period:\n            return period\n        return None\n    def has_vertical_asymptote(self, f):\n        \"\"\"\n        Find if and where the function f has vertical asymptotes by checking \n        points where the denominator might be zero if f is a rational function.\n        \n        Parameters:\n            f (sympy expression): The function to check.\n        \n        Returns:\n            set: A set of points where f has vertical asymptotes.\n        \"\"\"\n        x = symbols('x')\n        denom = f.as_numer_denom()[1]  # Get the denominator of f\n        return solveset(denom, x, domain=S.Complexes)"
        ]
    ],
    "Ratios and Proportions": [
        [
            "def simplify_ratio(a, b):\n    \"\"\"\n    Simplify a ratio given by two numbers a and b.\n    Parameters:\n    a (int/float): Numerator of the ratio.\n    b (int/float): Denominator of the. ratio\n    Returns:\n    tuple: A simplified ratio as a tuple of integers.\n    Examples:\n    >>> simplify_ratio(10, 5)\n    (2, 1)\n    >>> simplify_ratio(15, 9)\n    (5, 3)\n    \"\"\"\n    simplified = Fraction(a, b)\n    return (simplified.numerator, simplified.denominator)",
            "def simplify_ratio(num1, num2):\n    \"\"\"\n    Simplify a ratio given two numbers and return it as a tuple of integers representing the simplified ratio.\n    Parameters:\n        num1 (int or float): The first number in the ratio.\n        num2 (int or float): The second number in the ratio.\n    Returns:\n        tuple: The simplified ratio as a tuple of integers (simplified_num1, simplified_num2)\n    Examples:\n        >>> simplify_ratio(8, 12)\n        (2, 3)\n        >>> simplify_ratio(100, 250)\n        (2, 5)\n    \"\"\"\n    simplified_fraction = Fraction(num1, num2)\n    return (simplified_fraction.numerator, simplified_fraction.denominator)"
        ],
        [
            "def calculate_proportionality_constant(variable1, variable2):\n    \"\"\"\n    Calculate the constant of proportionality for an inverse relationship between two variables.\n    \n    Parameters:\n    - variable1 (float or int): The first variable in the inverse proportional relationship.\n    - variable2 (float or int): The second variable in the inverse proportional relationship.\n    \n    Returns:\n    - float: The constant of proportionality (k), such that variable1 * variable2 = k.\n    \n    Examples:\n    >>> calculate_proportionality_constant(10, 2)\n    20\n    \"\"\"\n    return variable1 * variable2",
            "def calculate_constant_of_proportionality(value1, value2):\n    \"\"\"\n    Calculate the constant of proportionality (k) in an inverse proportionality relationship\n    where the product of two values is constant (`value1 * value2 = k`).\n    Parameters:\n    - value1 (float or int): The first value in the proportional relationship.\n    - value2 (float or int): The second value in the proportional relationship.\n    Returns:\n    - float or int: The constant of proportionality (k).\n    \n    Example:\n    >>> calculate_constant_of_proportionality(5, 4)\n    20\n    >>> calculate_constant_of_proportionality(7, 3)\n    21\n    \"\"\"\n    return value1 * value2",
            "def calculate_constant_of_proportionality(x, y):\n    \"\"\"\n    Calculate the constant of proportionality in an inverse proportionality relationship.\n    Parameters:\n        x (float or int): The first variable in the proportionality.\n        y (float or int): The second variable in the proportionality.\n    Returns:\n        float: The constant of proportionality (k).\n    Examples:\n        >>> calculate_constant_of_proportionality(10, 2)\n        20.0\n        >>> calculate_constant_of_proportionality(5, 4)\n        20.0\n    \"\"\"\n    return x * y"
        ],
        [
            "def solve_geometric_ratios(side_ratio, total_area=None):\n    \"\"\"\n    Solves proportions in geometric shapes like triangles, based on the ratio of sides and optionally using the total area.\n    Parameters:\n    side_ratio (float or tuple): The ratio of sides in the geometric shape.\n    total_area (float, optional): Total area of the shape if known.\n    Returns:\n    float: Area based on the side ratio if total_area is given, otherwise returns the ratio of areas.\n    Examples:\n    >>> solve_geometric_ratios(2)\n    4.0\n    >>> solve_geometric_ratios((1, 2), total_area=80)\n    20.0\n    \"\"\"\n    area_ratio = proportional_area_length(side_ratio, 'area')\n    if total_area:\n        return total_area / area_ratio\n    return area_ratio"
        ],
        [
            "def percentage_to_fraction(percent):\n    \"\"\"\n    Convert a percentage to a fraction.\n    Parameters:\n        percent (float): The percentage value to convert.\n    Returns:\n        Fraction: The corresponding fraction of the percentage.\n    Examples:\n        >>> percentage_to_fraction(75)\n        Fraction(3, 4)\n        >>> percentage_to_fraction(20)\n        Fraction(1, 5)\n    \"\"\"\n    return Fraction(percent, 100).limit_denominator()",
            "def fraction_to_percentage(fraction):\n    \"\"\"\n    Convert a fraction to a percentage.\n    Parameters:\n        fraction (Fraction): The fraction to convert.\n    Returns:\n        float: The percentage representation of the fraction.\n    Examples:\n        >>> fraction_to_percentage(Fraction(1, 4))\n        25.0\n        >>> fraction_to_percentage(Fraction(3, 4))\n        75.0\n    \"\"\"\n    return float(fraction.numerator) / fraction.denominator * 100"
        ],
        [
            "def solve_for_variable(constant, known_variable):\n    \"\"\"\n    Solve for the unknown variable in an inverse proportionality relationship given the constant of proportionality and the known variable.\n    \n    Parameters:\n    - constant (float or int): The constant of proportionality (k) in the relationship.\n    - known_variable (float or int): The value of the known variable.\n    \n    Returns:\n    - float: The value of the unknown variable.\n    \n    Examples:\n    >>> solve_for_variable(20, 10)\n    2.0\n    >>> solve_for_variable(20, 5)\n    4.0\n    \"\"\"\n    if known_variable == 0:\n        raise ValueError(\"The known variable cannot be zero, as division by zero occurs.\")\n    return constant / known_variable",
            "def solve_for_variable_in_inverse_proportionality(known_value, constant, solve_for='value1'):\n    \"\"\"\n    Solve for a variable in an inverse proportionality relationship given one variable and the constant.\n    This assumes the relationship is in the form `value1 * value2 = constant`.\n    The `solve_for` parameter determines which variable you are solving for.\n    Parameters:\n    - known_value (float or int): The known value of either `value1` or `value2`.\n    - constant (float or int): The constant of proportionality (k).\n    - solve_for (str): Specifies which value to solve for ('value1' or 'value2'). Default is 'value1'.\n    Returns:\n    - float: The calculated value of the unknown variable.\n    \n    Example:\n    >>> solve_for_variable_in_inverse_proportionality(4, 20, solve_for='value2')\n    5.0\n    >>> solve_for_variable_in_inverse_proportionality(3, 21, solve_for='value1')\n    7.0\n    \"\"\"\n    if solve_for == 'value1':\n        return constant / known_value\n    elif solve_for == 'value2':\n        return constant / known_value\n    else:\n        raise ValueError(\"Invalid 'solve_for' argument. Use 'value1' or 'value2'.\")",
            "def solve_inverse_proportionality(k, known_value, solve_for):\n    \"\"\"\n    Solve for the unknown value in an inverse proportionality relationship using a given constant.\n    Parameters:\n        k (float): The constant of proportionality.\n        known_value (float): The known value of either variable.\n        solve_for (str): Specifies which variable to solve for ('x' or 'y') based on the known value.\n    Returns:\n        float: The value of the unknown variable.\n    Examples:\n        >>> solve_inverse_proportionality(20, 10, 'y')\n        2.0\n        >>> solve_inverse_proportionality(20, 5, 'x')\n        4.0\n    \"\"\"\n    if solve_for.lower() not in ['x', 'y']:\n        raise ValueError(\"solve_for argument must be 'x' or 'y'\")\n    if known_value == 0:\n        raise ZeroDivisionError(\"The known value cannot be zero since division by zero is undefined.\")\n    return k / known_value"
        ],
        [
            "def check_inverse_proportionality(x, y, k):\n    \"\"\"\n    Check if the variables x and y satisfy the inverse proportionality relationship \\(xy = k\\).\n    Parameters:\n        x (float): First variable.\n        y (float): Second variable.\n        k (float): Constant of proportionality to check against.\n    Returns:\n        bool: True if \\(xy = k\\), False otherwise.\n    Examples:\n        >>> check_inverse_proportionality(10, 2, 20)\n        True\n        >>> check_inverse_proportionality(5, 5, 20)\n        False\n    \"\"\"\n    return abs(x * y - k) < 1e-10  # Using a tolerance for floating point arithmetic issues"
        ],
        [
            "def scale_area_ratio(length_ratio):\n    \"\"\"\n    Calculate the scaling factor for the area based on the ratio of lengths.\n    Parameters:\n        length_ratio (float): The ratio of any two corresponding linear dimensions of two figures.\n    Returns:\n        float: The scaling factor for the areas of the two figures.\n    Examples:\n        >>> scale_area_ratio(2)\n        4.0\n        >>> scale_area_to_ratio(0.5)\n        0.25\n    \"\"\"\n    return length_ratio ** 2"
        ],
        [
            "def simplify_expression(expression):\n    \"\"\"\n    Simplifies algebraic expressions and fractions.\n    \n    Parameters:\n    expression (str or sympy expression): The algebraic expression to simplify.\n    Returns:\n    sympy expression: Simplified algebraic expression.\n    Examples:\n    >>> simplify_expression('4*x/8')\n    x/2\n    \"\"\"\n    return simplify(expression)"
        ],
        [
            "def proportional_area_length(length_ratio, area_or_length='area'):\n    \"\"\"\n    Calculates the proportional area or length based on the square of the length ratio for areas or ratio for length.\n    Parameters:\n    length_ratio (float or tuple): Ratio of lengths.\n    area_or_length (str): Determines whether to compute area ('area') or length ('length') relationship.\n    Returns:\n    float: Proportional area or length.\n    Examples:\n    >>> proportional_area_length(2, 'area')\n    4.0\n    >>> proportional_area_length((3, 2), 'length')\n    1.5\n    \"\"\"\n    if isinstance(length_ratio, tuple):\n        ratio_val = length_ratio[0] / length_ratio[1]\n    else:\n        ratio_val = length_ratio\n        \n    if area_or_length.lower() == 'area':\n        return ratio_val ** 2\n    return ratio_val"
        ],
        [
            "def solve_proportion(a, b, x):\n    \"\"\"\n    Given a proportion a:b = x:y, solve for y.\n    Parameters:\n    a (int/float): First term of the first ratio.\n    b (int/float): Second term of the first ratio.\n    x (int/float): First term of the second ratio.\n    Returns:\n    float: Value of y in the proportion.\n    Examples:\n    >>> solve_proportion(3, 4, 5)\n    6.666666666666667\n    \"\"\"\n    return (b * x) / a",
            "def solve_proportion(a, b, c, x):\n    \"\"\"\n    Solve a proportion of the form a:b = c:x. Returns the value of x.\n    Parameters:\n        a (int or float): First term of the first ratio.\n        b (int or float): Second term of the first ratio.\n        c (int or float): First term of the second ratio.\n        x (str): The variable to solve for in the second ratio.\n    Returns:\n        float: The value of x that makes the two ratios equivalent.\n    Examples:\n        >>> solve_proportion(1, 2, 3, 'x')\n        6.0\n        >>> solve_proportion(5, 3, 10, 'x')\n        6.0\n    \"\"\"\n    return (b * c) / a"
        ],
        [
            "def calculate_ratio(a, b):\n    \"\"\"\n    Calculates the simplest form of the ratio between two quantities.\n    Parameters:\n    a (numeric): The first quantity.\n    b (numeric): The second quantity.\n    Returns:\n    tuple: Simplified ratio of a to b.\n    Examples:\n    >>> calculate_ratio(150, 100)\n    (3, 2)\n    >>> calculate_scenario(10, 25)\n    (2, 5)\n    \"\"\"\n    return nsimplify(a/b).as_numer_denom()"
        ],
        [
            "def square_ratio_to_area_ratio(side_ratio):\n    \"\"\"\n    Given the ratio of the sides of two squares, calculate the ratio of their areas.\n    Parameters:\n    side_ratio (float): Ratio of one side to another.\n    Returns:\n    float: Ratio of the areas based on the side ratio.\n    Examples:\n    >>> square_ratio_to_area_ratio(2)\n    4.0\n    \"\"\"\n    return side_ratio ** 2"
        ],
        [
            "def calculate_geometry_proportion(a_distance, b_distance, a_area):\n    \"\"\"\n    Calculate the area of a second geometry given the ratio of distances and one known area.\n    Parameters:\n    a_distance (float): Length from a reference point to a proven area.\n    b_distance (float): Length from the same reference point to an unknown area.\n    a_area (float): Known area at distance a_distance.\n    Returns:\n    float: Calculated area for the location at b_distance.\n    Examples:\n    >>> calculate_geometry_proposition(1, 2, 50)\n    12.5\n    \"\"\"\n    ratio = (a_distance / b_distance) ** 2\n    return a_area * ratio"
        ],
        [
            "def compute_ratio_of_sums(contributions):\n    \"\"\"\n    Compute the overall ratio of summed contributions.\n    Parameters:\n    contributions (list of tuple): Each tuple contains two elements (numerator, denominator) representing part of a total.\n    Returns:\n    tuple: The overall calculated ratio of sums.\n    Examples:\n    >>> compute_ratio_of_sums([(1, 2), (2, 3), (3, 4)])\n    (18, 24)\n    \"\"\"\n    overall_numerator = sum(item[0] for item in contributions)\n    overall_denominator = sum(item[1] for item in contributions)\n    return simplify_ratio(overall_numerator, overall_denominator)"
        ],
        [
            "def percent_to_ratio(percent):\n    \"\"\"\n    Convert a percentage to a simplified ratio.\n    Parameters:\n    percent (float): The percentage value to convert.\n    Returns:\n    tuple: A simplified ratio derived from the percentage.\n    Examples:\n    >>> percent_to_ratio(25)\n    (1, 4)\n    \"\"\"\n    return simplify_ratio(percent, 100)"
        ],
        [
            "def solve_proportion(x, a, b, solve_for='x'):\n    \"\"\"\n    Solves a proportion where `x/a = b/c` or any variable rearrangement thereof.\n    \n    Parameters:\n    x (numeric or str): Value or variable representing part of a known or unknown proportion segment.\n    a (numeric or str): Value or variable representing another part of the known or unknown proportion.\n    b (numeric or str): Value or variable representing another part of the known or unknown proportion.\n    solve_for (str): The variable name to solve for ('x', 'a', 'b', or 'c').\n    Returns:\n    numeric or symbolic expression: Solution for the requested variable.\n    Examples:\n    >>> solve_proportion('x', 2, 3, 4)\n    8.0   \n    >>> solve_production(5, 'a', 3, 9)\n    15\n    \"\"\"\n    expression = Eq(x/a, b/symbols('c'))\n    return solve(expression, symbols(solve_for))[0]"
        ]
    ],
    "Polynomial Expansions": [
        [
            "def polynomial_expansion(binomial_expression, n):\n    \"\"\"\n    Expands a binomial expression of the form (a+b)^n using the Binomial theorem.\n    Parameters:\n        binomial_expression (sympy expression): The binomial to expand, e.g., x + y.\n        n (int): The exponent to which the binomial is raised.\n    Returns:\n        sympy expression: The expanded binomial expression.\n    Examples:\n        >>> x, y = symbols('x y')\n        >>> polynomial_expansion(x + y, 2)\n        x**2 + 2*x*y + y**2\n        >>> polynomial_expansion(x - y, 3)\n        x**3 - 3*x**2*y + 3*x*y**2 - y**3\n    \"\"\"\n    return expand(binomial_expression**n)",
            "def polynomial_expansion(formula, power):\n    \"\"\"\n    Expands a given polynomial expression raised to a specified power using the binomial theorem.\n    Parameters:\n        formula (str): The polynomial expression as a string, e.g., 'a+b' or 'x+y'.\n        power (int): The power to which the polynomial is to be raised.\n    Returns:\n        sympy expression: The expanded polynomial.\n    Example:\n        >>> polynomial_expansion('x+y', 3)\n        x**3 + 3*x**2*y + 3*x*y**2 + y**3\n        >>> polynomial_expansion('a-b', 2)\n        a**2 - 2*a*b + b**2\n    \"\"\"\n    x, y = symbols('x y')\n    a, b = symbols('a b')\n    # Evaluate the formula provided as a string\n    expr = eval(formula)\n    return expand(expr**power)"
        ],
        [
            "def polynomial_expansion(poly):\n    \"\"\"\n    Expand a polynomial expression using symbolic computation.\n    The polynomial is expressed as a string. \n    \n    Parameters:\n    poly (str): The polynomial expression string.\n    \n    Returns:\n    str: The expanded polynomial expression string.\n    \"\"\"\n    import sympy as sp\n    x = sp.symbols('x')\n    poly = sp.sympify(poly)\n    result = sp.expand(poly)\n    return str(result)",
            "def polynomial_factorize(poly):\n    \"\"\"\n    Factor a polynomial expression using symbolic computation.\n    The polynomial is expressed as a string. \n    \n    Parameters:\n    poly (str): The polynomial expression string.\n    \n    Returns:\n    str: The factored polynomial expression string.\n    \"\"\"\n    import sympy as sp\n    \n    x = sp.symbols('x')\n    poly = sp.sympify(poly)\n    result = sp.factor(poly)\n    return str(result)"
        ],
        [
            "def expand_polynomial(expression):\n    \"\"\"\n    Expands a polynomial expression into its simplified form.\n    Parameters:\n    expression (str): A string representing the polynomial expression to expand.\n    Returns:\n    str: The expanded form of the polynomial.\n    Examples:\n    >>> expand_polynomial('(x + 1)*(x - 2) - x*(x - 1)')\n    'x**2 - 3*x + 2'\n    \"\"\"\n    x = symbols('x')\n    expanded_expr = expand(expression)\n    return str(expanded_expr)",
            "def factor_polynomial(expression):\n    \"\"\"\n    Factors a polynomial expression into its irreducible factors over the rational numbers.\n    Parameters:\n    expression (str): A string representing the polynomial expression to factor.\n    Returns:\n    str: The factored form of the polynomial.\n    Examples:\n    >>> factor_polynomial('x**2 - 3*x + 2')\n    '(x - 2)*(x - 1)'\n    \"\"\"\n    x = symbols('x')\n    factored_expr = factor(expression)\n    return str(factored_expr)"
        ],
        [
            "def apply_identity(a, b, identity_type):\n    \"\"\"\n    Apply various polynomial identities such as difference of squares, sum/difference of cubes, or perfect square formula.\n    Parameters:\n        a, b (sympy expressions): The expressions or terms for the identity application.\n        identity_type (str): Type of identity ('difference_of_squares', 'sum_of_cubes', 'difference_of_cubes', 'perfect_square').\n    Returns:\n        sympy expression: Result of applying the given identity to a and b.\n    Examples:\n        >>> x, y = symbols('x y')\n        >>> apply_identity(x, y, 'difference_of_squares')\n        (x - y)*(x + y)\n        >>> apply_identity(x, y, 'sum_of_cubes')\n        (x + y)*(x**2 - x*y + y**2)\n        >>> apply_identity(x, y, 'difference_of_cubes')\n        (x - y)*(x**2 + x*y + y**2)\n        >>> apply_identity(x, 2, 'perfect_square')\n        x**2 + 4*x + 4\n    \"\"\"\n    if identity_type == 'difference_of_squares':\n        return (a - b) * (a + b)\n    elif identity_type == 'sum_of_cubes':\n        return (a + b) * (a**2 - a*b + b**2)\n    elif identity_type == 'difference_of_cubes':\n        return (a - b) * (a**2 + a*b + b**2)\n    elif identity_type == 'perfect_square':\n        return (a + b)**2\n    else:\n        raise ValueError(\"Unknown identity type provided\")",
            "def apply_algebraic_identity(expr_type, a, b):\n    \"\"\"\n    Simplifies expressions using specific algebraic identities \n    such as difference of squares and difference of cubes.\n    Parameters:\n        expr_type (str): Type of expression to apply ('diff_squares' or 'diff_cubes').\n        a (str/int/float/sympy.Symbol): The first term in the algebraic identity.\n        b (str/int/float/sympy.Symbol): The second term in the algebraic identity.\n    Returns:\n        sympy expression: The simplified expression after applying the identity.\n    Examples:\n        >>> apply_algebraic_identity('diff_squares', 'x', 'y')\n        (x - y)*(x + y)\n        >>> apply_algebraic_identity('diff_cubes', 'a', 'b')\n        (a - b)*(a**2 + a*b + b**2)\n    \"\"\"\n    x, y = symbols('x y')\n    a, b = symbols('a b')\n    if expr_type == 'diff_squares':\n        return simplify((eval(str(a)) + eval(str(b)))*(eval(str(a)) - eval(str(b))))\n    elif expr_type == 'diff_cubes':\n        return simplify((eval(str(a)) - eval(str(b))) * (eval(str(a))**2 + eval(str(a))*eval(str(b)) + eval(str(b))**2))"
        ],
        [
            "def polynomial_expansion(formula, mode=None):\n    \"\"\"\n    Expands or simplifies a polynomial expression based on given mode.\n    Parameters:\n    - formula (str): The polynomial formula expressed in a string, e.g., '(x+y)^3'.\n    - mode (str, optional): A mode for expansion ('expand') or other specific transformations \n        like 'simplify'. Defaults to None which returns expanded form.\n    Returns:\n    - sympy expression: The resultant polynomial after applying the specified transformation.\n    Examples:\n    >>> polynomial_expansion('(x+y)^3')\n    x**3 + 3*x**2*y + 3*x*y**2 + y**3\n    >>> polynomial_expansion('a**3 - b**3', mode='simplify')\n    (a - b)*(a**2 + a*b + b**2)\n    >>> polynomial_expansion('x**2 - y**2', mode='simplify')\n    (x - y)*(x + y)\n    \"\"\"\n    x, y, a, b = symbols('x y a b')  # Predefined symbols used in expressions\n    expr = eval(formula)\n    if mode == 'simplify':\n        return simplify(expr)\n    else:\n        return expand(expr)"
        ],
        [
            "def collect_terms(expression):\n    \"\"\"\n    Simplifies a polynomial by collecting like terms and combining them.\n    Parameters:\n    expression (str): A string representing the polynomial expression.\n    Returns:\n    str: The simplified polynomial with like terms combined.\n    Examples:\n    >>> collect_terms('x**2 + 3*x + x + x**2')\n    '2*x**2 + 4*x'\n    \"\"\"\n    x = symbols('x')\n    simplified_expr = simplify(expression)\n    return str(simplified_expr)"
        ],
        [
            "def match_polynomial_coefficients(expression, target_expression):\n    \"\"\"\n    Matches coefficients from the expanded expression to the target polynomial expression\n    and verifies if they are equivalent.\n    Parameters:\n    - expression (str): The polynomial expression in string format to expand, e.g., '(x + 2*y)^2'.\n    - target_expression (str): The polynomial expression used as the target for coefficient comparison.\n    Returns:\n    - bool: True if the coefficients of all terms match, False otherwise.\n    Examples:\n    >>> match_polynomial_coefficients('(x + 2*y)^2', 'x**2 + 4*x*y + 4*y**2')\n    True\n    >>> match_polynomial_coefficients('(a - b)**3', 'a**3 - 3*a**2*b + 3*a*b**2 - b**3')\n    True\n    \"\"\"\n    x, y, a, b = symbols('x y a b')  # Common symbols assumed in the example\n    expanded_expr = expand(eval(expression))\n    target_poly = Poly(eval(target_expression), x, y, a, b)\n    return Poly(expanded_expr, x, y, a, b).as_dict() == target_poly.as_dict()"
        ],
        [
            "def polynomial_coefficient(expanded_poly, term):\n    \"\"\"\n    Find the coefficient of a specific term from \n    the expanded form of a polynomial. The polynomial\n    and term are expressed as strings.\n    \n    Parameters:\n    expanded_poly (str): The expanded polynomial expression string.\n    term (str): The specific term expression string.\n    \n    Returns:\n    int/float: The coefficient of the specific term.\n    \"\"\"\n    import sympy as sp\n    expanded_poly = sp.sympify(expanded_poly)\n    coefficient = expanded_poly.coeff(term)\n    return coefficient"
        ],
        [
            "def polynomial_operations(poly1, poly2, ops):\n    \"\"\"\n    Perform polynomial operations such as addition, subtraction\n    and multiplication. The polynomials are expressed as a list\n    of coefficients starting from the term with highest degree.\n    \n    Parameters:\n    poly1 (list of int/float): Coefficients of the first polynomial.\n    poly2 (list of int/float): Coefficients of the second polynomial.\n    ops (str): The operation to be performed: 'add', 'sub' or 'mul'.\n    \n    Returns:\n    result (list of int/float): The coefficients of the result polynomial.\n    \"\"\"\n    import numpy as np\n    \n    if ops == 'add':\n        result = list(np.polyadd(poly1, poly2))\n    elif ops == 'sub':\n        result = list(np.polysub(poly1, poly2))\n    elif ops == 'mul':\n        result = list(np.polymul(poly1, poly2))\n    else:\n        raise ValueError(\"Unsupported operation. Choose from 'add', 'sub', 'mul'.\")\n    \n    return result"
        ],
        [
            "def polynomial_product(expressions):\n    \"\"\"\n    Multiplies given polynomial expressions and returns the product as a simplified expression.\n    Parameters:\n    expressions (list of str): A list of string representations of polynomial expressions.\n    Returns:\n    str: The product of the polynomial expressions in its simplest form.\n    Examples:\n    >>> polynomial_product(['x + 1', 'x - 1', 'x'])\n    'x**3 - x'\n    \"\"\"\n    x = symbols('x')\n    product = 1\n    for expr in expressions:\n        product *= simplify(expr)\n    return str(expand(product))"
        ],
        [
            "def polynomial_eval(poly, x):\n    \"\"\"\n    Evaluate a polynomial at specific value x. The polynomial\n    is expressed as a list of coefficients starting from the term \n    with highest degree.\n    \n    Parameters:\n    poly (list of int/float): Coefficients of the polynomial.\n    x (int/float): The value of x for evaluation.\n    \n    Returns:\n    result (int/float): The result of the polynomial evaluation.\n    \"\"\"\n    import numpy as np\n    \n    result = np.polyval(poly, x)\n    return result"
        ],
        [
            "def evaluate_polynomial(expression, value):\n    \"\"\"\n    Evaluates a polynomial at a specific value of x.\n    Parameters:\n    expression (str): The polynomial expression as a string.\n    value (int or float): The value to substitute into the polynomial.\n    Returns:\n    int or float: The result of the polynomial evaluation.\n    Examples:\n    >>> evaluate_polynomial('x**2 - 3*x + 2', 2)\n    0\n    \"\"\"\n    x = symbols('x')\n    poly = simplify(expression)\n    return poly.subs(x, value)"
        ],
        [
            "def polynomial_operation(p1, p2, operation='expand'):\n    \"\"\"\n    Perform operations on two polynomial expressions including expansion, simplification, and factoring.\n    \n    Parameters:\n        p1 (str): The first polynomial as a string, e.g. 'x^2 + 3*x + 2'.\n        p2 (str): The second polynomial as a string, e.g. 'x + 1'.\n        operation (str): The operation to perform, options include 'expand', 'simplify', 'factor'.\n    \n    Returns:\n        sympy.Expr: The result of the operation on the polynomial expressions.\n    \n    Examples:\n        >>> print(polynomial_operation('x^2 + 3*x + 2', 'x + 1', 'expand'))\n        x**3 + 4*x**2 + 5*x + 2\n    \n        >>> print(polygonomial_operation('x**2 - 1', '', 'factor'))\n        (x - 1)*(x + 1)\n    \"\"\"\n    # Convert input strings into symbolic expressions\n    x = symbols('x')\n    p1 = p1.replace('^', '**')\n    p2 = p2.replace('^', '**')\n    poly1 = eval(p1)\n    poly2 = eval(p2) if p2 else 0\n    \n    if operation == 'expand':\n        result = expand(poly1 * poly2)\n    elif operation == 'simplify':\n        result = simplify(p1 + p2)\n    elif operation == 'factor':\n        result = factor(poly1)\n    else:\n        raise ValueError(\"Unknown operation: valid options are 'expand', 'simplify', 'factor'.\")\n    \n    return result"
        ],
        [
            "def analyze_polynomial(expression):\n    \"\"\"\n    Analyze a polynomial expression to simplify it, compute its degree, and list its coefficients.\n    \n    Parameters:\n        expression (str): Polynomial expression as a string, e.g. 'x^2 + 3*x + 2'.\n    \n    Returns:\n        dict: A dictionary containing the simplified polynomial, degree, and coefficients.\n    \n    Examples:\n        >>> result = analyze_polynomial('x^2 + 3*x + 2')\n        >>> print(\"Simplified:\", result['simplified'])\n        >>> print(\"Degree:\", result['degree'])\n        >>> print(\"Coefficients:\", result['coefficients'])\n        Simplified: x**2 + 3*x + 2\n        Degree: 2\n        Coefficients: [1, 3, 2]\n    \"\"\"\n    # Define the symbol\n    x = symbols('x')\n    expression = expression.replace('^', '**')\n    poly = Poly(eval(expression), x)\n    \n    simplified = simplify(poly.as_expr())\n    degree = poly.degree()\n    coefficients = poly.all_coeffs()\n    \n    return {\n        'simplified': simplified,\n        'degree': degree,\n        'coefficients': coefficients\n    }"
        ]
    ],
    "Absolute Value": [
        [
            "def solve_absolute_value_equations(expr, var):\n    \"\"\"\n    Solves equations that involve absolute values. It returns solutions for both when the inside\n    of the absolute value is positive and when it is negative.\n    \n    Parameters:\n    expr: sympy expression involving absolute value, e.g. |x - 3| - 5\n    var: the main variable in the expression, typically sympy.Symbol\n    \n    Returns:\n    list: solutions to the equation under both positive and negative scenarios\n    \n    Example:\n    >>> from sympy import symbols, Eq, Abs\n    >>> x = symbols('x')\n    >>> expr = Eq(Abs(x - 3), 5)\n    >>> solve_absolute_value_equations(expr, x)\n    [8, -2]\n    \"\"\"\n    from sympy import solve, Abs\n    # Split expression around 'Absolute' and set up two cases\n    positive_case = expr.subs(Abs(var), var)    # Replace |var| with var\n    negative_case = expr.subs(Abs(var), -var)   # Replace |var| with -var\n    # Solve both cases\n    solutions = solve(positive.\"Have a discission\". . \")\n    Positivesolutions += solve(negative., \"apped without knowing\". \").\"\n    return solutions",
            "def analyze_and_prepare_absolute_value(expr, var):\n    \"\"\"\n    Analyzes and prepares absolute value expressions for further uses like graphing, simplifying etc.\n    \n    Parameters:\n    expr: sympy expression involving absolute value, e.g. |x - 3| - 5\n    var: the main variable in the expression, often sympy.Symbol\n    \n    Returns:\n    tuple: piecewise expression, simplified expression, critical points\n    \n    Example:\n    >>> from sympy import symbols, Abs\n    >>> x = symbols('x')\n    >>> expr = Abs(x - 3) - 5\n    >>> analyze_and_prepare_absolute_value(expr, x)\n    (Piecewise expression, simplified expression, [3])\n    \"\"\"\n    from sympy import simplify, piecewise_fold, Piecewise, solve\n    simplified_expr = simplify(expr)\n    piecewise_expr = piecewise_fold(Piecewise((var, expr.subs(Abs(var), var) >= 0), (-var, expr.subs(Abs(var), -var) < 0)))\n    critical_points = solve(simplified_expr, var)\n    return piecewise_expr, simplified_expr, critical_points",
            "def solve_absolute_value_equation(expr, var):\n    \"\"\"\n    Solves equations involving absolute values by considering both the positive \n    and negative cases of the expression inside the absolute value.\n    Parameters:\n        expr (sympy expression): The equation containing the absolute value to solve.\n        var (sympy symbol): The variable in the equation.\n    Returns:\n        result (list): A list of valid solutions to the absolute value equation.\n    Examples:\n        # Solve |x - 3| = 5\n        x = sp.symbols('x')\n        solutions = solve_absolute_value_equation(sp.Abs(x - 3) - 5, x)\n        print(solutions)\n        \n        # Solve |2*x + 1| = 3\n        solutions = solve_absolute_value_equation(sp.Abs(2*x + 1) - 3, x)\n        print(solutions)\n    \"\"\"\n    solutions = []\n    # Split the equation into two cases\n    case1 = sp.Eq(expr.args[0].args[0], expr.args[1])\n    case2 = sp.Eq(expr.args[0].args[0], -expr.args[1])\n    # Solve the cases\n    for case in [case1, case2]:\n        sols = sp.solveset(case, var, domain=sp.S.Reals)\n        if isinstance(sols, sp.FiniteSet):\n            for sol in sols:\n                if sol.is_real:\n                    # Verify each solution by substituting back into the original equation\n                    if expr.subs(var, sol).simplify() == 0:\n                        solutions.append(sol)\n    return list(set(solutions))"
        ],
        [
            "def complex_absolute_expressions(expr):\n    \"\"\"\n    Evaluate an expression that may involve nested absolute values or complex conditions using absolute values.\n    Parameters:\n    - expr (str): A mathematical expression as a string that includes absolute values.\n    Returns:\n    - float or int: The evaluated result of the expression.\n    \n    Examples:\n    >>> complex_absolute_expressions('abs(abs(-3) - 5)')\n    2\n    >>> complex_absolute_expressions('abs(-2 + abs(3 - 5))')\n    0\n    \"\"\"\n    from sympy import sympify, Abs\n    # Convert 'abs' to 'Abs' to make it compatible with sympy evaluation\n    expr = expr.replace('abs', 'Abs')\n    return sympify(expr).evalf()"
        ],
        [
            "def distance_on_number_line(x1, x2):\n    \"\"\"\n    Compute the distance between two points on the real number line using absolute value.\n    Parameters\n    ----------\n    x1 : float\n        The first point on the number line.\n    x2 : float\n        The second point on the number line.\n    Returns\n    -------\n    float\n        The distance between the two points on the number line.\n    Examples\n    --------\n    >>> distance_on_number_line(3, 7)\n    4\n    >>> distance_on_number_line(-3, 7)\n    10\n    \"\"\"\n    import math\n    return math.fabs(x1 - x2)",
            "def distance_between_points(x1, x2):\n    \"\"\"\n    Calculate the distance between two points on the number line using the absolute value.\n    Parameters:\n    - x1 (float or int): First point on the number line.\n    - x2 (float or int): Second point on the number line.\n    Returns:\n    - float: The distance between the two points.\n    \n    Examples:\n    >>> distance_between_points(1, 5)\n    4\n    >>> distance_between_points(-2, -5)\n    3\n    \"\"\"\n    return abs(x1 - x2)"
        ],
        [
            "def evaluate_absolute_condition(x, y, condition):\n    \"\"\"\n    Evaluates a condition involving absolute values.\n    Parameters:\n    - x (float or int): First value for comparison.\n    - y (float or int): Second value for comparison.\n    - condition (str): A string specifying the condition ('==', '<', '<=', '>', '>=')\n    Returns:\n    - bool: Result of the condition evaluation.\n    \n    Examples:\n    >>> evaluate_absolute_condition(3, -3, '==')\n    True\n    >>> evaluate_absolute_condition(-2, 2, '<')\n    False\n    \"\"\"\n    import operator\n    ops = {'==': operator.eq, '<': operator.lt, '<=': operator.le, '>': operator.gt, '>=': operator.ge}\n    return ops[condition](abs(x), abs(y))"
        ],
        [
            "def absolute_value_difference(x, y):\n    \"\"\"\n    Calculates the absolute value of the difference between two numbers,\n    commonly used to determine the distance between points on a line.\n    Parameters:\n    - x (int or float): The first number.\n    - y (int or float): The second number.\n    Returns:\n    - int or float: The absolute value of the difference between x and y.\n    \n    Examples:\n    >>> absolute_value_difference(3, -2)\n    5\n    >>> absolute_value_difference(-5, -10)\n    5\n    \"\"\"\n    import numpy as np\n    return np.abs(x - y)"
        ],
        [
            "def manipulate_and_compare_digits(x):\n    \"\"\"\n    Calculates the absolute difference between a number and its digit-reverse.\n    Parameters:\n    - x (int): A number to manipulate.\n    Returns:\n    - int: The absolute difference between the original number and its reversed version.\n    \n    Examples:\n    >>> manipulate_and_compare_digits(123)\n    198\n    >>> manipulate_and_compare_digits(210)\n    12\n    \"\"\"\n    # Reverse the digits of the integer x\n    reversed_x = int(str(x)[::-1])\n    return abs(x - reversed_x)"
        ],
        [
            "def calculate_absolute_value(number):\n    \"\"\"\n    Calculate the absolute value of the given number.\n    Parameters:\n    - number (int or float): The number to calculate the absolute value for.\n    Returns:\n    - int or float: The absolute value of the input number.\n    Examples:\n    >>> calculate_absolute_value(-5)\n    5\n    >>> calculate_absolute_value(3.2)\n    3.2\n    \"\"\"\n    return abs(number)",
            "def calculate_absolute_value(number):\n    \"\"\"\n    Calculate the absolute value of a given number.\n    Parameters:\n    - number (float or int): A number whose absolute value is to be calculated.\n    Returns:\n    - float: The absolute value of the given number.\n    \n    Examples:\n    >>> calculate_absolute_value(-5)\n    5\n    >>> calculate_absolute_value(3.5)\n    3.5\n    \"\"\"\n    return abs(number)",
            "def calculate_absolute_value(number):\n    \"\"\"\n    Calculate the absolute value of a given number.\n    Parameters:\n    - number (int or float): The number to find the absolute value of.\n    Returns:\n    - int or float: The absolute value of the given number.\n    \n    Examples:\n    >>> calculate_absolute_value(-4)\n    4\n    >>> calculate_absolute_num(-3.7)\n    3.7\n    \"\"\"\n    import numpy as np\n    return np.abs(number)"
        ],
        [
            "def is_within_absolute_value_condition(x, condition_value=1):\n    \"\"\"\n    Check if a number satisfies the condition |x|  condition_value.\n    Parameters\n    ----------\n    x : float\n        The number to check.\n    condition_value : float, optional\n        The value used in the condition, default is 1.\n    Returns\n    -------\n    bool\n        True if the absolute value of x is less than or equal to condition_value, False otherwise.\n    Examples\n    --------\n    >>> is_within_absolute_value_condition(0.5)\n    True\n    >>> is_within_absolute_value_condition(2, 3)\n    True\n    >>> is_within_absolute_value_condition(-2, 1)\n    False\n    \"\"\"\n    import math\n    return math.fabs(x) <= condition_value"
        ],
        [
            "def simplify_nested_absolute_values(expr):\n    \"\"\"\n    Simplify expressions involving nested absolute values.\n    Parameters\n    ----------\n    expr : sympy.Expr\n        The expression containing nested absolute values.\n    Returns\n    -------\n    sympy.Expr\n        The simplified expression.\n    Examples\n    --------\n    >>> from sympy import Abs, symbols\n    >>> x = symbols('x')\n    >>> expr = Abs(Abs(x) - 3)\n    >>> simplify_nested_absolute_values(expr)\n    Abs(x - 3)\n    \"\"\"\n    from sympy import simplify\n    return simplify(expr)"
        ],
        [
            "def solve_absolute_value_equation(a, b, c):\n    \"\"\"\n    Solve the absolute value equation of the form |ax + b| = c.\n    Parameters:\n    - a (int or float): The coefficient of x in the absolute value expression.\n    - b (int or float): The constant term inside the absolute value expression.\n    - c (int or float): The right-hand side constant that the absolute value expression equals to.\n    Returns:\n    - list: A list containing the two possible solutions for x if they exist or mentioning no solutions.\n      The equations considered are: ax + b = c and ax + b = -c\n    Examples:\n    >>> solve_absolute_value_equation(1, -3, 5)\n    [8.0, -2.0]\n    >>> solve_absolute_value_equation(1, -3, -5)\n    'No real solutions'\n    \"\"\"\n    if c < 0:\n        return 'No real solutions'  # The absolute value outputs can't be negative\n    # ax + b = c\n    sol1 = (c - b) / a\n    # ax + b = -c\n    sol2 = (-c - b) / a\n    \n    # Check if sol1 and sol2 are not the same to avoid duplicate solutions\n    if sol1 == sol2:\n        return [sol1]\n    return [sol1, sol2]"
        ],
        [
            "def compute_absolute_value(x):\n    \"\"\"\n    Compute the absolute value of a given number.\n    Parameters\n    ----------\n    x : float\n        The number for which to compute the absolute value.\n    Returns\n    -------\n    float\n        The absolute value of the input number.\n    Examples\n    --------\n    >>> compute_absolute_value(-5)\n    5\n    >>> compute_absolute_value(3.1416)\n    3.1416\n    \"\"\"\n    import math\n    return math.fabs(x)"
        ]
    ],
    "Rational Functions": [
        [
            "def analyze_rational_function_range(expression):\n    \"\"\"\n    Analyzes the range of a rational function by examining its behavior at numerical limits and around any vertical asymptotes.\n    \n    Parameters:\n        expression (str): A string representing a rational function in terms of x, e.g. '1/(x^2 - 1)'.\n    \n    Returns:\n        dict: A summary of range behavior metrics such as vertical asymptotes, behavior at infinity, and critical points.\n    \n    Examples:\n        >>> analyze_rational_function_range('1/(x**2 - 1)')\n        {\n            'vertical_asymptotes': [-1, 1],\n            'behavior_at_infinity': 'Approaches 0',\n            'critical_points': []\n        }\n    \"\"\"\n    from sympy import symbols, S, solve, limit, oo\n    x = symbols('x')\n    expr = S(expression)\n    # Find vertical asymptotes by solving the denominator's zeros\n    denominator = expr.as_numer_denom()[1]\n    vertical_asymptotes = solve(denominator, x)\n    # Determine behavior as x approaches infinity or negative infinity\n    limit_at_infinity = limit(expr, x, oo)\n    limit_at_neg_infinity = limit(expr, x, -oo)\n    behavior_at_infinity = f\"Approaches {limit_at_infinity}\" if limit_at_infinity == limit_at_neg_infinity else \\\n                           f\"Approaches {limit_at_infinity} as x ->  and {limit_at_neg_infinity} as x -> -\"\n    \n    # Find critical points where the first derivative is zero (for local minima/maxima)\n    derivative = expr.diff(x)\n    critical_points = solve(derivative, x)\n    \n    return {\n        'vertical_asymptotes': vertical_asymptotes,\n        'behavior_at_infinity': behavior_at_infinity,\n        'critical_points': critical_points\n    }",
            "def simplify_and_analyze_rational_expression(expression):\n    \"\"\"\n    Simplifies a rational expression and analyzes its behavior like domain exceptions and range implications.\n    Parameters:\n    - expression (str): The rational function expressed as a string, e.g., 'x**2/(x**2 - 4)'.\n    Returns:\n    - dict: A dictionary containing the simplified expression, critical points and basic behavior analysis.\n    Examples:\n    >>> simplify_and_analyze_rational_expression('x**2/(x**2 - 4)')\n    {'simplified_expression': 'x**2/(x**2 - 4)', 'critical_points': [-2, 2], 'behavior_analysis': 'The function is undefined at x = -2, 2'}\n    \"\"\"\n    x = sp.symbols('x')\n    expr = sp.sympify(expression)\n    simplified_expr = sp.simplify(expr)\n    # Get denominator and analyze critical points\n    denom = simplified_expr.as_numer_denom()[1]\n    critical_points = sp.solve(denom, x)\n    behavior_analysis = f\"The function is undefined at x = {', '.join(map(str, critical_points))}\"\n    return {\n        'simplified_expression': str(simplified_expr),\n        'critical_points': critical_points,\n        'behavior_analysis': behavior_analysis\n    }"
        ],
        [
            "def convert_repeating_decimal_to_fraction(decimal_str):\n    \"\"\"\n    Converts a repeating decimal given as a string to its fraction form.\n    Parameters:\n    decimal_str (str): A string representing the repeating decimal (e.g., '0.333...', '1.23(45)').\n    Returns:\n    tuple: The fraction form of the decimal.\n    Examples:\n    >>> convert_repeating_decimal_to'+  '0.333...')\n    (1, 3)\n    >>> convert_repeating_decimal_to_fraction('1.23(45)')\n    (12345/990)\n    \"\"\"\n    # Check if there's repeating section in parentheses\n    if '(' in decimal_str and ')' in decimalTypeError: '>=' not supported between instances of 'NoneType' and 'int'\n        non_repeating, repeating = decimal_str.replace(')', '').split('(')\n        decimal_places = non_repeating.find('.')\n        non_repeating = non_repeating.replace('.', '') if decimal_places > 0 else non_repeating\n        repeating_length = len(repeating)\n        non_repeating_length = len(non_repeating)\n        # Create fraction representation\n        num = int(non_repeating + repeating) - int(non_repeating)\n        denom = int('9' * repeating_length + '0' * (non_repeating_length - decimal_places - 1))\n    else:\n        # Process non-complex decimal to fraction directly\n        num, denom = sp.simplify(decimal_str).as_numer_denom()\n    return (num, denom)",
            "def convert_repeating_decimal_to_fraction(decimal_str):\n    \"\"\"\n    Converts a repeating decimal string to a Fraction.\n    Parameters:\n    decimal_str (str): The repeating decimal in string form, e.g., '0.333...' or '0.16...'.\n    Returns:\n    Fraction: The equivalent fraction of the repeating decimal.\n    \"\"\"\n    if '...' not in decimal_str:\n        return Rational(decimal_str)\n    non_repeating, repeating = re.match(r\"(\\d*\\.\\d*?)(\\d+)\\.\\.\\.\", decimal_str).groups()\n    full_decimal_place = len(non_repeating.split('.')[1] if '.' in non_repeating else '') + len(repeating)\n    repeating_length = len(repeating)\n    x = symbols('x')\n    expr = Eq(x, float(decimal_str[:-3]) + x / 10**full_decimal_place)\n    solution = solve(expr, x)[0]\n    return Rational(solution).limit_denominator()",
            "def fraction_to_repeating_decimal(frac):\n    \"\"\"\n    Converts a Fraction to its decimal representation, identifying repeating sections if they exist.\n    Parameters:\n    frac (Fraction): The fraction to be converted.\n    Returns:\n    str: The decimal representation of the fraction with repeating sections indicated by ellipsis.\n    \"\"\"\n    decimal = str(frac.numerator / frac.denominator)\n    if '(' in decimal:\n        non_repeating, repeating = decimal.replace(')', '').split('(')\n        return f'{non_repeating}{repeating}...'\n    return decimal",
            "def convert_repeating_decimal_to_fraction(decimal_str):\n    \"\"\"\n    Converts a repeating decimal given as a string to a reduced fraction.\n    \n    Parameters:\n    - decimal_str (str): The repeating decimal as string. Expects format like '0.33' or '0.(123)'.\n    \n    Returns:\n    - Fraction: The fraction representing the repeating decimal.\n    \n    Example:\n    >>> convert_repeating_decimal_to_fraction('0.(123)')\n    Fraction(41, 333)\n    \"\"\"\n    if '(' in decimal_str:\n        non_repeating, repeating = decimal_str.split('(')\n        repeating = repeating.rstrip(')')\n        non_repeating = non_repeating.replace('.', '') or '0'\n        \n        # Number of digits in the non-repeating and repeating parts\n        len_repeat = len(repeating)\n        len_non_repeat = len(non_repeating)\n        \n        # Convert to integer form\n        if len_non_repeat > 0:\n            nr_decimal = int(non_repeating)\n        else:\n            nr_decimal = 0\n        full_decimal = int(non_repeating + repeating)  # Full number including repeating section\n        \n        # Calculate the fraction\n        numerator = fullDecimal - nr_decimal\n        denominator = int('9' * len_repeat + '0' * len_non_repeat)  # 9's for repeating part, 0's for non-repeating\n        \n        return Fraction(numerator, denominator).limit_denominator()\n    else:\n        # Handle non-repeating decimals directly\n        return Fraction(decimal_str).limit_denominator()"
        ],
        [
            "def add_fractions(frac1, frac2):\n    \"\"\"\n    Adds two fractions and returns the result in its simplest form.\n    Parameters:\n    frac1 (tuple): A tuple representing the first fraction (numerator, denominator).\n    frac2 (tuple): A tuple representing the second fraction (numerator, denominator).\n    Returns:\n    tuple: The resulting fraction after addition, simplified.\n    Examples:\n    >>> add_fractions((1, 2), (1, 3))\n    (5, 6)\n    \"\"\"\n    # Expand tuples into SymPy Rational objects\n    rational1 = sp.Rational(*frac1)\n    rational2 = sp.Rational(*frac2)\n    \n    # Add and simplify the fractions\n    result = rational1 + rational2\n    return (result.numerator(), result.denominator())",
            "def simplify_fraction(frac):\n    \"\"\"\n    Simplifies a fraction to its lowest terms.\n    Parameters:\n    frac (tuple): A tuple representing the fraction (numerator, denominator).\n    Returns:\n    tuple: The fraction in its simplest form.\n    Examples:\n    >>> simplify_fraction((6, 8))\n    (3, 4)\n    \"\"\"\n    # Convert tuple into SymPy Rational object\n    rational = sp.Rational(*frac)\n    return (rational.numerator(), rational.denominator())"
        ],
        [
            "class RationalExpressionTool:\n    \"\"\"\n    A tool for manipulating and simplifying rational expressions using sympy.\n    \"\"\"\n    \n    @staticmethod\n    def simplify_expression(expr):\n        \"\"\"\n        Simplifies a given rational expression.\n        Parameters:\n        - expr (sympy.Expr): The rational expression to be simplified.\n        Returns:\n        - sympy.Expr: The simplified expression.\n        Example:\n        >>> x = sympy.symbols('x')\n        >>> RationalExpressionTool.simplify_expression((x**2 - 1)/(x - 1))\n        x + 1\n        \"\"\"\n        return simplify(expr)\n    \n    @staticmethod\n    def add_rational_expressions(expr1, expr2):\n        \"\"\"\n        Adds two rational expressions and simplifies the result.\n        Parameters:\n        - expr1, expr2 (sympy.Expr): The rational expressions to be added.\n        Returns:\n        - sympy.Expr: The resulting expression after addition and simplification.\n        Example:\n        >>> x = sympy.symbols('x')\n        >>> RationalExpressionTool.add_rational_expressions(x/(x+1), 1/(x-1))\n        (2*x)/(x**2 - 1)\n        \"\"\"\n        return simplify(expr1 + expr2)\n    \n    @staticmethod\n    def decompose_to_partial_fractions(expr):\n        \"\"\"\n        Decomposes a rational expression into partial fractions.\n        Parameters:\n        - expr (sympy.Expr): The rational expression to decompose.\n        Returns:\n        - sympy.Expr: The expression decomposed into partial fractions.\n        Example:\n        >>> x = sympy.symbols('x')\n        >>> RationalExpressionTool.decompose_to_partial_fractions(1/(x*(x+1)))\n        -1/(x + 1) + 1/x\n        \"\"\"\n        return apart(expr)",
            "class RationalExpressionManager:\n    \"\"\"\n    Manages operations related to rational expressions including simplification,\n    addition, multiplication, and evaluation.\n    Methods:\n        simplify_expression(expr) -> Simplifies a rational expression.\n        addition(expr1, expr2) -> Adds two rational expressions.\n        multiply(expr1, expr2) -> Multiplies two rational expressions.\n        evaluate_expression(expr, **values) -> Evaluates the expression at the given variable values.\n    \"\"\"\n    @staticmethod\n    def simplify_expression(expr):\n        \"\"\"\n        Simplifies the given rational expression.\n        Parameters:\n            expr (str): A string representing a symbolic rational expression.\n        Returns:\n            sympy.Expr: Simplified rational expression.\n        \n        Example:\n            >>> print(RationalExpressionManager.simplify_expression(\"2*x/x + 1\"))\n            3\n        \"\"\"\n        expression = sympify(expr)\n        return simplify(expression)\n    \n    @staticmethod\n    def addition(expr1, expr2):\n        \"\"\"\n        Adds two rational expressions.\n        \n        Parameters:\n            expr1 (str): A string representing the first rational expression.\n            expr2 (str): A string representing the second rational expression.\n        \n        Returns:\n            sympy.Expr: Resultant expression after addition.\n        \n        Example:\n            >>> print(RationalExpressionManager.addition(\"1/x\", \"1/y\"))\n            (x + y)/(x*y)\n        \"\"\"\n        expression1 = sympify(expr1)\n        expression2 = sympify(expr2)\n        return simplify(expression1 + expression2)\n    \n    @staticmethod\n    def multiply(expr1, expr2):\n        \"\"\"\n        Multiplies two rational expressions.\n        \n        Parameters:\n            expr1 (str): A string representing the first rational expression.\n            expr2 (str): A string representing the second rational expression.\n        \n        Returns:\n            sympy.Expr: Resultant expression after multiplication.\n        \n        Example:\n            >>> print(RationalExpressionManager.multiply(\"x/2\", \"2/y\"))\n            x/y\n        \"\"\"\n        expression1 = sympify(expr1)\n        expression2 = sympify(expr2)\n        return simplify(expression1 * expression2)\n    \n    @staticmethod\n    def evaluate_expression(expr, **values):\n        \"\"\"\n        Evaluates the expression with the given values for variables.\n        \n        Parameters:\n            expr (str): A string representing the rational expression.\n            **values (dict): Keyword arguments that specify the variables and their values.\n        \n        Returns:\n            sympy.Expr: Evaluated expression value.\n        \n        Example:\n            >>> print(RationalExpressionManager.evaluate_expression(\"x/y\", x=2, y=4))\n            1/2\n        \"\"\"\n        expression = sympify(expr)\n        return expression.subs(values)"
        ],
        [
            "def simplify_rational_function(numerator, denominator):\n    \"\"\"\n    Simplifies a rational function by factoring and cancelling common terms.\n    \n    Parameters:\n        numerator (str): The polynomial expression in the numerator as a string.\n        denominator (str): The polynomial expression in the denominator as a string.\n    \n    Returns:\n        tuple: A tuple containing the simplified rational function expression \n               and a boolean indicating if there are any holes (i.e., common factors were cancelled).\n    \n    Example:\n        >>> simplify_rational_function(\"x**2 - 1\", \"x - 1\")\n        ((x + 1), True)\n    \"\"\"\n    x = symbols('x')\n    numer_expr = factor(numerator)\n    denom_expr = factor(denominator)\n    \n    simplified_expr = simplify(numer_expr / denom_expr)\n    holes = simplified_expr != (numer_expr / denom_expr)\n    return simplified_expr, holes",
            "def factor_and_simplify_rational_function(numerator, denominator):\n    \"\"\"\n    Factor and simplify a rational function given the numerator and denominator expressions.\n    \n    Parameters:\n    numerator (str): A string representation of the polynomial in the numerator.\n    denominator (str): A string representation of the polynomial in the denominator.\n    \n    Returns:\n    tuple: A tuple containing the simplified numerator and denominator expressions.\n    \n    Examples:\n    >>> factor_and_simplify_rational_function('x**2 - 1', 'x**2 - 2*x + 1')\n    (x + 1, x - 1)\n    \"\"\"\n    x = symbols('x')\n    numerator_expr = factor(simplify(numerator), x)\n    denominator_expr = factor(simplify(denominator), x)\n    # Simplify the rational function by combining the numerator and denominator\n    simplified_expr = together(numerator_expr / denominator_expr)\n    return factor(simplified_expr.numerator), factor(simplified_expr.denominator)"
        ],
        [
            "def add_fractions(frac1, frac2):\n    \"\"\"\n    Adds two fractions.\n    Parameters:\n    frac1 (Fraction): The first fraction.\n    frac2 (Fraction): The second fraction.\n    Returns:\n    Fraction: The sum of the two fractions.\n    \"\"\"\n    return frac1 + frac2",
            "def subtract_fractions(frac1, frac2):\n    \"\"\"\n    Subtracts the second fraction from the first.\n    Parameters:\n    frac1 (Fraction): The first fraction.\n    frac2 (Fraction): The second fraction.\n    Returns:\n    Fraction: The result of the subtraction.\n    \"\"\"\n    return frac1 - frac2",
            "def multiply_fractions(frac1, frac2):\n    \"\"\"\n    Multiplies two fractions.\n    Parameters:\n    frac1 (Fraction): The first fraction.\n    frac2 (Fraction): The second fraction.\n    Returns:\n    Fraction: The product of the two fractions.\n    \"\"\"\n    return frac1 * frac2",
            "def divide_fractions(frac1, frac2):\n    \"\"\"\n    Divides the first fraction by the second.\n    Parameters:\n    frac1 (Fraction): The numerator fraction.\n    frac2 (Fraction): The denominator fraction (must not be zero).\n    Returns:\n    Fraction: The quotient of the fractions.\n    \"\"\"\n    return frac1 / frac2"
        ],
        [
            "def simplify_rational_expression(expr):\n    \"\"\"\n    Simplifies a given rational expression.\n    Parameters:\n        expr (sympy expression): The rational expression to simplify.\n    Returns:\n        sympy expression: The simplified form of the input expression.\n    Example:\n        >>> x = symbols('x')\n        >>> expr = (x**2 - 1) / (x - 1)\n        >>> simplify_rational_expression(expr)\n        x + 1\n    \"\"\"\n    return simplify(expr)",
            "def simplify_rational_expression(expr):\n    \"\"\"\n    Simplifies a rational algebraic expression.\n    \n    Parameters:\n    - expr (str): The rational expression as a string.\n    \n    Returns:\n    - str: The simplified algebraic expression.\n    \n    Example:\n    >>> simplify_rational_expression('x/(x+1) + x/(x-1)')\n    '2*x**2/(x**2 - 1)'\n    \"\"\"\n    x = symbols('x')\n    expression = simplify(expr)\n    return str(expression)"
        ],
        [
            "def simplify_rational_function(numerator, denominator):\n    \"\"\"\n    Simplify a rational function and detect its vertical asymptotes, horizontal asymptotes, holes, and reduced form.\n    \n    Parameters:\n        numerator (str): A string representation of the polynomial in the numerator.\n        denominator (str): A string representation of the polynomial in the denominator.\n    Returns:\n        dict: A dictionary containing:\n            - 'simplified': Factored and simplified form of the rational function.\n            - 'vertical_asymptotes': List of x values where vertical asymptotes occur.\n            - 'holes': List of x values where holes occur.\n            - 'horizontal_asymptote': The y-value of the horizontal asymptote, if it exists.\n            - 'slant_asymptote': Equation of the slant asymptote, if it exists.\n    Examples:\n        >>> simplify_rational_function(\"x**2-1\", \"x-1\")\n        {\n            'simplified': 'x + 1',\n            'vertical_asymptotes': [],\n            'holes': [(1, 2)],\n            'horizontal_asymptote': 0,\n            'slant_asymptote': None\n        }\n    \"\"\"\n    x = symbols('x')\n    num = simplify(numerator)\n    den = simplify(denominator)\n    # Factoring the numerator and denominator\n    num_fact = factor(num)\n    den_fact = factor(den)\n    # Get poles and zeros to detect vertical asymptotes and holes\n    num_poly = Poly(num, x)\n    den_poly = Poly(den, x)\n    \n    vertical_asymptotes = []\n    holes = []\n    \n    for root in sorted(den_poly.all_roots()):\n        root_multiplicity = den_poly.count_root(root)\n        if num_poly(root) == 0:\n            num_root_mult = num_poly.count_root(root)\n            if num_root_mult < root_multiplicity:\n                holes.append((root, simplify(num_fact / (den_fact / ((x - root)**num_root_mult)))))\n            # More occurrences in denominator, usual vertical asymptote\n            elif num_root_mult >= root_multiplicity:\n                vertical_asymptotes.append(root)\n        else:\n            vertical_asymptotes.append(root)\n    # Simplify the function if possible by cancelling out common factors\n    cancel_common = simplify(num_fact / den_fact)\n    # Analyze horizontal and slant asymptotes\n    deg_num = degree(num_fact)\n    deg_den = degree(den_fact)\n    horizontal_asymptote = slant_asymptote = None\n    if deg_num < deg_den:\n        horizontal_asymptote = 0\n    elif deg_num == deg_den:\n        horizontal_asymptote = num_fact.lead_coeff() / den_fact.lead_coeff()\n    else:  # Slant asymptote condition\n        quotient, remainder = div(num_fact, den_fact)\n        if remainder != 0:\n            slant_asymptote = quotient\n    results = {\n        'simplified': str(cancel_common),\n        'vertical_asymptotes': list(map(str, vertical_asymptotes)),\n        'holes': [(str(h[0]), str(h[1])) for h in holes],\n        'horizontal_asymptote': str(horizontal_asymptote) if horizontal_asymptote else 'None',\n        'slant_asymptote': str(slant_asymptote) if slant_asymptote else 'None'\n    }\n    return results",
            "def identify_asymptotes(numerator, denominator):\n    \"\"\"\n    Identifies vertical and horizontal asymptotes for a given rational function.\n    \n    Parameters:\n        numerator (str): The polynomial expression in the numerator as a string.\n        denominator (str): The polynomial expression in the denominator as a string.\n    \n    Returns:\n        dict: A dictionary containing lists of vertical and horizontal asymptotes.\n        \n    Example:\n        >>> identify_asymptotes(\"x**2 - 4\", \"x - 2\")\n        {'vertical': [2], 'horizontal': [x]}\n    \"\"\"\n    x = symbols('x')\n    simplified_expr, _ = simplify_rational_function(numerator, denominator)\n    vertical_asymptotes = solve(denominator, x)\n    horizontal_asymptotes = limit(simplified_expr, x, oo)\n    \n    return {'vertical': vertical_asymptotes, 'horizontal': horizontal_asymptotes}",
            "def find_asymptotes(numerator, denominator):\n    \"\"\"\n    Find the vertical, horizontal, and slant asymptotes of a rational function.\n    \n    Parameters:\n    numerator (str): A string representation of the polynomial in the numerator.\n    denominator (str): A string representation of the polynomial in the denominator.\n    \n    Returns:\n    dict: A dictionary containing the vertical, horizontal, and slant asymptotes.\n    \n    Examples:\n    >>> find_asymptotes('x**2 - 1', 'x**2 - 2*x + 1')\n    {'vertical': [1], 'horizontal': 1, 'slant': None}\n    \"\"\"\n    x = symbols('x')\n    numerator_expr = sympify(numerator)\n    denominator_expr = sympify(denominator)\n    \n    # Vertical Asymptotes (denominator equals zero)\n    vertical_asymptotes = solve(denominator_expr, x)\n    \n    # Horizontal Asymptotes\n    num_degree = numerator_expr.as_poly().degree()\n    den_degree = denominator_expr.as_poly().degree()\n    horizontal_asymptote = None\n    if num_degree < den_degree:\n        horizontal_asymptote = 0\n    elif num_degree == den_degree:\n        horizontal_asymptote = limit(numerator_expr/denominator_expr, x, oo)\n    \n    # Slant Asymptotes\n    slant_asymptote = None\n    if num_degree == den_degree + 1:\n        slant_asymptote = limit((numerator_expr - horizontal_asymptote * denominator_expr) / x, x, oo)\n    \n    return {\n        'vertical': vertical_asymptotes,\n        'horizontal': horizontal_asymptote,\n        'slant': slant_asymptote\n    }"
        ],
        [
            "def find_rational_function_domain(expression):\n    \"\"\"\n    Finds the domain of the given rational function, excluding values that make the denominator zero.\n    \n    Parameters:\n        expression (str): A string representing a rational function in terms of x, e.g. '1/(x^2 - 4)'.\n    \n    Returns:\n        list of tuples: A list of intervals (in tuple form) where the rational function is defined.\n    \n    Examples:\n        >>> find_rational_function_domain('1/(x**2 - 4)')\n        [(-, -2), (-2, 2), (2, )]\n        >>> find_rational_function_domain('x/(x-3)')\n        [(-, 3), (3, )]\n    \"\"\"\n    from sympy import symbols, S, solve\n    x = symbols('x')\n    # Parse the input expression\n    expr = S(expression)\n    # Find denominator and obtain its factors\n    denominator = expr.as_numer_denom()[1]\n    # Solve for zeros of the denominator\n    zero_points = solve(denominator, x)\n    zero_points.sort()\n    \n    # Formulate the domain intervals\n    intervals = []\n    # Add the intervals based on calculated zeros\n    if zero_points:\n        lower_bound = -float('inf')\n        for point in zero_points:\n            intervals.append((lower_bound, point))\n            lower_bound = point\n        intervals.append((lower_bound, float('inf')))\n    else:\n        intervals = [(-float('inf'), float('inf'))] # The function is defined everywhere if no zero points\n    \n    return intervals",
            "def find_domain_of_rational_function(expression):\n    \"\"\"\n    Calculates the domain of a rational function, excluding values that make the denominator zero.\n    Parameters:\n    - expression (str): The rational function expressed as a string, e.g., 'x/(x**2 - 1)'.\n    Returns:\n    - sympy.sets.sets.Set: A set representation (interval notation) of the domain where the function is defined.\n    Examples:\n    >>> find_domain_of_rational_function('x/(x**2 - 1)')\n    (-, -1)  (-1, 1)  (1, )\n    >>> find_domain_of_rational_function('1/(x*(x-3))')\n    (-, 0)  (0, 3)  (3, )\n    \"\"\"\n    x = sp.symbols('x')\n    # Parse the input expression\n    expr = sp.sympify(expression)\n    # Find the denominator part of the expression\n    denom = expr.as_numer_denom()[1]\n    # Solve when the denominator is zero\n    critical_points = sp.solve(denom, x)\n    # Create the domain set excluding critical points\n    domain = sp.S.Reals\n    for point in critical_points:\n        domain = domain - sp.FiniteSet(point)\n    return domain",
            "def find_rational_function_domain(expression):\n    \"\"\"\n    Calculates the domain of a rational function and returns it in interval notation.\n    Parameters:\n    expression (sympy.Expr): A rational expression involving a numerator and denominator.\n    Returns:\n    sympy.Set: The domain of the function represented in interval notation, excluding values that make the denominator zero.\n    Examples:\n    >>> from sympy import symbols, Rational\n    >>> x = symbols('x')\n    >>> expr = 1 / (x**2 - 4)\n    >>> find_rational_function_domain(expr)\n    Union(Interval.open(-oo, -2), Interval.open(-2, 2), Interval.open(2, oo))\n    \"\"\"\n    x = symbols('x')  # Assuming 'x' is the variable used, this can be parameterized\n    denominator = expression.as_numer_denom()[1]  # Extracting the denominator\n    zeros = solveset(denominator, x, domain=S.Reals)  # Find where denominator is zero\n    domain = S.Reals - zeros  # The domain is the real numbers excluding zeros of the denominator\n    return domain"
        ],
        [
            "def unit_digit_from_division(numerator, denominator):\n    \"\"\"\n    Determine the units digit of the result of a division.\n    \n    Parameters:\n    - numerator (int): The numerator of the division.\n    - denominator (int): The denominator of the division.\n    \n    Returns:\n    - int: The units digit of the quotient.\n    \n    Example:\n    >>> unit_digit_from_division(123, 5)\n    6\n    \"\"\"\n    quotient = numerator // denominator\n    return quotient % 10"
        ],
        [
            "def create_fraction(numerator, denominator=1):\n    \"\"\"\n    Creates a Fraction from numerator and denominator.\n    Parameters:\n    numerator (int): The numerator of the fraction.\n    denominator (int): The denominator of the fraction, defaults to 1.\n    Returns:\n    Fraction: A fraction object created from the numerator and denominator.\n    \"\"\"\n    return fractions.Fraction(numerator, denominator)"
        ],
        [
            "def manipulate_algebraic_expression(expression, operation):\n    \"\"\"\n    Manipulates and simplifies an algebraic expression based on the specified operation.\n    Parameters:\n    expression (str): A string representing the math expression to manipulate.\n    operation (str): An operation to perform on the expression, such as 'simplify', 'square', or 'reciprocal'.\n    Returns:\n    sympy.Expr: The resulting expression after manipulation.\n    Examples:\n    >>> manipulate_algebraic_expression('x/(x**2 - 1)', 'reciprocal')\n    (x**2 - 1)/x\n    >>> manipulate_algebraic_expression('x + x^2', 'simplify')\n    x**2 + x\n    >>> manipulate_algebraic_expression('x + 2*x', 'simplify')\n    3*x\n    \"\"\"\n    expr = sympify(expression.replace('^', '**'))  # Convert to a sympy expression, handling power operator\n    if operation == 'simplify':\n        return simplify(expr)\n    elif operation == 'square':\n        return simplify(expr**2)\n    elif operation == 'reciprocal':\n        return simplify(1/expr)\n    else:\n        raise ValueError(f\"Unsupported operation {operation}\")\n    return expr"
        ],
        [
            "def combine_rational_expressions(expr1, expr2, operation='add'):\n    \"\"\"\n    Combines two rational expressions using specified operation (addition or subtraction).\n    Parameters:\n        expr1 (sympy expression): First rational expression.\n        expr2 (sympy expression): Second rational expression.\n        operation (str): Operation type, 'add' or 'subtract'. Default is 'add'.\n    Returns:\n        sympy expression: Result of combining the expressions.\n    Example:\n        >>> x = symbols('x')\n        >>> expr1 = (x / (x + 1))\n        >>> expr2 = (1 / (x - 1))\n        >>> combine_rational_expressions(expr1, expr2, 'add')\n        (2*x**2 - 2*x + 1) / (x**2 - 1)\n    \"\"\"\n    if operation == 'add':\n        return together(expr1 + expr2)\n    elif operation == 'subtract':\n        return together(expr1 - expr2)\n    else:\n        raise ValueError(\"Operation must be 'add' or 'subtract'\")"
        ],
        [
            "def are_equivalent_fractions(frac1, frac2):\n    \"\"\"\n    Checks if two fractions are equivalent.\n    Parameters:\n    frac1 (tuple): A tuple representing the first fraction (numerator, denominator).\n    frac2 (tuple): A tuple representing the second fraction (numerator, denominator).\n    Returns:\n    bool: True if fractions are equivalent, otherwise False.\n    Examples:\n    >>> are_equivalent_fractions((1, 2), (2, 4))\n    True\n    \"\"\"\n    # Simplify both fractions\n    simplified1 = simplify_fraction(frac1)\n    simplified2 = simplify_fraction(frac2)\n    return simplified1 == simplified2"
        ],
        [
            "def solve_rational_equations(expr, symbol):\n    \"\"\"\n    Solves rational equations for the specified variable.\n    Parameters:\n        expr (symply expression): The equation to solve.\n        symbol (sympy symbol): The variable to solve for.\n    Returns:\n        list: Solutions of the equation.\n    Example:\n        >>> x = symbols('x')\n        >>> expr = x**2 - x - 6\n        >>> solve_rational_equations(expr, x)\n        [2, -3]\n    \"\"\"\n    return solve(expr, symbol)"
        ],
        [
            "def decompose_into_partial_fractions(expr):\n    \"\"\"\n    Decomposes a rational function into partial fractions.\n    Parameters:\n        expr (sympy expression): The rational function to decompose.\n    Returns:\n        sympy expression: The expression decomposed into partial fractions.\n    Example:\n        >>> x = symbols('x')\n        >>> expr = (x**2 + 3*x + 5)/(x**3 + x**2 - x - 1)\n        >>> decompose_into_partial_fractions(expr)\n        (x - 1)/(x**2 + 2*x + 1) + 2/(x + 1)\n    \"\"\"\n    return apart(expr)"
        ],
        [
            "def polynomial_long_division(numerator, denominator):\n    \"\"\"\n    Performs polynomial long division and identifies oblique/slant asymptotes if existent.\n    \n    Parameters:\n        numerator (str): The polynomial expression in the numerator as a string.\n        denominator (str): The polynomial expression in the denominator as a string.\n    \n    Returns:\n        tuple: A tuple (result, remainder) from the division, where result may represent an oblique asymptote.\n    \n    Example:\n        >>> polynomial_long_division(\"x**2 - 1\", \"x - 1\")\n        (x + 1, 0)\n    \"\"\"\n    x = symbols('x')\n    numer_expr = simplify(numerator)\n    denom_expr = simplify(denominator)\n    \n    quotient, remainder = div(numer_expr, denom_expr, x)\n    \n    return quotient, remainder"
        ],
        [
            "class RationalEquationSolver:\n    \"\"\"\n    A tool for solving equations involving rational functions, including handling \n    of partial fraction decomposition and solving linear, quadratic equations,\n    and systems of equations.\n    \"\"\"\n    \n    @staticmethod\n    def solve_rational_equation(expr, target_var):\n        \"\"\"\n        Solves a rational equation for a specified variable.\n        Parameters:\n        - expr (sympy.Expr): The equation to solve.\n        - target_var (sympy.Symbol): The variable to solve for.\n        Returns:\n        - list: Solutions to the equation.\n        Example:\n        >>> x = sympy.symbols('x')\n        >>> RationalEquationSolver.solve_rational_equation(x/(x + 1) - 1/2, x)\n        [1/3]\n        \"\"\"\n        return solve(expr, target_var)\n    \n    @staticmethod\n    def solve_system_of_rational_equations(equations, variables):\n        \"\"\"\n        Solves a system of rational equations.\n        Parameters:\n        - equations (list of sympy.Expr): A list of equations to solve.\n        - variables (list of sympy.Symbol): The variables to solve for in the system.\n        Returns:\n        - dict: A dictionary of solutions for each variable.\n        Example:\n        >>> x, y = sympy.symbols('x y')\n        >>> eq1 = x + y - 1\n        >>> eq2 = x - y - 1\n        >>> RationalEquationSolver.solve_system_of_rational_equations([eq1, eq2], [x, y])\n        {x: 0, y: 1}\n        \"\"\"\n        return solve(equations, variables)"
        ],
        [
            "def arithmetic_operations_on_fractions(frac1, frac2, operation='add'):\n    \"\"\"\n    Perform basic arithmetic operations on two fractions.\n    \n    Parameters:\n    - frac1 (Fraction): The first fraction.\n    - frac2 (Fraction): The second fraction.\n    - operation (str): Type of operation ('add', 'subtract', 'multiply', 'divide').\n    \n    Returns:\n    - Fraction: The result of the arithmetic operation.\n    \n    Example:\n    >>> f1 = Fraction(1, 2)\n    >>> f2 = Fraction(3, 4)\n    >>> arithmetic_operations_on_fractions(f1, f2, 'add')\n    Fraction(5, 4)\n    \"\"\"\n    if operation == 'add':\n        return frac1 + frac2\n    elif operation == 'subtract':\n        return frac1 - frac2\n    elif operation == 'multiply':\n        return frac1 * frac2\n    elif operation == 'divide':\n        return frac1 / frac2"
        ],
        [
            "def simplify_fraction(frac):\n    \"\"\"\n    Simplifies a fraction to its lowest terms.\n    Parameters:\n    frac (Fraction): The fraction to be simplified.\n    Returns:\n    Fraction: The simplified fraction.\n    \"\"\"\n    return frac.limit_denominator()"
        ]
    ],
    "Polynomial Factoring": [
        [
            "def complete_polynomial_factoring(expression):\n    \"\"\"\n    Completely factorize a polynomial using algebraic identities and simplification.\n    Parameters:\n    - expression (str): A string representing a polynomial (e.g., \"x^2 - 16\").\n    Returns:\n    - str: The completely factored form of the polynomial as a string.\n    Examples:\n    >>> complete_polynomial_factoring(\"x^2 - 16\")\n    '(x - 4)*(x + 4)'\n    \n    >>> complete_polynomial_factoring(\"x^2 - 2*x - 8\")\n    '(x - 4)*(x + 2)'\n    \"\"\"\n    import sympy as sp\n    # Convert string to a symbolic expression\n    expr = sp.sympify(expression.replace('^', '**'))\n    # Fully factor the polynomial using factor method\n    fully_factored_expr = sp.factor(expr)\n    return str(fully_factored_expr)",
            "def full_polynomial_factorization(expr):\n    \"\"\"\n    Carry out full factorization of a polynomial, utilizing various algebraic techniques.\n    Parameters:\n    - expr (str): The polynomial expression as a string.\n    Returns:\n    - factored_expr (str): The fully factored form of the polynomial.\n    \n    Examples:\n    >>> full_polynomial_factorization('x**2 - 4')\n    '(x - 2)*(x + 2)'\n    >>> full_polynomial_factorization('x**2 + 2*x + 1')\n    '(x + 1)**2'\n    \"\"\"\n    poly_expr = sympify(expr)\n    return str(factor(poly_expr))"
        ],
        [
            "def extract_common_factors(expression):\n    \"\"\"\n    Extracts common factors from a polynomial expression and returns the factored expression.\n    Parameters:\n        expression (str): The polynomial expression as a string.\n    Returns:\n        sympy.Expr: The expression with common factors extracted.\n    Examples:\n        >>> extract_common_factors('x^2 - 2*x^2 + x^3')\n        x^2*(x - 2 + 1)\n        >>> extract_common_factors('6*x*y + 9*x')\n        3*x*(2*y + 3)\n    \"\"\"\n    expr = sp.sympify(expression.replace('^', '**'))\n    return sp.factor(expr)",
            "def simplify_and_extract_common_factors(expression, variable='x'):\n    \"\"\"\n    Simplifies a polynomial expression by extracting common factors and applying the distributive property.\n    \n    Parameters:\n    - expression (str or sp.Expr): The expression to simplify. Can be a string or a sympy expression.\n    - variable (str): The main variable in the polynomial, default is 'x'.\n    \n    Returns:\n    - simplified_expr (sp.Expr): The simplified form of the input expression.\n    \n    Examples:\n    - simplify_and_extract_common_factors(\"x^2 - 2x + x\") returns x*(x - 1 + 1) = x*x\n    - simplify_and_extract_common_factors(\"2*x^2 + 4*x\") returns 2*x*(x + 2)\n    - simplify_and_extract_common_factors(\"x^3 + 3*x^2 + 3*x + 1\") simplifies to (x + 1)**3.\n    \"\"\"\n    x = sp.symbols(variable)\n    expression = sp.sympify(expression)\n    gcd_expr = sp.gcd(expression)\n    simplified_expr = gcd_expr*sp.factor(expression/gcd_expr)\n    return simplified_expr"
        ],
        [
            "def factor_gcf_polynomial(expression):\n    \"\"\"\n    Factor out the Greatest Common Factor (GCF) from a polynomial expression.\n    Parameters:\n    - expression (str): A string representing a polynomial (e.g., \"x^2 - 4*x + 4\").\n    Returns:\n    - str: The factored form of the polynomial as a string.\n    Examples:\n    >>> factor_gcf_polynomial(\"x^2 - 4*x + 4\")\n    'x*(x - 4) + 4'\n    \n    >>> factor_gcf_polynomial(\"6*x^3 - 9*x^2 + 3*x\")\n    '3*x*(2*x**2 - 3*x + 1)'\n    \"\"\"\n    import sympy as sp\n    # Convert string to a symbolic expression\n    expr = sp.sympify(expression.replace('^', '**'))\n    # Factor the polynomial\n    factored_expr = sp.factor(expr)\n    return str(factored_expr)",
            "def factor_out_gcf(expr):\n    \"\"\"\n    Factor out the Greatest Common Factor (GCF) from a polynomial expression.\n    \n    Parameters:\n    - expr (str): The polynomial expression as a string.\n    Returns:\n    - factored_expr (str): The polynomial expression factored by the GCF.\n    \n    Examples:\n    >>> factor_out_gcf('3*x^2 + 6*x')\n    '3*(x**2 + 2*x)'\n    >>> factor_out_gcf('2*x^3 + 4*x^2 + 6*x')\n    '2*x*(x**2 + 2*x + 3)'\n    \"\"\"\n    x = symbols('x')\n    poly_expr = Poly(expr, x)\n    coeffs = poly_expr.all_coeffs()\n    gcf = gcd(coeffs)\n    \n    factored_poly = poly_expr.as_expr() / gcf\n    factored_expr = f\"{int(gcf)}*({factored_poly})\"\n    return factored_expr",
            "def polynomial_gcf_finder(expression):\n    \"\"\"\n    Identifies and returns the greatest common factor of a polynomial expression.\n    Parameters:\n    - expression (str): A string representing the polynomial expression, e.g., \"6*x**2 + 8*x\"\n    Returns:\n    - sympy expression: The greatest common factor of the polynomial.\n    Examples:\n    - polynomial_gcf_finder(\"6*x**2 + 8*x\") would return 2*x (since 2*x is the common factor in 6*x**2 and 8*x).\n    \"\"\"\n    x = symbols('x')\n    expr = Poly(expression, x)\n    coeffs = expr.coeffs()\n    gcf_coeff = gcd_list(coeffs)\n    monomials = [term/gcf_coeff for term in expr.monoms()]\n    gcf = gcf_coeff * prod(x**deg for deg, in monomials)\n    return gcf",
            "def factor_polynomial(expression):\n    \"\"\"\n    Factors out the greatest common factor from a polynomial expression.\n    Parameters:\n    - expression (str): A string representing the polynomial expression, e.g., \"6*x**2 + 8*x\"\n    Returns:\n    - sympy expression: The factored form of the polynomial expression.\n    Examples:\n    - factor_polynomial(\"6*x**2 + 8*x\") would return \"2*x*(3*x + 4)\", factoring out the GCF.\n    \"\"\"\n    x = symbols('x')\n    gcf = polynomial_gcf_finder(expression)\n    original_expr = Poly(expression, x)\n    factored_expr = simplify(original_expr.as_expr() / gcf) * gcf\n    return factored_expr"
        ],
        [
            "def special_factorization(expression, method=\"difference_of_squares\"):\n    \"\"\"\n    Perform special factorizations like difference of squares or sum/difference of cubes on a polynomial.\n    Parameters:\n    - expression (str): The polynomial expression to factor.\n    - method (str): Type of factorization method such as 'difference_of_squares', 'sum_of_cubes', 'difference_of_cubes'.\n    Returns:\n    - sp.Expr: The factored form of the polynomial depending on the method.\n    Example:\n    >>> special_factorization(\"x**2 - 16\", \"difference_of_squares\")\n    (x - 4)*(x + 4)\n    \"\"\"\n    var = sp.symbols('x')  # Default variable is x for simplicity in general approach\n    polynomial = sp.sympify(expression)\n    if method == \"difference_of_squares\":\n        return sp.factor(polynomial)\n    elif method == \"sum_of_cubes\":\n        return sp.factor(polynomial)\n    elif method == \"difference_of_cubes\":\n        return sp.factor(polynomial)\n    else:\n        raise ValueError(\"Invalid method specified\")"
        ],
        [
            "def factor_polynomial(expression, variable):\n    \"\"\"\n    Factorize a polynomial expression in terms of a given variable.\n    Parameters:\n        expression (str): The polynomial expression as a string.\n        variable (str): The variable in terms of which the polynomial is expressed.\n    Returns:\n        sympy.Expr: The factorized form of the polynomial.\n    Examples:\n        >>> factor_polynomial('x^2 - y^2', 'x')\n        (x - y)*(x + y)\n        >>> factor_polynomial('x^2 + 2*x + 1', 'x')\n        (x + 1)**2\n    \"\"\"\n    var = sp.symbols(variable)\n    expr = sp.sympify(expression.replace('^', '**'))\n    return sp.factor(expr)",
            "def advanced_polynomial_factoring(expression, variable):\n    \"\"\"\n    Factorizes complex polynomial expressions using advanced methods like difference of squares, sum and difference of cubes.\n    Parameters:\n        expression (str): The polynomial expression as a string.\n        variable (str): The variable for advanced factorization methods.\n    Returns:\n        sympy.Expr: The factorized expression.\n    Examples:\n        >>> advanced_polynomial_factoring('x^3 - 8', 'x')\n        (x - 2)*(x^2 + 2*x + 4)\n        >>> advanced_polynomial_factoring('x^2 - 1', 'x')\n        (x - 1)*(x + 1)\n    \"\"\"\n    var = sp.symbols(variable)\n    expr = sp.sympify(expression.replace('^', '**'))\n    return sp.factor(expr)",
            "def factor_polynomial(expression, variable='x'):\n    \"\"\"\n    Factor a polynomial expression using symbolic computation.\n    \n    Parameters:\n    - expression (str or sp.Expr): The polynomial expression to factor. Can be a string or a sympy expression.\n    - variable (str): The main variable in the polynomial, default is 'x'.\n    \n    Returns:\n    - factored_expr (sp.Expr): The factored form of the input polynomial expression.\n    \n    Examples:\n    - factor_polynomial(\"x^2 - 4\") returns (x - 2)*(x + 2) using the difference of squares.\n    - factor_polynomial(\"x^3 - 27\") returns (x - 3)*(x**2 + 3*x + 9) using sum of cubes factorization.\n    - factor_polynomial(\"x^2 + 5x + 6\") returns (x + 2)*(x + 3), a simple quadratic factorization.\n    \"\"\"\n    x = sp.symbols(variable)\n    expression = sp.sympify(expression)\n    factored_expr = sp.factor(expression)\n    return factored_expr",
            "def factor_polynomial(expression, variable):\n    \"\"\"\n    Factor a polynomial expression in terms of a given variable.\n    Parameters:\n    - expression (str): The polynomial expression to factor as a string.\n    - variable (str): The variable in terms of which to factor the polynomial.\n    Returns:\n    - sp.Expr: The factored form of the polynomial.\n    Example:\n    >>> factor_polynomial(\"x**2 - 4\", \"x\")\n    (x - 2)*(x + 2)\n    \"\"\"\n    var = sp.symbols(variable)\n    polynomial = sp.sympify(expression)\n    factored_expr = sp.factor(polynomial, var)\n    return factored_expr"
        ]
    ],
    "Exponents and Logarithms": [
        [
            "def logarithm(value, base=np.e):\n    \"\"\"\n    Computes the logarithm of a number with an optional base, defaulting to natural logarithm.\n    \n    Parameters:\n    - value (float): The value to compute the logarithm for. Must be positive.\n    - base (float, optional): The base of the logarithm. Default is e (natural logarithm).\n    \n    Returns:\n    - float: The logarithm of `value` to the specified ` GridSearchCV`  Exception: `ValueError` if `value` <= 0 or `base` <= 0.\n    Examples:\n    >>> logarithm(10)\n    2.302585092994046\n    >>> logarithm(100, 10)\n    2.0\n    \"\"\"\n    if value <= 0:\n        raise ValueError(\"value must be greater than 0\")\n    if base <= 0:\n        raise ValueError(\"base must be greater than 0\")\n    return np.log(value) / np.log(base)",
            "def calculate_log(base, value):\n    \"\"\"\n    Compute the logarithm of a given value with a specified base.\n    \n    Parameters:\n        base (float): The base of the logarithm.\n        value (float): The value for which the logarithm is computed.\n    \n    Returns:\n        float: The logarithm of the value to the given base.\n    \n    Example:\n        >>> calculate_log(10, 100)\n        2.0\n    \"\"\"\n    if base <= 0 or value <= 0:\n        raise ValueError(\"Base and value must be positive numbers.\")\n    return math.log(value, base)",
            "def compute_log(value, base=np.e):\n    \"\"\"\n    Compute the logarithm of a given value with an optional base, default being the natural log.\n    \n    Parameters:\n    value (float or sympy.Symbol): The value to take the logarithm of.\n    base (float, optional): The base of the logarithm. Default is np.e for natural log.\n    \n    Returns:\n    float or sympy expression: The logarithm of the value.\n    \n    Examples:\n    >>> compute_log(8, 2)\n    3.0\n    >>> x = sp.symbols('x')\n    >>> compute_log(x)\n    log(x)\n    \"\"\"\n    return np.log(value) / np.log(base) if base != np.e else np.log(value)",
            "def logarithm(value, base=np.e):\n    \"\"\"\n    Compute the logarithm of a given value with an optional base. Default base is 'e' (natural logarithm).\n    \n    Parameters:\n        value (float): The value to calculate the logarithm for.\n        base (float, optional): The base of the logarithm.\n    \n    Returns:\n        float: The logarithm of the given value on the specified base.\n    \n    Examples:\n        >>> logarithm(10, 10)\n        1.0\n        >>> logarithm(8, 2)\n        3.0\n    \"\"\"\n    if base == np.e:\n        return np.log(value)\n    else:\n        return np.log(value) / np.log(base)"
        ],
        [
            "def simplify_exponent_expression(expression_str):\n    \"\"\"\n    Simplifies and computes expressions involving exponents using sympy library.\n    \n    Parameters:\n    expression_str (str): A string representation of the mathematical expression to be simplified.\n    \n    Returns:\n    str: A string representation of the simplified mathematical expression.\n    \n    Example:\n    >>> simplify_exponent_expression(\"2**x * 2**(2*x)\")\n    '2**(3*x)'\n    \"\"\"\n    expression = sp.sympify(expression_str)\n    simplified_expression = sp.simplify(expression)\n    return str(simplified_expression)",
            "def expression_simplifier_tool(expression):\n    \"\"\"\n    Simplifies expressions involving powers with known rules of exponents such as product of powers, \n    power of powers, quotient of powers, and handling of negative exponents.\n    Parameters:\n    - expression: str, a string representing the mathematical expression involving exponents.\n    \n    Returns:\n    - simplified_expression: str, a string of the simplified version of the initial expression.\n    \n    Examples:\n    >>> expression_simplifier_tool(\"x^3 * x^2\")\n    'x^5'\n    >>> expression_simplifier_tool(\"(x^2)^3\")\n    'x^6'\n    >>> expression_simplifier_tool(\"x^(-1)\")\n    '1/x'\n    \"\"\"\n    import sympy as sp\n    expr_sympy = sp.sympify(expression)\n    simplified_expr = sp.simplify(expr_sympy)\n    \n    return str(simplified_expr)",
            "def simplify_exponential_expression(expression):\n    \"\"\"\n    Simplifies an expression involving exponents by applying exponent rules and simplification.\n    Parameters:\n    - expression (str): A string representing the mathematical expression to simplify.\n    Returns:\n    - str: A simplified version of the input expression.\n    \n    Examples:\n    >>> simplify_exponential_expression(\"x**2 * x**3\")\n    'x**5'\n    >>> simplify_exponential_expression(\"(x**2)**3\")\n    'x**6'\n    >>> simplify_exponential_expression(\"x**2 / x**3\")\n    'x**(-1)'\n    \"\"\"\n    expr = sp.sympify(expression)\n    simplified_expr = sp.simplify(expr)\n    return str(simplified_expr)",
            "def simplify_exponential_expr(expr):\n    \"\"\"\n    Simplifies expressions involving exponents using sympy's simplification capabilities.\n    \n    Parameters:\n    expr (str or sympy expression): The exponential expression to simplify.\n    \n    Returns:\n    sympy expression: A simplified version of the input expression.\n    \n    Examples:\n    >>> simplify_exponential_expr('x**2 * x**3')\n    x**5\n    >>> simplify_exponential_expr('x**2 / x**3')\n    1/x\n    \"\"\"\n    expr = sp.sympify(expr)\n    return sp.simplify(expr)"
        ],
        [
            "def solve_exponential_equation(eq_str, variable_str):\n    \"\"\"\n    Solves an exponential equation by isolating the variable on one side.\n    \n    Parameters:\n    eq_str (str): A string representation of the equation to solve.\n    variable_str (str): The variable to isolate, given as a string.\n    \n    Returns:\n    list: A list of solutions to the exponential equation.\n    \n    Example:\n    >>> solve_exponential_equation(\"2**x = 8\", 'x')\n    [3]\n    \"\"\"\n    variable = sp.symbols(variable_str)\n    equation = sp.Eq(sp.sympify(eq_str.split('=')[0]), sp.sympify(eq_str.split('=')[1]))\n    solutions = sp.solve(equation, variable)\n    return [sol.evalf() for sol in solutions]  # Return numerical solutions if possible",
            "def solve_exponential_equation(equation):\n    \"\"\"\n    Solves exponential equations where the base and the exponent may contain variables.\n    Parameters:\n    - equation (str): The exponential equation to solve, expressed in terms of x.\n    Returns:\n    - list: Solutions to the exponential equation.\n    Examples:\n    >>> solve_exponential_equation(\"2**x = 8\")\n    [3]\n    >>> solve_exponential_equation(\"e**(2*x) = 7\")\n    [log(7)/2]\n    \"\"\"\n    x = sp.symbols('x')\n    expr = sp.sympify(equation)\n    solutions = sp.solveset(expr, x, domain=sp.S.Reals)\n    return list(solutions)",
            "def solve_exponential_eq(eq, var):\n    \"\"\"\n    Solves equations where the variable appears in an exponent.\n    \n    Parameters:\n    eq (str or sympy expression): The exponential equation to solve.\n    var (sympy.Symbol): The variable to solve for.\n    \n    Returns:\n    list: Solutions to the equation.\n    \n    Examples:\n    >>> x = sp.symbols('x')\n    >>> solve_exponential_eq('2**x - 8', x)\n    [3]\n    >>> solve_exponential_eq('3**(2*x + 1) - 9**x', x)\n    [0]\n    \"\"\"\n    eq = sp.sympify(eq)\n    return sp.solve(eq, var)"
        ],
        [
            "def calculate_power(base, exponent):\n    \"\"\"\n    Returns the result of the base raised to the power of the exponent.\n    \n    Parameters:\n    - base (float): The base of the exponential expression.\n    - exponent (float): The exponent to which the base is raised.\n    \n    Returns:\n    - float: Result of base ** exponent.\n    \n    Examples:\n    >>> calculate_power(2, 3)\n    8\n    >>> calculate_power(4, -0.5)\n    0.5\n    \"\"\"\n    return base ** exponent",
            "def exponential_calculator(base, exponent):\n    \"\"\"\n    Calculate the exponential of a base raised to a given exponent using numpy for high precision.\n    \n    Parameters:\n    - base (float or int): The base of the exponentiation.\n    - exponent (float or int): The exponent to which the base is raised.\n    \n    Returns:\n    - float: Result of base raised to the power of exponent.\n    \n    Examples:\n    >>> exponential_calculator(2, 3)\n    8\n    >>> exponential_calculator(4, -0.5)\n    0.5\n    \"\"\"\n    return np.power(base, exponent)",
            "def eval_power(base, exponent):\n    \"\"\"\n    Evaluates a number raised to a given power. Handles both fractional and negative exponents.\n    Parameters:\n        base (float): The base of the expression.\n        exponent (float): The exponent to which the base is raised.\n    Returns:\n        float: The result of base raised to the power of exponent.\n    Examples:\n        >>> eval_power(2, 3)\n        8\n        >>> eval_power(2, -2)\n        0.25\n        >>> eval_power(16, 0.5)\n        4.0\n    \"\"\"\n    return np.power(base, exponent)",
            "def exponentiate(base, exponent):\n    \"\"\"\n    Calculate the power of a base raised to an exponent.\n    \n    Parameters:\n        base (float): The base of the exponentiation.\n        exponent (float): The exponent of the power.\n    \n    Returns:\n        float: The result of base raised to the power of exponent.\n    \n    Example:\n        >>> exponentiate(2, 3)\n        8\n    \"\"\"\n    return base ** exponent",
            "def compute_power(base, exponent):\n    \"\"\"\n    Calculate the power of a given base raised to an exponent.\n    \n    Parameters:\n    base (float or int or sympy.Symbol): The base value.\n    exponent (float or int or sympy.Symbol): The exponent value.\n    \n    Returns:\n    float or sympy expression: Result of base raised to the power of exponent.\n    \n    Examples:\n    >>> compute_power(2, 3)\n    8\n    >>> x = sp.symbols('x')\n    >>> compute_power(x, 3)\n    x**3\n    \"\"\"\n    return base**exponent",
            "def compute_power(base, exponent):\n    \"\"\"\n    Compute the power of a given base raised to an exponent.\n    \n    Parameters:\n        base (float): The base which is the number to be raised.\n        exponent (float): The power to which the base is raised.\n    \n    Returns:\n        float: The result of the base raised to the exponent.\n    \n    Examples:\n        >>> compute_power(2, 3)\n        8.0\n        >>> compute_power(4, -0.5)\n        0.5\n    \"\"\"\n    return np.power(base, exponent)"
        ],
        [
            "def simplify_exponential_expression(base, exponents):\n    \"\"\"\n    Simplifies an exponential expression where a series of powers with the same base are being either multiplied or divided.\n    The exponents are represented in a list where each exponent corresponds to a power of the base; negative exponents imply division.\n    Parameters:\n        base (float): The common base of all the terms.\n        exponents (list of floats): The exponents in the expression.\n    Returns:\n        float: The simplified result of the exponential expression.\n    Examples:\n        >>> simplify_exponential_expression(2, [3, 2, -1])\n        16.0\n        >>> simplify_exponential_symplify(3, [-4, 2, 1])\n        0.1111111111111111\n    \"\"\"\n    total_exponent = sum(exponents)\n    return eval_power(base, total_exponent)",
            "def simplify_expressions_with_common_bases(values, operators):\n    \"\"\"\n    Simplify expressions involving exponents with the same base using properties of exponents.\n    \n    Parameters:\n        values (list of tuples): List of tuples each containing (base, exponent)\n        operators (list of str): List of operators ('*', '/') in order they apply to the list of values.\n    \n    Returns:\n        float: The simplified result of the expression.\n    \n    Examples:\n        >>> simplify_expressions_with_common_bases([(2, 3), (2, 4)], ['*'])\n        128.0\n        >>> simplify_expressions_with_common_bases([(2, 3), (2, -1)], ['/'])\n        4.0\n    \"\"\"\n    if not operators or len(values) <= 1:\n        return compute_power(*values[0])\n    \n    result = np.power(*values[0])\n    for op, (base, exponent) in zip(operators, values[1:]):\n        if op == '*':\n            result *= np.power(base, exponent)\n        elif op == '/':\n            result /= np.power(base, exponent)\n    \n    return result"
        ],
        [
            "def multiply_powers_same_base(base, exp1, exp2):\n    \"\"\"\n    Multiplies two powers with the same base according to the property a^m * a^n = a^(m+n).\n    Parameters:\n        base (float): The common base of the powers.\n        exp1 (float): The exponent of the first term.\n        exp2 (float): The exponent of the second term.\n    Returns:\n        float: The result of the multiplication of two powers with the same base.\n    Examples:\n        >>> multiply_powers_same_base(2, 3, 4)\n        128\n        >>> multiply_powers_same_base(3, -1, 2)\n        3.0\n    \"\"\"\n    return eval_power(base, exp1 + exp2)",
            "def divide_powers_same_base(base, exp1, exp2):\n    \"\"\"\n    Divides two powers with the same base according to the property a^m / a^n = a^(m-n).\n    Parameters:\n        base (float): The common base of the powers.\n        exp1 (float): The exponent of the numerator.\n        exp2 (float): The exponent of the denominator.\n    Returns:\n        float: The result of the division of two powers with the same base.\n    Examples:\n        >>> divide_powers_same_base(2, 3, 1)\n        4.0\n        >>> divide_powers_same_base(2, 1, -1)\n        4.0\n    \"\"\"\n    return eval_power(base, exp1 - exp2)"
        ],
        [
            "def change_of_base_logarithm(value, original_base, new_base):\n    \"\"\"\n    Applies the change of base formula to compute logarithm of `value` from one base to another.\n    Parameters:\n    - value (float): The number to compute the logarithm for.\n    - original_base (float): The current base of the logarithm.\n    - new_base (float): The desired new base for the logarithm.\n    \n    Returns:\n    - float: Logarithm of `value` using `new_base`.\n    \n    Examples:\n    >>> change_of_base_logarithm(100, 10, 2)\n    6.6449\n    \"\"\"\n    return logarithm(value, new_base) / logarithm(original_base, new_base)",
            "def change_of_base(value, old_base, new_base):\n    \"\"\"\n    Converts a logarithm from one base to another.\n    \n    Parameters:\n        value (float): The value for which the logarithmic change of base is calculated.\n        old_base (float): The original base of the logarithm.\n        new_base (float): The new base to convert to.\n    \n    Returns:\n        float: The value of the logarithm base `new_base` of `value` originally computed in `old_base`.\n    \n    Example:\n        >>> change_of_base(100, 10, 2)\n        6.644\n    \"\"\"\n    if old_base <= 0 or new_base <= 0 or value <= 0:\n        raise ValueError(\"Base and value must be positive numbers.\")\n    return math.log(value, new_base) / math.log(old_base, new_base)",
            "def logarithm_using_change_of_base(value, base, new_base):\n    \"\"\"\n    Compute logarithm of a value with a specified base using a new base via the change of base formula.\n    \n    Parameters:\n        value (float): Value to compute the logarithm for.\n        base (float): The original base of the logarithm.\n        new_base (float): The new base to convert to.\n    \n    Returns:\n        float: The value of the logarithm in the new base.\n    \n    Examples:\n        >>> logarithm_using_change_of_base(100, 10, 2)\n        6.644\n    \"\"\"\n    return logarithm(value, new_base) / logarithm(base, new_base)"
        ],
        [
            "def power_rule(n1, n2, m):\n    \"\"\"\n    Implements the power rule for exponents. It finds the solution for (n1^n2)^m using the formula (n1^n2)^m = n1^(n2*m).\n        \n    Parameters:\n    n1 (int): The base number.\n    n2 (int): The exponent applied to the base number.\n    m (int): The second exponent applied to the result after the base is raised to the power of n2.\n    \n    Returns:\n    float: The end result after applying the power rule on the inputs.\n    \"\"\"\n    import math\n    return math.pow(n1, n2 * m)"
        ],
        [
            "def power_of_a_quotient(a, b, n):\n    \"\"\"\n    Implements the power of a quotient rule. The function applies the rule (a/b)^n = a^n / b^n\n    \n    Parameters:\n    a (int): The numerator of the fraction.\n    b (int): The denominator of the fraction.\n    n (int): The exponent.\n    \n    Returns:\n    float: The result after applying the power of a quotient rule.\n    \"\"\"\n    import math\n    return (math.pow(a, n) / math.pow(b, n))"
        ],
        [
            "def solve_logarithmic_equation(log_expr, target_value):\n    \"\"\"\n    Solve a logarithmic equation where log_expr is set to target_value by converting to exponential form.\n    \n    Parameters:\n        log_expr (tuple): Logarithmic expression in the form (base, exponent_result)\n        target_value (float): The result to solve for which equates to base ** exponent_result.\n    \n    Returns:\n        float: The value of the exponent that satisfies the equation.\n        \n    Examples:\n        >>> solve_logarithmic_equation((10, 100), 2)\n        100.0\n    \"\"\"\n    base, exponent_result = log_expr\n    # Converting log equation to exponential form: base ** x = target_value\n    return np.power(exponent_result, 1 / logarithm(target_value, base))"
        ],
        [
            "def product_of_powers(n, m1, m2):\n    \"\"\"\n    Calculates the product of powers of the same base. It uses the formula a^m * a^n = a^(m+n).\n        \n    Parameters:\n    n (int): The base number.\n    m1 (int): The first exponent.\n    m2 (int): The second exponent.\n    \n    Returns:\n    float: The product of powers of the same base.\n    \"\"\"\n    import math\n    return math.pow(n, m1 + m2)",
            "def quotient_of_powers(n, m1, m2):\n    \"\"\"\n    Computes the quotient of powers of the same base. It applies the formula a^m / a^n = a^(m-n).\n        \n    Parameters:\n    n (int): The base number.\n    m1 (int): The first exponent.\n    m2 (int): The second exponent.\n    \n    Returns:\n    float: The quotient of powers of the same base.\n    \"\"\"\n    import math\n    return math.pow(n, m1 - m2)"
        ],
        [
            "def logarithm(base, x):\n    \"\"\"\n    Calculate the logarithm of a number with a specified base using numpy for high precision.\n    \n    Parameters:\n    - base (float or int): The base of the logarithmic function.\n    - x (float or int): The number whose logarithm is to be computed.\n    \n    Returns:\n    - float: The logarithm of x to the given base.\n    \n    Examples:\n    >>> logarithm(2, 8)\n    3.0\n    >>> logarithm(10, 100)\n    2.0\n    \"\"\"\n    return np.log(x) / np.log(base)"
        ],
        [
            "def power_of_a_power(base, outer_exp, inner_exp):\n    \"\"\"\n    Computes the result of raising a power to another power, i.e., (a^m)^n = a^(m*n).\n    Parameters:\n        base (float): The base of the expression.\n        outer_exp (float): The outer exponent.\n        inner_exp (float): The inner exponent.\n    Returns:\n        float: The result of the expression (a^m)^n.\n    Examples:\n        >>> power_of_a_power(2, 3, 2)\n        64.0\n        >>> power_of_a_power(4, 0.5, 2)\n        4.0\n    \"\"\"\n    return eval_power(base, outer_exp * inner_exp)"
        ],
        [
            "def solve_exponential_equation(base, result):\n    \"\"\"\n    Solve for the exponent given a base and a result using logarithms.\n    \n    Parameters:\n    base (float): Base of the exponential equation.\n    result (float): Result from raising base to the power of the unknown exponent.\n    \n    Returns:\n    float: The exponent x such that base ** x = result.\n    \n    Example:\n    >>> solve_exponential_equation(2, 8)\n    3.0\n    \"\"\"\n    if base <= 0 or result <= 0:\n        raise ValueError(\"Base and result must be positive numbers.\")\n    return math.log(result, base)"
        ],
        [
            "def negative_exponent(n, m):\n    \"\"\"\n    Implements the negative exponent rule. It finds the value for a^(-n) using the formula a^(-n) = 1/(a^n).\n        \n    Parameters:\n    n (int): The base number.\n    m (int): The exponent. The function will convert it to negative.\n    \n    Returns:\n    float: The result after applying the negative exponent rule.\n    \"\"\"\n    import math\n    return 1 / math.pow(n, m)"
        ],
        [
            "def power_operations_tool(base, exponent):\n    \"\"\"\n    Calculates the power of a base raised to an exponent while handling specific edge cases like negative bases \n    and exponents, and zero exponent rule.\n    \n    Parameters:\n    - base: float or int, the base of the exponential expression.\n    - exponent: float or int, the exponent to which the base is raised.\n    \n    Returns:\n    - float or int: result of the base raised to the exponent.\n    \n    Examples:\n    >>> power_operations_tool(5, -2)\n    0.04\n    >>> power_operations_tool(-3, 3)\n    -27\n    >>> power_operations_tool(2, 0)\n    1\n    \"\"\"\n    import numpy as np\n    if base == 0 and exponent <= 0:\n        raise ValueError(\"Base 0 with non-positive exponent is not defined.\")\n    if base < 0 and not exponent.is_integer():\n        raise ValueError(\"Negative base with non-integer exponent is not defined.\")\n    \n    return np.power(base, exponent)"
        ],
        [
            "def simplify_logarithmic_expression(expression):\n    \"\"\"\n    Simplifies a logarithmic expression applying logarithmic rules such as product, quotient, and power rules.\n    \n    Parameters:\n        expression (str): The logarithmic expression in string form to simplify.\n    \n    Returns:\n        float: The simplified result of the logarithmic expression.\n    \n    Example:\n        >>> simplify_logarithmic_expression(\"log(10, 100)*2 - log(10, 10)\")\n        3.0\n    \"\"\"\n    # This can include parsing and applying rules. Here's a basic implementation using eval.\n    return eval(expression, {\"log\": math.log10})"
        ],
        [
            "def simplify_exponents(expression):\n    \"\"\"\n    Simplify expressions involving powers especially when bases are the same.\n    \n    Parameters:\n        expression (str): A string containing the mathematical expression to simplify.\n    \n    Returns:\n        float: The simplified result of the expression.\n    \n    Example:\n        >>> simplify_exponents(\"2**3 * 2**4\")\n        128\n    \"\"\"\n    # For simplicity, use eval here, but in a real scenario, a more secure parser may be used.\n    return eval(expression)"
        ]
    ],
    "Function Transformations": [
        [
            "def find_vertex_of_quadratic(a, b=None, c=None, h=None, k=None):\n    \"\"\"\n    Find the vertex of a quadratic equation provided standard form coefficients or vertex form parameters.\n    \n    Parameters:\n    ---------------\n    a : float\n        The coefficient of x^2.\n    b : float, optional\n        The coefficient of x in the standard form (ax^2 + bx + c).\n    c : float, optional\n        The constant term in the standard form.\n    h : float, optional\n        The x-coordinate of the vertex in the vertex form (a(x - h)^2 + k).\n    k : float, optional\n        The y-coordinate of the vertex in the vertex form.\n    Returns:\n    ---------------\n    tuple\n        The coordinates of the vertex (x, y).\n    Examples:\n    ---------------\n    >>> find_vertex_of_quadratic(1, -4, 4)  # Standard form y = x^2 - 4x + 4\n    (2, 0)\n    >>> find_vertex_of_quadratic(1, h=2, k=0)  # Vertex form y = (x - 2)^2\n    (2, 0)\n    \"\"\"\n    if h is not None and k is not None:\n        return (h, k)\n    elif b is not None and c is not None:\n        vertex_x = -b / (2 * a)\n        vertex_y = a * vertex_x ** 2 + b * vertex_x + c\n        return (vertex_x, vertex_y)\n    else:\n        raise ValueError(\"Insufficient parameters supplied.\")",
            "def find_vertex_quadratic(a, b, c):\n    \"\"\"\n    Determines the vertex of a quadratic function of the form ax^2 + bx + c.\n    Parameters:\n    - a (float): Coefficient of x^2.\n    - b (float): Coefficient of x.\n    - c (float): Constant term.\n    Returns:\n    - tuple: Coordinates of the vertex (h, k).\n    Example:\n    >>> find_vertex_quadratic(1, -4, 4)\n    (2.0, 0.0)\n    \"\"\"\n    h = -b / (2 * a)\n    k = a * h**2 + b * h + c\n    return (h, k)"
        ],
        [
            "def shift_function_horizontally(f, h):\n    \"\"\"\n    Shift the function f horizontally.\n    Parameters:\n        f (sp.Expr): A sympy expression representing a function of variable x.\n        h (float): The horizontal shift amount. Positive values shift right, negative shift left.\n    Returns:\n        sp.Expr: A new function expression representing f shifted horizontally by h units.\n    \n    Example:\n        >>> x = sp.symbols('x')\n        >>> original_function = x**2\n        >>> shifted_function = shift_function_horizontally(original_function, 2)  # Shifts right by 2\n        >>> print(shifted_function)\n        (x - 2)**2\n    \"\"\"\n    x = sp.symbols('x')\n    return f.subs(x, x - h)",
            "def vertical_shift(f, c):\n    \"\"\"\n    Shift the function f vertically.\n    Parameters:\n        f (sp.Expr): A sympy expression representing a function of variable x.\n        c (float): The vertical shift amount. Positive values shift upwards, negative shift downwards.\n    Returns:\n        sp.Expr: A new function expression representing f shifted vertically by c units.\n    \n    Example:\n        >>> x = sp.symbols('x')\n        >>> original_function = sp.sin(x)\n        >>> shifted_function = vertical_shift(original_function, 3)  # Shifts up by 3\n        >>> print(shifted_function)\n        sin(x) + 3\n    \"\"\"\n    return f + c"
        ],
        [
            "def transform_function(expression, h_shift=0, v_shift=0, h_scale=1, v_scale=1, reflection_x=False, reflection_y=False):\n    \"\"\"\n    Transform a function by applying horizontal and vertical shifts, scalings, and reflections.\n    Parameters:\n    ---------------\n    expression : sympy.Expr\n        The mathematical expression representing the function to be transformed.\n    h_shift : float, optional\n        Horizontal shift (positive shifts right, negative shifts left). Default is 0.\n    v_shift : float, optional\n        Vertical shift (positive shifts up, negative shifts down). Default is 0.\n    h_scale : float, optional\n        Horizontal scaling factor (greater than 1 compresses the x-axis, less than 1 expands the x-axis). Default is 1.\n    v_scale : float, optional\n        Vertical scaling factor (greater than 1 stretches the function, less than 1 compresses the function). Default is 1.\n    reflection_x : bool, optional\n        Apply reflection across the x-axis. Default is False.\n    reflection_y : bool, optional\n        Apply reflection across the y-axis. Default is False.\n    Returns:\n    ---------------\n    sympy.Expr\n        The transformed function as a sympy expression.\n    Examples:\n    ---------------\n    >>> x = sp.symbols('x')\n    >>> original_expr = x ** 2  # y = x^2\n    >>> transformed_expr = transform_function(original_expr, h_shift=2, v_shift=-3, h_scale=0.5, v_scale=2)\n    >>> transformed_expr\n    2*(0.5*x - 1)**2 - 3\n    \"\"\"\n    x = sp.Symbol('x')\n    transformed_expr = expression.subs(x, (x - h_shift) / h_scale)\n    \n    if reflection_x:\n        transformed_expr = -transformed_expr\n    \n    transformed_expr = v_scale * transformed_expr + v_shift\n    \n    if reflection_y:\n        transformed_expr = transformed_expr.subs(x, -x)\n    return transformed_expr",
            "class FunctionTransformer:\n    \"\"\"\n    A utility class for applying mathematical transformations to functions.\n    \n    Parameters:\n    - function (sympy.Expr): The mathematical function represented as a sympy expression.\n    \n    Examples:\n    - f = sp.sympy.Function('f')\n    - x = sp.symbols('x')\n    - transformer = FunctionTransformer(f(x))\n    \"\"\"\n    \n    def __init__(self, function):\n        self.function = function\n    \n    def reflect_y_axis(self):\n        \"\"\"Reflects the function across the y-axis to obtain f(-x).\n        \n        Returns:\n        - sympy.Expr: The reflected function.\n        \"\"\"\n        x = sp.symbols('x')\n        return self.function.subs(x, -x)\n    \n    def horizontal_shift(self, shift):\n        \"\"\"Shifts the function horizontally by a specified amount.\n        \n        Parameters:\n        - shift (float): The amount to shift; positive shifts to the right, negative to the left.\n        \n        Returns:\n        - sympy.Expr: The horizontally shifted function.\n        \"\"\"\n        x = sp.symbols('x')\n        return self.function.subs(x, x - shift)\n    \n    def horizontal_scale(self, scale_factor):\n        \"\"\"Scales the function horizontally by a specific factor.\n        \n        Parameters:\n        - scale_factor (float): The scaling factor. Values > 1 compress the function, < 1 stretch it.\n        \n        Returns:\n        - sympy.Expr: The horizontally scaled function.\n        \"\"\"\n        x = sp.symbols('x')\n        return self.function.subs(x, x * scale_birthdate)\n    \n    def vertical_shift(self, shift):\n        \"\"\"Shifts the function vertically by a specified amount.\n        \n        Parameters:\n        - shift (float): The amount to shift upwards or downwards.\n        \n        Returns:\n        - sympy.Expr: The vertically shifted function.\n        \"\"\"\n        return self.function + shift",
            "def apply_function_transformation(f, shift_x=0, shift_y=0, scale_x=1, scale_y=1, reflect_x=False, reflect_y=False):\n    \"\"\"\n    Applies transformations to a given symbolic function: translation, scaling, and reflection.\n    Parameters:\n    - f (sympy.Expr): The function to transform, expressed as a sympy expression.\n    - shift_x (float, optional): Horizontal shift; positive for right, negative for left.\n    - shift_y (float, optional): Vertical shift; positive for up, negative for down.\n    - scale_x (float, optional): Scaling factor along the x-axis.\n    - scale_y (float, optional): Scaling factor along the y-axis.\n    - reflect_x (bool, optional): Set to True to reflect the function across y-axis.\n    - reflect_y (bool, optional): Set to True to reflect the function across x-axis.\n    Returns:\n    - sympy.Expr: The transformed function.\n    Example:\n    >>> x = sp.symbols('x')\n    >>> f = x**2\n    >>> apply_function_transformation(f, shift_x=2, shift_y=3, scale_x=-1, scale_y=0.5)\n    0.5*(-x + 2)**2 + 3\n    \"\"\"\n    x = sp.symbols('x')\n    # Apply scaling and reflection\n    if reflect_x:\n        x_transformed = -x * scale_x\n    else:\n        x_transformed = x * scale_x\n    \n    if reflect_y:\n        f = -f\n    f_transformed = f.subs(x, x_transformed - shift_x) * scale_y + shift_y\n    return f_transformed",
            "def transform_function(expression, x_shift=0, y_shift=0, horizontal_stretch=1, reflect_y_axis=False):\n    \"\"\"\n    Apply various transformations to a symbolic expression representing a function.\n    \n    Parameters:\n    - expression (str or sympy.Expr): The mathematical expression in a string or Sympy expression format.\n    - x_shift (float, optional): The horizontal shift amount. Positive values shift right; negative values shift left.\n    - y_shift (float, optional): The vertical shift amount. Positive values shift up; negative values shift down.\n    - horizontal_stretch (float, optional): The factor by which the function is horizontally stretched or compressed.\n                                        Values > 1 compress the function, and 0 < values < 1 stretch the function.\n    - reflect_y_axis (bool, optional): If True, reflect the function across the y-axis.\n    \n    Returns:\n    sympy.Expr: The transformed function.\n    Examples:\n    >>> f = \"x**2 + 3*x + 2\"\n    >>> print(transform_function(f))\n    x**2 + 3*x + 2\n    >>> print(transform_function(f, x_shift=2))\n    (x - 2)**2 + 3*(x - 2) + 2\n    >>> print(transform_function(f, y_shift=3))\n    x**2 + 3*x + 5\n    >>> print(transform_function(f, horizontal_stretch=2))\n    (x/2)**2 + 3*(x/2) + 2\n    >>> print(transform_function(f, reflect_y_axis=True))\n    (-x)**2 + 3*(-x) + 2\n    \"\"\"\n    x = sp.symbols('x')  # Define the symbol for the function\n    f = sp.sympify(expression)  # Convert string expression to a sympy expression if necessary\n    \n    # Apply Horizontal Stretch/Compression\n    if horizontal_stretch != 1:\n        f = f.subs(x, x / horizontal_stretch)\n    \n    # Apply Reflection across the y-axis\n    if reflect_y_axis:\n        f = f.subs(x, -x)\n    \n    # Apply Horizontal Shift\n    if x_shift != 0:\n        f = f.subs(x, x - x_shift)\n    \n    # Apply Vertical Shift\n    f = f + y_shift\n    \n    return f"
        ],
        [
            "def scale_function(expression, horizontal_scale, vertical_scale):\n    \"\"\"\n    Scales a function by modifying its width and height.\n    Parameters:\n    - expression (callable): The function to be scaled.\n    - horizontal_scale (float): The horizontal scaling factor.\n    - vertical_scale (float): The vertical scaling factor.\n    Returns:\n    - callable: A new function that represents the scaled function.\n    Example:\n    >>> f = lambda x: x**2\n    >>> g = scale_function(f, horizontal_scale=2, vertical_scale=0.5)\n    >>> g(2)  # This evaluates 0.5 * (x/2)^2 at x = 2\n    0.5\n    \"\"\"\n    return lambda x: vertical_scale * expression(x / horizontal_scale)"
        ],
        [
            "def find_function_vertex(f):\n    \"\"\"\n    Finds the vertex of a quadratic or absolute value function.\n    Parameters:\n    - f (sympy.Expr): The function, expected to be either quadratic or absolute value of linear.\n    Returns:\n    - tuple: Vertex of the function as (x, y).\n    Example:\n    >>> x = sp.symbols('x')\n    >>> f = abs(x - 1) + 3\n    >>> find_function_vertex(f)\n    (1, 3)\n    Note:\n    For quadratic, the vertex form is assumed. If not provided in vertex form, convert f accordingly.\n    \"\"\"\n    x = sp.symbols('x')\n    if isinstance(f, sp.Abs):\n        # For absolute functions, vertex is where the expression inside abs is zero\n        inside_abs = list(f.args)[0]\n        vertex_x = sp.solve(inside_abs, x)\n        vertex_y = f.subs(x, vertexx)\n    else:\n        # Assuming the function is quadratic and already in vertex form\n        vertex_x = -f.coeff(x, 2) / (2 * f.coeff(x, 1))\n        vertex_y = f.subs(x, vertex_x)\n    \n    return (vertex_x, vertex_y)"
        ],
        [
            "class FunctionPlotter:\n    \"\"\"\n    Plots mathematical functions to visualize transformations.\n    \n    Parameters:\n    - expression (sympy.Expr): The function expression to plot.\n    - domain (tuple): A tuple (start, end) defining the domain over which to plot the function.\n    \n    Examples:\n    - x = sp.symbols('x')\n    - plotter = FunctionPlotter(sp.sin(x), (-10, 10))\n    \"\"\"\n    \n    def __init__(self, expression, domain=(-10, 10)):\n        self.expression = expression\n        self.domain = domain\n    \n    def plot(self):\n        \"\"\"Plots the function over its domain using matplotlib.\n        \n        Uses a numpy array to evaluate the function at multiple points.\n        \"\"\"\n        x = sp.symbols('x')\n        f = sp.lambdify(x, self.expression, 'numpy')\n        x_vals = np.linspace(self.domain[0], self.domain[1], 400)\n        y_vals = f(x_vals)\n        \n        plt.figure(figsize=(8, 4))\n        plt.plot(x_vals, y_vals, label=str(self.expression))\n        plt.xlabel('x')\n        plt.ylabel('f(x)')\n        plt.title('Function Plot')\n        plt.legend()\n        plt.grid(True)\n        plt.show()"
        ],
        [
            "def reflect_function_across_y_axis(f):\n    \"\"\"\n    Reflect the function f across the y-axis.\n    Parameters:\n        f (sp.Expr): A sympy expression representing a function of variable x.\n    Returns:\n        sp.Expr: A new function expression representing the reflection of f across the y-axis, i.e., f(-x).\n    \n    Example:\n        >>> x = sp.symbols('x')\n        >>> original_function = x**2\n        >>> reflected_function = reflect_function_across_y_axis(original_function)\n        >>> print(reflected_function)\n        x**2\n    \"\"\"\n    x = sp.symbols('x')\n    return f.subs(x, -x)"
        ],
        [
            "def horizontal_stretch_compression(f, b):\n    \"\"\"\n    Apply horizontal stretch or compression to the function f.\n    Parameters:\n        f (sp.Expr): A sympy expression representing a function of variable x.\n        b (float): The factor by which the function is stretched (b > 1) or compressed (0 < b < 1).\n    Returns:\n        sp.Expr: A new function expression representing f stretched or compressed horizontally.\n    \n    Example:\n        >>> x = sp.symbols('x')\n        >>> original_function = sp.exp(x)\n        >>> modified_function = horizontal_stretch_compression(original_function, 2)  # Compress by factor of 2\n        >>> print(modified_function)\n        exp(x/2)\n    \"\"\"\n    x = sp.symbols('x')\n    return f.subs(x, x / b)"
        ],
        [
            "def translate_function(expression, h_shift, v_shift):\n    \"\"\"\n    Translates a function by applying horizontal and vertical shifts.\n    Parameters:\n    - expression (callable): The function to be translated.\n    - h_shift (float): The horizontal shift (`h` units to the right if positive).\n    - v_shift (float): The vertical shift (`k` units up if positive).\n    Returns:\n    - callable: A new function that represents the translated function.\n    Example:\n    >>> f = lambda x: x**2\n    >>> g = translate_function(f, h_shift=3, v_shift=-4)\n    >>> g(0)  # This evaluates (x - 3)^2 - 4 at x = 0\n    5\n    \"\"\"\n    return lambda x: expression(x - h_shift) + v_shift"
        ]
    ],
    "Completing the Square": [
        [
            "def complete_the_square(expression):\n    \"\"\"\n    Converts a quadratic expression ax^2 + bx + c into the form a(x-h)^2 + k.\n    Parameters:\n    - expression : str\n        A string representing the quadratic expression in the form 'ax^2 + bx + c'.\n    Returns:\n    - str\n        The completed square form of the input quadratic expression.\n    Example:\n    >>> complete_the_square('x^2 + 6x + 9')\n    '(x + 3)**2 + 0'\n    \"\"\"\n    x = symbols('x')\n    # Convert the input expression to a sympy expression\n    expr = eval(expression.replace('^', '**'))\n    \n    # Factor out 'a' if necessary (coeff of x^2)\n    a = expr.coeff(x, 2)\n    b = expr.coeff(x, 1)\n    c = expr.coeff(x, 0)\n    \n    if a != 1 and a != 0:\n        expr = expr/a\n    # Complete the square\n    # Expression now is x^2 + (b/a)x + (c/a)\n    b = expr.coeff(x, 1)\n    \n    # (x + b/2a)^2 = x^2 + bx/a + (b/2a)^2\n    # we have to subtract (b/2a)^2 then add (c/a)\n    completed_square = (x + b/2)**2 - (b/2)**2 + c\n    if a != 1 and a != 0:\n        # Multiply the completed square with 'a'\n        completed_square = a * completed_square\n    return str(factor(completed_square))",
            "def factor_and_complete_square(expression, variable):\n    \"\"\"\n    Factor out common terms from a quadratic expression and completes the square.\n    Parameters:\n    - expression (sympy.Expr): A SymPy expression, preferably quadratic in nature.\n    - variable (sympy.Symbol): The primary variable in the expression to complete the square.\n    Returns:\n    - sympy.Expr: A new expression where the square has been completed.\n    Examples:\n    >>> x = sp.symbols('x')\n    >>> expr = 3*x**2 + 18*x + 27\n    >>> print(factor_and_complete_square(expr, x))\n    3*(x + 3)**2\n    \"\"\"\n    # Normalize the expression\n    expr = sp.simplify(expression)\n    # Coefficients a, b, c from ax^2 + bx + c\n    a, b, c = expr.as_poly(variable).all_coeffs()\n    # Completing the square\n    completed_square = a * (variable + b/(2*a))**2 + (c - (b**2)/(4*a))\n    return sp.simplify(completed_square)",
            "def complete_the_square(expression, variable):\n    \"\"\"\n    Completes the square for a given quadratic expression in one variable.\n    Parameters:\n    - expression (sp.Expr): The quadratic expression (assumed to be in terms of one variable).\n    - variable (sp.Symbol): The variable with respect to which the square is to be completed.\n    Returns:\n    - sp.Expr: The expression rewritten in the completed square form.\n    Example:\n    >>> x = sp.Symbol('x')\n    >>> expr = x**2 + 6*x + 5\n    >>> print(complete_the_square(expr, x))\n    (x + 3)**2 - 4\n    \"\"\"\n    expr = sp.expand(expression)\n    a, b, c = expr.coeff(variable, 2), expr.coeff(variable, 1), expr.coeff(variable, 0)\n    completed_square = a*(variable + b/(2*a))**2 - (b**2 - 4*a*c)/(4*a)\n    return sp.simplify(completed_square)",
            "def complete_the_square(expr, var):\n    \"\"\"\n    Completes the square for a given quadratic expression.\n    Parameters\n    ----------\n    expr : sympy Expr\n        A sympy expression representing the quadratic expression to be completed.\n    var : sympy Symbol\n        The variable with respect to which the square is to be completed.\n    Returns\n    -------\n    completed_expr : sympy Expr\n        The quadratic expression in completed square form.\n    constants : tuple\n        Additional constants that were added or subtracted to maintain equality.\n    Examples\n    --------\n    >>> from sympy.abc import x\n    >>> expr = x**2 - 4*x + 1\n    >>> completed_expr, constants = complete_the_square(expr, x)\n    >>> completed_expr\n    (x - 2)**2 - 3\n    >>> constants\n    (4,)\n    \"\"\"\n    a_coef = expr.coeff(var, 2)\n    b_coef = expr.coeff(var, 1)\n    c = expr.as_coeff_add(var**2)[0]  # Free term not involving var\n    # Calculate the term to complete the square\n    completing_term = (b_coef / (2*a_coef))**2\n    # Construct the completed square expression\n    completed_expr = a_coef * (var + b_coef / (2*a_coef))**2 - a_coef * completing_term + c\n    return completed_expr, (a_coef * completing_term,)"
        ],
        [
            "def quadratic_to_vertex_form(a, b, c):\n    \"\"\"\n    Converts a quadratic equation of the form ax^2 + bx + c = 0 into its vertex form.\n    Parameters:\n    - a (float): Coefficient of x^2\n    - b (float): Coefficient of x\n    - c (float): Constant term\n    Returns:\n    - str: A string representing the quadratic equation in vertex form.\n    Examples:\n    >>> quadratic_to_vertex_form(1, -6, 8)\n    'x**2 - 6*x + 8 = (x - 3)**2 - 1'\n    \"\"\"\n    x = symbols('x')  # Define the symbol\n    # The original expression\n    original_expr = a*x**2 + b*x + c\n    # Complete the square\n    completed_expr = original_expr.expand().complete_square(x)\n    # Create the equation form\n    equation = Eq(original_expr, completed_expr)\n    return equation",
            "def complete_the_square(a, b, c):\n    \"\"\"\n    Converts a quadratic equation `ax^2 + bx + c` into its completed square form.\n    Parameters:\n    - a (int/float): Coefficient of x^2\n    - b (int/float): Coefficient of x\n    - c (int/float): Constant term\n    Returns:\n    - (sp.Expr, float): A tuple containing a SymPy expression of the completed square and the transformed constant term.\n    Examples:\n    >>> complete_the_square(1, -2, -3)\n    ((x - 1)**2, -4)\n    >>> complete_the_square(2, 4, 2)\n    (2*(x + 1)**2, -6)\n    \"\"\"\n    x = sp.symbols('x')\n    if a != 1:\n        b /= a\n        c /= a\n        a = 1\n    completed_square = a * (x + b / 2)**2\n    constant_term = c - (b**2 / (4 * a))\n    return completed_square, constant_term",
            "def complete_square(a, b, c):\n    \"\"\"\n    Transform a quadratic equation ax^2 + bx + c = 0 into the completed square form (x-h)^2 + k = 0.\n    Parameters:\n        a (float): Coefficient of x^2\n        b (float): Coefficient of x\n        c (float): Constant term\n    Returns:\n        str: The quadratic equation in completed square form.\n    Examples:\n        >>> complete_square(1, -6, 8)\n        '(x - 3.0)^2 - 1.0 = 0'\n    \"\"\"\n    from sympy import Rational, sqrt, simplify\n    if a == 0:\n        raise ValueError(\"Coefficient 'a' must not be zero for a quadratic expression.\")\n    h = -b / (2 * a)\n    k = a * h**2 + b * h + c\n    h = simplify(h)\n    k = simplify(k)\n    \n    return f\"(x - {h})^2 + {k} = 0\"",
            "def complete_square_univariate(a, b, c):\n    \"\"\"\n    Converts a univariate quadratic equation of the form ax^2 + bx + c into vertex form (x-h)^2 + k.\n    Parameters:\n    a (float): Coefficient of x^2\n    b (float): Coefficient of x\n    c (float): Constant term\n    Returns:\n    tuple: A tuple containing the vertex form as a symbolic expression and the vertex as a tuple (h, k).\n    Examples:\n    >>> complete_square_univariate(1, -6, 8)\n    ((x - 3)**2 - 1, (3, -1))\n    \n    >>> complete_square_univariate(2, -8, 6)\n    (2*(x - 2)**2 - 2, (2, -2))\n    \"\"\"\n    x = sp.symbols('x')\n    # Forming the quadratic equation\n    expr = a*x**2 + b*x + c\n    \n    # Completing the square\n    completed_expr = sp.simplify(sp.expand(expr).collect(x))\n    vertex_form = completed_expr - sp.simplify(completed_expr.subs(x, 0)) + sp.simplify(completed_expr.subs(x, 0))\n    \n    # Determining the vertex (h, k)\n    vertex_h = -b / (2*a)\n    vertex_k = a*vertex_h**2 + b*vertex_h + c\n    \n    return vertex_form, (vertex_h, vertex_k)",
            "def complete_the_square(a, b, c):\n    \"\"\"\n    Transform a quadratic equation ax^2 + bx + c = 0 into the vertex form a(x-h)^2 + k = 0 using the technique of completing the square.\n    \n    Parameters:\n    - a (int, float): Coefficient of x^2.\n    - b (int, float): Coefficient of x.\n    - c (int, float): Constant term.\n    \n    Returns:\n    - tuple: Provides the vertex form coefficients `(a, h, k)`.\n    \n    Examples:\n    >>> complete_the_square(1, -4, 4)\n    (1, 2, 0)  # corresponding to (x-2)^2\n    \n    >>> complete_the_square(2, -8, 8)\n    (2, 2, -4)  # corresponding to 2(x-2)^2 - 4\n    \"\"\"\n    x = sp.symbols('x')\n    # Convert the standard quadratic form into a symbolic expression\n    expr = a*x**2 + b*x + c\n    \n    # Completing the square\n    completed_expr = sp.expand(expr).collect(x)\n    \n    # Get vertex form by completing the square\n    p = sp.Poly(completed_expr, x)\n    a2, b2, c2 = p.all_coeffs()\n    h = -b2/(2*a2)\n    k = a2*(h**2) + b2*h + c2\n    \n    return (a, h, k)",
            "def complete_the_square(a, b, c):\n    \"\"\"\n    Convert a quadratic equation in the form ax^2 + bx + c into a completed square form.\n    Parameters:\n    - a (int/float): Coefficient of x^2\n    - b (int/float): Coefficient of x\n    - c (int/float): Constant term\n    Returns:\n    - tuple: A tuple containing the expression of the completed square and the simplified constant component.\n      Form: ((expression in completed square), constant)\n    Examples:\n    >>> complete_the_square(1, 4, 4)\n    ((x + 2)**2, 0)\n    \n    >>> complete_the_square(1, -6, 9)\n    ((x - 3)**2, 0)\n    \n    >>> complete_the_square(2, -8, 8)\n    (2*(x - 2)**2, 0)\n    \"\"\"\n    from sympy import symbols, simplify\n    \n    x = symbols('x')\n    p = -b / (2*a)\n    q = a*(x + p)**2 + c - a*p**2\n    \n    return simplify(a*(x + p)**2), simplify(q)",
            "def solve_quadratic_from_completed_square(a, b, c):\n    \"\"\"\n    Solve a quadratic equation given in the standard form ax^2 + bx + c using the completed square form to find solutions.\n    Parameters:\n    - a (int/float): Coefficient of x^2\n    - b (int/float): Coefficient of x\n    - c (int/float): Constant term\n    Returns:\n    - tuple: Real or complex roots of the quadratic equation.\n    Examples:\n    >>> solve_quadratic_from_completed_square(1, 4, 4)\n    (-2, -2)\n    \n    >>> solve_quadratic_from_completed_square(1, -6, 9)\n    (3, 3)\n    \n    >>> solve_quadratic_from_completed_square(2, -8, 8)\n    (2, 2)\n    \"\"\"\n    from sympy import symbols, solve, simplify\n    \n    x = symbols('x')\n    square_form, additional_constant = complete_the_square(a, b, c)\n    \n    # Equation to solve\n    equation = square_form + additional_constant\n    \n    # Finding the roots\n    roots = solve(equation, x)\n    \n    return tuple(simplify(root) for root in roots)",
            "def complete_square_one_variable(a, b, c):\n    \"\"\"\n    This function transforms a quadratic equation of the form ax^2 + bx + c into the vertex form a(x-h)^2 + k.\n    \n    Parameters:\n        a (int or float): Coefficient of x^2\n        b (int or float): Coefficient of x\n        c (int or float): Constant term\n    Returns:\n        tuple: Contains the vertex form expression as a sympy expression and the vertex (h, k) as a tuple.\n    Examples:\n        >>> complete_square_one_variable(1, -4, 4)\n        (1*(x-2)**2+0, (2, 0))\n        >>> complete_square_one_variable(2, 8, 2)\n        (2*(x+2)**2-14, (-2, -14))\n    \"\"\"\n    x = sp.symbols('x')\n    # Transformation into vertex form\n    vertex_form = a * (x - (-b / (2 * a)))**2 + (c - (b**2 / (4 * a)))\n    h = -b / (2 * a)\n    k = c - (b**2 / (4 * a))\n    return vertex_form, (h, k)",
            "def complete_the_square(a, b, c):\n    \"\"\"\n    Takes the coefficients of a quadratic equation ax^2 + bx + c, and returns the equation in the \n    completed square form along with the h and k values from vertex form (x+h)^2 = k.\n    \n    Parameters:\n    a (float/int): Coefficient of x^2\n    b (float/int): Coefficient of x\n    c (float/int): Constant term\n    \n    Returns:\n    Tuple:\n        - str: Quadratic equation in completed square form as a string\n        - float: Value 'h' in the vertex form\n        - float: Value 'k' in the vertex form\n    \n    Example:\n    >>> complete_the_square(1, -6, 8)\n    (\"(x - 3.0)^2 - 1.0\", 3.0, -1.0)\n    \"\"\"\n    # Derive the square completion\n    x = sp.Symbol('x')\n    expression = a*x**2 + b*x + c\n    completed_square = sp.simplify(sp.expand(expression)).collect(x, sp.factor)\n    \n    # Extract h and k for the vertex form\n    h = -b / (2 * a)\n    k = a * h**2 + b * h + c\n    \n    # Creating the completed square form as a string\n    if h == 0:\n        cs_form = f'(x)^2 + {k}'\n    else:\n        cs_form = f'(x - {h})^2 + {k}'\n    \n    return cs_form, h, k",
            "def complete_square(a, b, c):\n    \"\"\"\n    Transform a quadratic equation of form `ax^2 + bx + c` into a completed square form.\n    Parameters:\n    a (int or float): Coefficient of x^2\n    b (int or float): Coefficient of x\n    c (int or float): Constant term\n    Returns:\n    tuple: A tuple containing the symbolic equation in completed square form and \n           the roots calculated from this transformation.\n    \n    Examples:\n    >>> complete_square(1, -3, 2)\n    (Eq((x - 1.5)**2, 0.25), [1.50000000000000])\n    >>> complete_square(2, -4, 2)\n    (Eq((x - 1.0)**2, 0), [1.00000000000000])\n    \"\"\"\n    # Define the variable\n    x = symbols('x')\n    \n    # First ensure the coefficient of x^2 is 1 by dividing entire equation if needed\n    a_normal = a / a  # which is essentially 1\n    b_normal = b / a\n    c_normal = c / a\n    \n    # Compute the term to complete the square\n    half_b = b_normal / 2\n    completion_square_add = half_b**2\n    \n    # Form the completed square\n    completed_form = (x + half_b)**2 - completion_square_add + c_normal\n    \n    # Set the equation to zero\n    equation = Eq(completed_form, 0)\n    \n    # Calculate roots\n    roots = solve(equation, x)\n    \n    return equation.simplify(), roots",
            "def complete_the_square(coef_a, coef_b, coef_c):\n    \"\"\"\n    Transform a quadratic equation ax^2 + bx + c into the form a(x-h)^2 + k.\n    Parameters:\n    - coef_a (int or float): Coefficient of x^2\n    - coef_b (int or float): Coefficient of x\n    - coef_c (int or float): Constant term\n    \n    Returns:\n    - sympy.Expr: The equation in completed square form.\n    - float: The value h in the completed square.\n    - float: The value k in the completed square.\n    Examples:\n    >>> equation, h, k = complete_the_square(1, -4, 4)\n    >>> equation\n    (x - 2)**2\n    >>> h, k\n    (2, 0)\n    \"\"\"\n    x = sp.symbols('x')\n    equation = coef_a * x**2 + coef_bg * x + coef_c\n    completed_square = sp.expand(equation).complete_square(x)\n    h = -coef_b / (2 * coef_a)\n    k = coef_a * h**2 + coef_b * h + coef_c\n    return completed_square, h, k"
        ],
        [
            "def complete_square_bivariate(ax2, bxy, cy2, dx, ey, f):\n    \"\"\"\n    Completes the square for a bivariate quadratic expression of the form ax^2 + bxy + cy^2 + dx + ey + f\n    Parameters:\n    - ax2 (float): Coefficient of x^2\n    - bxy (float): Coefficient of xy\n    - cy2 (float): Coefficient of y^2\n    - dx (float): Coefficient of x\n    - ey (float): Coefficient of y\n    - f (float): Constant term\n    Returns:\n    - expr: The expression reorganized by completing the square, in symbolic form.\n    Examples:\n    >>> str(complete_square_bivariate(1, 0, 1, -6, -8, 20))\n    'x**2 - 6*x + y**2 - 8*y + 20 = (x - 3)**2 + (y - 4)**2 + 3'\n    \"\"\"\n    x, y = symbols('x y')  # Define the symbols\n    # The original expression\n    original_expr = ax2*x**2 + bxy*x*y + cy2*y**2 + dx*x + ey*y + f\n    # Complete the square for both x and y\n    x_part = (ax2*x**2 + dx*x).complete_square(x)\n    y_part = (cy2*y**2 + ey*y).complete_square(y)\n    # Reformulate the expression\n    completed_expr = x_part + y_part + f - x_part.subs(x, 0) - y_part.subs(y, 0)\n    equation = Eq(original_expr, completed_expr)\n    return equation",
            "def complete_square_two_variables(a, b, c, d, e, f):\n    \"\"\"\n    Convert a general quadratic equation in two variables (x, y) ax^2 + by^2 + cx + dy + e = f \n    into a completed square form.\n    Parameters:\n        a (float): Coefficient of x^2\n        b (float): Coefficient of y^2\n        c (float): Coefficient of x\n        d (float): Coefficient of y\n        e (float): Constant term\n        f (float): Term on the other side of the equation\n    Returns:\n        str: The quadratic equation in completed square form and perhaps matching a form of circles or ellipses.\n    Examples:\n        >>> complete_square_two_variables(1, 1, -6, -8, 9, 0)\n        '(x - 3.0)^2 + (y + 4.0)^2 = 16.0'\n    \"\"\"\n    from sympy import Rational, sqrt, simplify\n    # Complete the square for x terms\n    h = -c / (2 * a)\n    x_term = a * (h**2) + c * h\n    # Complete the square for y terms\n    k = -d / (2 * b)\n    y_term = b * (k**2) + d * k\n    # Combining constants and rearranging equation\n    constant_term = e - f + x_term + y_term\n    constant_term = simplify(constant_term)\n    h = simplify(h)\n    k = simplify(k)\n    return f\"(x - {h})^2 + (y - {k})^2 = {-constant_term}\"",
            "def complete_square_bivariate(a, b, c, d, e, f):\n    \"\"\"\n    Completes the square for a bivariate quadratic equation of form ax^2 + by^2 + cxy + dx + ey + f.\n    Parameters:\n    a, b, c (float): Coefficients for x^2, y^2, and xy terms respectively.\n    d, e, f (float): Linear and constant coefficients for x, y, and constant term respectively.\n    Returns:\n    tuple: Returns the expression in a completed square form involving terms (u-h)^2, (v-k)^2 and possibly others if the equation is not perfectly factorable.\n    Examples:\n    >>> complete_square_bivariate(1, 1, 0, -6, -8, 9)\n    ((x - 3)**2 + (y - 4)**2 - 4, (3, 4))\n    >>> complete_square_bivariate(1, 1, 0, 0, 0, -25)\n    (x**2 + y**2 - 25, (0, 0))\n    \"\"\"\n    x, y = sp.symbols('x y')\n    expr = a*x**2 + b*y**2 + c*x*y + d*x + e*y + f\n    \n    completed_expr_x = sp.collect(sp.expand(expr), x)\n    completed_expr_xy = sp.collect(completed_expr_x, y)\n    \n    # Simplify to obtain minimum value\n    h, k = sp.symbols('h k')\n    min_expr = sp.expand(completed_expr_xy.subs({x: h, y: k}))\n    \n    vertex_form = completed_expr_xy - min_expr + sp.expand(min_expr)\n    \n    vertex_h = -d / (2*a) if a != 0 else 0\n    vertex_k = -e / (2*b) if b != 0 else 0\n    \n    return vertex_form, (vertex_h, vertex_k)",
            "def complete_square_two_variables(A, B, C, D, E, F):\n    \"\"\"\n    Completes the square for a two-variable quadratic equation of the form\n    Ax^2 + Bxy + Cy^2 + Dx + Ey + F = 0.\n    Parameters:\n        A, B, C, D, E, F (int or float): Coefficients of the equation terms.\n    Returns:\n        str: A string representing the equation in a more simplified form where squares are completed.\n    Examples:\n        >>> complete_square_two_variables(1, 0, 1, -6, -8, 9)\n        '(x - 3.0)**2 + (y - 4.0)**2 - 4.0 = 0'\n        >>> complete_square_two_variables(1, 0, 1, 0, 0, -1)\n        '(x - 0.0)**2 + (y - 0.0)**2 + 1 = 0'\n    \"\"\"\n    x, y = sp.symbols('x y')\n    expr = A*x**2 + B*x*y + C*y**2 + D*x + E*y + F\n    # The completing the square step depends greatly on the specific form and simplifications may vary\n    # Here, a basic completion with B=0 is assumed for simplicity and common case handling.\n    # Completing the square for the x terms\n    x_term = A * (x + D / (2 * A))**2 - (D**2 / (4 * A))\n    # Completing the square for the y terms\n    y_term = C * (y + E / (2 * C))**2 - (E**2 / (4 * C))\n    # Combine the completed terms with constant to form a new equation\n    simplified_expr = sp.simplify(x_term + y_term + F)\n    return str(simplified_expr) + \" = 0\""
        ],
        [
            "def standardize_circle_equation(expression, x, y):\n    \"\"\"\n    Converts a general quadratic equation of two variables (x and y) into the standard form of a circle.\n    Parameters:\n    - expression (sp.Expr): The quadratic expression in terms of x and y.\n    - x (sp.Symbol), y (sp.Symbol): The symbols representing the variables.\n    Returns:\n    - dict: A dictionary containing the standard form and parameters like center and radius.\n    Example:\n    >>> x, y = sp.symbols('x y')\n    >>> expr = x**2 + y**2 + 6*x - 4*y - 12\n    >>> result = standardize_circle_equation(expr, x, y)\n    >>> print(result['standard_form'])\n    (x + 3)**2 + (y - 2)**2 = 25\n    >>> print(result['center'])\n    (-3, 2)\n    >>> print(result['radius'])\n    5\n    \"\"\"\n    # Move constants to the right\n    expr = sp.expand(expression)\n    C = expr.subs({x: 0, y: 0})\n    expr -= C\n    # Complete the square for x and y terms\n    x_part = complete_the_index(expr, x)\n    y_part = complete_the_index(expr, y)\n    \n    # Combine results\n    standard_form = x_part + y_part + C\n    center_x, center_y = -x_part.as_poly().LC() / 2, -y_part.as_poly().LC() / 2\n    radius = sp.sqrt(abs(C))\n    return {'standard_form': sp.Eq(x_part + y_part, radius**2),\n            'center': (center_x, center_y),\n            'radius': radius}"
        ],
        [
            "def get_vertex_from_quadratic(a, b, c):\n    \"\"\"\n    Returns the vertex (x, y) of the parabola defined by the quadratic equation `ax^2 + bx + c`.\n    Parameters:\n    - a (int/float): Coefficient of x^2\n    - b (int/float): Coefficient of x\n    - c (int/float): Constant term\n    Returns:\n    - (float, float): The vertex of the quadratic equation.\n    Examples:\n    >>> get_vertex_from_quadratic(1, -2, -3)\n    (1.0, -4.0)\n    >>> get_vertex_from_quadratic(2, 4, 2)\n    (-1.0, -6.0)\n    \"\"\"\n    x = -b / (2 * a)\n    y = a * x * x + b * x + c\n    return x, y"
        ],
        [
            "def standardize_circle_equation(coef_x2, coef_xy, coef_y2, coef_x, coef_y, constant):\n    \"\"\"\n    Convert a general form of a circle's equation into the standard form\n    (x-h)^2 + (y-k)^2 = r^2 using completing the square technique.\n    Parameters:\n    - coef_x2 (int or float): Coefficient of x^2 (should be 1 for circle)\n    - coef_xy (int or float): Coefficient of xy (should be 0 for circle)\n    - coef_y2 (int or float): Coefficient of y^2 (should be 1 for circle)\n    - coef_x (int or float): Coefficient of x\n    - coef_y (int or float): Coefficient of y\n    - constant (int or float): Constant term in the equation\n    Returns:\n    - sp.Expr: The equation of the circle in standard form.\n    - float: The center coordinates (h, k) of the circle.\n    - float: The radius (r) of the circle.\n    Examples:\n    >>> equation, center, radius = standardize_circle_equation(1, 0, 1, -6, -8, 9)\n    >>> equation\n    (x + 3)**2 + (y + 4)**2 = 16\n    >>> center\n    (-3, -4)\n    >>> radius\n    4\n    \"\"\"\n    x, y = sp.symbols('x y')\n    original_equation = coef_x2*x**2 + coef_y2*y**2 + coef_xy*x*y + coef_x*x + coef_y*y + constant\n    h = -coef_x / (2 * coef_x2)\n    k = -coef_y / (2 * coef_y2)\n    r_squared = -(constant - coef_x2*h**2 - coef_y2*k**2)\n    standard_form = (x-h)**2 + (y-k)**2 - r_squared\n    return standard_form.simplify(), (h, k), sp.sqrt(r_squared)"
        ],
        [
            "def convert_to_circle_form(A, B, C, D, E, F):\n    \"\"\"\n    Converts a general second-degree equation into a standard circle equation form.\n    \n    Parameters:\n    A, B, C, D, E, F (float|int): Coefficients of the equation Ax^2 + Bxy + Cy^2 + Dx + Ey + F = 0\n    \n    Returns:\n    str: A string representing the circle equation in standard form (x-h)^2 + (y-k)^2 = r^2\n    \n    Examples:\n    >>> convert_to_circle_form(1, 0, 1, -4, -6, 8)\n    '(x - 2.0)**2 + (y - 3.0)**2 = 1.0'\n    \n    Note:\n    This function assumes the equation can be reformed into a circle, which may not always be possible.\n    \"\"\"\n    x, y = symbols('x y', real=True)\n    \n    # The general second-degree equation form we will start with:\n    expr = A*x**2 + B*x*y + C*y**2 + D*x + E*y + F\n    \n    # Solving by completing the square:\n    # Complete the square for x\n    x_term = A*(x + D/(2*A))**2 - (D**2)/(4*A)\n    \n    # Complete the square for y\n    y_term = C*(y + E/(2*C))**2 - (E**2)/(4*C)\n    \n    # Combine terms and simplified equation\n    expression = x_term + y_term + F\n    \n    # Finally, we move constant terms to the right-hand side\n    equation = Eq(expression.subs({x: x, y: y}), 0)\n    circle_eq = solve(equation, y)\n    \n    # Extract the center coordinates (h, k) and radius r;\n    # Assuming h, k, r are derived from conditions on the resulting equation\n    h = -D / (2 * A)\n    k = -E / (2 * C)\n    radius_square = -(F - (D**2)/(4*A) - (E**2)/(4*C))\n    \n    if radius_square >= 0:\n        result = f'(x - {h})**2 + (y - {k})**2 = {radius_square}'\n    else:\n        result = 'No real circle form exists for the given coefficients.'\n        \n    return result",
            "def convert_to_circle_equation(A, B, C, D, E, F, x, y):\n    \"\"\"\n    Convert a general second-degree equation to a circle's standard form equation by completing the square.\n    Parameters:\n    - A, B, C, D, E, F (float): Coefficients of the general second-degree equation: \n      Ax^2 + Bxy + Cy^2 + Dx + Ey + F = 0\n    - x, y (sympy.Symbol): Symbolic representation of the variables.\n    Returns:\n    - sympy.Expr: A new expression representing the circle equation in standard form.\n    Examples:\n    >>> x, y = sp.symbols('x y')\n    >>> print(convert_to_circle_equation(1, 0, 1, -6, -8, 9, x, y))\n    (x - 3)**2 + (y - 4)**2 = 4\n    \"\"\"\n    if B != 0:\n        raise ValueError(\"The equation must not include a cross-term xy for this transformation.\")\n    # Complete the square for x and y terms\n    expr_x = A*x**2 + D*x\n    expr_y = C*y**2 + E*y\n    completed_x = factor_and_complete_square(expr_x, x)\n    completed_y = factor_and_complete Articlenonary\n    # Calculate the right side of the equation\n    rhs = -F + completed_x.subs(x, 0) + completed_y.subs(y, 0)\n    circle_eq = sp.Eq(completed_x + completed_y, rhs)\n    return sp.simplify(circle_eq)"
        ],
        [
            "def rationalize_decimal(decimal_number):\n    \"\"\"\n    Convert a decimal number to its simplest fractional form.\n    \n    Parameters:\n    - decimal_number : float\n        The decimal number to convert.\n    \n    Returns:\n    - str\n        The string representation of the number as a fraction.\n    \n    Example:\n    >>> rationalize_decimal(0.3333)\n    '1/3'\n    \"\"\"\n    return str(Fraction(decimal_number).limit_denominator())"
        ],
        [
            "def quadratic_to_vertex_form(coefficients):\n    \"\"\"\n    Wrapper for `complete_the_square` that accepts coefficients as list and handles floating points or fraction inputs.\n    \n    Parameters:\n    - coefficients (list): List of coefficients [a, b, c]\n    \n    Returns:\n    - tuple: Vertex form coefficients `(a, h, k)`\n    \n    Examples:\n    >>> quadratic_to_vertex_form([1, -4, 4])\n    (1, 2, 0)\n    \n    >>> quadratic_to_vertex_form([2, -8, 8])\n    (2, 2, -4)\n    \"\"\"\n    a, b, c = map(sp.Rational, coefficients)\n    return complete_the_square(a, b, c)"
        ]
    ],
    "Complex Numbers": [
        [
            "def complex_power(z, n):\n    \"\"\"\n    Raise a complex number to the power of n.\n    Parameters:\n        z (complex): The base complex number.\n        n (int): The exponent to which the base is raised.\n    Returns:\n        complex: The result of raising z to the power of n.\n    Examples:\n        >>> complex_power(1+2j, 3)\n        (-11+2j)\n    \"\"\"\n    return z ** n",
            "def complex_pow(z, n):\n    \"\"\"Raise a complex number to the power of n.\n    Parameters:\n        z (complex or sp.core.add.Add): A complex number.\n        n (int): The power to which the complex number is raised.\n    Returns:\n        sp.core.add.Add: Result of raising z to the power n.\n    \n    Example:\n        >>> complex_pow(sp.I, 4)\n        1\n    \"\"\"\n    return z**n"
        ],
        [
            "def complex_add(z1, z2):\n    \"\"\"\n    Add two complex numbers.\n    Parameters:\n        z1 (complex): The first complex number.\n        z2 (complex): The second complex number.\n    Returns:\n        complex: The sum of z1 and z2.\n    Examples:\n        >>> complex_add(1+2j, 3-4j)\n        (4-2j)\n    \"\"\"\n    return z1 + z2",
            "def complex_subtract(z1, z2):\n    \"\"\"\n    Subtract one complex number from another.\n    Parameters:\n        z1 (complex): The first complex number.\n        z2 (complex): The second complex number.\n    Returns:\n        complex: The result of z1 - z2.\n    Examples:\n        >>> complex_subtract(5+3j, 2+2j)\n        (3+1j)\n    \"\"\"\n    return z1 - z2",
            "def complex_multiply(z1, z2):\n    \"\"\"\n    Multiply two complex numbers.\n    Parameters:\n        z1 (complex): The first complex number.\n        z2 (complex): The second complex by which z1 is to be multiplied.\n    Returns:\n        complex: The product of z1 and z2.\n    Examples:\n        >>> complex_multiply(1+2j, 3+4j)\n        (-5+10j)\n    \"\"\"\n    return z1 * z2",
            "def complex_divide(z1, z2):\n    \"\"\"\n    Divide one complex number by another.\n    Parameters:\n        z1 (complex): The numerator complex number.\n        z2 (complex): The denominator complex number.\n    Returns:\n        complex: The quotient of z1 and z2.\n    Examples:\n        >>> complex_divideon(1+2j, 1-2j)\n        (0.2+0.6j)\n    \"\"\"\n    if z2 == 0:\n        raise ValueError(\"Cannot divide by zero complex number\")\n    return z1 / z2"
        ],
        [
            "def complex_operations(z1, z2, operation='add'):\n    \"\"\"\n    Perform basic arithmetic operations on two complex numbers.\n    Parameters:\n    z1 (complex): First complex number. Example: 3+5j\n    z2 (complex): Second complex number. Example: 4+4j\n    operation (str): Type of operation ('add', 'subtract', 'multiply', 'divide', 'conjugate', 'modulus', 'argument'). Default is 'add'.\n    \n    Returns:\n    complex or float: Result of the operation. Returns a complex number for arithmetic or a float for 'modulus', 'argument'.\n    \n    Example:\n    >>> complex_operations(3+5j, 4+4j, 'add')\n    (7+9j)\n    >>> complex_operations(3+5j, 4+4j, 'multiply')\n    (-8+32j)\n    >>> complex_operations(3+5j, operation='argument')\n    1.0303768265243125\n    \"\"\"\n    if operation == 'add':\n        return z1 + z2\n    elif operation == 'subtract':\n        return z1 - z2\n    elif operation == 'multiply':\n        return z1 * z2\n    elif operation == 'divide':\n        return z1 / z2\n    elif operation == 'conjugate':\n        return cmath.conjugate(z1)\n    elif operation == 'modulus':\n        return abs(z1)\n    elif operation == 'argument':\n        return cmath.phase(z1)\n    else:\n        raise ValueError(\"Unsupported operation supplied.\")",
            "def complex_operations(z1, z2=None, operation='add'):\n    \"\"\"\n    Perform various operations on complex numbers including addition, multiplication,\n    conjugation, and magnitude calculation.\n    Parameters:\n        z1 (complex): First complex number.\n        z2 (complex, optional): Second complex number. Default is None.\n        operation (str): Operation to perform - 'add', 'subtract', 'multiply',\n                         'divide', 'conjugate', 'magnitude', or 'exp_form'.\n                         Default is 'add'.\n    Returns:\n        complex or float: The result of the operation.\n    Examples:\n        >>> complex_operations(1+2j, 2+3j, 'add')\n        (3+5j)\n        >>> complex_operations(1+2j, operation='conjugate')\n        (1-2j)\n        >>> complex_operations(1+2j, operation='magnitude')\n        2.23606797749979\n        \n        >>> complex_operations(np.pi/4, operation='exp_form')\n        (0.7071067811865476+0.7071067811865475j)\n    \"\"\"\n    if operation == 'add':\n        return z1 + z2\n    elif operation == 'subtract':\n        return z1 - z2\n    elif operation == 'multiply':\n        return z1 * z2\n    elif operation == 'divide':\n        return z1 / z2 if z2 != 0 else None\n    elif operation == 'conjugate':\n        return np.conj(z1)\n    elif operation == 'magnitude':\n        return np.abs(z1)\n    elif operation == 'exp_form':\n        if isinstance(z1, (int, float)):\n            theta = z1  # Assuming z1 is an angle in radians\n            return np.exp(1j*theta)\n        else:\n            return np.exp(z1)\n    else:\n        raise ValueError(\"Unsupported operation. Choose from 'add', 'subtract', 'multiply', 'divide', 'conjugate', 'magnitude', or 'exp_form'.\")",
            "def complex_operations(a, b, operation='add'):\n    \"\"\"\n    Perform basic arithmetic operations on two complex numbers.\n    Parameters:\n    - a (complex): The first complex number.\n    - b (complex): The second complex number, which can also be used to represent scalars in some operations.\n    - operation (str): The operation to perform. Options: 'add', 'subtract', 'multiply', 'divide', 'power', 'conjugate'.\n    Returns:\n    - complex: The result of the operation on the two complex numbers.\n    Examples:\n    >>> complex_operations(1+2j, 1-2j, 'add')\n    (2+0j)\n    >>> complex_operations(1+2j, 2, 'multiply')\n    (2+4j)\n    >>> complex_operations(2+3j, 2, 'power')\n    (-5+12j)\n    >>> complex_operations(2+3j, 0, 'conjugate')\n    (2-3j)\n    \"\"\"\n    if operation == 'add':\n        return a + b\n    elif operation == 'subtract':\n        return a - b\n    elif operation == 'multiply':\n        return a * b\n    elif operation == 'divide':\n        return a / b\n    elif operation == 'power':\n        return a ** b\n    elif operation == 'conjugate':\n        return a.conjugate()\n    else:\n        raise ValueError(\"Unsupported operation.\")"
        ],
        [
            "def complex_add(z1, z2):\n    \"\"\"Perform addition of two complex numbers.\n    Parameters:\n        z1 (complex or sp.core.add.Add): First complex number, can be a native Python complex or a SymPy expression.\n        z2 (complex or sp.core.add.Add): Second complex number.\n    Returns:\n        sp.core.add.Add: Result of the addition as a symbolic expression.\n    \n    Example:\n        >>> complex_add(sp.I, 1 + 2 * sp.I)\n        1 + 3*I\n    \"\"\"\n    return z1 + z2",
            "def complex_mult(z1, z2):\n    \"\"\"Perform multiplication of two complex numbers.\n    Parameters:\n        z1 (complex or sp.core.add.Add): First complex number.\n        z2 (complex or sp.core.add.Add): Second complex number.\n    Returns:\n        sp.core.add.Add: Result of the multiplication.\n    \n    Example:\n        >>> complex_mult(1 + sp.I, 2 + 3 * sp.I)\n        -1 + 5*I\n    \"\"\"\n    return z1 * z2",
            "def complex_div(z1, z2):\n    \"\"\"Perform division of the first complex number by the second.\n    Parameters:\n        z1 (complex or sp.core.add.Add): Numerator complex number.\n        z2 (complex or sp.core.add.Add): Denominator complex number.\n    Returns:\n        sp.core.add.Add: Quotient of the division.\n    Example:\n        >>> complex_div(1 + 2*sp.I, 1 + sp.I)\n        1.5 + 0.5*I\n    \"\"\"\n    return z1 / z2"
        ],
        [
            "def complex_modulus(z):\n    \"\"\"\n    Calculate the modulus (absolute value) of a complex number.\n    Parameters:\n        z (complex): The complex number whose modulus is to be calculated.\n    Returns:\n        float: The modulus of the complex number.\n    Examples:\n        >>> complex_modulus(3+4j)\n        5.0\n    \"\"\"\n    return abs(z)",
            "def complex_modulus(z):\n    \"\"\"Compute the modulus (or absolute value) of a complex number.\n    Parameters:\n        z (complex or sp.core.add.Add): A complex number.\n    Returns:\n        sp.core.add.Add: Modulus of the complex number.\n    \n    Example:\n        >>> complex_modulus(3 + 4*sp.I)\n        5\n    \"\"\"\n    return sp.Abs(z)"
        ],
        [
            "def complex_parts(c):\n    \"\"\"\n    This function returns the real and imaginary parts of a complex number.\n    Parameters:\n    c (complex): a complex number of the form a + bi\n    Returns:\n    real_part (float): the real part of the complex number\n    imaginary_part (float): the imaginary part of the complex number\n    \"\"\"\n    real_part = c.real\n    imaginary_part = c.imag\n    return real_part, imaginary_part"
        ],
        [
            "def complex_from_polar(r, theta):\n    \"\"\"\n    Convert a polar coordinate (magnitude, angle) into a complex number.\n    Parameters:\n    - r (float): The magnitude of the complex number.\n    - theta (float): The angle in radians.\n    Returns:\n    - complex: The complex number in rectangular form.\n    Examples:\n    >>> complex_from_polar(1, np.pi / 4)\n    (0.7071067811865476+0.7071067811865475j)\n    \"\"\"\n    return cmath.rect(r, theta)"
        ],
        [
            "def complex_conjugate(c):\n    \"\"\"\n    This function calculates the conjugate of a complex number.\n    Parameters:\n    c (complex): a complex number of the form a + bi\n    Returns:\n    conjugate (complex): the conjugate of the complex number\n    \"\"\"\n    return c.conjugate()"
        ],
        [
            "def solve_polynomial(coefficients):\n    \"\"\"\n    Find the roots of a polynomial with given coefficients.\n    Parameters:\n    coefficients (list): Coefficients of the polynomial, highest degree first.\n    Returns:\n    array: Roots of the polynomial, which can be real or complex numbers.\n    \n    Example:\n    >>> solve_polynomial([1, 0, -1])\n    array([-1.,  1.])\n    \"\"\"\n    return np.roots(coefficients)",
            "def polynomial_roots(coefficients):\n    \"\"\"\n    Calculate the roots of a polynomial with given coefficients.\n    Parameters:\n    - coefficients (list of float or complex): The coefficients of the polynomial from highest to lowest degree,\n      e.g., [1, 0, -4] represents x^2 - 4.\n    Returns:\n    - list of complex: The roots of the polynomial.\n    \n    Examples:\n    >>> polynomial_roots([1, 0, -4])\n    [2.0, -2.0]\n    >>> polynomial_roots([1, -3, 2, 0])\n    [2.0, 1.0, 0.0]\n    \"\"\"\n    return np.roots(coefficients)"
        ],
        [
            "def complex_to_cartesian(z):\n    \"\"\"Converts a complex number from its polar form to cartesian coordinates.\n    Parameters:\n        z (sp.core.add.Add): A complex number in polar form.\n    Returns:\n        tuple: A tuple (re, im) representing real and imaginary parts.\n    \n    Example:\n        >>> complex_to_cartesian(sp.exp(sp.I*sp.pi/4))\n        (sqrt(2)/2, sqrt(2)/2)\n    \"\"\"\n    re, im = z.as_real_imag()\n    return (re, im)"
        ],
        [
            "def solve_complex_eq(eq):\n    \"\"\"\n    This function solves equations involving complex numbers.\n    Parameters:\n    eq (str): an equation involving complex numbers\n    Returns:\n    solution (complex): the solution(s) to the equation\n    \"\"\"\n    from sympy import symbols, Eq, solve, I\n    x = symbols('x')\n    eq = eq.replace('i', '*I')\n    solution = solve(Eq(eval(eq.split('=')[0]), eval(eq.split('=')[1])), x)\n    return solution"
        ],
        [
            "def expand_complex_expression(expr):\n    \"\"\"Expand a complex polynomial expression.\n    Parameters:\n        expr (sp.core.add.Add): A complex expression.\n    Returns:\n        sp.core.add.Add: Expanded expression.\n    \n    Example:\n        >>> expand_complex_expression((1 + sp.I)**3)\n        -2 + 2*I\n    \"\"\"\n    return sp.expand(expr)"
        ],
        [
            "def solve_complex_equation(equation, variable):\n    \"\"\"Solve an equation that involves complex numbers.\n    Parameters:\n        equation (sp.core.add.Add): The equation to be solved.\n        variable (sp.Symbol): The variable to solve for.\n    Returns:\n        list: Solutions to the equation.\n    \n    Example:\n        >>> z = sp.symbols('z', complex=True)\n        >>> solve_complex_equation(z**2 + 1, z)\n        [-I, I]\n    \"\"\"\n    return sp.solveset(equation, variable, domain=sp.S.Complexes)"
        ],
        [
            "def complex_conjugate(z):\n    \"\"\"Return the conjugate of a complex number.\n    Parameters:\n        z (complex or sp.core.add.Add): A complex number.\n    Returns:\n        sp.core.add.Add: Conjugate of the complex number.\n    \n    Example:\n        >>> complex_conjugate(1 + 2*sp.I)\n        1 - 2*I\n    \"\"\"\n    return sp.conjugate(z)"
        ],
        [
            "def simplify_complex(c):\n    \"\"\"\n    This function simplifies an expression involving complex numbers.\n    Parameters:\n    c (complex): a complex number of the form a + bi\n    Returns:\n    simplified (complex): the simplified form of the complex number\n    \"\"\"\n    from sympy import simplify, I\n    c = c.replace('i', '*I')\n    simplified = simplify(eval(c))\n    return simplified"
        ],
        [
            "def solve_quadratic_complex(a, b, c):\n    \"\"\"\n    Solve a quadratic equation of the form ax^2 + bx + c = 0 where coefficients can be complex.\n    Parameters:\n        a (complex): Coefficient of x^2.\n        b (complex): Coefficient of x.\n        c (complex): Constant term.\n    Returns:\n        tuple: A tuple of two complex numbers representing the roots.\n    Examples:\n        >>> solve_quadratic_complex(1, -3+4j, -6-8j)\n        ((6+2j), (-2+6j))\n    \"\"\"\n    if a == 0:\n        raise ValueError(\"Coefficient a must not be zero\")\n    d = cmath.sqrt(b ** 2 - 4 * a * c)\n    root1 = (-b + d) / (2 * a)\n    root2 = (-b - d) / (2 * a)\n    return (root1, root2)"
        ],
        [
            "def polynomial_roots_and_relations(coefficients, relationship='roots'):\n    \"\"\"\n    Calculate roots of a polynomial or relationships between roots based on coefficients\n    using Vieta's formulas.\n    Parameters:\n        coefficients (list): Coefficients of the polynomial, beginning from the highest degree.\n        relationship (str): Desired output 'roots', 'sum', 'product', or 'Vieta_relations'.\n                             Default is 'roots'.\n    Returns:\n        ndarray or tuple: Roots of the polynomial, or specific relationships between roots.\n    Examples:\n        >>> polynomial_roots_and_relations([1, 0, -4, 4], 'roots')\n        array([ 2., -2.,  1.])\n        >>> polynomial_roots_and_relations([1, 0, -4, 4], 'Vieta_relations')\n        (0, -4, 4)  # Sum, product by pairs, and overall product of roots\n    \"\"\"\n    p = np.poly1d(coefficients)\n    roots = p.r\n    if relationship == 'roots':\n        return roots\n    elif relationship == 'sum':\n        return np.sum(roots)\n    elif relationship == 'product':\n        return np.prod(roots)\n    elif relationship == 'Vieta_relations':\n        n = len(roots)\n        sums = [sum(np.prod(roots[list(inds)]) for inds in combinations(range(n), r)) for r in range(1, n+1)]\n        products = [sum(roots**i) for i in range(1, n+1)]\n        return sums, products\n    else:\n        raise ValueError(\"Unsupported relationship type. Choose 'roots', 'sum', 'product', or 'Vieta_relations'.\")"
        ],
        [
            "def roots_of_unity(n):\n    \"\"\"\n    Calculate the n-th roots of unity, e^(2*pi*i / n).\n   \n    Parameters:\n    n (int): The degree of the root of unity.\n    \n    Returns:\n    list: n complex numbers which are the n-th roots of unity.\n    \n    Example:\n    >>> roots_of_unity(3)\n    [(1+0j), (-0.5+0.8660254037844386j), (-0.5-0.8660254037844386j)]\n    \"\"\"\n    return [cmath.exp(2j * cmath.pi * k / n) for k in range(n)]"
        ],
        [
            "def complex_operations(c1, c2, operation):\n    \"\"\"\n    This function performs basic operations (addition, subtraction, multiplication and division) on complex numbers.\n    Parameters:\n    c1, c2 (complex): complex numbers\n    operation (str): the operation to be performed; can be 'add', 'subtract', 'multiply', or 'divide'\n    Returns:\n    result (complex): the result of the operation\n    \"\"\"\n    if operation == 'add':\n        result = c1 + c2\n    elif operation == 'subtract':\n        result = c1 - c2\n    elif operation == 'multiply':\n        result = c1 * c2\n    elif operation == 'divide':\n        if c2 != 0:\n            result = c1 / c2\n        else:\n            result = 'undefined'\n    else:\n        result = 'invalid operation'\n    \n    return result"
        ]
    ],
    "Polynomial Equations": [
        [
            "def evaluate_polynomial(expression, value):\n    \"\"\"\n    Substitutes a given value into the polynomial and evaluates it.\n    Parameters:\n    - expression (str or sympy Expression): The polynomial expression.\n    - value (float or int): The value to substitute into the polynomial.\n    Returns:\n    - sympy Expression: The result after evaluating the polynomial at the given value.\n    Examples:\n    >>> evaluate_polynomial(\"x**2 - 3*x + 2\", 2)\n    0\n    \"\"\"\n    x = symbols('x')\n    expr = sympify(expression)\n    return expr.subs(x, value)",
            "def evaluate_polynomial_at_value(poly_expr, variable, value):\n    \"\"\"\n    Evaluates a polynomial expression at a specific variable value.\n    Parameters:\n    - poly_expr (str): The polynomial expression as a string.\n    - variable (str): The variable in the polynomial expression.\n    - value (numeric): The value at which to evaluate the polynomial.\n    Returns:\n    - numeric: The result of the polynomial evaluated at the specified value.\n    \n    Examples:\n    >>> evaluate_polynomial_at_value(\"x**2 - 4*x + 4\", \"x\", 2)\n    0\n    \"\"\"\n    x = sp.symbols(variable)\n    expr = sp.sympify(poly_expr)\n    # Substitute the value into the polynomial\n    evaluated_expr = expr.subs(x, value)\n    return evaluated_expr.evalf()  # Ensure it returns a float or int."
        ],
        [
            "def factorize_polynomial(expression):\n    \"\"\"\n    Factorizes a polynomial and finds its roots.\n    Parameters:\n    - expression (str or sympy Expression): The polynomial as a string or a sympy expression.\n    Returns:\n    - tuple: (factored polynomial as sympy Expression, list of roots)\n    Examples:\n    >>> factorize_polynomial(\"x**2 - 5*x + 6\")\n    (x - 2)*(x - 3), [2, 3]\n    \"\"\"\n    x = symbols('x')\n    factored_expr = factor(expression)\n    roots = solve(expression, x)\n    return factored_expr, roots",
            "def factor_and_solve_polynomial(poly_expr, variable):\n    \"\"\"\n    Factorizes a polynomial and finds its roots.\n    Parameters:\n    - poly_expr (str): The polynomial expression as a string.\n    - variable (str): The variable in the polynomial expression.\n    Returns:\n    - tuple: A tuple containing the factored form of the polynomial and its roots.\n    \n    Examples:\n    >>> factor_and_solve_polynomial(\"x**2 - 4\", \"x\")\n    (x - 2)*(x + 2), [-2, 2]\n    \"\"\"\n    x = sp.symbols(variable)\n    # Parse the polynomial expression\n    expr = sp.sympify(poly_expr)\n    # Factor the expression\n    factored_expr = sp.factor(expr)\n    # Find roots\n    roots = sp.solveset(expr, x)\n    return factored_expr, list(roots)"
        ],
        [
            "def solve_polynomial(coefficients):\n    \"\"\"\n    Solves a polynomial equation using the given coefficients.\n    \n    Parameters:\n    - coefficients (list or array): Coefficients of the polynomial starting from the highest degree to the constant term.\n    \n    Returns:\n    - roots (array): Roots of the polynomial, including real and complex roots.\n    \n    Example:\n    >>> solve_polynomial([1, -3, 2])\n    array([2., 1.])\n    \"\"\"\n    return polyroots(coefficients)",
            "def solve_polynomial_equation(coefficients):\n    \"\"\"\n    Solves a polynomial equation given its coefficients.\n    \n    Parameters:\n        coefficients (list): List of coefficients from the highest degree term to the constant term.\n    \n    Returns:\n        roots (np.array): Array of roots (real and complex).\n        \n    Examples:\n        >>> solve_polysical_equation([1, 0, -4])\n        array([-2.,  2.])\n    \"\"\"\n    roots = np.roots(coefficients)\n    return roots",
            "def solve_polynomial(coeffs):\n    \"\"\"\n    Solve polynomial equations given the coefficients.\n    Parameters:\n    - coeffs (list): A list of coefficients from the highest degree term to the constant term.\n    Returns:\n    - tuple: Contains the roots of the polynomial equation.\n    Example:\n    >>> solve_polynomial([1, 0, -1])  # Solving x^2 - 1 = 0\n    (-1, 1)\n    \"\"\"\n    # Create the polynomial equation\n    x = sp.symbols('x')\n    polynomial = sum(coef * x ** i for i, coef in enumerate(reversed(coeffs)))\n    \n    # Solve the polynomial\n    roots = sp.solve(polynomial, x)\n    return tuple(roots)"
        ],
        [
            "def polynomial_coefficients_to_roots(coefficients):\n    \"\"\"\n    Given polynomial coefficients, returns the roots using Vieta's formulas.\n    \n    Parameters:\n        coefficients (list): List of coefficients, from highest degree to the coefficient of the free term.\n    \n    Returns:\n        roots (list): List of roots, can be real or complex numbers.\n        \n    Examples:\n        >>> polynomial_coefficients_to_roots([1, -3, 2])\n        [2, 1]\n    \"\"\"\n    x = sp.symbols('x')\n    polynomial = sum(c * x**i for i, c in enumerate(reversed(coefficients)))\n    roots = sp.solve(polynomial, x)\n    return roots",
            "def polynomial_roots_to_coefficients(roots):\n    \"\"\"\n    Given a set of polynomial roots, returns the polynomial coefficients using Vieta's formulas.\n    \n    Parameters:\n        roots (list): List of roots of the polynomial.\n    \n    Returns:\n        coefficients (list): List of coefficients derived from the roots.\n    \n    Examples:\n        >>> polynomial_roots_to_coefficients([2, 1])\n        [1, -3, 2]\n    \"\"\"\n    x = sp.symbols('x')\n    polynomial = sp.prod(x - r for r in roots)\n    return sp.Poly(polynomial, x).all_coeffs()"
        ],
        [
            "def polynomial_discriminant(coefficients):\n    \"\"\"\n    Calculates the discriminant of a polynomial given its coefficients.\n    \n    Parameters:\n        coefficients (list): Coefficients of the polynomial from highest degree to lowest.\n    \n    Returns:\n        discriminant (number): The discriminant of the polynomial.\n        \n    Examples:\n        >>> polynomial_discriminant([1, -5, 6])\n        1\n    \"\"\"\n    x = sp.symbols('x')\n    polynomial = sum(coef * x**idx for idx, coef in enumerate(reversed(coefficients)))\n    discriminant = sp.Discriminant(polynomial)\n    return discriminant"
        ],
        [
            "def factor_polynomial(coefficients):\n    \"\"\"\n    Factors a polynomial represented by given coefficients.\n    \n    Parameters:\n    - coefficients (list or array): Coefficients of the polynomial from the highest degree to the constant term.\n    \n    Returns:\n    - factorized_form (symbolic expression): Factorized form of the polynomial.\n    \n    Example:\n    >>> factor_polynomial([1, -3, 2, 0])\n    x*(x - 1)*(x - 2)\n    \"\"\"\n    x = symbols('x')\n    polynomial = sum(coef * x**i for i, coef in enumerate(reversed(coefficients)))\n    return factor(polynomial)",
            "def factorize_polynomial(coefficients):\n    \"\"\"\n    Factorizes a polynomial into irreducible factors over the real numbers.\n    \n    Parameters:\n        coefficients (list): List of coefficients from the highest degree term to the constant term.\n    \n    Returns:\n        factors (sp.Mul): Factored form of the polynomial.\n        \n    Examples:\n        >>> factorize_polynomial([1, -3, 2])\n        (x - 2)*(x - 1)\n    \"\"\"\n    x = sp.symbols('x')\n    polynomial = sum(c * x**i for i, c in enumerate(reversed(coefficients)))\n    factors = sp.factor(polynomial)\n    return factors",
            "def factorize_polynomial(coeffs):\n    \"\"\"\n    Factorizes a polynomial into its irreducible factors.\n    Parameters:\n    - coeffs (list): A list of coefficients from the highest degree term to the constant term.\n    Returns:\n    - sp.Expr: A factorized form of the polynomial.\n    Example:\n    >>> factorize_polynomial([1, 0, -1])  # for x^2 - 1 = 0\n    (x - 1)*(x + 1)\n    \"\"\"\n    x = sp.symbols('x')\n    polynomial = sum(coef * x ** i for i, coef in enumerate(reversed(coeffs)))\n    \n    # Factorize the polynomial\n    factorized = sp.factor(polynomial)\n    return factorized"
        ],
        [
            "def vietas_formulas(coefficients):\n    \"\"\"\n    Compute sums and products of the roots of the polynomial via Vieta's formulas based on coefficients.\n    \n    Parameters:\n    - coefficients (list or array): Coefficients of the polynomial starting from the highest degree to the constant term.\n    \n    Returns:\n    - sums_products (dict): Dictionary representing the sum and product of roots up to the degree of polynomial.\n    \n    Example:\n    >>> vietas_formulas([1, -3, 2])\n    {'sum': 3, 'product': 2}\n    \"\"\"\n    degree = len(coefficients) - 1\n    roots = solve_polynomial(coefficients)\n    sum_roots = -coefficients[1] / coefficients[0] if degree >= 1 else 0\n    product_roots = (-1)**degree * coefficients[-1] / coefficients[0] if coefficients[0] != 0 else 0\n    return {'sum': sum_roots, 'product': product_roots}",
            "def vietas_formulas(coeffs):\n    \"\"\"\n    Calculate the sum and product of the roots of a polynomial based on Vieta's formulas.\n    Parameters:\n    - coeffs (list): A list of coefficients from the highest degree term to the constant term.\n    Returns:\n    - dict: A dictionary containing sums and products of roots for each power.\n    Example:\n    >>> vietas_formulas([1, -3, 2])  # for x^2 - 3x + 2 = 0\n    {'sum_of_roots': 3, 'product_of_roots': 2}\n    \"\"\"\n    n = len(coeffs) - 1  # Degree of the polynomial\n    x = sp.symbols('x')\n    polynomial = sum(coef * x ** i for i, coef in enumerate(reversed(coeffs)))\n    roots = sp.solve(polynomial, x)\n    \n    results = {\n        'sum_of_roots': sum(roots),\n        'product_of_roots': sp.prod(roots)\n    }\n    return results"
        ],
        [
            "def generate_polynomial_from_roots(roots, leading_coeff=1):\n    \"\"\"\n    Generate a polynomial from given roots.\n    Parameters:\n    - roots (list): A list of roots.\n    - leading_coeff (int, optional): The leading coefficient. Default is 1.\n    Returns:\n    - sp.Poly: The polynomial created from the roots.\n    Example:\n    >>> generate_polynomial_from_roots([1, -1])\n    x**2 - 1\n    \"\"\"\n    x = sp.symbols('x')\n    polynomial = sp.prod((x - root) for root in roots) * leading_coeff\n    return sp.Poly(polynomial, x)"
        ],
        [
            "def expand_and_simplify_polynomial(poly_expr):\n    \"\"\"\n    Expands and simplifies a given polynomial expression.\n    Parameters:\n    - poly_expr (str): The polynomial expression as a string.\n    Returns:\n    - sympy expression: The expanded and simplified form of the input polynomial.\n    \n    Examples:\n    >>> expand_and_simplify_polynomial(\"(x-1)*(x+2)\")\n    x**2 + x - 2\n    \"\"\"\n    expr = sp.sympify(poly_expr)\n    # Expand and simplify the polynomial\n    simplified_expr = sp.simplify(sp.expand(expr))\n    return simplified_expr"
        ],
        [
            "def polynomial_operations(expression, operation_type, **kwargs):\n    \"\"\"\n    Handles various polynomial operations including expansion, factorization, solving equations, \n    finding roots, and simplifying expressions.\n    \n    Parameters:\n        expression (str): The polynomial expression as a string.\n        operation_type (str): The type of operation to perform ('expand', 'factor', 'solve', 'roots', 'simplify').\n        kwargs:\n            - var (str, optional): Variable to consider if expression is univariate. Required for solving.\n            - value (dict, optional): Values to substitute in the polynomial.\n    \n    Returns:\n        Various: Depending on the operation, can return expanded form, factors, solutions, roots or simplified form.\n    \n    Example:\n        >>> polynomial_operations(\"x**2 + 2*x + 1\", 'factor')\n        (x + 1)**2\n        >>> polynomial_operations(\"x**2 - 1\", 'roots')\n        {1: 1, -1: 1}\n        >>> polynomial_operations(\"x**2 - 3*x + 2 == 0\", 'solve', var='x')\n        [1, 2]\n    \"\"\"\n    x = symbols(kwargs.get('var', 'x'))\n    expr = simplify(expression) if '==' not in expression else simplify(expression.split('==')[0]) - simplify(expression.split('==')[1])\n    if kwargs.get('value'):\n        expr = expr.subs(kwargs['value'])\n    if operation_type == 'expand':\n        return expand(expr)\n    elif operation_type == 'factor':\n        return factor(expr)\n    elif operation_type == 'solve':\n        return solve(expr, x)\n    elif operation_type == 'roots':\n        return roots(expr)\n    elif operation_type == 'simplify':\n        return simplify(expr)\n    else:\n        raise ValueError(\"Invalid operation type provided.\")"
        ],
        [
            "def simplify_expression(expression):\n    \"\"\"\n    Simplifies a given algebraic expression or polynomial.\n    \n    Parameters:\n    - expression (str or symbolic expression): The expression to be simplified.\n    \n    Returns:\n    - simplified_form (symbolic expression): Simplified form of the input expression.\n    \n    Example:\n    >>> simplify_expression(\"x**2 - 2*x + 1\")\n    (x - 1)**2\n    \"\"\"\n    return simplify(sympify(expression))"
        ],
        [
            "def solve_polynomial_system(equations, variables):\n    \"\"\"\n    Solves a system of polynomial equations.\n    Parameters:\n        equations (list): A list of strings, where each string is a polynomial equation.\n        variables (list): A list of string variable names used in the equations.\n    \n    Returns:\n        dict: A dictionary of solutions where keys are variables and values are their solutions.\n    \n    Example:\n        >>> solve_polynomial_system([\"x**2 + y**2 - 4\", \"x - y - 1\"], ['x', 'y'])\n        {x: 1 + y, y: y}\n    \"\"\"\n    sym_vars = symbols(variables)\n    eqs = [Eq(simplify(eq.split('==')[0]) - simplify(eq.split('==')[1]), 0) if '==' in eq else Eq(simplify(eq), 0) for eq in equations]\n    sol = solve(eqs, sym_vars, dict=True)\n    return sol"
        ],
        [
            "def expand_polynomial(expression):\n    \"\"\"\n    Expands a polynomial using algebraic identities.\n    \n    Parameters:\n    - expression (str or sympy Expression): The algebraic expression in string format that needs expanding.\n    Returns:\n    - sympy Expression: The expanded form of the given polynomial.\n    Examples:\n    >>> expand_polynomial(\"x*(x + 1)*(x - 1)\")\n    x**3 - x\n    \"\"\"\n    x = symbols('x')\n    return expand(expression)"
        ],
        [
            "def derive_polynomial_from_roots(roots):\n    \"\"\"\n    Forms a polynomial equation given the roots.\n    \n    Parameters:\n    - roots (list of numbers): The roots of the polynomial.\n    Returns:\n    - sympy Expression: The polynomial having the given roots.\n    Examples:\n    >>> derive_polynomial_from_roots([1, 2, 3])\n    x**3 - 6*x**2 + 11*x - 6\n    \"\"\"\n    x = symbols('x')\n    prod_expr = 1\n    for root in roots:\n        prod_expr *= (x - root)\n    return expand(prod_expr)"
        ]
    ],
    "Summation": [
        [
            "def symbolic_sum(expr, var, start, end):\n    \"\"\"\n    Compute the symbolic summation of a mathematical expression from start to end.\n    Parameters:\n    expr (sympy expression): The mathematical expression to be summed, involving var.\n    var (sympy.Symbol): The symbolic variable in the expression.\n    start (int): The starting value of the summation index.\n    end (int): The ending value of the summation index.\n    Returns:\n    sympy expression: The symbolically computed sum of the expression from start to end.\n    Examples:\n    >>> x = sp.Symbol('x')\n    >>> expr = sp.sin(x)\n    >>> symbolic_sum(expr, x, 1, 10) # Sum of sin(x) from x=1 to 10\n    Sum(sin(x), (x, 1, 10))\n    >>> expr = x**2\n    >>> symbolic_sum(expr, x, 1, 5) # Sum of x^2 from x=1 to 5\n    55\n    \"\"\"\n    return sp.summation(expr, (var, start, end))",
            "def algebraic_sum(expression, variable, start, end):\n    \"\"\"\n    Computes the sum of a given algebraic expression from a specified start to end values for a given variable.\n    Parameters:\n    - expression (str): The algebraic expression to sum, in terms of the variable.\n    - variable (str): The variable in the expression.\n    - start (int): The starting value of the summation index.\n    - end (int): The ending value of the summation index.\n    Returns:\n    - sum_result: The computed sum of the expression from `start` to `end` using sympy.\n    Examples:\n    --------\n    >>> algebraic_sum('1/n', 'n', 1, 4)\n    25/12\n    >>> algebraic_sum('1/(n**2)', 'n', 1, 3)\n    49/36\n    \"\"\"\n    sym_var = sp.symbols(variable)\n    expr = sp.sympify(expression)\n    sum_expr = sp.Sum(expr, (sym_var, start, end))\n    return sum_expr.doit()",
            "def symbolic_sum_with_constants(expression, variable, start, end):\n    \"\"\"\n    Computes the sum of an algebraic expression involving symbolic constants like , over a specified index range.\n    Parameters:\n    - expression (str): The algebraic expression to sum which may include constants like .\n    - variable (str): The variable in the expression.\n    - start (int): The starting value of the summation index.\n    - end (int): The ending value of the subprocess.\n    Returns:\n    - sum_result: The computed sum of the expression from `start` to `end`.\n    Examples:\n    --------\n    >>> symbolic_sum_with_constants('1/(n*pi)', 'n', 1, 5)\n    0.382048379547716\n    >>> symbolic_sum_with_xml_constants('pi/n', 'n', 1, 3)\n    3.28986813369645\n    \"\"\"\n    sym_var = sp.symbols(variable)\n    expr = sp.sympify(expression)\n    # Replacing  with sympy's pi constant safely\n    expr = expr.subs({'pi': sp.pi, 'Pi': sp.pi})\n    \n    sum_expr = sp.Sum(expr, (sym\"];\n    return sum_expr.doit().evalf()",
            "def evaluate_sum(expression, variable, start, end):\n    \"\"\"\n    Evaluate the summation of a mathematical expression over a specified range.\n    Parameters:\n        expression (str or sympy.Expr): The expression to sum, given as a string or sympy expression.\n        variable (sympy.Symbol): The variable used in the summation.\n        start (int): The starting index of the summation.\n        end (int or sympy.oo): The ending index of the summation (can be sympy.oo for infinity).\n    Returns:\n        sympy.Expr: The evaluated sum of the series.\n    Example:\n        >>> x = sp.symbols('x')\n        >>> evaluate_sum('x**2', x, 1, 5)\n        55\n        >>> evaluate_sum('1/x', x, 1, sp.oo)\n        zoo (sympy's representation of infinity or an undefined number)\n    \"\"\"\n    expr = sp.sympify(expression)\n    if end == 'oo':  # Handling infinite series explicitly if needed\n        end = sp.oo\n    return sp.summation(expr, (variable, start, end))",
            "def simplify_and_evaluate_sum(expression, variable, start, end):\n    \"\"\"\n    Simplify and evaluate a summation using algebraic identities, useful for complex expressions or series.\n    Parameters:\n        expression (str): The expression to sum.\n        variable (sympy.Symbol): The variable in the series.\n        start (int): Initial value of the summation variable.\n        end (int or str): Ending value of the summation variable, 'oo' for infinity.\n    Returns:\n        sympy.Expr: The result of the evaluated and simplified series.\n    Example:\n        >>> x = sp.symbols('x')\n        >>> simplify_and_evaluate_sum('x*(x+1)/2', x, 1, 10)\n        220\n        >>> simplify_and_evaluate_sum('1/x**2', x, 1, 'oo')\n        pi**2/6\n    \"\"\"\n    expr = sp.sympify(expression)\n    if end == 'oo':\n        end = sp.oo\n    sum_expr = sp.Sum(expr, (variable, start, end)).doit()\n    return sp.simplify(sum_expr)",
            "def general_summation(expr, var, start, end):\n    \"\"\"\n    Calculate the sum of an arbitrary expression over a specified range.\n    Parameters:\n    - expr (sympy expression): The mathematical expression to sum, which might include variables, numbers, and functions.\n    - var (sympy Symbol): The variable used in the expression over which the summation is performed.\n    - start (int): The starting value of the summation range.\n    - end (int): The ending value of the summation range (inclusive).\n    Returns:\n    - sum_expr (sympy expression or float): The summed value of the expression over the given range.\n    Examples:\n    >>> x = sp.symbols('x')\n    >>> general_summation(sp.sin(x), x, 0, 3)\n    sin(0) + sin(1) + sin(2) + sin(3)\n    >>> general_summation(x**2, x, 1, 5)\n    55\n    >>> general_summation(sp.cos(x), x, 0, 4)\n    cos(0) + cos(1) + cos(2) + cos(3) + cos(4)\n    \"\"\"\n    sum_expr = sp.summation(expr, (var, start, end))\n    return sum_expr"
        ],
        [
            "def calculate_summation(term_function, start, end=None):\n    \"\"\"\n    Calculate the summation of a series defined by a term function from a start index to an end index.\n    If `end` is None, attempts to calculate an infinite series sum.\n    Parameters:\n    - term_function (function): A function that takes an integer index and returns the term at that index.\n    - start (int): The start index of the summation.\n    - end (optional, int): The end index of the summation. If None, calculate for an infinite series.\n    Returns:\n    - The summation as a symbolic expression if successful, None if the infinite series does not converge.\n    Examples:\n    >>> from sympy import symbols, Rational\n    >>> x = symbols('x')\n    >>> calculate_summation(lambda n: x**n, 0, 10)  # Sum x^n from n=0 to 10\n    x**11/(-x + 1) - 1/(-x + 1)\n    >>> calculate_summation(lambda n: 1/n**2, 1, None)  # Sum 1/n^2 from n=1 to infinity\n    pi**2/6\n    \"\"\"\n    import sympy as sp\n    \n    if end is None:\n        # Infinite series\n        n = sp.symbols('n', integer=True)\n        term = term_function(n)\n        return sp.summation(term, (n, start, sp.oo))\n    else:\n        # Finite series\n        n = sp.symbols('n', integer=True)\n        term = term_function(n)\n        return sp.summation(term, (n, start, end))",
            "def sum_series(function_of_n, start, end):\n    \"\"\"\n    General function to calculate the symbolic sum of a sequence defined by a function over a specified range.\n    Parameters:\n        function_of_n (lambda or sympy expression): Mathematical function of 'n', the variable to sum over.\n        start (int): Starting value of the summation index.\n        end (int or sp.oo): Ending value of the summation index (inclusive). Use sp.oo for infinity.\n    \n    Returns:\n        Summation result as a symbolic expression or a numerical value if end is finite.\n    Examples:\n        >>> sum_series(lambda n: n**2, 1, 5)\n        55\n        >>> sum_series(sp.symbols('n')**2, 1, 10)\n        385\n    \"\"\"\n    n = sp.symbols('n')\n    if callable(function_of_n):\n        function = function_of_n(n)\n    else:\n        function = function_of_n\n    return sp.summation(function, (n, start, end))"
        ],
        [
            "def sum_of_first_n_natural_numbers(n):\n    \"\"\"\n    Calculates the sum of the first n natural numbers using the formula S = n * (n + 1) / 2.\n    Parameters:\n        n (int): The number of natural numbers to sum. Should be a non-negative integer.\n    \n    Returns:\n        int: The sum of the first n natural numbers.\n    Example:\n    >>> sum_of_first_n_natural_uid_numbers(10)\n    55\n    \"\"\"\n    return n * (n + 1) // 2",
            "def natural_numbers_sum(n):\n    \"\"\"\n    Calculate the sum of the first n natural numbers.\n    \n    Parameters:\n    - n (int): The number of natural numbers to sum up.\n    \n    Returns:\n    - int: The sum of the first n natural numbers.\n    Example:\n    >>> natural_numbers_sum(10)\n    55\n    >>> natural_numbers_sum(100)\n    5050\n    \"\"\"\n    # Utilize the derived formula which is a specific case of arithmetic sum with a1=1, d=1\n    return arithmetic_series_sum(1, 1, n)",
            "def sum_n_natural_numbers(n):\n    \"\"\"\n    Calculates the sum of the first n natural numbers, which is a specialized case of an arithmetic sequence where each number increments by 1.\n    \n    Parameters:\n    - n (int): The number of terms in the sequence to sum up.\n    \n    Returns:\n    - int: The sum of the first n natural numbers.\n    \n    Example:\n    >>> sum_n_natural_numbers(100)\n    5050\n    \"\"\"\n    # Sum of first n natural numbers formula: n * (n + 1) / 2\n    return n * (n + 1) / 2"
        ],
        [
            "def sum_of_arithmetic_sequence(a, d, n):\n    \"\"\"\n    Calculates the sum of the first n terms of an arithmetic sequence using the formula S_n = n/2 * (2a + (n-1) * d).\n    Parameters:\n        a (numeric): The first term of the arithmetic sequence.\n        d (numeric): The common difference between consecutive terms of the arithmetic sequence.\n        n (int): The number of terms in the sequence to sum. Should be a non-negative integer.\n    Returns:\n        numeric: The sum of the first n terms of the arithmetic sequence.\n    Example:\n    >>> sum_of_arithmetic_sequence(1, 1, 10)\n    55\n    >>> sum_of_arithmetic_sequence(3, 2, 5)\n    35\n    \"\"\"\n    return n / 2 * (2 * a + (n - 1) * d)",
            "def arithmetic_series_sum(a1, d, n):\n    \"\"\"\n    Calculate the sum of the first n terms of an arithmetic series.\n    \n    Parameters:\n    - a1 (int/float/sympy.Symbol): The first term of the arithmetic sequence.\n    - d (int/float/sympy.Symbol): The common difference of the series.\n    - n (int/sympy.Symbol): The number of terms to sum.\n    \n    Returns:\n    - sympy.Expr: The symbolic or numeric sum of the first n terms of the sequence.\n    Example:\n    >>> arithmetic_series_sum(1, 1, 10)  # Sum of the first 10 natural numbers\n    55\n    >>> a, d, n = sp.symbols('a d n')\n    >>> arithmetic_series_sum(a, d, n)  # Symbolic representation\n    n*(2*a + (n - 1)*d)/2\n    \"\"\"\n    # Formula for sum of an arithmetic series: n/2 * (2a1 + (n-1)d)\n    return n/2 * (2*a1 + (n-1)*d)"
        ],
        [
            "def sum_of_expressions(expressions):\n    \"\"\"\n    Sum a list of algebraic expressions.\n    Parameters:\n    expressions (list of sympy.Expr): A list of sympy expression objects.\n    \n    Returns:\n    sympy.Expr: The summed expression.\n    Examples:\n    >>> expr1 = sp.sympify(\"1/2 * x + 3\")\n    >>> expr2 = sp.sympify(\"2/3 * pi * x**2\")\n    >>> sum_of_expressions([expr1, expr2])\n    2/3*pi*x**2 + 1/2*x + 3\n    \"\"\"\n    return sum(expressions, sp.sympify(0))"
        ],
        [
            "def geometric_sum(a, r, n):\n    \"\"\"\n    Calculate the sum of a geometric series.\n    Parameters:\n        a (float or int): The first term of the geometric series.\n        r (float or int): The common ratio of the series.\n        n (int): The number of terms in the series.\n    \n    Returns:\n        float: The sum of the first n terms of the geometric series.\n    Examples:\n        >>> geometric_sum(1, 2, 4)  # Sum of 1, 2, 4, 8\n        15.0\n        \n        >>> geometric_sum(3, 3, 3)  # Sum of 3, 9, 27\n        39.0\n    \"\"\"\n    return a * (1 - r ** (n + 1)) // (1 - r)",
            "def sum_of_geometric_series(a, r, n):\n    \"\"\"\n    Calculate the sum of the first n terms of a geometric series.\n    Parameters:\n    a (float): The first term of the series.\n    r (float): The common ratio of the series.\n    n (int): The number of terms to sum.\n    Returns:\n    float: The sum of the first n terms.\n    \n    Examples:\n    >>> sum_of_geometric_series(1, 2, 4)\n    15.0\n    \"\"\"\n    if r == 1:\n        return a * n\n    else:\n        return a * (1 - r**n) / (1 - r)",
            "def geometric_sum(a, r, n):\n    \"\"\"\n    Calculates the sum of the first n terms of a geometric series a * r^k for k from 0 to n-1.\n    Parameters:\n        a (numeric): First term of the geometric series.\n        r (numeric): Common ratio of the series.\n        n (int): Number of terms to sum.\n    Returns:\n        numeric: Sum of the first n terms of the geometric series.\n    Examples:\n        >>> geometric_sum(1, 2, 3)\n        7  # because 1 + 2 + 4 = 7\n    \"\"\"\n    if r == 1:\n        return a * n\n    else:\n        return a * (1 - r ** n) / (1 - r)"
        ],
        [
            "def sum_algebraic_expressions(expr1, expr2):\n    \"\"\"\n    Takes two algebraic expressions, potentially involving fractions, and returns their sum in the simplest form.\n    \n    Parameters:\n    expr1 (str or sympy expression): The first algebraic expression to sum.\n    expr2 (str or sympy expression): The second algebraic expression to sum.\n    \n    Returns:\n    sympy expression: The simplified sum of the two expressions.\n    Examples:\n    >>> sum_algebraic_expressions(\"1/2 * x\", \"3/4 * y\")\n    1/2*x + 3/4*y\n    \n    >>> sum_algebraic_expressions(\"1/3 + 2/3\", \"1/2\")\n    3/2\n    >>> sum_algebraic_expressions(\"pi/4\", \"1/4\")\n    pi/4 + 1/4\n    \"\"\"\n    # Ensure the input expressions are in sympy format\n    expr1 = sympify(expr1)\n    expr2 = sympify(expr2)\n    \n    # Sum the expressions\n    sum_expr = expr1 + expr2\n    \n    # Simplify the result\n    simplified_sum = sum_expr.simplify()\n    \n    return simplified_sum",
            "def sum_expressions_with_pi(expr1, expr2):\n    \"\"\"\n    Sum two algebraic expressions which may include the mathematical constant .\n    \n    Parameters:\n    expr1 (str or sympy expression): The first expression involving .\n    expr2 (str or sympy expression): The second expression involving .\n    \n    Returns:\n    sympy expression: The sum of the two expressions, simplified if possible.\n    Examples:\n    >>> sum_expressions_with_pi(\"pi/4\", \"pi/2\")\n    3*pi/4\n    \n    >>> sum_expressions_with_pi(\"pi/3\", \"1/3\")\n    pi/3 + 1/3\n    \n    >>> sum_expressions_with_pi(\"2*pi\", \"3\")\n    2*pi + 3\n    \"\"\"\n    # Ensure input expressions use sympy's pi and are in sympy format\n    expr1 = sympify(expr1.replace('pi', 'pi'))\n    expr2 = sympify(expr2.replace('pi', 'pi'))\n    \n    # Compute sum of expressions\n    sum_expr = expr1 + expr2\n    \n    # Simplify the result\n    simplified_sum = sum_expr.simplify()\n    \n    return simplified_sum"
        ],
        [
            "def evaluate_expression_at_points(expression, points):\n    \"\"\"\n    Evaluates an algebraic expression at specified points.\n    Parameters:\n    expression (sympy.Expr): A sympy expression object.\n    points (list): A list of values at which to evaluate the expression.\n    \n    Returns:\n    list: A list of results from evaluating the expression at each point.\n    Examples:\n    >>> expression = sp.sympify(\"x**2 + 3*x + 1\")\n    >>> points = [1, 2, 3]\n    >>> evaluate_expression_at_points(expression, points)\n    [5, 11, 19]\n    \"\"\"\n    x = sp.symbols('x')\n    return [expression.subs(x, point).evalf() for point in points]"
        ],
        [
            "def evaluate_infinite_series(term_function, symbol):\n    \"\"\"\n    Evaluate the sum of an infinite series given a term function and the variable used in the function.\n    Parameters:\n        term_function (sp.Expr): A symbolic expression representing the term of the series which involves the symbol.\n        symbol (sp.Symbol): The symbol used in the term function, typically sp.Symbol('n') or similar.\n    \n    Returns:\n        sp.Expr: The symbolic expression representing the sum of the series, if it converges.\n    \n    Examples:\n        # Sum of an infinite geometric series 1/2^n from n=0 to infinity\n        >>> n = sp.Symbol('n')\n        >>> evaluate_infinite_series(1/2**n, n)\n        2\n    \"\"\"\n    return sp.summation(term_hand(d_cursor), (symbol, 0, sp.oo))"
        ],
        [
            "def sum_of_squares(start, end):\n    \"\"\"\n    Calculates the sum of squares from 'start' to 'end'.\n    Parameters:\n        start (int): The starting integer.\n        end (int): The ending integer (inclusive).\n    Returns:\n        int: Sum of the squares from start to end.\n    Examples:\n        >>> sum_of_squares(1, 3)\n        14  # because 1^2 + 2^2 + 3^2 = 1 + 4 + 9 = 14\n    \"\"\"\n    return sum(n ** 2 for n in range(start, end + 1))"
        ],
        [
            "def simplify_trigonometric_expression(expression):\n    \"\"\"\n    Simplifies a trigonometric expression using sympy.\n    Parameters:\n        expression (str): The trigonometric expression to simplify.\n    Returns:\n        str: A simplified version of the input expression.\n    Example:\n        >>> simplify_trigonometric_expression(\"sin(x)**2 + cos(x)**2\")\n        '1'\n        >>> simplify_trigonometric_expression(\"sin(x) + sin(x)\")\n        '2*sin(x)'\n    \"\"\"\n    # Parse the expression\n    expr = sp.sympify(expression)\n    # Simplify the expression\n    simplified_expr = sp.simplify(expr)\n    return str(simplified_expr)"
        ],
        [
            "def pairing_sum(sequence):\n    \"\"\"\n    Calculate the sum of elements by pairing them (used in binary operations).\n    Parameters:\n    sequence (list of float/int): The elements to be summed.\n    Returns:\n    float/int: The sum of the elements.\n    \n    Examples:\n    >>> pairing_sum([1, 2, 3, 4])\n    10\n    >>> pairing_sum([1, 2, 4, 8, 16])\n    31\n    \"\"\"\n    return sum(sequence)"
        ],
        [
            "def special_distributive_sum(terms, factor=1):\n    \"\"\"\n    Applies distributive property over addition and returns the sum multiplied by an optional factor.\n    Parameters:\n    terms (list): Numeric terms of the sum.\n    factor (int/float): Multiplicative factor to be applied to the whole sum.\n    Returns:\n    float: Resulting sum after applying the distributive property.\n    \n    Examples:\n    >>> special_distributive_sum([1, 2, 3], 2)\n    12\n    \"\"\"\n    return sum(terms) * factor"
        ],
        [
            "def numeric_sum(function, start, end):\n    \"\"\"\n    Compute the numeric summation for a function from start to end using Numpy.\n    \n    Parameters:\n    function (callable): A Python function that takes a single argument and returns a numerical result.\n    start (int): The starting value of the summation index.\n    end (int): The ending value of the summation index.\n    Returns:\n    float: The computed numerical sum of the function applied from start to end.\n    Examples:\n    >>> import numpy as np\n    >>> numeric_sum(np.sin, 1, 10) # Numeric sum of sin(x) from x=1 to 10\n    \"\"\"\n    index_values = np.arange(start, end + 1)\n    values = function(index_values)\n    return np.sum(values)"
        ],
        [
            "def finite_summation(sequence_function, lower_bound, upper_bound):\n    \"\"\"\n    Calculate the finite sum of a given sequence from a specified lower bound to an upper bound.\n    Parameters:\n        sequence_function (function): A callable that computes the terms of the sequence.\n                                      It should accept an integer and return the sequence element.\n        lower_bound (int): The starting index of the summation.\n        upper_bound (int): The ending index of the summation.\n    \n    Returns:\n        float: The sum of the sequence elements from lower bound to upper bound.\n    \n    Examples:\n        # Sum of the first 10 natural numbers\n        >>> finite_summation(lambda x: x, 1, 10)\n        55.0\n        # Sum of the first 10 squares\n        >>> finite_summation(lambda x: x**2, 1, 10)\n        385.0\n    \"\"\"\n    return np.sum([sequence_function(x) for x in range(lower_bound, upper_bound + 1)])"
        ],
        [
            "def polynomial_sum(n, k, expr):\n    \"\"\"\n    Calculate the summation of a polynomial expression from 1 to n.\n    Parameters:\n        n (int or sp.Symbol): The upper limit of the summation (inclusive).\n        k (sp.Symbol): The symbol used in the polynomial expression.\n        expr (sp.Expr): The polynomial expression involving k.\n    Returns:\n        sp.Expr: The symbolic expression of the sum for the polynomial.\n    Examples:\n        >>> k = sp.symbols('k')\n        >>> polynomial_sum(100, k, k**2)  # Sum of squares from 1 to 100\n        338350\n  \n        >>> polynomial_sum(10, k, k)  # Sum of first 10 natural numbers\n        55\n        >>> polynomial_sum(5, k, 3*k + 1)  # Sum of 3*k + 1 from 1 to 5\n        40\n    \"\"\"\n    return sum(expr.subs(k, i) for i in range(1, n+1))"
        ],
        [
            "def simplify_and_evaluate_series(expression):\n    \"\"\"\n    Simplify and potentially evaluate a series expression.\n    Parameters:\n    - expression (sympy.Expr): A sympy expression representing a series.\n    Returns:\n    - A simplified version of the series expression or its evaluated sum if possible.\n    Examples:\n    >>> from sympy import symbols, simplify\n    >>> x = symbols('x')\n    >>> series_expr = (1 - x)**2 / (1 - x)\n    >>> simplify_and_evaluate_series(series_expr)\n    1 - x\n    \n    >>> series_expr = sum(x**n for n in range(11))  # x^n from n=0 to 10\n    >>> simplify_and_evaluate_series(series_expr)\n    x**11/(-x + 1) - 1/(-x + 1)\n    \"\"\"\n    import sympy as sp\n    simplified_expr = sp.simplify(expression)\n    return simplified_expr"
        ],
        [
            "def binary_pairing_sum(n):\n    \"\"\"\n    Calculates the sum of the first n terms of the series defined by 2^k where k belongs to integers and k < log2(n).\n    Parameters:\n        n (int): The number till which powers of 2 are considered (exclusive).\n    Returns:\n        int: Sum of terms 2^k for k in 0 to floor(log2(n-1)).\n    Examples:\n        >>> binary_pairing_sum(8) \n        15  # because 1 + 2 + 4 + 8 = 15\n    \"\"\"\n    k = 0\n    summation = 0\n    while (1 << k) < n:\n        summation += (1 << k)\n        k += 1\n    return summation"
        ],
        [
            "def sum_arithmetic_sequence(first_term, last_term, common_difference):\n    \"\"\"\n    Calculates the sum of an arithmetic sequence from the first term to the last term with a given common difference.\n    \n    Parameters:\n    - first_term (int/float): The first term of the arithmetic sequence.\n    - last_term (int/float): The last term of the arithmetic sequence.\n    - common_difference (int/float): The common difference between successive terms.\n    \n    Returns:\n    - float: The sum of the arithmetic sequence.\n    \n    Example:\n    >>> sum_arithmetic_sequence(1, 10, 1)\n    55.0\n    >>> sum_arithmetic observations(3, 9, 2)\n    24.0\n    \"\"\"\n    import math\n    if common_difference == 0:\n        raise ValueError(\"Common difference cannot be zero.\")\n    \n    # Calculate the number of terms (n)\n    n = int((last_term - first_term) / common_difference + 1)\n    \n    # Sum of arithmetic sequence formula: n/2 * (first_term + last_term)\n    sum_sequence = n / 2 * (first_term + last_term)\n    return sum_sequence"
        ],
        [
            "def sum_of_squares(n):\n    \"\"\"\n    Calculate the sum of the squares of the first n natural numbers.\n    Parameters:\n    n (int): The number of terms.\n    Returns:\n    int: The sum of the squares of the first n natural numbers.\n    \n    Examples:\n    >>> sum_of_squares(10)\n    385\n    \"\"\"\n    return n * (n + 1) * (2 * n + 1) // 6"
        ],
        [
            "def trigonometric_series_sum(func_type, coef, offset, lower_bound, upper_bound):\n    \"\"\"\n    Calculates the sum of a trigonometric function over a specified range.\n    Parameters:\n        func_type (str): Type of trigonometric function. Must be 'sin' or 'cos'.\n        coef (float): Coefficient of the variable in the function argument.\n        offset (float): Constant offset in the function argument.\n        lower_bound (int): The lower bound of the summation index.\n        upper_bound (int): The upper bound of the summation index.\n    Returns:\n        float: The sum of the series.\n    Example:\n        >>> trigonometric_series_sum('sin', 1, 0, 0, 10)\n        1.4112\n        >>> trigonometric_series_sum('cos', 2, np.pi/4, 0, 10)\n        0.7214\n    \"\"\"\n    # Validate the function type\n    if func_type not in ['sin', 'cos']:\n        raise ValueError(\"func_type must be 'sin' or 'cos'\")\n    # Generating the function according to the type\n    trig_func = np.sin if func_type == 'sin' else np.cos\n    # Calculate the sum of the series\n    total_sum = sum(trig_func(coef * k + offset) for k in range(lower_bound, upper_bound + 1))\n    return total_sum"
        ],
        [
            "def general_arithmetic_sum(start, end, step=1):\n    \"\"\"\n    Calculate the sum of an arithmetic sequence from start to end with a common difference step.\n    Parameters:\n    start (int/float): The first term of the arithmetic sequence.\n    end (int/float): The last term of the sequence.\n    step (int/float): The common difference between terms.\n    Returns:\n    float: The sum of the arithmetic sequence.\n    \n    Examples:\n    >>> general_arithmetic_sum(1, 10)\n    55.0\n    >>> general_arithmetic_sum(1, 100, 2)\n    2500.0\n    \"\"\"\n    import numpy as np\n    N = int((end - start) / step + 1)\n    return np.sum(np.arange(start, end + 1, step))"
        ]
    ],
    "Substitution": [
        [
            "def solve_linear_system(equations, variables):\n    \"\"\"\n    Solve a system of linear equations.\n    \n    Parameters:\n    - equations (list of str): List containing equations in string format.\n    - variables (list of str): List of variable strings involved in the system.\n    \n    Returns:\n    - dict: Dictionary showing solutions for variables or a message if no solution exists.\n    \n    Examples:\n    >>> solve_linear_system(['2*x + 3*y - 6', 'x - y - 1'], ['x', 'y'])\n    {x: 3, y: 2}\n    >>> solve_linear_system(['x + y - 2', '2*x + 2*y - 4'], ['x', 'y'])\n    'Infinite solutions'\n    \"\"\"\n    # Parse equations and variables\n    sym_vars = sp.symbols(variables)\n    sympy_eqs = [sp.sympify(eq) for eq in equations]\n    # Solver\n    sol = sp.solve(sympy_eqs, sym_vars)\n    \n    # Process infinite solutions or contradictions\n    if isinstance(sol, list) and len(sol) == 0:\n        return \"No solution\"\n    elif isinstance(sol, dict) and all(val.is_number for val in sol.values()):\n        return sol\n    else:\n        return \"Infinite solutions\"",
            "def solve_system_of_equations(equations, target_vars):\n    \"\"\"\n    Solves a system of linear equations using substitution and algebraic manipulation.\n    Parameters:\n    - equations (list of str or sympy.Expr): List of algebraic equations.\n    - target_vars (list of str): List of variables to solve for.\n    \n    Returns:\n    - dict: Solutions in the form of a dictionary of variable:value pairs.\n    \n    Examples:\n    >>> equations = ['2*x + 3*y = 5', 'x - y = 2']\n    >>> target_vars = ['x', 'y']\n    >>> solve_system_of_equations(equations, target_vars)\n    {x: 3, y: 1}\n    \"\"\"\n    # Create symbolic variables and parse the equations if provided as strings\n    sympy_equations = [sp.sympify(eq) for eq in equations]\n    symbols = sp.symbols(target_vars)\n    # Solve the system of equations\n    solution = sp.solve(sympy_equations, symbols)\n    return solution"
        ],
        [
            "def substitute_and_evaluate(expression, substitutions):\n    \"\"\"\n    Substitute values into an algebraic expression and evaluate it.\n    \n    Parameters:\n    - expression (str): The algebraic expression in string format.\n    - substitutions (dict): A dictionary mapping from variable (str) to value (numeric or symbolic).\n    \n    Returns:\n    - sympy.Expr: Resultant expression after applying substitutions and simplification.\n    \n    Examples:\n    >>> substitute_and_evaluate('x**2 + 3*y', {'x': 2, 'y': 1})\n    7\n    >>> substitute_and_evaluate('a*b + c', {'a': 1, 'b': 2, 'c': 3})\n    5\n    \"\"\"\n    # Parse the expression\n    expr = sp.sympify(expression)\n    # Substitute the values\n    substituted_expr = expr.subs(substitutions)\n    \n    # Simplify and return evaluated expression\n    return sp.simplify(substituted_expr)",
            "def simplify_and_substitute(expression, substitutions):\n    \"\"\"\n    Substitutes values or expressions into a given algebraic or trigonometric expression and simplifies the result.\n    Parameters:\n    - expression (str): A string representing the algebraic or trigonometric expression.\n    - substitutions (dict): A dictionary where keys are variable names as strings and values are the numerical values,\n                            expressions or other variables to substitute in the `expression`.\n    Returns:\n    - sympy.Expr: The simplified expression after substitution.\n    Examples:\n    ---------\n    simplify_and_substitute('x^2 + 3*x + 4', {'x': 2})\n    => 12\n    \n    simplify_and_substitute('sin(x) + cos(x)', {'x': 'pi/4'})\n    => sqrt(2)/2 + sqrt(2)/2\n    \n    simplify_and_substitute('a*b + 5*a', {'a': '3', 'b': '2'})\n    => 21\n    \"\"\"\n    # Convert the string expression to a Sympy expression\n    expr = sp.sympify(expression)\n    \n    # Substitute the values using dictionary unpacking\n    substituted_expr = expr.subs(substitutions)\n    \n    # Simplify the substituted expression\n    simplified_expr = sp.simplify(substituted_expr)\n    \n    return simplified_expr",
            "def evaluate_expression_with_substitution(expression, substitutions):\n    \"\"\"\n    Evaluate an algebraic expression with specified substitutions for its variables.\n    \n    Parameters\n    ----------\n    expression : str\n        A string representing the algebraic expression to evaluate. \n        Example: '2*x + y**2 - 3'\n    substitutions : dict\n        A dictionary where keys are variable names (as strings) and values are the numbers \n        or expressions to substitute. Example: {'x': 10, 'y': 5}\n    Returns\n    -------\n    sympy.core.expr.Expr\n        The result of the expression after applying the substitutions. This can be a \n        numerical result or a symbolic expression, depending on whether all variables \n        have been substituted.\n    Examples\n    --------\n    >>> result = evaluate_expression_with_substitution('2*x + 3*y - 4', {'x': 2, 'y': 3})\n    >>> print(result)\n    13\n    \n    >>> result = evaluate_expression_with_substitution('x**2 + y**2', {'x': 3})\n    >>> print(result)\n    y**2 + 9\n    \"\"\"\n    from sympy import sympify, symbols\n    \n    # Convert the string expression to a sympy expression\n    expr = sympify(expression)\n    \n    # Create symbols for each key in substitutions if not already a symbol\n    for var in substitutions:\n        if not isinstance(substitutions[var], symbols):\n            substitutions[var] = sympify(substitutions[var])\n    \n    # Substitute values into the expression\n    substituted_expr = expr.subs(substitutions)\n    \n    # Return the simplified expression\n    return substituted_expr",
            "def algebraic_substitution(expression, variable_dict):\n    \"\"\"\n    Substitutes the given variable values into the expression and evaluates/solves it.\n    Parameters:\n    - expression (str or sympy.Expr): The algebraic expression or equation to substitute into.\n    - variable_dict (dict): A dictionary of variable:value pairs where the keys are variable names (str)\n                             and the values are the numerical substitutions or expressions.\n    Returns:\n    - sympy.Expr: The simplified expression or solution of the equation after substitution.\n    \n    Examples:\n    >>> expr = '2*x + 3*y - 5'\n    >>> values = {'x': 1, 'y': 2}\n    >>> algebraic_substitution(expr, values)\n    5\n    \"\"\"\n    # Create symbolic variables and parse the expression if given as string\n    expr = sp.sympify(expression)\n    # Substitute the values into the expression\n    subs_expr = expr.subs(variable_dict)\n    # Simplify the substituted expression\n    simplified_expr = sp.simplify(subs_expr)\n    return simplified_expr",
            "def substitute_and_simplify(expression, substitutions):\n    \"\"\"\n    Substitute the values into the expression and then simplify it.\n    Parameters:\n    - expression (str): The algebraic expression in string format.\n    - substitutions (dict): Dictionary of substitutions where keys are variable names \n                            as strings and values are the numeric or symbolic values to substitute.\n    Returns:\n    - sympy.Expr: The simplified expression after substitutions.\n    Examples:\n    >>> substitute_and_simplify(\"x**2 + 3*x + 1\", {\"x\": 2})\n    11\n    >>> substitute_and_simplify(\"sin(x) + cos(x)\", {\"x\": \"pi/4\"})\n    sqrt(2)\n    \"\"\"\n    # Convert string to a symbolic expression\n    expr = sympy.sympify(expression)\n    # Convert substitution dictionary to symbolic form\n    symbolic_subs = {symbols(k): sympy.sympify(v) for k, v in substitutions.items()}\n    # Perform substitution\n    substituted_expr = expr.subs(symbolic_subs)\n    # Simplify the expression\n    simplified_expr = simplify(substituted_expr)\n    \n    return simplified_expr",
            "def substitute_and_evaluate(expression, values):\n    \"\"\"\n    Substitutes given values into the algebraic expression and evaluates it.\n    Parameters:\n    - expression (str): A string representing the algebraic expression to be evaluated.\n    - values (dict): A dictionary where keys are the variable names as strings and\n                     values are the numerical values to substitute into the expression.\n    Returns:\n    - result: The evaluated result of the expression after substitution.\n    Example:\n    >>> substitute_and_evaluate('x**2 + 3*y', {'x': 2, 'y': 1})\n    7\n    >>> substitute_and_evaluate('a*b + c**2', {'a': -1, 'b': 5, 'c': 3})\n    4\n    Note:\n    This function uses sympy for symbolic manipulation and evaluation of expressions.\n    Ensure all operation rules such as PEMDAS/BODMAS are respected, including handling\n    of exponentiation and negative numbers appropriately.\n    \"\"\"\n    # Convert the string expression to a sympy expression\n    expr = sp.sympify(expression)\n    \n    # Create symbolic variables and substitute in the provided values\n    substituted_expr = expr.subs(values)\n    \n    # Evaluate the expression\n    result = substituted_expr.evalf()\n    \n    return result",
            "def substitute_and_simplify(expression, substitution_dict):\n    \"\"\"\n    Substitute values into an algebraic expression and simplify it.\n    Parameters:\n        expression (str): The symbolic math expression in string form.\n        substitution_dict (dict): A dictionary where keys are variables in `expression`\n                                  as strings, and values are the numeric or symbolic values\n                                  to substitute into these variables.\n    Returns:\n        sympy.Expr: The simplified expression after substitution.\n    Example:\n        >>> substitute_and_simplify('x**2 + y + 3', {'x': 2, 'y': 1})\n        8\n    \"\"\"\n    from sympy import sympify, simplify\n    expr = sympify(expression)\n    substituted_expr = expr.subs(substitution_dict)\n    return simplify(substituted_expr)",
            "def evaluate_expression_with_substitution(expression: str, substitutions: dict) -> sp.Expr:\n    \"\"\"\n    Evaluate an algebraic expression with given substitutions and return the simplified result.\n    \n    Parameters:\n        expression (str): The string representation of the algebraic expression.\n        substitutions (dict): A dictionary where keys are symbols (as strings) and values are the values to substitute.\n    \n    Returns:\n        sympy.Expr: The evaluated and simplified expression.\n    \n    Examples:\n        >>> evaluate_expression_with_sublication(\"x**2 + 2*x + 1\", {\"x\": 2})\n        9\n        >>> evaluate_expression_with_sublication(\"sin(x) + cos(x)\", {\"x\": sp.pi/4})\n        sqrt(2)\n    \"\"\"\n    expr = sp.sympify(expression)\n    subs_dict = {sp.symbols(k): v for k, v in substitutions.items()}\n    substituted_expr = expr.subs(subs_dict)\n    return sp.simplify(substituted_expr)",
            "def evaluate_expression(expression, substitutions):\n    \"\"\"\n    Evaluates an algebraic expression with specific substitutions for its variables.\n    Parameters:\n    -----------\n    expression : str \n        A string representing the mathematical expression.\n        Example: \"2 * x + 3 * y - z**2\"\n    \n    substitutions : dict\n        A dictionary mapping variables as strings to their corresponding values.\n        Example: {'x': 10, 'y': 5, 'z': 3}\n    Returns:\n    --------\n    result : sympy expression, float or int\n        The result of the expression after substituting the values and computing it.\n    \n    Example:\n    --------\n    >>> evaluate_expression(\"2 * x + 3 * y - z**2\", {'x': 10, 'y': 5, 'z': 3})\n    29\n    \"\"\"\n    # Parse the string into a symbolic expression\n    expr = sympy.sympify(expression)\n    # Substitute the values into the expression\n    substituted_expr = expr.subs(substitutions)\n    # Evaluate the expression\n    result = substituted_expr.evalf()\n    return result"
        ],
        [
            "def solve_equation(equations, variables, substitutions={}):\n    \"\"\"\n    Solves algebraic or trigonometric equations, allowing for substitution of given values or expressions prior to solving.\n    Parameters:\n    - equations (list): A list of strings or sympy.Expr representing the equations to solve.\n    - variables (list): A list of variables as strings or sympy.Symbol for which the equations are to be solved.\n    - substitutions (dict, optional): A dictionary for substituting values in the equations before solving.\n    Returns:\n    - dict: Solutions of the equations with variables as keys.\n    Examples:\n    ----------\n    solve_equation(['x^2 - 4 = 0', 'x - y = 2'], ['x', 'y'])\n    => {x: [-2, 2], y: [0, 4]}\n    solve_equation(['sin(x) + cos(x) = 1', 'x + y = pi/2'], ['x', 'y'], {'x': 'pi/4'})\n    => {y: pi/4}\n    \"\"\"\n    # Convert string equations to sympy expressions if needed\n    eqs = [sp.sympify(eq) for eq in equations]\n    \n    # Convert string variables to sympy symbols\n    vars = [sp.symbols(var) if isinstance(var, str) else var for var in variables]\n    \n    if substitutions:\n        eqs = [eq.subs(substitutions) for eq in eqs]\n    \n    solutions = sp.solve(eqs, vars)\n    \n    return solutions",
            "def solve_equations(equations, variables, substitution_dict={}):\n    \"\"\"\n    Solve a system of equations by substituting known values and solving for the unknowns.\n    Parameters:\n        equations (list): List of strings representing each equation.\n        variables (list): List of string variables to solve for.\n        substitution_dict (dict, optional): A dictionary where keys are variables and\n                                            values are the known values to substitute.\n    \n    Returns:\n        dict: A dictionary where keys are the variables and values are the solutions.\n    Example:\n        >>> solve_equations(['x + y = 10', '2*x + y = 12'], ['x', 'y'])\n        {'x': 2, 'y': 8}\n    \"\"\"\n    from sympy import symbols, Eq, solve, sympify\n    # Convert strings to sympy equation objects\n    equation_objs = [Eq(sympify(eq.split('=')[0]), sympify(eq.split('=')[1])) for eq in equations]\n    # Substitute known values before solving if any\n    if substitution_dict:\n        equation_objs = [eq.subs(substitution_dict) for eq in equation_objs]\n    # Define symbols\n    sym_vars = symbols(variables)\n    # Solve equations\n    sol = solve(equation_objs, sym_vars)\n    return sol"
        ],
        [
            "def simplify_expression(expression: str) -> sp.Expr:\n    \"\"\"\n    Simplifies the given algebraic expression and returns the simplified result.\n    \n    Parameters:\n        expression (str): The string representation of the mathematic expression.\n    \n    Returns:\n        sympy.Expr: The simplified expression.\n    \n    Examples:\n        >>> simplify_expression(\"x**2 - 2*x + 1 + 0*x\")\n        x**2 - 2*x + 1\n        >>> simplify_expression(\"sin(x)**2 + cos(x)**2\")\n        1\n    \"\"\"\n    expr = sp.sympify(expression)\n    return sp.simplify(expr)"
        ],
        [
            "def evaluate_function_after_substitution(function, substitution_dict):\n    \"\"\"\n    Evaluates a function after substituting specific values or expressions for its variables.\n    Parameters:\n    - function (str or sympy.Function): The function to be evaluated, given as an expression.\n    - substitution_dict (dict): A dictionary specifying the substitutions to be made, where keys are variable names.\n    Returns:\n    - sympy.Expr: The result of the function after substitution.\n    \n    Examples:\n    >>> func = 'x**2 + y**2'\n    >>> subs = {'x': 1, 'y': 3}\n    >>> evaluate_function_after_substitution(func, subs)\n    10\n    \"\"\"\n    # Parse the function if provided as string\n    func_expr = sp.sympify(function)\n    # Substitute the values\n    substituted_expr = func_expr.subs(substitution_dict)\n    # Evaluate the expression\n    evaluated_expr = sp.simplify(substituted_expr)\n    return evaluated_expr"
        ],
        [
            "def trig_substitute(expression, angle_subs, period_multiple=True):\n    \"\"\"\n    Perform trigonometric substitutions including handling expressions with \n    multiple angles or cycles.\n    Parameters:\n    - expression (str): Trigonometric expression as a string.\n    - angle_subs (dict): Dictionary specifying angle substitutions, where variables \n                         are given as strings and values are the angle measures.\n    - period_multiple (bool): If True, considers multiple cycles by integrating the period (2*pi for radians).\n    Returns:\n    - sympy.Expr: Resulting expression after substitution and simplification.\n    \n    Examples:\n    >>> trig_substitute(\"sin(x) + sin(2*x)\", {\"x\": \"pi/6\"})\n    1.5\n    >>> trig_substitute(\"cos(x) - sin(x)\", {\"x\": \"pi/3\"})\n    0.5*sqrt(3) - 0.5\n    \"\"\"\n    # Convert string to a symbolic expression\n    expr = sympy.sympify(expression)\n    # Modify angle values accounting for period multiples if indicated\n    modified_subs = {symbols(k): (sympy.sympify(v) * (2 * pi if period_multiple else 1)) for k, v in angle_subs.items()}\n    # Perform substitution\n    substituted_expr = expr.subs(modified_subs)\n    # Simplify the expression\n    simplified_expr = sympy.simplify(substituted_expr)\n    \n    return simplified_expr"
        ]
    ],
    "Fractions": [
        [
            "def simplify_fraction(numerator, denominator):\n    \"\"\"\n    Simplify a fraction by finding the greatest common divisor (GCD) of the numerator and the denominator.\n    Parameters:\n    numerator (int): Numerator of the fraction.\n    denominator (int): Denominator of the fraction.\n    Returns:\n    Fraction: A simplified fraction.\n    Examples:\n    >>> simplify_fraction(8, 20)\n    Fraction(2, 5)\n    >>> simplify_fraction(5, 15)\n    Fraction(1, 3)\n    \"\"\"\n    if denominator == 0:\n        raise ValueError(\"Denominator cannot be zero.\")\n    return Fraction(numerator, denominator).limit_denominator()",
            "def simplify_fraction(numerator, denominator):\n    \"\"\"\n    Simplifies a fraction to its lowest terms.\n    Parameters:\n    numerator (int): The numerator of the fraction.\n    denominator (int): The denominator of the fraction.\n    Returns:\n    Fraction: A fraction object representing the fraction in its simplest form.\n    Examples:\n    >>> simplify_fraction(8, 20)\n    Fraction(2, 5)\n    >>> simplify_fraction(10, 28)\n    Fraction(5, 14)\n    \"\"\"\n    return Fraction(numerator, denominator).limit_denominator()",
            "def simplify_fraction(numerator, denominator):\n    \"\"\"\n    Simplifies a fraction given a numerator and a denominator.\n    \n    Parameters:\n        numerator (int or sympy expression): The numerator of the fraction.\n        denominator (int or sympy expression): The denominator of the fraction.\n        \n    Returns:\n        sympy.Rational: Simplified fraction.\n    \n    Examples:\n        >>> simplify_fraction(15, 35)\n        3/7\n        \n        >>> simplify_fraction(x**2 - 4, x - 2)  # where x is a sympy symbol\n        x + 2\n    \"\"\"\n    return simplify(Rational(numerator, denominator))",
            "def simplify_fraction(numerator, denominator):\n    \"\"\"\n    Simplifies a fraction and returns its simplest form as a Fraction object.\n    \n    Parameters\n    ----------\n    numerator : int\n        The numerator of the fraction.\n        \n    denominator : int\n        The denominator of the fraction.\n        \n    Returns\n    -------\n    Fraction\n        The simplified fraction.\n        \n    Examples\n    --------\n    >>> simplify_fraction(8, 4)\n    Fraction(2, 1)\n    \"\"\"\n    common_divisor = gcd(numerator, denominator)\n    return Fraction(numerator // common_divisor, denominator // common_divisor)"
        ],
        [
            "def reciprocal(fraction):\n    \"\"\"\n    Finds the reciprocal of a given fraction.\n    \n    Parameters:\n        fraction (tuple): The fraction represented as a tuple (numerator, denominator).\n        \n    Returns:\n        sympy.Rational: The reciprocal of the given fraction.\n    \n    Examples:\n        >>> reciprocal((1, 2))\n        2\n    \"\"\"\n    num, den = fraction\n    return simplify_fraction(den, num)",
            "def find_reciprocal(frac):\n    \"\"\"\n    Finds the reciprocal of a given fraction.\n    Parameters:\n        frac (tuple): A tuple representing the fraction (numerator, denominator).\n    \n    Returns:\n        tuple: Reciprocal of the given fraction (denominator, numerator).\n    \n    Example:\n        >>> find_reciprocal((3, 4))\n        (4, 3)\n    \"\"\"\n    num, den = frac\n    return (den, num)"
        ],
        [
            "def fraction_to_decimal(numerator, denominator):\n    \"\"\"\n    Convert a fraction represented by numerator and denominator into a decimal.\n    Decimal may be terminating or repeating.\n    Parameters:\n    numerator (int): the numerator of the fraction.\n    denominator (int): the denominator of the fraction.\n    Returns:\n    str: String representation of the decimal.\n    Examples:\n    >>> fraction_to_decimal(1, 3)\n    '0.(3)'\n    >>> fraction_to_decimal(1, 2)\n    '0.5'\n    \"\"\"\n    if denominator == 0:\n        raise ValueError(\"Denominator cannot be zero.\")\n    fraction = Fraction(numerator, denominator)\n    integer_part = int(fraction.numerator / fraction.denominator)\n    remainder = fraction.numerator % fraction.denominator\n    decimals = []\n    remainders = {}\n    while remainder and remainder not in remainders:\n        remainders[remainder] = len(decimals)\n        remainder *= 10\n        decimals.append(str(remainder // fraction.denominator))\n        remainder %= fraction.denominator\n    if remainder:\n        index = remainders[remainder]\n        non_repeating = ''.join(decimals[:index])\n        repeating = ''.join(decimals[index:])\n        return f\"{integer_part}.({repeating})\"\n    else:\n        return f\"{integer_part}.{''.join(decimals)}\"",
            "def decimal_to_fraction(decimal_str):\n    \"\"\"\n    Convert a decimal in string format to a fraction.\n    Parameters:\n    decimal_str (str): The decimal number as a string, which might have repeating sequences.\n    Returns:\n    Fraction: A Fraction object representing the number.\n    Examples:\n    >>> decimal_to_fraction(\"0.5\")\n    Fraction(1, 2)\n    >>> decimal_to_fraction(\"0.(3)\")\n    Fraction(1, 3)\n    \"\"\"\n    # Match non-repeating and repeating parts of the decimal.\n    match = re.match(r\"^(-?\\d*)\\.(\\d*)\\(?(\\d*)\\)?$\", decimal_str)\n    if not match:\n        raise ValueError(\"Invalid decimal format.\")\n    \n    integer_part, non_repeating, repeating = match.groups()\n    if not repeating:\n        # Simple decimal without repetition.\n        if non_repeating:\n            denominator = 10 ** len(non_repeating)\n            numerator = int(non_repeating) + int(integer_part) * denominator\n            return Fraction(numerator, denominator)\n        else:\n            return Fraction(int(integer_part), 1)\n    else:\n        # Decimal with repetition.\n        total_length = len(non_repeating) + len(repeating)\n        non_repeat_value = int(non_repeating) if non_repeating else 0\n        repeat_value = int(repeating)\n        non_repeating_full = int(integer_part + non_repeating) if non_repeating else int(integer_part)\n        base_number = 10 ** len(non_repeating)\n        repeating_factor = (10**len(repeating) - 1) * base_number\n        \n        numerator = non_repeating_full * repeating_factor + repeat_value - non_repeat_value\n        denominator = repeating_factor\n        return Fraction(numerator, denominator)",
            "def fraction_to_decimal(numerator, denominator):\n    \"\"\"\n    Converts a given fraction represented by a numerator and denominator to its decimal form.\n    It handles both repeating and terminating decimals and identifies the repeating part if it exists.\n    Parameters:\n    numerator (int): The numerator of the fraction.\n    denominator (int): The denominator of the fraction.\n    Returns:\n    tuple: A tuple containing the decimal representation as a string, and a string for the repeating part (if any, else an empty string).\n    Examples:\n    >>> fraction_to_decimal(1, 2)\n    ('0.5', '')\n    >>> fraction_to_decimal(1, 3)\n    ('0.', '3')\n    \"\"\"\n    # Fraction instantiation to handle large integers and GCD simplification\n    frac = Fraction(numerator, denominator)\n    # Get the decimal string\n    decimal_str = str(frac)\n    if '.' in decimal_str:\n        # Process to find repeating sequence (not implemented here due to simplicity but can be done using more elaborate algorithms)\n        int_part, dec_part = decimal_str.split('.')\n        return (f\"{int_part}.{dec_part}\", '')  # Placeholder for no repeating sequence handling\n    return (decimal_str, '')  # For whole numbers or zero",
            "def decimal_to_fraction(decimal_str):\n    \"\"\"\n    Converts a decimal given as a string to the simplest form of fraction.\n    It can handle both repeating and non-repeating decimals.\n    Parameters:\n    decimal_str (str): The decimal number in string format.\n    Returns:\n    Fraction: A fraction object representing the simplest form of the given decimal.\n    Examples:\n    >>> decimal_to_fraction('0.5')\n    Fraction(1, 2)\n    >>> decimal_toference '0.333...'\n    Fraction(1, 3)\n    \"\"\"\n    if '(' in decimal_str and ')' in decimal_str:\n        # Handling repeating decimals\n        start, repetend = decimal_str.replace(')', '').split('(')\n        non_repeat_length = len(start.split('.')[1]) if '.' in start else 0\n        repeat_length = len(repetend)\n        integer_part = int(start.replace('.', ''))\n        repeat_part = int(repetend)\n        fractional_value = integer_part + repeat_part / (10**repeat_length - 1) * (10**non_repeat_length)\n        return Fraction(fractional_value).limit_denominator()\n    return Fraction(decimal_str).limit_denominator()",
            "def repeating_decimal_to_fraction(decimal_str):\n    \"\"\"\n    Converts a repeating decimal string to a simplified fraction.\n    Parameters\n    ----------\n    decimal_str : str\n        A string representing the repeating decimal.\n        \n    Returns\n    -------\n    Fraction\n        The fraction representation of the repeating decimal.\n    \n    Examples\n    --------\n    >>> repeating_decimal_to_fraction('0.333...')\n    Fraction(1, 3)\n    \"\"\"\n    # Pattern to identify repeating digits (assumed to be indicated by '...')\n    repeating_pattern = re.compile(r\"(\\d+?)\\1+\") \n    if '...' not in decimal_str:\n        # If there's no indication of repeating, it's a regular decimal\n        return decimal_to_fraction(float(decimal_str))\n    # Separate the non-repeating and repeating parts\n    whole_number, fractional_part = decimal_str.split('.')\n    non_repeating_part, repeating_part = fractional_part.split('...')\n    \n    # Detect repeating sequence using regex\n    match = repeating_pattern.fullmatch(repeating_part)\n    if match:\n        repeating_sequence = match.group(1)\n    else:\n        repeating_sequence = repeating_part\n    # Create a fraction using the repeating sequence\n    repeat_length = len(repeating_sequence)\n    as_integer = int(whole_number + non_repeating_part + repeating_sequence)\n    non_repeat_length = len(non_repeating_part)\n    \n    if non_repeat_length == 0:\n        numerator = as_integer - int(whole_number)\n    else:\n        numerator = as_integer - int(whole_number + non_repeating_part)\n    \n    denominator = (10**repeat_length - 1) * 10**non_repeat_length\n    \n    return simplify_fraction(numerator, denominator)"
        ],
        [
            "def add_fractions(fraction1, fraction2):\n    \"\"\"\n    Adds two fractions and simplifies the result.\n    Parameters\n    ----------\n    fraction1 : Fraction\n        First fraction to be added.\n    fraction2 : Fraction\n        Second fraction to be"
        ],
        [
            "def multiply_fractions(frac1, frac2):\n    \"\"\"\n    Multiplies two fractions represented as tuples of numerators and denominators.\n    \n    Parameters:\n        frac1 (tuple): A tuple (numerator1, denominator1) of the first fraction.\n        frac2 (tuple): A tuple (numerator2, denominator2) of the second fraction.\n        \n    Returns:\n        sympy.Rational: Product of the two fractions in its simplest form.\n    \n    Examples:\n        >>> multiply_fractions((1, 2), (3, 4))\n        3/8\n    \"\"\"\n    num1, den1 = frac1\n    num2, den2 = frac2\n    return simplify_fraction(num1 * num2, den1 * den2)",
            "def add_fractions(frac1, frac2):\n    \"\"\"\n    Adds two fractions and returns the result in its simplest form.\n    \n    Parameters:\n        frac1 (tuple): A tuple or list representing the first fraction (numerator, denominator).\n        frac2 (tuple): A tuple or list representing the second fraction (numerator, denominator).\n    \n    Returns:\n        tuple: Resulting fraction from the addition in its simplest form (numerator, denominator).\n    \n    Example:\n        >>> add_fractions((1, 3), (1, 6))\n        (1, 2)\n    \"\"\"\n    num1, den1 = frac1\n    num2, den2 = frac2\n    common_den = lcm(den1, den2)\n    num_result = num1 * (common_den / den1) + num2 * (common_den / den2)\n    result_gcd = gcd(num_result, common_den)\n    return (int(num_result / result_gcd), int(common_den / result_gcd))",
            "def multiply_fractions(frac1, frac2):\n    \"\"\"\n    Multiplies two fractions and returns the result in its simplest form.\n    \n    Parameters:\n        frac1 (tuple): A tuple or list representing the first fraction (numerator, denominator).\n        frac2 (tuple): A tuple or list representing the second fraction (numerator, denominator).\n    \n    Returns:\n        tuple: Resulting fraction from the multiplication in its simplest form (numerator, denominator).\n        \n    Example:\n        >>> multiply_fractions((1, 3), (2, 5))\n        (2, 15)\n    \"\"\"\n    num1, den1 = frac1\n    num2, den2 = frac2\n    result_num = num1 * num2\n    result_den = den1 * den2\n    result_gcd = gcd(result_num, result_den)\n    return (int(result_num / result_gcd), int(result_den / result_gcd))"
        ],
        [
            "def is_integer_fraction(frac):\n    \"\"\"\n    Determines if the simplified form of a fraction is an integer.\n    Parameters:\n        frac (tuple): A tuple representing the fraction (numerator, denominator).\n    \n    Returns:\n        bool: True if the simplified fraction is an integer, else False.\n    \n    Example:\n        >>> is_integer_fraction((2, 4))\n        True\n    \"\"\"\n    num, den = simplify_fraction(frac)\n    return den == 1"
        ],
        [
            "def decimal_to_fraction(decimal_value):\n    \"\"\"\n    Converts a decimal number to a fraction.\n    Parameters\n    ----------\n    decimal_value : float\n        A decimal number that we want to convert to a fraction.\n    Returns\n    -------\n    Fraction\n        The fractional representation of the decimal number.\n        \n    Examples\n    --------\n    >>> decimal_to_fraction(0.75)\n    Fraction(3, 4)\n    \"\"\"\n    return Fraction(decimal_value).limit_denominator()"
        ],
        [
            "def fraction_inequality_solver(inequality_str):\n    \"\"\"\n    Solves an inequality involving fractions given as a string.\n    \n    Parameters:\n        inequality_str (str): The inequality as a string.\n    \n    Returns:\n        list: Solutions to the inequality.\n    \n    Examples:\n        >>> x = symbols('x')\n        >>> fraction_inequality_solver('1/x > 0')\n        (0, oo)\n        \n        >>> fraction_inequality_solver('x/(x+1) < 1')\n        (-oo, -1) U (0, oo)\n    \"\"\"\n    x = symbols('x')\n    inequality = eval(inequality_str)\n    return solve(inequality, x)"
        ],
        [
            "def find_common_denominator(*fractions):\n    \"\"\"\n    Finds a common denominator for a series of fractions given as tuples.\n    \n    Parameters:\n        fractions (tuple): Variable length tuple argument, where each element is a tuple (numerator, denominator).\n        \n    Returns:\n        int: Least common denominator for all provided fractions.\n    \n    Examples:\n        >>> find_common_denominator((1, 2), (3, 4), (5, 6))\n        12\n    \"\"\"\n    denominators = [frac[1] for frac in fractions]\n    return lcm(denominators)"
        ],
        [
            "def fraction_operation(a, b, operation='add'):\n    \"\"\"\n    Perform arithmetic operations on two fractions and return the result in the simplest form.\n    Parameters\n    ----------\n    a : tuple of ints or tuple of sympy.Rational\n        The numerator and denominator of the first fraction, e.g., (1, 2) for 1/2.\n    b : tuple of ints or tuple of sympy.Rational\n        The numerator and denominator of the second fraction, e.g., (3, 4) for 3/4.\n    operation : str\n        The operation to perform on the fractions ('add', 'subtract', 'multiply', 'divide').\n    Returns\n    -------\n    sympy.Rational\n        The result of the operation in its simplest form.\n    Examples\n    --------\n    >>> fraction_operation((1, 2), (3, 4), 'add')\n    5/4\n    >>> fraction_operation((1, 3), (1, 2), 'multiply')\n    1/6\n    \"\"\"\n    # Create Rational objects for the fractions\n    frac_a = Rational(*a)\n    frac_b = Rational(*b)\n    \n    # Perform the specified operation\n    if operation == 'add':\n        result = frac_a + frac_b\n    elif operation == 'subtract':\n        result = frac_a - frac_b\n    elif operation == 'multiply':\n        result = frac_a * frac_b\n    elif operation == 'divide':\n        result = frac_a / frac_b\n    else:\n        raise ValueError(\"Unsupported operation. Choose from 'add', 'subtract', 'multiply', 'divide'.\")\n    \n    # Return the simplified result\n    return simplify(result)"
        ],
        [
            "def fraction_to_decimal(numerator, denominator):\n    \"\"\"\n    Converts a fraction represented by numerator and denominator to \n    the float decimal form.\n    Parameters\n    ----------\n    numerator : int\n        The numerator of the fraction.\n    \n    denominator : int\n        The denominator of the fraction.\n    Returns\n    -------\n    float\n        The decimal representation of the fraction.\n        \n    Examples\n    --------\n    >>> fraction_to_decimal(3, 4)\n    0.75\n    \"\"\"\n    return numerator / denominator"
        ],
        [
            "def handle_complex_fractions(frac):\n    \"\"\"\n    Simplifies complex fractions.\n    Parameters:\n        frac (sympy expression): A complex fraction possibly involving nested fractions.\n    \n    Returns:\n        sympy expression: Simplified expression of the fraction.\n    \n    Example:\n        >>> from sympy.abc import x, y\n        >>> handle_complex_fractions((x/(y/2)+(3/4)))\n        2*x/y + 3/4\n    \"\"\"\n    return simplify(frac)"
        ],
        [
            "def simplify_fraction(frac):\n    \"\"\"\n    Simplifies a fraction to its lowest terms.\n    \n    Parameters:\n        frac (tuple): A tuple or list representing the fraction (numerator, denominator).\n    \n    Returns:\n        tuple: Simplified fraction (numerator, denominator).\n    \n    Example:\n        >>> simplify_fraction((6, 9))\n        (2, 3)\n    \"\"\"\n    num, den = frac\n    common_gcd = gcd(num, den)\n    return (int(num / common_gcd), int(den / common_gcd))"
        ],
        [
            "def complex_fraction_operations(expr, variables=None):\n    \"\"\"\n    Perform operations on an algebraic expression involving fractions. It simplifies the expression and can handle nested fractions.\n    Parameters\n    ----------\n    expr : sympy expression or str\n        The entire algebraic expression involving fractions to simplify.\n    variables : dict, optional\n        A dictionary mapping string representations of variables to their numerical or algebraic values.\n    Returns\n    -------\n    sympy.Expr\n        The simplified algebraic expression.\n    Examples\n    --------\n    >>> complex_fraction_operations('1/2 + 1/3 * x', {'x': 3})\n    3/2\n    >>> complex_fraction_operations('(1/2) / (1/3)')\n    3/2\n    \"\"\"\n    # Parse the expression if it's given as a string\n    if isinstance(expr, str):\n        if variables:\n            # Define symbols\n            varsymbols = {k: symbols(k) for k in variables}\n            expr = expr.format(**varsymbols)\n        expr = simplify(expr)\n    \n    if variables:\n        # Substitute values into the expression\n        substitutions = {symbols(k): v for k, v in variables.items()}\n        expr = expr.subs(substitutions)\n    \n    return simplify(expr)"
        ]
    ],
    "Variables and Expressions": [
        [
            "def solve_equation(equation, variable):\n    \"\"\"\n    Solves a symbolic equation for the given variable.\n    \n    Parameters:\n        equation (str or sympy.Expr): The equation to solve. Can be a string or a sympy expression.\n        variable (str or sympy.Symbol): The variable to solve for.\n    \n    Returns:\n        list: Solutions of the equation with respect to the given variable.\n        \n    Examples:\n        >>> solve_equation(\"x**2 - 9\", \"x\")\n        [-3, 3]\n    \"\"\"\n    if isinstance(equation, str):\n        equation = create_expression(equation)\n    if isinstance(variable, str):\n        variable = sp.symbols(variable)\n    return sp.solveset(equation, variable, domain=sp.S.Reals)",
            "def solve_equation(equation_str, target_var, **values):\n    \"\"\"\n    Solve an algebraic equation or evaluate it for the given values of other variables.\n    Parameters:\n    - equation_str (str): The equation in string format.\n    - target_var (str): The variable to solve for if other variables are provided or it's a pure evaluation.\n    - values (dict): Key-value pairs of variables and their values if needed for substitution before solving.\n    \n    Returns:\n    - Union[dict, sympy.core.expr.Expr]: The solutions to the equation or the evaluated result.\n    \n    Examples:\n    >>> solve_equation(\"x + y - 10\", \"x\", y=3)\n    {x: 7}\n    \n    >>> solve_equation(\"x^2 - 1 = 0\", \"x\")\n    {x: [-1, 1]}\n    \"\"\"\n    expr = sympy.sympify(equation_str)\n    if values:\n        expr = expr.subs(values)\n    return solve(Eq(expr, 0), symbols(target_var))",
            "def solve_equation(equation, variable):\n    \"\"\"\n    Solve an algebraic equation for the given variable.\n    \n    Parameters:\n        equation (str): The equation to solve, provided as a string.\n        variable (str): The variable to solve the equation for.\n    \n    Returns:\n        list: The solutions to the equation.\n    \n    Example:\n        >>> solve_equation(\"x + 2 - 5 = x - 1\", \"x\")\n        [-6]\n    \"\"\"\n    var = symbols(variable)\n    eq = Eq(simplify(equation.split('=')[0]), simplify(equation.split('=')[1]))\n    return solve(eq, var)",
            "def solve_equation(equation: str, variable: str):\n    \"\"\"\n    Solves an algebraic equation for a given variable.\n    \n    Parameters:\n    equation (str): The equation to solve expressed in a string.\n    variable (str): The variable to solve for in the equation.\n    Returns:\n    list: A list of solutions for the equation.\n    Example:\n    >>> solve_equation('x**2 - 4*x + 4 = 0', 'x')\n    [2]\n    \"\"\"\n    var = sp.symbols(variable)\n    expr = sp.sympify(equation.replace(\"=\", \"-(\") + \")\")\n    solutions = sp.solve(expr, var)\n    return solutions",
            "def solve_equation(equation, variables):\n    \"\"\"\n    Solves a given algebraic equation for the specified variables.\n    \n    Parameters\n    ----------\n    equation : str\n        The equation in string format that needs to be solved.\n    variables : list of str\n        The list of variable names represented as strings that are the unknowns in the equation.\n    Returns\n    -------\n    dict\n        A dictionary of solutions where keys are variable names and values are their solved values.\n    \n    Examples\n    --------\n    >>> solve_equation('2*x + 10 = 0', ['x'])\n    {x: -5}\n    \"\"\"\n    # Define symbols\n    sympy_vars = symbols(variables)\n    # Parse the equation\n    parsed_eq = sympify(equation)\n    # Solve the equation\n    solutions = solve(parsed_eq, sympy_vars)\n    return solutions",
            "def solve_equation(equation, variable):\n    \"\"\"\n    Solves an algebraic equation for a specified variable.\n    Parameters:\n    - equation (str): A string representation of the equation to solve.\n    - variable (str): The variable to solve for.\n    Returns:\n    - list: A list containing the solutions of the equation.\n    Examples:\n    >>> solve_equation(\"x**2 - 4 = 0\", 'x')\n    [2, -2]\n    \"\"\"\n    expr = sp.sympify(equation)\n    var = sp.symbols(variable)\n    solutions = sp.solve(expr, var)\n    return solutions"
        ],
        [
            "def evaluate_expression(expression, values=None):\n    \"\"\"\n    Evaluate or simplify an algebraic expression, with the option to substitute values for variables.\n    Parameters:\n    - expression (str): The algebraic expression to evaluate or simplify.\n    - values (dict, optional): A dictionary mapping variable names (str) to their values (float/int). Defaults to None.\n    Returns:\n    - sympy.Expr or numeric: The simplified expression or the result of the evaluation if values are substituted.\n    Examples:\n    >>> evaluate_expression(\"x + y\", {\"x\": 2, \"y\": 3})\n    5\n    >>> evaluate_expression(\"x/y\", {\"x\": 1, \"y\": 2})\n    0.5\n    >>> evaluate_expression(\"3*x + 2\")\n    3*x + 2\n    \"\"\"\n    expr = simplify(expression)\n    if values:\n        expr = expr.subs(values)\n    return expr",
            "def evaluate_expression(expression, **variables):\n    \"\"\"\n    Evaluates a mathematical expression, potentially with variables.\n    \n    Parameters:\n    - expression (str): The expression to evaluate.\n    - variables (dict): A dictionary of variable values where keys are variable names.\n    Returns:\n    - float or int: Result of the evaluated expression.\n    \n    Examples:\n    >>> evaluate_expression('x + y', x=3, y=4)\n    7\n    >>> evaluate_expression('a * b + c', a=2, b=3, c=1)\n    7\n    \"\"\"\n    from sympy import sympify\n    expr = sympify(expression)\n    return expr.evalf(subs=variables)",
            "def evaluate_expression(expression, values=None):\n    \"\"\"\n    Form, simplify, and evaluate an algebraic expression.\n    Parameters\n    ----------\n    expression : str\n        A string representing the algebraic expression to be evaluated.\n    values : dict, optional\n        A dictionary of variable values used for substituting in the expression \n        (e.g., {'x': 1, 'y': 2}).\n    Returns\n    -------\n    sympy.Expr\n        The simplified form of the algebraic expression, or the evaluated expression\n        if values are provided.\n    Examples\n    --------\n    >>> evaluate_expression('x**2 + 3*x + 2')\n    x**2 + 3*x + 2\n    \n    >>> evaluate_expression('x**2 + 3*x + 2', {'x': 2})\n    12\n    \"\"\"\n    expr = sympify(expression)\n    simplified_expr = simplify(expr)\n    if values:\n        return simplified_expr.subs(values)\n    return simplified_expr",
            "def expression_evaluator(expression, **vars):\n    \"\"\"\n    Evaluates a mathematical expression based on given variable values and returns the result.\n    Parameters:\n    expression (str): A string representing the mathematical expression to be evaluated.\n    **vars (dict): A set of variable assignments for the expression.\n    Returns:\n    float or int: The result of the expression after substituting the values of the variables.\n    Examples:\n    >>> expression_evaluator('x + 2*y', x=1, y=3)\n    7\n    >>> expression_evaliator('a**2 + b**2', a=3, b=4)\n    25\n    \"\"\"\n    expr = sympify(expression)\n    variables = {symbols(key): value for key, value in vars.items()}\n    return expr.subs(variables).evalf()",
            "def simplify_expression(expression, values=None):\n    \"\"\"\n    Simplifies a mathematical expression, and evaluates it if values for the variables are provided.\n    Parameters:\n    - expression (str): The algebraic expression as a string.\n    - values (dict, optional): A dictionary mapping variable names (str) to their values (float/int). Defaults to None.\n    Returns:\n    - Expr or float: Returns the simplified expression or numerical result if values are provided.\n    \n    Examples:\n    >>> simplify_expression(\"2*x + 3*x - 5\")\n    5*x - 5\n    \n    >>> simplify_expression(\"2*x + 3*x - 5\", values={'x': 1})\n    0\n    \"\"\"\n    # Define the variables dynamically\n    sympy_vars = {str(s): symbols(str(s)) for s in set(filter(str.isalpha, expression))}\n    \n    # Parse the expression into a symbolic form\n    expr = simplify(expression, locals=sympy_vars)\n    \n    # If values dict is provided, substitute and evaluate the expression\n    if values:\n        expr = expr.subs(values)\n        if expr.is_number:\n            expr = float(expr)\n    \n    return expr",
            "def evaluate_expression(expression, values):\n    \"\"\"\n    Evaluates an algebraic expression given a dictionary of variable values.\n    Parameters:\n    - expression (str): The algebraic expression to evaluate.\n    - values (dict): A dictionary where keys are variable names as strings and values are their numerical values.\n    Returns:\n    - float or int: The result of the evaluated expression.\n    Examples:\n    >>> evaluate_expression(\"2*x + 3\", {'x': 2})\n    7\n    \"\"\"\n    expr = sp.sympify(expression)\n    return expr.subs(values)",
            "def evaluate_expression(expression, variable_values=None):\n    \"\"\"\n    Evaluates a symbolic expression given a set of values for its variables.\n    \n    Parameters:\n    - expression (str or sympy.Expr): The algebraic expression in string format or as a sympy.Expr object.\n    - variable_values (dict, optional): A dictionary where keys are variable names as strings and values are the numerical values assigned to those variables. Example: {'x': 2, 'y': 3}\n    \n    Returns:\n    - float: The result of evaluating the expression.\n    \n    Examples:\n    >>> exp = \"x * y + 3\"\n    >>> evaluate_expression(exp, {'x': 2, 'y': 3})\n    9.0\n    \"\"\"\n    if isinstance(expression, str):\n        expression = sp.sympify(expression)\n    if variable_values:\n        expression = expression.subs(variable_values)\n    return float(expression.evalf())"
        ],
        [
            "def expand_expression(expression: str) -> str:\n    \"\"\"\n    Expands an algebraic expression using distributive properties and simplifying nested parentheses.\n    \n    Parameters:\n    expression (str): The algebraic expression in string format to be expanded.\n    \n    Returns:\n    str: The expanded expression as a string.\n    \n    Examples:\n    >>> expand_expression('(x + 2)*(x - 3)')\n    'x**2 - x - 6'\n    \n    >>> expand_expression('(a + b + c)*(x + y)')\n    'a*x + a*y + b*x + b*y + c*x + c*y'\n    \"\"\"\n    # Convert the input string to a symbolic expression\n    expr = expand(expression)\n    # Return the expanded expression in string format\n    return str(expr)",
            "def expand_expression(expression: str) -> str:\n    \"\"\"\n    Expands an algebraic expression, especially useful for expressions with nested parentheses.\n    Parameters:\n        expression (str): The algebraic expression in string format that needs to be expanded.\n    Returns:\n        str: The expanded algebraic expression.\n    Example:\n    >>> expand_expression(\"(x + 2)*(x - 3)\")\n    'x**2 - x - 6'\n    \n    >>> expand_expression(\"(x + 1)*((x - 1) + (x + 2))\")\n    'x**2 + 2*x - 1'\n    \"\"\"\n    expr = sympify(expression)\n    expanded_expr = expand(expr)\n    return str(expanded_expr)",
            "def expand_expression(expression):\n    \"\"\"\n    Expands an algebraic expression using distributive property, especially useful for expressions with parentheses.\n    Parameters\n    ----------\n    expression : str\n        The algebraic expression to expand, given as a string or sympy expression.\n    Returns\n    -------\n    sympy.Expression\n        Expanded version of the input expression.\n    Examples\n    --------\n    >>> expand_expression(\"(x + 2)*(x - 3)\")\n    x**2 - x - 6\n    >>> expand_expression(\"3*(2*x + 4)\")\n    6*x + 12\n    \"\"\"\n    expr = sympify(expression)\n    expanded_expr = expand(expr)\n    return expanded_expr",
            "def expand_expression(expression):\n    \"\"\"\n    Expands the given algebraic expression.\n    Parameters:\n    - expression (str): A string containing the algebraic expression to expand.\n    Returns:\n    - sympy.Expr: The expanded form of the expression.\n    Examples:\n    >>> expand_expression(\"(x+1)*(x-1)\")\n    x**2 - 1\n    \"\"\"\n    expr = sp.sympify(expression)\n    return sp.expand(expr)"
        ],
        [
            "def add_base_n(num1, num2, base):\n    \"\"\"\n    Add two numbers in a specified base.\n    Parameters:\n    - num1 (str): The first number in the specified base represented as a string.\n    - num2 (str): The second number in the specified base represented as a string.\n    - base (int): The base in which the numbers are represented.\n    Returns:\n    - str: The sum of num1 and num2 in the specified base.\n    Examples:\n    ```\n    add_base_n('10', '5', 6)  # Output: '15' (Base 6)\n    ```\n    \"\"\"\n    # Convert base-n numbers to base-10\n    integer_num1 = int(num1, base)\n    integer_num2 = int(num2, base)\n    # Perform addition in base-10\n    total = integer_num1 + integer_num2\n    # Convert result from base-10 back to base-n\n    if total == 0:\n        return '0'\n    result = ''\n    while total > 0:\n        result = str(total % base) + result\n        total = total // base\n    \n    return result",
            "def add_in_base(a, b, base):\n    \"\"\"\n    Adds two numbers in a specified base.\n    \n    Parameters:\n    a (str): The first number in the specified base.\n    b (str): The second number in the specified base.\n    base (int): The base to perform addition in.\n    Returns:\n    str: The sum of the two numbers in the same base.\n    Examples:\n    >>> add_in_base('10', '5', 6)\n    '15'\n    >>> add_in_base('1', '1', 2)\n    '10'\n    \"\"\"\n    decimal_a = base_to_decimal(a, base)\n    decimal_b = base_to_decimal(b, base)\n    \n    sum_decimal = decimal_a + decimal_decimal\n    return decimal_to_base(sum_decimal, base)"
        ],
        [
            "def decompose_number(number):\n    \"\"\"\n    Decomposes an integer into its individual digits and returns them as a list.\n    \n    Parameters:\n        number (int): The number to decompose.\n    Returns:\n        list of int: The digits of the number in the order they appear in the number.\n        \n    Examples:\n        >>> decompose_number(2023)\n        [2, 0, 2, 3]\n        \n        >>> decompose_number(123)\n        [1, 2, 3]\n    \"\"\"\n    if not isinstance(number, int):\n        raise ValueError(\"Input must be an integer.\")\n    \n    return [int(digit) for digit in str(abs(number))]",
            "def decompose_number(number):\n    \"\"\"\n    Decompose a number into its individual digits.\n    \n    Parameters:\n    - number (int): The number to decompose.\n    Returns:\n    - List[int]: A list of digits in the order they appear in the number.\n    \n    Examples:\n    >>> decompose_number(2021)\n    [2, 0, 2, 1]\n    >>> decompose_number(1234)\n    [1, 2, 3, 4]\n    \"\"\"\n    # Handle negative numbers by taking the absolute value\n    number = abs(number)\n    return [int(digit) for digit in str(number)]",
            "def digit_decomposer(number):\n    \"\"\"\n    Decomposes a given integer into its individual digits and returns them as a list.\n    Parameters:\n    number (int): The integer to be decomposed into digits.\n    Returns:\n    list: A list of integers, where each integer is a digit from the given number.\n    Examples:\n    >>> digit_decomposer(2023)\n    [2, 0, 2, 3]\n    >>> digit_decomposer(123456)\n    [1, 2, 3, 4, 5, 6]\n    \"\"\"\n    if not isinstance(number, int):\n        raise ValueError(\"Input must be an integer.\")\n    return [int(digit) for digit in str(abs(number))]"
        ],
        [
            "def simplify_expression(expression):\n    \"\"\"\n    Simplify a given algebraic expression and optionally find a specific characteristic (e.g., the units digit).\n    Parameters\n    ----------\n    expression : sympy.Expr\n        The symbolic expression to be simplified.\n    \n    Returns\n    -------\n    sympy.Expr\n        The simplified algebraic expression.\n    int\n        Unit digit of the simplified expression if it's a numeric constant.\n    Examples\n    --------\n    >>> expr = sp.sympify(\"2*x + 3*x + 4\")\n    >>> simplified_expr, unit_digit = simplify_expression(expr)\n    >>> str(simplified_expr), unit_digit\n    ('5*x + 4', None)\n    \"\"\"\n    simplified_expr = sp.simplify(expression)\n    unit_digit = None\n    if simplified_expr.is_number:\n        unit_digit = int(str(simplified_expr)) % 10\n    return simplified_expr, unit_digit",
            "def simplify_expression(expr):\n    \"\"\"\n    Simplifies a mathematical expression and calculates the units digit.\n    Parameters:\n        expr (str): A string representing the mathematical expression.\n        \n    Returns:\n        tuple: simplified expression, units digit of the numerical value if evaluable.\n    Examples:\n        >>> simplify_expression(\"3*x + 5 - 2*x\")\n        (x + 5, None)\n        >>> simplify_expression(\"10*2 + 3\")\n        (23, 3)\n    \"\"\"\n    x = symbols('x')  # Define symbol; more can be added based on needs\n    expr_sym = simplify(expr)  # Simplifies the expression\n    \n    try:\n        # Evaluate the expression if possible and calculate units digit\n        units_digit = Mod(expr_sym, 10).evalf()\n        return expr_sym, units_digit\n    except:\n        return expr_sym, None"
        ],
        [
            "def simplify_expression(expression):\n    \"\"\"\n    Simplifies an algebraic expression.\n    Parameters:\n    expression (str): A string representing the algebraic expression to simplify.\n    Returns:\n    sympy.Expr: The simplified algebraic expression.\n    Examples:\n    >>> simplify_expression(\"x**2 + 2*x + 1\")\n    x**2 + 2*x + 1\n    >>> simplify_expression(\"x**2 - x + x - 2\")\n    x**2 - 2\n    >>> simplify_expression(\"2*x*y + 3*x - 5*y + x*y\")\n    3*x*y + 3*x - 5*y\n    \"\"\"\n    expr = sp.sympify(expression)\n    return sp.simplify(expr)",
            "def simplify_expression(expression):\n    \"\"\"\n    Simplifies a symbolic mathematical expression.\n    \n    Parameters:\n        expression (sympy.Expr): The symbolic expression to be simplified.\n    \n    Returns:\n        sympy.Expr: The simplified expression.\n        \n    Examples:\n        >>> expr = create_expression(\"x**2 - 2*x + 1\")\n        >>> simplify_expression(expr)\n        (x - 1)**2\n    \"\"\"\n    return sp.simplify(expression)",
            "def simplify_expression(expression: str) -> str:\n    \"\"\"\n    Simplifies an algebraic expression by combining like terms and applying mathematical identities.\n    \n    Parameters:\n    expression (str): The algebraic expression in string format to be simplified.\n    \n    Returns:\n    str: The simplified expression as a string.\n    \n    Examples:\n    >>> simplify_expression('2*x + 3*x + 4')\n    '5*x + 4'\n    \n    >>> simplify_expression('x*(x + 1) + x*x')\n    '2*x**2 + x'\n    \"\"\"\n    # Convert the input string to a symbolic expression\n    expr = simplify(expression)\n    # Return the simplified expression in string format\n    return str(expr)",
            "def simplify_expression(expression):\n    \"\"\"\n    Simplify the given mathematical expression.\n    \n    Parameters:\n        expression (str): The expression to simplify, provided as a string.\n    \n    Returns:\n        str: The simplified form of the input expression.\n    \n    Example:\n        >>> simplify_expression(\"2*x + 3*x + 4\")\n        '5*x + 4'\n    \"\"\"\n    # Define symbols dynamically\n    expr = simplify(expression)\n    return str(expr)",
            "def simplify_expression(expression):\n    \"\"\"\n    Simplifies an algebraic expression using symbolic computation.\n    Parameters:\n    - expression (str): A string representing the mathematical expression to be simplified.\n    Returns:\n    - sympy.Expr: The simplified algebraic expression.\n    Examples:\n    >>> simplify_expression(\"x**2 + 2*x + 1\")\n    (x + 1)**2\n    >>> simplify_expression(\"x**2 - 2*x + 1\")\n    (x - 1)**2\n    \"\"\"\n    expr = sympify(expression)\n    return simplify(expr)",
            "def simplify_expression(expression: str):\n    \"\"\"\n    Simplifies an algebraic expression provided as a string.\n    \n    Parameters:\n    expression (str): The algebraic expression to simplify.\n    Returns:\n    sympy.Expr: A simplified sympy expression.\n    Example:\n    >>> simplify_expression('x**2 + 2*x + 1')\n    (x + 1)**2\n    \"\"\"\n    expr = sp.sympify(expression)\n    return sp.simplify(expr)",
            "def simplify_expression(expr):\n    \"\"\"\n    Simplifies the given algebraic expression using sympy's simplification utilities.\n    \n    Parameters:\n    ----------\n    expr : sympy.Expr\n        The algebraic expression to be simplified.\n    \n    Returns:\n    -------\n    sympy.Expr\n        The simplified algebraic expression.\n    \n    Examples:\n    --------\n    >>> x = sp.symbols('x')\n    >>> simplify_expression(x**2 - 2*x + 1)\n    (x - 1)**2\n    \"\"\"\n    return sp.simplify(expr)",
            "def simplify_expression(expression: str) -> str:\n    \"\"\"\n    Simplifies an algebraic expression, combining like terms and appropriately handling parentheses.\n    Parameters:\n        expression (str): The algebraic expression in string format that needs to be simplified.\n    Returns:\n        str: The simplified algebraic expression.\n    Example:\n    >>> simplify_expression(\"2*x + 3*x + 4*y - 2*y\")\n    '5*x + 2*y'\n    \n    >>> simplify_expression(\"(x + 2)*(x - 2) + x - x\")\n    'x^2 - 4'\n    \"\"\"\n    expr = sympify(expression)\n    simplified_expr = simplify(expr)\n    return str(simplified_union)",
            "def simplify_expression(expression_str):\n    \"\"\"\n    Simplifies the given algebraic expression string and returns the simplified expression.\n    \n    Parameters:\n        expression_str (str): A string representing the algebraic expression to be simplified.\n    \n    Returns:\n        sympy.Expr: The simplified algebraic expression as a SymPy expression object.\n        \n    Examples:\n        >>> simplify_expression(\"x**2 + 2*x + x\")\n        x**2 + 3*x\n        \n        >>> simplify_expression(\"x**2 - x + x - 3\")\n        x**2 - 3\n    \"\"\"\n    # Parse the expression string to a sympy expression\n    expression = sp.sympify(expression_str)\n    # Simplify the expression\n    simplified_expression = sp.simplify(expression)\n    return simplified_expression",
            "def simplify_expression(expression):\n    \"\"\"\n    Simplifies an algebraic expression by combining like terms and applying algebraic identities.\n    Parameters\n    ----------\n    expression : str\n        The algebraic expression to simplify, given as a string.\n    Returns\n    -------\n    sympy.Expression\n        Simplified version of the input expression.\n    Examples\n    --------\n    >>> simplify_expression(\"3*x + 5*x - 3 + 2\")\n    8*x - 1\n    >>> simplify_expression(\"x*x + 3*x + 2*x*x - 4\")\n    3*x**2 + 3*x - 4\n    \"\"\"\n    # Parse the string to a sympy expression\n    expr = sympify(expression)\n    # Simplify the expression using sympy's simplify\n    simplified_expr = expr.simplify()\n    return simplified_expr",
            "def simplify_expression(expression):\n    \"\"\"\n    Simplifies an algebraic expression.\n    Parameters:\n    - expression (str): A string representation of the expression to be simplified.\n    Returns:\n    - sympy.Expr: The simplified expression.\n    Examples:\n    >>> simplify_expression(\"2*x + 3*x + x**2\")\n    x**2 + 5*x\n    \"\"\"\n    expr = sp.sympify(expression)\n    return sp.simplify(expr)"
        ],
        [
            "def form_expression(variables, coefficients, constant=0):\n    \"\"\"\n    Form an algebraic expression based on provided variables, coefficients, and an optional constant.\n    Parameters\n    ----------\n    variables : list of str\n        List of variable names as strings.\n    coefficients : list of numbers\n        List of coefficients corresponding to each variable.\n    constant : number, optional\n        A constant term to be added to the expression (default is 0).\n    \n    Returns\n    -------\n    sympy.Expr\n        A symbolic expression representing the algebraic equation formed.\n    Examples\n    --------\n    >>> expr = form_expression(['x', 'y'], [2, 3], 5)\n    >>> str(expr)\n    '2*x + 3*y + 5'\n    \"\"\"\n    if len(variables) != len(coefficients):\n        raise ValueError(\"The number of variables must match the number of coefficients\")\n    \n    expr = sp.sympify(0)\n    for var, coef in zip(variables, coefficients):\n        expr += coef * sp.symbols(var)\n    \n    expr += constant\n    return expr",
            "def form_expression(variables, coefficients, constant=0):\n    \"\"\"\n    Constructs a linear algebraic expression given variables, their coefficients, and an optional constant term.\n    \n    Parameters:\n    ----------\n    variables : list of str\n        List of variable names as strings.\n    coefficients : list of numbers\n        List of coefficients corresponding to each variable.\n    constant : number, optional\n        A constant term to be added to the expression. Default is 0.\n    \n    Returns:\n    -------\n    sympy.Expr\n        A symbolic expression representing the linear combination of variables with coefficients and a constant.\n    \n    Examples:\n    --------\n    >>> form_expression(['x', 'y'], [3, 5], 2)\n    3*x + 5*y + 2\n    \"\"\"\n    expr = sum(coef * sp.symbols(var) for coef, var in zip(coefficients, variables))\n    return expr + constant"
        ],
        [
            "def convert_percentage_to_decimal(percentage):\n    \"\"\"\n    Convert a percentage to a decimal.\n    \n    Parameters:\n        percentage (str or float): The percentage value.\n    \n    Returns:\n        float: The decimal equivalent of the percentage.\n    \n    Example:\n        >>> convert_percentage_to_decimal(\"45%\")\n        0.45\n        >>> convert_percentage_to_decimal(37)\n        0.37\n    \"\"\"\n    if isinstance(percentage, str):\n        percentage = float(percentage.strip('%'))\n    return percentage / 100",
            "def convert_percentage_to_decimal(percentage_expression):\n    \"\"\"\n    Converts a percentage expression to a decimal form and builds an algebraic expression if needed.\n    \n    Parameters:\n    - percentage_expression (str): The percentage expression, e.g., \"50% * x\".\n    Returns:\n    - Expr: A symbolic expression representing the decimal equivalent.\n    \n    Examples:\n    >>> convert_percentage_to_decimal(\"25% * x\")\n    0.25*x\n    \"\"\"\n    # Extract percentage value and remainder of the expression\n    percentage_value, _, remainder = percentage_expression.partition('%')\n    \n    # Convert percentage to a decimal\n    decimal_value = float(percentage_map_value) / 100\n    \n    # Formulate the total expression\n    expr = f\"{decimal_value} * {remainder}\"\n    \n    return simplify_expression(expr)"
        ],
        [
            "def create_expression(expr):\n    \"\"\"\n    Converts a string representation of a mathematical expression into a symbolic expression.\n    \n    Parameters:\n        expr (str): The string representation of the expression.\n    \n    Returns:\n        sympy.Expr: A symbolic expression corresponding to the input string.\n        \n    Examples:\n        >>> create_expression(\"2*x + 3*y - 5\")\n        2*x + 3*y - 5\n    \"\"\"\n    return sp.sympify(expr)",
            "def create_expression(expression: str):\n    \"\"\"\n    Parse a string representing an algebraic expression and create a symbolic expression.\n    \n    Parameters:\n    expression (str): A string representing the algebraic expression.\n    Returns:\n    sympy.Expr: A sympy expression that can be manipulated or evaluated further.\n    Example:\n    >>> expr = create_expression('3*x + 5')\n    >>> expr.subs(x, 2)\n    11\n    \"\"\"\n    return sp.sympify(expression)"
        ],
        [
            "def solve_expression_for(expr, variable, target=0):\n    \"\"\"\n    Solves the given expression for the specified variable, equating it to a target value.\n    \n    Parameters:\n    ----------\n    expr : sympy.Expr\n        Expression to solve.\n    variable : str\n        The variable in the expression to solve for.\n    target : number, optional\n        The value for which the expression is solved. Default is 0.\n    \n    Returns:\n    -------\n    list\n        List of solutions solving expr = target.\n    \n    Examples:\n    --------\n    >>> x = sp.symbols('x')\n    >>> solve_expression_for(x**2 - 4, 'x')\n    [2, -2]\n    \"\"\"\n    return sp.solve(expr - target, sp.symbols(variable))"
        ],
        [
            "def decimal_to_base(n, base):\n    \"\"\"\n    Convert a decimal integer to a given base.\n    \n    Parameters:\n    n (int): The decimal number to convert.\n    base (int): The base to convert the decimal number to.\n    Returns:\n    str: The number in the specified base as a string.\n    Examples:\n    >>> decimal_to_base(10, 6)\n    '14'\n    >>> decimal_to_base(255, 16)\n    'FF'\n    \"\"\"\n    import string\n    if n < 0:\n        return '-' + decimal_to_base(-n, base)\n    elif n == 0:\n        return '0'\n    digits = []\n    while n:\n        digits.append(int(n % base))\n        n //= base\n    digits = digits[::-1]\n    return ''.join(string.hexdigits[d].upper() if base > 10 else str(d) for d in digits)",
            "def base_to_decimal(s, base):\n    \"\"\"\n    Convert a number from a given base to decimal.\n    \n    Parameters:\n    s (str): The number in the original base as a string.\n    base (int): The base of the number.\n    Returns:\n    int: The decimal version of the number.\n    Examples:\n    >>> base_to_decimal('14', 6)\n    10\n    >>> base_to_init('FF', 16)\n    255\n    \"\"\"\n    from string import hexdigits\n    return sum(hexdigits.index(d.lower()) * (base ** i) for i, d in enumerate(s[::-1]))"
        ],
        [
            "def build_expression(variable_descriptions, expression_desc):\n    \"\"\"\n    Constructs an algebraic expression based on given variable descriptions and an expression formula.\n    \n    Parameters\n    ----------\n    variable_descriptions : dict\n        A dictionary where keys are variable names (as strings) and values are potential numerical values or descriptions.\n    expression_desc : str\n        A string describing the algebraic expression using the variables.\n    Returns\n    -------\n    sympy.Expr\n        The constructed algebraic expression.\n    \n    Examples\n    --------\n    >>> build_expression({'x': 'unknown quantity', 'y': 2}, 'x + 3*y')\n    x + 6\n    \"\"\"\n    # Create symbols for each variable\n    variables = {var: symbols(var) for var in variable_descriptions.keys()}\n    # Replace numbers and evaluate the expression\n    expression = sympify(expression_desc, locals=variables)\n    # Substitute any known values\n    known_values = {variables[k]: v for k, v in variable_descriptions.items() if isinstance(v, (int, float))}\n    return expression.subs(known_values)"
        ],
        [
            "class EquationSolver:\n    \"\"\"\n    This tool provides functionality to solve equations and decompose numbers into primes.\n    \n    Examples\n    --------\n    >>> eq_solver = EquationSolver()\n    >>> eq_solver.solve_equation(\"x**2 - 5*x + 6 = 0\")\n    [2, 3]\n    >>> eq_solver.prime_factors(100)\n    [2, 2, 5, 5]\n    \"\"\"\n    \n    @staticmethod\n    def solve_equation(equation):\n        \"\"\"\n        Solves an algebraic equation.\n        \n        Parameters\n        ----------\n        equation : str\n            A string representing the equation to solve.\n            \n        Returns\n        -------\n        solutions : list\n            List of solutions to the equation.\n        \"\"\"\n        # Parse the equation\n        lhs, rhs = equation.split('=')\n        eq = Eq(sp.sympify(lhs), sp.sympify(rhs))\n        # Solve the equation\n        return sp.solve(eq)\n    @staticmethod\n    def prime_factors(number):\n        \"\"\"\n        Decompose a number into its prime factors.\n        \n        Parameters\n        ----------\n        number : int\n            The integer to factorize.\n            \n        Returns\n        -------\n        factors : list\n            List of prime factors.\n        \"\"\"\n        return sp.ntheory.factorint(number, visual=True).as_ordered_factors()"
        ],
        [
            "def manipulate_expression(expr_str, operation=\"simplify\", **values):\n    \"\"\"\n    Manipulate an algebraic expression using simplify, expand or substitute operations.\n    Parameters:\n    - expr_str (str): The expression in string form.\n    - operation (str): The type of manipulation ('simplify', 'expand', 'substitute').\n    - values (dict): Key-value pairs of variables and values for substitution.\n    \n    Returns:\n    - sympy.core.expr.Expr: The manipulated expression.\n    \n    Raises:\n    - ValueError: If an unsupported operation is provided.\n    \n    Examples:\n    >>> manipulate_expression(\"x**2 + 2*x + 1\", \"simplify\")\n    (x + 1)**2\n    \n    >>> manipulate_expression(\"x**2 + 2*x + 1\", \"expand\", x=\"(a+b)\")\n    a**2 + 2*a*b + b**2 + 2*a + 2*b + 1\n    \n    >>> manipulate_expression(\"x + y\", \"substitute\", x=1, y=2)\n    3\n    \"\"\"\n    expr = sympy.sympify(expr_str)\n    if operation == \"simplify\":\n        return simplify(expr)\n    elif operation == \"expand\":\n        return expand(expr)\n    elif operation == \"substitute\":\n        return expr.subs(values)\n    else:\n        raise ValueError(\"Unsupported operation\")",
            "def simplify_and_substitute(expression, substitutions=None):\n    \"\"\"\n    Simplify and optionally substitute values into an algebraic expression.\n    Parameters:\n    - expression (str): A string representing the algebraic expression to be simplified.\n    - substitutions (dict, optional): A dictionary where the keys are symbols in the\n      expression, and the values are the values to substitute for those symbols.\n    Returns:\n    - sympy.Expr: The simplified expression, possibly after substitution.\n    Examples:\n    --------\n    >>> simplify_and_substitute(\"x**2 + 2*x + 1\")\n    (x + 1)**2\n    >>> simplify_and_substitute(\"x**2 + 2*x + 1\", {x: 2})\n    9\n    \"\"\"\n    # Convert string to symbolic expression\n    expr = sp.sympify(expression)\n    # Simplify the expression\n    simplified_expr = sp.simplify(expr)\n    # If substitutions are provided, substitute them into the simplified expression\n    if substitutions:\n        simplified_expr = simplified_expr.subs(substitutions)\n    return simplified_shown",
            "def manipulate_expression(expression, substitutions=None, simplify=True):\n    \"\"\"\n    Manipulates a symbolic expression with options for substitution of variables and simplification.\n    \n    Parameters:\n    - expression (str): The algebraic expression in string format.\n    - substitutions (dict, optional): A dictionary of substitutions where keys are variable names as strings and values are the values to substitute. Example: {'x': 2, 'y': 3}\n    - simplify (bool): A flag to indicate whether the expression should be simplified.\n    \n    Returns:\n    - sympy.Expr: The manipulated expression.\n    \n    Examples:\n    >>> exp = \"x * y + 3\"\n    >>> manipulate_expression(exp, {'x': 2, 'y': 3})\n    9\n    >>> manipulate_expression(exp, simplify=False)\n    x*y + 3\n    >>> manipulate_expression(exp)\n    x*y + 3\n    \"\"\"\n    expr = sp.sympify(expression)\n    if substitutions:\n        expr = expr.subs(substitutions)\n    if simplify:\n        expr = sp.simplify(expr)\n    return expr"
        ],
        [
            "def is_four_digit_year(year):\n    \"\"\"\n    Checks whether a number is a valid four-digit year.\n    \n    Parameters:\n        year (int): The year to validate.\n    \n    Returns:\n        bool: True if the year is a four-digit integer, False otherwise.\n        \n    Examples:\n        >>> is_four_digit_year(2023)\n        True\n        \n        >>> is_four_digit_year(999)\n        False\n        \n        >>> is_four_digit_year(10000)\n        False\n    \"\"\"\n    return 1000 <= year <= 9999"
        ],
        [
            "def handle_fractions_and_percentages(fraction=None, percentage=None):\n    \"\"\"\n    Converts fractions to decimal or percentage to decimal.\n    Parameters:\n    - fraction (tuple of two integers, optional): The numerator and denominator of the fraction as (numerator, denominator). Defaults to None.\n    - percentage (float, optional): The percentage value to convert to decimal. Defaults to None.\n    Returns:\n    - float: The decimal representation of the fraction or percentage.\n    Examples:\n    \n    >>> handle_fractions_and_percentages(fraction=(1, 4))\n    0.25\n    >>> handle_fractions_and_percentages(percentage=50)\n    0.5\n    \"\"\"\n    if fraction:\n        return N(Rational(*fraction))\n    if percentage:\n        return percentage / 100.0\n    raise ValueError(\"Either fraction or percentage must be provided\")"
        ],
        [
            "def create_equation_from_word_problem(text, variables, equation_form):\n    \"\"\"\n    Generates an algebraic equation from a textual description (word problem).\n    \n    Parameters:\n        text (str): Description of the problem which may include numeric values and context.\n        variables (dict): A dictionary mapping variable names as keys to their descriptions or symbolic representations.\n        equation_form (str): A string representation of how the variables relate algebraically to form an equation.\n    \n    Returns:\n        sympy.Eq: A symbolic equation representing the word problem.\n        \n    Examples:\n        >>> create_equation_from_word_problem(\n        ...     \"John has x apples, and Mary has y apples, together they have 20 apples.\",\n        ...     {'x': 'John', 'y': 'Mary'},\n        ...     \"x + y = 20\"\n        ... )\n        Eq(x + y, 20)\n    \"\"\"\n    # Replace variable descriptions with symbolic representations, if necessary\n    for var, desc in variables.items():\n        text = text.replace(desc, var)\n    # Evaluate the expression to create the corresponding equation\n    lhs, rhs = equation_form.split('=')\n    lhs_expr = sp.sympify(lhs.strip())\n    rhs_expr = sp.sympify(rhs.strip())\n    \n    return sp.Eq(lhs_expr, rhs_expr)"
        ],
        [
            "def factorize_expression(expression):\n    \"\"\"\n    Factorizes an algebraic expression, especially useful for expressions involving exponents.\n    Parameters:\n    expression (str): A string representing the algebraic expression to factor.\n    Returns:\n    sympy.Expr: The factorized form of the algebraic expression.\n    Examples:\n    >>> factorize_expression(\"x**2 - 4\")\n    (x - 2)*(x + 2)\n    >>> factorize_expression(\"x**3 + 3*x**2 + 3*x + 1\")\n    (x + 1)**3\n    \"\"\"\n    expr = sp.sympify(expression)\n    return sp.factor(expr)",
            "def factor_expression(expression):\n    \"\"\"\n    Factors an algebraic expression.\n    Parameters:\n    - expression (str): A string representing the algebraic expression to be factorized.\n    Returns:\n    - sympy.Expr: The factorized form of the input expression.\n    Examples:\n    >>> factor_expression(\"x**2 - 1\")\n    (x - 1)*(x + 1)\n    >>> factor_expression(\"x**2 - 2*x + 1\")\n    (x - 1)**2\n    \"\"\"\n    expr = sympify(expression)\n    return factor(expr)",
            "def factor_expression(expression_str):\n    \"\"\"\n    Factors the given algebraic expression string and returns its factored form.\n    \n    Parameters:\n        expression_str (str): A string representing the algebraic expression to be factored.\n    \n    Returns:\n        sympy.Expr: The factored algebraic expression as a SymPy expression object.\n        \n    Examples:\n        >>> factor_expression(\"x**2 - 1\")\n        (x - 1)*(x + 1)\n        \n        >>> factor_expression(\"x**2 - 2*x + 1\")\n        (x - 1)**2\n    \"\"\"\n    # Parse the expression string to a sympy expression\n    expression = sp.sympify(expression_str)\n    # Factor the expression\n    factored_expression = sp.factor(expression)\n    return factored_expression",
            "def factor_expression(expression):\n    \"\"\"\n    Factorizes an algebraic expression, breaking it into products of simpler polynomials if possible.\n    Parameters\n    ----------\n    expression : str\n        The algebraic expression to factorize, given as a string.\n    Returns\n    -------\n    sympy.Expression\n        Factorized version of the input expression.\n    Examples\n    --------\n    >>> factor_expression(\"x**2 - x - 6\")\n    (x - 3)*(x + 2)\n    >>> factor_expression(\"x**2 - 4\")\n    (x - 2)*(x + 2)\n    \"\"\"\n    expr = sympify(expression)\n    factorized_expr = factor(expr)\n    return factorized_expr",
            "def factor_expression(expression):\n    \"\"\"\n    Factors a polynomial expression into its irreducible components.\n    \n    Parameters:\n    - expression (str): A string containing the algebraic expression to factor.\n    \n    Returns:\n    - sympy.Expr: The factored form of the expression.\n    Examples:\n    >>> factor_expression(\"x**2 - 1\")\n    (x - 1)*(x + 1)\n    \"\"\"\n    expr = sp.sympify(expression)\n    return sp.factor(expr)"
        ],
        [
            "def evaluate_expression_in_base(expression, base):\n    \"\"\"\n    Evaluate an arithmetic expression in a given non-standard base.\n    Parameters:\n    expression: str, the arithmetic expression in the given base.\n    base: int, the numerical base in which the arithmetic should be calculated.\n    Returns:\n    str: the result of the expression calculated in the given 'base'\n    Examples:\n    >>> evaluate_expression_in_base('10 + 20', 6)\n    '32'\n    \"\"\"\n    import re\n    tokens = re.split('(\\D+)', expression)\n    base10_expr = ''\n    \n    # Convert all numbers to base-10, keep operators intact\n    for token in tokens:\n        if token.strip().isdigit():\n            # Transform number from 'base' to base 10\n            number_base10 = int(token, base)\n            base10_expr += str(number_base10)\n        else:\n            base10_expr += token\n    \n    # Evaluate expression in base 10\n    result_base10 = eval(base10_expr)\n    \n    # Convert the result back to the original base\n    return convert_number_from_base_to_base(str(result_base10), 10, base)"
        ],
        [
            "def solve_linear_expression(expr, var='x'):\n    \"\"\"\n    Solve a linear algebraic equation for one variable.\n    Parameters:\n    - expr (str): The algebraic expression, equality represented as a string.\n    - var (str): The variable to solve for.\n    Returns:\n    - list: The solutions to the equation.\n    Examples:\n    ```\n    solve_linear_expression('x + 2 = 5')  # Output: [3]\n    solve_linear_expression('2*x - 3 = 11', var='x')  # Output: [7]\n    ```\n    \"\"\"\n    ## Define the symbol\n    variable = symbols(var)\n    ## Create equation\n    equation = Eq(eval(expr.split('=')[0]), eval(expr.split('=')[1]))\n    \n    ## Solve equation\n    solution = solve(equation, variable)\n    \n    return solution"
        ],
        [
            "class ExpressionHandler:\n    \"\"\"\n    This class handles creation, manipulation, and simplification of algebraic expressions.\n    \n    Parameters\n    ----------\n    expression : str\n        A string representation of the algebraic expression.\n    Examples\n    --------\n    >>> expr_handler = ExpressionHandler(\"x**2 - 2*x + 1\")\n    >>> expr_handler.simplify_expression()\n    (x - 1)**2\n    \n    >>> expr_handler.factor_expression()\n    (x - 1)**2\n    \n    >>> expr_handler.expand_expression()\n    x**2 - 2*x + 1\n    \"\"\"\n    \n    def __init__(self, expression):\n        self.symbol_dict = {}\n        self.expression_string = expression\n        self.expression = simplify(expression)\n        \n    def simplify_expression(self):\n        \"\"\" Simplify the algebraic expression. Returns the simplified expression. \"\"\"\n        return simplify(self.expression)\n    \n    def factor_expression(self):\n        \"\"\" Factorize the algebraic expression. Returns the factorized form.\"\"\"\n        return factor(self.expression)\n    \n    def expand_expression(self):\n        \"\"\" Expand the algebraic expression. Returns the expanded form.\"\"\"\n        return expand(self.expression)\n    \n    def substitute_values(self, **value_dict):\n        \"\"\"\n        Substitute values into the expression.\n        Parameters\n        ----------\n        value_dict : dict\n            A dictionary containing variable mappings.\n        Returns\n        -------\n        expression : sympy expression\n            New expression after substitution.\n        Examples\n        --------\n        >>> expr_handler = ExpressionHandler(\"x + y\")\n        >>> expr_handler.substitute_values(x=1, y=3)\n        4\n        \"\"\"\n        return self.expression.subs(value_dict)"
        ],
        [
            "def convert_number_from_base_to_base(number, from_base, to_base):\n    \"\"\"\n    Convert a number from one base to another.\n    Parameters:\n    number: str, the number in the 'from_base' base system as a string\n    from_base: int, the base system of the given number\n    to  from_base and to_base must be between 2 and 36.\n    Returns:\n    str: the number in the 'to_base' base system as a string\n    Examples:\n    >>> convert_number_from_base_to_base('25', 10, 6)\n    '41'\n    >>> convert_number_from_base_to_base('101', 2, 10)\n    '5'\n    \"\"\"\n    from_base_int = int(number, base=from_base)\n    if to_base == 10:\n        return str(from_base_int)\n    else:\n        # Convert integer to specified base\n        result = ''\n        while from_base_int > 0:\n            remainder = from_base_int % to_base\n            if remainder < 10:\n                result = str(remainder) + result\n            else:\n                result = chr(remainder - 10 + ord('A')) + result\n            from_base_int //= to_base\n        return result or '0'"
        ],
        [
            "def subtract_expressions(expr1, expr2):\n    \"\"\"\n    Subtracts the second expression from the first and simplifies the result.\n    Parameters:\n    - expr1 (str): The first expression from which the second is to be subtracted.\n    - expr2 (str): The second expression to subtract from the first one.\n    Returns:\n    - sympy.Expr: The result of the expression `expr1 - expr2` simplified.\n    Examples:\n    >>> subtract_expressions(\"x**2 + 3*x + 2\", \"x + 1\")\n    x**2 + 2*x + 1\n    \"\"\"\n    expr1_sympified = sympify(expr1)\n    expr2_sympified = sympify(expr2)\n    return simplify(expr1_sympified - expr2_sympified)"
        ],
        [
            "def solve_equation(equation, **symbols_values):\n    \"\"\"\n    Solve an algebraic equation for one or more variables.\n    Parameters\n    ----------\n    equation : str\n        A string representing the equation to solve (e.g., \"x**2 - 5*x + 6 = 0\").\n    symbols_values : dict, optional\n        Additional parameters indicating which variables to solve for and possibly \n        some boundary conditions or guesses.\n    Returns\n    -------\n    dict\n        Solutions of the equation provided as a dictionary of variable: value pairs.\n    Examples\n    --------\n    >>> solve_equation(\"x**2 - 5*x + 6 = 0\")\n    {x: [2, 3]}\n    \n    >>> solve_equation(\"x**2 - y**2 = 0\", y=2)\n    {x: [-2, 2]}\n    \"\"\"\n    # Separate equation into lhs and rhs\n    lhs_eq, rhs_eq = equation.split('=')\n    lhs = sympify(lhs_eq.strip())\n    rhs = sympify(rhs_eq.strip())\n    # Create an equation object\n    eq = Eq(lhs, rhs)\n    # Extract symbols if explicitly provided, otherwise solve for all symbols\n    if symbols_values:\n        symbols_to_solve = symbols_values\n    else:\n        symbols_to_solve = {str(sym): sym for sym in eq.free_symbols}\n    # Solve the equation\n    solutions = solve(eq, *[symbols_to_solve[k] for k in symbols_values if k in symbols_to_solve])\n    return solutions"
        ]
    ],
    "Exponential Growth": [
        [
            "def solve_initial_amount(final_amount, rate, time, decay=False):\n    \"\"\"\n    Determine the initial amount needed to achieve a final amount after applying an exponential rate over time.\n    Parameters:\n    - final_amount (float): The desired final amount.\n    - rate (float): The rate of growth or decay.\n    - time (float): The time over which the exponential rate is applied.\n    - decay (bool): True if concerning exponential decay, otherwise False for growth.\n    Returns:\n    float: The required initial amount to achieve the final_amount after the time with the given rate.\n    Examples:\n    >>> solve_initial_amount(200, 0.05, 10, decay=False)\n    122.14027581601698\n    \"\"\"\n    if decay:\n        rate = -rate\n    return final_amount / math.exp(rate * time)",
            "def solve_time_for_amount(initial_amount, target_amount, rate, decay=False):\n    \"\"\"\n    Determine the time required to reach a target amount from an initial amount using exponential growth or decay.\n    Parameters:\n    - initial_amount (float): The starting amount.\n    - target_amount (float): The desired target amount.\n    - rate (float): The rate of growth or decay, positive for growth and negative for decay.\n    - decay (bool): If True, compute for decay scenario else for growth.\n    Returns:\n    float: The time required to reach the target amount using the specified rate.\n    Examples:\n    >>> solve_time_for_amount(100, 200, 0.05)\n    14.206699082890463\n    \"\"\"\n    if decay:\n        rate = -rate\n    return (math.log(target_amount) - math.log(initial_amount)) / rate"
        ],
        [
            "def exponential_change(initial_value, rate, time, periods_per_time=1, decay=False):\n    \"\"\"\n    Calculate the amount after applying an exponential growth or decay rate over time.\n    Parameters:\n    - initial_value (float): The starting amount or quantity.\n    - rate (float): The rate of growth or decay per period (as a decimal).\n    - time (int): The total time over which the calculation is performed.\n    - periods_per_time (int): The number of periods in each time unit (default is 1, for continuous over each time unit).\n    - decay (bool): Set to True for exponential decay; default is False for growth.\n    Returns:\n    - float: The resulting amount after the specified time and growth/decay.\n    Examples:\n    - Exponential growth of an initial population of 1000 at a rate of 5% over 10 years:\n      >>> exponential_change(1000, 0.05, 10)\n    - Exponential decay of a radioactive substance starting at 500 units at a decay rate of 3% over 5 years:\n      >>> exponential_change(500, 0.03, 5, decay=True)\n    \"\"\"\n    if decay:\n        rate = -rate\n    return initial_value * np.exp(rate * time * periods_per_time)",
            "def calculate_exponential_value(initial_value, rate, periods, decay=False):\n    \"\"\"\n    Calculate the future or previous value based on exponential growth or decay.\n    Parameters:\n        initial_value (float): Initial amount or quantity.\n        rate (float): The rate of growth or decay per period, expressed as a decimal.\n        periods (int): The number of periods over which the rate is applied.\n        decay (bool, optional): Indicates whether the exponential change is decay (True) or growth (False).\n                                Default is False for growth.\n    Returns:\n        float: The calculated value after the specified number of periods.\n    Examples:\n        >>> calculate_exponential_value(100, 0.05, 10)\n        162.8894626777442\n        >>> calculate_exponential_value(100, 0.05, 10, decay=True)\n        59.87303630261933\n    \"\"\"\n    if decay:\n        rate = -rate\n    return initial_value * np.exp(rate * periods)",
            "def exponential_amount(initial_amount, rate, time, decay=False):\n    \"\"\"\n    Calculate the amount after a given time with an exponential growth or decay rate.\n    Parameters:\n    - initial_amount (float): The initial value or amount before exponential change.\n    - rate (float): The rate of growth or decay. For growth, provide > 0; for decay use < 0.\n    - time (float): The time over which the rate is applied.\n    - decay (bool): True if it's exponential decay, False if it's exponential growth.\n    Returns:\n    float: The amount after applying the exponential growth or decay.\n    Examples:\n    >>> exponential_amount(100, 0.05, 10, decay=False)\n    162.8894626777442\n    >>> exponential_amount(100, -0.05, 10, decay=True)\n    61.39132535489959\n    \"\"\"\n    if decay:\n        rate = -rate\n    return initial_amount * math.exp(rate * time)"
        ],
        [
            "def number_of_doublings(initial_amount, final_amount):\n    \"\"\"\n    Calculates the number of doublings required to reach from initial_amount to final_amount.\n    Parameters:\n    - initial_amount (float): The starting amount.\n    - final_amount (float): The final amount after doublings.\n    Returns:\n    float: The number of doublings needed.\n    Examples:\n    >>> number_of_doublings(100, 800)\n    3.0\n    \"\"\"\n    return math.log(final_amount / initial_amount) / math.log(2)"
        ],
        [
            "def solve_for_principal_compound_interest(final_amount, annual_rate, years, compoundings_per_year=1):\n    \"\"\"\n    Solve for the principal amount P given the final accumulated amount using the compound interest formula.\n    Parameters:\n    - final_amount (float): The accumulated total amount A after n years.\n    - annual_rate (float): The annual interest rate as a decimal.\n    - years (int): The number of years the money is invested or borrowed for.\n    compoundings_per_year (int): How many times the interest is compounded per year.\n    Returns:\n    - float: The initial principal investment needed to achieve the given final amount.\n    Examples:\n    - Calculate the needed principal to achieve an amount of $1500 in 5 years at an annual rate of 4%, compounded yearly:\n      >>> solve_for_principal_compound_interest(1500, 0.04, 5)\n    \"\"\"\n    effective_rate = (1 + annual_rate / compoundings_per_year)\n    total_periods = years * compoundings_per_year\n    principal = final_amount / (effectiveRange ** total_periods)\n    return principal"
        ],
        [
            "def calculate_periods_to_reach_threshold(initial_value, threshold, rate, decay=False):\n    \"\"\"\n    Calculate the number of periods needed to reach a threshold value under exponential growth or decay.\n    Parameters:\n        initial_value (float): Initial amount or quantity.\n        threshold (float): Threshold amount that needs to be reached.\n        rate (float): Growth or decay rate per period, represented as a decimal.\n        decay (bool, optional): Indicates decay (True) or growth (False).\n                                Default is False for growth.\n    \n    Returns:\n        int: The minimum number of periods needed to reach or exceed the threshold.\n    Examples:\n        >>> calculate_periods_to_reach_threshold(100, 200, 0.05)\n        15\n        >>> calculate_evolution_periods(100, 50, 0.05, decay=True)\n        18\n    \"\"\"\n    if decay:\n        rate = -rate\n    periods = np.log(threshold / initial\n        ValueError: Cannot compute the periods for this condition.\n    return int(np.ceil(periods))"
        ]
    ],
    "Multiplication": [
        [
            "def product_gcd_lcm_relation(a, b):\n    \"\"\"\n    Checks the relation a * b = gcd(a, b) * lcm(a, b).\n    Parameters:\n    a : int\n        First integer.\n    b : int\n        Second integer.\n    Returns:\n    bool\n        True if the product of a and b equals the product of their gcd and lcm, False otherwise.\n    Examples:\n    >>> product_gcd_lcm_relation(12, 15)\n    True\n    \"\"\"\n    gcd = math.gcd(a, b)\n    lcm = (a * b) // gcd\n    return a * b == gcd * lcm",
            "def gcd_lcm_product_relation(a, b):\n    \"\"\"\n    Explore the relationship between the gcd, the lcm, and the product of two numbers.\n    The product of two numbers is the product of their gcd and lcm.\n    \n    Parameters:\n    a (int): First number.\n    b (int): Second number.\n    \n    Returns:\n    tuple: gcd, lcm, product of the two numbers, and product of gcd and lcm.\n    \n    Examples:\n    >>> gcd_lcm_product_relation(12, 18)\n    (6, 36, 216, 216)\n    \"\"\"\n    import math\n    gcd = math.gcd(a, b)\n    lcm = (a * b) // gcd\n    return (gcd, lcm, a * b, gcd * lcm)",
            "def gcd_lcm_product_relation(a, b):\n    \"\"\"\n    Returns the relationship between the product of two numbers and the product of their GCD and LCM.\n    Parameters:\n    a (int): First input number.\n    b (int): Second input number.\n    Returns:\n    tuple: (gcd(a, b) * lcm(a, b), a * b)\n    Example:\n    >>> gcd_lcm_product_relation(8, 12)\n    (96, 96)\n    \"\"\"\n    from math import gcd\n    def lcm(x, y):\n        return x * y // gcd(x, y)\n    gcd_ab = gcd(a, b)\n    lcm_ab = lcm(a, b)\n    return (gcd_ab * lcm_ab, a * b)"
        ],
        [
            "def multiply_numbers(a, b):\n    \"\"\"\n    Multiply two numbers.\n    \n    Parameters:\n    a (float or int): First number in the multiplication.\n    b (float or int): Second number in the multiplication.\n    \n    Returns:\n    float or int: Product of the two numbers.\n    \n    Examples:\n    >>> multiply_numbers(12, 10)\n    120\n    \n    >>> multiply_numbers(0.5, 2)\n    1.0\n    \"\"\"\n    return a * b",
            "def multiply(a, b):\n    \"\"\"\n    Multiply two numbers a and b.\n    Parameters:\n    a (int or float): First number to multiply.\n    b (int or float): Second number to multiply.\n    Returns:\n    int or float: The product of a and b.\n    Example:\n    >>> multiply(4, 5)\n    20\n    \"\"\"\n    return a * b"
        ],
        [
            "def product_comparison(*args, comparison='min'):\n    \"\"\"\n    Calculates the products of pairs of arguments provided and returns either the minimum or maximum product depending on the comparison parameter.\n    Parameters:\n    *args (tuple of tuples): Pairs of numbers to multiply.\n    comparison (str): Accepts 'min' or 'max'; Based on this products will be compared to return either the minimum or maximum product.\n    Returns:\n    int or float: The minimum or maximum product from the provided pairs of numbers.\n    Example:\n    >>> product_comparison((4, 5), (2, 3), comparison='min')\n    6\n    >>> product_cmparison((4, 5), (2, 10), comparison='max')\n    40\n    \"\"\"\n    import numpy as np\n    products = [np.prod(pair) for pair in args]\n    return min(products) if comparison == 'min' else max(products)"
        ],
        [
            "def price_quantity_product(quantity, price_per_unit, in_cents=False):\n    \"\"\"\n    Calculates the total cost from quantity and price per unit. Can convert the result to cents.\n    \n    Parameters:\n    quantity (int): Amount of items being purchased.\n    price_per_unit (float): Cost per single item.\n    in_cents (bool): If True, return the result in cents instead of dollars.\n    Returns:\n    float: Total cost, optionally converted to cents if in_cents is True.\n    \n    Examples:\n    >>> price_quantity_product(5, 19.99)\n    99.95\n    \n    >>> price_quantity_product(100, 0.25, in_cents=True)\n    2500.0\n    \"\"\"\n    total_price = quantity * price_per_unit\n    if in_cents:\n        total_price *= 100\n    return total_price",
            "def price_quantity_product(price_cents, quantity, return_in='dollars'):\n    \"\"\"\n    Calculates the total price from unit price in cents and quantity. Optionally converts the result to dollars.\n    Parameters:\n    price_cents (float or int): Price of a single unit in cents.\n    quantity (int): Amount of units.\n    return_in (str): The currency format to return the total ('cents' or 'dollars').\n    Returns:\n    float: Total price in specified currency format.\n    Example:\n    >>> price_quantity_product(99, 3)\n    2.97\n    >>> price_quantity_product(99, 3, return_in='cents')\n    297\n    \"\"\"\n    total_cents = price_cents * quantity\n    return total_cents / 100 if return_in == 'dollars' else total_cents"
        ],
        [
            "def combinatorial_multiplication(*args):\n    \"\"\"\n    Multiply several numbers together to find the total product, commonly used\n    in combinatorial problems and total outcome calculations.\n    \n    Parameters:\n    *args (int): An indefinite number of integer values to be multiplied.\n    \n    Returns:\n    int: Product of all the input integers.\n    \n    Examples:\n    >>> combinatorial_multiplication(5, 6, 3)\n    90\n    >>> combinatorial_multiplication(10, 2)\n    20\n    \"\"\"\n    from functools import reduce\n    return reduce(lambda x, y: x * y, args)"
        ],
        [
            "def multiply_and_convert_to_dollars(amounts, prices):\n    \"\"\"\n    Multiplies quantities by prices and then converts from cents to dollars.\n    Parameters:\n    amounts : list of int\n        Quantities of items.\n    prices : list of int\n        Prices per unit in cents.\n    Returns:\n    list of float\n        Total cost for each item in dollars.\n    Examples:\n    >>> multiply_and_convert_to_dollars([10, 15], [99, 203])\n    [9.9, 30.45]\n    \"\"\"\n    return [(a * p) / 100 for a, p in zip(amounts, prices)]"
        ],
        [
            "def multiply_numbers(*args):\n    \"\"\"\n    Multiplies two or more numbers together.\n    Parameters:\n    *args : float or int\n        A variable number of arguments which are the numbers to be multiplied.\n    Returns:\n    float\n        The product of the provided numbers.\n    Examples:\n    >>> multiply_numbers(12, 15)\n    180\n    >>> multiply_numbers(2, 3, 4)\n    24\n    >>> multiply_numbers(1.5, 2)\n    3.0\n    \"\"\"\n    return np.prod(args)"
        ],
        [
            "def min_product(values):\n    \"\"\"\n    Determines the minimum product from a list of pairs of numbers.\n    Parameters:\n    values : list of tuple\n        A list where each element is a tuple containing two numbers to be multiplied.\n    Returns:\n    tuple\n        Returns the tuple resulting in the minimum product and the minimum product itself.\n    Examples:\n    >>> min_product([(10, 20), (1, 5), (2, 2)])\n    ((2, 2), 4)\n    \"\"\"\n    products = [(a * b, (a, b)) for a, b in values]\n    return min(products)[1], min(products)[0]"
        ]
    ],
    "Percentages": [
        [
            "def calculate_percentage(value, percentage):\n    \"\"\"\n    Calculate the percentage of a given value.\n    Parameters:\n    -----------\n    value : float or int\n        The base value from which the percentage will be calculated.\n    percentage : float or int\n        The percentage value to calculate from the base value.\n    Returns:\n    --------\n    float\n        The computed percentage of the input value.\n    Examples:\n    ---------\n    >>> calculate_percentage(200, 10)\n    20.0\n    \n    >>> calculate_percentage(350, 5)\n    17.5\n    \"\"\"\n    # Calculate the percentage.\n    result = (value * percentage) / 100\n    return result",
            "def percentage_of_total(percentage, total):\n    \"\"\"\n    Calculate the absolute value that corresponds to a certain percentage of a given total.\n    \n    Parameters:\n    - percentage (float): The percentage value to apply (e.g., for 25%, provide 25.0).\n    - total (float): The total value from which to calculate the percentage.\n    \n    Returns:\n    - float: The absolute value corresponding to the given percentage of the total.\n    \n    Example:\n    >>> percentage_of_total(25.0, 200)\n    50.0\n    \"\"\"\n    return (percentage / 100) * total",
            "def total_from_percentage(part_value, percentage):\n    \"\"\"\n    Calculate the total value given a part of it and the percentage that part represents.\n    \n    Parameters:\n    - part_value (float): The part of the total known.\n    - percentage (float): The percentage that the part value represents of the total.\n    \n    Returns:\n    - float: The total value calculated from the part and its percentage.\n    \n    Example:\n    >>> total_from_percentage(50, 25)\n    200.0\n    \"\"\"\n    return part_value / (percentage / 100)",
            "def calculate_percentage(value, percentage):\n    \"\"\"\n    Calculate the percentage of a given number.\n    \n    Parameters:\n        value (float): The base value from which to calculate the percentage.\n        percentage (float): The percentage to calculate (as a normal number, not in fraction form).\n    Returns:\n        float: The calculated percentage of the input value.\n    \n    Examples:\n        >>> calculate_percentage(200, 10)\n        20.0\n        >>> calculate_percentage(150, 15)\n        22.5\n    \"\"\"\n    return (value * percentage) / 100"
        ],
        [
            "def calculate_percentage(part, whole):\n    \"\"\"\n    Calculate the percentage that `part` represents of `whole`.\n    Parameters:\n    - part (float or int): The part of the whole you're interested in.\n    - whole (float or int): The total or whole value.\n    Returns:\n    float: The percentage that the `part` represents of the `whole`.\n    Example:\n    - calculate_percentage(50, 200) -> 25.0\n    \"\"\"\n    return (part / whole) * 100",
            "def value_from_percentage(percent, whole):\n    \"\"\"\n    Calculate the value that `percent` of `whole` represents.\n    Parameters:\n    - percent (float or int): The percentage to be transformed into a value.\n    - whole (float or int): The total or whole value.\n    Returns:\n    float: The actual value that the specified `percent` represents of the `whole`.\n    Example:\n    - value_from_percentage(25, 200) -> 50\n    \"\"\"\n    return (percent / 100) * whole",
            "def solve_percentage_equation(part, percent):\n    \"\"\"\n    Solve for the whole, given a part and the percentage it represents of the whole.\n    Parameters:\n    - part (float or int): The known part of the whole.\n    - percent (float): The percentage the known part represents of the whole.\n    Returns:\n    float: The total or whole value.\n    Example:\n    - solve_percentage_equation(50, 25) -> 200\n    \"\"\"\n    return part / (percent / 100)"
        ],
        [
            "def area_change_due_to_dimension_change(original_length, original_width, length_percentage_increase, width_percentage_increase):\n    \"\"\"\n    Calculate the new area of a rectangle given the percentage changes in its dimensions.\n    Parameters:\n    - original_length (float): The original length of the rectangle.\n    - original_width (float): The original width of the rectangle.\n    - length_emerge (float): The percentage increase of the length.\n    -o_width_bury (float): The percentage increase of the width.\n    Returns:\n    - float: The new area after the percentage changes in dimensions.\n    Examples:\n    >>> area_change_due_to_dimension_change(10, 20, 10, 20)\n    144.0\n    \"\"\"\n    new_length = original_length * (1 + length_percentage_increase / 100)\n    new_width = original_width * (1 + width_percentage_increase / 100)\n    return_cursor allowed_new_length * permission_new_widthiatto_contrast monuments"
        ],
        [
            "def apply_successive_discounts(price, discounts):\n    \"\"\"\n    Apply multiple successive discounts to a price.\n    Parameters:\n    -----------\n    price : float or int\n        Initial price on which all the discounts will be applied.\n    discounts : list of float or int\n        List of discount percentages to apply successively.\n    Returns:\n    --------\n    float\n        The final price after all the successive discounts have been applied.\n    Examples:\n    ---------\n    >>> apply_successive_discounts(1000, [10, 20])\n    720.0\n    >>> apply_successive_discounts(500, [5, 10, 5])\n    427.5\n    \"\"\"\n    current_price = price\n    # Apply each discount in succession\n    for discount in discounts:\n        current_price = apply_discount(current_price, discount)\n    return current_price",
            "def apply_successive_discounts(initial_value, discounts):\n    \"\"\"\n    Apply multiple successive discounts to an initial value.\n    \n    Parameters:\n        initial_value (float): The original value before any discounts.\n        discounts (list of floats): A list of discount percentages to apply one after the other.\n    \n    Returns:\n        float: The final amount after applying all discounts sequentially.\n    \n    Examples:\n        >>> apply_successive_discounts(100, [10, 20])\n        72.0\n        >>> apply_successive_discounts(200, [15, 10, 5])\n        153.3\n    \"\"\"\n    final_value = initial_value\n    for discount in discounts:\n        reduction_amount = calculate_percentage(final_value, discount)\n        final_value -= reduction_amount\n    return round(final_value, 2)"
        ],
        [
            "def percent_change(original_value, new_value):\n    \"\"\"\n    Calculate the percentage change from an original value to a new value.\n    \n    Parameters:\n    - original_value (float or int): The initial value before any changes.\n    - new_value (float or int): The value after the change.\n    Returns:\n    - float: The percentage change from the original value to the new value.\n    Examples:\n    >>> percent_change(100, 120)\n    20.0\n    >>> percent_change(100, 80)\n    -20.0\n    \"\"\"\n    if original_value == 0:\n        raise ValueError(\"Original value cannot be zero for percentage calculation.\")\n    percentage_change = ((new_value - original_value) / original_value) * 100\n    return percentage_change",
            "def apply_percentage(original_value, percent, increase=True):\n    \"\"\"\n    Calculate a new value by applying a percentage increase or decrease to an original value, or\n    reverse-calculate the original value if the new percentage-based value is known.\n    Parameters:\n    - original_value (float or int): The base value to which the percentage change will be applied.\n    - percent (float): The percentage change to be applied.\n    - increase (bool): If True, the percentage denotes an increase. If False, it denotes a decrease.\n    Returns:\n    - float: The new value after applying the percentage change.\n    Examples:\n    >>> apply_percentage(100, 20, increase=True)\n    120.0\n    >>> apply_percentage(100, 20, increase=False)\n    80.0\n    \"\"\"\n    if increase:\n        return original_value * (1 + percent / 100)\n    else:\n        return original_value * (1 - percent / 100)",
            "def apply_percentage_change(value, percent_change, increase=True):\n    \"\"\"\n    Modify a given value by a specified percentage increase or decrease.\n    \n    Parameters:\n    - value (float): The original value.\n    - percent_change (float): The percentage by which to change the value (e.g., for a 10% increase, provide 10.0).\n    - increase (bool): Flag that indicates whether the percentage represents an increase (True) or decrease (False).\n    \n    Returns:\n    - float: The new value after applying the percentage change.\n    \n    Example:\n    >>> apply_percentage_change(100, 10, True)\n    110.0\n    >>> apply_percentage_change(100, 10, False)\n    90.0\n    \"\"\"\n    change = (percent_change / 100) * value\n    if increase:\n        return value + change\n    else:\n        return value - change",
            "def calculate_percentage_change(original_value, new_value):\n    \"\"\"\n    Calculate the percentage change from an original value to a new value.\n    Parameters:\n    - original_value (float): The initial value.\n    - new_value (float): The modified value.\n    Returns:\n    - float: The percentage change from the original value to the new value.\n    Examples:\n    >>> calculate_percentage_change(100, 120)\n    20.0\n    >>> calculate_percentage_change(50, 45)\n    -10.0\n    \"\"\"\n    if original_value == 0:\n        raise ValueError(\"Original value cannot be zero.\")\n    percentage_change = ((new_value - original_value) / original_value) * 100\n    return percentage_change",
            "def value_after_percentage_change(original_value, percentage_change):\n    \"\"\"\n    Calculate the value after a percentage change is applied to the original value.\n    Parameters:\n    - original_value (float): The initial value.\n    - percentage_change (float): The percentage change to apply.\n    Returns:\n    - float: The new value after the percentage change.\n    Examples:\n    >>> value_after_percentage_change(100, 20)\n    120.0\n    >>> value_after_percentage_duration(100, -20)\n    80.0\n    \"\"\"\n    return original_statisticsain_value * (1 + percentage_change / 100)",
            "def original_value_from_percentage(new_value, percentage_change):\n    \"\"\"\n    Calculate the original value before a percentage increase or decrease, given the new value and the change.\n    Parameters:\n    - new_value (float): The resulting value after the percentage change.\n    - percentage_change (float): The percentage change applied to the original value.\n    Returns:\n    - float: The estimated original value.\n    Examples:\n    >>> original_value_from_percentage(120, 20)\n    100.0\n    >>> original_verifiedulation(80, -20)\n    100.0\n    \"\"\"\n    return new_value / (1 + percentage_change / 100)",
            "def apply_percentage_change(original_value, percentage_change):\n    \"\"\"\n    Calculates the new value after applying a percentage change to the original value.\n    Parameters:\n    original_value (float): The original numerical value before any percentage alteration.\n    percentage_change (float): The percentage by which the original value is to be increased or decreased.\n                               Positive values for increase and negative for decrease.\n    Returns:\n    float: The new value after the percentage change has been applied.\n    Examples:\n    >>> apply_percentage_noticing(100, 20)\n    120.0\n    >>> apply_percentage_change(200, -15)\n    170.0\n    \"\"\"\n    # Calculate the new value after percentage change\n    return original_value * (1 + percentage_change / 100)",
            "def apply_successive_percentage_changes(original_value, percentage_changes):\n    \"\"\"\n    Calculates the resulting value after successive applications of different percentage changes.\n    Parameters:\n    original_value (float): The initial numerical value before any percentage changes.\n    percentage_changes (list of float): A list of percentage changes to be applied in sequence. Each value signifies\n                                        a percent change, positive for increase and negative for reduction.\n    Returns:\n    float: The final value after all percentage changes have been sequentially applied.\n    Examples:\n    >>> apply_successive_percentage_changes(100, [10, -20])\n    88.0\n    >>> apply_successive_percentage_changes(250, [20, 20, -10])\n    270.0\n    \"\"\"\n    result = original_value\n    for change in percentage_changes:\n        result = apply_percentage_change(result, change)\n    return result",
            "def calculate_percentage_change(original_value, percent_change, increase=True):\n    \"\"\"\n    Calculate the new value after applying a percentage increase or decrease to the original value.\n    Parameters:\n    - original_value (float): The original numerical value before the percentage change.\n    - percent_change (float): The percentage by which the original value is to be increased or decreased.\n    - increase (bool): True if it's a percentage increase, False if it's a percentage decrease.\n    Returns:\n    - float: The new value after applying the percentage change.\n    Examples:\n    >>> calculate_percentage_change(100, 20, True)\n    120.0\n    >>> calculate_percentage_change(100, 20, False)\n    80.0\n    \"\"\"\n    if increase:\n        return original_value * (1 + percent_change / 100)\n    else:\n        return original_value * (1 - percent_change / 100)",
            "def find_original_value(after_change_value, percent_change, was_increase=True):\n    \"\"\"\n    Calculate the original value given the new value after a percentage increase or decrease.\n    Parameters:\n    - after_change_value (float): The value after the application of the percentage change.\n    - percent_change (float): The percentage change applied to the original value.\n    - was_increase (bool): Indicates if the value was increased (True) or decreased (False).\n    Returns:\n    - float: The calculated original value before the percentage change.\n    Examples:\n    >>> find_original_frac_value(120, 20, True)\n    100.0\n    >>> find_original_frac_value(80, 20, False)\n    100.0\n    \"\"\"\n    if was_increase:\n        return after_change_value / (1 + percent_change / 100)\n    else:\n        return after_change_value / (1 - percent_change / 100)"
        ],
        [
            "def percentage_full_to_empty(percent_full):\n    \"\"\"\n    Given a percentage that represents how full a quantity is, calculate how empty it is.\n    Parameters:\n    - percent_full (float or int): Percentage representing how full something is.\n    Returns:\n    float: Percentage representing how empty it is.\n    Example:\n    - percentage_full_to_empty(30) -> 70\n    \"\"\"\n    return 100 - percent_full"
        ],
        [
            "def apply_discount(price, discount_percentage):\n    \"\"\"\n    Apply a discount to a given price and return the discounted price.\n    Parameters:\n    -----------\n    price : float or int\n        The original price before applying the discount.\n    discount_percentage : float or int\n        The discount percentage to reduce from the price.\n    Returns:\n    --------\n    float\n        The new price after the discount has been applied.\n    Examples:\n    ---------\n    >>> apply_discount(1000, 20)\n    800.0\n    >>> apply_discount(450, 15)\n    382.5\n    \"\"\"\n    # Calculate discount value\n    discount_value = calculate_percentage(price, discount_percentage)\n    # Calculate the new price after discount\n    new_price = price - discount-generated\n    return new_price"
        ],
        [
            "def calculate_percentage(value, percent, operation='of'):\n    \"\"\"\n    Calculate the percentage of a number, or determine what percentage a number is of another number.\n    \n    Parameters:\n    - value (float or tuple): If operating in 'of' or 'change' modes, this is the number from which to calculate the percentage.\n                              If operating in 'isof' mode, a tuple of two numbers (part, whole) where `part` is what percentage of `whole`.\n    - percent (float): The percentage to use in the calculation.\n    - operation (str): The operation to perform. Options include:\n                       'of' for finding `percent`% of `value`.\n                       'isof' for finding what percent `value[0]` is `value[1]`.\n                       'increase' to increase `value` by `percent`%.\n                       'decrease' to decrease `value` by `percent`%.\n    Returns:\n    float: Result of the percentage operation.\n    \n    Examples:\n    >>> calculate_percentage(200, 10, 'of')\n    20.0\n    >>> calculate_percentage((50, 200), 0, 'isof')\n    25.0\n    >>> calculate_percentage(100, 15, 'increase')\n    115.0\n    >>> calculate_percentage(100, 15, 'decrease')\n    85.0\n    \"\"\"\n    if operation == 'of':\n        return (value * percent) / 100\n    elif operation == 'isof':\n        part, whole = value\n        return (part / whole) * 100\n    elif operation == 'increase':\n        return value * (1 + (percent / 100))\n    elif operation == 'decrease':\n        return value * (1 - (percent / 100))\n    else:\n        raise ValueError(\"Unsupported operation specified.\")"
        ],
        [
            "def convert_percentage(fullness, state='full'):\n    \"\"\"\n    Convert between different percentage descriptions, specifically handling 'full' vs 'empty' descriptions.\n    \n    Parameters:\n    - fullness (float): The percentage value to convert.\n    - state (str): The initial state of the percentage, can be 'full' or 'empty'. Defaults to 'full'.\n                   'full' indicates the percentage provided is how full something is.\n                   'empty' converts how empty something is to how full it is.\n    Returns:\n    float: The converted percentage based on the state.\n    \n    Examples:\n    >>> convert_percentage(80, 'full')\n    80.0\n    >>> convert_percentage(20, 'empty')\n    80.0\n    \"\"\"\n    if state.lower() == 'full':\n        return fullness\n    elif state.lower() == 'empty':\n        return 100 - fullness\n    else:\n        raise ValueError(\"Unsupported state specified. Use 'full' or 'empty'.\")"
        ]
    ],
    "Divisibility": [
        [
            "def adjust_to_divisibility(n, d):\n    \"\"\"\n    Adjust a number to make it divisible by another number by possibly adding or subtracting a minimal amount.\n    Parameters:\n    n (int): The number to be adjusted.\n    d (int): The divisor.\n    \n    Returns:\n    tuple: (adjusted number, added/subtracted value)\n    Examples:\n    >>> adjust_to_divisibility(37, 5)\n    (35, -2)\n    >>> adjust_to_divisibility(20, 4)\n    (20, 0)\n    \"\"\"\n    remainder = n % d\n    if remainder == 0:\n        return (n, 0)\n    to_subtract = remainder\n    to_add = d - remainder\n    if to_add < to_subtract:\n        return (n + to_add, to_add)\n    else:\n        return (n - to_subtract, -to_subtract)",
            "def adjust_to_be_divisible(n, divisor):\n    \"\"\"\n    Adjust n to the nearest number less than or equal to n that is divisible by divisor.\n    Parameters:\n    - n (int): The number to be adjusted.\n    - divisor (int): The divisor to achieve divisibility.\n    Returns:\n    int: The adjusted number that is divisible by divisor.\n    Examples:\n    >>> adjust_to_be_divisible(14, 5)\n    10\n    >>> adjust_to_be_divisible(23, 4)\n    20\n    \"\"\"\n    return n - (n % divisor)",
            "def adjust_for_divisibility(number, divisor):\n    \"\"\"\n    Adjusts the number minimally so that it becomes divisible by the divisor.\n    \n    Parameters:\n    - number : int\n        The number to adjust.\n    - divisor : int\n        The divisor to be divisible by.\n        \n    Returns:\n    - int\n        The adjusted number that is divisible by `divisor`.\n        \n    Examples:\n    >>> adjust_for_divisibility(10, 5)\n    10\n    >>> adjust_for_divisibility(7, 3)\n    6\n    \"\"\"\n    remainder = number % divisor\n    if remainder == 0:\n        return number\n    return number - remainder"
        ],
        [
            "def prime_factors(n):\n    \"\"\"\n    Compute the prime factors of a given number.\n    \n    Parameters:\n    n (int): The number to factorize.\n    \n    Returns:\n    list: A list of prime factors of the number.\n    \n    Examples:\n    >>> prime_factors(18)\n    [2, 3, 3]\n    >>> prime_factors(17)\n    [17]\n    \"\"\"\n    return list(sp.factorint(n).elements())",
            "def get_prime_factors(n):\n    \"\"\"\n    Return the prime factors of the integer n.\n    Parameters:\n    - n (int): The number to factorize.\n    Returns:\n    list: A list of the prime factors of n.\n    Examples:\n    >>> get_prime_factors(56)\n    [2, 7]\n    >>> get_prime_factors(18)\n    [2, 3]\n    \"\"\"\n    return primefactors(n)",
            "def prime_factors(number):\n    \"\"\"\n    Returns the list of prime factors of the given number.\n    \n    Parameters:\n    - number : int\n        The number to be factorized.\n        \n    Returns:\n    - list\n        The prime factors of `number`.\n    \n    Examples:\n    >>> prime_factors(18)\n    [2, 3, 3]\n    >>> prime_factors(17)\n    [17]\n    \"\"\"\n    return list(sp.primefactors(number, multiple=True))"
        ],
        [
            "def is_divisible_by_digit_sum(number):\n    \"\"\"\n    Check if the number is divisible by the sum of its digits.\n    \n    Parameters:\n    - number : int\n        The number to check.\n        \n    Returns:\n    - bool\n        True if `number` is divisible by the sum of its digits, False otherwise.\n    \n    Examples:\n    >>> is_divisible_by_digit_sum(123)\n    False\n    >>> is_divisible_by_digit_sum(111)\n    True\n    \"\"\"\n    digit_sum = sum(map(int, str(number)))\n    return number % digit_sum == 0"
        ],
        [
            "def is_divisible(n, d):\n    \"\"\"\n    Check if a number n is divisible by another number d.\n    Parameters:\n    n (int): The number to be checked for divisibility.\n    d (int): The divisor.\n    Returns:\n    bool: True if n is divisible by d, False otherwise.\n    \n    Examples:\n    >>> is_divisible(10, 2)\n    True\n    >>> is_divisible(7, 3)\n    False\n    \"\"\"\n    return n % d == 0",
            "def is_divisible(n, divisor):\n    \"\"\"\n    Check if the integer n is divisible by the divisor.\n    Parameters:\n    - n (int): The number to be checked.\n    - divisor (int): The divisor to check divisibility against.\n    Returns:\n    bool: True if n is divisible by divisor, False otherwise.\n    Examples:\n    >>> is_divisible(10, 2)\n    True\n    >>> is_divisible(13, 3)\n    False\n    \"\"\"\n    return n % divisor == 0",
            "def is_divisible_by_n(number, n):\n    \"\"\"\n    Check if the provided number is divisible by n.\n    \n    Parameters:\n    - number : int\n        The number to be checked for divisibility.\n    - n : int\n        The divisor.\n        \n    Returns:\n    - bool\n        True if `number` is divisible by `n`, False otherwise.\n        \n    Examples:\n    >>> is_divisible_by_n(10, 2)\n    True\n    >>> is_divisible_by_n(14, 3)\n    False\n    \"\"\"\n    return number % n == 0"
        ],
        [
            "def sum_of_digits_divisible_by(n, divisor):\n    \"\"\"\n    Check if the sum of the digits of n is divisible by divisor.\n    Parameters:\n    - n (int): The number whose digits are to be summed.\n    - divisor (int): The divisor to check against.\n    Returns:\n    bool: True if the sum of the digits is divisible by the divisor.\n    Examples:\n    >>> sum_of_digits_divisible_by(123, 3)\n    True\n    >>> sum_of_digits_divisible_by(124, 3)\n    False\n    \"\"\"\n    return sum(int(digit) for digit in str(n)) % divisor == 0"
        ],
        [
            "def is_even_or_odd(number):\n    \"\"\"\n    Determines if the number is even or odd.\n    \n    Parameters:\n    - number : int\n        The number to check.\n        \n    Returns:\n    - str\n        \"even\" if number is even, \"odd\" if number is odd.\n    \n    Examples:\n    >>> is_even_or_odd(4)\n    'even'\n    >>> is_even_or_odd(7)\n    'odd'\n    \"\"\"\n    return \"even\" if number % 2 == 0 else \"odd\""
        ],
        [
            "def calculate_remainder(dividend, divisor):\n    \"\"\"\n    Calculates the remainder of the division of dividend by divisor.\n    \n    Parameters:\n    - dividend : int\n        The number to be divided.\n    - divisor : int\n        The number which divides.\n        \n    Returns:\n    - int\n        The remainder when `dividend` is divided by `divisor`.\n        \n    Examples:\n    >>> calculate_remainder(10, 3)\n    1\n    >>> calculate_remainder(25, 4)\n    1\n    \"\"\"\n    return dividend % divisor"
        ],
        [
            "def polynomial_divisibility_check(p, q):\n    \"\"\"\n    Check if a polynomial p is divisible by another polynomial q using Remainder Theorem.\n    Parameters:\n    p (sympy.Poly): Polynomial to be checked.\n    q (sympy.Poly): Divisor polynomial.\n    Returns:\n    bool: True if the remainder of p divided by q is zero, False otherwise.\n    \n    Examples:\n    >>> polynomial_divisibility_check(sp.Poly(x**2 - 4), sp.Poly(x - 2))\n    True\n    >>> polynomial_divisibility_check(sp.Poly(x**2 - 1), sp.Poly(x - 2))\n    False\n    \"\"\"\n    remainder = rem(p, q, x)\n    return remainder == 0"
        ],
        [
            "def polynomial_divisibility(polynomial, divisor):\n    \"\"\"\n    Evaluates polynomial divisibility under modular arithmetic conditions.\n    \n    Parameters:\n    - polynomial : sp.Poly\n        A sympy polynomial object.\n    - divisor : int\n        The divisor for modular arithmetic.\n        \n    Returns:\n    - bool\n        True if polynomial is zero under modulo `divisor`, otherwise False.\n    \n    Examples:\n    >>> x = sp.symbols('x')\n    >>> poly = sp.Poly(x**2 - 2*x + 1)\n    >>> polynomial_divisibility(poly, 2)\n    True\n    \"\"\"\n    poly_mod = polynomial.as_expr() % divisor\n    return sp.simplify(poly_mod) == 0"
        ],
        [
            "def find_common_divisors(a, b):\n    \"\"\"\n    Find common divisors of two numbers.\n    \n    Parameters:\n    a (int): First number.\n    b (int): Second number.\n    \n    Returns:\n    list: A list of common divisors between a and b.\n    \n    Examples:\n    >>> find_common_divisors(12, 18)\n    [1, 2, 3, 6]\n    >>> find_common_divisors(13, 17)\n    [1]\n    \"\"\"\n    return sorted(list(sp.divisors(sp.gcd(a, b))))"
        ],
        [
            "def remainder_when_divided_by(n, divisor):\n    \"\"\"\n    Calculate the remainder of n divided by divisor.\n    Parameters:\n    - n (int): The numerator.\n    - divisor (int): The denominator.\n    Returns:\n    int: The remainder of n divided by divisor.\n    Examples:\n    >>> remainder_when_divided_by(10, 3)\n    1\n    >>> remainder_when_divided_by(25, 5)\n    0\n    \"\"\"\n    return n % divisor"
        ]
    ]
}