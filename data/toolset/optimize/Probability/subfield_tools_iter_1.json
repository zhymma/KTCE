{"Basic Concepts": [{"tool": "def calculate_probability(favorable_outcomes, total_outcomes):\n    \n    if total_outcomes == 0:\n        raise ValueError(\"Total outcomes cannot be zero.\")\n    return favorable_outcomes / total_outcomes", "subfield": "Basic Concepts", "tool_name": "calculate_probability", "tool_type": "function", "description": "Calculate the probability of an event given the number of favorable and total outcomes.", "docstring": "Calculate the probability of an event given the number of favorable and total outcomes.\n    \n    Parameters:\n        favorable_outcomes (int): The number of favorable outcomes for the event.\n        total_outcomes (int): The total number of possible outcomes.\n    \n    Returns:\n        float: The probability of the event.\n    \n    Examples:\n        >>> calculate_probability(20, 100)\n        0.2\n        >>> calculate_probability(5, 50)\n        0.1", "Freq": 23, "TSR": 18, "experience_pool": "Experience 1:\nProblem: What is the probability that the same number will be facing up on each of three standard six-sided dice that are tossed simultaneously? Express your answer as a common fraction.\nAnswer: \\frac{1}{36}\n\nSolution:\nTo calculate the probability of getting the same number on each of three dice, you need to calculate the probability of getting the same number on each individual die and then multiply them together.\n\n```python\n# Probability of getting the same number on each die\nprob_same_number = calculate_probability(1, 6) * calculate_probability(1, 6) * calculate_probability(1, 6)\n\n# Print the result\nprint(prob_same_number)\n```\n\nExperience 2:\nProblem: Two standard dice are rolled. What is the expected number of 1's obtained? Express your answer as a common fraction.\nAnswer: \\frac{1}{3}\n\nSolution:\nTo calculate the expected number of 1's obtained when rolling two dice, you need to consider the different possibilities and their probabilities.\n\n```python\n# Probability of rolling a 1 on one die\nprob_1 = calculate_probability(1, 6)\n\n# Probability of not rolling a 1 on one die\nprob_not_1 = calculate_probability(5, 6)\n\n# Probability of rolling a 1 on both dice\nprob_both_1 = prob_1 * prob_1\n\n# Probability of rolling exactly one 1\nprob_one_1 = 1 - prob_both_1 - prob_not_1 * prob_1\n\n# Expected number of 1's\nexpected_1 = prob_both_1 * 2 + prob_one_1 * 1 + prob_not_1 * 0\n\n# Print the result\nprint(expected_1)\n```"}, {"tool": "def combinations(n, k):\n    \n    return factorial(n) // (factorial(k) * factorial(n - k))", "subfield": "Basic Concepts", "tool_name": "combinations", "tool_type": "function", "description": "Calculate the number of combinations of `n` items taken `k` at a time.", "docstring": "Calculate the number of combinations of `n` items taken `k` at a time.\n    \n    Parameters\n    ----------\n    n : int\n        Number of items.\n    k : int\n        Number of items to take.\n    \n    Returns\n    -------\n    int\n        Number of combinations.\n    \n    Examples\n    --------\n    >>> combinations(5, 3)\n    10", "Freq": 5, "TSR": 4}, {"tool": "def binomial_coefficient(n, k):\n    \n    if k > n:\n        return 0\n    if k == 0 or k == n:\n        return 1\n    k = min(k, n - k)  # Take advantage of symmetry\n    c = 1\n    for i in range(k):\n        c = c * (n - i) // (i + 1)\n    return c", "subfield": "Basic Concepts", "tool_name": "binomial_coefficient", "tool_type": "function", "description": "Calculate the binomial coefficient (n choose k), which is the number of ways to choose k elements from a set of n elements.", "docstring": "Calculate the binomial coefficient (n choose k), which is the number of ways to choose k elements from a set of n elements.\n    \n    Parameters:\n        n (int): total number of items.\n        k (int): number of items to choose.\n    \n    Returns:\n        int: The binomial coefficient C(n, k).\n    Example:\n        >>> binomial_coefficient(5, 3)\n        10", "Freq": 12, "TSR": 11, "experience_pool": "- Experience 1: Calculating the binomial coefficient using the current tool code.\n- Experience 2: Understanding the parameters n and k in the context of calculating binomial coefficients."}, {"tool": "def probability_intersection(p_a, p_b, p_a_intersection_b):\n    \n    return p_a * p_b * p_a_intersection_b", "subfield": "Basic Concepts", "tool_name": "probability_intersection", "tool_type": "function", "description": "This function calculates the probability of the intersection of two events A and B.", "docstring": "This function calculates the probability of the intersection of two events A and B.\n    Parameters:\n        p_a (float): Probability of event A\n        p_b (float): Probability of event B\n        p_a_intersection_b (float): Probability of both A and B occurring\n    Returns:\n        float: Probability of the intersection of A and B", "Freq": 1, "TSR": 0}, {"tool": "def probability_of_independent_events(*probabilities):\n    \n    from functools import reduce\n    import operator\n    return reduce(operator.mul, probabilities, 1)", "subfield": "Basic Concepts", "tool_name": "probability_of_independent_events", "tool_type": "function", "description": "Calculate the probability of multiple independent events occurring together.", "docstring": "Calculate the probability of multiple independent events occurring together.\n    \n    Parameters:\n        probabilities (list of float): A list of probabilities of each independent event.\n    \n    Returns:\n        float: The total probability of all events occurring together.\n    \n    Examples:\n        >>> probability_of_independent_events(0.5, 0.5, 0.5)  # Probability of flipping three heads in a row\n        0.125\n        >>> probability_of_independent_events(0.3, 0.7)  # Probability of two independent events\n        0.21", "Freq": 10, "TSR": 9}, {"tool": "def complement_probability(event_probability):\n    \n    return 1 - event_probability", "subfield": "Basic Concepts", "tool_name": "complement_probability", "tool_type": "function", "description": "Calculate the probability of the complement of an event.", "docstring": "Calculate the probability of the complement of an event.\n    \n    Parameters:\n        event_probability (float): Probability of the event for which to find the complement.\n    \n    Returns:\n        float: Probability of the complement of the event.\n    Example:\n        >>> complement_probability(0.3)\n        0.7", "Freq": 8, "TSR": 8}, {"tool": "def independent_events_probability(*args):\n    \n    probability = 1\n    for event_probability in args:\n        probability *= event_probability\n    return probability", "subfield": "Basic Concepts", "tool_name": "independent_events_probability", "tool_type": "function", "description": "Calculate the probability of multiple independent events all occurring.", "docstring": "Calculate the probability of multiple independent events all occurring.\n    \n    Parameters\n    ----------\n    *args : list of float\n        A variable number of probabilities representing independent events.\n    \n    Returns\n    -------\n    float\n        The probability of all independent events occurring.\n    \n    Examples\n    --------\n    >>> independent_events_probability(0.5, 0.5)\n    0.25   # Probability of two independent events both with P=0.5", "Freq": 0, "TSR": 0}, {"tool": "def is_prime(num):\n    \n    return isprime(num)", "subfield": "Basic Concepts", "tool_name": "is_prime", "tool_type": "function", "description": "Determine if a number is prime.", "docstring": "Determine if a number is prime.\n    Parameters\n    ----------\n    num : int\n    \n    Returns\n    -------\n    bool\n        True if num is prime, otherwise False.\n    \n    Examples\n    --------\n    >>> is_prime(7)\n    True\n    >>> is_prime(8)\n    False", "Freq": 0, "TSR": 0}, {"tool": "def multijective_count(n, r):\n    \n    return comb(r + n - 1, r)", "subfield": "Basic Concepts", "tool_name": "multijective_count", "tool_type": "function", "description": "This function calculates the number of multijective (or multiple) ways to map (or choose) r items \n    from n categories. This is calculated using the stars and bars method in combinatorics, \n    where there are r+ n-1 total slots, and r of them must be 'stars' (representing chosen items).", "docstring": "This function calculates the number of multijective (or multiple) ways to map (or choose) r items \n    from n categories. This is calculated using the stars and bars method in combinatorics, \n    where there are r+ n-1 total slots, and r of them must be 'stars' (representing chosen items). \n    Parameters:\n        n (int): number of distinct categories \n        r (int): number of items to be chosen \n    Returns:\n        int: number of multijective ways", "Freq": 0, "TSR": 0}, {"tool": "def simplify_fraction(a, b, return_sum=False):\n    \n    fraction = Fraction(a, b).limit_denominator()\n    if return_sum:\n        return fraction.numerator + fraction.denominator\n    return fraction", "subfield": "Basic Concepts", "tool_name": "simplify_fraction", "tool_type": "function", "description": "Simplify a fraction given by numerator a and denominator b, and optionally return the sum of the simplified numerator and denominator.", "docstring": "Simplify a fraction given by numerator a and denominator b, and optionally return the sum of the simplified numerator and denominator.\n    \n    Parameters:\n        a (int): Numerator of the fraction.\n        b (int): Denominator of the fraction.\n        return_sum (bool): If True, returns the sum of the simplified numerator and denominator.\n    \n    Returns:\n        Fraction or int: The simplified fraction or its sum depending on return_sum.\n    \n    Examples:\n        >>> simplify_fraction(50, 100)\n        Fraction(1, 2)\n        >>> simplify_fraction(50, 100, return_sum=True)\n        3", "Freq": 0, "TSR": 0}, {"tool": "def conditional_probability(P_A_given_B, P_B):\n    \n    return P_A_given_B * P_B", "subfield": "Basic Concepts", "tool_name": "conditional_probability", "tool_type": "function", "description": "Calculate the probability of A happening given that B has happened using the conditional probability formula.", "docstring": "Calculate the probability of A happening given that B has happened using the conditional probability formula.\n    \n    Parameters:\n        P_A_given_B (float): Probability of A given B.\n        P_B (float): Probability of B occurring.\n    \n    Returns:\n        float: The conditional probability P(A âˆ© B).\n    \n    Examples:\n        >>> conditional_probability(0.4, 0.5)\n        0.2\n        >>> conditional_probability(0.9, 0.1)\n        0.09", "Freq": 0, "TSR": 0}, {"tool": "def expected_value(outcomes, probabilities):\n    \n    return sum(o * p for o, p in zip(outcomes, probabilities))", "subfield": "Basic Concepts", "tool_name": "expected_value", "tool_type": "function", "description": "Calculate the expected value (mean) of a list of outcomes weighted by their probabilities.", "docstring": "Calculate the expected value (mean) of a list of outcomes weighted by their probabilities.\n    \n    Parameters:\n        outcomes (list of float): List of possible outcomes.\n        probabilities (list of float): List of probabilities associated with each outcome.\n    \n    Returns:\n        float: The expected value of the outcomes.\n    Example:\n        >>> outcomes = [0, 1]\n        >>> probabilities = [0.5, 0.5]\n        >>> expected_value(outcomes, probabilities)\n        0.5", "Freq": 0, "TSR": 0}, {"tool": "def probability_of_specific_outcome(total_outcomes, favorable_outcomes):\n    \n    if total_outcomes == 0:\n        raise ValueError(\"Total outcomes cannot be zero.\")\n    return favorable_outcomes / total_outcomes", "subfield": "Basic Concepts", "tool_name": "probability_of_specific_outcome", "tool_type": "function", "description": "Calculate the probability of a specific outcome given the total number of outcomes and the number of favorable outcomes.\n    \n    Args:\n        total_outcomes (int): The total number of possible outcomes.\n        favorable_outcomes (int): The number of favorable outcomes.\n        \n    Returns:\n        float: The probability of the specific outcome.", "docstring": "Calculate the probability of a specific outcome given the total number of outcomes and the number of favorable outcomes.\n    \n    Args:\n        total_outcomes (int): The total number of possible outcomes.\n        favorable_outcomes (int): The number of favorable outcomes.\n        \n    Returns:\n        float: The probability of the specific outcome.", "Freq": 1, "TSR": 1}], "Expected Value": [{"tool": "def expected_value(outcomes, probabilities):\n    \n    if len(outcomes) != len(probabilities):\n        raise ValueError(\"The lists of outcomes and probabilities must have the same length.\")\n    \n    return sum(o * p for o, p in zip(outcomes, probabilities))", "subfield": "Expected Value", "tool_name": "expected_value", "tool_type": "function", "description": "Calculate the expected value given a list of outcomes and their corresponding probabilities.", "docstring": "Calculate the expected value given a list of outcomes and their corresponding probabilities.\n    \n    Parameters:\n    - outcomes (list of float): A list of potential outcomes.\n    - probabilities (list of float): A list of probabilities corresponding to each outcome.\n    \n    Returns:\n    - float: The expected value calculated as the sum of all outcomes multiplied by their probabilities.\n    \n    Examples:\n    >>> expected_value([10, 20, 30], [0.3, 0.4, 0.3])\n    20.0", "Freq": 4, "TSR": 3}, {"tool": "def min_trials_for_repeat(total_outcomes):\n    \n    return total_outcomes + 1", "subfield": "Expected Value", "tool_name": "min_trials_for_repeat", "tool_type": "function", "description": "Calculate the minimum number of trials needed to ensure at least one repetition\n    according to the Pigeonhole Principle.", "docstring": "Calculate the minimum number of trials needed to ensure at least one repetition\n    according to the Pigeonhole Principle.\n    Parameters:\n    - total_outcomes (int): The total number of unique possible outcomes.\n    Returns:\n    - int: The minimum number of trials to ensure at least one repeat.\n    Example:\n    >>> min_trials_for_repeat(365)\n    366", "Freq": 1, "TSR": 1}, {"tool": "def expected_value_binomial(n, p):\n    \n    return n * p", "subfield": "Expected Value", "tool_name": "expected_value_binomial", "tool_type": "function", "description": "Calculate the expected value of a binomial distribution.", "docstring": "Calculate the expected value of a binomial distribution.\n    Parameters:\n    n (int): The number of trials.\n    p (float): The probability of success on any given trial.\n    Returns:\n    float: The expected value of the binomial distribution, which is n*p.\n    Examples:\n    >>> expected_value_binomial(10, 0.5)\n    5.0\n    >>> expected_value_binomial(20, 0.3)\n    6.0", "Freq": 0, "TSR": 0}, {"tool": "def dice_roll_stats(dice_count, sides=6):\n    \n    from sympy import Rational\n    \n    min_sum = dice_count * 1\n    max_sum = dice_count * sides\n    expected_sum = dice_count * (sides + 1) / 2\n    return {\n        'min_sum': min_sum,\n        'max_sum': max_sum,\n        'expected_sum': Rational(expected_sum).limit_denominator()\n    }", "subfield": "Expected Value", "tool_name": "dice_roll_stats", "tool_type": "function", "description": "Compute the minimum, maximum, and expected sum when rolling a certain number of dice each having a given number of sides.", "docstring": "Compute the minimum, maximum, and expected sum when rolling a certain number of dice each having a given number of sides.\n    Parameters\n    ----------\n    dice_count : int\n        Number of dice to roll.\n    sides : int, optional\n        Number of sides on each die (default is 6 for a standard die).\n    Returns\n    -------\n    dict\n        A dictionary containing 'min_sum', 'max_sum', and 'expected_sum'\n    \n    Example\n    -------\n    >>> dice_roll_stats(dice_count=3, sides=6)\n    {'min_sum': 3, 'max_sum': 18, 'expected_sum': 10.5}", "Freq": 0, "TSR": 0}, {"tool": "def validate_and_normalize_probabilities(probabilities):\n    \n    prob_sum = np.sum(probabilities)\n    if prob_sum == 0:\n        raise ValueError(\"Sum of probabilities should not be zero.\")\n    return probabilities / prob_sum", "subfield": "Expected Value", "tool_name": "validate_and_normalize_probabilities", "tool_type": "function", "description": "Validate and, if necessary, normalize an array of probabilities so they sum to 1.", "docstring": "Validate and, if necessary, normalize an array of probabilities so they sum to 1.\n    Parameters:\n    - probabilities (np.ndarray): An array of raw probability values that might not sum to 1.\n    Returns:\n    - np.ndarray: Normalized probability array.\n    Examples:\n    >>> validate_and_normalize_probabilities(np.array([0.1, 0.2, 0.3]))\n    np.array([0.1667, 0.3333, 0.5])\n    >>> validate_and_normalize_probabilities(np.array([0.5, 0.5]))\n    np.array([0.5, 0.5])", "Freq": 0, "TSR": 0}, {"tool": "def expected_value_combinatorial(n, k, success_probability):\n    \n    return n * success_probability", "subfield": "Expected Value", "tool_name": "expected_value_combinatorial", "tool_type": "function", "description": "Calculate the expected value for combinatorial probability problems, like Bernoulli trials.", "docstring": "Calculate the expected value for combinatorial probability problems, like Bernoulli trials.\n    Parameters:\n    n (int): Total number of trials or elements.\n    k (int): Number of successful trials.\n    success_probability (float): The probability of success in each trial.\n    Returns:\n    float: Expected value calculated as `E[X] = n * p` where `p` is the success probability.\n    Examples:\n    >>> expected_value_combinatorial(10, 3, 0.5)\n    5.0", "Freq": 0, "TSR": 0}, {"tool": "def expected_value_from_pmf(pmf):\n    \n    return sum(outcome * probability for outcome, probability in pmf.items())", "subfield": "Expected Value", "tool_name": "expected_value_from_pmf", "tool_type": "function", "description": "Calculate the expected value from a probability mass function.", "docstring": "Calculate the expected value from a probability mass function.\n    Parameters:\n    pmf (dict): A dictionary where keys are outcomes and values are the probabilities of these outcomes.\n    Returns:\n    float: The expected value calculated as the sum of all outcomes weighted by their probabilities.\n    Examples:\n    >>> pmf = {0: 0.5, 1: 0.3, 2: 0.2}\n    >>> expected_value_from_pmf(pmf)\n    0.7", "Freq": 2, "TSR": 2}, {"tool": "def probability_of_mutually_exclusive_events(*probabilities):\n    \n    return sum(probabilities)", "subfield": "Expected Value", "tool_name": "probability_of_mutually_exclusive_events", "tool_type": "function", "description": "Calculate the total probability of the occurrence of any one of several mutually exclusive events.", "docstring": "Calculate the total probability of the occurrence of any one of several mutually exclusive events.\n    \n    Parameters:\n    - probabilities (floats): A sequence of probabilities for each event, each being independent and mutually exclusive.\n    \n    Returns:\n    - float: The total probability of occurring at least one of the events.\n    \n    Examples:\n    >>> probability_of_mutually_exclusive_events(0.1, 0.2, 0.05)\n    0.35", "Freq": 1, "TSR": 1}]}