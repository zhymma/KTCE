{"Absolute Value": [{"tool": "def add_complex(z1, z2):\n    \n    return z1 + z2", "subfield": "Absolute Value", "tool_name": "add_complex", "tool_type": "function", "description": "Adds two complex numbers.", "docstring": "Adds two complex numbers.\n    Parameters:\n        z1 (complex): The first complex number.\n        z2 (complex): The second complex number.\n    Returns:\n        complex: The sum of z1 and z2.", "Freq": 2, "TSR": 0}, {"tool": "def modulus_complex(z):\n    \n    return np.abs(z)", "subfield": "Absolute Value", "tool_name": "modulus_complex", "tool_type": "function", "description": "Computes the modulus (absolute value) of a complex number.", "docstring": "Computes the modulus (absolute value) of a complex number.\n    Parameters:\n        z (complex): The complex number to compute the modulus for.\n    Returns:\n        float: The modulus of the complex number.", "Freq": 34, "TSR": 21, "experience_pool": "- Experience: When using the `modulus_complex()` function, make sure to pass a complex number as the parameter. The function expects a complex number and will raise an error if a different type is provided.\n- Experience: The `modulus_complex()` function uses the `np.abs()` function from the NumPy library to calculate the modulus of a complex number. Make sure to import the NumPy library (`import numpy as np`) before using the function."}, {"tool": "def conjugate(z):\n    \n    return np.conj(z)", "subfield": "Absolute Value", "tool_name": "conjugate", "tool_type": "function", "description": "Return the complex conjugate of the given complex number.\n    \n    :param z: complex, a complex number in the form a + bi.\n    :return: complex, the conjugate of the complex number.\n    Examples\n    --------\n    >>> conjugate(3 + 4j)\n    (3-4j)", "docstring": "Return the complex conjugate of the given complex number.\n    \n    :param z: complex, a complex number in the form a + bi.\n    :return: complex, the conjugate of the complex number.\n    Examples\n    --------\n    >>> conjugate(3 + 4j)\n    (3-4j)", "Freq": 4, "TSR": 3}, {"tool": "def complex_operations(a, b, operation='multiply'):\n    \n    if operation == 'multiply':\n        return np.multiply(a, b)\n    elif operation == 'divide':\n        return np.divide(a, b)\n    elif operation == 'add':\n        return np.add(a, b)\n    elif operation == 'power':\n        return np.power(a, int(b.real))  # b is assumed to be an integer for power\n    else:\n        raise ValueError(\"Unsupported operation. Use 'multiply', 'divide', 'add', or 'power'.\")", "subfield": "Absolute Value", "tool_name": "complex_operations", "tool_type": "function", "description": "Perform operations (multiply, divide, add, power) on two complex numbers given in Cartesian form.", "docstring": "Perform operations (multiply, divide, add, power) on two complex numbers given in Cartesian form.\n    Parameters:\n    a (complex): First complex number in the form a + bi.\n    b (complex): Second complex number in the form a + bi.\n    operation (str): The operation to perform ['multiply', 'divide', 'add', 'power'].\n    Returns:\n    complex: The result of the operation.\n    Examples:\n    >> complex_operations(complex(1, 1), complex(2, 3), 'multiply')\n    (-1+5j)", "Freq": 15.0, "TSR": 4, "experience_pool": "Experience 1:\nProblem: The tool code is missing the necessary import statement for the numpy library, causing an \"Unsupported operation\" error.\nSolution: Add the import statement `import numpy as np` at the beginning of the tool code.\n\nExperience 2:\nProblem: The tool code is not handling the 'add' operation correctly.\nSolution: Add a new condition in the `complex_operations` function to handle the 'add' operation using the numpy `add` function."}, {"tool": "def complex_to_polar(z):\n    import numpy as np\n    return (np.abs(z), np.angle(z))", "subfield": "Absolute Value", "tool_name": "complex_to_polar", "tool_type": "function", "description": "None", "docstring": null, "Freq": 6.5, "TSR": 2, "experience_pool": "Problem: The complex number $(3 \\operatorname{cis} 18^\\circ)(-2\\operatorname{cis} 37^\\circ)$ is expressed in polar form as $r \\operatorname{cis} \\theta,$ where $r > 0$ and $0^\\circ \\le \\theta < 360^\\circ.$  Enter the ordered pair $(r, \\theta).$\nAnswer: (6,235^\\circ)\n```python\ndef solution():\n    import numpy as np\n    \n    # Given complex numbers in polar form\n    z1 = 3 * np.exp(18j * np.pi / 180)\n    z2 = -2 * np.exp(37j * np.pi / 180)\n\n    # Perform multiplication of complex numbers\n    result = complex_operations(z1, z2, 'multiply')\n\n    # Convert the result to polar form\n    polar_result = complex_to_polar(result)\n\n    return polar_result\n\n# Print the result\nprint(solution())\n```\nOutput:(6.0, -2.181661564992912)"}, {"tool": "def divide_complex(z1, z2):\n    \n    return z1 / z2", "subfield": "Absolute Value", "tool_name": "divide_complex", "tool_type": "function", "description": "Divides one complex number by another.", "docstring": "Divides one complex number by another.\n    Parameters:\n        z1 (complex): The numerator complex number.\n        z2 (complex): The denominator complex number.\n    Returns:\n        complex: The quotient z1 / z2.", "Freq": 4, "TSR": 1}, {"tool": "def convert_complex_number(z, target_form='polar'):\n    \n    modulus = abs(z)\n    argument = cmath.phase(z)\n    if target_form == 'exponential':\n        return cmath.exp(complex(0, argument))\n    elif target_form == 'polar':\n        return modulus, argument\n    else:\n        raise ValueError(\"Unsupported form requested: choose 'polar' or 'exponential'\")", "subfield": "Absolute Value", "tool_name": "convert_complex_number", "tool_type": "function", "description": "Converts a complex number to the specified form and calculates its modulus and argument.", "docstring": "Converts a complex number to the specified form and calculates its modulus and argument.\n    \n    Parameters:\n        z (complex): The complex number in Cartesian form (a + bj).\n        target_form (str): The desired output form ('polar' or 'exponential').\n    \n    Returns:\n        tuple: Depending on the target_form:\n            - 'polar': (modulus, argument)\n            - 'exponential': complex number in exponential form  e^(iÎ¸)\n            \n    Examples:\n        >>> convert_complex_number(1+1j, 'polar')\n        (1.4142135623730951, 0.7853981633974483)\n        >>> convert_complex_format(1+1j, 'exponential')\n        (2.718281828459045**1j*0.7853981633974483)", "Freq": 2, "TSR": 0}, {"tool": "def conjugate_complex_number(c):\n    \n    return c.conjugate()", "subfield": "Absolute Value", "tool_name": "conjugate_complex_number", "tool_type": "function", "description": "This function computes the conjugate of a complex number.", "docstring": "This function computes the conjugate of a complex number.\n    Parameters:\n    c (complex): Complex number\n    Returns:\n    complex : The conjugate of the complex number `c`.", "Freq": 1, "TSR": 1}, {"tool": "def euler_to_complex(theta):\n    \n    return cmath.exp(1j * theta)", "subfield": "Absolute Value", "tool_name": "euler_to_complex", "tool_type": "function", "description": "Converts an angle in radians, using Euler's formula, to its complex representation.", "docstring": "Converts an angle in radians, using Euler's formula, to its complex representation.\n    \n    Parameters:\n        theta (float): The angle in radians.\n    \n    Returns:\n        complex: A complex number represented by cos(theta) + i*sin(theta).\n    \n    Examples:\n        >>> euler_to_complex(np.pi/4)\n        (0.7071067811865476+0.7071067811865475j)", "Freq": 2, "TSR": 0}, {"tool": "def absolute_value_complex(complex_number):\n    \n    return abs(complex_number)", "subfield": "Absolute Value", "tool_name": "absolute_value_complex", "tool_type": "function", "description": "Computes the absolute value (modulus) of a complex number.", "docstring": "Computes the absolute value (modulus) of a complex number.\n    Parameters:\n    - complex_number (complex): The complex number for which to find the modulus.\n    Returns:\n    - float: The modulus of the complex number.\n    Example:\n    >>> absolute_value_complex(3+4j)\n    5.0", "Freq": 1, "TSR": 1}, {"tool": "def are_equal(z1, z2):\n    \n    return z1 == z2", "subfield": "Absolute Value", "tool_name": "are_equal", "tool_type": "function", "description": "Check if two complex numbers are equal.\n    \n    :param z1: complex, the first complex number.\n    :param z2: complex, the second complex number.\n    :return: bool, True if they are equal, else False.\n    Examples\n    --------\n    >>> are_equal(2+3j, 2+3j)\n    True\n    >>> are_equal(2+3j, 3+2j)\n    False", "docstring": "Check if two complex numbers are equal.\n    \n    :param z1: complex, the first complex number.\n    :param z2: complex, the second complex number.\n    :return: bool, True if they are equal, else False.\n    Examples\n    --------\n    >>> are_equal(2+3j, 2+3j)\n    True\n    >>> are_equal(2+3j, 3+2j)\n    False", "Freq": 0, "TSR": 0}, {"tool": "def argument_complex(z):\n    \n    return np.angle(z)", "subfield": "Absolute Value", "tool_name": "argument_complex", "tool_type": "function", "description": "Computes the argument (angle) of a complex number.", "docstring": "Computes the argument (angle) of a complex number.\n    Parameters:\n        z (complex): The complex number to compute the argument for.\n    Returns:\n        float: The argument of the complex number in radians.", "Freq": 1, "TSR": 1}, {"tool": "def absolute_complex_number(c):\n    \n    return abs(c)", "subfield": "Absolute Value", "tool_name": "absolute_complex_number", "tool_type": "function", "description": "This function computes the absolute value (magnitude) of a complex number.", "docstring": "This function computes the absolute value (magnitude) of a complex number.\n    Parameters:\n    c (complex): Complex number whose absolute value has to be computed.\n    Returns:\n    float : absolute value (magnitude) of the input complex number `c`.", "Freq": 1, "TSR": 0}, {"tool": "def sum_powers_complex_number(c, start, end):\n    \n    sum_powers = 0\n    for i in range(start, end+1):\n        sum_powers += c ** i\n    \n    return sum_powers", "subfield": "Absolute Value", "tool_name": "sum_powers_complex_number", "tool_type": "function", "description": "Compute the sum of powers of a complex number.", "docstring": "Compute the sum of powers of a complex number.\n    Parameters:\n    c (complex): Complex number\n    start (int): Starting exponent\n    end (int): Ending exponent\n    Returns:\n    complex : The sum of powers of `c` from `start` to `end`.", "Freq": 4.5, "TSR": 1, "experience_pool": "Problem: Let $\\omega$ be a complex number such that $\\omega^7 = 1$ and $\\omega \\ne 1.$  Compute\n\\[\\omega^{16} + \\omega^{18} + \\omega^{20} + \\dots + \\omega^{54}.\\]\nAnswer: -1\n```python\ndef solution():\n    \"\"\"Compute the sum of powers of a complex number omega.\"\"\"\n    \n    # Given that omega^7 = 1 and omega != 1\n    omega = complex(0.6234898018587336, 0.7818314824680298)  # One of the 7th roots of unity\n    \n    # Calculate the required sum\n    sum_powers = sum_powers_complex_number(omega, 16, 54)\n    \n    return sum_powers\n\n# Calculate and print the result\nprint(solution())\n```\nOutput: -1"}, {"tool": "def complex_modulus(x, y):\n    \n    return np.sqrt(x**2 + y**2)", "subfield": "Absolute Value", "tool_name": "complex_modulus", "tool_type": "function", "description": "Calculates the modulus of a complex number given its Cartesian coordinates.", "docstring": "Calculates the modulus of a complex number given its Cartesian coordinates.\n    Parameters:\n    x (float): The real part of the complex number.\n    y (float): The imaginary part of the complex number.\n    Returns:\n    float: The modulus of the complex number.\n    Examples:\n    >> complex_modulus(3, 4)\n    5.0", "Freq": 0, "TSR": 0}, {"tool": "def complex_from_cartesian(real, imag):\n    \n    return complex(real, imag)", "subfield": "Absolute Value", "tool_name": "complex_from_cartesian", "tool_type": "function", "description": "Constructs a complex number from its real and imaginary parts.", "docstring": "Constructs a complex number from its real and imaginary parts.\n    Parameters:\n        real (float): The real part of the complex number.\n        imag (float): The imaginary part of the complex number.\n    Returns:\n        complex: A complex number represented as real + imag*j.", "Freq": 0, "TSR": 0}, {"tool": "def multiplicative_property(z1, z2):\n    \n    return abs(z1 * z2)", "subfield": "Absolute Value", "tool_name": "multiplicative_property", "tool_type": "function", "description": "Apply the multiplicative property of moduli on two complex numbers.", "docstring": "Apply the multiplicative property of moduli on two complex numbers.\n    Parameters\n    ----------\n    z1, z2 : complex\n        Two complex numbers.\n    Returns\n    -------\n    float\n        The product of the moduli of the given complex numbers, demonstrating that |z1*z2| = |z1|*|z2|.\n    Examples\n    --------\n    >>> multiplicative_property(1+2j, 3+4j)\n    10.0", "Freq": 2, "TSR": 2}, {"tool": "def complex_to_cartesian(z):\n    \n    return (z.real, z.imag)", "subfield": "Absolute Value", "tool_name": "complex_to_cartesian", "tool_type": "function", "description": "Decomposes a complex number into its real and imaginary parts.", "docstring": "Decomposes a complex number into its real and imaginary parts.\n    Parameters:\n        z (complex): The complex number to decompose.\n    Returns:\n        tuple: A tuple containing the real part and imaginary part of the complex number.", "Freq": 1, "TSR": 0}, {"tool": "def magnitude_phase(z):\n    \n    return (abs(z), cmath.phase(z))", "subfield": "Absolute Value", "tool_name": "magnitude_phase", "tool_type": "function", "description": "Computes the magnitude and phase of the complex number.", "docstring": "Computes the magnitude and phase of the complex number.\n    \n    Parameters:\n        z (complex): The complex number.\n    \n    Returns:\n        tuple: Magnitude and phase (angle in radians) of the complex number.\n    \n    Examples:\n        >>> magnitude_phase(1+2j)\n        (2.23606797749979, 1.1071487177940904)", "Freq": 0, "TSR": 0}, {"tool": "def complex_magnitude(z):\n    \n    return abs(z)", "subfield": "Absolute Value", "tool_name": "complex_magnitude", "tool_type": "function", "description": "Calculates the magnitude of the complex number.", "docstring": "Calculates the magnitude of the complex number.\n    Parameters:\n    - z (complex): A complex number.\n    Returns:\n    - float: The magnitude (absolute value) of the complex number.\n    Examples:\n    >>> complex_magnitude(3+4j)\n    5.0", "Freq": 0, "TSR": 0}, {"tool": "def solve_complex_equation(coefficients, target):\n    \n    import numpy as np\n    # Convert the coefficients to a numpy array\n    coefficients = np.array(coefficients, dtype=complex)\n    # Solve the equation using numpy's roots function\n    solutions = np.roots(coefficients) \n    # Round the solutions to avoid floating point errors\n    solutions = np.round(solutions, decimals=10)\n    # Filter out solutions that are not equal to the target value\n    solutions = [s for s in solutions if np.isclose(s, target)]\n    return solutions", "subfield": "Absolute Value", "tool_name": "solve_complex_equation", "tool_type": "function", "description": "Solve an equation with complex coefficients.", "docstring": "Solve an equation with complex coefficients.\n    Parameters:\n    coefficients (list): A list of complex coefficients of the equation in descending order.\n    target (complex): The target value to solve for.\n    Returns:\n    solutions (list): A list of complex solutions to the equation.", "Freq": 7, "TSR": 1}], "Function Operations": [{"tool": "def complex_add(z1, z2):\n    \n    return z1 + z2", "subfield": "Function Operations", "tool_name": "complex_add", "tool_type": "function", "description": "Add two complex numbers.", "docstring": "Add two complex numbers.\n    Parameters:\n        z1 (complex): First complex number.\n        z2 (complex): Second complex number.\n    Returns:\n        complex: Sum of the two complex numbers.\n    \n    Example:\n        >>> complex_add(1+2j, 3+4j)\n        (4+6j)", "Freq": 1, "TSR": 0}, {"tool": "def conjugate_complex(z):\n    \n    return np.conjugate(z)", "subfield": "Function Operations", "tool_name": "conjugate_complex", "tool_type": "function", "description": "Compute the complex conjugate of a complex number.", "docstring": "Compute the complex conjugate of a complex number.\n    \n    Parameters:\n        z (complex): The complex number.\n        \n    Returns:\n        complex: The conjugate of the complex number.", "Freq": 1, "TSR": 0}, {"tool": "def add_complex_numbers(z1, z2):\n    \n    return z1 + z2", "subfield": "Function Operations", "tool_name": "add_complex_numbers", "tool_type": "function", "description": "Add two complex numbers.", "docstring": "Add two complex numbers.\n    \n    Parameters:\n        z1 (sp.core.expr.Expr): A complex number.\n        z2 (sp.core.expr.Expr): Another complex number.\n        \n    Returns:\n        sp.core.expr.Expr: The sum of the two complex numbers.\n        \n    Example:\n        >>> add_complex_numbers(sp.I, 1 + 1*sp.I)\n        1 + 2*I", "Freq": 0, "TSR": 0}, {"tool": "def inverse_complex(z):\n    \n    if z == 0:\n        raise ValueError(\"Complex number cannot be zero for inversion.\")\n    return 1 / z", "subfield": "Function Operations", "tool_name": "inverse_complex", "tool_type": "function", "description": "Compute the multiplicative inverse of a complex number.", "docstring": "Compute the multiplicative inverse of a complex number.\n    \n    Parameters:\n        z (complex): The complex number to invert.\n        \n    Returns:\n        complex: The inverse of the complex number.", "Freq": 0, "TSR": 0}, {"tool": "def modulus_of_complex(z):\n    \n    if isinstance(z, tuple):\n        z = complex(*z)\n    return np.abs(z)", "subfield": "Function Operations", "tool_name": "modulus_of_complex", "tool_type": "function", "description": "Calculate the modulus (absolute value) of a complex number.", "docstring": "Calculate the modulus (absolute value) of a complex number.\n    Parameters:\n    - z (complex or tuple): The complex number.\n    Returns:\n    - float: The modulus of the complex number.\n    Example:\n    >>> modulus_of_complex((3+4j))\n    5.0", "Freq": 1, "TSR": 1}, {"tool": "def cartesian_to_polar(z):\n    \n    return cmath.polar(z)", "subfield": "Function Operations", "tool_name": "cartesian_to_polar", "tool_type": "function", "description": "Convert Cartesian coordinates to polar coordinates.", "docstring": "Convert Cartesian coordinates to polar coordinates.\n    \n    Parameters:\n        z (complex): Complex number in Cartesian form.\n    \n    Returns:\n        tuple: Two-dimensional tuple (magnitude, angle_in_radians).\n    \n    Examples:\n        >>> cartesian_to_polar(1+1j)\n        (1.4142135623730951, 0.7853981633974483)", "Freq": 0, "TSR": 0}, {"tool": "def real_part(z):\n    \n    return z.real", "subfield": "Function Operations", "tool_name": "real_part", "tool_type": "function", "description": "Extract the real part of a complex number.", "docstring": "Extract the real part of a complex number.\n    Parameters:\n        z (complex): The complex number.\n    Returns:\n        float: The real part of the complex number.\n    \n    Example:\n        >>> real_part(3+4j)\n        3.0", "Freq": 0, "TSR": 0}, {"tool": "def apply_piecewise_function(z, conditions_functions):\n    \n    result = None\n    for condition, function in conditions_functions:\n        if condition.subs(z, z):\n            result = function.subs(z, z)\n            break\n    return result", "subfield": "Function Operations", "tool_name": "apply_piecewise_function", "tool_type": "function", "description": "Apply a piecewise function to a complex number based on specified conditions and functions.", "docstring": "Apply a piecewise function to a complex number based on specified conditions and functions.\n    \n    Parameters:\n        z (sp.core.expr.Expr): The input complex number.\n        conditions_functions (list of tuples): Each tuple contains a condition and a corresponding function.\n    \n    Returns:\n        sp.core.expr.Expr: The result after applying the piecewise function.\n        \n    Example:\n        >>> conditions_functions = [\n                (sp.Abs(z) > 1, z**2),\n                (sp.Abs(z) <= 1, z + 1)\n            ]\n        >>> apply_piecewise_function(sp.I, conditions_functions)\n        1 + I", "Freq": 0, "TSR": 0}, {"tool": "def euler_to_complex(r, theta):\n    \n    return r * np.exp(1j * theta)", "subfield": "Function Operations", "tool_name": "euler_to_complex", "tool_type": "function", "description": "Convert a complex number from polar (Euler's) form (r*e^(i*theta)) to rectangular form.", "docstring": "Convert a complex number from polar (Euler's) form (r*e^(i*theta)) to rectangular form.\n    \n    Parameters:\n        r (float): Magnitude of the complex number.\n        theta (float): Phase (angle in radians) of the complex number.\n    \n    Returns:\n        complex: The complex number in rectangular form.\n    \n    Examples:\n        >>> euler_to_complex(5, np.pi/4)\n        (3.5355339059327378+3.5355339059327378j)", "Freq": 0, "TSR": 0}, {"tool": "def perform_complex_arithmetic(z1, z2, operation='add'):\n    \n    if isinstance(z1, tuple):\n        z1 = complex(*z1)\n    if isinstance(z2, tuple):\n        z2 = complex(*z2)\n    \n    if operation == 'add':\n        return z1 + z2\n    elif operation == 'subtract':\n        return z1 - z2\n    elif operation == 'multiply':\n        return z1 * z2\n    elif operation == 'divide':\n        return z1 / z2 if z2 != 0 else None", "subfield": "Function Operations", "tool_name": "perform_complex_arithmetic", "tool_type": "function", "description": "Calculate arithmetic operations between two complex numbers.", "docstring": "Calculate arithmetic operations between two complex numbers.\n    Parameters:\n    - z1 (complex or tuple): The first complex number.\n    - z2 (complex or tuple): The second complex number.\n    - operation (str): The type of arithmetic operation ('add', 'subtract', 'multiply', 'divide').\n    Returns:\n    - complex: The result of the arithmetic operation on the two complex numbers.\n    Example:\n    >>> perform_complex_arithmetic((1, 2), (3, 4), 'add')\n    (4+6j)\n    >>> perform_complex_arithmetic((1, 2), (3, 4), 'multiply')\n    (-5+10j)", "Freq": 0, "TSR": 0}, {"tool": "def complex_scale(z, factor):\n    \n    return z * factor", "subfield": "Function Operations", "tool_name": "complex_scale", "tool_type": "function", "description": "Scales a complex number by a given factor.", "docstring": "Scales a complex number by a given factor.\n    Parameters:\n    - z (complex): The complex number to scale.\n    - factor (float or complex): Scaling factor.\n    Returns:\n    - complex: The scaled complex number.\n    Examples:\n    >>> complex_scale(1+2j, 2)\n    (2+4j)", "Freq": 1, "TSR": 0}, {"tool": "def calculate_complex_power(z, power):\n    \n    if isinstance(z, tuple):\n        z = complex(*z)\n    return np.power(z, power)", "subfield": "Function Operations", "tool_name": "calculate_complex_power", "tool_type": "function", "description": "Calculate the exponentiation of a complex number.", "docstring": "Calculate the exponentiation of a complex number.\n    Parameters:\n    - z (complex or tuple): The complex number.\n    - power (int): The power to which the complex number is raised.\n    Returns:\n    - complex: The complex number raised to the specified power.\n    Example:\n    >>> calculate_complex_power((1, 2), 3)\n    (-9+46j)", "Freq": 2, "TSR": 0}, {"tool": "def normalize_angle(angle):\n    \n    return angle % (2 * math.pi)", "subfield": "Function Operations", "tool_name": "normalize_angle", "tool_type": "function", "description": "Normalize an angle to the range [0, 2*pi).", "docstring": "Normalize an angle to the range [0, 2*pi).\n    \n    Parameters:\n        angle (float): An angle in radians.\n        \n    Returns:\n        float: The angle normalized to [0, 2*pi).", "Freq": 0, "TSR": 0}, {"tool": "def from_polar(magnitude, angle):\n    \n    return magnitude * np.exp(1j * angle)", "subfield": "Function Operations", "tool_name": "from_polar", "tool_type": "function", "description": "Convert a complex number from polar to Cartesian form using Euler's formula.", "docstring": "Convert a complex number from polar to Cartesian form using Euler's formula.\n    \n    Parameters:\n        magnitude (float): The magnitude of the complex number.\n        angle (float): The angle in radians.\n        \n    Returns:\n        complex: The complex number in Cartesian form.", "Freq": 0, "TSR": 0}, {"tool": "def complex_operations(z, operation=\"modulus\"):\n    \n    if operation == \"modulus\":\n        return cmath.sqrt(z.real**2 + z.imag**2).real\n    elif operation == \"power\":\n        return cmath.exp(z)\n    elif operation == \"rationalize\":\n        return z.conjugate() / (z.real**2 + z.imag**2)\n    elif operation == \"simplify\":\n        return (z**2).real - 1 + 2 * z.imag * 1j        # Using i^2 = -1", "subfield": "Function Operations", "tool_name": "complex_operations", "tool_type": "function", "description": "Perform various operations on complex numbers such as calculating modulus, \n    finding powers, rationalizing denominator, and simplifying using i^2 = -1.", "docstring": "Perform various operations on complex numbers such as calculating modulus, \n    finding powers, rationalizing denominator, and simplifying using i^2 = -1.\n    Parameters:\n    z (complex): The complex number to operate on.\n    operation (str): Type of operation to perform ['modulus', 'power', 'rationalize', 'simplify'].\n    Returns:\n    Various: Depending on the operation, returns complex number or real number.\n    \n    Example:\n    >>> complex_operations(1+3j, \"modulus\")\n    3.1622776601683795\n    >>> complex_operations((1+3j)**2, \"simplify\")\n    (-8+6j)", "Freq": 0, "TSR": 0}, {"tool": "class ComplexOperations:\n    \"\"\"\n    A class containing a suite of operations for complex numbers.\n    \"\"\"\n    @staticmethod\n    def add_complex_numbers(z1, z2):\n        \"\"\"\n        Add two complex numbers.\n        Parameters:\n        z1 (complex): First complex number.\n        z2 (complex): Second complex number.\n        Returns:\n        complex: The sum of the two complex numbers.\n        Examples:\n        >>> ComplexOperations.add_complex_numbers(1+2j, 3+4j)\n        (4+6j)\n        \"\"\"\n        return z1 + z2\n    @staticmethod\n    def multiply_complex_numbers(z1, z2):\n        \"\"\"\n        Multiply two complex numbers.\n        Parameters:\n        z1 (complex): First complex number.\n        z2 (complex): Second complex number.\n        Returns:\n        complex: The product of the two complex numbers.\n        Examples:\n        >>> ComplexOperations.multiply_complex_numbers(1+2j, 3+4j)\n        (-5+10j)\n        \"\"\"\n        return z1 * z2\n    @staticmethod\n    def square_complex_number(z):\n        \"\"\"\n        Square a complex number.\n        Parameters:\n        z (complex): Complex number to square.\n        Returns:\n        complex: The square of the complex number.\n        Examples:\n        >>> ComplexOperations.square_complex_number(2+3j)\n        (-5+12j)\n        \"\"\"\n        return z * z\n    @staticmethod\n    def find_fixed_points(w, z):\n        \"\"\"\n        Find fixed points of the function w(z), assuming w is a lambda function.\n        Parameters:\n        w (function): A lambda function representing a complex function w(z).\n        z (sympy.Symbol): Symbolic representation of complex variable z.\n        Returns:\n        list: Solutions that satisfy w(z) = z.\n        Examples:\n        >>> z = sp.symbols('z', complex=True)\n        >>> w = lambda z: z**2 + 1 + 0*z  # Suppresses simplification issues\n        >>> ComplexOperations.find_fixed_points(w, z)\n        [1/2 - sqrt(3)*I/2, 1/2 + sqrt(3)*I/2]\n        \"\"\"\n        z_fixed = sp.Eq(w(z), z)\n        return sp.solve(z_fixed, z)\n    @staticmethod\n    def apply_piecewise_function(funcs, conditions, z):\n        \"\"\"\n        Evaluate piecewise complex functions based on conditions.\n        Parameters:\n        funcs (list of functions): A list of lambda functions for each piece.\n        conditions (list of functions): A list of lambda boolean expressions representing conditions for pieces.\n        z (complex): Complex number input.\n        Returns:\n        complex: Output after evaluating the correct piece.\n        Examples:\n        >>> funcs = [lambda z: z**2, lambda z: sp.exp(z)]\n        >>> conditions = [lambda z: sp.re(z) > 0, lambda z: sp.re(z) <= 0]\n        >>> ComplexOperations.apply_piecewise_function(funcs, conditions, -1+1j)\n        exp(-1 + 1j)\n        \"\"\"\n        for func, condition in zip(funcs, conditions):\n            if condition(z):\n                return func(z)\n        return None  # Default case if no conditions are met", "subfield": "Function Operations", "tool_name": "ComplexOperations:\n    \"\"\"\n    A class containing a suite of operations for complex numbers.\n    \"\"\"\n    @staticmethod\n    def add_complex_numbers", "tool_type": "class", "description": "A class containing a suite of operations for complex numbers.", "docstring": "A class containing a suite of operations for complex numbers.", "Freq": 0, "TSR": 0}, {"tool": "def find_fixed_points(z_function, z_var, initial_guesses):\n    \n    equation = sp.Eq(z_function, z_var)\n    solutions = []\n    for guess in initial_guesses:\n        sol = sp.nsolve(equation, z_var, guess)\n        if sol not in solutions:  # Avoid duplicate roots\n            solutions.append(sol)\n    return solutions", "subfield": "Function Operations", "tool_name": "find_fixed_points", "tool_type": "function", "description": "Find fixed points of a complex function where f(z) = z.", "docstring": "Find fixed points of a complex function where f(z) = z.\n    \n    Parameters:\n        z_function (sp.core.expr.Expr): A function of complex variable z.\n        z_var (sp.Symbol): The symbol used as a complex variable in z_function.\n        initial_guesses (list): List of initial guesses to start the root finding.\n        \n    Returns:\n        list: The list of complex numbers which are fixed points.\n        \n    Example:\n        >>> z = sp.symbols('z')\n        >>> f_z = z**2 + 1 - 1*z\n        >>> find_fixed_points(f_z, z, [0, 1 + sp.I])\n        [-1.0, 1.0]", "Freq": 0, "TSR": 0}, {"tool": "def complex_details(z):\n    \n    real_part = z.real\n    imaginary_part = z.imag\n    modulus = cmath.sqrt(real_part**2 + imaginary_part**2).real\n    reciprocal = 1 / z if z != 0 else None\n    return {\n        \"real_part\": real_part,\n        \"imaginary_part\": imaginary_part,\n        \"modulus\": modulus,\n        \"reciprocal\": reciprocal\n    }", "subfield": "Function Operations", "tool_name": "complex_details", "tool_type": "function", "description": "Provides detailed components of a complex number including real and imaginary parts,\n    and other representations.", "docstring": "Provides detailed components of a complex number including real and imaginary parts,\n    and other representations.\n    Parameters:\n    z (complex): A complex number.\n    \n    Returns:\n    dict: Dictionary containing real and imaginary parts, modulus, and reciprocal,\n    \n    Example:\n    >>> complex_details(1+3j)\n    {'real_part': 1, 'imaginary_part': 3, 'modulus': 3.1622776601683795, 'reciprocal': (0.1-0.3j)}", "Freq": 0, "TSR": 0}, {"tool": "def raise_to_power(z, power):\n    \n    magnitude, angle = to_polar(z)\n    return from_polar(magnitude**power, angle*power)", "subfield": "Function Operations", "tool_name": "raise_to_power", "tool_type": "function", "description": "Raise a complex number to a given power using DeMoivre's Theorem.", "docstring": "Raise a complex number to a given power using DeMoivre's Theorem.\n    \n    Parameters:\n        z (complex): The complex number.\n        power (int): The power to which the complex number is to be raised.\n        \n    Returns:\n        complex: The result of raising z to the power.", "Freq": 0, "TSR": 0}, {"tool": "def square_sum_complex(z1, z2):\n    \n    sum_z = z1 + z2\n    squares_sum = z1**2 + z2**2\n    twice_product = 2 * z1 * z2\n    return (sum_z**2, squares_sum, twice_product)", "subfield": "Function Operations", "tool_name": "square_sum_complex", "tool_type": "function", "description": "Calculate the square of the sum of two complex numbers and relate it to separate squares and product.", "docstring": "Calculate the square of the sum of two complex numbers and relate it to separate squares and product.\n    Parameters:\n        z1 (complex): First complex number.\n        z2 (complex): Second complex number.\n    Returns:\n        tuple: Contains the square of the sum, sum of squares, and twice the product of the numbers.\n    \n    Example:\n        >>> square_sum_complex(1+2j, 3+4j)\n        ((16+20j), (10+20j), 28+0j)", "Freq": 0, "TSR": 0}, {"tool": "def create_complex(real, imag):\n    \n    return complex(real, imag)", "subfield": "Function Operations", "tool_name": "create_complex", "tool_type": "function", "description": "Create a complex number from real and imaginary parts.", "docstring": "Create a complex number from real and imaginary parts.\n    Parameters:\n        real (float): The real part of the complex number.\n        imag (float): The imaginary part of the complex number.\n    Returns:\n        complex: The complex number represented as 'real + imag*j'.\n    \n    Example:\n        >>> create_complex(3, 4)\n        (3+4j)", "Freq": 0, "TSR": 0}, {"tool": "def magnitude_and_phase(z):\n    \n    return (np.abs(z), np.angle(z))", "subfield": "Function Operations", "tool_name": "magnitude_and_phase", "tool_type": "function", "description": "Calculate magnitude and phase (angle) of a complex number.", "docstring": "Calculate magnitude and phase (angle) of a complex number.\n    \n    Parameters:\n        z (complex): Complex number to calculate properties for.\n    \n    Returns:\n        tuple: Magnitude and phase (in radians).\n    \n    Examples:\n        >>> magnitude_and_phase(3+4j)\n        (5.0, 0.9272952180016122)", "Freq": 0, "TSR": 0}]}