{
    "Limits": [
        [
            "def compute_limit(expression, variable, approach_value, direction='both'):\n    \"\"\"\n    This function computes the limit of a given algebraic expression with respect to a specified variable \n    as this variable approaches a certain value. The direction can be 'both', '+' (right-hand limit), \n    or '-' (left-hand limit).\n    \n    Parameters:\n    expression (str or sympy.Expr): The algebraic expression for which the limit is to be calculated.\n    variable (str or sympy.Symbol): The variable in the expression with respect to which the limit is calculated.\n    approach_value (int, float, str): The point that the variable approaches. Can be '-oo' or 'oo' for infinity.\n    direction (str, optional): Direction of approach towards the limit point ('both', '+', '-').\n    \n    Returns:\n    sympy.Expr: The result of the limit computation.\n    \n    Examples:\n    >>> compute_limit(\"1/x\", \"x\", 0, '+')\n    oo\n    >>> compute_limit(\"1/x\", \"x\", 0, '-')\n    -oo\n    >>> compute_limit(\"sin(x)/x\", \"x\", \"oo\")\n    0\n    \"\"\"\n    var = sp.symbols(variable) if isinstance(variable, str) else variable\n    expr = sp.sympify(expression)\n    point_of_approach = 'oo' if approach_value == \"oo\" else ('-oo' if approach_value == \"-oo\" else float(approach_value))\n    if direction == 'both':\n        lim = sp.limit(expr, var, point_of_approach)\n    elif direction == '+':\n        lim = sp.limit(expr, var, point_of_approach, dir='+')\n    elif direction == '-':\n        lim = sp.limit(expr, var, point_of_approach, dir='-')\n    else:\n        raise ValueError(\"direction should be 'both', '+', or '-'\")\n    \n    return lim",
            "def evaluate_limit(expression, variable, approaching_value, direction='both'):\n    \"\"\"\n    Evaluates the limit of a given symbolic expression as the variable approaches a specified value.\n    Parameters:\n    - expression (str or sympy.Expr): The mathematical expression for which the limit is to be calculated.\n    - variable (str or sympy.Symbol): The variable in the expression that approaches a certain value.\n    - approaching_value: The point that the variable approaches (can be a finite number, sp.oo for infinity).\n    - direction (str, optional): The direction of limit calculation ('both', '+', or '-'). Defaults to 'both' for two-sided limits.\n    Returns:\n    - limit_value (sympy.Expr): The evaluated limit of the expression.\n    Examples:\n    >>> evaluate_limit('1/x', 'x', 0, '+')\n    oo\n    >>> evaluate_limit('1/x', 'x', 0, '-')\n    -oo\n    >>> evaluate_limit('sin(x)/x', 'x', sp.oo)\n    0\n    \"\"\"\n    # Convert input to sympy format if necessary\n    if isinstance(expression, str):\n        expression = sp.sympify(expression)\n    if isinstance(variable, str):\n        variable = sp.Symbol(variable)\n    \n    if direction == 'both':\n        limit_value = sp.limit(expression, variable, approaching_value)\n    elif direction == '+':\n        limit_value = sp.limit(expression, variable, approaching_value, dir='+')\n    elif direction == '-':\n        limit_value = sp.limit(expression, variable, approaching_value, dir='-')\n    else:\n        raise ValueError(\"Direction must be 'both', '+', or '-'.\")\n    return limit_value",
            "def evaluate_limit(expression, var, point, dir='both'):\n    \"\"\"\n    Evaluate the limit of an expression as the variable approaches a given point.\n    \n    Parameters:\n    - expression : str or sympy.Expr\n        The mathematical expression for which the limit is to be calculated.\n    - var : str or sympy.Symbol\n        The variable in the expression which approaches the specified point.\n    - point : numeric or sympy.Sym\n        The point the variable approaches (can be sympy.oo for infinity).\n    - dir : str, optional\n        The direction of the limit to be evaluated ('+', '-', or 'both').\n        '+' for right-hand limit, '-' for left-hand limit, and 'both' for two-sided limit.\n    \n    Returns:\n    - limit_value : sympy.Expr or float\n        Evaluated limit of the function. If the limit does not exist or is undefined, return None.\n        \n    Examples\n    -------\n    >>> expr = \"1/x\"\n    >>> evaluate_limit(expr, 'x', 0, dir='+')\n    oo\n    \n    >>> evaluate_limit(expr, 'x', 0, dir='-')\n    -oo\n    \n    >>> expr = \"x**2\"\n    >>> evaluate_limit(expr, 'x', sympy.oo)\n    oo\n    \"\"\"\n    expr = sp.sympify(expression) if isinstance(expression, str) else expression\n    var = sp.symbols(var) if isinstance(var, str) else var\n    if dir == 'both':\n        try:\n            lim_plus = sp.limit(expr, var, point, '+')\n            lim_minus = sp.limit(expr, var, point, '-')\n            return lim_plus if lim_plus == lim_minus else None  # Returns None if limits are not equal\n        except:\n            return None\n    else:\n        direction = '+' if dir == '+' else '-'\n        try:\n            return sp.limit(expr, var, point, direction)\n        except:\n            return None"
        ],
        [
            "def check_continuity(expression, var, point):\n    \"\"\"\n    Check continuity of an expression at a given point and provide limit evaluations from both sides.\n    \n    Parameters:\n    - expression : str or sympy.Expr\n        Expression whose continuity at a point is to be checked.\n    - var : str or sympo.Symbol\n        Variable in the expression, typically where the point is being substituted.\n    - point : numeric or sympy.expr\n        Point at which to check the continuity.\n        \n    Returns:\n    - continuity_info : dict\n        Dictionary returning left-hand limit, right-hand limit, and bool indicating continuity at the point.\n    \n    Examples:\n    -------\n    >>> expr = \"sp.Piecewise((x**2, x < 1), (x + 1, x >= 1))\"\n    >>> check_continuity(expr, 'x', 1)\n    {'left_limit': 1, 'right_limit': 2, 'is_continuous': False}\n    \"\"\"\n    expr = sp.sympify(expression) if isinstance(expression, str) else expression\n    var = sp.symbols(var) if isinstance(var, str) else var\n    \n    left_limit = evaluate_limit(expr, var, point, dir='-')\n    right_limit = evaluate_limit(expr, var, point, dir='+')\n    value_at_point = expr.subs(var, point) if not isinstance(expr, sp.Piecewise) else expr.subs(var, point).simplify()\n    \n    is_continuous = left_limit == right_limit == value_attempt if point_potent and potential_value_at_point\n    is_continuous = left_limit ==_ability == potential_value_if point is true or \n    ensuring to-rested ressity at the left \n    return {\n        'left_limit': left_limit,\n        'right_limit': right_limit,\n        'value_at_point': value_at_point,\n        'is_continuous': is_continuous\n    }"
        ],
        [
            "def check_piecewise_continuity(piecewise_func, check_points):\n    \"\"\"\n    Checks the continuity of a piecewise function at specified points and evaluates limits from both sides.\n    Parameters:\n    - piecewise_func (sympy.Piecewise): The piecewise function to check.\n    - check_points (list): Points at which to check the continuity.\n    Returns:\n    - results (dict): A dictionary where keys are points and values are boolean indicating continuity at that point.\n    Examples:\n    >>> f = sp.Piecewise((x**2, x < 1), (x + 1, x >= 1))\n    >>> check_piecewise_continuity(f, [1])\n    {1: True}\n    \"\"\"\n    results = {}\n    variable = piecewise_func.args[0][0].free_symbols.pop()  # Extract the primary variable\n    \n    for point in check_points:\n        limit_left = sp.limit(piecewise_func, variable, point, dir='-')\n        limit_right = sp.limit(piecewise_func, variable, point, dir='+')\n        func_value = piecewise_func.subs(variable, point)\n        # Check if both one-sided limits and the function value at the point are equal\n        is_continuous = (limit_left == limit_right == func_value)\n        results[point] = is_continuous\n    \n    return results"
        ]
    ],
    "Function Operations": [
        [
            "def find_function_intersections(f, g, var, interval):\n    \"\"\"\n    Determine the intersections of two functions over a given interval.\n    \n    Parameters:\n    - f (sympy expression): The first function expressed in symbolic terms.\n    - g (sympy expression): The second function expressed in symbolic terms.\n    - var (sympy.Symbol): The variable in the expressions.\n    - interval (tuple): A tuple (start, end) defining the interval over which to find intersections.\n    \n    Returns:\n    - list: A list of points (x, f(x)) where the functions intersect within the interval.\n    \n    Examples:\n    >>> x = sp.symbols('x')\n    >>> f = sp.sin(x)\n    >>> g = sp.exp(-x/5)\n    >>> find_function_intersections(f, g, x, (0, 10))\n    [(x1, y1), (x2, y2), ..., (xn, yn)]\n    \"\"\"\n    equation = sp.Eq(f, g)\n    solutions = sp.solveset(equation, var, domain=sp.Interval(*interval))\n    return [(sol, f.subs(var, sol)) for sol in solutions]",
            "def find_function_intersections(f, g, variable, interval):\n    \"\"\"\n    Calculate the intersection points of two functions within a given interval.\n    \n    Parameters:\n    - f (sympy expression): The first function in symbolic form.\n    - g (sympy expression): The second function in symbolic form.\n    - variable (sympy.Symbol): The main variable in the functions.\n    - interval (tuple): A tuple of form (start, end) representing the interval within which to find intersections.\n    \n    Returns:\n    - list: A list of points (might be empty) where f intersects g in the given interval.\n    \n    Examples:\n    >>> x = symbols('x')\n    >>> find_function_intersections(sin(x), x/2, x, (0, 10))\n    [Intersection points in interval]\n    \"\"\"\n    equation = Eq(f, g)\n    solutions = solve(equation, variable)\n    return [sol for sol in solutions if sol.is_real and interval[0] <= sol <= interval[1]]",
            "def find_function_intersections(f, g, x_start, x_end, steps=1000):\n    \"\"\"\n    Determines the points of intersection between two mathematical functions over a specified interval.\n    \n    Parameters:\n    f (callable): The first mathematical function.\n    g (callable): The second mathematical function.\n    x_start (float): Start of the interval on which to check for intersections.\n    x_end (float): End of the interval.\n    steps (int): Number of divisions in interval for checking intersections (determines resolution).\n    \n    Returns:\n    list of tuples: A list of (x, y) tuples where the functions f and g intersect within the specified range.\n    \n    Example:\n    >>> f = lambda x: np.sin(x)\n    >>> g = lambda x: 0.5**x\n    >>> find_function_intersections(f, g, 0, 10)\n    [(1.7671458676442586, 0.7009694056660885), (4.912399210575485, 0.5177455994312951), ... ]\n    \"\"\"\n    x_values = np.linspace(x_start, x_end, steps)\n    intersections = []\n    for i in range(len(x_values) - 1):\n        root, info, ier, msg = fsolve(lambda x: f(x) - g(x), x_values[i], full_output=True)\n        if ier == 1:  # Root has been found by fsolve\n            y_value = f(root[0])\n            if x_start <= root <= x_end and (not intersections or abs(root[0] - intersections[-1][0]) > 1e-5):\n                intersections.append((root[0], y_value))\n    return intersections"
        ],
        [
            "def function_operations(f, g, operation, x_val=None):\n    \"\"\"\n    Perform basic arithmetic operations on two functions and evaluate at a specific point if requested.\n    \n    Parameters:\n        f (sympy expression or function): The first mathematical function.\n        g (sympy expression or function): The second mathematical function.\n        operation (str): The operation to perform ('add', 'subtract', 'multiply', 'divide', 'compose').\n        x_val (float, optional): The x value at which the resultant function should be evaluated.\n    \n    Returns:\n        sympy expression or numeric: The resulting function after applying the operation, or a numeric value if `x_val` is provided.\n    \n    Examples:\n        >>> x = sp.symbols('x')\n        >>> f = sp.sin(x)\n        >>> g = sp.cos(x)\n        >>> print(function_operations(f, g, 'add'))\n        sin(x) + cos(x)\n        \n        >>> print(function_operations(f, g, 'compose'))\n        sin(cos(x))\n        \n        >>> print(function_operations(f, g, 'add', 0))\n        1\n    \"\"\"\n    x = sp.symbols('x')\n    result = None\n    \n    if operation == 'add':\n        result = f + g\n    elif operation == 'subtract':\n        result = f - g\n    elif operation == 'multiply':\n        result = f * g\n    elif operation == 'divide':\n        result = f / g\n    elif operation == 'compose':\n        result = f.subs(x, g)\n    \n    if x_val is not None:\n        return result.subs(x, x_val)\n    return result",
            "def combine_functions(f, g, x, operation='add'):\n    \"\"\"\n    Combine two functions using basic operations: addition, subtraction, multiplication, division.\n    Parameters:\n    - f (sp.Expr): First function expression.\n    - g (sp.Expr): Second function expression.\n    - x (sp.Symbol): The symbolic variable used in functions.\n    - operation (str): The operation type ('add', 'subtract', 'multiply', 'divide').\n    Returns:\n    - sp.Expr: The result of combining f and g using the specified operation.\n    \n    Examples:\n    - combine_functions(sp.sin(x), sp.cos(x), x, 'multiply') returns sin(x)*cos(x).\n    \"\"\"\n    if operation == 'add':\n        return f + g\n    elif operation == 'subtract':\n        return f - g\n    elif operation == 'multiply':\n        return f * g\n    elif operation == 'divide':\n        return f / g\n    else:\n        raise ValueError(\"Unsupported operation. Use 'add', 'subtract', 'multiply', or 'divide'.\")"
        ],
        [
            "def simplify_trigonometric_expression(expr):\n    \"\"\"\n    Simplifies a given trigonometric expression using trigonometric identities.\n    Parameters:\n    expr (sympy.Expr): The trigonometric expression to simplify\n    \n    Returns:\n    sympy.Expr: Simplified expression\n    \n    Examples:\n    >>> x = symbols('x')\n    >>> expr = sin(x)**2 + cos(x)**2\n    >>> simplify_trigonometric_expression(expr)\n    1\n    \"\"\"\n    return simplify(expand_trig(expr))",
            "def simplify_trigonometric_expression(expr):\n    \"\"\"\n    Simplifies a trigonometric expression using trigonometric identities and algebraic simplifications.\n    \n    Parameters:\n    - expr (sympy expression): Trigonometric expression to be simplified.\n    \n    Returns:\n    - sympy expression: Simplified form of the provided expression.\n    \n    Examples:\n    >>> x = symbols('x')\n    >>> expr = sin(x)**2 + cos(x)**2\n    >>> simplify_trigonometric_expression(expr)\n    1\n    \"\"\"\n    simplified_expr = simplify(expr)\n    return simplified_expr",
            "def trigonometric_simplify(expression, x):\n    \"\"\"\n    Simplify an expression using trigonometric identities.\n    Parameters:\n    - expression (sp.Expr): The trigonometric expression to simplify.\n    - x (sp.Symbol): The symbolic variable used in the expression.\n    Returns:\n    - sp.Expr: Simplified expression using trigonometric identities.\n    \n    Examples:\n    - trigonometric_simplify(sp.sin(x)**2 + sp.cos(x)**2, x) returns 1.\n    \"\"\"\n    return sp.simplify(expression)"
        ],
        [
            "def invert_function(f, x):\n    \"\"\"\n    Return the inverse of a function, if exists.\n    Parameters:\n    f (sympy.Function): function to be inverted\n    x (sympy.Symbol): The symbol used for the argument in the function\n    \n    Returns:\n    sympy.Function: Inverse of the function\n    \n    Examples:\n    >>> x = symbols('x')\n    >>> f = Function('sin')(x)\n    >>> invert_function(f, x)\n    asin(x)\n    \"\"\"\n    return f.inverse()",
            "def function_inverse(f, x):\n    \"\"\"\n    Find the inverse of a function if it exists.\n    Parameters:\n    - f (sp.Expr): Function expression for which to find the inverse.\n    - x (sp.Symbol): The symbolic variable used in the function.\n    Returns:\n    - sp.Expr or None: Inverse of the function f, or None if the inverse does not exist.\n    \n    Examples:\n    - function_inverse(sp.sin(x), x) returns asin(x) over its principal value range.\n    \"\"\"\n    try:\n        return sp.solve(f - y, x)\n    except Exception as e:\n        return None"
        ],
        [
            "def function_transform(expr, transformation_type, **kwargs):\n    \"\"\"\n    Applies various transformations like translations, scaling, or conversion between forms to a symbolic expression.\n    Parameters:\n        expr (sympy.Expr): the mathematical expression representing the function.\n        transformation_type (str): type of transformation, such as \"translate\", \"scale\", \"parametric_to_cartesian\", \"polar_to_cartesian\".\n        kwargs: Additional parameters depending on `transformation_type`.\n            - For \"translate\" and \"scale\": vector (list) defining translation or scaling factors.\n            - For \"parametric_to_cartesian\": parametric symbols (sympy.Symbol), new symbols.\n            - For \"polar_to_cartesian\": radial function (sympy.Expr).\n    Returns:\n        sympy.Expr: Transformed expression.\n    Examples:\n        >>> x, y, t, r = sp.symbols('x y t r')\n        >>> expr = sp.sin(x)\n        >>> trans_expr = function_transform(expr, 'translate', vector=[sp.pi/2])\n        >>> print(trans_expr)\n        sin(x + pi/2)\n        \n        >>> expr = r*sp.cos(t)\n        >>> trans_expr = function_transform(expr, 'polar_to_cartesian', radial_function=r*sp.sin(t))\n        >>> print(trans_expr)\n        x = r*cos(t)\n        y = r*sin(t)\n    \"\"\"\n    x, y, t = sp.symbols('x y t') # default symbols for Cartesian and parametric\n    if transformation_type == \"translate\":\n        vector = kwargs['vector']\n        return expr.subs({x: x - vector[0], y: y - vector[1]})\n    elif transformation_type == \"scale\":\n        vector = kwargs['vector']\n        return expr.subs({x: x * vector[0], y: y * vector[1]})\n    elif transformation_type == \"parametric_to_cartesian\":\n        parametric_symbols = kwargs['parametric_symbols']\n        new_symbols = kwargs['new_symbols']\n        return [expr.subs(zip(parametric_symbols, new_symbols[coord])) for coord in range(len(new_symbols))]\n    elif transformation_type == \"polar_to_cartesian\":\n        radial_function = kwargs['radial_function']\n        return (expr.subs(t, sp.atan2(y, x)), radial_function.subs(r, sp.sqrt(x**2 + y**2)))\n    else:\n        raise ValueError(\"Unsupported transformation type\")",
            "def analyze_and_manipulate_expr(expr, operation_type, **kwargs):\n    \"\"\"\n    Analyzes and manipulates mathematical expressions using various algebraic techniques including periodicity checks and solving equations.\n    Parameters:\n        expr (sympy.Expr): the mathematical expression to be analyzed or manipulated.\n        operation_type (str): type of operation such as 'periodicity', 'invertibility_check', 'solve_curve_properties'.\n        kwargs: Additional parameters depending on `operation_type`.\n            - For \"invertibility_check\": variable (sympy.Symbol).\n    Returns:\n        Various: Depending on the operation, can be a tuple with properties, boolean for checks, or symbolic expressions.\n    Examples:\n        >>> x = sp.symbols('x')\n        >>> expr = sp.sin(x)\n        >>> result = analyze_and_manipulate_expr(expr, 'periodicity')\n        >>> print(result)\n        2*pi\n        \n        >>> expr = sp.exp(x)\n        >>> result = analyze_and_manipulate_expr(expr, 'invertibility_check', variable=x)\n        >>> print(result)\n        True\n    \"\"\"\n    if operation_type == \"periodicity\":\n        return expr.periodicity(kwargs.get('variable', sp.Symbol('x')))\n    elif operation_type == \"invertibility_check\":\n        variable = kwargs['variable']\n        return sp.solveset(sp.diff(expr, variable), domain=sp.S.Reals).is_empty\n    elif operation_type == \"solve_curve_properties\":\n        return sp.solveset(expr, kwargs.get('variable', sp.Symbol('x')), domain=sp.S.Reals)\n    else:\n        raise ValueError(\"Unsupported operation type\")"
        ],
        [
            "def compose_functions(f, g, var):\n    \"\"\"\n    Compose two functions f(g(x)).\n    \n    Parameters:\n        f (sympy expression): The outer function f(x).\n        g (sympy expression): The inner function g(x).\n        var (sympy symbol): The variable with respect to which the functions are defined.\n    Returns:\n        sympy expression: The composition of the functions as a symbolic expression.\n    Examples:\n        x = symbols('x')\n        f = x**2\n        g = 2*x + 1\n        print(compose_functions(f, g, x))  # Returns (2*x + 1)**2\n    \"\"\"\n    return f.subs(var, g)",
            "def compose_functions(f, g, x):\n    \"\"\"\n    Compose two mathematical functions.\n    Parameters:\n    f (sympy.Function): The outer function in composition, f(g(x))\n    g (sympy.Function): The inner function in composition, f(g(x))\n    x (sympy.Symbol): The symbol used for function argument\n    \n    Returns:\n    sympy.Function: The result of the function composition f(g(x))\n    \n    Examples:\n    >>> x = symbols('x')\n    >>> f = Function('f')(x)\n    >>> g = Function('g')(x)\n    >>> compose_functions(f, g, x)\n    f(g(x))\n    \"\"\"\n    return f.subs(x, g)",
            "def compose_functions(f, g, variable):\n    \"\"\"\n    Composes two functions f and g where the result is f(g(x)).\n    \n    Parameters:\n    - f (sympy expression): The outer function f in the composition f(g(x)).\n    - g (sympy expression): The inner function g in the composition f(g(x)).\n    - variable (sympy symbol): The main variable symbol used in the functions.\n    \n    Returns:\n    - sympy expression: The resulting function from the composition.\n    \n    Examples:\n    >>> x = symbols('x')\n    >>> f = x**2\n    >>> g = 2*x + 1\n    >>> compose_functions(f, g, x)\n    (2*x + 1)**2\n    \"\"\"\n    composed_function = f.subs(variable, g)\n    return composed_function",
            "def compose_functions(f, g, x):\n    \"\"\"\n    Compose two functions f(g(x)).\n    Parameters:\n    - f (sp.Expr): An expression representing the outer function f.\n    - g (sp.Expr): An expression representing the inner function g.\n    - x (sp.Symbol): The symbolic variable used in both functions.\n    Returns:\n    - sp.Expr: The composed function f(g(x)).\n    \n    Examples:\n    - compose_functions(sp.sin(x), sp.cos(x), x) returns sin(cos(x)).\n    \"\"\"\n    return f.subs(x, g)"
        ],
        [
            "def calculate_limit(expr, var, point):\n    \"\"\"\n    Calculate the limit of a rational function as the variable approaches a given point or infinity.\n    \n    Parameters:\n    - expr (str or sp.Expr): The rational expression for which the limit needs to be found, provided as a string or sympy expression.\n    - var (str or sp.Symbol): The variable in the expression, provided as a string or sympy symbol.\n    - point (str or number): The point (including infinity) to which the variable approaches. Use 'oo' for positive infinity in sympy.\n    Returns:\n    - limit_value (sp.Expr): The calculated limit of the expression as the variable approaches the given point. If the limit does not exist, it returns an appropriate sympy object indicating the limit's nature (e.g., oo, -oo, or NaN).\n    Example:\n    >>> calculate_limit(\"1/x\", \"x\", \"oo\")\n    0\n    \"\"\"\n    if isinstance(expr, str):\n        expr = sp.sympify(expr)\n    if isinstance(var, str):\n        var = sp.Symbol(var)\n    point = sp.oo if point == 'oo' else point\n    limit_value = sp.limit(expr, var, point)\n    return limitSvalue",
            "def calculate_limit_at_infinity(expr):\n    \"\"\"\n    Calculate the limit of a given expression as the variable approaches infinity.\n    Parameters:\n    expr (sympy expression): The mathematical expression for which the limit needs to be computed.\n    Returns:\n    limit_value (sympy expression): The limit of the expression as x approaches infinity.\n    Examples:\n    >>> from sympy import symbols\n    >>> x = symbols('x')\n    >>> expr = (3*x**2 + 2*x + 1) / (x**2 - x + 5)\n    >>> calculate_limit_at_infinity(expr)\n    3\n    \"\"\"\n    x = symbols('x')  # Define the variable\n    return limit(expr, x, oo)"
        ],
        [
            "def find_inverse_function(expr):\n    \"\"\"\n    Finds the inverse of a single-valued function if it exists.\n    Parameters:\n    expr (sympy expression): The function for which the inverse is to be found.\n    Returns:\n    inverse_expr (sympy expression or None): The inverse function expressed in terms of the original independent variable or None if the inverse does not exist.\n    Examples:\n    >>> from sympy import symbols\n    >>> x = symbols('x')\n    >>> y = symbols('y')\n    >>> expr = 2*x + 3\n    >>> find_inverse_function(expr)\n    (y - 3) / 2\n    \"\"\"\n    x, y = symbols('x y')\n    inverse_solution = solve(Eq(y, expr), x)\n    if len(inverse_solution) == 1:\n        return inverse_solution[0]\n    else:\n        return None  # When multiple or no solutions exist indicating non-invertibility or a non-function",
            "def find_inverse_function(expr, symbol=sp.Symbol('x')):\n    \"\"\"\n    Compute the inverse of a given function if it exists.\n    Parameters:\n    expr (sympy expression): A symbolic expression representing the function.\n    symbol (sympy Symbol, optional): The symbol used in the expression, default is 'x'.\n    Returns:\n    sympy expression or None: The inverse function of the provided function, or None if the function does not have an inverse.\n    Examples:\n    >>> x, y = sp.symbols('x y')\n    >>> expr = 2*x + 3\n    >>> find_inverse_function(expr)\n    (y - 3)/2\n    \"\"\"\n    y = sp.Symbol('y')\n    inverse_solution = sp.solve(expr - y, symbol)\n    if not inverse_solution:\n        return None\n    \n    if len(inverse_solution) > 1:\n        raise ValueError(\"The function does not have a unique inverse. It might not be a one-to-one function.\")\n    \n    return inverse_solution[0].subs(symbol, y)"
        ],
        [
            "def evaluate_function_at_point(function_expression, point):\n    \"\"\"\n    Evaluates a mathematical function at a specific point.\n    \n    Parameters:\n        function_expression (str): The algebraic expression of the function.\n        point (float/int): The x-value at which the function should be evaluated.\n    \n    Returns:\n        float: The function value at the specified point.\n    \n    Examples:\n        >>> evaluate_function_at_point('x**2 - 2*x + 1', 5)\n        16\n    \"\"\"\n    x = symbols('x')\n    expression = sympify(function_expression)\n    func = lambdify(x, expression, 'numpy')\n    return func(point)",
            "def evaluate_function(expression, value):\n    \"\"\"\n    Evaluate the function at a specific x value.\n    \n    Parameters:\n        expression (str): The expression of the function in x.\n        value (float): The value to substitute into the function.\n        \n    Returns:\n        float: The computed value of the function at the given x.\n    \"\"\"\n    x = symbols('x')\n    func = sympify(expression)\n    return func.subs(x, value)"
        ],
        [
            "def check_function_properties(f_expr, var, properties):\n    \"\"\"\n    Checks specified properties of the function such as even, odd, increasing, or decreasing.\n    Parameters:\n    f_expr (str or sympy expression): The function expression.\n    var (str): The variable in the function.\n    properties (list): List of properties to check, e.g., ['even', 'odd', 'increasing']\n    Returns:\n    Dict: Dictionary stating the result of each property check.\n    Example:\n    --------\n    >>> check_function_properties('x**2', 'x', ['even', 'increasing'])\n    {'even': True, 'increasing': False}\n    \"\"\"\n    x = sp.symbols(var)\n    func = sp.sympify(f_expr)\n    results = {}\n    for prop in properties:\n        if prop == 'even':\n            results['even'] = sp.simplify(func.subs(x, -x) - func) == 0\n        elif prop == 'odd':\n            results['odd'] = sp.simplify(func.subs(x, -x) + func) == 0\n        elif prop == 'increasing':\n            derivative = sp.diff(func, x)\n            results['increasing'] = sp.solve(derivative > 0)\n        elif prop == 'decreasing':\n            derivative = sp.diff(func, x)\n            results['decreasing'] = sp.solve(derivative < 0)\n    return results",
            "def check_function_properties(func_expr, var_symbol):\n    \"\"\"\n    Analyzes the given function for properties like evenness, oddness, and monotonicity.\n    Parameters:\n    - func_expr (str): The function expressed as a string e.g. 'x**2'.\n    - var_symbol (str): The variable in the function e.g. 'x'.\n    Returns:\n    - dict: A dictionary with properties 'even', 'odd', 'increasing', 'decreasing'.\n    Examples:\n    >>> check_function_properties('x**2', 'x')\n    {'even': True, 'odd': False, 'increasing': False, 'decreasing': False}\n    \"\"\"\n    x = sp.symbols(var_symbol)\n    expr = sp.sympify(func_mu...\n    xn = -x\n    # Check for even: f(-x) == f(x)\n    is_even = sp.simplify(expr.subs(x, xn) - expr) == 0\n    # Check for odd: f(-x) == -f(x)\n    is_odd = sp.simplify(expr.subs(x, xn) + expr) == 0\n    \n    # Check for increasing/decreasing: by evaluating derivative\n    derivative = sp.diff(expr, x)\n    increasing = sp.simplify(derivative > 0)\n    decreasing = sp.simplify(derivative < 0)\n    return {'even': is_even, 'odd': is_odd, 'increasing': increasing, 'decreasing': decreasing}"
        ],
        [
            "def function_monotonicity(f, variable):\n    \"\"\"\n    Assess the monotonicity (increasing or decreasing behavior) of a function.\n    Parameters:\n    - f (sympy expression): The function to analyze.\n    - variable (sympy symbol): The variable in respect to which monotonicity is checked.\n    Returns:\n    - str: A description of the function's monotonicity over its domain.\n    Examples:\n    >>> x = symbols('x')\n    >>> function_monotonicity(x**2, x)\n    'Function is decreasing over (-oo, 0), increasing over (0, oo)'\n    >>> function_monotonicity(log(x), x)\n    'Function is increasing over the interval (0, oo)'\n    \"\"\"\n    derivative = diff(f, variable)\n    if derivative > 0:\n        return f\"Function is increasing over the interval {function_domain(f, variable)}\"\n    elif derivative < 0:\n        return f\"Function is decreasing over the interval {function_domain(f, variable)}\"\n    else:\n        return \"Function has constant monotonicity\"",
            "def function_monotonicity(expression, interval):\n    \"\"\"\n    Determine the increasing or decreasing nature of a function over a given interval.\n    Parameters:\n    - expression : sympy.Expr\n        The mathematical expression representing the function.\n    - interval : sympy.Interval\n        The interval over which the function's monotonicity is to be evaluated.\n    Returns:\n    - str\n        A description of whether the function is increasing, decreasing, or neither over the interval.\n    Examples:\n    >>> x = symbols('x')\n    >>> function_monotonicity(x**3 - 3*x**2 + 2*x, S.Reals)\n    'Increasing on Interval.open(-oo, 0) and Interval.open(1, oo), Decreasing on Interval.open(0, 1)'\n    \"\"\"\n    x = Symbol(expression.free_symbols.pop().name, real=True)\n    derivative = diff(expression, x)\n    critical_points = solve(derivative, x)\n    critical_points = [pt for pt in critical_points if pt.is_real and interval.contains(pt)]\n    intervals = [interval.intersection(interval) for interval in (interval.bisect(pt) for pt in critical_point)]\n    monotonicity = []\n    for sub_interval in intervals:\n        test_point = sub_interval.midpoint\n        if derivative.subs(x, test_point) > 0:\n            monotonicity.append(f\"Increasing on {sub_interval}\")\n        elif derivative.subs(x, test_point) < 0:\n            monotonicity.append(f\"Decreasing on {sub_interval}\")\n    return ', '.join(monotonicity) or \"No monotonicity determined\""
        ],
        [
            "def find_function_range(f, variable):\n    \"\"\"\n    Determines the range of a trigonometric function, especially focusing on critical points derived from derivatives.\n    \n    Parameters:\n    - f (sympy expression): Function whose range needs to be determined.\n    - variable (sympy symbol): The primary variable in the function.\n    \n    Returns:\n    - tuple: A possible range for the function as a description of min and max values.\n    \n    Examples:\n    >>> x = symbols('x')\n    >>> f = sin(x)\n    >>> find_function_range(f, x)\n    (-1, 1)\n    \"\"\"\n    derivative = diff(f, variable)\n    critical_points = solve(derivative, variable)\n    critical_values = [f.subs(variable, cp) for cp in critical_points] + [f.subs(variable, S.Infinity), f.subs(variable, S.NegativeInfinity)]\n    return (min(critical_values), max(critical_values))"
        ],
        [
            "def differentiate_function(f, respect_to):\n    \"\"\"\n    Differentiate a function with respect to a given variable.\n    Parameters:\n    f (sympy expression): The function to be differentiated.\n    respect_to (sympy symbol): The variable with respect to which the differentiation is performed.\n    Returns:\n    sympy expression: The derivative of the function.\n    Examples:\n    >>> x = sp.symbols('x')\n    >>> f = x**2\n    >>> df = differentiate_function(f, x)\n    >>> df\n    2*x\n    \"\"\"\n    return sp.diff(f, respect_to)",
            "def integrate_function(f, respect_to):\n    \"\"\"\n    Integrate a function with respect to a given variable.\n    Parameters:\n    f (sympy expression): The function to be integrated.\n    respect_to (sympy symbol): The variable with respect_to which the integration is performed.\n    \n    Returns:\n    sympy expression: The indefinite integral of the function.\n    Examples:\n    >>> x = sp.symbols('x')\n    >>> f = x**2\n    >>> integral_f = integrate_function(f, x)\n    >>> integral_f\n    x**3/3\n    \"\"\"\n    return sp.integrate(f, respect_to)"
        ],
        [
            "def function_domain(f, variable):\n    \"\"\"\n    Calculate the domain of a single-variable function, handling a variety of function types.\n    Parameters:\n    - f (sympy expression): The function whose domain is to be determined.\n    - variable (sympy symbol): The primary variable in the function.\n    Returns:\n    - sympy set: Symbolic expression of the domain.\n    Examples:\n    >>> x = symbols('x')\n    >>> function_domain(log(x), x)\n    Interval.open(0, oo)\n    >>> function_domain(1/(x-2), x)\n    Union(Interval.open(-oo, 2), Interval.open(2, oo))\n    >>> function_domain(sqrt(x-3), x)\n    Interval(3, oo)\n    \"\"\"\n    return continuous_domain(f, variable, S.Reals)",
            "def function_domain(expression, variable):\n    \"\"\"\n    Analyze and return the domain of the given mathematical expression.\n    Parameters:\n    - expression : sympy.Expr\n        The mathematical expression for which the domain is to be determined.\n    - variable : sympy.Symbol\n        The variable in the expression.\n    Returns:\n    - sympy.Set\n        The domain of the expression as a sympy Set object.\n    Examples:\n    >>> x = symbols('x')\n    >>> function_domain(log(x), x)\n    Interval.open(0, oo)\n    >>> function_domain(sqrt(x) + sqrt(13 - x), x)\n    Interval(0, 13)\n    \"\"\"\n    return solveset(expression.domain_defined(variable), variable, domain=S.Reals)"
        ],
        [
            "def evaluate_function_at_points(func, var, points):\n    \"\"\"\n    Evaluate a symbolic function at multiple points.\n    Parameters:\n        func (sympy expression): The symbolic function to evaluate.\n        var (sympy symbol): The variable used in the function.\n        points (list): A list of points at which to evaluate the function.\n    Returns:\n        list: Results of the function evaluation at the specified points.\n    Examples:\n        x = symbols('x')\n        func = x**2 + 3*x + 2\n        points = [1, 2, 3]\n        print(evaluate_function_at_points(func, x, points))  # Returns [6, 12, 20]\n    \"\"\"\n    lambdified_func = lambdify(var, func)\n    return [lambdified_func(point) for point in points]",
            "def evaluate_function(f, var, at_points):\n    \"\"\"\n    Evaluate a function at specific points.\n    \n    Parameters:\n    - f (sympy expression): The function to be evaluated.\n    - var (sympy.Symbol): The variable in the expression.\n    - at_points (list or single value): Points at which to evaluate the function.\n    \n    Returns:\n    - dict: Values of the function at specified points.\n    \n    Examples:\n    >>> x = sp.symbols('x')\n    >>> f = sp.piecewise_fold(sp.Piecewise((x**2, x<0), (sp.sin(x), x>=0)))\n    >>> evaluate_function(f, x, [-1, 0, 1, 2])\n    {-1: 1, 0: 0, 1: sin(1), 2: sin(2)}\n    \"\"\"\n    if isinstance(at_points, (list, tuple)):\n        return {p: f.subs(var, p) for p in at_points}\n    else:\n        return {at_points: f.subs(var, at_points)}"
        ],
        [
            "def find_intersection(f1, f2, var):\n    \"\"\"\n    Find intersections of two functions.\n    \n    Parameters\n    ----------\n    f1 : sympy.Expr\n        The first function expression.\n    f2 : sympy.Expr\n        The second function expression.\n    var : sympy.Symbol\n        The variable of the functions.\n    \n    Returns\n    -------\n    list\n        List of intersection points as solutions.\n    Examples\n    --------\n    >>> x = sp.Symbol('x')\n    >>> f1 = x**2\n    >>> f2 = x + 2\n    >>> find_intersection(f1, f2, x)\n    [2, -1]\n    \"\"\"\n    return sp.solve(sp.Eq(f1, f2), var)"
        ],
        [
            "def find_horizontal_asymptotes(expr, var):\n    \"\"\"\n    Identify and calculate the horizontal asymptotes of a rational function.\n    \n    Parameters:\n    - expr (str or sp.Expr): The rational expression for which to find horizontal asymptotes, provided as a string or sympy expression.\n    - var (str or sp.Symbol): The variable in the expression, provided as a string or sympy symbol.\n    \n    Returns:\n    - asymptotes (list): A list containing the y-values of horizontal asymptotes. The list may be empty if no horizontal asymptotes exist.\n    Example:\n    >>> find_horizontal_asymptotes(\"x**2 / (x+1)\", \"x\")\n    [1]\n    \"\"\"\n    if isinstance(expr, str):\n        expr = sp.sympify(expr)\n    if isinstance(var, str):\n        var = sp.Symbol(var)\n    asymptotes = []\n    # Check limits at positive and negative infinity\n    for point in [sp.oo, -sp.oo]:\n        try:\n            lim_val = sp.limit(expr, var, point)\n            if lim_val.is_real:\n                asymptotes.append(lim_val)\n        except (sp.PoleError, ValueError):\n            continue\n    return list(set(asymptotes))  # Return unique asymptotes",
            "def find_horizontal_asymptotes(expr):\n    \"\"\"\n    Identifies and calculates horizontal asymptotes of the given rational function.\n    Parameters:\n    expr (sympy expression): A rational function expression.\n    Returns:\n    asymptotes (list): A list containing the horizontal asymptotes of the function, if any. Returns an empty list if no horizontal asymptotes are found.\n    Examples:\n    >>> from sympy import symbols\n    >>> x = symbols('x')\n    >>> expr = (2*x**2 - 3*x + 4) / (x**2 - 2*x + 3)\n    >>> find_horizontal_asymptotes(expr)\n    [2]\n    \"\"\"\n    limit_at_inf = calculate_limit_at_infinity(expr)\n    limit_at_neg_inf = calculate_limit_at_infinity(-expr)\n    asymptotes = set([limit_at_inf, limit_at_neg_inf]) - set([oo, -oo])\n    return list(asymptotes)",
            "def find_horizontal_asymptotes(expr, symbol=sp.Symbol('x')):\n    \"\"\"\n    Calculate the horizontal asymptotes of a given rational function.\n    Parameters:\n    expr (sympy expression): A symbolic expression representing the rational function.\n    symbol (sympy Symbol, optional): The symbol used in the expression, default is 'x'.\n    Returns:\n    list: A list of y-values where the function has horizontal asymptotes as x tends to infinity and negative infinity.\n    Examples:\n    >>> f = sp.symbols('f', cls=sp.Function)\n    >>> expr = (2*f(x)**2 + 3*f(x) + 1) / (f(x)**2 + f(x))\n    >>> find_horizontal_asymptotes(expr, f(x))\n    [2]\n    \"\"\"\n    # Simplify the function\n    simplified_expr = sp.simplify(expr)\n    \n    # Check if the expression is a rational function\n    if not isinstance(simplified_expr, sp.core.mul.Mul) and not any(isinstance(arg, sp.core.power.Pow) for arg in simplified_expr.args):\n        raise ValueError(\"The provided expression is not a rational function.\")\n    \n    # Apply limit to find horizontal asymptotes\n    asymptote_pos_inf = sp.limit(expr, symbol, sp.oo)\n    asymptote_neg_inf = sp.limit(expr, symbol, -sp.oo)\n    # Eliminate cases where the limit is infinity (no horizontal asymptote there)\n    asymptotes = []\n    if asymptote_pos_inf.is_finite:\n        asymptotes.append(asymptote_pos_inf)\n    if asymptote_neg_inf.is_finite:\n        asymptotes.append(asymptote_neg_inf)\n    \n    # Return unique asymptotes since +-inf might have the same y-value\n    return list(set(asymptotes))"
        ],
        [
            "def analyze_function_properties(f, var):\n    \"\"\"\n    Analyze the properties of a function such as periodicity, evenness, and oddness.\n    \n    Parameters:\n    - f (sympy expression): The function to be analyzed, expressed in symbolic terms.\n    - var (sympy.Symbol): The variable in the expression.\n    \n    Returns:\n    - dict: A dictionary containing properties like 'is_periodic', 'is_even', and 'is_odd'.\n    \n    Examples:\n    >>> x = sp.symbols('x')\n    >>> f = sp.sin(x)\n    >>> analyze_function_properties(f, x)\n    {'is_periodic': True, 'period': 2*pi, 'is_even': False, 'is_odd': True}\n    \"\"\"\n    properties = {}\n    properties['is_periodic'] = f.is_periodic(var)\n    if properties['is_periodic']:\n        properties['period'] = f.period(var)\n    properties['is_even'] = f.is_even()\n    properties['is_odd'] = f.is_odd()\n    \n    return properties",
            "def trigonometric_properties(func, variable):\n    \"\"\"\n    Analyze properties such as periodicity and even-odd nature of a trigonometric function.\n    \n    Parameters:\n    - func (sympy expression): Trigonometric function.\n    - variable (sympy.Symbol): The main variable in the function.\n    Returns: \n    - dict: Properties including 'periodicity', 'is_even', 'is_odd'.\n    \n    Examples:\n    >>> x = symbols('x')\n    >>> trigonometric_properties(sin(x), x)\n    {'periodicity': 2*pi, 'is_even': False, 'is_odd': True}\n    \"\"\"\n    from sympy import pi\n    properties = {}\n    properties['periodicity'] = 2 * pi # Assuming base trig functions for simplicity\n    properties['is_even'] = func.subs(variable, -variable) == func\n    properties['is_odd'] = func.subs(variable, -variable) == -func\n    return properties",
            "def analyze_function_properties(func, variable):\n    \"\"\"\n    Analyzes the properties of a function such as periodicity, whether it is even or odd.\n    \n    Parameters:\n    func (sp.Expr): The function expression, as a Sympy expression.\n    variable (sp.Symbol): The variable used in the function.\n    \n    Returns:\n    dict: Properties including 'is_even', 'is_odd', and 'period'\n    \n    Example:\n    >>> x = sp.symbols('x')\n    >>> analyze_function_properties(sp.sin(x), x)\n    {'is_even': False, 'is_odd': True, 'period': 2*pi}\n    \"\"\"\n    properties = {}\n    properties['is_even'] = sp.simplify(func.subs(variable, -variable) - func) == 0\n    properties['is_odd'] = sp.simplify(func.subs(variable, -variable) + func) == 0\n    properties['period'] = sp.periodicity(func, variable)\n    \n    return properties"
        ],
        [
            "def differentiate_function(expr, var, point=None):\n    \"\"\"\n    Differentiate an expression with respect to a given variable and optionally evaluate at a specific point.\n    \n    Parameters:\n        expr (sympy expression): The symbolic expression of the function.\n        var (sympy symbol): The variable with respect to which the expression is differentiated.\n        point (float, optional): The point at which the derivative is evaluated. If None, the function returns a symbolic derivative.\n    Returns:\n        sympy expression or float: The derivative of the function as a symbolic expression or the evaluation result at a given point.\n    \n    Examples:\n        x = symbols('x')\n        expr = x**2 + 3*x + 2\n        print(differentiate_function(expr, x))  # Returns 2*x + 3\n        print(differentiate_function(expr, x, point=1))  # Returns 5\n    \"\"\"\n    derivative = diff(expr, var)\n    if point is not None:\n        return derivative.subs(var, point)\n    return derivative",
            "def differentiate_and_evaluate(f_expr, var, at_value=None):\n    \"\"\"\n    Differentiates the given function and optionally evaluates it at a specific point.\n    Parameters:\n    f_expr (str or sympy expression): The mathematical function expression, e.g., 'sin(x) + x**2'.\n    var (str): The variable with respect to which differentiation is to be performed.\n    at_value (numeric, optional): The point at which the differentiated function should be evaluated.\n    Returns:\n    sympy expression: The derivative of the function.\n    numeric (optional): The value of the derivative at a specific point, if `at_value` is provided.\n    Example:\n    --------\n    >>> differentiate_and_evaluate('x**2 + 3*x + 2', 'x', at_value=1)\n    (2*x + 3, 5)\n    \"\"\"\n    x = sp.symbols(var)\n    func = sp.sympify(f_env_expr)\n    df = sp.diff(func, x)\n    if at_value is not None:\n        value = df.subs(x, at_value)\n        return df, value\n    return df",
            "def differentiate_and_evaluate(func_expr, var_symbol, point=None):\n    \"\"\"\n    Differentiates a function with respect to a given variable and evaluates it at a specified point if provided.\n    Parameters:\n    - func_expr (str): The mathematical expression in string form e.g. 'x**2 + 3*x + 2'.\n    - var_symbol (str): The symbol of the variable to differentiate with respect to e.g. 'x'.\n    - point (float, optional): The point at which to evaluate the derivative. If None, the function will return the derivative expression.\n    Returns:\n    - sympy expression or numerical value: The derivative as an expression if point is None, otherwise the evaluated value at `point`.\n    Examples:\n    >>> differentiate_and_evaluate('x**2 + 3*x + 2', 'x', 1)\n    5\n    >>> differentiate_and_evaluate('sin(x)', 'x')\n    cos(x)\n    \"\"\"\n    x = sp.symbols(var_symbol)\n    expr = sp.sympify(func_expr)\n    derivative = sp.diff(expr, x)\n    return derivative.subs(x, point) if point is not None else derivative"
        ],
        [
            "def substitute_function(f, var, subs_var):\n    \"\"\"\n    Substitute variable in a function expression.\n    \n    Parameters\n    ----------\n    f : sympy.Expr\n        The function expression.\n    var : sympy.Symbol\n        The original variable in the function.\n    subs_var : sympy.Expr\n        The expression to substitute for the original variable.\n    \n    Returns\n    -------\n    sympy.Expr\n        The substituted function.\n    \n    Examples\n    --------\n    >>> x = sp.Symbol('x')\n    >>> f = x**2 + 1\n    >>> substitute_function(f, x, x + 2)\n    (x + 2)**2 + 1\n    \"\"\"\n    return f.subs(var, subs_var)"
        ],
        [
            "def reflect_function(expression, axis='x'):\n    \"\"\"\n    Reflect the function across a specified axis ('x' or 'y').\n    \n    Parameters:\n        expression (str): The expression of the function in x.\n        axis (str): The axis to reflect across ('x' or 'y').\n    Returns:\n        sympy expression: New function expression after reflection.\n    \"\"\"\n    x = symbols('x')\n    func = sympify(expression)\n    if axis == 'x':\n        reflected_func = func * -1\n    elif axis == 'y':\n        reflected_func = func.subs(x, -x)\n    else:\n        raise ValueError(\"axis must be 'x' or 'y'\")\n    return reflected_func"
        ],
        [
            "def parametric_to_cartesian(x_t, y_t, t):\n    \"\"\"\n    Converts parametric equations to Cartesian form.\n    Parameters:\n    x_t (sympy expression): Parametric expression for x in terms of parameter t.\n    y_t (sympy expression): Parametric expression for y in terms of parameter t.\n    t (sympy symbol): The symbol used as the parameter in parametric equations.\n    Returns:\n    sympy expression: Cartesian form of the equation.\n    Examples:\n    >>> t = sp.symbols('t')\n    >>> x_t = sp.cos(t)\n    >>> y_t = sp.sin(t)\n    >>> cartesian_form = parametric_to_cartesian(x_t, y_t, t)\n    >>> cartesian_form\n    x**2 + y**2 - 1\n    \"\"\"\n    x, y = sp.symbols('x y')\n    cartesian = sp.Eq(x_t.subs(t, sp.solve(x_t - x, t)[0]), y)\n    cartesian = sp.simplify(cartesian.subs(y, y_t))\n    return cartesian",
            "def parametric_to_cartesian(param_eq_x, param_eq_y, t):\n    \"\"\"\n    Convert parametric equations to Cartesian form.\n    \n    Parameters\n    ----------\n    param_eq_x : sympy.Expr\n        The parametric equation for x as a function of parameter t.\n    param_eq_y : sympy.Expr\n        The parametric equation for y as a function of parameter t.\n    t : sympy.Symbol\n        The parameter used in parametric equations.\n    \n    Returns\n    -------\n    sympy.Eq\n        The Cartesian equation.\n    \n    Examples\n    --------\n    >>> t = sp.Symbol('t')\n    >>> x = t**2 + 1\n    >>> y = t + 1\n    >>> parametric_to_cartesian(x, y, t)\n    x - (y - 1)**2 - 1\n    \"\"\"\n    x, y = sp.symbols('x y')\n    eq_x = sp.Eq(x, param_eq_x)\n    eq_y = sp.Eq(y, param_eq_y)\n    t_solutions = sp.solve(eq_x, t)\n    \n    cartesian_eq = []\n    for sol in t_solutions:\n        cartesian_eq.append(sp.simplify(eq_y.subs(t, sol)))\n    \n    return cartesian_eq"
        ],
        [
            "def translate_function(f, var, translation):\n    \"\"\"\n    Translate the function horizontally or vertically.\n    \n    Parameters\n    ----------\n    f : sympy.Expr\n        The function to be translated.\n    var : sympy.Symbol\n        The variable of the function.\n    translation : sympy.Expr\n        The translation vector.\n    \n    Returns\n    -------\n    sympy.Expr\n        The translated function.\n    \n    Examples\n    --------\n    >>> x = sp.Symbol('x')\n    >>> f = x**2\n    >>> translate_function(f, x, 2)\n    (x - 2)**2\n    \"\"\"\n    return f.subs(var, var - translation)"
        ],
        [
            "def evaluate_piecewise_function(conditions_functions, value):\n    \"\"\"\n    Evaluate a piecewise function at a given value.\n    Parameters:\n    - conditions_functions (list of tuples): Each tuple corresponds to (condition, function),\n      where `condition` is a sympy relation that the value must satisfy, and `function` is \n      what should be evaluated if the condition is True.\n    - value (number): The point at which to evaluate the piecewise function.\n    \n    Returns:\n    - result (expression/value): Result after evaluating the appropriate piecewise branch.\n    \n    Examples:\n    >>> x = symbols('x')\n    >>> conditions_functions = [(x < 0, x**2), (x >= 0, x+3)]\n    >>> evaluate_piecewise_function(conditions_functions, -1)\n    1\n    \"\"\"\n    from sympy import Piecewise\n    pw_func = Piecewise(*conditions_functions)\n    return pw_func.subs(variable, value)"
        ],
        [
            "def definite_integral(expression, lower, upper):\n    \"\"\"\n    Calculates the definite integral of the function between two bounds.\n    \n    Parameters:\n        expression (str): The expression of the function in x.\n        lower (float): The lower bound of integration.\n        upper (float): The upper bound of integration.\n    Returns:\n        float: The area under the function from lower to upper.\n    \"\"\"\n    x = symbols('x')\n    func = sympify(expression)\n    integral_value = integrate(func, (x, lower, upper))\n    return integral_value"
        ],
        [
            "def factorize_expression(expr):\n    \"\"\"\n    Factorize a given expression.\n    \n    Parameters\n    ----------\n    expr : sympy.Expr\n        The expression to be factorized.\n    \n    Returns\n    -------\n    sympy.Expr\n        The factorized expression.\n    \n    Examples\n    --------\n    >>> x = sp.Symbol('x')\n    >>> expr = x**2 - 4\n    >>> factorize_expression(expr)\n    (x - 2)*(x + 2)\n    \"\"\"\n    return sp.factor(expr)"
        ],
        [
            "def transform_function(f, transformation={'translate': (0, 0), 'scale': (1, 1)}):\n    \"\"\"\n    Perform transformations on a given function including translation and scaling.\n    Parameters:\n    f (sympy expression): The function to be transformed, expressed in sympy format.\n    transformation (dict): A dictionary containing the translation and scaling parameters.\n        Expected keys are 'translate' with a tuple for (x-shift, y-shift) and \n        'scale' with a tuple for (x-scale, y-scale).\n    Returns:\n    sympy expression: The transformed function.\n    Examples:\n    >>> x = sp.symbols('x')\n    >>> f = x**2\n    >>> transformed_f = transform_function(f, {'translate': (2, 0), 'scale': (1, 3)})\n    >>> transformed_f\n    3*(x - 2)**2\n    \"\"\"\n    x, y = sp.symbols('x y')\n    x_shift, y_shift = transformation['translate']\n    x_scale, y_scale = transformation['scale']\n    # Apply scaling then translation\n    scaled_f = (f.subs(x, x / x_scale)) * y_scale\n    translated_f = scaled_f.subs(x, x - x_shift) + y_shift\n    return translated_f"
        ],
        [
            "def solve_function_equation(expr, var, target):\n    \"\"\"\n    Solve a function equation \\( f(x) = target \\) for the given variable.\n    Parameters:\n        expr (sympy expression): The symbolic expression of the function.\n        var (sympy symbol): The variable in the expression.\n        target: The target value to which the function is set.\n    Returns:\n        list: Solutions to the equation.\n    Examples:\n        x = symbols('x')\n        expr = x**2 - 4*x + 4\n        print(solve_function_equation(expr, x, 0))  # Returns [2]\n    \"\"\"\n    equation = Eq(expr, target)\n    return solve(equation, var)"
        ],
        [
            "def subtract_functions(function_expression1, function_expression2, x_value):\n    \"\"\"\n    Subtracts the second function from the first at a specific x-value.\n    \n    Parameters:\n        function_expression1 (str): The expression for the first function.\n        function_expression2 (str): The expression for the second function.\n        x_value (float/int): The x-value at which to perform the subtraction.\n        \n    Returns:\n        float: The result of the subtraction at the specified x-value.\n        \n    Examples:\n        >>> subtract_functions('x**2', '2*x', 3)\n        3\n    \"\"\"\n    x = symbols('x')\n    f1 = sympify(function_expression1)\n    f2 = sympify(function_expression2)\n    f_sub = f1 - f2\n    func_sub = lambdify(x, f_sub, 'numpy')\n    return func_sub(x_value)"
        ],
        [
            "def check_continuity(expr, var, point):\n    \"\"\"\n    Check if a function is continuous at a given point.\n    \n    Parameters:\n        expr (sympy expression): The symbolic expression of the function.\n        var (sympy symbol): The variable in the expression.\n        point (float): The point at which continuity is checked.\n    Returns:\n        bool: True if the function is continuous at the specified point, False otherwise.\n    \n    Examples:\n        x = symbols('x')\n        expr = Piecewise((x**2, x < 0), (x + 2, x >= 0))\n        print(check_continuity(expr, x, 0))  # Returns False\n    \"\"\"\n    left_limit = expr.subs(var, point - 1e-6)\n    right_limit = expr.subs(var, point + 1e-6)\n    point_value = expr.subs(var, point)\n    return abs(left_limit - point_value) < 1e-5 and abs(right_limit - point_value) < 1e-5"
        ],
        [
            "def analyze_transformation_effects(original_expr, transformed_expr, variable):\n    \"\"\"\n    Analyze the effects of transformations on the domain and range of a function.\n    Parameters:\n    - original_expr : sympy.Expr\n        The original mathematical expression.\n    - transformed_expr : sympy.Expr\n        The transformed mathematical expression.\n    - variable : sympy.Symbol\n        The variable in the expressions.\n    Returns:\n    - dict\n        Dictionary containing original and transformed domains and ranges.\n    Examples:\n    >>> x = symbols('x')\n    >>> analyze_transformation_effects(x**2, 2*x**2 - 3, x)\n    {'Original Domain': '(-oo, oo)', 'Transformed Domain': '(-oo, oo)',\n     'Original Range': '[0, oo)', 'Transformed Range': '[-3, oo)'}\n    \"\"\"\n    original_domain = function_domain(original_expr, variable)\n    transformed_domain = function_domain(transformed_expr, variable)\n    original_range = solveset(original_expr, variable, domain=S.Reals)\n    transformed_range = solveset(transformed_expr, variable, domain=S.Reals)\n    \n    return {\n        \"Original Domain\": str(original_domain),\n        \"Transformed Domain\": str(transformed_domain),\n        \"Original Range\": str(original_range),\n        \"Transformed Range\": str(transformed_range)\n    }"
        ],
        [
            "def vertical_scale_function(f, scale_factor):\n    \"\"\"\n    Apply vertical scaling to a function.\n    \n    Parameters\n    ----------\n    f : sympy.Expr\n        The function to be scaled.\n    scale_factor : float\n        The scaling factor.\n    \n    Returns\n    -------\n    sympy.Expr\n        The scaled function.\n    \n    Examples\n    --------\n    >>> x = sp.Symbol('x')\n    >>> f = x**2 + 2\n    >>> vertical_scale_function(f, 3)\n    3*(x**2 + 2)\n    \"\"\"\n    return scale_factor * f"
        ],
        [
            "def analyze_function_properties(expression_string, variable_string='x'):\n    \"\"\"\n    Analyze various properties of a function including its domain, monotonicity, and the possibility of calculating its range.\n    Parameters:\n    expression_string : str\n        A string that defines the mathematical expression for the function.\n    variable_string : str\n        The main variable used in the function, default is 'x'.\n    Returns:\n    dict\n        Returns a dictionary containing the domain, ranges where the function is monotonic, and a symbolic range if calculable.\n    Examples:\n    >>> analyze_function_properties(\"log(x) + 1/x\")\n    {'domain': Interval.open(0, oo), 'monotonic_intervals': [Interval.open(0, oo)], 'range': 'Cannot determine range algebraically'}\n    >>> analyze_function_properties(\"x**2 - 4*x + 4\")\n    {'domain': Reals, 'monotonic_intervals': [Interval.open(-oo, 2), Interval.open(2, oo)], 'range': Interval(0, oo)}\n    \"\"\"\n    x = sp.symbols(variable_string)\n    expression = sp.sympify(expression_string)\n    \n    # Determine the domain:\n    domain = sp.calculus.util.continuous_domain(expression, x, sp.S.Reals)\n    \n    # Find derivative and analyze monotonicity:\n    derivative = sp.diff(expression, x)\n    critical_points = sp.solveset(derivative, x, domain=sp.S.Reals)\n    monotonic_intervals = sp.calculus.util.monotonicity_intervals(derivative, domain)\n    \n    # Try to determine the range:\n    try:\n        function_range = sp.calculus.util.function_range(expression, x, domain)\n    except:\n        function_range = \"Cannot determine range algebraically\"\n    return {\n        'domain': domain,\n        'monotonic_intervals': monotonic_intervals,\n        'range': function_range\n    }"
        ],
        [
            "def evaluate_graph_properties(f, x_range, properties):\n    \"\"\"\n    Evaluate various properties of a function's graph such as intercepts, minima, and continuity over a specified range.\n    \n    Parameters:\n        f (sympy expression): The function to analyze.\n        x_range (tuple): The range (start, end) of x values to consider.\n        properties (list): List of properties to evaluate ('intercepts', 'minima', 'continuity').\n    \n    Returns:\n        dict: A dictionary with requested properties and their evaluated results.\n    \n    Examples:\n        >>> x = sp.symbols('x')\n        >>> f = x ** 2 - 4 * x + 4\n        >>> print(evaluate_graph_properties(f, (-10, 10), ['intercepts', 'minima']))\n        {'intercepts': [2], 'minima': [(2, 0)]}\n    \"\"\"\n    x = sp.symbols('x')\n    results = {}\n    \n    if 'intercepts' in properties:\n        results['intercepts'] = [sp.solve(f, x)]\n    \n    if 'minima' in properties:\n        deriv = sp.diff(f, x)\n        critical_points = sp.solve(deriv, x)\n        second_deriv = sp.diff(deriv, x)\n        minima = [(cp, f.subs(x, cp)) for cp in critical_points if second_deriv.subs(x, cp) > 0]\n        results['minima'] = minima\n    \n    if 'continuity' in properties:\n        points_of_discontinuity = sp.singularities(f, x)\n        continuous = all(p not in x_range for p in points_of_discontinuity)\n        results['continuity'] = continuous\n    return results"
        ],
        [
            "def translate_function(expression, horizontal_shift=0, vertical_shift=0):\n    \"\"\"\n    Apply horizontal and vertical translations to the function expression.\n    \n    Parameters:\n        expression (str): The expression of the function in x.\n        horizontal_shift (float): The shift along the x-axis (positive right, negative left).\n        vertical_shift (float): The shift along the y-axis (positive up, negative down).\n    Returns:\n        sympy expression: New function expression after translation.\n    \"\"\"\n    x = symbols('x')\n    func = sympify(expression)\n    transformed_func = func.subs(x, x - horizontal_shift) + vertical_shift\n    return transformed_func"
        ],
        [
            "def function_operations(f_expr1, f_expr2, operation, var):\n    \"\"\"\n    Performs a specified operation between two functions.\n    \n    Parameters:\n    f_expr1 (str or sympy expression): The first function expression.\n    f_expr2 (str or sympy expression): The second function expression.\n    operation (str): Operation to perform. Should be one of ['add', 'subtract', 'multiply', 'divide'].\n    var (str): The variable used in both functions.\n    Returns:\n    sympy expression: Result of the operation between the two functions.\n    Example:\n    --------\n    >>> function_operations('x**2', 'x + 1', 'add', 'x')\n    x**2 + x + 1\n    \"\"\"\n    x = sp.symbols(var)\n    func1 = sp.sympify(f_expr1)\n    func2 = sp.sympify(f_expr2)\n    if operation == 'add':\n        result = func1 + func2\n    elif operation == 'subtract':\n        result = func1 - func2\n    elif operation == 'multiply':\n        result = func1 * func2\n    elif operation == 'divide':\n        result = func1 / func2\n    else:\n        raise ValueError(\"Invalid operation. Choose from 'add', 'subtract', 'multiply', 'divide'.\")\n    return result"
        ],
        [
            "def simplify_expression(expr_str):\n    \"\"\"\n    Simplifies a given mathematical expression.\n    Parameters:\n    - expr_str (str): The expression to simplify, as a string.\n    Returns:\n    - sympy expression: The simplified expression.\n    Examples:\n    >>> simplify_expression('x**2 - 2*x + 1')\n    (x - 1)**2\n    \"\"\"\n    expr = sp.sympify(expr_str)\n    return sp.simplify(expr)"
        ],
        [
            "def find_intercepts(function_expression):\n    \"\"\"\n    Finds the x-intercepts of a given function where f(x) = 0.\n    \n    Parameters:\n        function_expression (str): The algebraic expression of the function.\n    \n    Returns:\n        list: A list of x-values where the function intercepts the x-axis.\n        \n    Examples:\n        >>> find_intercepts('x**2 - 4')\n        [-2, 2]\n    \"\"\"\n    x = symbols('x')\n    expression = sympify(function_expression)\n    intercepts = solve(expression, x)\n    return intercepts"
        ],
        [
            "def find_horizontal_translation(function_expression, translation_value):\n    \"\"\"\n    Finds the new expression of a function after a horizontal translation.\n    \n    Parameters:\n        function_expression (str): The algebraic expression of the function.\n        translation_value (float/int): The value to translate the function on the x-axis.\n    \n    Returns:\n        str: The algebraic expression of the translated function.\n        \n    Examples:\n        >>> find_horizontal_translation('x**2', -3)\n        '(x + 3)**2'\n    \"\"\"\n    x = symbols('x')\n    expression = sympify(function_expression)\n    translated_expr = expression.subs(x, x - translation_value)\n    return str(translated_expr)"
        ],
        [
            "def apply_pytogorean_identity(expr, x):\n    \"\"\"\n    Apply the Pythagorean identity to replace sin^2(x) or cos^2(x) in the expression.\n    Parameters:\n    expr (sympy.Expr): Expression to modify\n    x (sympy.Symbol): symbol representing the variable in expression\n    \n    Returns:\n    sympy.Expr: Expression after applying the identity\n    \n    Examples:\n    >>> x = symbols('x')\n    >>> expr = sin(x)**2 + 3\n    >>> apply_pytogorean_identity(expr, x)\n    1 - cos(x)**2 + 3\n    \"\"\"\n    expr = expr.subs(sin(x)**2, 1 - cos(x)**2)\n    return expr.subs(cos(x)**2, 1 - sin(x)**2)"
        ],
        [
            "def polar_to_cartesian(r, theta):\n    \"\"\"\n    Convert polar coordinates to Cartesian coordinates.\n    \n    Parameters\n    ----------\n    r : sympy.Expr\n        The polar radius.\n    theta : sympy.Symbol\n        The polar angle.\n    \n    Returns\n    -------\n    tuple\n        A tuple containing the x and y expressions in Cartesian coordinates.\n    \n    Examples\n    --------\n    >>> r = sp.symbols('r')\n    >>> theta = sp.symbols('theta')\n    >>> polar_to_cartesian(r, theta)\n    (r*cos(theta), r*sin(theta))\n    \"\"\"\n    x = r * sp.cos(theta)\n    y = r * sp.sin(theta)\n    return x, y"
        ],
        [
            "def function_composition(outer_function_expr, inner_function_expr, x_value):\n    \"\"\"\n    Composes two functions (f(g(x))) and evaluates at a specific x-value.\n    \n    Parameters:\n        outer_function_expr (str): The expression for the outer function f(x).\n        inner_function_expr (str): The expression for the inner function g(x).\n        x_value (float/int): The x-value to evaluate the composition at.\n        \n    Returns:\n        float: The result of the composed function evaluated at `x_value`.\n        \n    Examples:\n        >>> function_composition('x+1', 'x**2', 2)\n        5\n    \"\"\"\n    x = symbols('x')\n    g = sympify(inner_function_expr)\n    f = sympify(outer_function_expr)\n    composed_expr = f.subs(x, g)\n    composed_func = lambdify(x, composed_expr, 'numpy')\n    return composed_func(x_value)"
        ],
        [
            "def function_transformation_domain(f, variable, transformation):\n    \"\"\"\n    Determine the domain of a transformed function.\n    Parameters:\n    - f: sympy expression of the base function\n    - variable: sympy symbol for the variable in f\n    - transformation: A function applying a transformation to 'f'\n    Returns:\n    - sympy set: The domain of the transformed function.\n    Examples:\n    >>> x = symbols('x')\n    >>> transformation = lambda f, x: f + 2*x\n    >>> function_transformation_domain(x**2, x, transformation)\n    Interval(-oo, oo)\n    \"\"\"\n    transformed_f = transformation(f, variable)\n    return function_domain(transformed_f, variable)"
        ],
        [
            "def derivative_function(expression, point):\n    \"\"\"\n    Calculates the derivative of the function at a specific point.\n    \n    Parameters:\n        expression (str): The expression of the function in x.\n        point (float): The x value at which to evaluate the derivative.\n    Returns:\n        float: The derivative of the function at the given point.\n    \"\"\"\n    x = symbols('x')\n    func = sympify(expression)\n    deriv = diff(func, x)\n    return deriv.subs(x, point)"
        ]
    ],
    "Optimization": [
        [
            "def function_optimization(f_expr, var, domain=(None, None)):\n    \"\"\"\n    Perform optimization analysis on a given symbolic expression to find critical points, and local minima and maxima.\n    \n    Parameters:\n        f_expr (sp.Expr): The symbolic expression of the function to optimize.\n        var (sp.Symbol): The main variable in the function.\n        domain (tuple, optional): A tuple (min, max) defining the domain of interest. None in any position means unbounded in that direction.\n    \n    Returns:\n        dict: A dictionary containing critical points, local minima, and local maxima within the given domain.\n    \n    Examples:\n        >>> x = sp.symbols('x')\n        >>> f = x**2 - 4*x + 4\n        >>> function_optimization(f, x)\n        {\n            'critical_points': [2],\n            'local_minima': [2],\n            'local_maxima': [],\n            'saddle_points': []\n        }\n    \"\"\"\n    f_diff = sp.diff(f_expr, var)\n    critical_points = sp.solveset(f_diff, var, domain=sp.Interval(*domain))\n    \n    extrema = {\n        'critical_points': sorted(list(critical_points)),\n        'local_minima': [],\n        'local_maxima': [],\n        'saddle_points': []\n    }\n    \n    # Second derivative test\n    f_ddiff = sp.diff(f_diff, var)\n    for cp in critical_points:\n        cp_value = f_ddiff.subs(var, cp)\n        if cp_value > 0:\n            extrema['local_minima'].append(cp)\n        elif cp_value < 0:\n            extrema['local_maxima'].append(cp)\n        else:\n            extrema['saddle_points'].append(cp)\n            \n    return extrema",
            "def find_critical_points(function_expr, var, interval=None):\n    \"\"\"\n    Finds critical points of a single variable function and determines their nature (maxima, minima, or saddle points).\n    Parameters:\n        function_expr (str): The mathematical expression of function as a string.\n        var (str): The variable in the expression.\n        interval (tuple, optional): An interval (start, end) within which to find critical points.\n    Returns:\n        dict: A dictionary with critical points and their nature {'critical_points': list, 'maxima': list, 'minima': list, 'saddle_points': list}\n    Example:\n        >>> find_critical_points('x**3 - 6*x**2 + 9*x + 3', 'x')\n        {'critical_points': [-1, 1, 3], 'maxima': [3], 'minima': [1], 'saddle_points': []}\n    \"\"\"\n    x = sp.symbols(var)\n    f = sp.sympify(function_expr)\n    \n    # First derivative and critical points\n    f_prime = sp.diff(f, x)\n    critical_points = list(sp.solveset(f_prime, x, domain=sp.S.Reals))\n    # Second derivative to determine nature\n    f_double_prime = sp.diff(f_prime, x)\n    maxima = []\n    minima = []\n    saddle_points = []\n    for cp in critical_points:\n        cp_value = cp.evalf()\n        if interval and not (interval[0] <= cp_value <= interval[1]):\n            continue\n        second_derivative_test = f_double_prime.subs(x, cp)\n        # Check nature of critical point\n        if second_derivative_test > 0:\n            minima.append(cp)\n        elif second_derivative_test < 0:\n            maxima.append(cp)\n        else:\n            saddle_points.append(cp)\n    result = {\n        'critical_points': critical_points,\n        'maxima': maxima,\n        'minima': minima,\n        'saddle_points': saddle_points\n    }\n    return result",
            "def find_critical_points(function_expr, variable_expr):\n    \"\"\"\n    Calculate the critical points of a given function by finding the derivative\n    and setting it to zero. This includes points inside the domain and checks\n    endpoints if the function domain is limited.\n    \n    Parameters:\n    - function_expr (str): A string expression representing the function.\n    - variable_expr (str): The variable in the function expression.\n    Returns:\n    - list: Critical points and their nature {'point': value, 'nature': str}\n    \n    Examples:\n    >>> find_critical_points(\"x**2 - 4*x + 4\", \"x\")\n    [{'point': 2, 'nature': 'minima'}]\n    \"\"\"\n    x = sp.symbols(variable_expr)\n    f = sp.sympify(function_expr)\n    \n    # First derivative\n    f_prime = sp.diff(f, x)\n    critical_points = sp.solveset(f_prime, x, domain=sp.S.Reals)\n    \n    # Second derivative for nature of critical points\n    f_double_prime = sp.diff(f_prime, x)\n    \n    result = []\n    for p in critical_points:\n        nature = \"minima\" if f_double_prime.subs(x, p) > 0 else \"maxima\"\n        result.append({'point': p, 'nature': nature})\n    \n    return result"
        ],
        [
            "def apply_am_gm_inequality(variables, values=None, equality_condition=False):\n    \"\"\"\n    Apply the Arithmetic Mean-Geometric Mean (AM-GM) Inequality to find bounds\n    or check for equality conditions.\n    \n    Parameters:\n        variables (list of sympy.Symbol): List of variables in the inequality.\n        values (list of numbers, optional): Real values assigned to variables for computation.\n                                           Must match the order of variables if provided.\n        equality_condition (bool): If True, checks and returns conditions when AM-GM equality holds.\n    \n    Returns:\n        tuple: Contains the AM-GM inequality statement, and optionally, equality conditions.\n    \n    Example:\n        >>> x, y = sp.symbols('x y')\n        >>> apply_am_gm_inequality([x, y])\n        (x/2 + y/2 >= sqrt(x*y), [])\n        >>> apply_am_gm_inequality([x, y], equality_condition=True)\n        (x/2 + y/2 >= sqrt(x*y), [x = y])\n    \"\"\"\n    n = len(variables)\n    arithmetic_mean = sp.Sum(variables[i] for i in range(n)) / n\n    geometric_mean = sp.prod(variables[i] for i in range(n)) ** (1/n)\n    inequality = sp.Ge(arithmetic_mean, geometric_mean)\n    if values is not None:\n        values_dict = {variables[i]: values[i] for i in range(n)}\n        inequality = inequality.subs(values_dict)\n    equality_conditions = []\n    if equality_condition:\n        equality_conditions = [sp.Eq(variables[i], variables[(i+1) % n]) for i in range(n)]\n    return (inequality, equality_conditions)",
            "def apply_qm_am_inequality(variables, values=None):\n    \"\"\"\n    Apply the Quadratic Mean - Arithmetic Mean (QM-AM) Inequality to find lower bounds.\n    \n    Parameters:\n        variables (list of sympy.Symbol): List of variables in the inequality.\n        values (list of numbers, optional): Real values assigned to variables for computation.\n                                           Must match the order of variables if provided.\n    \n    Returns:\n        sympy inequality: Represents the QM-AM inequality applied to the given variables.\n    \n    Example:\n        >>> x, y = sp.symbols('x y')\n        >>> apply_qm_am_inequality([x, y])\n        sqrt((x**2 + y**2)/2) >= (x + y)/2\n    \"\"\"\n    n = len(variables)\n    quadratic_mean = sp.sqrt(sp.Sum(variables[i]**2 for i in range(n)) / n)\n    arithmetic_mean = sp.Sum(variables[i] for i in range(n)) / n\n    inequality = sp.Ge(quadratic+mean, arithmetic_mean)\n    if values is not None:\n        values_dict = {variables[i]: values[i] for i in range(n)}\n        inequality = inequality.subs(values_act)\n    return inequality",
            "def apply_am_gm_inequality(values):\n    \"\"\"\n    Function to apply Arithmetic Mean-Geometric Mean (AM-GM) Inequality and provide the minimum value.\n    Parameters:\n    values (list): A list of positive real numbers.\n    Returns:\n    min_value (float): The minimum value of the expression by applying AM-GM inequality. \n    Example:\n    >>> apply_am_gm_inequality([4, 1, 0.25])\n    1.0\n    \"\"\"\n    from math import sqrt, pow\n    from sympy import symbols, Eq, solve\n    # Define a list to store the utilizing symbols\n    symbols_list = [symbols('x' + str(i)) for i in range(len(values))]\n    \n    # Calculate the arithmetic mean\n    ar_mean = sum(values)/len(values)\n    \n    # Define the product value holder\n    prod_value = 1\n    # Calculate the geometric mean\n    for value in values:\n         prod_value *= value\n    geo_mean = pow(prod_value, 1/len(values))\n    \n    # Introduce AM-GM inequality\n    am_gm_inequality = Eq(ar_mean, geo_mean)\n    \n    # Solve for the equality\n    min_value = solve(am_gm_inequality, symbols('x0'))[0]\n    return min_value",
            "def apply_qm_am_inequality(values):\n    \"\"\"\n    Function to apply Quadratic Mean-Arithmetic Mean (QM-AM) Inequality and provide the maximum value.\n    Parameters:\n    values (list): A list of positive real numbers.\n    Returns:\n    max_value (float): The maximum value of the expression by applying QM-AM inequality. \n    Example:\n    >>> apply_qm_am_inequality([1, 2, 3, 4])\n    2.8284271247461903\n    \"\"\"\n    from math import sqrt, pow\n    from sympy import symbols, Eq, solve\n    # Define a list to store the utilizing symbols\n    symbols_list = [symbols('x' + str(i)) for i in range(len(values))]\n    \n    # Calculate the arithmetic mean\n    ar_mean = sum(values)/len(values)\n    \n    # Calculate the quadratic mean\n    quad_mean = sqrt(sum([value*value for value in values])/len(values))\n    \n    # Introduce QM-AM inequality\n    qm_am_inequality = Eq(quad_mean, ar_mean)\n    \n    # Solve for the equality\n    max_value = solve(qm_am_inequality, symbols('x0'))[0]\n    return max_value"
        ],
        [
            "def apply_cauchy_schwarz_inequality(a, b, var):\n    \"\"\"\n    Apply the Cauchy-Schwarz inequality to an expression to find the bounds.\n    \n    Parameters:\n        a (list of sp.Expr): Coefficients on the left side of the inequality.\n        b (list of sp.Expr): Coefficients on the right side of the inequality.\n        var (sp.Symbol): The main variable involved in the inequality expressions.\n    \n    Returns:\n        sp.Expr: The derived inequality expression using Cauchy-Schwarz.\n    \n    Examples:\n        >>> x = sp.symbols('x')\n        >>> a = [1, x]\n        >>> b = [x, 1]\n        >>> apply_cauchy_schwarz_inequality(a, b, x)\n        x**2 + 1 <= (x**2 + 1)**2  # Representing the inequality (1*x + x*1)^2 <= (1^2 + x^2)*(x^2 + 1^2)\n    \"\"\"\n    sum_sq_a = sum(i**2 for i in a)\n    sum_sq_b = sum(i**2 for i in b)\n    cross_prod = sum(a[i]*b[i] for i in range(len(a)))\n    \n    inequality = cross_prod**2 <= sum_sq_a * sum_sq_b\n    return inequality",
            "def apply_cauchy_schwarz_inequality(a, b):\n    \"\"\"\n    Applies the Cauchy-Schwarz inequality to determine bounds on the sum or product of two lists of numbers.\n    Parameters:\n        a (list of numbers): The first list of numbers.\n        b (list of numbers): The second list of numbers.\n    Returns:\n        dict: A dictionary with maximum and minimum bounds {'maximum': float or None, 'minimum': float or None}\n    Example:\n        >>> apply_cauchy_schwarz_inequality([1, 2, 3], [4, 5, 6])\n        {'maximum': 56.0, 'minimum': 0}\n    \"\"\"\n    import sympy as sp\n    \n    # Validate input sizes\n    if len(a) != len(b):\n        return None\n    sum_a_squared = sum(x**2 for x in a)\n    sum_b_squared = sum(x**2 for x in b)\n    sum_ab = sum(x*y for x, y in zip(a, b))\n    \n    maximum = sum_ab**2\n    minimum = sum_a_squared * sum_b_squared\n    return {'maximum': maximum, 'minimum': minimum}"
        ],
        [
            "def complete_square_optimize(function_expr, variable_expr):\n    \"\"\"\n    Transform a quadratic function into its vertex form to easily find the maximum\n    or minimum value by completing the square.\n    \n    Parameters:\n    - function_expr (str): A string expression representing the function.\n    - variable_expr (str): The variable in the function expression.\n    Returns:\n    - tuple: (vertex form of the function, vertex point, nature of vertex)\n    \n    Examples:\n    >>> complete_square_optimize(\"x**2 - 6*x + 5\", \"x\")\n    ('(x - 3)**2 - 4', (3, -4), 'minimum')\n    \"\"\"\n    x = sp.symbols(variable_expr)\n    f = sp.sympify(function_expr)\n    \n    # Complete the square\n    a, b, _ = sp.Poly(f, x).all_coeffs()\n    vertex_x = -b / (2*a)\n    vertex_y = f.subs(x, vertex_x)\n    vertex_form = f - (f.subs(x, vertex_x) + (x - vertex_x)**2)\n    \n    min_or_max = \"minimum\" if a > 0 else \"maximum\"\n    \n    return str(vertex_form), (vertex_x, vertex_y), min_or_max"
        ],
        [
            "def find_equality_conditions(values, inequality_type):\n    \"\"\"\n    Function to find conditions for equality in AM-GM and QM-AM inequality.\n    Parameters:\n    values (list): A list of positive real numbers.\n    inequality_type (str): A string specifying the type of inequality. Possible values: 'AM-GM', 'QM-AM'.\n    Returns:\n    equality_conditions (list): The conditions for equality in the specified inequality. \n    Example:\n    >>> find_equality_conditions([1, 2, 3, 4], 'QM-AM')\n    ['x0 = x1', 'x1 = x2', 'x2 = x3', 'x3 = x0']\n    \"\"\"\n    from sympy import symbols\n    # Define a list to store the utilizing symbols and their associated equality conditions\n    symbols_list = [symbols('x' + str(i)) for i in range(len(values))]\n    equality_conditions = [str(symbols_list[i]) + ' = ' + str(symbols_list[(i + 1) % len(values)]) for i in range(len(values))]\n    # Conditions for equality in AM-GM or QM-AM inequality is when all variables are equal\n    return equality_conditions"
        ],
        [
            "def AM_GM_Inequality_Tool(numbers):\n    \"\"\"\n    Apply the Arithmetic Mean-Geometric Mean (AM-GM) Inequality to compute the arithmetic and geometric means,\n    establish bounds, and check for equality condition in the provided list of numbers.\n    Parameters:\n    -----------\n    numbers : array-like\n        A list or array of non-negative real numbers.\n    Returns:\n    --------\n    result : dict\n        Dictionary containing:\n        - 'arithmetic_mean': Arithmetic Mean of the numbers.\n        - 'geometric_mean': Geometric Mean of the numbers.\n        - 'am_gm_equality': Boolean indicating if the equality condition holds (True if all numbers are equal).\n    Example:\n    --------\n    >>> AM_GM_Inequality_Tool([3,3,3])\n    {'arithmetic_mean': 3.0, 'geometric_mean': 3.0, 'am_gm_equality': True}\n    \"\"\"\n    numbers = np.array(numbers)\n    if np.any(numbers < 0):\n        raise ValueError(\"All input numbers must be non-negative.\")\n    arithmetic_mean = np.mean(numbers)\n    geometric_mean = np.prod(numbers)**(1/len(numbers))\n    am_gm_equality = np.all(np.isclose(numbers, arithmetic_mean))\n    return {\n        'arithmetic_mean': arithmetic_mean,\n        'geometric_mean': geometric_mean,\n        'am_gm_equality': am_gm_equality\n    }",
            "def QM_AM_Inequality_Tool(numbers):\n    \"\"\"\n    Apply the Quadratic Mean-Arithmetic Mean (QM-AM) Inequality to compute the quadratic mean and arithmetic mean,\n    and analyze if the equality condition holds.\n    Parameters:\n    -----------\n    numbers : array-like\n        A list or array of real numbers.\n    Returns:\n    --------\n    result : dict\n        Dictionary containing:\n        - 'quadratic_mean': Quadratic Mean of the numbers.\n        - 'arithmetic_mean': Arithmetic Mean of the numbers.\n        - 'qm_am_equality': Boolean indicating if the equality condition holds (True if all numbers are equal).\n    Example:\n    --------\n    >>> QM_AM_Inequality_Tool([4,4,4,4])\n    {'quadratic_mean': 4.0, 'arithmetic_mean': 4.0, 'qm_am_equality': True}\n    \"\"\"\n    numbers = np.array(numbers)\n    \n    arithmetic_mean = np.mean(numbers)\n    quadratic_mean = np.sqrt(np.mean(numbers**2))\n    qm_am_equality = np.all(np.isclose(numbers, arithmetic_mean))\n    return {\n        'quadratic_mean': quadratic_mean,\n        'arithmetic_mean': arithmetic_mean,\n        'qm_am_equality': qm_am_equality\n    }"
        ]
    ],
    "Infinite Series": [
        [
            "def partial_fraction_decomposition(expression, variable_str):\n    \"\"\"\n    Decomposes a rational function into partial fractions.\n    \n    Parameters:\n      - expression (str or sympy expression): The rational function as a string or a Sympy expression.\n      - variable_str (str): The variable name used in the rational function.\n    \n    Returns:\n      - Sympy expression: The decomposed expression in terms of partial fractions.\n    \n    Examples:\n      - partial_fraction_decomposition('1/(x**2 + 3*x + 2)', 'x') -> \"1/(x + 1) - 1/(x + 2)\"\n    \"\"\"\n    variable = symbols(variable_str)\n    rational_expr = sympify(expression)\n    return apart(rational_expr, variable)",
            "def decompose_to_partial_fractions(expression):\n    \"\"\"\n    Decomposes a rational function into partial fractions.\n    \n    Parameters:\n    - expression (sympy expression): The rational function to decompose.\n    \n    Returns:\n    - sympy expression: The expression decomposed into partial fractions.\n    \n    Examples:\n    >>> x = symbols('x')\n    >>> decompose_to_partial_fractions(1/(x**2 + 3*x + 2))\n    -1/(x + 2) + 1/(x + 1)\n    \"\"\"\n    return apart(expression)"
        ],
        [
            "def infinite_series_sum(expression, variable_str, start=1):\n    \"\"\"\n    Calculates the sum of an infinite series given its general term.\n    Parameters:\n      - expression (str or sympy expression): A symbolic expression representing the general term of the series. Should be a string or a Sympy expression.\n      - variable_str (str): The variable name as a string used in the expression.\n      - start (int): The starting index of the summation (default 1).\n    Returns:\n      - A Sympy expression of the summed series or None if the series does not converge.\n    Examples:\n      - infinite_series_sum('1/x**2', 'x') -> π²/6 (result of Σ (1/x²) from x=1 to ∞)\n      - infinite_series_sum('x/(2**x)', 'x') -> 2 (result of Σ (x/2^x) from x=1 to ∞)\n    \"\"\"\n    variable = symbols(variable_str)\n    series_expr = sympify(expression)\n    series = Sum(series_expr, (variable, start, oo))\n    return series.doit()",
            "def check_series_convergence(expression, variable_str, start=1):\n    \"\"\"\n    Determines if an infinite series converges or diverges.\n    Parameters:\n      - expression (str or sympy expression): The general term of the series as a string or a Sympy expression.\n      - variable_str (str): The variable name used in the expression.\n      - start (int): The index at which to start the summation.\n    Returns:\n      - string: \"converges\" if the series converges, \"diverges\" if it diverges, and \"unknown\" if convergence cannot be determined.\n    Examples:\n      - check_series_convergence('1/x**2', 'x') -> \"converges\"\n      - check_series_convergence('1/x', 'x') -> \"diverges\"\n    \"\"\"\n    variable = symbols(variable_str)\n    series_expr = sympify(expression)\n    series = Sum(series_expr, (variable, start, oo))\n    result = series.is_convergent()\n    if result is None:\n        return \"unknown\"\n    elif result:\n        return \"converges\"\n    else:\n        return \"diverges\""
        ],
        [
            "def sum_geometric_series(a, r, n=oo):\n    \"\"\"\n    Summarizes an infinite geometric series given the first term, common ratio, and number of terms (optional).\n    \n    Parameters:\n        a (sympy expression): The first term of the geometric series.\n        r (sympy expression): The common ratio of the geometric series.\n        n (int or sympy expression, optional): The number of terms to sum, defaults to infinity for infinite series.\n    \n    Returns:\n        sympy expression: The sum of the geometric series.\n    \n    Examples:\n        >>> from sympy import symbols\n        >>> a, r = symbols('a r')\n        >>> sum_geometric_series(a, r)\n        a/(1 - r)\n    \"\"\"\n    if abs(r) < 1 or (isinstance(n, S.Infinity) and abs(simplify(r)) < 1):\n        return a / (1 - r)\n    else:\n        return Sum(a * r**k, (k, 0, n-1)).doit()",
            "def geometric_series_sum(a, r, n=None):\n    \"\"\"\n    Calculates the sum of a geometric series.\n    \n    Parameters:\n    - a (float or sympy expression): the first term of the series.\n    - r (float or sympy expression): the common ratio of the series.\n    - n (int, optional): the number of terms in the series; if not provided, assumes an infinite series.\n    \n    Returns:\n    - sympy expression or float: the sum of the series.\n    \n    Examples:\n    >>> geometric_series_sum(1, 1/2, 3)\n    1.75\n    >>> geometric_series_sum(1, 1/2)  # infinite series\n    2.0\n    \"\"\"\n    x = symbols('x')\n    if n is None:\n        if abs(r) < 1:\n            return simplify(a / (1 - r))\n        else:\n            raise ValueError(\"Infinite series does not converge unless |r| < 1\")\n    else:\n        return a * (1 - r**n) / (1 - r)"
        ],
        [
            "def factor_polynomial_in_series(polynomial_expr, var):\n    \"\"\"\n    Factors a polynomial in a series expression.\n    \n    Parameters:\n        polynomial_expr (sympy expression): The polynomial expression to be factored.\n        var (sympy Symbol): The primary variable in the polynomial expression.\n    Returns:\n        sympy expression: The factored polynomial expression.\n    \n    Examples:\n        >>> from sympy import symbols\n        >>> x = symbols('x')\n        >>> factor_polynomial_in_series(x**2 - 1, x)\n        (x - 1)*(x + 1)\n    \"\"\"\n    return simplify(polynomial_expr).factor()"
        ],
        [
            "def sum_telescoping_series(term, var, start, end):\n    \"\"\"\n    Evaluates the sum of a telescoping series from the start to the end term.\n    \n    Parameters:\n        term (function): A function that represents the term of the series which depends on 'var'.\n        var (sympy Symbol): The variable in the term function.\n        start (int): The starting index of the sum.\n        end (int or symbol): The ending index of the sum, can be sympy.oo for infinity.\n    \n    Returns:\n        sympy expression: The evaluated sum of the series.\n    \n    Examples:\n        >>> from sympy import symbols, Function\n        >>> n = symbols('n')\n        >>> f = Function('f')\n        >>> sum_telescoping_series(f(n) - f(n+1), n, 1, oo)\n        -f(oo) + f(1)\n    \"\"\"\n    if end == oo:\n        return simplify(term.subs(var, start) - term.subs(var, oo))\n    else:\n        return sum(simplify(term.subs(var, k)) for k in range(start, end + 1))"
        ],
        [
            "def simplify_series_via_partial_fraction(series_expr, var):\n    \"\"\"\n    Simplifies a series by applying partial fraction decomposition.\n    \n    Parameters:\n        series_expr (sympy expression): The series expression to be decomposed.\n        var (sympy Symbol): The primary variable in the series expression.\n    \n    Returns:\n        sympy expression: The simplified series expression using partial fraction decomposition.\n    \n    Examples:\n        >>> from sympy import symbols\n        >>> x = symbols('x')\n        >>> simplify_series_via_partial_fraction(1/(x*(x+1)), x)\n        1/x - 1/(x + 1)\n    \"\"\"\n    return apart(series_expr, var)"
        ]
    ]
}