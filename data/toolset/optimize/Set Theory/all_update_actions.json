{"Overlapping Sets": [{"Iter": 0, "delete": [{"tool": "def set_difference(set_a, set_b):\n    \n    return set_a - set_b", "subfield": "Overlapping Sets", "tool_name": "set_difference", "tool_type": "function", "description": "Compute the difference of two sets (elements in set_a not in set_b).", "docstring": "Compute the difference of two sets (elements in set_a not in set_b).\n    \n    Parameters:\n    - set_a (set): The first set.\n    - set_b (set): The second set.\n    \n    Returns:\n    set: The set of elements that are in set_a but not in set_b.\n    \n    Examples:\n    >>> set_difference({1, 2, 3}, {3, 4, 5})\n    {1, 2}", "Freq": 0, "TSR": 0}, {"tool": "def set_union(set_a, set_b):\n    \n    return set_a | set_b", "subfield": "Overlapping Sets", "tool_name": "set_union", "tool_type": "function", "description": "Computes the union of two sets.", "docstring": "Computes the union of two sets.\n    \n    Parameters:\n    - set_a (set): First set.\n    - set_b (set): Second set.\n    \n    Returns:\n    - set: Union of set_a and set_b.\n    \n    Examples:\n    >>> set_union({1, 2, 3}, {2, 3, 4})\n    {1, 2, 3, 4}", "Freq": 0, "TSR": 0}, {"tool": "def set_operations(set_list, operation=\"union\"):\n    \n    import functools\n    result_set = set_list[0]  # Initialize with the first set in the list.\n    # Apply the appropriate set operation.\n    if operation == \"union\":\n        result_set = functools.reduce(lambda a, b: a.union(b), set_list[1:], result_set)\n    elif operation == \"intersection\":\n        result_set = functools.reduce(lambda a, b: a.intersection(b), set_list[1:], result_set)\n    elif operation == \"difference\":\n        result_set = functools.reduce(lambda a, b: a.difference(b), set_list[1:], result_set)\n    elif operation == \"symmetric_difference\":\n        result_set = functools.reduce(lambda a, b: a.symmetric_difference(b), set_list[1:], result_set)\n        \n    return result_set", "subfield": "Overlapping Sets", "tool_name": "set_operations", "tool_type": "function", "description": "Conducts specified operations (union, intersection, difference, symmetric_difference)\n    on a list of sets.", "docstring": "Conducts specified operations (union, intersection, difference, symmetric_difference)\n    on a list of sets.\n    \n    Parameters:\n    - set_list (list of set): List of sets on which the operation needs to be performed.\n    - operation (str): Specifies the operation to perform. Options include \"union\",\n      \"intersection\", \"difference\", \"symmetric_difference\".\n    \n    Returns:\n    - set: Resulting set after the specified operation.\n    \n    Examples:\n    >>> set_operations([set([1,2,3]), set([3,4])], operation=\"union\")\n    {1, 2, 3, 4}\n    >>> set_operations([set([1,2,3]), set([2,3,4])], operation=\"intersection\")\n    {2, 3}\n    >>> set_operations([set([1,2,3]), set([3,4])], operation=\"difference\")\n    {1, 2}\n    >>> set_operations([set([1,2,3]), set([3,4])], operation=\"symmetric_difference\")\n    {1, 2, 4}", "Freq": 0, "TSR": 0}], "add": [{"tool": "def set_symmetric_difference(set_a, set_b):\n    \n    return set_a ^ set_b", "subfield": "Overlapping Sets", "tool_name": "set_symmetric_difference", "tool_type": "function", "description": "Calculate the elements unique to each set when subsets overlap.\n    \n    Args:\n    set_a (set): The first set.\n    set_b (set): The second set.\n    \n    Returns:\n    set: The symmetric difference between set_a and set_b.", "docstring": "Calculate the elements unique to each set when subsets overlap.\n    \n    Args:\n    set_a (set): The first set.\n    set_b (set): The second set.\n    \n    Returns:\n    set: The symmetric difference between set_a and set_b.", "Freq": 0, "TSR": 0}], "update": [[{"tool": "def set_intersection(set_a, set_b):\n    \n    return set_a & set_b", "subfield": "Overlapping Sets", "tool_name": "set_intersection", "tool_type": "function", "description": "Computes the intersection of two sets.", "docstring": "Computes the intersection of two sets.\n    \n    Parameters:\n    - set_a (set): First set.\n    - set_b (set): Second set.\n    \n    Returns:\n    - set: Intersection of set_a and set_b.\n    \n    Examples:\n    >>> set_intersection({1, 2, 3}, {2, 3, 4})\n    {2, 3}", "Freq": 2, "TSR": 0}, {"tool": "def set_intersection(num_elements_a, num_elements_b):\n    \n    set_a = set(range(1, num_elements_a + 1))\n    set_b = set(range(1, num_elements_b + 1))\n    \n    return set_a & set_b", "subfield": "Overlapping Sets", "tool_name": "set_intersection", "tool_type": "function", "description": "Computes the intersection of two sets.", "docstring": "Computes the intersection of two sets.\n    Parameters:\n    - num_elements_a (int): Number of elements in the first set.\n    - num_elements_b (int): Number of elements in the second set.\n    Returns:\n    - set: Intersection of the two sets.", "Freq": 1, "TSR": 1, "experience_pool": "- Problem: The sets are not created correctly in the wrong tool callings.\n- Solution: Modify the `set_intersection` function to accept the number of elements in each set as arguments and create the sets internally."}]]}, {"Iter": 1, "delete": [{"tool": "def set_union(set_a, set_b):\n    \n    return set_a | set_b", "subfield": "Overlapping Sets", "tool_name": "set_union", "tool_type": "function", "description": "Computes the union of two sets.", "docstring": "Computes the union of two sets.\n    \n    Parameters:\n    - set_a (set): First set.\n    - set_b (set): Second set.\n    \n    Returns:\n    - set: Union of set_a and set_b.\n    \n    Examples:\n    >>> set_union({1, 2, 3}, {2, 3, 4})\n    {1, 2, 3, 4}", "Freq": 0, "TSR": 0}, {"tool": "def set_operations(set_list, operation=\"union\"):\n    \n    import functools\n    result_set = set_list[0]  # Initialize with the first set in the list.\n    # Apply the appropriate set operation.\n    if operation == \"union\":\n        result_set = functools.reduce(lambda a, b: a.union(b), set_list[1:], result_set)\n    elif operation == \"intersection\":\n        result_set = functools.reduce(lambda a, b: a.intersection(b), set_list[1:], result_set)\n    elif operation == \"difference\":\n        result_set = functools.reduce(lambda a, b: a.difference(b), set_list[1:], result_set)\n    elif operation == \"symmetric_difference\":\n        result_set = functools.reduce(lambda a, b: a.symmetric_difference(b), set_list[1:], result_set)\n        \n    return result_set", "subfield": "Overlapping Sets", "tool_name": "set_operations", "tool_type": "function", "description": "Conducts specified operations (union, intersection, difference, symmetric_difference)\n    on a list of sets.", "docstring": "Conducts specified operations (union, intersection, difference, symmetric_difference)\n    on a list of sets.\n    \n    Parameters:\n    - set_list (list of set): List of sets on which the operation needs to be performed.\n    - operation (str): Specifies the operation to perform. Options include \"union\",\n      \"intersection\", \"difference\", \"symmetric_difference\".\n    \n    Returns:\n    - set: Resulting set after the specified operation.\n    \n    Examples:\n    >>> set_operations([set([1,2,3]), set([3,4])], operation=\"union\")\n    {1, 2, 3, 4}\n    >>> set_operations([set([1,2,3]), set([2,3,4])], operation=\"intersection\")\n    {2, 3}\n    >>> set_operations([set([1,2,3]), set([3,4])], operation=\"difference\")\n    {1, 2}\n    >>> set_operations([set([1,2,3]), set([3,4])], operation=\"symmetric_difference\")\n    {1, 2, 4}", "Freq": 0, "TSR": 0}, {"tool": "def union_intersection_sizes(*sets):\n    \n    from functools import reduce\n    if not sets:\n        return (0, 0)\n    \n    # Set up the first set for intersection starting comparison\n    set_union = sets[0].copy()\n    set_intersection = sets[0].copy()\n    \n    # Apply union and intersection across all sets provided\n    for s in sets[1:]:\n        set_union.update(s)\n        set_intersection.intersection_update(s)\n    return (len(set_union), len(set_intersection))", "subfield": "Overlapping Sets", "tool_name": "union_intersection_sizes", "tool_type": "function", "description": "Calculate the total sizes of the union and intersection of multiple sets.", "docstring": "Calculate the total sizes of the union and intersection of multiple sets.\n    \n    Parameters:\n    *sets (list of set): Variable number of sets for which union and intersection sizes will be calculated.\n    Returns:\n    tuple: A tuple containing two integers:\n           - The size of the union of all provided sets.\n           - The size of the intersection of all provided sets. For more than two sets, it calculates the size of the n-way intersection.\n    Examples:\n    >>> set_A = {1, 2, 3, 4}\n    >>> set_B = {3, 4, 5, 6}\n    >>> set_C = {1, 4, 7, 8}\n    >>> union_intersection_sizes(set_A, set_B, set_C)\n    (8, 1)  # Union has elements from 1 to 8 except 2,5,6,7 and intersection has {4}\n    Notes:\n    - If no sets are provided, the function returns (0, 0).\n    - If a single set is provided, it returns the size of that set for both the union and intersection.", "Freq": 0, "TSR": 0}, {"tool": "def set_complement(universal_set, subset):\n    \n    return universal_set - subset", "subfield": "Overlapping Sets", "tool_name": "set_complement", "tool_type": "function", "description": "Computes the complement of a subset within a given universal set.", "docstring": "Computes the complement of a subset within a given universal set.\n    \n    Parameters:\n    - universal_set (set): The universal set.\n    - subset (set): The subset for which the complement is found.\n    \n    Returns:\n    - set: Complement of the subset within the universal set.\n    \n    Examples:\n    >>> set_complement({1, 2, 3, 4, 5}, {2, 3})\n    {1, 4, 5}", "Freq": 0, "TSR": 0}, {"tool": "def inclusion_exclusion(*args):\n    \n    total_sum = sum(x[1] for x in args if len(x) == 2)\n    intersection_sum = sum(x[1] for x in args if len(x) == 3)\n    return total_sum - intersection_sum", "subfield": "Overlapping Sets", "tool_name": "inclusion_exclusion", "tool_type": "function", "description": "Implementation of the inclusion-exclusion principle to find the\n    count of elements in the union of multiple sets.", "docstring": "Implementation of the inclusion-exclusion principle to find the\n    count of elements in the union of multiple sets.\n    \n    Parameters:\n    - args (list of tuples): Each tuple contains a set and its cardinality. For intersections,\n      tuples should be provided in the format (set, cardinality, intersecting_with).\n    \n    Returns:\n    int: Count of unique elements in the union of the given sets.\n    \n    Example:\n    >>> A = {1, 2, 3}\n    >>> B = {3, 4, 5}\n    >>> A_int_B = {3}\n    >>> inclusion_exclusion((A, 3), (B, 3), (A_int_B, 1))\n    5  # Since |A ∪ B| = |A| + |B| - |A ∩ B|\n    Note: This function assumes simplifications where the user manually provides counts for intersections.", "Freq": 0, "TSR": 0}], "add": [{"tool": "def set_symmetric_difference(set_a, set_b):\n    \n    return set_a ^ set_b", "subfield": "Overlapping Sets", "tool_name": "set_symmetric_difference", "tool_type": "function", "description": "Calculate the elements unique to each set when subsets overlap.\n    \n    Args:\n    set_a (set): The first set.\n    set_b (set): The second set.\n    \n    Returns:\n    set: The symmetric difference between set_a and set_b.", "docstring": "Calculate the elements unique to each set when subsets overlap.\n    \n    Args:\n    set_a (set): The first set.\n    set_b (set): The second set.\n    \n    Returns:\n    set: The symmetric difference between set_a and set_b.", "Freq": 0, "TSR": 0}], "update": [[{"tool": "def set_intersection(set_a, set_b):\n    \n    return set_a & set_b", "subfield": "Overlapping Sets", "tool_name": "set_intersection", "tool_type": "function", "description": "Computes the intersection of two sets.", "docstring": "Computes the intersection of two sets.\n    \n    Parameters:\n    - set_a (set): First set.\n    - set_b (set): Second set.\n    \n    Returns:\n    - set: Intersection of set_a and set_b.\n    \n    Examples:\n    >>> set_intersection({1, 2, 3}, {2, 3, 4})\n    {2, 3}", "Freq": 2, "TSR": 0}, {"tool": "def set_intersection(num_slices, num_property_a, num_property_b):\n    \n    return set(range(1, min(num_property_a, num_property_b) + 1))", "subfield": "Overlapping Sets", "tool_name": "set_intersection", "tool_type": "function", "description": "Computes the intersection of two sets.", "docstring": "Computes the intersection of two sets.\n    Parameters:\n    - num_slices (int): Total number of slices.\n    - num_property_a (int): Number of slices with property A.\n    - num_property_b (int): Number of slices with property B.\n    Returns:\n    - set: Intersection of slices with property A and slices with property B.", "Freq": 1, "TSR": 1, "experience_pool": "Experience 1:\nProblem: An 18-slice pizza was made with only pepperoni and mushroom toppings, and every slice has at least one topping. Exactly ten slices have pepperoni, and exactly ten slices have mushrooms. How many slices have both pepperoni and mushrooms?\nAnswer: 2\n\nExperience 2:\nProblem: Twelve students in Mrs. Stephenson's class have brown eyes. Twenty students in the class have a lunch box. Of Mrs. Stephenson's 30 students, what is the least possible number of students who have brown eyes and a lunch box?\nAnswer: 2"}]]}, {"Iter": 2, "delete": [{"tool": "def set_difference(set_a, set_b):\n    \n    return set_a - set_b", "subfield": "Overlapping Sets", "tool_name": "set_difference", "tool_type": "function", "description": "Compute the difference of two sets (elements in set_a not in set_b).", "docstring": "Compute the difference of two sets (elements in set_a not in set_b).\n    \n    Parameters:\n    - set_a (set): The first set.\n    - set_b (set): The second set.\n    \n    Returns:\n    set: The set of elements that are in set_a but not in set_b.\n    \n    Examples:\n    >>> set_difference({1, 2, 3}, {3, 4, 5})\n    {1, 2}", "Freq": 0, "TSR": 0}, {"tool": "def set_complement(universal_set, subset):\n    \n    return universal_set - subset", "subfield": "Overlapping Sets", "tool_name": "set_complement", "tool_type": "function", "description": "Computes the complement of a subset within a given universal set.", "docstring": "Computes the complement of a subset within a given universal set.\n    \n    Parameters:\n    - universal_set (set): The universal set.\n    - subset (set): The subset for which the complement is found.\n    \n    Returns:\n    - set: Complement of the subset within the universal set.\n    \n    Examples:\n    >>> set_complement({1, 2, 3, 4, 5}, {2, 3})\n    {1, 4, 5}", "Freq": 0, "TSR": 0}, {"tool": "def create_set(elements):\n    \n    return set(elements)", "subfield": "Overlapping Sets", "tool_name": "create_set", "tool_type": "function", "description": "Create a set from a list of elements or a range.", "docstring": "Create a set from a list of elements or a range.\n    \n    Parameters:\n    - elements (iterable): An iterable (list, tuple, range) of elements to be converted into a set.\n    \n    Returns:\n    set: A set containing the unique elements from the input iterable.\n    \n    Examples:\n    >>> create_set([1, 2, 3, 2, 1])\n    {1, 2, 3}\n    >>> create_set(range(1, 6))\n    {1, 2, 3, 4, 5}", "Freq": 0, "TSR": 0}, {"tool": "def inclusion_exclusion(*args):\n    \n    total_sum = sum(x[1] for x in args if len(x) == 2)\n    intersection_sum = sum(x[1] for x in args if len(x) == 3)\n    return total_sum - intersection_sum", "subfield": "Overlapping Sets", "tool_name": "inclusion_exclusion", "tool_type": "function", "description": "Implementation of the inclusion-exclusion principle to find the\n    count of elements in the union of multiple sets.", "docstring": "Implementation of the inclusion-exclusion principle to find the\n    count of elements in the union of multiple sets.\n    \n    Parameters:\n    - args (list of tuples): Each tuple contains a set and its cardinality. For intersections,\n      tuples should be provided in the format (set, cardinality, intersecting_with).\n    \n    Returns:\n    int: Count of unique elements in the union of the given sets.\n    \n    Example:\n    >>> A = {1, 2, 3}\n    >>> B = {3, 4, 5}\n    >>> A_int_B = {3}\n    >>> inclusion_exclusion((A, 3), (B, 3), (A_int_B, 1))\n    5  # Since |A ∪ B| = |A| + |B| - |A ∩ B|\n    Note: This function assumes simplifications where the user manually provides counts for intersections.", "Freq": 0, "TSR": 0}, {"tool": "def create_set_from_range(start, end):\n    \n    return set(range(start, end + 1))", "subfield": "Overlapping Sets", "tool_name": "create_set_from_range", "tool_type": "function", "description": "Creates a set of integers from a specified range.", "docstring": "Creates a set of integers from a specified range.\n    \n    Parameters:\n    - start (int): The starting point of the range (inclusive).\n    - end (int): The ending point of the range (inclusive).\n    \n    Returns:\n    - set: A set containing integers from start to end.\n    \n    Examples:\n    >>> create_set_from_range(1, 5)\n    {1, 2, 3, 4, 5}", "Freq": 0, "TSR": 0}], "add": [{"tool": "def set_symmetric_difference(set_a, set_b):\n    \n    return set_a ^ set_b", "subfield": "Overlapping Sets", "tool_name": "set_symmetric_difference", "tool_type": "function", "description": "Computes the symmetric difference between two sets.\n    \n    Args:\n    set_a (set): The first set.\n    set_b (set): The second set.\n    \n    Returns:\n    set: The symmetric difference between set_a and set_b.", "docstring": "Computes the symmetric difference between two sets.\n    \n    Args:\n    set_a (set): The first set.\n    set_b (set): The second set.\n    \n    Returns:\n    set: The symmetric difference between set_a and set_b.", "Freq": 0, "TSR": 0}], "update": []}, {"Iter": 3, "delete": [{"tool": "def set_union(set_a, set_b):\n    \n    return set_a | set_b", "subfield": "Overlapping Sets", "tool_name": "set_union", "tool_type": "function", "description": "Computes the union of two sets.", "docstring": "Computes the union of two sets.\n    \n    Parameters:\n    - set_a (set): First set.\n    - set_b (set): Second set.\n    \n    Returns:\n    - set: Union of set_a and set_b.\n    \n    Examples:\n    >>> set_union({1, 2, 3}, {2, 3, 4})\n    {1, 2, 3, 4}", "Freq": 0, "TSR": 0}, {"tool": "def set_operations(set_list, operation=\"union\"):\n    \n    import functools\n    result_set = set_list[0]  # Initialize with the first set in the list.\n    # Apply the appropriate set operation.\n    if operation == \"union\":\n        result_set = functools.reduce(lambda a, b: a.union(b), set_list[1:], result_set)\n    elif operation == \"intersection\":\n        result_set = functools.reduce(lambda a, b: a.intersection(b), set_list[1:], result_set)\n    elif operation == \"difference\":\n        result_set = functools.reduce(lambda a, b: a.difference(b), set_list[1:], result_set)\n    elif operation == \"symmetric_difference\":\n        result_set = functools.reduce(lambda a, b: a.symmetric_difference(b), set_list[1:], result_set)\n        \n    return result_set", "subfield": "Overlapping Sets", "tool_name": "set_operations", "tool_type": "function", "description": "Conducts specified operations (union, intersection, difference, symmetric_difference)\n    on a list of sets.", "docstring": "Conducts specified operations (union, intersection, difference, symmetric_difference)\n    on a list of sets.\n    \n    Parameters:\n    - set_list (list of set): List of sets on which the operation needs to be performed.\n    - operation (str): Specifies the operation to perform. Options include \"union\",\n      \"intersection\", \"difference\", \"symmetric_difference\".\n    \n    Returns:\n    - set: Resulting set after the specified operation.\n    \n    Examples:\n    >>> set_operations([set([1,2,3]), set([3,4])], operation=\"union\")\n    {1, 2, 3, 4}\n    >>> set_operations([set([1,2,3]), set([2,3,4])], operation=\"intersection\")\n    {2, 3}\n    >>> set_operations([set([1,2,3]), set([3,4])], operation=\"difference\")\n    {1, 2}\n    >>> set_operations([set([1,2,3]), set([3,4])], operation=\"symmetric_difference\")\n    {1, 2, 4}", "Freq": 0, "TSR": 0}, {"tool": "def union_intersection_sizes(*sets):\n    \n    from functools import reduce\n    if not sets:\n        return (0, 0)\n    \n    # Set up the first set for intersection starting comparison\n    set_union = sets[0].copy()\n    set_intersection = sets[0].copy()\n    \n    # Apply union and intersection across all sets provided\n    for s in sets[1:]:\n        set_union.update(s)\n        set_intersection.intersection_update(s)\n    return (len(set_union), len(set_intersection))", "subfield": "Overlapping Sets", "tool_name": "union_intersection_sizes", "tool_type": "function", "description": "Calculate the total sizes of the union and intersection of multiple sets.", "docstring": "Calculate the total sizes of the union and intersection of multiple sets.\n    \n    Parameters:\n    *sets (list of set): Variable number of sets for which union and intersection sizes will be calculated.\n    Returns:\n    tuple: A tuple containing two integers:\n           - The size of the union of all provided sets.\n           - The size of the intersection of all provided sets. For more than two sets, it calculates the size of the n-way intersection.\n    Examples:\n    >>> set_A = {1, 2, 3, 4}\n    >>> set_B = {3, 4, 5, 6}\n    >>> set_C = {1, 4, 7, 8}\n    >>> union_intersection_sizes(set_A, set_B, set_C)\n    (8, 1)  # Union has elements from 1 to 8 except 2,5,6,7 and intersection has {4}\n    Notes:\n    - If no sets are provided, the function returns (0, 0).\n    - If a single set is provided, it returns the size of that set for both the union and intersection.", "Freq": 0, "TSR": 0}, {"tool": "def set_complement(universal_set, subset):\n    \n    return universal_set - subset", "subfield": "Overlapping Sets", "tool_name": "set_complement", "tool_type": "function", "description": "Computes the complement of a subset within a given universal set.", "docstring": "Computes the complement of a subset within a given universal set.\n    \n    Parameters:\n    - universal_set (set): The universal set.\n    - subset (set): The subset for which the complement is found.\n    \n    Returns:\n    - set: Complement of the subset within the universal set.\n    \n    Examples:\n    >>> set_complement({1, 2, 3, 4, 5}, {2, 3})\n    {1, 4, 5}", "Freq": 0, "TSR": 0}, {"tool": "def inclusion_exclusion(*args):\n    \n    total_sum = sum(x[1] for x in args if len(x) == 2)\n    intersection_sum = sum(x[1] for x in args if len(x) == 3)\n    return total_sum - intersection_sum", "subfield": "Overlapping Sets", "tool_name": "inclusion_exclusion", "tool_type": "function", "description": "Implementation of the inclusion-exclusion principle to find the\n    count of elements in the union of multiple sets.", "docstring": "Implementation of the inclusion-exclusion principle to find the\n    count of elements in the union of multiple sets.\n    \n    Parameters:\n    - args (list of tuples): Each tuple contains a set and its cardinality. For intersections,\n      tuples should be provided in the format (set, cardinality, intersecting_with).\n    \n    Returns:\n    int: Count of unique elements in the union of the given sets.\n    \n    Example:\n    >>> A = {1, 2, 3}\n    >>> B = {3, 4, 5}\n    >>> A_int_B = {3}\n    >>> inclusion_exclusion((A, 3), (B, 3), (A_int_B, 1))\n    5  # Since |A ∪ B| = |A| + |B| - |A ∩ B|\n    Note: This function assumes simplifications where the user manually provides counts for intersections.", "Freq": 0, "TSR": 0}], "add": [{"tool": "def set_symmetric_difference(set_a, set_b):\n    \n    return set_a ^ set_b", "subfield": "Overlapping Sets", "tool_name": "set_symmetric_difference", "tool_type": "function", "description": "Compute the symmetric difference between two sets (elements that are in set_a or set_b, but not in both).\n    Args:\n    set_a (set): The first set.\n    set_b (set): The second set.\n    Returns:\n    set: The symmetric difference between set_a and set_b.", "docstring": "Compute the symmetric difference between two sets (elements that are in set_a or set_b, but not in both).\n    Args:\n    set_a (set): The first set.\n    set_b (set): The second set.\n    Returns:\n    set: The symmetric difference between set_a and set_b.", "Freq": 0, "TSR": 0}], "update": []}]}